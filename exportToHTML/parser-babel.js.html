<html>
<head>
<title>parser-babel.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
.s1 { color: #cc7832;}
.s2 { color: #6a8759;}
.s3 { color: #6897bb;}
.s4 { color: #4646f1;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
parser-babel.js</font>
</center></td></tr></table>
<pre><span class="s0">(</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">exports==</span><span class="s2">&quot;object&quot;</span><span class="s0">&amp;&amp;</span><span class="s1">typeof </span><span class="s0">module==</span><span class="s2">&quot;object&quot;</span><span class="s0">)module.exports=e();</span><span class="s1">else if</span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">define==</span><span class="s2">&quot;function&quot;</span><span class="s0">&amp;&amp;define.amd)define(e);</span><span class="s1">else</span><span class="s0">{</span><span class="s1">var </span><span class="s0">i=</span><span class="s1">typeof </span><span class="s0">globalThis&lt;</span><span class="s2">&quot;u&quot;</span><span class="s0">?globalThis:</span><span class="s1">typeof </span><span class="s0">global&lt;</span><span class="s2">&quot;u&quot;</span><span class="s0">?global:</span><span class="s1">typeof </span><span class="s0">self&lt;</span><span class="s2">&quot;u&quot;</span><span class="s0">?self:</span><span class="s1">this</span><span class="s0">||{};i.prettierPlugins=i.prettierPlugins||{},i.prettierPlugins.babel=e()}})(</span><span class="s1">function</span><span class="s0">(){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;</span><span class="s1">var </span><span class="s0">E=(l,h)=&gt;()=&gt;(h||l((h={exports:{}}).exports,h),h.exports);</span><span class="s1">var </span><span class="s0">re=E((xd,Zr)=&gt;{</span><span class="s1">var </span><span class="s0">Ct=</span><span class="s1">function</span><span class="s0">(l){</span><span class="s1">return </span><span class="s0">l&amp;&amp;l.Math==Math&amp;&amp;l};Zr.exports=Ct(</span><span class="s1">typeof </span><span class="s0">globalThis==</span><span class="s2">&quot;object&quot;</span><span class="s0">&amp;&amp;globalThis)||Ct(</span><span class="s1">typeof </span><span class="s0">window==</span><span class="s2">&quot;object&quot;</span><span class="s0">&amp;&amp;window)||Ct(</span><span class="s1">typeof </span><span class="s0">self==</span><span class="s2">&quot;object&quot;</span><span class="s0">&amp;&amp;self)||Ct(</span><span class="s1">typeof </span><span class="s0">global==</span><span class="s2">&quot;object&quot;</span><span class="s0">&amp;&amp;global)||</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return this</span><span class="s0">}()||Function(</span><span class="s2">&quot;return this&quot;</span><span class="s0">)()});</span><span class="s1">var </span><span class="s0">ie=E((gd,ei)=&gt;{ei.exports=</span><span class="s1">function</span><span class="s0">(l){</span><span class="s1">try</span><span class="s0">{</span><span class="s1">return</span><span class="s0">!!l()}</span><span class="s1">catch</span><span class="s0">{</span><span class="s1">return</span><span class="s0">!</span><span class="s3">0</span><span class="s0">}}});</span><span class="s1">var </span><span class="s0">ye=E((Pd,ti)=&gt;{</span><span class="s1">var </span><span class="s0">kh=ie();ti.exports=!kh(</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">Object.defineProperty({},</span><span class="s3">1</span><span class="s0">,{get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s3">7</span><span class="s0">}})[</span><span class="s3">1</span><span class="s0">]!=</span><span class="s3">7</span><span class="s0">})});</span><span class="s1">var </span><span class="s0">bt=E((Ad,si)=&gt;{</span><span class="s1">var </span><span class="s0">Dh=ie();si.exports=!Dh(</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">var </span><span class="s0">l=</span><span class="s1">function</span><span class="s0">(){}.bind();</span><span class="s1">return typeof </span><span class="s0">l!=</span><span class="s2">&quot;function&quot;</span><span class="s0">||l.hasOwnProperty(</span><span class="s2">&quot;prototype&quot;</span><span class="s0">)})});</span><span class="s1">var </span><span class="s0">wt=E((Td,ri)=&gt;{</span><span class="s1">var </span><span class="s0">Fh=bt(),St=Function.prototype.call;ri.exports=Fh?St.bind(St):</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">St.apply(St,arguments)}});</span><span class="s1">var </span><span class="s0">oi=E(ni=&gt;{</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;</span><span class="s1">var </span><span class="s0">ii={}.propertyIsEnumerable,ai=Object.getOwnPropertyDescriptor,Lh=ai&amp;&amp;!ii.call({</span><span class="s3">1</span><span class="s0">:</span><span class="s3">2</span><span class="s0">},</span><span class="s3">1</span><span class="s0">);ni.f=Lh?</span><span class="s1">function</span><span class="s0">(h){</span><span class="s1">var </span><span class="s0">p=ai(</span><span class="s1">this</span><span class="s0">,h);</span><span class="s1">return</span><span class="s0">!!p&amp;&amp;p.enumerable}:ii});</span><span class="s1">var </span><span class="s0">fs=E((Ed,li)=&gt;{li.exports=</span><span class="s1">function</span><span class="s0">(l,h){</span><span class="s1">return</span><span class="s0">{enumerable:!(l&amp;</span><span class="s3">1</span><span class="s0">),configurable:!(l&amp;</span><span class="s3">2</span><span class="s0">),writable:!(l&amp;</span><span class="s3">4</span><span class="s0">),value:h}}});</span><span class="s1">var </span><span class="s0">ae=E((Cd,ci)=&gt;{</span><span class="s1">var </span><span class="s0">hi=bt(),ui=Function.prototype,ds=ui.call,Oh=hi&amp;&amp;ui.bind.bind(ds,ds);ci.exports=hi?Oh:</span><span class="s1">function</span><span class="s0">(l){</span><span class="s1">return function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">ds.apply(l,arguments)}}});</span><span class="s1">var </span><span class="s0">Ye=E((bd,fi)=&gt;{</span><span class="s1">var </span><span class="s0">pi=ae(),Bh=pi({}.toString),Mh=pi(</span><span class="s2">&quot;&quot;</span><span class="s0">.slice);fi.exports=</span><span class="s1">function</span><span class="s0">(l){</span><span class="s1">return </span><span class="s0">Mh(Bh(l),</span><span class="s3">8</span><span class="s0">,-</span><span class="s3">1</span><span class="s0">)}});</span><span class="s1">var </span><span class="s0">mi=E((Sd,di)=&gt;{</span><span class="s1">var </span><span class="s0">_h=ae(),Rh=ie(),jh=Ye(),ms=Object,qh=_h(</span><span class="s2">&quot;&quot;</span><span class="s0">.split);di.exports=Rh(</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return</span><span class="s0">!ms(</span><span class="s2">&quot;z&quot;</span><span class="s0">).propertyIsEnumerable(</span><span class="s3">0</span><span class="s0">)})?</span><span class="s1">function</span><span class="s0">(l){</span><span class="s1">return </span><span class="s0">jh(l)==</span><span class="s2">&quot;String&quot;</span><span class="s0">?qh(l,</span><span class="s2">&quot;&quot;</span><span class="s0">):ms(l)}:ms});</span><span class="s1">var </span><span class="s0">ys=E((wd,yi)=&gt;{yi.exports=</span><span class="s1">function</span><span class="s0">(l){</span><span class="s1">return </span><span class="s0">l==</span><span class="s1">null</span><span class="s0">}});</span><span class="s1">var </span><span class="s0">xs=E((Id,xi)=&gt;{</span><span class="s1">var </span><span class="s0">Uh=ys(),$h=TypeError;xi.exports=</span><span class="s1">function</span><span class="s0">(l){</span><span class="s1">if</span><span class="s0">(Uh(l))</span><span class="s1">throw </span><span class="s0">$h(</span><span class="s2">&quot;Can't call method on &quot;</span><span class="s0">+l);</span><span class="s1">return </span><span class="s0">l}});</span><span class="s1">var </span><span class="s0">It=E((Nd,gi)=&gt;{</span><span class="s1">var </span><span class="s0">Hh=mi(),zh=xs();gi.exports=</span><span class="s1">function</span><span class="s0">(l){</span><span class="s1">return </span><span class="s0">Hh(zh(l))}});</span><span class="s1">var </span><span class="s0">Ps=E((kd,Pi)=&gt;{</span><span class="s1">var </span><span class="s0">gs=</span><span class="s1">typeof </span><span class="s0">document==</span><span class="s2">&quot;object&quot;</span><span class="s0">&amp;&amp;document.all,Vh=</span><span class="s1">typeof </span><span class="s0">gs&gt;</span><span class="s2">&quot;u&quot;</span><span class="s0">&amp;&amp;gs!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">;Pi.exports={all:gs,IS_HTMLDDA:Vh}});</span><span class="s1">var </span><span class="s0">ee=E((Dd,Ti)=&gt;{</span><span class="s1">var </span><span class="s0">Ai=Ps(),Kh=Ai.all;Ti.exports=Ai.IS_HTMLDDA?</span><span class="s1">function</span><span class="s0">(l){</span><span class="s1">return typeof </span><span class="s0">l==</span><span class="s2">&quot;function&quot;</span><span class="s0">||l===Kh}:</span><span class="s1">function</span><span class="s0">(l){</span><span class="s1">return typeof </span><span class="s0">l==</span><span class="s2">&quot;function&quot;</span><span class="s0">}});</span><span class="s1">var </span><span class="s0">Ie=E((Fd,Ci)=&gt;{</span><span class="s1">var </span><span class="s0">vi=ee(),Ei=Ps(),Wh=Ei.all;Ci.exports=Ei.IS_HTMLDDA?</span><span class="s1">function</span><span class="s0">(l){</span><span class="s1">return typeof </span><span class="s0">l==</span><span class="s2">&quot;object&quot;</span><span class="s0">?l!==</span><span class="s1">null</span><span class="s0">:vi(l)||l===Wh}:</span><span class="s1">function</span><span class="s0">(l){</span><span class="s1">return typeof </span><span class="s0">l==</span><span class="s2">&quot;object&quot;</span><span class="s0">?l!==</span><span class="s1">null</span><span class="s0">:vi(l)}});</span><span class="s1">var </span><span class="s0">Qe=E((Ld,bi)=&gt;{</span><span class="s1">var </span><span class="s0">As=re(),Gh=ee(),Jh=</span><span class="s1">function</span><span class="s0">(l){</span><span class="s1">return </span><span class="s0">Gh(l)?l:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">};bi.exports=</span><span class="s1">function</span><span class="s0">(l,h){</span><span class="s1">return </span><span class="s0">arguments.length&lt;</span><span class="s3">2</span><span class="s0">?Jh(As[l]):As[l]&amp;&amp;As[l][h]}});</span><span class="s1">var </span><span class="s0">wi=E((Od,Si)=&gt;{</span><span class="s1">var </span><span class="s0">Xh=ae();Si.exports=Xh({}.isPrototypeOf)});</span><span class="s1">var </span><span class="s0">Ni=E((Bd,Ii)=&gt;{</span><span class="s1">var </span><span class="s0">Yh=Qe();Ii.exports=Yh(</span><span class="s2">&quot;navigator&quot;</span><span class="s0">,</span><span class="s2">&quot;userAgent&quot;</span><span class="s0">)||</span><span class="s2">&quot;&quot;</span><span class="s0">});</span><span class="s1">var </span><span class="s0">Mi=E((Md,Bi)=&gt;{</span><span class="s1">var </span><span class="s0">Oi=re(),Ts=Ni(),ki=Oi.process,Di=Oi.Deno,Fi=ki&amp;&amp;ki.versions||Di&amp;&amp;Di.version,Li=Fi&amp;&amp;Fi.v8,ne,Nt;Li&amp;&amp;(ne=Li.split(</span><span class="s2">&quot;.&quot;</span><span class="s0">),Nt=ne[</span><span class="s3">0</span><span class="s0">]&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;ne[</span><span class="s3">0</span><span class="s0">]&lt;</span><span class="s3">4</span><span class="s0">?</span><span class="s3">1</span><span class="s0">:+(ne[</span><span class="s3">0</span><span class="s0">]+ne[</span><span class="s3">1</span><span class="s0">]));!Nt&amp;&amp;Ts&amp;&amp;(ne=Ts.match(/Edge\/(\d+)/),(!ne||ne[</span><span class="s3">1</span><span class="s0">]&gt;=</span><span class="s3">74</span><span class="s0">)&amp;&amp;(ne=Ts.match(/Chrome\/(\d+)/),ne&amp;&amp;(Nt=+ne[</span><span class="s3">1</span><span class="s0">])));Bi.exports=Nt});</span><span class="s1">var </span><span class="s0">vs=E((_d,Ri)=&gt;{</span><span class="s1">var </span><span class="s0">_i=Mi(),Qh=ie();Ri.exports=!!Object.getOwnPropertySymbols&amp;&amp;!Qh(</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">var </span><span class="s0">l=Symbol();</span><span class="s1">return</span><span class="s0">!String(l)||!(Object(l)</span><span class="s1">instanceof </span><span class="s0">Symbol)||!Symbol.sham&amp;&amp;_i&amp;&amp;_i&lt;</span><span class="s3">41</span><span class="s0">})});</span><span class="s1">var </span><span class="s0">Es=E((Rd,ji)=&gt;{</span><span class="s1">var </span><span class="s0">Zh=vs();ji.exports=Zh&amp;&amp;!Symbol.sham&amp;&amp;</span><span class="s1">typeof </span><span class="s0">Symbol.iterator==</span><span class="s2">&quot;symbol&quot;</span><span class="s0">});</span><span class="s1">var </span><span class="s0">Cs=E((jd,qi)=&gt;{</span><span class="s1">var </span><span class="s0">eu=Qe(),tu=ee(),su=wi(),ru=Es(),iu=Object;qi.exports=ru?</span><span class="s1">function</span><span class="s0">(l){</span><span class="s1">return typeof </span><span class="s0">l==</span><span class="s2">&quot;symbol&quot;</span><span class="s0">}:</span><span class="s1">function</span><span class="s0">(l){</span><span class="s1">var </span><span class="s0">h=eu(</span><span class="s2">&quot;Symbol&quot;</span><span class="s0">);</span><span class="s1">return </span><span class="s0">tu(h)&amp;&amp;su(h.prototype,iu(l))}});</span><span class="s1">var </span><span class="s0">$i=E((qd,Ui)=&gt;{</span><span class="s1">var </span><span class="s0">au=String;Ui.exports=</span><span class="s1">function</span><span class="s0">(l){</span><span class="s1">try</span><span class="s0">{</span><span class="s1">return </span><span class="s0">au(l)}</span><span class="s1">catch</span><span class="s0">{</span><span class="s1">return</span><span class="s2">&quot;Object&quot;</span><span class="s0">}}});</span><span class="s1">var </span><span class="s0">kt=E((Ud,Hi)=&gt;{</span><span class="s1">var </span><span class="s0">nu=ee(),ou=$i(),lu=TypeError;Hi.exports=</span><span class="s1">function</span><span class="s0">(l){</span><span class="s1">if</span><span class="s0">(nu(l))</span><span class="s1">return </span><span class="s0">l;</span><span class="s1">throw </span><span class="s0">lu(ou(l)+</span><span class="s2">&quot; is not a function&quot;</span><span class="s0">)}});</span><span class="s1">var </span><span class="s0">Vi=E(($d,zi)=&gt;{</span><span class="s1">var </span><span class="s0">hu=kt(),uu=ys();zi.exports=</span><span class="s1">function</span><span class="s0">(l,h){</span><span class="s1">var </span><span class="s0">p=l[h];</span><span class="s1">return </span><span class="s0">uu(p)?</span><span class="s1">void </span><span class="s3">0</span><span class="s0">:hu(p)}});</span><span class="s1">var </span><span class="s0">Wi=E((Hd,Ki)=&gt;{</span><span class="s1">var </span><span class="s0">bs=wt(),Ss=ee(),ws=Ie(),cu=TypeError;Ki.exports=</span><span class="s1">function</span><span class="s0">(l,h){</span><span class="s1">var </span><span class="s0">p,d;</span><span class="s1">if</span><span class="s0">(h===</span><span class="s2">&quot;string&quot;</span><span class="s0">&amp;&amp;Ss(p=l.toString)&amp;&amp;!ws(d=bs(p,l))||Ss(p=l.valueOf)&amp;&amp;!ws(d=bs(p,l))||h!==</span><span class="s2">&quot;string&quot;</span><span class="s0">&amp;&amp;Ss(p=l.toString)&amp;&amp;!ws(d=bs(p,l)))</span><span class="s1">return </span><span class="s0">d;</span><span class="s1">throw </span><span class="s0">cu(</span><span class="s2">&quot;Can't convert object to primitive value&quot;</span><span class="s0">)}});</span><span class="s1">var </span><span class="s0">Ji=E((zd,Gi)=&gt;{Gi.exports=!</span><span class="s3">1</span><span class="s0">});</span><span class="s1">var </span><span class="s0">Dt=E((Vd,Yi)=&gt;{</span><span class="s1">var </span><span class="s0">Xi=re(),pu=Object.defineProperty;Yi.exports=</span><span class="s1">function</span><span class="s0">(l,h){</span><span class="s1">try</span><span class="s0">{pu(Xi,l,{value:h,configurable:!</span><span class="s3">0</span><span class="s0">,writable:!</span><span class="s3">0</span><span class="s0">})}</span><span class="s1">catch</span><span class="s0">{Xi[l]=h}</span><span class="s1">return </span><span class="s0">h}});</span><span class="s1">var </span><span class="s0">Ft=E((Kd,Zi)=&gt;{</span><span class="s1">var </span><span class="s0">fu=re(),du=Dt(),Qi=</span><span class="s2">&quot;__core-js_shared__&quot;</span><span class="s0">,mu=fu[Qi]||du(Qi,{});Zi.exports=mu});</span><span class="s1">var </span><span class="s0">Is=E((Wd,ta)=&gt;{</span><span class="s1">var </span><span class="s0">yu=Ji(),ea=Ft();(ta.exports=</span><span class="s1">function</span><span class="s0">(l,h){</span><span class="s1">return </span><span class="s0">ea[l]||(ea[l]=h!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?h:{})})(</span><span class="s2">&quot;versions&quot;</span><span class="s0">,[]).push({version:</span><span class="s2">&quot;3.26.1&quot;</span><span class="s0">,mode:yu?</span><span class="s2">&quot;pure&quot;</span><span class="s0">:</span><span class="s2">&quot;global&quot;</span><span class="s0">,copyright:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">A9 2014-2022 Denis Pushkarev (zloirock.ru)&quot;</span><span class="s0">,license:</span><span class="s2">&quot;https://github.com/zloirock/core-js/blob/v3.26.1/LICENSE&quot;</span><span class="s0">,source:</span><span class="s2">&quot;https://github.com/zloirock/core-js&quot;</span><span class="s0">})});</span><span class="s1">var </span><span class="s0">Ns=E((Gd,sa)=&gt;{</span><span class="s1">var </span><span class="s0">xu=xs(),gu=Object;sa.exports=</span><span class="s1">function</span><span class="s0">(l){</span><span class="s1">return </span><span class="s0">gu(xu(l))}});</span><span class="s1">var </span><span class="s0">ve=E((Jd,ra)=&gt;{</span><span class="s1">var </span><span class="s0">Pu=ae(),Au=Ns(),Tu=Pu({}.hasOwnProperty);ra.exports=Object.hasOwn||</span><span class="s1">function</span><span class="s0">(h,p){</span><span class="s1">return </span><span class="s0">Tu(Au(h),p)}});</span><span class="s1">var </span><span class="s0">ks=E((Xd,ia)=&gt;{</span><span class="s1">var </span><span class="s0">vu=ae(),Eu=</span><span class="s3">0</span><span class="s0">,Cu=Math.random(),bu=vu(</span><span class="s3">1 </span><span class="s0">.toString);ia.exports=</span><span class="s1">function</span><span class="s0">(l){</span><span class="s1">return</span><span class="s2">&quot;Symbol(&quot;</span><span class="s0">+(l===</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?</span><span class="s2">&quot;&quot;</span><span class="s0">:l)+</span><span class="s2">&quot;)_&quot;</span><span class="s0">+bu(++Eu+Cu,</span><span class="s3">36</span><span class="s0">)}});</span><span class="s1">var </span><span class="s0">Ze=E((Yd,ha)=&gt;{</span><span class="s1">var </span><span class="s0">Su=re(),wu=Is(),aa=ve(),Iu=ks(),na=vs(),la=Es(),qe=wu(</span><span class="s2">&quot;wks&quot;</span><span class="s0">),Ne=Su.Symbol,oa=Ne&amp;&amp;Ne.</span><span class="s1">for</span><span class="s0">,Nu=la?Ne:Ne&amp;&amp;Ne.withoutSetter||Iu;ha.exports=</span><span class="s1">function</span><span class="s0">(l){</span><span class="s1">if</span><span class="s0">(!aa(qe,l)||!(na||</span><span class="s1">typeof </span><span class="s0">qe[l]==</span><span class="s2">&quot;string&quot;</span><span class="s0">)){</span><span class="s1">var </span><span class="s0">h=</span><span class="s2">&quot;Symbol.&quot;</span><span class="s0">+l;na&amp;&amp;aa(Ne,l)?qe[l]=Ne[l]:la&amp;&amp;oa?qe[l]=oa(h):qe[l]=Nu(h)}</span><span class="s1">return </span><span class="s0">qe[l]}});</span><span class="s1">var </span><span class="s0">fa=E((Qd,pa)=&gt;{</span><span class="s1">var </span><span class="s0">ku=wt(),ua=Ie(),ca=Cs(),Du=Vi(),Fu=Wi(),Lu=Ze(),Ou=TypeError,Bu=Lu(</span><span class="s2">&quot;toPrimitive&quot;</span><span class="s0">);pa.exports=</span><span class="s1">function</span><span class="s0">(l,h){</span><span class="s1">if</span><span class="s0">(!ua(l)||ca(l))</span><span class="s1">return </span><span class="s0">l;</span><span class="s1">var </span><span class="s0">p=Du(l,Bu),d;</span><span class="s1">if</span><span class="s0">(p){</span><span class="s1">if</span><span class="s0">(h===</span><span class="s1">void </span><span class="s3">0</span><span class="s0">&amp;&amp;(h=</span><span class="s2">&quot;default&quot;</span><span class="s0">),d=ku(p,l,h),!ua(d)||ca(d))</span><span class="s1">return </span><span class="s0">d;</span><span class="s1">throw </span><span class="s0">Ou(</span><span class="s2">&quot;Can't convert object to primitive value&quot;</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">h===</span><span class="s1">void </span><span class="s3">0</span><span class="s0">&amp;&amp;(h=</span><span class="s2">&quot;number&quot;</span><span class="s0">),Fu(l,h)}});</span><span class="s1">var </span><span class="s0">Ds=E((Zd,da)=&gt;{</span><span class="s1">var </span><span class="s0">Mu=fa(),_u=Cs();da.exports=</span><span class="s1">function</span><span class="s0">(l){</span><span class="s1">var </span><span class="s0">h=Mu(l,</span><span class="s2">&quot;string&quot;</span><span class="s0">);</span><span class="s1">return </span><span class="s0">_u(h)?h:h+</span><span class="s2">&quot;&quot;</span><span class="s0">}});</span><span class="s1">var </span><span class="s0">xa=E((em,ya)=&gt;{</span><span class="s1">var </span><span class="s0">Ru=re(),ma=Ie(),Fs=Ru.document,ju=ma(Fs)&amp;&amp;ma(Fs.createElement);ya.exports=</span><span class="s1">function</span><span class="s0">(l){</span><span class="s1">return </span><span class="s0">ju?Fs.createElement(l):{}}});</span><span class="s1">var </span><span class="s0">Ls=E((tm,ga)=&gt;{</span><span class="s1">var </span><span class="s0">qu=ye(),Uu=ie(),$u=xa();ga.exports=!qu&amp;&amp;!Uu(</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">Object.defineProperty($u(</span><span class="s2">&quot;div&quot;</span><span class="s0">),</span><span class="s2">&quot;a&quot;</span><span class="s0">,{get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s3">7</span><span class="s0">}}).a!=</span><span class="s3">7</span><span class="s0">})});</span><span class="s1">var </span><span class="s0">Os=E(Aa=&gt;{</span><span class="s1">var </span><span class="s0">Hu=ye(),zu=wt(),Vu=oi(),Ku=fs(),Wu=It(),Gu=Ds(),Ju=ve(),Xu=Ls(),Pa=Object.getOwnPropertyDescriptor;Aa.f=Hu?Pa:</span><span class="s1">function</span><span class="s0">(h,p){</span><span class="s1">if</span><span class="s0">(h=Wu(h),p=Gu(p),Xu)</span><span class="s1">try</span><span class="s0">{</span><span class="s1">return </span><span class="s0">Pa(h,p)}</span><span class="s1">catch</span><span class="s0">{}</span><span class="s1">if</span><span class="s0">(Ju(h,p))</span><span class="s1">return </span><span class="s0">Ku(!zu(Vu.f,h,p),h[p])}});</span><span class="s1">var </span><span class="s0">va=E((rm,Ta)=&gt;{</span><span class="s1">var </span><span class="s0">Yu=ye(),Qu=ie();Ta.exports=Yu&amp;&amp;Qu(</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">Object.defineProperty(</span><span class="s1">function</span><span class="s0">(){},</span><span class="s2">&quot;prototype&quot;</span><span class="s0">,{value:</span><span class="s3">42</span><span class="s0">,writable:!</span><span class="s3">1</span><span class="s0">}).prototype!=</span><span class="s3">42</span><span class="s0">})});</span><span class="s1">var </span><span class="s0">Lt=E((im,Ea)=&gt;{</span><span class="s1">var </span><span class="s0">Zu=Ie(),ec=String,tc=TypeError;Ea.exports=</span><span class="s1">function</span><span class="s0">(l){</span><span class="s1">if</span><span class="s0">(Zu(l))</span><span class="s1">return </span><span class="s0">l;</span><span class="s1">throw </span><span class="s0">tc(ec(l)+</span><span class="s2">&quot; is not an object&quot;</span><span class="s0">)}});</span><span class="s1">var </span><span class="s0">et=E(ba=&gt;{</span><span class="s1">var </span><span class="s0">sc=ye(),rc=Ls(),ic=va(),Ot=Lt(),Ca=Ds(),ac=TypeError,Bs=Object.defineProperty,nc=Object.getOwnPropertyDescriptor,Ms=</span><span class="s2">&quot;enumerable&quot;</span><span class="s0">,_s=</span><span class="s2">&quot;configurable&quot;</span><span class="s0">,Rs=</span><span class="s2">&quot;writable&quot;</span><span class="s0">;ba.f=sc?ic?</span><span class="s1">function</span><span class="s0">(h,p,d){</span><span class="s1">if</span><span class="s0">(Ot(h),p=Ca(p),Ot(d),</span><span class="s1">typeof </span><span class="s0">h==</span><span class="s2">&quot;function&quot;</span><span class="s0">&amp;&amp;p===</span><span class="s2">&quot;prototype&quot;</span><span class="s0">&amp;&amp;</span><span class="s2">&quot;value&quot;</span><span class="s1">in </span><span class="s0">d&amp;&amp;Rs </span><span class="s1">in </span><span class="s0">d&amp;&amp;!d[Rs]){</span><span class="s1">var </span><span class="s0">x=nc(h,p);x&amp;&amp;x[Rs]&amp;&amp;(h[p]=d.value,d={configurable:_s </span><span class="s1">in </span><span class="s0">d?d[_s]:x[_s],enumerable:Ms </span><span class="s1">in </span><span class="s0">d?d[Ms]:x[Ms],writable:!</span><span class="s3">1</span><span class="s0">})}</span><span class="s1">return </span><span class="s0">Bs(h,p,d)}:Bs:</span><span class="s1">function</span><span class="s0">(h,p,d){</span><span class="s1">if</span><span class="s0">(Ot(h),p=Ca(p),Ot(d),rc)</span><span class="s1">try</span><span class="s0">{</span><span class="s1">return </span><span class="s0">Bs(h,p,d)}</span><span class="s1">catch</span><span class="s0">{}</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;get&quot;</span><span class="s1">in </span><span class="s0">d||</span><span class="s2">&quot;set&quot;</span><span class="s1">in </span><span class="s0">d)</span><span class="s1">throw </span><span class="s0">ac(</span><span class="s2">&quot;Accessors not supported&quot;</span><span class="s0">);</span><span class="s1">return</span><span class="s2">&quot;value&quot;</span><span class="s1">in </span><span class="s0">d&amp;&amp;(h[p]=d.value),h}});</span><span class="s1">var </span><span class="s0">js=E((nm,Sa)=&gt;{</span><span class="s1">var </span><span class="s0">oc=ye(),lc=et(),hc=fs();Sa.exports=oc?</span><span class="s1">function</span><span class="s0">(l,h,p){</span><span class="s1">return </span><span class="s0">lc.f(l,h,hc(</span><span class="s3">1</span><span class="s0">,p))}:</span><span class="s1">function</span><span class="s0">(l,h,p){</span><span class="s1">return </span><span class="s0">l[h]=p,l}});</span><span class="s1">var </span><span class="s0">Na=E((om,Ia)=&gt;{</span><span class="s1">var </span><span class="s0">qs=ye(),uc=ve(),wa=Function.prototype,cc=qs&amp;&amp;Object.getOwnPropertyDescriptor,Us=uc(wa,</span><span class="s2">&quot;name&quot;</span><span class="s0">),pc=Us&amp;&amp;</span><span class="s1">function</span><span class="s0">(){}.name===</span><span class="s2">&quot;something&quot;</span><span class="s0">,fc=Us&amp;&amp;(!qs||qs&amp;&amp;cc(wa,</span><span class="s2">&quot;name&quot;</span><span class="s0">).configurable);Ia.exports={EXISTS:Us,PROPER:pc,CONFIGURABLE:fc}});</span><span class="s1">var </span><span class="s0">Hs=E((lm,ka)=&gt;{</span><span class="s1">var </span><span class="s0">dc=ae(),mc=ee(),$s=Ft(),yc=dc(Function.toString);mc($s.inspectSource)||($s.inspectSource=</span><span class="s1">function</span><span class="s0">(l){</span><span class="s1">return </span><span class="s0">yc(l)});ka.exports=$s.inspectSource});</span><span class="s1">var </span><span class="s0">La=E((hm,Fa)=&gt;{</span><span class="s1">var </span><span class="s0">xc=re(),gc=ee(),Da=xc.WeakMap;Fa.exports=gc(Da)&amp;&amp;/native code/.test(String(Da))});</span><span class="s1">var </span><span class="s0">Ma=E((um,Ba)=&gt;{</span><span class="s1">var </span><span class="s0">Pc=Is(),Ac=ks(),Oa=Pc(</span><span class="s2">&quot;keys&quot;</span><span class="s0">);Ba.exports=</span><span class="s1">function</span><span class="s0">(l){</span><span class="s1">return </span><span class="s0">Oa[l]||(Oa[l]=Ac(l))}});</span><span class="s1">var </span><span class="s0">zs=E((cm,_a)=&gt;{_a.exports={}});</span><span class="s1">var </span><span class="s0">Ua=E((pm,qa)=&gt;{</span><span class="s1">var </span><span class="s0">Tc=La(),ja=re(),vc=Ie(),Ec=js(),Vs=ve(),Ks=Ft(),Cc=Ma(),bc=zs(),Ra=</span><span class="s2">&quot;Object already initialized&quot;</span><span class="s0">,Ws=ja.TypeError,Sc=ja.WeakMap,Bt,tt,Mt,wc=</span><span class="s1">function</span><span class="s0">(l){</span><span class="s1">return </span><span class="s0">Mt(l)?tt(l):Bt(l,{})},Ic=</span><span class="s1">function</span><span class="s0">(l){</span><span class="s1">return function</span><span class="s0">(h){</span><span class="s1">var </span><span class="s0">p;</span><span class="s1">if</span><span class="s0">(!vc(h)||(p=tt(h)).type!==l)</span><span class="s1">throw </span><span class="s0">Ws(</span><span class="s2">&quot;Incompatible receiver, &quot;</span><span class="s0">+l+</span><span class="s2">&quot; required&quot;</span><span class="s0">);</span><span class="s1">return </span><span class="s0">p}};Tc||Ks.state?(oe=Ks.state||(Ks.state=</span><span class="s1">new </span><span class="s0">Sc),oe.get=oe.get,oe.has=oe.has,oe.set=oe.set,Bt=</span><span class="s1">function</span><span class="s0">(l,h){</span><span class="s1">if</span><span class="s0">(oe.has(l))</span><span class="s1">throw </span><span class="s0">Ws(Ra);</span><span class="s1">return </span><span class="s0">h.facade=l,oe.set(l,h),h},tt=</span><span class="s1">function</span><span class="s0">(l){</span><span class="s1">return </span><span class="s0">oe.get(l)||{}},Mt=</span><span class="s1">function</span><span class="s0">(l){</span><span class="s1">return </span><span class="s0">oe.has(l)}):(ke=Cc(</span><span class="s2">&quot;state&quot;</span><span class="s0">),bc[ke]=!</span><span class="s3">0</span><span class="s0">,Bt=</span><span class="s1">function</span><span class="s0">(l,h){</span><span class="s1">if</span><span class="s0">(Vs(l,ke))</span><span class="s1">throw </span><span class="s0">Ws(Ra);</span><span class="s1">return </span><span class="s0">h.facade=l,Ec(l,ke,h),h},tt=</span><span class="s1">function</span><span class="s0">(l){</span><span class="s1">return </span><span class="s0">Vs(l,ke)?l[ke]:{}},Mt=</span><span class="s1">function</span><span class="s0">(l){</span><span class="s1">return </span><span class="s0">Vs(l,ke)});</span><span class="s1">var </span><span class="s0">oe,ke;qa.exports={set:Bt,get:tt,has:Mt,enforce:wc,getterFor:Ic}});</span><span class="s1">var </span><span class="s0">Js=E((fm,Ha)=&gt;{</span><span class="s1">var </span><span class="s0">Nc=ie(),kc=ee(),_t=ve(),Gs=ye(),Dc=Na().CONFIGURABLE,Fc=Hs(),$a=Ua(),Lc=$a.enforce,Oc=$a.get,Rt=Object.defineProperty,Bc=Gs&amp;&amp;!Nc(</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">Rt(</span><span class="s1">function</span><span class="s0">(){},</span><span class="s2">&quot;length&quot;</span><span class="s0">,{value:</span><span class="s3">8</span><span class="s0">}).length!==</span><span class="s3">8</span><span class="s0">}),Mc=String(String).split(</span><span class="s2">&quot;String&quot;</span><span class="s0">),_c=Ha.exports=</span><span class="s1">function</span><span class="s0">(l,h,p){String(h).slice(</span><span class="s3">0</span><span class="s0">,</span><span class="s3">7</span><span class="s0">)===</span><span class="s2">&quot;Symbol(&quot;</span><span class="s0">&amp;&amp;(h=</span><span class="s2">&quot;[&quot;</span><span class="s0">+String(h).replace(/^Symbol\(([^)]*)\)/,</span><span class="s2">&quot;$1&quot;</span><span class="s0">)+</span><span class="s2">&quot;]&quot;</span><span class="s0">),p&amp;&amp;p.getter&amp;&amp;(h=</span><span class="s2">&quot;get &quot;</span><span class="s0">+h),p&amp;&amp;p.setter&amp;&amp;(h=</span><span class="s2">&quot;set &quot;</span><span class="s0">+h),(!_t(l,</span><span class="s2">&quot;name&quot;</span><span class="s0">)||Dc&amp;&amp;l.name!==h)&amp;&amp;(Gs?Rt(l,</span><span class="s2">&quot;name&quot;</span><span class="s0">,{value:h,configurable:!</span><span class="s3">0</span><span class="s0">}):l.name=h),Bc&amp;&amp;p&amp;&amp;_t(p,</span><span class="s2">&quot;arity&quot;</span><span class="s0">)&amp;&amp;l.length!==p.arity&amp;&amp;Rt(l,</span><span class="s2">&quot;length&quot;</span><span class="s0">,{value:p.arity});</span><span class="s1">try</span><span class="s0">{p&amp;&amp;_t(p,</span><span class="s2">&quot;constructor&quot;</span><span class="s0">)&amp;&amp;p.constructor?Gs&amp;&amp;Rt(l,</span><span class="s2">&quot;prototype&quot;</span><span class="s0">,{writable:!</span><span class="s3">1</span><span class="s0">}):l.prototype&amp;&amp;(l.prototype=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">)}</span><span class="s1">catch</span><span class="s0">{}</span><span class="s1">var </span><span class="s0">d=Lc(l);</span><span class="s1">return </span><span class="s0">_t(d,</span><span class="s2">&quot;source&quot;</span><span class="s0">)||(d.source=Mc.join(</span><span class="s1">typeof </span><span class="s0">h==</span><span class="s2">&quot;string&quot;</span><span class="s0">?h:</span><span class="s2">&quot;&quot;</span><span class="s0">)),l};Function.prototype.toString=_c(</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">kc(</span><span class="s1">this</span><span class="s0">)&amp;&amp;Oc(</span><span class="s1">this</span><span class="s0">).source||Fc(</span><span class="s1">this</span><span class="s0">)},</span><span class="s2">&quot;toString&quot;</span><span class="s0">)});</span><span class="s1">var </span><span class="s0">Va=E((dm,za)=&gt;{</span><span class="s1">var </span><span class="s0">Rc=ee(),jc=et(),qc=Js(),Uc=Dt();za.exports=</span><span class="s1">function</span><span class="s0">(l,h,p,d){d||(d={});</span><span class="s1">var </span><span class="s0">x=d.enumerable,P=d.name!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?d.name:h;</span><span class="s1">if</span><span class="s0">(Rc(p)&amp;&amp;qc(p,P,d),d.global)x?l[h]=p:Uc(h,p);</span><span class="s1">else</span><span class="s0">{</span><span class="s1">try</span><span class="s0">{d.unsafe?l[h]&amp;&amp;(x=!</span><span class="s3">0</span><span class="s0">):</span><span class="s1">delete </span><span class="s0">l[h]}</span><span class="s1">catch</span><span class="s0">{}x?l[h]=p:jc.f(l,h,{value:p,enumerable:!</span><span class="s3">1</span><span class="s0">,configurable:!d.nonConfigurable,writable:!d.nonWritable})}</span><span class="s1">return </span><span class="s0">l}});</span><span class="s1">var </span><span class="s0">Wa=E((mm,Ka)=&gt;{</span><span class="s1">var </span><span class="s0">$c=Math.ceil,Hc=Math.floor;Ka.exports=Math.trunc||</span><span class="s1">function</span><span class="s0">(h){</span><span class="s1">var </span><span class="s0">p=+h;</span><span class="s1">return</span><span class="s0">(p&gt;</span><span class="s3">0</span><span class="s0">?Hc:$c)(p)}});</span><span class="s1">var </span><span class="s0">Xs=E((ym,Ga)=&gt;{</span><span class="s1">var </span><span class="s0">zc=Wa();Ga.exports=</span><span class="s1">function</span><span class="s0">(l){</span><span class="s1">var </span><span class="s0">h=+l;</span><span class="s1">return </span><span class="s0">h!==h||h===</span><span class="s3">0</span><span class="s0">?</span><span class="s3">0</span><span class="s0">:zc(h)}});</span><span class="s1">var </span><span class="s0">Xa=E((xm,Ja)=&gt;{</span><span class="s1">var </span><span class="s0">Vc=Xs(),Kc=Math.max,Wc=Math.min;Ja.exports=</span><span class="s1">function</span><span class="s0">(l,h){</span><span class="s1">var </span><span class="s0">p=Vc(l);</span><span class="s1">return </span><span class="s0">p&lt;</span><span class="s3">0</span><span class="s0">?Kc(p+h,</span><span class="s3">0</span><span class="s0">):Wc(p,h)}});</span><span class="s1">var </span><span class="s0">Qa=E((gm,Ya)=&gt;{</span><span class="s1">var </span><span class="s0">Gc=Xs(),Jc=Math.min;Ya.exports=</span><span class="s1">function</span><span class="s0">(l){</span><span class="s1">return </span><span class="s0">l&gt;</span><span class="s3">0</span><span class="s0">?Jc(Gc(l),</span><span class="s3">9007199254740991</span><span class="s0">):</span><span class="s3">0</span><span class="s0">}});</span><span class="s1">var </span><span class="s0">jt=E((Pm,Za)=&gt;{</span><span class="s1">var </span><span class="s0">Xc=Qa();Za.exports=</span><span class="s1">function</span><span class="s0">(l){</span><span class="s1">return </span><span class="s0">Xc(l.length)}});</span><span class="s1">var </span><span class="s0">sn=E((Am,tn)=&gt;{</span><span class="s1">var </span><span class="s0">Yc=It(),Qc=Xa(),Zc=jt(),en=</span><span class="s1">function</span><span class="s0">(l){</span><span class="s1">return function</span><span class="s0">(h,p,d){</span><span class="s1">var </span><span class="s0">x=Yc(h),P=Zc(x),m=Qc(d,P),v;</span><span class="s1">if</span><span class="s0">(l&amp;&amp;p!=p){</span><span class="s1">for</span><span class="s0">(;P&gt;m;)</span><span class="s1">if</span><span class="s0">(v=x[m++],v!=v)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">0</span><span class="s0">}</span><span class="s1">else for</span><span class="s0">(;P&gt;m;m++)</span><span class="s1">if</span><span class="s0">((l||m </span><span class="s1">in </span><span class="s0">x)&amp;&amp;x[m]===p)</span><span class="s1">return </span><span class="s0">l||m||</span><span class="s3">0</span><span class="s0">;</span><span class="s1">return</span><span class="s0">!l&amp;&amp;-</span><span class="s3">1</span><span class="s0">}};tn.exports={includes:en(!</span><span class="s3">0</span><span class="s0">),indexOf:en(!</span><span class="s3">1</span><span class="s0">)}});</span><span class="s1">var </span><span class="s0">nn=E((Tm,an)=&gt;{</span><span class="s1">var </span><span class="s0">ep=ae(),Ys=ve(),tp=It(),sp=sn().indexOf,rp=zs(),rn=ep([].push);an.exports=</span><span class="s1">function</span><span class="s0">(l,h){</span><span class="s1">var </span><span class="s0">p=tp(l),d=</span><span class="s3">0</span><span class="s0">,x=[],P;</span><span class="s1">for</span><span class="s0">(P </span><span class="s1">in </span><span class="s0">p)!Ys(rp,P)&amp;&amp;Ys(p,P)&amp;&amp;rn(x,P);</span><span class="s1">for</span><span class="s0">(;h.length&gt;d;)Ys(p,P=h[d++])&amp;&amp;(~sp(x,P)||rn(x,P));</span><span class="s1">return </span><span class="s0">x}});</span><span class="s1">var </span><span class="s0">ln=E((vm,on)=&gt;{on.exports=[</span><span class="s2">&quot;constructor&quot;</span><span class="s0">,</span><span class="s2">&quot;hasOwnProperty&quot;</span><span class="s0">,</span><span class="s2">&quot;isPrototypeOf&quot;</span><span class="s0">,</span><span class="s2">&quot;propertyIsEnumerable&quot;</span><span class="s0">,</span><span class="s2">&quot;toLocaleString&quot;</span><span class="s0">,</span><span class="s2">&quot;toString&quot;</span><span class="s0">,</span><span class="s2">&quot;valueOf&quot;</span><span class="s0">]});</span><span class="s1">var </span><span class="s0">un=E(hn=&gt;{</span><span class="s1">var </span><span class="s0">ip=nn(),ap=ln(),np=ap.concat(</span><span class="s2">&quot;length&quot;</span><span class="s0">,</span><span class="s2">&quot;prototype&quot;</span><span class="s0">);hn.f=Object.getOwnPropertyNames||</span><span class="s1">function</span><span class="s0">(h){</span><span class="s1">return </span><span class="s0">ip(h,np)}});</span><span class="s1">var </span><span class="s0">pn=E(cn=&gt;{cn.f=Object.getOwnPropertySymbols});</span><span class="s1">var </span><span class="s0">dn=E((bm,fn)=&gt;{</span><span class="s1">var </span><span class="s0">op=Qe(),lp=ae(),hp=un(),up=pn(),cp=Lt(),pp=lp([].concat);fn.exports=op(</span><span class="s2">&quot;Reflect&quot;</span><span class="s0">,</span><span class="s2">&quot;ownKeys&quot;</span><span class="s0">)||</span><span class="s1">function</span><span class="s0">(h){</span><span class="s1">var </span><span class="s0">p=hp.f(cp(h)),d=up.f;</span><span class="s1">return </span><span class="s0">d?pp(p,d(h)):p}});</span><span class="s1">var </span><span class="s0">xn=E((Sm,yn)=&gt;{</span><span class="s1">var </span><span class="s0">mn=ve(),fp=dn(),dp=Os(),mp=et();yn.exports=</span><span class="s1">function</span><span class="s0">(l,h,p){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">d=fp(h),x=mp.f,P=dp.f,m=</span><span class="s3">0</span><span class="s0">;m&lt;d.length;m++){</span><span class="s1">var </span><span class="s0">v=d[m];!mn(l,v)&amp;&amp;!(p&amp;&amp;mn(p,v))&amp;&amp;x(l,v,P(h,v))}}});</span><span class="s1">var </span><span class="s0">Pn=E((wm,gn)=&gt;{</span><span class="s1">var </span><span class="s0">yp=ie(),xp=ee(),gp=/#|\.prototype\./,st=</span><span class="s1">function</span><span class="s0">(l,h){</span><span class="s1">var </span><span class="s0">p=Ap[Pp(l)];</span><span class="s1">return </span><span class="s0">p==vp?!</span><span class="s3">0</span><span class="s0">:p==Tp?!</span><span class="s3">1</span><span class="s0">:xp(h)?yp(h):!!h},Pp=st.normalize=</span><span class="s1">function</span><span class="s0">(l){</span><span class="s1">return </span><span class="s0">String(l).replace(gp,</span><span class="s2">&quot;.&quot;</span><span class="s0">).toLowerCase()},Ap=st.data={},Tp=st.NATIVE=</span><span class="s2">&quot;N&quot;</span><span class="s0">,vp=st.POLYFILL=</span><span class="s2">&quot;P&quot;</span><span class="s0">;gn.exports=st});</span><span class="s1">var </span><span class="s0">Zs=E((Im,An)=&gt;{</span><span class="s1">var </span><span class="s0">Qs=re(),Ep=Os().f,Cp=js(),bp=Va(),Sp=Dt(),wp=xn(),Ip=Pn();An.exports=</span><span class="s1">function</span><span class="s0">(l,h){</span><span class="s1">var </span><span class="s0">p=l.target,d=l.global,x=l.stat,P,m,v,S,k,F;</span><span class="s1">if</span><span class="s0">(d?m=Qs:x?m=Qs[p]||Sp(p,{}):m=(Qs[p]||{}).prototype,m)</span><span class="s1">for</span><span class="s0">(v </span><span class="s1">in </span><span class="s0">h){</span><span class="s1">if</span><span class="s0">(k=h[v],l.dontCallGetSet?(F=Ep(m,v),S=F&amp;&amp;F.value):S=m[v],P=Ip(d?v:p+(x?</span><span class="s2">&quot;.&quot;</span><span class="s0">:</span><span class="s2">&quot;#&quot;</span><span class="s0">)+v,l.forced),!P&amp;&amp;S!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">k==</span><span class="s1">typeof </span><span class="s0">S)</span><span class="s1">continue</span><span class="s0">;wp(k,S)}(l.sham||S&amp;&amp;S.sham)&amp;&amp;Cp(k,</span><span class="s2">&quot;sham&quot;</span><span class="s0">,!</span><span class="s3">0</span><span class="s0">),bp(m,v,k,l)}}});</span><span class="s1">var </span><span class="s0">Tn=E(()=&gt;{</span><span class="s1">var </span><span class="s0">Np=Zs(),er=re();Np({global:!</span><span class="s3">0</span><span class="s0">,forced:er.globalThis!==er},{globalThis:er})});</span><span class="s1">var </span><span class="s0">vn=E(()=&gt;{Tn()});</span><span class="s1">var </span><span class="s0">bn=E((Lm,Cn)=&gt;{</span><span class="s1">var </span><span class="s0">En=Js(),kp=et();Cn.exports=</span><span class="s1">function</span><span class="s0">(l,h,p){</span><span class="s1">return </span><span class="s0">p.get&amp;&amp;En(p.get,h,{getter:!</span><span class="s3">0</span><span class="s0">}),p.set&amp;&amp;En(p.set,h,{setter:!</span><span class="s3">0</span><span class="s0">}),kp.f(l,h,p)}});</span><span class="s1">var </span><span class="s0">wn=E((Om,Sn)=&gt;{</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;</span><span class="s1">var </span><span class="s0">Dp=Lt();Sn.exports=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">var </span><span class="s0">l=Dp(</span><span class="s1">this</span><span class="s0">),h=</span><span class="s2">&quot;&quot;</span><span class="s0">;</span><span class="s1">return </span><span class="s0">l.hasIndices&amp;&amp;(h+=</span><span class="s2">&quot;d&quot;</span><span class="s0">),l.global&amp;&amp;(h+=</span><span class="s2">&quot;g&quot;</span><span class="s0">),l.ignoreCase&amp;&amp;(h+=</span><span class="s2">&quot;i&quot;</span><span class="s0">),l.multiline&amp;&amp;(h+=</span><span class="s2">&quot;m&quot;</span><span class="s0">),l.dotAll&amp;&amp;(h+=</span><span class="s2">&quot;s&quot;</span><span class="s0">),l.unicode&amp;&amp;(h+=</span><span class="s2">&quot;u&quot;</span><span class="s0">),l.unicodeSets&amp;&amp;(h+=</span><span class="s2">&quot;v&quot;</span><span class="s0">),l.sticky&amp;&amp;(h+=</span><span class="s2">&quot;y&quot;</span><span class="s0">),h}});</span><span class="s1">var </span><span class="s0">kn=E(()=&gt;{</span><span class="s1">var </span><span class="s0">Fp=re(),Lp=ye(),Op=bn(),Bp=wn(),Mp=ie(),In=Fp.RegExp,Nn=In.prototype,_p=Lp&amp;&amp;Mp(</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">var </span><span class="s0">l=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">try</span><span class="s0">{In(</span><span class="s2">&quot;.&quot;</span><span class="s0">,</span><span class="s2">&quot;d&quot;</span><span class="s0">)}</span><span class="s1">catch</span><span class="s0">{l=!</span><span class="s3">1</span><span class="s0">}</span><span class="s1">var </span><span class="s0">h={},p=</span><span class="s2">&quot;&quot;</span><span class="s0">,d=l?</span><span class="s2">&quot;dgimsy&quot;</span><span class="s0">:</span><span class="s2">&quot;gimsy&quot;</span><span class="s0">,x=</span><span class="s1">function</span><span class="s0">(S,k){Object.defineProperty(h,S,{get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">p+=k,!</span><span class="s3">0</span><span class="s0">}})},P={dotAll:</span><span class="s2">&quot;s&quot;</span><span class="s0">,global:</span><span class="s2">&quot;g&quot;</span><span class="s0">,ignoreCase:</span><span class="s2">&quot;i&quot;</span><span class="s0">,multiline:</span><span class="s2">&quot;m&quot;</span><span class="s0">,sticky:</span><span class="s2">&quot;y&quot;</span><span class="s0">};l&amp;&amp;(P.hasIndices=</span><span class="s2">&quot;d&quot;</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">m </span><span class="s1">in </span><span class="s0">P)x(m,P[m]);</span><span class="s1">var </span><span class="s0">v=Object.getOwnPropertyDescriptor(Nn,</span><span class="s2">&quot;flags&quot;</span><span class="s0">).get.call(h);</span><span class="s1">return </span><span class="s0">v!==d||p!==d});_p&amp;&amp;Op(Nn,</span><span class="s2">&quot;flags&quot;</span><span class="s0">,{configurable:!</span><span class="s3">0</span><span class="s0">,get:Bp})});</span><span class="s1">var </span><span class="s0">tr=E((_m,Dn)=&gt;{</span><span class="s1">var </span><span class="s0">Rp=Ye();Dn.exports=Array.isArray||</span><span class="s1">function</span><span class="s0">(h){</span><span class="s1">return </span><span class="s0">Rp(h)==</span><span class="s2">&quot;Array&quot;</span><span class="s0">}});</span><span class="s1">var </span><span class="s0">Ln=E((Rm,Fn)=&gt;{</span><span class="s1">var </span><span class="s0">jp=TypeError,qp=</span><span class="s3">9007199254740991</span><span class="s0">;Fn.exports=</span><span class="s1">function</span><span class="s0">(l){</span><span class="s1">if</span><span class="s0">(l&gt;qp)</span><span class="s1">throw </span><span class="s0">jp(</span><span class="s2">&quot;Maximum allowed index exceeded&quot;</span><span class="s0">);</span><span class="s1">return </span><span class="s0">l}});</span><span class="s1">var </span><span class="s0">Bn=E((jm,On)=&gt;{</span><span class="s1">var </span><span class="s0">Up=Ye(),$p=ae();On.exports=</span><span class="s1">function</span><span class="s0">(l){</span><span class="s1">if</span><span class="s0">(Up(l)===</span><span class="s2">&quot;Function&quot;</span><span class="s0">)</span><span class="s1">return </span><span class="s0">$p(l)}});</span><span class="s1">var </span><span class="s0">Rn=E((qm,_n)=&gt;{</span><span class="s1">var </span><span class="s0">Mn=Bn(),Hp=kt(),zp=bt(),Vp=Mn(Mn.bind);_n.exports=</span><span class="s1">function</span><span class="s0">(l,h){</span><span class="s1">return </span><span class="s0">Hp(l),h===</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?l:zp?Vp(l,h):</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">l.apply(h,arguments)}}});</span><span class="s1">var </span><span class="s0">Un=E((Um,qn)=&gt;{</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;</span><span class="s1">var </span><span class="s0">Kp=tr(),Wp=jt(),Gp=Ln(),Jp=Rn(),jn=</span><span class="s1">function</span><span class="s0">(l,h,p,d,x,P,m,v){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">S=x,k=</span><span class="s3">0</span><span class="s0">,F=m?Jp(m,v):!</span><span class="s3">1</span><span class="s0">,w,L;k&lt;d;)k </span><span class="s1">in </span><span class="s0">p&amp;&amp;(w=F?F(p[k],k,h):p[k],P&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;Kp(w)?(L=Wp(w),S=jn(l,h,w,L,S,P-1)-</span><span class="s3">1</span><span class="s0">):(Gp(S+</span><span class="s3">1</span><span class="s0">),l[S]=w),S++),k++;</span><span class="s1">return </span><span class="s0">S};qn.exports=jn});</span><span class="s1">var </span><span class="s0">zn=E(($m,Hn)=&gt;{</span><span class="s1">var </span><span class="s0">Xp=Ze(),Yp=Xp(</span><span class="s2">&quot;toStringTag&quot;</span><span class="s0">),$n={};$n[Yp]=</span><span class="s2">&quot;z&quot;</span><span class="s0">;Hn.exports=String($n)===</span><span class="s2">&quot;[object z]&quot;</span><span class="s0">});</span><span class="s1">var </span><span class="s0">Kn=E((Hm,Vn)=&gt;{</span><span class="s1">var </span><span class="s0">Qp=zn(),Zp=ee(),qt=Ye(),ef=Ze(),tf=ef(</span><span class="s2">&quot;toStringTag&quot;</span><span class="s0">),sf=Object,rf=qt(</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">arguments}())==</span><span class="s2">&quot;Arguments&quot;</span><span class="s0">,af=</span><span class="s1">function</span><span class="s0">(l,h){</span><span class="s1">try</span><span class="s0">{</span><span class="s1">return </span><span class="s0">l[h]}</span><span class="s1">catch</span><span class="s0">{}};Vn.exports=Qp?qt:</span><span class="s1">function</span><span class="s0">(l){</span><span class="s1">var </span><span class="s0">h,p,d;</span><span class="s1">return </span><span class="s0">l===</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?</span><span class="s2">&quot;Undefined&quot;</span><span class="s0">:l===</span><span class="s1">null</span><span class="s0">?</span><span class="s2">&quot;Null&quot;</span><span class="s0">:</span><span class="s1">typeof</span><span class="s0">(p=af(h=sf(l),tf))==</span><span class="s2">&quot;string&quot;</span><span class="s0">?p:rf?qt(h):(d=qt(h))==</span><span class="s2">&quot;Object&quot;</span><span class="s0">&amp;&amp;Zp(h.callee)?</span><span class="s2">&quot;Arguments&quot;</span><span class="s0">:d}});</span><span class="s1">var </span><span class="s0">Qn=E((zm,Yn)=&gt;{</span><span class="s1">var </span><span class="s0">nf=ae(),of=ie(),Wn=ee(),lf=Kn(),hf=Qe(),uf=Hs(),Gn=</span><span class="s1">function</span><span class="s0">(){},cf=[],Jn=hf(</span><span class="s2">&quot;Reflect&quot;</span><span class="s0">,</span><span class="s2">&quot;construct&quot;</span><span class="s0">),sr=/^\s*(?:class|</span><span class="s1">function</span><span class="s0">)\b/,pf=nf(sr.exec),ff=!sr.exec(Gn),rt=</span><span class="s1">function</span><span class="s0">(h){</span><span class="s1">if</span><span class="s0">(!Wn(h))</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">try</span><span class="s0">{</span><span class="s1">return </span><span class="s0">Jn(Gn,cf,h),!</span><span class="s3">0</span><span class="s0">}</span><span class="s1">catch</span><span class="s0">{</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">}},Xn=</span><span class="s1">function</span><span class="s0">(h){</span><span class="s1">if</span><span class="s0">(!Wn(h))</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">switch</span><span class="s0">(lf(h)){</span><span class="s1">case</span><span class="s2">&quot;AsyncFunction&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;GeneratorFunction&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;AsyncGeneratorFunction&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">}</span><span class="s1">try</span><span class="s0">{</span><span class="s1">return </span><span class="s0">ff||!!pf(sr,uf(h))}</span><span class="s1">catch</span><span class="s0">{</span><span class="s1">return</span><span class="s0">!</span><span class="s3">0</span><span class="s0">}};Xn.sham=!</span><span class="s3">0</span><span class="s0">;Yn.exports=!Jn||of(</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">var </span><span class="s0">l;</span><span class="s1">return </span><span class="s0">rt(rt.call)||!rt(Object)||!rt(</span><span class="s1">function</span><span class="s0">(){l=!</span><span class="s3">0</span><span class="s0">})||l})?Xn:rt});</span><span class="s1">var </span><span class="s0">so=E((Vm,to)=&gt;{</span><span class="s1">var </span><span class="s0">Zn=tr(),df=Qn(),mf=Ie(),yf=Ze(),xf=yf(</span><span class="s2">&quot;species&quot;</span><span class="s0">),eo=Array;to.exports=</span><span class="s1">function</span><span class="s0">(l){</span><span class="s1">var </span><span class="s0">h;</span><span class="s1">return </span><span class="s0">Zn(l)&amp;&amp;(h=l.constructor,df(h)&amp;&amp;(h===eo||Zn(h.prototype))?h=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">:mf(h)&amp;&amp;(h=h[xf],h===</span><span class="s1">null</span><span class="s0">&amp;&amp;(h=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">))),h===</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?eo:h}});</span><span class="s1">var </span><span class="s0">io=E((Km,ro)=&gt;{</span><span class="s1">var </span><span class="s0">gf=so();ro.exports=</span><span class="s1">function</span><span class="s0">(l,h){</span><span class="s1">return new</span><span class="s0">(gf(l))(h===</span><span class="s3">0</span><span class="s0">?</span><span class="s3">0</span><span class="s0">:h)}});</span><span class="s1">var </span><span class="s0">ao=E(()=&gt;{</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;</span><span class="s1">var </span><span class="s0">Pf=Zs(),Af=Un(),Tf=kt(),vf=Ns(),Ef=jt(),Cf=io();Pf({target:</span><span class="s2">&quot;Array&quot;</span><span class="s0">,proto:!</span><span class="s3">0</span><span class="s0">},{flatMap:</span><span class="s1">function</span><span class="s0">(h){</span><span class="s1">var </span><span class="s0">p=vf(</span><span class="s1">this</span><span class="s0">),d=Ef(p),x;</span><span class="s1">return </span><span class="s0">Tf(h),x=Cf(p,</span><span class="s3">0</span><span class="s0">),x.length=Af(x,p,p,d,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,h,arguments.length&gt;</span><span class="s3">1</span><span class="s0">?arguments[</span><span class="s3">1</span><span class="s0">]:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">),x}})});</span><span class="s1">var </span><span class="s0">md=E((ty,Oo)=&gt;{vn();kn();ao();</span><span class="s1">var </span><span class="s0">nr=Object.defineProperty,bf=Object.getOwnPropertyDescriptor,or=Object.getOwnPropertyNames,Sf=Object.prototype.hasOwnProperty,co=(l,h)=&gt;</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">l&amp;&amp;(h=(</span><span class="s3">0</span><span class="s0">,l[or(l)[</span><span class="s3">0</span><span class="s0">]])(l=</span><span class="s3">0</span><span class="s0">)),h},$=(l,h)=&gt;</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">h||(</span><span class="s3">0</span><span class="s0">,l[or(l)[</span><span class="s3">0</span><span class="s0">]])((h={exports:{}}).exports,h),h.exports},wf=(l,h)=&gt;{</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">p </span><span class="s1">in </span><span class="s0">h)nr(l,p,{get:h[p],enumerable:!</span><span class="s3">0</span><span class="s0">})},If=(l,h,p,d)=&gt;{</span><span class="s1">if</span><span class="s0">(h&amp;&amp;</span><span class="s1">typeof </span><span class="s0">h==</span><span class="s2">&quot;object&quot;</span><span class="s0">||</span><span class="s1">typeof </span><span class="s0">h==</span><span class="s2">&quot;function&quot;</span><span class="s0">)</span><span class="s1">for</span><span class="s0">(let x of or(h))!Sf.call(l,x)&amp;&amp;x!==p&amp;&amp;nr(l,x,{get:()=&gt;h[x],enumerable:!(d=bf(h,x))||d.enumerable});</span><span class="s1">return </span><span class="s0">l},Nf=l=&gt;If(nr({},</span><span class="s2">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s3">0</span><span class="s0">}),l),U=co({</span><span class="s2">&quot;&lt;define:process&gt;&quot;</span><span class="s0">(){}}),kf=$({</span><span class="s2">&quot;src/utils/try-combinations.js&quot;</span><span class="s0">(l,h){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;U();</span><span class="s1">function </span><span class="s0">p(){let d;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">x=arguments.length,P=</span><span class="s1">new </span><span class="s0">Array(x),m=</span><span class="s3">0</span><span class="s0">;m&lt;x;m++)P[m]=arguments[m];</span><span class="s1">for</span><span class="s0">(let[v,S]of P.entries())</span><span class="s1">try</span><span class="s0">{</span><span class="s1">return</span><span class="s0">{result:S()}}</span><span class="s1">catch</span><span class="s0">(k){v===</span><span class="s3">0</span><span class="s0">&amp;&amp;(d=k)}</span><span class="s1">return</span><span class="s0">{error:d}}h.exports=p}}),po=$({</span><span class="s2">&quot;src/language-js/utils/get-shebang.js&quot;</span><span class="s0">(l,h){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;U();</span><span class="s1">function </span><span class="s0">p(d){</span><span class="s1">if</span><span class="s0">(!d.startsWith(</span><span class="s2">&quot;#!&quot;</span><span class="s0">))</span><span class="s1">return</span><span class="s2">&quot;&quot;</span><span class="s0">;let x=d.indexOf(`</span>
<span class="s0">`);</span><span class="s1">return </span><span class="s0">x===-</span><span class="s3">1</span><span class="s0">?d:d.slice(</span><span class="s3">0</span><span class="s0">,x)}h.exports=p}}),Df=$({</span><span class="s2">&quot;src/utils/text/skip-inline-comment.js&quot;</span><span class="s0">(l,h){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;U();</span><span class="s1">function </span><span class="s0">p(d,x){</span><span class="s1">if</span><span class="s0">(x===!</span><span class="s3">1</span><span class="s0">)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(d.charAt(x)===</span><span class="s2">&quot;/&quot;</span><span class="s0">&amp;&amp;d.charAt(x+</span><span class="s3">1</span><span class="s0">)===</span><span class="s2">&quot;*&quot;</span><span class="s0">){</span><span class="s1">for</span><span class="s0">(let P=x+</span><span class="s3">2</span><span class="s0">;P&lt;d.length;++P)</span><span class="s1">if</span><span class="s0">(d.charAt(P)===</span><span class="s2">&quot;*&quot;</span><span class="s0">&amp;&amp;d.charAt(P+</span><span class="s3">1</span><span class="s0">)===</span><span class="s2">&quot;/&quot;</span><span class="s0">)</span><span class="s1">return </span><span class="s0">P+</span><span class="s3">2</span><span class="s0">}</span><span class="s1">return </span><span class="s0">x}h.exports=p}}),Ff=$({</span><span class="s2">&quot;src/utils/text/skip-newline.js&quot;</span><span class="s0">(l,h){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;U();</span><span class="s1">function </span><span class="s0">p(d,x,P){let m=P&amp;&amp;P.backwards;</span><span class="s1">if</span><span class="s0">(x===!</span><span class="s3">1</span><span class="s0">)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;let v=d.charAt(x);</span><span class="s1">if</span><span class="s0">(m){</span><span class="s1">if</span><span class="s0">(d.charAt(x-1)===</span><span class="s2">&quot;</span><span class="s4">\r</span><span class="s2">&quot;</span><span class="s0">&amp;&amp;v===`</span>
<span class="s0">`)</span><span class="s1">return </span><span class="s0">x-2;</span><span class="s1">if</span><span class="s0">(v===`</span>
<span class="s0">`||v===</span><span class="s2">&quot;</span><span class="s4">\r</span><span class="s2">&quot;</span><span class="s0">||v===</span><span class="s2">&quot;</span><span class="s4">\u2028</span><span class="s2">&quot;</span><span class="s0">||v===</span><span class="s2">&quot;</span><span class="s4">\u2029</span><span class="s2">&quot;</span><span class="s0">)</span><span class="s1">return </span><span class="s0">x-1}</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(v===</span><span class="s2">&quot;</span><span class="s4">\r</span><span class="s2">&quot;</span><span class="s0">&amp;&amp;d.charAt(x+</span><span class="s3">1</span><span class="s0">)===`</span>
<span class="s0">`)</span><span class="s1">return </span><span class="s0">x+</span><span class="s3">2</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(v===`</span>
<span class="s0">`||v===</span><span class="s2">&quot;</span><span class="s4">\r</span><span class="s2">&quot;</span><span class="s0">||v===</span><span class="s2">&quot;</span><span class="s4">\u2028</span><span class="s2">&quot;</span><span class="s0">||v===</span><span class="s2">&quot;</span><span class="s4">\u2029</span><span class="s2">&quot;</span><span class="s0">)</span><span class="s1">return </span><span class="s0">x+</span><span class="s3">1</span><span class="s0">}</span><span class="s1">return </span><span class="s0">x}h.exports=p}}),fo=$({</span><span class="s2">&quot;src/utils/text/skip.js&quot;</span><span class="s0">(l,h){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;U();</span><span class="s1">function </span><span class="s0">p(v){</span><span class="s1">return</span><span class="s0">(S,k,F)=&gt;{let w=F&amp;&amp;F.backwards;</span><span class="s1">if</span><span class="s0">(k===!</span><span class="s3">1</span><span class="s0">)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;let{length:L}=S,A=k;</span><span class="s1">for</span><span class="s0">(;A&gt;=</span><span class="s3">0</span><span class="s0">&amp;&amp;A&lt;L;){let _=S.charAt(A);</span><span class="s1">if</span><span class="s0">(v </span><span class="s1">instanceof </span><span class="s0">RegExp){</span><span class="s1">if</span><span class="s0">(!v.test(_))</span><span class="s1">return </span><span class="s0">A}</span><span class="s1">else if</span><span class="s0">(!v.includes(_))</span><span class="s1">return </span><span class="s0">A;w?A--:A++}</span><span class="s1">return </span><span class="s0">A===-</span><span class="s3">1</span><span class="s0">||A===L?A:!</span><span class="s3">1</span><span class="s0">}}</span><span class="s1">var </span><span class="s0">d=p(/\s/),x=p(</span><span class="s2">&quot;    &quot;</span><span class="s0">),P=p(</span><span class="s2">&quot;,;  &quot;</span><span class="s0">),m=p(/[^\n\r]/);h.exports={skipWhitespace:d,skipSpaces:x,skipToLineEnd:P,skipEverythingButNewLine:m}}}),Lf=$({</span><span class="s2">&quot;src/utils/text/skip-trailing-comment.js&quot;</span><span class="s0">(l,h){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;U();</span><span class="s1">var</span><span class="s0">{skipEverythingButNewLine:p}=fo();</span><span class="s1">function </span><span class="s0">d(x,P){</span><span class="s1">return </span><span class="s0">P===!</span><span class="s3">1</span><span class="s0">?!</span><span class="s3">1</span><span class="s0">:x.charAt(P)===</span><span class="s2">&quot;/&quot;</span><span class="s0">&amp;&amp;x.charAt(P+</span><span class="s3">1</span><span class="s0">)===</span><span class="s2">&quot;/&quot;</span><span class="s0">?p(x,P):P}h.exports=d}}),Of=$({</span><span class="s2">&quot;src/utils/text/get-next-non-space-non-comment-character-index-with-start-index.js&quot;</span><span class="s0">(l,h){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;U();</span><span class="s1">var </span><span class="s0">p=Df(),d=Ff(),x=Lf(),{skipSpaces:P}=fo();</span><span class="s1">function </span><span class="s0">m(v,S){let k=</span><span class="s1">null</span><span class="s0">,F=S;</span><span class="s1">for</span><span class="s0">(;F!==k;)k=F,F=P(v,F),F=p(v,F),F=x(v,F),F=d(v,F);</span><span class="s1">return </span><span class="s0">F}h.exports=m}}),mo={};wf(mo,{EOL:()=&gt;ar,arch:()=&gt;Bf,cpus:()=&gt;vo,</span><span class="s1">default</span><span class="s0">:()=&gt;wo,endianness:()=&gt;yo,freemem:()=&gt;Ao,getNetworkInterfaces:()=&gt;So,hostname:()=&gt;xo,loadavg:()=&gt;go,networkInterfaces:()=&gt;bo,platform:()=&gt;Mf,release:()=&gt;Co,tmpDir:()=&gt;rr,tmpdir:()=&gt;ir,totalmem:()=&gt;To,type:()=&gt;Eo,uptime:()=&gt;Po});</span><span class="s1">function </span><span class="s0">yo(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">Ut&gt;</span><span class="s2">&quot;u&quot;</span><span class="s0">){</span><span class="s1">var </span><span class="s0">l=</span><span class="s1">new </span><span class="s0">ArrayBuffer(</span><span class="s3">2</span><span class="s0">),h=</span><span class="s1">new </span><span class="s0">Uint8Array(l),p=</span><span class="s1">new </span><span class="s0">Uint16Array(l);</span><span class="s1">if</span><span class="s0">(h[</span><span class="s3">0</span><span class="s0">]=</span><span class="s3">1</span><span class="s0">,h[</span><span class="s3">1</span><span class="s0">]=</span><span class="s3">2</span><span class="s0">,p[</span><span class="s3">0</span><span class="s0">]===</span><span class="s3">258</span><span class="s0">)Ut=</span><span class="s2">&quot;BE&quot;</span><span class="s0">;</span><span class="s1">else if</span><span class="s0">(p[</span><span class="s3">0</span><span class="s0">]===</span><span class="s3">513</span><span class="s0">)Ut=</span><span class="s2">&quot;LE&quot;</span><span class="s0">;</span><span class="s1">else throw new </span><span class="s0">Error(</span><span class="s2">&quot;unable to figure out endianess&quot;</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">Ut}</span><span class="s1">function </span><span class="s0">xo(){</span><span class="s1">return typeof </span><span class="s0">globalThis.location&lt;</span><span class="s2">&quot;u&quot;</span><span class="s0">?globalThis.location.hostname:</span><span class="s2">&quot;&quot;</span><span class="s0">}</span><span class="s1">function </span><span class="s0">go(){</span><span class="s1">return</span><span class="s0">[]}</span><span class="s1">function </span><span class="s0">Po(){</span><span class="s1">return </span><span class="s3">0</span><span class="s0">}</span><span class="s1">function </span><span class="s0">Ao(){</span><span class="s1">return </span><span class="s0">Number.MAX_VALUE}</span><span class="s1">function </span><span class="s0">To(){</span><span class="s1">return </span><span class="s0">Number.MAX_VALUE}</span><span class="s1">function </span><span class="s0">vo(){</span><span class="s1">return</span><span class="s0">[]}</span><span class="s1">function </span><span class="s0">Eo(){</span><span class="s1">return</span><span class="s2">&quot;Browser&quot;</span><span class="s0">}</span><span class="s1">function </span><span class="s0">Co(){</span><span class="s1">return typeof </span><span class="s0">globalThis.navigator&lt;</span><span class="s2">&quot;u&quot;</span><span class="s0">?globalThis.navigator.appVersion:</span><span class="s2">&quot;&quot;</span><span class="s0">}</span><span class="s1">function </span><span class="s0">bo(){}</span><span class="s1">function </span><span class="s0">So(){}</span><span class="s1">function </span><span class="s0">Bf(){</span><span class="s1">return</span><span class="s2">&quot;javascript&quot;</span><span class="s0">}</span><span class="s1">function </span><span class="s0">Mf(){</span><span class="s1">return</span><span class="s2">&quot;browser&quot;</span><span class="s0">}</span><span class="s1">function </span><span class="s0">rr(){</span><span class="s1">return</span><span class="s2">&quot;/tmp&quot;</span><span class="s0">}</span><span class="s1">var </span><span class="s0">Ut,ir,ar,wo,_f=co({</span><span class="s2">&quot;node-modules-polyfills:os&quot;</span><span class="s0">(){U(),ir=rr,ar=`</span>
<span class="s0">`,wo={EOL:ar,tmpdir:ir,tmpDir:rr,networkInterfaces:bo,getNetworkInterfaces:So,release:Co,type:Eo,cpus:vo,totalmem:To,freemem:Ao,uptime:Po,loadavg:go,hostname:xo,endianness:yo}}}),Rf=$({</span><span class="s2">&quot;node-modules-polyfills-commonjs:os&quot;</span><span class="s0">(l,h){U();</span><span class="s1">var </span><span class="s0">p=(_f(),Nf(mo));</span><span class="s1">if</span><span class="s0">(p&amp;&amp;p.</span><span class="s1">default</span><span class="s0">){h.exports=p.</span><span class="s1">default</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(let d </span><span class="s1">in </span><span class="s0">p)h.exports[d]=p[d]}</span><span class="s1">else </span><span class="s0">p&amp;&amp;(h.exports=p)}}),jf=$({</span><span class="s2">&quot;node_modules/detect-newline/index.js&quot;</span><span class="s0">(l,h){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;U();</span><span class="s1">var </span><span class="s0">p=d=&gt;{</span><span class="s1">if</span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">d!=</span><span class="s2">&quot;string&quot;</span><span class="s0">)</span><span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">&quot;Expected a string&quot;</span><span class="s0">);let x=d.match(/(?:\r?\n)/g)||[];</span><span class="s1">if</span><span class="s0">(x.length===</span><span class="s3">0</span><span class="s0">)</span><span class="s1">return</span><span class="s0">;let P=x.filter(v=&gt;v===`\r</span>
<span class="s0">`).length,m=x.length-P;</span><span class="s1">return </span><span class="s0">P&gt;m?`\r</span>
<span class="s0">`:`</span>
<span class="s0">`};h.exports=p,h.exports.graceful=d=&gt;</span><span class="s1">typeof </span><span class="s0">d==</span><span class="s2">&quot;string&quot;</span><span class="s0">&amp;&amp;p(d)||`</span>
<span class="s0">`}}),qf=$({</span><span class="s2">&quot;node_modules/jest-docblock/build/index.js&quot;</span><span class="s0">(l){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;U(),Object.defineProperty(l,</span><span class="s2">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s3">0</span><span class="s0">}),l.extract=A,l.parse=G,l.parseWithComments=N,l.print=O,l.strip=_;</span><span class="s1">function </span><span class="s0">h(){let R=Rf();</span><span class="s1">return </span><span class="s0">h=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">R},R}</span><span class="s1">function </span><span class="s0">p(){let R=d(jf());</span><span class="s1">return </span><span class="s0">p=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">R},R}</span><span class="s1">function </span><span class="s0">d(R){</span><span class="s1">return </span><span class="s0">R&amp;&amp;R.__esModule?R:{</span><span class="s1">default</span><span class="s0">:R}}</span><span class="s1">var </span><span class="s0">x=/\*\/$/,P=/^\/\*\*?/,m=/^\s*(\/\*\*?(.|\r?\n)*?\*\/)/,v=/(^|\s+)\/\/([^\r\n]*)/g,S=/^(\r?\n)+/,k=/(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g,F=/(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g,w=/(\r?\n|^) *\* ?/g,L=[];</span><span class="s1">function </span><span class="s0">A(R){let z=R.match(m);</span><span class="s1">return </span><span class="s0">z?z[</span><span class="s3">0</span><span class="s0">].trimLeft():</span><span class="s2">&quot;&quot;</span><span class="s0">}</span><span class="s1">function </span><span class="s0">_(R){let z=R.match(m);</span><span class="s1">return </span><span class="s0">z&amp;&amp;z[</span><span class="s3">0</span><span class="s0">]?R.substring(z[</span><span class="s3">0</span><span class="s0">].length):R}</span><span class="s1">function </span><span class="s0">G(R){</span><span class="s1">return </span><span class="s0">N(R).pragmas}</span><span class="s1">function </span><span class="s0">N(R){let z=(</span><span class="s3">0</span><span class="s0">,p().</span><span class="s1">default</span><span class="s0">)(R)||h().EOL;R=R.replace(P,</span><span class="s2">&quot;&quot;</span><span class="s0">).replace(x,</span><span class="s2">&quot;&quot;</span><span class="s0">).replace(w,</span><span class="s2">&quot;$1&quot;</span><span class="s0">);let Q=</span><span class="s2">&quot;&quot;</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(;Q!==R;)Q=R,R=R.replace(k,`${z}$1 $2${z}`);R=R.replace(S,</span><span class="s2">&quot;&quot;</span><span class="s0">).trimRight();let b=Object.create(</span><span class="s1">null</span><span class="s0">),B=R.replace(F,</span><span class="s2">&quot;&quot;</span><span class="s0">).replace(S,</span><span class="s2">&quot;&quot;</span><span class="s0">).trimRight(),Z;</span><span class="s1">for</span><span class="s0">(;Z=F.exec(R);){let q=Z[</span><span class="s3">2</span><span class="s0">].replace(v,</span><span class="s2">&quot;&quot;</span><span class="s0">);</span><span class="s1">typeof </span><span class="s0">b[Z[</span><span class="s3">1</span><span class="s0">]]==</span><span class="s2">&quot;string&quot;</span><span class="s0">||Array.isArray(b[Z[</span><span class="s3">1</span><span class="s0">]])?b[Z[</span><span class="s3">1</span><span class="s0">]]=L.concat(b[Z[</span><span class="s3">1</span><span class="s0">]],q):b[Z[</span><span class="s3">1</span><span class="s0">]]=q}</span><span class="s1">return</span><span class="s0">{comments:B,pragmas:b}}</span><span class="s1">function </span><span class="s0">O(R){let{comments:z=</span><span class="s2">&quot;&quot;</span><span class="s0">,pragmas:Q={}}=R,b=(</span><span class="s3">0</span><span class="s0">,p().</span><span class="s1">default</span><span class="s0">)(z)||h().EOL,B=</span><span class="s2">&quot;/**&quot;</span><span class="s0">,Z=</span><span class="s2">&quot; *&quot;</span><span class="s0">,q=</span><span class="s2">&quot; */&quot;</span><span class="s0">,ue=Object.keys(Q),te=ue.map(se=&gt;H(se,Q[se])).reduce((se,He)=&gt;se.concat(He),[]).map(se=&gt;`${Z} ${se}${b}`).join(</span><span class="s2">&quot;&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(!z){</span><span class="s1">if</span><span class="s0">(ue.length===</span><span class="s3">0</span><span class="s0">)</span><span class="s1">return</span><span class="s2">&quot;&quot;</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(ue.length===</span><span class="s3">1</span><span class="s0">&amp;&amp;!Array.isArray(Q[ue[</span><span class="s3">0</span><span class="s0">]])){let se=Q[ue[</span><span class="s3">0</span><span class="s0">]];</span><span class="s1">return</span><span class="s0">`${B} ${H(ue[</span><span class="s3">0</span><span class="s0">],se)[</span><span class="s3">0</span><span class="s0">]}${q}`}}let it=z.split(b).map(se=&gt;`${Z} ${se}`).join(b)+b;</span><span class="s1">return </span><span class="s0">B+b+(z?it:</span><span class="s2">&quot;&quot;</span><span class="s0">)+(z&amp;&amp;ue.length?Z+b:</span><span class="s2">&quot;&quot;</span><span class="s0">)+te+q}</span><span class="s1">function </span><span class="s0">H(R,z){</span><span class="s1">return </span><span class="s0">L.concat(z).map(Q=&gt;`@${R} ${Q}`.trim())}}}),Uf=$({</span><span class="s2">&quot;src/common/end-of-line.js&quot;</span><span class="s0">(l,h){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;U();</span><span class="s1">function </span><span class="s0">p(m){let v=m.indexOf(</span><span class="s2">&quot;</span><span class="s4">\r</span><span class="s2">&quot;</span><span class="s0">);</span><span class="s1">return </span><span class="s0">v&gt;=</span><span class="s3">0</span><span class="s0">?m.charAt(v+</span><span class="s3">1</span><span class="s0">)===`</span>
<span class="s0">`?</span><span class="s2">&quot;crlf&quot;</span><span class="s0">:</span><span class="s2">&quot;cr&quot;</span><span class="s0">:</span><span class="s2">&quot;lf&quot;</span><span class="s0">}</span><span class="s1">function </span><span class="s0">d(m){</span><span class="s1">switch</span><span class="s0">(m){</span><span class="s1">case</span><span class="s2">&quot;cr&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s2">&quot;</span><span class="s4">\r</span><span class="s2">&quot;</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;crlf&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s0">`\r</span>
<span class="s0">`;</span><span class="s1">default</span><span class="s0">:</span><span class="s1">return</span><span class="s0">`</span>
<span class="s0">`}}</span><span class="s1">function </span><span class="s0">x(m,v){let S;</span><span class="s1">switch</span><span class="s0">(v){</span><span class="s1">case</span><span class="s0">`</span>
<span class="s0">`:S=/\n/g;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;</span><span class="s4">\r</span><span class="s2">&quot;</span><span class="s0">:S=/\r/g;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s0">`\r</span>
<span class="s0">`:S=/\r\n/g;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">default</span><span class="s0">:</span><span class="s1">throw new </span><span class="s0">Error(`Unexpected </span><span class="s2">&quot;eol&quot; </span><span class="s0">${JSON.stringify(v)}.`)}let k=m.match(S);</span><span class="s1">return </span><span class="s0">k?k.length:</span><span class="s3">0</span><span class="s0">}</span><span class="s1">function </span><span class="s0">P(m){</span><span class="s1">return </span><span class="s0">m.replace(/\r\n?/g,`</span>
<span class="s0">`)}h.exports={guessEndOfLine:p,convertEndOfLineToChars:d,countEndOfLineChars:x,normalizeEndOfLine:P}}}),$f=$({</span><span class="s2">&quot;src/language-js/pragma.js&quot;</span><span class="s0">(l,h){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;U();</span><span class="s1">var</span><span class="s0">{parseWithComments:p,strip:d,extract:x,print:P}=qf(),{normalizeEndOfLine:m}=Uf(),v=po();</span><span class="s1">function </span><span class="s0">S(w){let L=v(w);L&amp;&amp;(w=w.slice(L.length+</span><span class="s3">1</span><span class="s0">));let A=x(w),{pragmas:_,comments:G}=p(A);</span><span class="s1">return</span><span class="s0">{shebang:L,text:w,pragmas:_,comments:G}}</span><span class="s1">function </span><span class="s0">k(w){let L=Object.keys(S(w).pragmas);</span><span class="s1">return </span><span class="s0">L.includes(</span><span class="s2">&quot;prettier&quot;</span><span class="s0">)||L.includes(</span><span class="s2">&quot;format&quot;</span><span class="s0">)}</span><span class="s1">function </span><span class="s0">F(w){let{shebang:L,text:A,pragmas:_,comments:G}=S(w),N=d(A),O=P({pragmas:Object.assign({format:</span><span class="s2">&quot;&quot;</span><span class="s0">},_),comments:G.trimStart()});</span><span class="s1">return</span><span class="s0">(L?`${L}</span>
<span class="s0">`:</span><span class="s2">&quot;&quot;</span><span class="s0">)+m(O)+(N.startsWith(`</span>
<span class="s0">`)?`</span>
<span class="s0">`:`</span>

<span class="s0">`)+N}h.exports={hasPragma:k,insertPragma:F}}}),Io=$({</span><span class="s2">&quot;src/utils/is-non-empty-array.js&quot;</span><span class="s0">(l,h){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;U();</span><span class="s1">function </span><span class="s0">p(d){</span><span class="s1">return </span><span class="s0">Array.isArray(d)&amp;&amp;d.length&gt;</span><span class="s3">0</span><span class="s0">}h.exports=p}}),No=$({</span><span class="s2">&quot;src/language-js/loc.js&quot;</span><span class="s0">(l,h){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;U();</span><span class="s1">var </span><span class="s0">p=Io();</span><span class="s1">function </span><span class="s0">d(S){</span><span class="s1">var </span><span class="s0">k,F;let w=S.range?S.range[</span><span class="s3">0</span><span class="s0">]:S.start,L=(k=(F=S.declaration)===</span><span class="s1">null</span><span class="s0">||F===</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?</span><span class="s1">void </span><span class="s3">0</span><span class="s0">:F.decorators)!==</span><span class="s1">null</span><span class="s0">&amp;&amp;k!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?k:S.decorators;</span><span class="s1">return </span><span class="s0">p(L)?Math.min(d(L[</span><span class="s3">0</span><span class="s0">]),w):w}</span><span class="s1">function </span><span class="s0">x(S){</span><span class="s1">return </span><span class="s0">S.range?S.range[</span><span class="s3">1</span><span class="s0">]:S.end}</span><span class="s1">function </span><span class="s0">P(S,k){let F=d(S);</span><span class="s1">return </span><span class="s0">Number.isInteger(F)&amp;&amp;F===d(k)}</span><span class="s1">function </span><span class="s0">m(S,k){let F=x(S);</span><span class="s1">return </span><span class="s0">Number.isInteger(F)&amp;&amp;F===x(k)}</span><span class="s1">function </span><span class="s0">v(S,k){</span><span class="s1">return </span><span class="s0">P(S,k)&amp;&amp;m(S,k)}h.exports={locStart:d,locEnd:x,hasSameLocStart:P,hasSameLoc:v}}}),ko=$({</span><span class="s2">&quot;src/language-js/parse/utils/create-parser.js&quot;</span><span class="s0">(l,h){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;U();</span><span class="s1">var</span><span class="s0">{hasPragma:p}=$f(),{locStart:d,locEnd:x}=No();</span><span class="s1">function </span><span class="s0">P(m){</span><span class="s1">return </span><span class="s0">m=</span><span class="s1">typeof </span><span class="s0">m==</span><span class="s2">&quot;function&quot;</span><span class="s0">?{parse:m}:m,Object.assign({astFormat:</span><span class="s2">&quot;estree&quot;</span><span class="s0">,hasPragma:p,locStart:d,locEnd:x},m)}h.exports=P}}),lr=$({</span><span class="s2">&quot;src/common/parser-create-error.js&quot;</span><span class="s0">(l,h){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;U();</span><span class="s1">function </span><span class="s0">p(d,x){let P=</span><span class="s1">new </span><span class="s0">SyntaxError(d+</span><span class="s2">&quot; (&quot;</span><span class="s0">+x.start.line+</span><span class="s2">&quot;:&quot;</span><span class="s0">+x.start.column+</span><span class="s2">&quot;)&quot;</span><span class="s0">);</span><span class="s1">return </span><span class="s0">P.loc=x,P}h.exports=p}}),Do=$({</span><span class="s2">&quot;src/language-js/parse/utils/create-babel-parse-error.js&quot;</span><span class="s0">(l,h){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;U();</span><span class="s1">var </span><span class="s0">p=lr();</span><span class="s1">function </span><span class="s0">d(x){let{message:P,loc:m}=x;</span><span class="s1">return </span><span class="s0">p(P.replace(/ \(.*\)/,</span><span class="s2">&quot;&quot;</span><span class="s0">),{start:{line:m?m.line:</span><span class="s3">0</span><span class="s0">,column:m?m.column+</span><span class="s3">1</span><span class="s0">:</span><span class="s3">0</span><span class="s0">}})}h.exports=d}}),Hf=$({</span><span class="s2">&quot;src/language-js/utils/is-ts-keyword-type.js&quot;</span><span class="s0">(l,h){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;U();</span><span class="s1">function </span><span class="s0">p(d){let{type:x}=d;</span><span class="s1">return </span><span class="s0">x.startsWith(</span><span class="s2">&quot;TS&quot;</span><span class="s0">)&amp;&amp;x.endsWith(</span><span class="s2">&quot;Keyword&quot;</span><span class="s0">)}h.exports=p}}),zf=$({</span><span class="s2">&quot;src/language-js/utils/is-block-comment.js&quot;</span><span class="s0">(l,h){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;U();</span><span class="s1">var </span><span class="s0">p=</span><span class="s1">new </span><span class="s0">Set([</span><span class="s2">&quot;Block&quot;</span><span class="s0">,</span><span class="s2">&quot;CommentBlock&quot;</span><span class="s0">,</span><span class="s2">&quot;MultiLine&quot;</span><span class="s0">]),d=x=&gt;p.has(x==</span><span class="s1">null</span><span class="s0">?</span><span class="s1">void </span><span class="s3">0</span><span class="s0">:x.type);h.exports=d}}),Vf=$({</span><span class="s2">&quot;src/language-js/utils/is-type-cast-comment.js&quot;</span><span class="s0">(l,h){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;U();</span><span class="s1">var </span><span class="s0">p=zf();</span><span class="s1">function </span><span class="s0">d(x){</span><span class="s1">return </span><span class="s0">p(x)&amp;&amp;x.value[</span><span class="s3">0</span><span class="s0">]===</span><span class="s2">&quot;*&quot;</span><span class="s0">&amp;&amp;/@(?:type|satisfies)\b/.test(x.value)}h.exports=d}}),Kf=$({</span><span class="s2">&quot;src/utils/get-last.js&quot;</span><span class="s0">(l,h){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;U();</span><span class="s1">var </span><span class="s0">p=d=&gt;d[d.length-1];h.exports=p}}),Wf=$({</span><span class="s2">&quot;src/language-js/parse/postprocess/visit-node.js&quot;</span><span class="s0">(l,h){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;U();</span><span class="s1">function </span><span class="s0">p(d,x){</span><span class="s1">if</span><span class="s0">(Array.isArray(d)){</span><span class="s1">for</span><span class="s0">(let P=</span><span class="s3">0</span><span class="s0">;P&lt;d.length;P++)d[P]=p(d[P],x);</span><span class="s1">return </span><span class="s0">d}</span><span class="s1">if</span><span class="s0">(d&amp;&amp;</span><span class="s1">typeof </span><span class="s0">d==</span><span class="s2">&quot;object&quot;</span><span class="s0">&amp;&amp;</span><span class="s1">typeof </span><span class="s0">d.type==</span><span class="s2">&quot;string&quot;</span><span class="s0">){let P=Object.keys(d);</span><span class="s1">for</span><span class="s0">(let m=</span><span class="s3">0</span><span class="s0">;m&lt;P.length;m++)d[P[m]]=p(d[P[m]],x);</span><span class="s1">return </span><span class="s0">x(d)||d}</span><span class="s1">return </span><span class="s0">d}h.exports=p}}),Gf=$({</span><span class="s2">&quot;src/language-js/parse/postprocess/throw-syntax-error.js&quot;</span><span class="s0">(l,h){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;U();</span><span class="s1">var </span><span class="s0">p=lr();</span><span class="s1">function </span><span class="s0">d(x,P){let{start:m,end:v}=x.loc;</span><span class="s1">throw </span><span class="s0">p(P,{start:{line:m.line,column:m.column+</span><span class="s3">1</span><span class="s0">},end:{line:v.line,column:v.column+</span><span class="s3">1</span><span class="s0">}})}h.exports=d}}),Jf=$({</span><span class="s2">&quot;src/language-js/parse/postprocess/index.js&quot;</span><span class="s0">(l,h){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;U();</span><span class="s1">var</span><span class="s0">{locStart:p,locEnd:d}=No(),x=Hf(),P=Vf(),m=Kf(),v=Wf(),S=Gf();</span><span class="s1">function </span><span class="s0">k(A,_){</span><span class="s1">if</span><span class="s0">(_.parser!==</span><span class="s2">&quot;typescript&quot;</span><span class="s0">&amp;&amp;_.parser!==</span><span class="s2">&quot;flow&quot;</span><span class="s0">&amp;&amp;_.parser!==</span><span class="s2">&quot;acorn&quot;</span><span class="s0">&amp;&amp;_.parser!==</span><span class="s2">&quot;espree&quot;</span><span class="s0">&amp;&amp;_.parser!==</span><span class="s2">&quot;meriyah&quot;</span><span class="s0">){let N=</span><span class="s1">new </span><span class="s0">Set;A=v(A,O=&gt;{O.leadingComments&amp;&amp;O.leadingComments.some(P)&amp;&amp;N.add(p(O))}),A=v(A,O=&gt;{</span><span class="s1">if</span><span class="s0">(O.type===</span><span class="s2">&quot;ParenthesizedExpression&quot;</span><span class="s0">){let{expression:H}=O;</span><span class="s1">if</span><span class="s0">(H.type===</span><span class="s2">&quot;TypeCastExpression&quot;</span><span class="s0">)</span><span class="s1">return </span><span class="s0">H.range=O.range,H;let R=p(O);</span><span class="s1">if</span><span class="s0">(!N.has(R))</span><span class="s1">return </span><span class="s0">H.extra=Object.assign(Object.assign({},H.extra),{},{parenthesized:!</span><span class="s3">0</span><span class="s0">}),H}})}</span><span class="s1">return </span><span class="s0">A=v(A,N=&gt;{</span><span class="s1">switch</span><span class="s0">(N.type){</span><span class="s1">case</span><span class="s2">&quot;ChainExpression&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">F(N.expression);</span><span class="s1">case</span><span class="s2">&quot;LogicalExpression&quot;</span><span class="s0">:{</span><span class="s1">if</span><span class="s0">(w(N))</span><span class="s1">return </span><span class="s0">L(N);</span><span class="s1">break</span><span class="s0">}</span><span class="s1">case</span><span class="s2">&quot;VariableDeclaration&quot;</span><span class="s0">:{let O=m(N.declarations);O&amp;&amp;O.init&amp;&amp;G(N,O);</span><span class="s1">break</span><span class="s0">}</span><span class="s1">case</span><span class="s2">&quot;TSParenthesizedType&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">x(N.typeAnnotation)||N.typeAnnotation.type===</span><span class="s2">&quot;TSThisType&quot;</span><span class="s0">||(N.typeAnnotation.range=[p(N),d(N)]),N.typeAnnotation;</span><span class="s1">case</span><span class="s2">&quot;TSTypeParameter&quot;</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">N.name==</span><span class="s2">&quot;string&quot;</span><span class="s0">){let O=p(N);N.name={type:</span><span class="s2">&quot;Identifier&quot;</span><span class="s0">,name:N.name,range:[O,O+N.name.length]}}</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;ObjectExpression&quot;</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(_.parser===</span><span class="s2">&quot;typescript&quot;</span><span class="s0">){let O=N.properties.find(H=&gt;H.type===</span><span class="s2">&quot;Property&quot;</span><span class="s0">&amp;&amp;H.value.type===</span><span class="s2">&quot;TSEmptyBodyFunctionExpression&quot;</span><span class="s0">);O&amp;&amp;S(O.value,</span><span class="s2">&quot;Unexpected token.&quot;</span><span class="s0">)}</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;SequenceExpression&quot;</span><span class="s0">:{let O=m(N.expressions);N.range=[p(N),Math.min(d(O),d(N))];</span><span class="s1">break</span><span class="s0">}</span><span class="s1">case</span><span class="s2">&quot;TopicReference&quot;</span><span class="s0">:_.__isUsingHackPipeline=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;ExportAllDeclaration&quot;</span><span class="s0">:{let{exported:O}=N;</span><span class="s1">if</span><span class="s0">(_.parser===</span><span class="s2">&quot;meriyah&quot;</span><span class="s0">&amp;&amp;O&amp;&amp;O.type===</span><span class="s2">&quot;Identifier&quot;</span><span class="s0">){let H=_.originalText.slice(p(O),d(O));(H.startsWith(</span><span class="s2">'&quot;'</span><span class="s0">)||H.startsWith(</span><span class="s2">&quot;'&quot;</span><span class="s0">))&amp;&amp;(N.exported=Object.assign(Object.assign({},N.exported),{},{type:</span><span class="s2">&quot;Literal&quot;</span><span class="s0">,value:N.exported.name,raw:H}))}</span><span class="s1">break</span><span class="s0">}</span><span class="s1">case</span><span class="s2">&quot;PropertyDefinition&quot;</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(_.parser===</span><span class="s2">&quot;meriyah&quot;</span><span class="s0">&amp;&amp;N.static&amp;&amp;!N.computed&amp;&amp;!N.key){let O=</span><span class="s2">&quot;static&quot;</span><span class="s0">,H=p(N);Object.assign(N,{static:!</span><span class="s3">1</span><span class="s0">,key:{type:</span><span class="s2">&quot;Identifier&quot;</span><span class="s0">,name:O,range:[H,H+O.length]}})}</span><span class="s1">break</span><span class="s0">}}),A;</span><span class="s1">function </span><span class="s0">G(N,O){_.originalText[d(O)]!==</span><span class="s2">&quot;;&quot;</span><span class="s0">&amp;&amp;(N.range=[p(N),d(O)])}}</span><span class="s1">function </span><span class="s0">F(A){</span><span class="s1">switch</span><span class="s0">(A.type){</span><span class="s1">case</span><span class="s2">&quot;CallExpression&quot;</span><span class="s0">:A.type=</span><span class="s2">&quot;OptionalCallExpression&quot;</span><span class="s0">,A.callee=F(A.callee);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;MemberExpression&quot;</span><span class="s0">:A.type=</span><span class="s2">&quot;OptionalMemberExpression&quot;</span><span class="s0">,A.object=F(A.object);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;TSNonNullExpression&quot;</span><span class="s0">:A.expression=F(A.expression);</span><span class="s1">break</span><span class="s0">}</span><span class="s1">return </span><span class="s0">A}</span><span class="s1">function </span><span class="s0">w(A){</span><span class="s1">return </span><span class="s0">A.type===</span><span class="s2">&quot;LogicalExpression&quot;</span><span class="s0">&amp;&amp;A.right.type===</span><span class="s2">&quot;LogicalExpression&quot;</span><span class="s0">&amp;&amp;A.operator===A.right.operator}</span><span class="s1">function </span><span class="s0">L(A){</span><span class="s1">return </span><span class="s0">w(A)?L({type:</span><span class="s2">&quot;LogicalExpression&quot;</span><span class="s0">,operator:A.operator,left:L({type:</span><span class="s2">&quot;LogicalExpression&quot;</span><span class="s0">,operator:A.operator,left:A.left,right:A.right.left,range:[p(A.left),d(A.right.left)]}),right:A.right.right,range:[p(A),d(A)]}):A}h.exports=k}}),Fo=$({</span><span class="s2">&quot;node_modules/@babel/parser/lib/index.js&quot;</span><span class="s0">(l){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;U(),Object.defineProperty(l,</span><span class="s2">&quot;__esModule&quot;</span><span class="s0">,{value:!</span><span class="s3">0</span><span class="s0">});</span><span class="s1">var </span><span class="s0">h={sourceType:</span><span class="s2">&quot;script&quot;</span><span class="s0">,sourceFilename:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,startColumn:</span><span class="s3">0</span><span class="s0">,startLine:</span><span class="s3">1</span><span class="s0">,allowAwaitOutsideFunction:!</span><span class="s3">1</span><span class="s0">,allowReturnOutsideFunction:!</span><span class="s3">1</span><span class="s0">,allowNewTargetOutsideFunction:!</span><span class="s3">1</span><span class="s0">,allowImportExportEverywhere:!</span><span class="s3">1</span><span class="s0">,allowSuperOutsideMethod:!</span><span class="s3">1</span><span class="s0">,allowUndeclaredExports:!</span><span class="s3">1</span><span class="s0">,plugins:[],strictMode:</span><span class="s1">null</span><span class="s0">,ranges:!</span><span class="s3">1</span><span class="s0">,tokens:!</span><span class="s3">1</span><span class="s0">,createParenthesizedExpressions:!</span><span class="s3">1</span><span class="s0">,errorRecovery:!</span><span class="s3">1</span><span class="s0">,attachComment:!</span><span class="s3">0</span><span class="s0">,annexB:!</span><span class="s3">0</span><span class="s0">};</span><span class="s1">function </span><span class="s0">p(t){</span><span class="s1">if</span><span class="s0">(t&amp;&amp;t.annexB!=</span><span class="s1">null</span><span class="s0">&amp;&amp;t.annexB!==!</span><span class="s3">1</span><span class="s0">)</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;The `annexB` option can only be set to `false`.&quot;</span><span class="s0">);let r={};</span><span class="s1">for</span><span class="s0">(let e of Object.keys(h))r[e]=t&amp;&amp;t[e]!=</span><span class="s1">null</span><span class="s0">?t[e]:h[e];</span><span class="s1">return </span><span class="s0">r}</span><span class="s1">var </span><span class="s0">d=class{constructor(t,r){</span><span class="s1">this</span><span class="s0">.token=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.preserveSpace=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.token=t,</span><span class="s1">this</span><span class="s0">.preserveSpace=!!r}},x={brace:</span><span class="s1">new </span><span class="s0">d(</span><span class="s2">&quot;{&quot;</span><span class="s0">),j_oTag:</span><span class="s1">new </span><span class="s0">d(</span><span class="s2">&quot;&lt;tag&quot;</span><span class="s0">),j_cTag:</span><span class="s1">new </span><span class="s0">d(</span><span class="s2">&quot;&lt;/tag&quot;</span><span class="s0">),j_expr:</span><span class="s1">new </span><span class="s0">d(</span><span class="s2">&quot;&lt;tag&gt;...&lt;/tag&gt;&quot;</span><span class="s0">,!</span><span class="s3">0</span><span class="s0">)};x.template=</span><span class="s1">new </span><span class="s0">d(</span><span class="s2">&quot;`&quot;</span><span class="s0">,!</span><span class="s3">0</span><span class="s0">);</span><span class="s1">var </span><span class="s0">P=!</span><span class="s3">0</span><span class="s0">,m=!</span><span class="s3">0</span><span class="s0">,v=!</span><span class="s3">0</span><span class="s0">,S=!</span><span class="s3">0</span><span class="s0">,k=!</span><span class="s3">0</span><span class="s0">,F=!</span><span class="s3">0</span><span class="s0">,w=class{constructor(t){let r=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">1</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">1</span><span class="s0">]:{};</span><span class="s1">this</span><span class="s0">.label=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.keyword=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.beforeExpr=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.startsExpr=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.rightAssociative=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.isLoop=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.isAssign=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.prefix=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.postfix=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.binop=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.label=t,</span><span class="s1">this</span><span class="s0">.keyword=r.keyword,</span><span class="s1">this</span><span class="s0">.beforeExpr=!!r.beforeExpr,</span><span class="s1">this</span><span class="s0">.startsExpr=!!r.startsExpr,</span><span class="s1">this</span><span class="s0">.rightAssociative=!!r.rightAssociative,</span><span class="s1">this</span><span class="s0">.isLoop=!!r.isLoop,</span><span class="s1">this</span><span class="s0">.isAssign=!!r.isAssign,</span><span class="s1">this</span><span class="s0">.prefix=!!r.prefix,</span><span class="s1">this</span><span class="s0">.postfix=!!r.postfix,</span><span class="s1">this</span><span class="s0">.binop=r.binop!=</span><span class="s1">null</span><span class="s0">?r.binop:</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.updateContext=</span><span class="s1">null</span><span class="s0">}},L=</span><span class="s1">new </span><span class="s0">Map;</span><span class="s1">function </span><span class="s0">A(t){let r=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">1</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">1</span><span class="s0">]:{};r.keyword=t;let e=b(t,r);</span><span class="s1">return </span><span class="s0">L.set(t,e),e}</span><span class="s1">function </span><span class="s0">_(t,r){</span><span class="s1">return </span><span class="s0">b(t,{beforeExpr:P,binop:r})}</span><span class="s1">var </span><span class="s0">G=-</span><span class="s3">1</span><span class="s0">,N=[],O=[],H=[],R=[],z=[],Q=[];</span><span class="s1">function </span><span class="s0">b(t){let r=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">1</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">1</span><span class="s0">]:{};</span><span class="s1">var </span><span class="s0">e,s,i,a;</span><span class="s1">return</span><span class="s0">++G,O.push(t),H.push((e=r.binop)!=</span><span class="s1">null</span><span class="s0">?e:-</span><span class="s3">1</span><span class="s0">),R.push((s=r.beforeExpr)!=</span><span class="s1">null</span><span class="s0">?s:!</span><span class="s3">1</span><span class="s0">),z.push((i=r.startsExpr)!=</span><span class="s1">null</span><span class="s0">?i:!</span><span class="s3">1</span><span class="s0">),Q.push((a=r.prefix)!=</span><span class="s1">null</span><span class="s0">?a:!</span><span class="s3">1</span><span class="s0">),N.push(</span><span class="s1">new </span><span class="s0">w(t,r)),G}</span><span class="s1">function </span><span class="s0">B(t){let r=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">1</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">1</span><span class="s0">]:{};</span><span class="s1">var </span><span class="s0">e,s,i,a;</span><span class="s1">return</span><span class="s0">++G,L.set(t,G),O.push(t),H.push((e=r.binop)!=</span><span class="s1">null</span><span class="s0">?e:-</span><span class="s3">1</span><span class="s0">),R.push((s=r.beforeExpr)!=</span><span class="s1">null</span><span class="s0">?s:!</span><span class="s3">1</span><span class="s0">),z.push((i=r.startsExpr)!=</span><span class="s1">null</span><span class="s0">?i:!</span><span class="s3">1</span><span class="s0">),Q.push((a=r.prefix)!=</span><span class="s1">null</span><span class="s0">?a:!</span><span class="s3">1</span><span class="s0">),N.push(</span><span class="s1">new </span><span class="s0">w(</span><span class="s2">&quot;name&quot;</span><span class="s0">,r)),G}</span><span class="s1">var </span><span class="s0">Z={bracketL:b(</span><span class="s2">&quot;[&quot;</span><span class="s0">,{beforeExpr:P,startsExpr:m}),bracketHashL:b(</span><span class="s2">&quot;#[&quot;</span><span class="s0">,{beforeExpr:P,startsExpr:m}),bracketBarL:b(</span><span class="s2">&quot;[|&quot;</span><span class="s0">,{beforeExpr:P,startsExpr:m}),bracketR:b(</span><span class="s2">&quot;]&quot;</span><span class="s0">),bracketBarR:b(</span><span class="s2">&quot;|]&quot;</span><span class="s0">),braceL:b(</span><span class="s2">&quot;{&quot;</span><span class="s0">,{beforeExpr:P,startsExpr:m}),braceBarL:b(</span><span class="s2">&quot;{|&quot;</span><span class="s0">,{beforeExpr:P,startsExpr:m}),braceHashL:b(</span><span class="s2">&quot;#{&quot;</span><span class="s0">,{beforeExpr:P,startsExpr:m}),braceR:b(</span><span class="s2">&quot;}&quot;</span><span class="s0">),braceBarR:b(</span><span class="s2">&quot;|}&quot;</span><span class="s0">),parenL:b(</span><span class="s2">&quot;(&quot;</span><span class="s0">,{beforeExpr:P,startsExpr:m}),parenR:b(</span><span class="s2">&quot;)&quot;</span><span class="s0">),comma:b(</span><span class="s2">&quot;,&quot;</span><span class="s0">,{beforeExpr:P}),semi:b(</span><span class="s2">&quot;;&quot;</span><span class="s0">,{beforeExpr:P}),colon:b(</span><span class="s2">&quot;:&quot;</span><span class="s0">,{beforeExpr:P}),doubleColon:b(</span><span class="s2">&quot;::&quot;</span><span class="s0">,{beforeExpr:P}),dot:b(</span><span class="s2">&quot;.&quot;</span><span class="s0">),question:b(</span><span class="s2">&quot;?&quot;</span><span class="s0">,{beforeExpr:P}),questionDot:b(</span><span class="s2">&quot;?.&quot;</span><span class="s0">),arrow:b(</span><span class="s2">&quot;=&gt;&quot;</span><span class="s0">,{beforeExpr:P}),template:b(</span><span class="s2">&quot;template&quot;</span><span class="s0">),ellipsis:b(</span><span class="s2">&quot;...&quot;</span><span class="s0">,{beforeExpr:P}),backQuote:b(</span><span class="s2">&quot;`&quot;</span><span class="s0">,{startsExpr:m}),dollarBraceL:b(</span><span class="s2">&quot;${&quot;</span><span class="s0">,{beforeExpr:P,startsExpr:m}),templateTail:b(</span><span class="s2">&quot;...`&quot;</span><span class="s0">,{startsExpr:m}),templateNonTail:b(</span><span class="s2">&quot;...${&quot;</span><span class="s0">,{beforeExpr:P,startsExpr:m}),at:b(</span><span class="s2">&quot;@&quot;</span><span class="s0">),hash:b(</span><span class="s2">&quot;#&quot;</span><span class="s0">,{startsExpr:m}),interpreterDirective:b(</span><span class="s2">&quot;#!...&quot;</span><span class="s0">),eq:b(</span><span class="s2">&quot;=&quot;</span><span class="s0">,{beforeExpr:P,isAssign:S}),assign:b(</span><span class="s2">&quot;_=&quot;</span><span class="s0">,{beforeExpr:P,isAssign:S}),slashAssign:b(</span><span class="s2">&quot;_=&quot;</span><span class="s0">,{beforeExpr:P,isAssign:S}),xorAssign:b(</span><span class="s2">&quot;_=&quot;</span><span class="s0">,{beforeExpr:P,isAssign:S}),moduloAssign:b(</span><span class="s2">&quot;_=&quot;</span><span class="s0">,{beforeExpr:P,isAssign:S}),incDec:b(</span><span class="s2">&quot;++/--&quot;</span><span class="s0">,{prefix:k,postfix:F,startsExpr:m}),bang:b(</span><span class="s2">&quot;!&quot;</span><span class="s0">,{beforeExpr:P,prefix:k,startsExpr:m}),tilde:b(</span><span class="s2">&quot;~&quot;</span><span class="s0">,{beforeExpr:P,prefix:k,startsExpr:m}),doubleCaret:b(</span><span class="s2">&quot;^^&quot;</span><span class="s0">,{startsExpr:m}),doubleAt:b(</span><span class="s2">&quot;@@&quot;</span><span class="s0">,{startsExpr:m}),pipeline:_(</span><span class="s2">&quot;|&gt;&quot;</span><span class="s0">,</span><span class="s3">0</span><span class="s0">),nullishCoalescing:_(</span><span class="s2">&quot;??&quot;</span><span class="s0">,</span><span class="s3">1</span><span class="s0">),logicalOR:_(</span><span class="s2">&quot;||&quot;</span><span class="s0">,</span><span class="s3">1</span><span class="s0">),logicalAND:_(</span><span class="s2">&quot;&amp;&amp;&quot;</span><span class="s0">,</span><span class="s3">2</span><span class="s0">),bitwiseOR:_(</span><span class="s2">&quot;|&quot;</span><span class="s0">,</span><span class="s3">3</span><span class="s0">),bitwiseXOR:_(</span><span class="s2">&quot;^&quot;</span><span class="s0">,</span><span class="s3">4</span><span class="s0">),bitwiseAND:_(</span><span class="s2">&quot;&amp;&quot;</span><span class="s0">,</span><span class="s3">5</span><span class="s0">),equality:_(</span><span class="s2">&quot;==/!=/===/!==&quot;</span><span class="s0">,</span><span class="s3">6</span><span class="s0">),lt:_(</span><span class="s2">&quot;&lt;/&gt;/&lt;=/&gt;=&quot;</span><span class="s0">,</span><span class="s3">7</span><span class="s0">),gt:_(</span><span class="s2">&quot;&lt;/&gt;/&lt;=/&gt;=&quot;</span><span class="s0">,</span><span class="s3">7</span><span class="s0">),relational:_(</span><span class="s2">&quot;&lt;/&gt;/&lt;=/&gt;=&quot;</span><span class="s0">,</span><span class="s3">7</span><span class="s0">),bitShift:_(</span><span class="s2">&quot;&lt;&lt;/&gt;&gt;/&gt;&gt;&gt;&quot;</span><span class="s0">,</span><span class="s3">8</span><span class="s0">),bitShiftL:_(</span><span class="s2">&quot;&lt;&lt;/&gt;&gt;/&gt;&gt;&gt;&quot;</span><span class="s0">,</span><span class="s3">8</span><span class="s0">),bitShiftR:_(</span><span class="s2">&quot;&lt;&lt;/&gt;&gt;/&gt;&gt;&gt;&quot;</span><span class="s0">,</span><span class="s3">8</span><span class="s0">),plusMin:b(</span><span class="s2">&quot;+/-&quot;</span><span class="s0">,{beforeExpr:P,binop:</span><span class="s3">9</span><span class="s0">,prefix:k,startsExpr:m}),modulo:b(</span><span class="s2">&quot;%&quot;</span><span class="s0">,{binop:</span><span class="s3">10</span><span class="s0">,startsExpr:m}),star:b(</span><span class="s2">&quot;*&quot;</span><span class="s0">,{binop:</span><span class="s3">10</span><span class="s0">}),slash:_(</span><span class="s2">&quot;/&quot;</span><span class="s0">,</span><span class="s3">10</span><span class="s0">),exponent:b(</span><span class="s2">&quot;**&quot;</span><span class="s0">,{beforeExpr:P,binop:</span><span class="s3">11</span><span class="s0">,rightAssociative:!</span><span class="s3">0</span><span class="s0">}),_in:A(</span><span class="s2">&quot;in&quot;</span><span class="s0">,{beforeExpr:P,binop:</span><span class="s3">7</span><span class="s0">}),_instanceof:A(</span><span class="s2">&quot;instanceof&quot;</span><span class="s0">,{beforeExpr:P,binop:</span><span class="s3">7</span><span class="s0">}),_break:A(</span><span class="s2">&quot;break&quot;</span><span class="s0">),_case:A(</span><span class="s2">&quot;case&quot;</span><span class="s0">,{beforeExpr:P}),_catch:A(</span><span class="s2">&quot;catch&quot;</span><span class="s0">),_continue:A(</span><span class="s2">&quot;continue&quot;</span><span class="s0">),_debugger:A(</span><span class="s2">&quot;debugger&quot;</span><span class="s0">),_default:A(</span><span class="s2">&quot;default&quot;</span><span class="s0">,{beforeExpr:P}),_else:A(</span><span class="s2">&quot;else&quot;</span><span class="s0">,{beforeExpr:P}),_finally:A(</span><span class="s2">&quot;finally&quot;</span><span class="s0">),_function:A(</span><span class="s2">&quot;function&quot;</span><span class="s0">,{startsExpr:m}),_if:A(</span><span class="s2">&quot;if&quot;</span><span class="s0">),_return:A(</span><span class="s2">&quot;return&quot;</span><span class="s0">,{beforeExpr:P}),_switch:A(</span><span class="s2">&quot;switch&quot;</span><span class="s0">),_throw:A(</span><span class="s2">&quot;throw&quot;</span><span class="s0">,{beforeExpr:P,prefix:k,startsExpr:m}),_try:A(</span><span class="s2">&quot;try&quot;</span><span class="s0">),_var:A(</span><span class="s2">&quot;var&quot;</span><span class="s0">),_const:A(</span><span class="s2">&quot;const&quot;</span><span class="s0">),_with:A(</span><span class="s2">&quot;with&quot;</span><span class="s0">),_new:A(</span><span class="s2">&quot;new&quot;</span><span class="s0">,{beforeExpr:P,startsExpr:m}),_this:A(</span><span class="s2">&quot;this&quot;</span><span class="s0">,{startsExpr:m}),_super:A(</span><span class="s2">&quot;super&quot;</span><span class="s0">,{startsExpr:m}),_class:A(</span><span class="s2">&quot;class&quot;</span><span class="s0">,{startsExpr:m}),_extends:A(</span><span class="s2">&quot;extends&quot;</span><span class="s0">,{beforeExpr:P}),_export:A(</span><span class="s2">&quot;export&quot;</span><span class="s0">),_import:A(</span><span class="s2">&quot;import&quot;</span><span class="s0">,{startsExpr:m}),_null:A(</span><span class="s2">&quot;null&quot;</span><span class="s0">,{startsExpr:m}),_true:A(</span><span class="s2">&quot;true&quot;</span><span class="s0">,{startsExpr:m}),_false:A(</span><span class="s2">&quot;false&quot;</span><span class="s0">,{startsExpr:m}),_typeof:A(</span><span class="s2">&quot;typeof&quot;</span><span class="s0">,{beforeExpr:P,prefix:k,startsExpr:m}),_void:A(</span><span class="s2">&quot;void&quot;</span><span class="s0">,{beforeExpr:P,prefix:k,startsExpr:m}),_delete:A(</span><span class="s2">&quot;delete&quot;</span><span class="s0">,{beforeExpr:P,prefix:k,startsExpr:m}),_do:A(</span><span class="s2">&quot;do&quot;</span><span class="s0">,{isLoop:v,beforeExpr:P}),_for:A(</span><span class="s2">&quot;for&quot;</span><span class="s0">,{isLoop:v}),_while:A(</span><span class="s2">&quot;while&quot;</span><span class="s0">,{isLoop:v}),_as:B(</span><span class="s2">&quot;as&quot;</span><span class="s0">,{startsExpr:m}),_assert:B(</span><span class="s2">&quot;assert&quot;</span><span class="s0">,{startsExpr:m}),_async:B(</span><span class="s2">&quot;async&quot;</span><span class="s0">,{startsExpr:m}),_await:B(</span><span class="s2">&quot;await&quot;</span><span class="s0">,{startsExpr:m}),_from:B(</span><span class="s2">&quot;from&quot;</span><span class="s0">,{startsExpr:m}),_get:B(</span><span class="s2">&quot;get&quot;</span><span class="s0">,{startsExpr:m}),_let:B(</span><span class="s2">&quot;let&quot;</span><span class="s0">,{startsExpr:m}),_meta:B(</span><span class="s2">&quot;meta&quot;</span><span class="s0">,{startsExpr:m}),_of:B(</span><span class="s2">&quot;of&quot;</span><span class="s0">,{startsExpr:m}),_sent:B(</span><span class="s2">&quot;sent&quot;</span><span class="s0">,{startsExpr:m}),_set:B(</span><span class="s2">&quot;set&quot;</span><span class="s0">,{startsExpr:m}),_static:B(</span><span class="s2">&quot;static&quot;</span><span class="s0">,{startsExpr:m}),_using:B(</span><span class="s2">&quot;using&quot;</span><span class="s0">,{startsExpr:m}),_yield:B(</span><span class="s2">&quot;yield&quot;</span><span class="s0">,{startsExpr:m}),_asserts:B(</span><span class="s2">&quot;asserts&quot;</span><span class="s0">,{startsExpr:m}),_checks:B(</span><span class="s2">&quot;checks&quot;</span><span class="s0">,{startsExpr:m}),_exports:B(</span><span class="s2">&quot;exports&quot;</span><span class="s0">,{startsExpr:m}),_global:B(</span><span class="s2">&quot;global&quot;</span><span class="s0">,{startsExpr:m}),_implements:B(</span><span class="s2">&quot;implements&quot;</span><span class="s0">,{startsExpr:m}),_intrinsic:B(</span><span class="s2">&quot;intrinsic&quot;</span><span class="s0">,{startsExpr:m}),_infer:B(</span><span class="s2">&quot;infer&quot;</span><span class="s0">,{startsExpr:m}),_is:B(</span><span class="s2">&quot;is&quot;</span><span class="s0">,{startsExpr:m}),_mixins:B(</span><span class="s2">&quot;mixins&quot;</span><span class="s0">,{startsExpr:m}),_proto:B(</span><span class="s2">&quot;proto&quot;</span><span class="s0">,{startsExpr:m}),_require:B(</span><span class="s2">&quot;require&quot;</span><span class="s0">,{startsExpr:m}),_satisfies:B(</span><span class="s2">&quot;satisfies&quot;</span><span class="s0">,{startsExpr:m}),_keyof:B(</span><span class="s2">&quot;keyof&quot;</span><span class="s0">,{startsExpr:m}),_readonly:B(</span><span class="s2">&quot;readonly&quot;</span><span class="s0">,{startsExpr:m}),_unique:B(</span><span class="s2">&quot;unique&quot;</span><span class="s0">,{startsExpr:m}),_abstract:B(</span><span class="s2">&quot;abstract&quot;</span><span class="s0">,{startsExpr:m}),_declare:B(</span><span class="s2">&quot;declare&quot;</span><span class="s0">,{startsExpr:m}),_enum:B(</span><span class="s2">&quot;enum&quot;</span><span class="s0">,{startsExpr:m}),_module:B(</span><span class="s2">&quot;module&quot;</span><span class="s0">,{startsExpr:m}),_namespace:B(</span><span class="s2">&quot;namespace&quot;</span><span class="s0">,{startsExpr:m}),_interface:B(</span><span class="s2">&quot;interface&quot;</span><span class="s0">,{startsExpr:m}),_type:B(</span><span class="s2">&quot;type&quot;</span><span class="s0">,{startsExpr:m}),_opaque:B(</span><span class="s2">&quot;opaque&quot;</span><span class="s0">,{startsExpr:m}),name:b(</span><span class="s2">&quot;name&quot;</span><span class="s0">,{startsExpr:m}),string:b(</span><span class="s2">&quot;string&quot;</span><span class="s0">,{startsExpr:m}),num:b(</span><span class="s2">&quot;num&quot;</span><span class="s0">,{startsExpr:m}),bigint:b(</span><span class="s2">&quot;bigint&quot;</span><span class="s0">,{startsExpr:m}),decimal:b(</span><span class="s2">&quot;decimal&quot;</span><span class="s0">,{startsExpr:m}),regexp:b(</span><span class="s2">&quot;regexp&quot;</span><span class="s0">,{startsExpr:m}),privateName:b(</span><span class="s2">&quot;#name&quot;</span><span class="s0">,{startsExpr:m}),eof:b(</span><span class="s2">&quot;eof&quot;</span><span class="s0">),jsxName:b(</span><span class="s2">&quot;jsxName&quot;</span><span class="s0">),jsxText:b(</span><span class="s2">&quot;jsxText&quot;</span><span class="s0">,{beforeExpr:!</span><span class="s3">0</span><span class="s0">}),jsxTagStart:b(</span><span class="s2">&quot;jsxTagStart&quot;</span><span class="s0">,{startsExpr:!</span><span class="s3">0</span><span class="s0">}),jsxTagEnd:b(</span><span class="s2">&quot;jsxTagEnd&quot;</span><span class="s0">),placeholder:b(</span><span class="s2">&quot;%%&quot;</span><span class="s0">,{startsExpr:!</span><span class="s3">0</span><span class="s0">})};</span><span class="s1">function </span><span class="s0">q(t){</span><span class="s1">return </span><span class="s0">t&gt;=</span><span class="s3">93</span><span class="s0">&amp;&amp;t&lt;=</span><span class="s3">130</span><span class="s0">}</span><span class="s1">function </span><span class="s0">ue(t){</span><span class="s1">return </span><span class="s0">t&lt;=</span><span class="s3">92</span><span class="s0">}</span><span class="s1">function </span><span class="s0">te(t){</span><span class="s1">return </span><span class="s0">t&gt;=</span><span class="s3">58</span><span class="s0">&amp;&amp;t&lt;=</span><span class="s3">130</span><span class="s0">}</span><span class="s1">function </span><span class="s0">it(t){</span><span class="s1">return </span><span class="s0">t&gt;=</span><span class="s3">58</span><span class="s0">&amp;&amp;t&lt;=</span><span class="s3">134</span><span class="s0">}</span><span class="s1">function </span><span class="s0">se(t){</span><span class="s1">return </span><span class="s0">R[t]}</span><span class="s1">function </span><span class="s0">He(t){</span><span class="s1">return </span><span class="s0">z[t]}</span><span class="s1">function </span><span class="s0">Bo(t){</span><span class="s1">return </span><span class="s0">t&gt;=</span><span class="s3">29</span><span class="s0">&amp;&amp;t&lt;=</span><span class="s3">33</span><span class="s0">}</span><span class="s1">function </span><span class="s0">hr(t){</span><span class="s1">return </span><span class="s0">t&gt;=</span><span class="s3">127</span><span class="s0">&amp;&amp;t&lt;=</span><span class="s3">129</span><span class="s0">}</span><span class="s1">function </span><span class="s0">Mo(t){</span><span class="s1">return </span><span class="s0">t&gt;=</span><span class="s3">90</span><span class="s0">&amp;&amp;t&lt;=</span><span class="s3">92</span><span class="s0">}</span><span class="s1">function </span><span class="s0">$t(t){</span><span class="s1">return </span><span class="s0">t&gt;=</span><span class="s3">58</span><span class="s0">&amp;&amp;t&lt;=</span><span class="s3">92</span><span class="s0">}</span><span class="s1">function </span><span class="s0">_o(t){</span><span class="s1">return </span><span class="s0">t&gt;=</span><span class="s3">39</span><span class="s0">&amp;&amp;t&lt;=</span><span class="s3">59</span><span class="s0">}</span><span class="s1">function </span><span class="s0">Ro(t){</span><span class="s1">return </span><span class="s0">t===</span><span class="s3">34</span><span class="s0">}</span><span class="s1">function </span><span class="s0">jo(t){</span><span class="s1">return </span><span class="s0">Q[t]}</span><span class="s1">function </span><span class="s0">qo(t){</span><span class="s1">return </span><span class="s0">t&gt;=</span><span class="s3">119</span><span class="s0">&amp;&amp;t&lt;=</span><span class="s3">121</span><span class="s0">}</span><span class="s1">function </span><span class="s0">Uo(t){</span><span class="s1">return </span><span class="s0">t&gt;=</span><span class="s3">122</span><span class="s0">&amp;&amp;t&lt;=</span><span class="s3">128</span><span class="s0">}</span><span class="s1">function </span><span class="s0">xe(t){</span><span class="s1">return </span><span class="s0">O[t]}</span><span class="s1">function </span><span class="s0">at(t){</span><span class="s1">return </span><span class="s0">H[t]}</span><span class="s1">function </span><span class="s0">$o(t){</span><span class="s1">return </span><span class="s0">t===</span><span class="s3">57</span><span class="s0">}</span><span class="s1">function </span><span class="s0">nt(t){</span><span class="s1">return </span><span class="s0">t&gt;=</span><span class="s3">24</span><span class="s0">&amp;&amp;t&lt;=</span><span class="s3">25</span><span class="s0">}</span><span class="s1">function </span><span class="s0">ce(t){</span><span class="s1">return </span><span class="s0">N[t]}N[</span><span class="s3">8</span><span class="s0">].updateContext=t=&gt;{t.pop()},N[</span><span class="s3">5</span><span class="s0">].updateContext=N[</span><span class="s3">7</span><span class="s0">].updateContext=N[</span><span class="s3">23</span><span class="s0">].updateContext=t=&gt;{t.push(x.brace)},N[</span><span class="s3">22</span><span class="s0">].updateContext=t=&gt;{t[t.length-1]===x.template?t.pop():t.push(x.template)},N[</span><span class="s3">140</span><span class="s0">].updateContext=t=&gt;{t.push(x.j_expr,x.j_oTag)};</span><span class="s1">function </span><span class="s0">ot(t,r){</span><span class="s1">if</span><span class="s0">(t==</span><span class="s1">null</span><span class="s0">)</span><span class="s1">return</span><span class="s0">{};</span><span class="s1">var </span><span class="s0">e={},s=Object.keys(t),i,a;</span><span class="s1">for</span><span class="s0">(a=</span><span class="s3">0</span><span class="s0">;a&lt;s.length;a++)i=s[a],!(r.indexOf(i)&gt;=</span><span class="s3">0</span><span class="s0">)&amp;&amp;(e[i]=t[i]);</span><span class="s1">return </span><span class="s0">e}</span><span class="s1">var </span><span class="s0">ge=class{constructor(t,r,e){</span><span class="s1">this</span><span class="s0">.line=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.column=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.index=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.line=t,</span><span class="s1">this</span><span class="s0">.column=r,</span><span class="s1">this</span><span class="s0">.index=e}},lt=class{constructor(t,r){</span><span class="s1">this</span><span class="s0">.start=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.end=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.filename=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.identifierName=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.start=t,</span><span class="s1">this</span><span class="s0">.end=r}};</span><span class="s1">function </span><span class="s0">Y(t,r){let{line:e,column:s,index:i}=t;</span><span class="s1">return new </span><span class="s0">ge(e,s+r,i+r)}</span><span class="s1">var </span><span class="s0">Ht={SyntaxError:</span><span class="s2">&quot;BABEL_PARSER_SYNTAX_ERROR&quot;</span><span class="s0">,SourceTypeModuleError:</span><span class="s2">&quot;BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED&quot;</span><span class="s0">},Ho=</span><span class="s1">function</span><span class="s0">(t){let r=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">1</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">1</span><span class="s0">]:t.length-1;</span><span class="s1">return</span><span class="s0">{get(){</span><span class="s1">return </span><span class="s0">t.reduce((e,s)=&gt;e[s],</span><span class="s1">this</span><span class="s0">)},set(e){t.reduce((s,i,a)=&gt;a===r?s[i]=e:s[i],</span><span class="s1">this</span><span class="s0">)}}},zo=(t,r,e)=&gt;Object.keys(e).map(s=&gt;[s,e[s]]).filter(s=&gt;{let[,i]=s;</span><span class="s1">return</span><span class="s0">!!i}).map(s=&gt;{let[i,a]=s;</span><span class="s1">return</span><span class="s0">[i,</span><span class="s1">typeof </span><span class="s0">a==</span><span class="s2">&quot;function&quot;</span><span class="s0">?{value:a,enumerable:!</span><span class="s3">1</span><span class="s0">}:</span><span class="s1">typeof </span><span class="s0">a.reflect==</span><span class="s2">&quot;string&quot;</span><span class="s0">?Object.assign({},a,Ho(a.reflect.split(</span><span class="s2">&quot;.&quot;</span><span class="s0">))):a]}).reduce((s,i)=&gt;{let[a,n]=i;</span><span class="s1">return </span><span class="s0">Object.defineProperty(s,a,Object.assign({configurable:!</span><span class="s3">0</span><span class="s0">},n))},Object.assign(</span><span class="s1">new </span><span class="s0">t,r)),Vo={ImportMetaOutsideModule:{message:`import.meta may appear only </span><span class="s1">with </span><span class="s2">'sourceType: &quot;module&quot;'</span><span class="s0">`,code:Ht.SourceTypeModuleError},ImportOutsideModule:{message:`</span><span class="s2">'import' </span><span class="s0">and </span><span class="s2">'export' </span><span class="s0">may appear only </span><span class="s1">with </span><span class="s2">'sourceType: &quot;module&quot;'</span><span class="s0">`,code:Ht.SourceTypeModuleError}},ur={ArrayPattern:</span><span class="s2">&quot;array destructuring pattern&quot;</span><span class="s0">,AssignmentExpression:</span><span class="s2">&quot;assignment expression&quot;</span><span class="s0">,AssignmentPattern:</span><span class="s2">&quot;assignment expression&quot;</span><span class="s0">,ArrowFunctionExpression:</span><span class="s2">&quot;arrow function expression&quot;</span><span class="s0">,ConditionalExpression:</span><span class="s2">&quot;conditional expression&quot;</span><span class="s0">,CatchClause:</span><span class="s2">&quot;catch clause&quot;</span><span class="s0">,ForOfStatement:</span><span class="s2">&quot;for-of statement&quot;</span><span class="s0">,ForInStatement:</span><span class="s2">&quot;for-in statement&quot;</span><span class="s0">,ForStatement:</span><span class="s2">&quot;for-loop&quot;</span><span class="s0">,FormalParameters:</span><span class="s2">&quot;function parameter list&quot;</span><span class="s0">,Identifier:</span><span class="s2">&quot;identifier&quot;</span><span class="s0">,ImportSpecifier:</span><span class="s2">&quot;import specifier&quot;</span><span class="s0">,ImportDefaultSpecifier:</span><span class="s2">&quot;import default specifier&quot;</span><span class="s0">,ImportNamespaceSpecifier:</span><span class="s2">&quot;import namespace specifier&quot;</span><span class="s0">,ObjectPattern:</span><span class="s2">&quot;object destructuring pattern&quot;</span><span class="s0">,ParenthesizedExpression:</span><span class="s2">&quot;parenthesized expression&quot;</span><span class="s0">,RestElement:</span><span class="s2">&quot;rest element&quot;</span><span class="s0">,UpdateExpression:{</span><span class="s1">true</span><span class="s0">:</span><span class="s2">&quot;prefix operation&quot;</span><span class="s0">,</span><span class="s1">false</span><span class="s0">:</span><span class="s2">&quot;postfix operation&quot;</span><span class="s0">},VariableDeclarator:</span><span class="s2">&quot;variable declaration&quot;</span><span class="s0">,YieldExpression:</span><span class="s2">&quot;yield expression&quot;</span><span class="s0">},zt=t=&gt;{let{type:r,prefix:e}=t;</span><span class="s1">return </span><span class="s0">r===</span><span class="s2">&quot;UpdateExpression&quot;</span><span class="s0">?ur.UpdateExpression[String(e)]:ur[r]},Ko={AccessorIsGenerator:t=&gt;{let{kind:r}=t;</span><span class="s1">return</span><span class="s0">`A ${r}ter cannot be a generator.`},ArgumentsInClass:</span><span class="s2">&quot;'arguments' is only allowed in functions and class methods.&quot;</span><span class="s0">,AsyncFunctionInSingleStatementContext:</span><span class="s2">&quot;Async functions can only be declared at the top level or inside a block.&quot;</span><span class="s0">,AwaitBindingIdentifier:</span><span class="s2">&quot;Can not use 'await' as identifier inside an async function.&quot;</span><span class="s0">,AwaitBindingIdentifierInStaticBlock:</span><span class="s2">&quot;Can not use 'await' as identifier inside a static block.&quot;</span><span class="s0">,AwaitExpressionFormalParameter:</span><span class="s2">&quot;'await' is not allowed in async function parameters.&quot;</span><span class="s0">,AwaitInUsingBinding:</span><span class="s2">&quot;'await' is not allowed to be used as a name in 'using' declarations.&quot;</span><span class="s0">,AwaitNotInAsyncContext:</span><span class="s2">&quot;'await' is only allowed within async functions and at the top levels of modules.&quot;</span><span class="s0">,AwaitNotInAsyncFunction:</span><span class="s2">&quot;'await' is only allowed within async functions.&quot;</span><span class="s0">,BadGetterArity:</span><span class="s2">&quot;A 'get' accessor must not have any formal parameters.&quot;</span><span class="s0">,BadSetterArity:</span><span class="s2">&quot;A 'set' accessor must have exactly one formal parameter.&quot;</span><span class="s0">,BadSetterRestParameter:</span><span class="s2">&quot;A 'set' accessor function argument must not be a rest parameter.&quot;</span><span class="s0">,ConstructorClassField:</span><span class="s2">&quot;Classes may not have a field named 'constructor'.&quot;</span><span class="s0">,ConstructorClassPrivateField:</span><span class="s2">&quot;Classes may not have a private field named '#constructor'.&quot;</span><span class="s0">,ConstructorIsAccessor:</span><span class="s2">&quot;Class constructor may not be an accessor.&quot;</span><span class="s0">,ConstructorIsAsync:</span><span class="s2">&quot;Constructor can't be an async function.&quot;</span><span class="s0">,ConstructorIsGenerator:</span><span class="s2">&quot;Constructor can't be a generator.&quot;</span><span class="s0">,DeclarationMissingInitializer:t=&gt;{let{kind:r}=t;</span><span class="s1">return</span><span class="s0">`Missing initializer </span><span class="s1">in </span><span class="s0">${r} declaration.`},DecoratorArgumentsOutsideParentheses:</span><span class="s2">&quot;Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.&quot;</span><span class="s0">,DecoratorBeforeExport:</span><span class="s2">&quot;Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.&quot;</span><span class="s0">,DecoratorsBeforeAfterExport:</span><span class="s2">&quot;Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.&quot;</span><span class="s0">,DecoratorConstructor:</span><span class="s2">&quot;Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?&quot;</span><span class="s0">,DecoratorExportClass:</span><span class="s2">&quot;Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.&quot;</span><span class="s0">,DecoratorSemicolon:</span><span class="s2">&quot;Decorators must not be followed by a semicolon.&quot;</span><span class="s0">,DecoratorStaticBlock:</span><span class="s2">&quot;Decorators can't be used with a static block.&quot;</span><span class="s0">,DeletePrivateField:</span><span class="s2">&quot;Deleting a private field is not allowed.&quot;</span><span class="s0">,DestructureNamedImport:</span><span class="s2">&quot;ES2015 named imports do not destructure. Use another statement for destructuring after the import.&quot;</span><span class="s0">,DuplicateConstructor:</span><span class="s2">&quot;Duplicate constructor in the same class.&quot;</span><span class="s0">,DuplicateDefaultExport:</span><span class="s2">&quot;Only one default export allowed per module.&quot;</span><span class="s0">,DuplicateExport:t=&gt;{let{exportName:r}=t;</span><span class="s1">return</span><span class="s0">`\`${r}\` has already been exported. Exported identifiers must be unique.`},DuplicateProto:</span><span class="s2">&quot;Redefinition of __proto__ property.&quot;</span><span class="s0">,DuplicateRegExpFlags:</span><span class="s2">&quot;Duplicate regular expression flag.&quot;</span><span class="s0">,ElementAfterRest:</span><span class="s2">&quot;Rest element must be last element.&quot;</span><span class="s0">,EscapedCharNotAnIdentifier:</span><span class="s2">&quot;Invalid Unicode escape.&quot;</span><span class="s0">,ExportBindingIsString:t=&gt;{let{localName:r,exportName:e}=t;</span><span class="s1">return</span><span class="s0">`A string literal cannot be used as an exported binding without \`from\`.</span>
<span class="s0">- Did you mean \`export { </span><span class="s2">'${r}' </span><span class="s0">as </span><span class="s2">'${e}' </span><span class="s0">} from </span><span class="s2">'some-module'</span><span class="s0">\`?`},ExportDefaultFromAsIdentifier:</span><span class="s2">&quot;'from' is not allowed as an identifier after 'export default'.&quot;</span><span class="s0">,ForInOfLoopInitializer:t=&gt;{let{type:r}=t;</span><span class="s1">return</span><span class="s0">`</span><span class="s2">'${r===&quot;ForInStatement&quot;?&quot;for-in&quot;:&quot;for-of&quot;}' </span><span class="s0">loop variable declaration may not have an initializer.`},ForInUsing:</span><span class="s2">&quot;For-in loop may not start with 'using' declaration.&quot;</span><span class="s0">,ForOfAsync:</span><span class="s2">&quot;The left-hand side of a for-of loop may not be 'async'.&quot;</span><span class="s0">,ForOfLet:</span><span class="s2">&quot;The left-hand side of a for-of loop may not start with 'let'.&quot;</span><span class="s0">,GeneratorInSingleStatementContext:</span><span class="s2">&quot;Generators can only be declared at the top level or inside a block.&quot;</span><span class="s0">,IllegalBreakContinue:t=&gt;{let{type:r}=t;</span><span class="s1">return</span><span class="s0">`Unsyntactic ${r===</span><span class="s2">&quot;BreakStatement&quot;</span><span class="s0">?</span><span class="s2">&quot;break&quot;</span><span class="s0">:</span><span class="s2">&quot;continue&quot;</span><span class="s0">}.`},IllegalLanguageModeDirective:</span><span class="s2">&quot;Illegal 'use strict' directive in function with non-simple parameter list.&quot;</span><span class="s0">,IllegalReturn:</span><span class="s2">&quot;'return' outside of function.&quot;</span><span class="s0">,ImportBindingIsString:t=&gt;{let{importName:r}=t;</span><span class="s1">return</span><span class="s0">`A string literal cannot be used as an imported binding.</span>
<span class="s0">- Did you mean \`import { </span><span class="s2">&quot;${r}&quot; </span><span class="s0">as foo }\`?`},ImportCallArgumentTrailingComma:</span><span class="s2">&quot;Trailing comma is disallowed inside import(...) arguments.&quot;</span><span class="s0">,ImportCallArity:t=&gt;{let{maxArgumentCount:r}=t;</span><span class="s1">return</span><span class="s0">`\`import()\` requires exactly ${r===</span><span class="s3">1</span><span class="s0">?</span><span class="s2">&quot;one argument&quot;</span><span class="s0">:</span><span class="s2">&quot;one or two arguments&quot;</span><span class="s0">}.`},ImportCallNotNewExpression:</span><span class="s2">&quot;Cannot use new with import(...).&quot;</span><span class="s0">,ImportCallSpreadArgument:</span><span class="s2">&quot;`...` is not allowed in `import()`.&quot;</span><span class="s0">,ImportJSONBindingNotDefault:</span><span class="s2">&quot;A JSON module can only be imported with `default`.&quot;</span><span class="s0">,ImportReflectionHasAssertion:</span><span class="s2">&quot;`import module x` cannot have assertions.&quot;</span><span class="s0">,ImportReflectionNotBinding:</span><span class="s2">'Only `import module x from &quot;./module&quot;` is valid.'</span><span class="s0">,IncompatibleRegExpUVFlags:</span><span class="s2">&quot;The 'u' and 'v' regular expression flags cannot be enabled at the same time.&quot;</span><span class="s0">,InvalidBigIntLiteral:</span><span class="s2">&quot;Invalid BigIntLiteral.&quot;</span><span class="s0">,InvalidCodePoint:</span><span class="s2">&quot;Code point out of bounds.&quot;</span><span class="s0">,InvalidCoverInitializedName:</span><span class="s2">&quot;Invalid shorthand property initializer.&quot;</span><span class="s0">,InvalidDecimal:</span><span class="s2">&quot;Invalid decimal.&quot;</span><span class="s0">,InvalidDigit:t=&gt;{let{radix:r}=t;</span><span class="s1">return</span><span class="s0">`Expected number </span><span class="s1">in </span><span class="s0">radix ${r}.`},InvalidEscapeSequence:</span><span class="s2">&quot;Bad character escape sequence.&quot;</span><span class="s0">,InvalidEscapeSequenceTemplate:</span><span class="s2">&quot;Invalid escape sequence in template.&quot;</span><span class="s0">,InvalidEscapedReservedWord:t=&gt;{let{reservedWord:r}=t;</span><span class="s1">return</span><span class="s0">`Escape sequence </span><span class="s1">in </span><span class="s0">keyword ${r}.`},InvalidIdentifier:t=&gt;{let{identifierName:r}=t;</span><span class="s1">return</span><span class="s0">`Invalid identifier ${r}.`},InvalidLhs:t=&gt;{let{ancestor:r}=t;</span><span class="s1">return</span><span class="s0">`Invalid left-hand side </span><span class="s1">in </span><span class="s0">${zt(r)}.`},InvalidLhsBinding:t=&gt;{let{ancestor:r}=t;</span><span class="s1">return</span><span class="s0">`Binding invalid left-hand side </span><span class="s1">in </span><span class="s0">${zt(r)}.`},InvalidNumber:</span><span class="s2">&quot;Invalid number.&quot;</span><span class="s0">,InvalidOrMissingExponent:</span><span class="s2">&quot;Floating-point numbers require a valid exponent after the 'e'.&quot;</span><span class="s0">,InvalidOrUnexpectedToken:t=&gt;{let{unexpected:r}=t;</span><span class="s1">return</span><span class="s0">`Unexpected character </span><span class="s2">'${r}'</span><span class="s0">.`},InvalidParenthesizedAssignment:</span><span class="s2">&quot;Invalid parenthesized assignment pattern.&quot;</span><span class="s0">,InvalidPrivateFieldResolution:t=&gt;{let{identifierName:r}=t;</span><span class="s1">return</span><span class="s0">`Private name #${r} is not defined.`},InvalidPropertyBindingPattern:</span><span class="s2">&quot;Binding member expression.&quot;</span><span class="s0">,InvalidRecordProperty:</span><span class="s2">&quot;Only properties and spread elements are allowed in record definitions.&quot;</span><span class="s0">,InvalidRestAssignmentPattern:</span><span class="s2">&quot;Invalid rest operator's argument.&quot;</span><span class="s0">,LabelRedeclaration:t=&gt;{let{labelName:r}=t;</span><span class="s1">return</span><span class="s0">`Label </span><span class="s2">'${r}' </span><span class="s0">is already declared.`},LetInLexicalBinding:</span><span class="s2">&quot;'let' is not allowed to be used as a name in 'let' or 'const' declarations.&quot;</span><span class="s0">,LineTerminatorBeforeArrow:</span><span class="s2">&quot;No line break is allowed before '=&gt;'.&quot;</span><span class="s0">,MalformedRegExpFlags:</span><span class="s2">&quot;Invalid regular expression flag.&quot;</span><span class="s0">,MissingClassName:</span><span class="s2">&quot;A class name is required.&quot;</span><span class="s0">,MissingEqInAssignment:</span><span class="s2">&quot;Only '=' operator can be used for specifying default value.&quot;</span><span class="s0">,MissingSemicolon:</span><span class="s2">&quot;Missing semicolon.&quot;</span><span class="s0">,MissingPlugin:t=&gt;{let{missingPlugin:r}=t;</span><span class="s1">return</span><span class="s0">`This experimental syntax requires enabling the parser plugin: ${r.map(e=&gt;JSON.stringify(e)).join(</span><span class="s2">&quot;, &quot;</span><span class="s0">)}.`},MissingOneOfPlugins:t=&gt;{let{missingPlugin:r}=t;</span><span class="s1">return</span><span class="s0">`This experimental syntax requires enabling one of the following parser plugin(s): ${r.map(e=&gt;JSON.stringify(e)).join(</span><span class="s2">&quot;, &quot;</span><span class="s0">)}.`},MissingUnicodeEscape:</span><span class="s2">&quot;Expecting Unicode escape sequence </span><span class="s4">\\</span><span class="s2">uXXXX.&quot;</span><span class="s0">,MixingCoalesceWithLogical:</span><span class="s2">&quot;Nullish coalescing operator(??) requires parens when mixing with logical operators.&quot;</span><span class="s0">,ModuleAttributeDifferentFromType:</span><span class="s2">&quot;The only accepted module attribute is `type`.&quot;</span><span class="s0">,ModuleAttributeInvalidValue:</span><span class="s2">&quot;Only string literals are allowed as module attribute values.&quot;</span><span class="s0">,ModuleAttributesWithDuplicateKeys:t=&gt;{let{key:r}=t;</span><span class="s1">return</span><span class="s0">`Duplicate key </span><span class="s2">&quot;${r}&quot; </span><span class="s0">is not allowed </span><span class="s1">in </span><span class="s0">module attributes.`},ModuleExportNameHasLoneSurrogate:t=&gt;{let{surrogateCharCode:r}=t;</span><span class="s1">return</span><span class="s0">`An export name cannot include a lone surrogate, found </span><span class="s2">'</span><span class="s4">\\</span><span class="s2">u${r.toString(16)}'</span><span class="s0">.`},ModuleExportUndefined:t=&gt;{let{localName:r}=t;</span><span class="s1">return</span><span class="s0">`Export </span><span class="s2">'${r}' </span><span class="s0">is not defined.`},MultipleDefaultsInSwitch:</span><span class="s2">&quot;Multiple default clauses.&quot;</span><span class="s0">,NewlineAfterThrow:</span><span class="s2">&quot;Illegal newline after throw.&quot;</span><span class="s0">,NoCatchOrFinally:</span><span class="s2">&quot;Missing catch or finally clause.&quot;</span><span class="s0">,NumberIdentifier:</span><span class="s2">&quot;Identifier directly after number.&quot;</span><span class="s0">,NumericSeparatorInEscapeSequence:</span><span class="s2">&quot;Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.&quot;</span><span class="s0">,ObsoleteAwaitStar:</span><span class="s2">&quot;'await*' has been removed from the async functions proposal. Use Promise.all() instead.&quot;</span><span class="s0">,OptionalChainingNoNew:</span><span class="s2">&quot;Constructors in/after an Optional Chain are not allowed.&quot;</span><span class="s0">,OptionalChainingNoTemplate:</span><span class="s2">&quot;Tagged Template Literals are not allowed in optionalChain.&quot;</span><span class="s0">,OverrideOnConstructor:</span><span class="s2">&quot;'override' modifier cannot appear on a constructor declaration.&quot;</span><span class="s0">,ParamDupe:</span><span class="s2">&quot;Argument name clash.&quot;</span><span class="s0">,PatternHasAccessor:</span><span class="s2">&quot;Object pattern can't contain getter or setter.&quot;</span><span class="s0">,PatternHasMethod:</span><span class="s2">&quot;Object pattern can't contain methods.&quot;</span><span class="s0">,PrivateInExpectedIn:t=&gt;{let{identifierName:r}=t;</span><span class="s1">return</span><span class="s0">`Private names are only allowed </span><span class="s1">in </span><span class="s0">property accesses (\`obj.#${r}\`) or </span><span class="s1">in </span><span class="s0">\`</span><span class="s1">in</span><span class="s0">\` expressions (\`#${r} </span><span class="s1">in </span><span class="s0">obj\`).`},PrivateNameRedeclaration:t=&gt;{let{identifierName:r}=t;</span><span class="s1">return</span><span class="s0">`Duplicate private name #${r}.`},RecordExpressionBarIncorrectEndSyntaxType:</span><span class="s2">&quot;Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.&quot;</span><span class="s0">,RecordExpressionBarIncorrectStartSyntaxType:</span><span class="s2">&quot;Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.&quot;</span><span class="s0">,RecordExpressionHashIncorrectStartSyntaxType:</span><span class="s2">&quot;Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.&quot;</span><span class="s0">,RecordNoProto:</span><span class="s2">&quot;'__proto__' is not allowed in Record expressions.&quot;</span><span class="s0">,RestTrailingComma:</span><span class="s2">&quot;Unexpected trailing comma after rest element.&quot;</span><span class="s0">,SloppyFunction:</span><span class="s2">&quot;In non-strict mode code, functions can only be declared at top level or inside a block.&quot;</span><span class="s0">,SloppyFunctionAnnexB:</span><span class="s2">&quot;In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.&quot;</span><span class="s0">,StaticPrototype:</span><span class="s2">&quot;Classes may not have static property named prototype.&quot;</span><span class="s0">,SuperNotAllowed:</span><span class="s2">&quot;`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?&quot;</span><span class="s0">,SuperPrivateField:</span><span class="s2">&quot;Private fields can't be accessed on super.&quot;</span><span class="s0">,TrailingDecorator:</span><span class="s2">&quot;Decorators must be attached to a class element.&quot;</span><span class="s0">,TupleExpressionBarIncorrectEndSyntaxType:</span><span class="s2">&quot;Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.&quot;</span><span class="s0">,TupleExpressionBarIncorrectStartSyntaxType:</span><span class="s2">&quot;Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.&quot;</span><span class="s0">,TupleExpressionHashIncorrectStartSyntaxType:</span><span class="s2">&quot;Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.&quot;</span><span class="s0">,UnexpectedArgumentPlaceholder:</span><span class="s2">&quot;Unexpected argument placeholder.&quot;</span><span class="s0">,UnexpectedAwaitAfterPipelineBody:</span><span class="s2">'Unexpected &quot;await&quot; after pipeline body; await must have parentheses in minimal proposal.'</span><span class="s0">,UnexpectedDigitAfterHash:</span><span class="s2">&quot;Unexpected digit after hash token.&quot;</span><span class="s0">,UnexpectedImportExport:</span><span class="s2">&quot;'import' and 'export' may only appear at the top level.&quot;</span><span class="s0">,UnexpectedKeyword:t=&gt;{let{keyword:r}=t;</span><span class="s1">return</span><span class="s0">`Unexpected keyword </span><span class="s2">'${r}'</span><span class="s0">.`},UnexpectedLeadingDecorator:</span><span class="s2">&quot;Leading decorators must be attached to a class declaration.&quot;</span><span class="s0">,UnexpectedLexicalDeclaration:</span><span class="s2">&quot;Lexical declaration cannot appear in a single-statement context.&quot;</span><span class="s0">,UnexpectedNewTarget:</span><span class="s2">&quot;`new.target` can only be used in functions or class properties.&quot;</span><span class="s0">,UnexpectedNumericSeparator:</span><span class="s2">&quot;A numeric separator is only allowed between two digits.&quot;</span><span class="s0">,UnexpectedPrivateField:</span><span class="s2">&quot;Unexpected private name.&quot;</span><span class="s0">,UnexpectedReservedWord:t=&gt;{let{reservedWord:r}=t;</span><span class="s1">return</span><span class="s0">`Unexpected reserved word </span><span class="s2">'${r}'</span><span class="s0">.`},UnexpectedSuper:</span><span class="s2">&quot;'super' is only allowed in object methods and classes.&quot;</span><span class="s0">,UnexpectedToken:t=&gt;{let{expected:r,unexpected:e}=t;</span><span class="s1">return</span><span class="s0">`Unexpected token${e?` </span><span class="s2">'${e}'</span><span class="s0">.`:</span><span class="s2">&quot;&quot;</span><span class="s0">}${r?`, expected </span><span class="s2">&quot;${r}&quot;</span><span class="s0">`:</span><span class="s2">&quot;&quot;</span><span class="s0">}`},UnexpectedTokenUnaryExponentiation:</span><span class="s2">&quot;Illegal expression. Wrap left hand side or entire exponentiation in parentheses.&quot;</span><span class="s0">,UnexpectedUsingDeclaration:</span><span class="s2">&quot;Using declaration cannot appear in the top level when source type is `script`.&quot;</span><span class="s0">,UnsupportedBind:</span><span class="s2">&quot;Binding should be performed on object property.&quot;</span><span class="s0">,UnsupportedDecoratorExport:</span><span class="s2">&quot;A decorated export must export a class declaration.&quot;</span><span class="s0">,UnsupportedDefaultExport:</span><span class="s2">&quot;Only expressions, functions or classes are allowed as the `default` export.&quot;</span><span class="s0">,UnsupportedImport:</span><span class="s2">&quot;`import` can only be used in `import()` or `import.meta`.&quot;</span><span class="s0">,UnsupportedMetaProperty:t=&gt;{let{target:r,onlyValidPropertyName:e}=t;</span><span class="s1">return</span><span class="s0">`The only valid meta property </span><span class="s1">for </span><span class="s0">${r} is ${r}.${e}.`},UnsupportedParameterDecorator:</span><span class="s2">&quot;Decorators cannot be used to decorate parameters.&quot;</span><span class="s0">,UnsupportedPropertyDecorator:</span><span class="s2">&quot;Decorators cannot be used to decorate object literal properties.&quot;</span><span class="s0">,UnsupportedSuper:</span><span class="s2">&quot;'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).&quot;</span><span class="s0">,UnterminatedComment:</span><span class="s2">&quot;Unterminated comment.&quot;</span><span class="s0">,UnterminatedRegExp:</span><span class="s2">&quot;Unterminated regular expression.&quot;</span><span class="s0">,UnterminatedString:</span><span class="s2">&quot;Unterminated string constant.&quot;</span><span class="s0">,UnterminatedTemplate:</span><span class="s2">&quot;Unterminated template.&quot;</span><span class="s0">,UsingDeclarationHasBindingPattern:</span><span class="s2">&quot;Using declaration cannot have destructuring patterns.&quot;</span><span class="s0">,VarRedeclaration:t=&gt;{let{identifierName:r}=t;</span><span class="s1">return</span><span class="s0">`Identifier </span><span class="s2">'${r}' </span><span class="s0">has already been declared.`},YieldBindingIdentifier:</span><span class="s2">&quot;Can not use 'yield' as identifier inside a generator.&quot;</span><span class="s0">,YieldInParameter:</span><span class="s2">&quot;Yield expression is not allowed in formal parameters.&quot;</span><span class="s0">,ZeroDigitNumericSeparator:</span><span class="s2">&quot;Numeric separator can not be used after leading 0.&quot;</span><span class="s0">},Wo={StrictDelete:</span><span class="s2">&quot;Deleting local variable in strict mode.&quot;</span><span class="s0">,StrictEvalArguments:t=&gt;{let{referenceName:r}=t;</span><span class="s1">return</span><span class="s0">`Assigning to </span><span class="s2">'${r}' </span><span class="s1">in </span><span class="s0">strict mode.`},StrictEvalArgumentsBinding:t=&gt;{let{bindingName:r}=t;</span><span class="s1">return</span><span class="s0">`Binding </span><span class="s2">'${r}' </span><span class="s1">in </span><span class="s0">strict mode.`},StrictFunction:</span><span class="s2">&quot;In strict mode code, functions can only be declared at top level or inside a block.&quot;</span><span class="s0">,StrictNumericEscape:</span><span class="s2">&quot;The only valid numeric escape in strict mode is '</span><span class="s4">\\</span><span class="s2">0'.&quot;</span><span class="s0">,StrictOctalLiteral:</span><span class="s2">&quot;Legacy octal literals are not allowed in strict mode.&quot;</span><span class="s0">,StrictWith:</span><span class="s2">&quot;'with' in strict mode.&quot;</span><span class="s0">},Go=</span><span class="s1">new </span><span class="s0">Set([</span><span class="s2">&quot;ArrowFunctionExpression&quot;</span><span class="s0">,</span><span class="s2">&quot;AssignmentExpression&quot;</span><span class="s0">,</span><span class="s2">&quot;ConditionalExpression&quot;</span><span class="s0">,</span><span class="s2">&quot;YieldExpression&quot;</span><span class="s0">]),Jo={PipeBodyIsTighter:</span><span class="s2">&quot;Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.&quot;</span><span class="s0">,PipeTopicRequiresHackPipes:</span><span class="s2">'Topic reference is used, but the pipelineOperator plugin was not passed a &quot;proposal&quot;: &quot;hack&quot; or &quot;smart&quot; option.'</span><span class="s0">,PipeTopicUnbound:</span><span class="s2">&quot;Topic reference is unbound; it must be inside a pipe body.&quot;</span><span class="s0">,PipeTopicUnconfiguredToken:t=&gt;{let{token:r}=t;</span><span class="s1">return</span><span class="s0">`Invalid topic token ${r}. In order to use ${r} as a topic reference, the pipelineOperator plugin must be configured </span><span class="s1">with </span><span class="s0">{ </span><span class="s2">&quot;proposal&quot;</span><span class="s0">: </span><span class="s2">&quot;hack&quot;</span><span class="s0">, </span><span class="s2">&quot;topicToken&quot;</span><span class="s0">: </span><span class="s2">&quot;${r}&quot; </span><span class="s0">}.`},PipeTopicUnused:</span><span class="s2">&quot;Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.&quot;</span><span class="s0">,PipeUnparenthesizedBody:t=&gt;{let{type:r}=t;</span><span class="s1">return</span><span class="s0">`Hack-style pipe body cannot be an unparenthesized ${zt({type:r})}; please wrap it </span><span class="s1">in </span><span class="s0">parentheses.`},PipelineBodyNoArrow:</span><span class="s2">'Unexpected arrow &quot;=&gt;&quot; after pipeline body; arrow function in pipeline body must be parenthesized.'</span><span class="s0">,PipelineBodySequenceExpression:</span><span class="s2">&quot;Pipeline body may not be a comma-separated sequence expression.&quot;</span><span class="s0">,PipelineHeadSequenceExpression:</span><span class="s2">&quot;Pipeline head should not be a comma-separated sequence expression.&quot;</span><span class="s0">,PipelineTopicUnused:</span><span class="s2">&quot;Pipeline is in topic style but does not use topic reference.&quot;</span><span class="s0">,PrimaryTopicNotAllowed:</span><span class="s2">&quot;Topic reference was used in a lexical context without topic binding.&quot;</span><span class="s0">,PrimaryTopicRequiresSmartPipeline:</span><span class="s2">'Topic reference is used, but the pipelineOperator plugin was not passed a &quot;proposal&quot;: &quot;hack&quot; or &quot;smart&quot; option.'</span><span class="s0">},Xo=[</span><span class="s2">&quot;toMessage&quot;</span><span class="s0">],Yo=[</span><span class="s2">&quot;message&quot;</span><span class="s0">];</span><span class="s1">function </span><span class="s0">Qo(t){let{toMessage:r}=t,e=ot(t,Xo);</span><span class="s1">return function </span><span class="s0">s(i){let{loc:a,details:n}=i;</span><span class="s1">return </span><span class="s0">zo(SyntaxError,Object.assign({},e,{loc:a}),{clone(){let o=arguments.length&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">0</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">0</span><span class="s0">]:{},u=o.loc||{};</span><span class="s1">return </span><span class="s0">s({loc:</span><span class="s1">new </span><span class="s0">ge(</span><span class="s2">&quot;line&quot;</span><span class="s1">in </span><span class="s0">u?u.line:</span><span class="s1">this</span><span class="s0">.loc.line,</span><span class="s2">&quot;column&quot;</span><span class="s1">in </span><span class="s0">u?u.column:</span><span class="s1">this</span><span class="s0">.loc.column,</span><span class="s2">&quot;index&quot;</span><span class="s1">in </span><span class="s0">u?u.index:</span><span class="s1">this</span><span class="s0">.loc.index),details:Object.assign({},</span><span class="s1">this</span><span class="s0">.details,o.details)})},details:{value:n,enumerable:!</span><span class="s3">1</span><span class="s0">},message:{get(){</span><span class="s1">return</span><span class="s0">`${r(</span><span class="s1">this</span><span class="s0">.details)} (${</span><span class="s1">this</span><span class="s0">.loc.line}:${</span><span class="s1">this</span><span class="s0">.loc.column})`},set(o){Object.defineProperty(</span><span class="s1">this</span><span class="s0">,</span><span class="s2">&quot;message&quot;</span><span class="s0">,{value:o})}},pos:{reflect:</span><span class="s2">&quot;loc.index&quot;</span><span class="s0">,enumerable:!</span><span class="s3">0</span><span class="s0">},missingPlugin:</span><span class="s2">&quot;missingPlugin&quot;</span><span class="s1">in </span><span class="s0">n&amp;&amp;{reflect:</span><span class="s2">&quot;details.missingPlugin&quot;</span><span class="s0">,enumerable:!</span><span class="s3">0</span><span class="s0">}})}}</span><span class="s1">function </span><span class="s0">pe(t,r){</span><span class="s1">if</span><span class="s0">(Array.isArray(t))</span><span class="s1">return </span><span class="s0">s=&gt;pe(s,t[</span><span class="s3">0</span><span class="s0">]);let e={};</span><span class="s1">for</span><span class="s0">(let s of Object.keys(t)){let i=t[s],a=</span><span class="s1">typeof </span><span class="s0">i==</span><span class="s2">&quot;string&quot;</span><span class="s0">?{message:()=&gt;i}:</span><span class="s1">typeof </span><span class="s0">i==</span><span class="s2">&quot;function&quot;</span><span class="s0">?{message:i}:i,{message:n}=a,o=ot(a,Yo),u=</span><span class="s1">typeof </span><span class="s0">n==</span><span class="s2">&quot;string&quot;</span><span class="s0">?()=&gt;n:n;e[s]=Qo(Object.assign({code:Ht.SyntaxError,reasonCode:s,toMessage:u},r?{syntaxPlugin:r}:{},o))}</span><span class="s1">return </span><span class="s0">e}</span><span class="s1">var </span><span class="s0">f=Object.assign({},pe(Vo),pe(Ko),pe(Wo),pe`pipelineOperator`(Jo)),{defineProperty:Zo}=Object,cr=(t,r)=&gt;Zo(t,r,{enumerable:!</span><span class="s3">1</span><span class="s0">,value:t[r]});</span><span class="s1">function </span><span class="s0">ze(t){</span><span class="s1">return </span><span class="s0">t.loc.start&amp;&amp;cr(t.loc.start,</span><span class="s2">&quot;index&quot;</span><span class="s0">),t.loc.end&amp;&amp;cr(t.loc.end,</span><span class="s2">&quot;index&quot;</span><span class="s0">),t}</span><span class="s1">var </span><span class="s0">el=t=&gt;class extends t{parse(){let e=ze(super.parse());</span><span class="s1">return this</span><span class="s0">.options.tokens&amp;&amp;(e.tokens=e.tokens.map(ze)),e}parseRegExpLiteral(e){let{pattern:s,flags:i}=e,a=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">try</span><span class="s0">{a=</span><span class="s1">new </span><span class="s0">RegExp(s,i)}</span><span class="s1">catch</span><span class="s0">{}let n=</span><span class="s1">this</span><span class="s0">.estreeParseLiteral(a);</span><span class="s1">return </span><span class="s0">n.regex={pattern:s,flags:i},n}parseBigIntLiteral(e){let s;</span><span class="s1">try</span><span class="s0">{s=BigInt(e)}</span><span class="s1">catch</span><span class="s0">{s=</span><span class="s1">null</span><span class="s0">}let i=</span><span class="s1">this</span><span class="s0">.estreeParseLiteral(s);</span><span class="s1">return </span><span class="s0">i.bigint=String(i.value||e),i}parseDecimalLiteral(e){let i=</span><span class="s1">this</span><span class="s0">.estreeParseLiteral(</span><span class="s1">null</span><span class="s0">);</span><span class="s1">return </span><span class="s0">i.decimal=String(i.value||e),i}estreeParseLiteral(e){</span><span class="s1">return this</span><span class="s0">.parseLiteral(e,</span><span class="s2">&quot;Literal&quot;</span><span class="s0">)}parseStringLiteral(e){</span><span class="s1">return this</span><span class="s0">.estreeParseLiteral(e)}parseNumericLiteral(e){</span><span class="s1">return this</span><span class="s0">.estreeParseLiteral(e)}parseNullLiteral(){</span><span class="s1">return this</span><span class="s0">.estreeParseLiteral(</span><span class="s1">null</span><span class="s0">)}parseBooleanLiteral(e){</span><span class="s1">return this</span><span class="s0">.estreeParseLiteral(e)}directiveToStmt(e){let s=e.value;</span><span class="s1">delete </span><span class="s0">e.value,s.type=</span><span class="s2">&quot;Literal&quot;</span><span class="s0">,s.raw=s.extra.raw,s.value=s.extra.expressionValue;let i=e;</span><span class="s1">return </span><span class="s0">i.type=</span><span class="s2">&quot;ExpressionStatement&quot;</span><span class="s0">,i.expression=s,i.directive=s.extra.rawValue,</span><span class="s1">delete </span><span class="s0">s.extra,i}initFunction(e,s){super.initFunction(e,s),e.expression=!</span><span class="s3">1</span><span class="s0">}checkDeclaration(e){e!=</span><span class="s1">null</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.isObjectProperty(e)?</span><span class="s1">this</span><span class="s0">.checkDeclaration(e.value):super.checkDeclaration(e)}getObjectOrClassMethodParams(e){</span><span class="s1">return </span><span class="s0">e.value.params}isValidDirective(e){</span><span class="s1">var </span><span class="s0">s;</span><span class="s1">return </span><span class="s0">e.type===</span><span class="s2">&quot;ExpressionStatement&quot;</span><span class="s0">&amp;&amp;e.expression.type===</span><span class="s2">&quot;Literal&quot;</span><span class="s0">&amp;&amp;</span><span class="s1">typeof </span><span class="s0">e.expression.value==</span><span class="s2">&quot;string&quot;</span><span class="s0">&amp;&amp;!((s=e.expression.extra)!=</span><span class="s1">null</span><span class="s0">&amp;&amp;s.parenthesized)}parseBlockBody(e,s,i,a,n){super.parseBlockBody(e,s,i,a,n);let o=e.directives.map(u=&gt;</span><span class="s1">this</span><span class="s0">.directiveToStmt(u));e.body=o.concat(e.body),</span><span class="s1">delete </span><span class="s0">e.directives}pushClassMethod(e,s,i,a,n,o){</span><span class="s1">this</span><span class="s0">.parseMethod(s,i,a,n,o,</span><span class="s2">&quot;ClassMethod&quot;</span><span class="s0">,!</span><span class="s3">0</span><span class="s0">),s.typeParameters&amp;&amp;(s.value.typeParameters=s.typeParameters,</span><span class="s1">delete </span><span class="s0">s.typeParameters),e.body.push(s)}parsePrivateName(){let e=super.parsePrivateName();</span><span class="s1">return this</span><span class="s0">.getPluginOption(</span><span class="s2">&quot;estree&quot;</span><span class="s0">,</span><span class="s2">&quot;classFeatures&quot;</span><span class="s0">)?</span><span class="s1">this</span><span class="s0">.convertPrivateNameToPrivateIdentifier(e):e}convertPrivateNameToPrivateIdentifier(e){let s=super.getPrivateNameSV(e);</span><span class="s1">return </span><span class="s0">e=e,</span><span class="s1">delete </span><span class="s0">e.id,e.name=s,e.type=</span><span class="s2">&quot;PrivateIdentifier&quot;</span><span class="s0">,e}isPrivateName(e){</span><span class="s1">return this</span><span class="s0">.getPluginOption(</span><span class="s2">&quot;estree&quot;</span><span class="s0">,</span><span class="s2">&quot;classFeatures&quot;</span><span class="s0">)?e.type===</span><span class="s2">&quot;PrivateIdentifier&quot;</span><span class="s0">:super.isPrivateName(e)}getPrivateNameSV(e){</span><span class="s1">return this</span><span class="s0">.getPluginOption(</span><span class="s2">&quot;estree&quot;</span><span class="s0">,</span><span class="s2">&quot;classFeatures&quot;</span><span class="s0">)?e.name:super.getPrivateNameSV(e)}parseLiteral(e,s){let i=super.parseLiteral(e,s);</span><span class="s1">return </span><span class="s0">i.raw=i.extra.raw,</span><span class="s1">delete </span><span class="s0">i.extra,i}parseFunctionBody(e,s){let i=arguments.length&gt;</span><span class="s3">2</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">2</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">2</span><span class="s0">]:!</span><span class="s3">1</span><span class="s0">;super.parseFunctionBody(e,s,i),e.expression=e.body.type!==</span><span class="s2">&quot;BlockStatement&quot;</span><span class="s0">}parseMethod(e,s,i,a,n,o){let u=arguments.length&gt;</span><span class="s3">6</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">6</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">6</span><span class="s0">]:!</span><span class="s3">1</span><span class="s0">,c=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">c.kind=e.kind,c=super.parseMethod(c,s,i,a,n,o,u),c.type=</span><span class="s2">&quot;FunctionExpression&quot;</span><span class="s0">,</span><span class="s1">delete </span><span class="s0">c.kind,e.value=c,o===</span><span class="s2">&quot;ClassPrivateMethod&quot;</span><span class="s0">&amp;&amp;(e.computed=!</span><span class="s3">1</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;MethodDefinition&quot;</span><span class="s0">)}parseClassProperty(){let e=super.parseClassProperty(...arguments);</span><span class="s1">return this</span><span class="s0">.getPluginOption(</span><span class="s2">&quot;estree&quot;</span><span class="s0">,</span><span class="s2">&quot;classFeatures&quot;</span><span class="s0">)&amp;&amp;(e.type=</span><span class="s2">&quot;PropertyDefinition&quot;</span><span class="s0">),e}parseClassPrivateProperty(){let e=super.parseClassPrivateProperty(...arguments);</span><span class="s1">return this</span><span class="s0">.getPluginOption(</span><span class="s2">&quot;estree&quot;</span><span class="s0">,</span><span class="s2">&quot;classFeatures&quot;</span><span class="s0">)&amp;&amp;(e.type=</span><span class="s2">&quot;PropertyDefinition&quot;</span><span class="s0">,e.computed=!</span><span class="s3">1</span><span class="s0">),e}parseObjectMethod(e,s,i,a,n){let o=super.parseObjectMethod(e,s,i,a,n);</span><span class="s1">return </span><span class="s0">o&amp;&amp;(o.type=</span><span class="s2">&quot;Property&quot;</span><span class="s0">,o.kind===</span><span class="s2">&quot;method&quot;</span><span class="s0">&amp;&amp;(o.kind=</span><span class="s2">&quot;init&quot;</span><span class="s0">),o.shorthand=!</span><span class="s3">1</span><span class="s0">),o}parseObjectProperty(e,s,i,a){let n=super.parseObjectProperty(e,s,i,a);</span><span class="s1">return </span><span class="s0">n&amp;&amp;(n.kind=</span><span class="s2">&quot;init&quot;</span><span class="s0">,n.type=</span><span class="s2">&quot;Property&quot;</span><span class="s0">),n}isValidLVal(e,s,i){</span><span class="s1">return </span><span class="s0">e===</span><span class="s2">&quot;Property&quot;</span><span class="s0">?</span><span class="s2">&quot;value&quot;</span><span class="s0">:super.isValidLVal(e,s,i)}isAssignable(e,s){</span><span class="s1">return </span><span class="s0">e!=</span><span class="s1">null</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.isObjectProperty(e)?</span><span class="s1">this</span><span class="s0">.isAssignable(e.value,s):super.isAssignable(e,s)}toAssignable(e){let s=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">1</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">1</span><span class="s0">]:!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(e!=</span><span class="s1">null</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.isObjectProperty(e)){let{key:i,value:a}=e;</span><span class="s1">this</span><span class="s0">.isPrivateName(i)&amp;&amp;</span><span class="s1">this</span><span class="s0">.classScope.usePrivateName(</span><span class="s1">this</span><span class="s0">.getPrivateNameSV(i),i.loc.start),</span><span class="s1">this</span><span class="s0">.toAssignable(a,s)}</span><span class="s1">else </span><span class="s0">super.toAssignable(e,s)}toAssignableObjectExpressionProp(e,s,i){e.kind===</span><span class="s2">&quot;get&quot;</span><span class="s0">||e.kind===</span><span class="s2">&quot;set&quot;</span><span class="s0">?</span><span class="s1">this</span><span class="s0">.raise(f.PatternHasAccessor,{at:e.key}):e.method?</span><span class="s1">this</span><span class="s0">.raise(f.PatternHasMethod,{at:e.key}):super.toAssignableObjectExpressionProp(e,s,i)}finishCallExpression(e,s){let i=super.finishCallExpression(e,s);</span><span class="s1">if</span><span class="s0">(i.callee.type===</span><span class="s2">&quot;Import&quot;</span><span class="s0">){</span><span class="s1">if</span><span class="s0">(i.type=</span><span class="s2">&quot;ImportExpression&quot;</span><span class="s0">,i.source=i.arguments[</span><span class="s3">0</span><span class="s0">],</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s2">&quot;importAssertions&quot;</span><span class="s0">)){</span><span class="s1">var </span><span class="s0">a;i.attributes=(a=i.arguments[</span><span class="s3">1</span><span class="s0">])!=</span><span class="s1">null</span><span class="s0">?a:</span><span class="s1">null</span><span class="s0">}</span><span class="s1">delete </span><span class="s0">i.arguments,</span><span class="s1">delete </span><span class="s0">i.callee}</span><span class="s1">return </span><span class="s0">i}toReferencedArguments(e){e.type!==</span><span class="s2">&quot;ImportExpression&quot;</span><span class="s0">&amp;&amp;super.toReferencedArguments(e)}parseExport(e,s){let i=</span><span class="s1">this</span><span class="s0">.state.lastTokStartLoc,a=super.parseExport(e,s);</span><span class="s1">switch</span><span class="s0">(a.type){</span><span class="s1">case</span><span class="s2">&quot;ExportAllDeclaration&quot;</span><span class="s0">:a.exported=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;ExportNamedDeclaration&quot;</span><span class="s0">:a.specifiers.length===</span><span class="s3">1</span><span class="s0">&amp;&amp;a.specifiers[</span><span class="s3">0</span><span class="s0">].type===</span><span class="s2">&quot;ExportNamespaceSpecifier&quot;</span><span class="s0">&amp;&amp;(a.type=</span><span class="s2">&quot;ExportAllDeclaration&quot;</span><span class="s0">,a.exported=a.specifiers[</span><span class="s3">0</span><span class="s0">].exported,</span><span class="s1">delete </span><span class="s0">a.specifiers);</span><span class="s1">case</span><span class="s2">&quot;ExportDefaultDeclaration&quot;</span><span class="s0">:{</span><span class="s1">var </span><span class="s0">n;let{declaration:o}=a;(o==</span><span class="s1">null</span><span class="s0">?</span><span class="s1">void </span><span class="s3">0</span><span class="s0">:o.type)===</span><span class="s2">&quot;ClassDeclaration&quot;</span><span class="s0">&amp;&amp;((n=o.decorators)==</span><span class="s1">null</span><span class="s0">?</span><span class="s1">void </span><span class="s3">0</span><span class="s0">:n.length)&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;o.start===a.start&amp;&amp;</span><span class="s1">this</span><span class="s0">.resetStartLocation(a,i)}</span><span class="s1">break</span><span class="s0">}</span><span class="s1">return </span><span class="s0">a}parseSubscript(e,s,i,a){let n=super.parseSubscript(e,s,i,a);</span><span class="s1">if</span><span class="s0">(a.optionalChainMember){</span><span class="s1">if</span><span class="s0">((n.type===</span><span class="s2">&quot;OptionalMemberExpression&quot;</span><span class="s0">||n.type===</span><span class="s2">&quot;OptionalCallExpression&quot;</span><span class="s0">)&amp;&amp;(n.type=n.type.substring(</span><span class="s3">8</span><span class="s0">)),a.stop){let o=</span><span class="s1">this</span><span class="s0">.startNodeAtNode(n);</span><span class="s1">return </span><span class="s0">o.expression=n,</span><span class="s1">this</span><span class="s0">.finishNode(o,</span><span class="s2">&quot;ChainExpression&quot;</span><span class="s0">)}}</span><span class="s1">else</span><span class="s0">(n.type===</span><span class="s2">&quot;MemberExpression&quot;</span><span class="s0">||n.type===</span><span class="s2">&quot;CallExpression&quot;</span><span class="s0">)&amp;&amp;(n.optional=!</span><span class="s3">1</span><span class="s0">);</span><span class="s1">return </span><span class="s0">n}hasPropertyAsPrivateName(e){</span><span class="s1">return </span><span class="s0">e.type===</span><span class="s2">&quot;ChainExpression&quot;</span><span class="s0">&amp;&amp;(e=e.expression),super.hasPropertyAsPrivateName(e)}isObjectProperty(e){</span><span class="s1">return </span><span class="s0">e.type===</span><span class="s2">&quot;Property&quot;</span><span class="s0">&amp;&amp;e.kind===</span><span class="s2">&quot;init&quot;</span><span class="s0">&amp;&amp;!e.method}isObjectMethod(e){</span><span class="s1">return </span><span class="s0">e.method||e.kind===</span><span class="s2">&quot;get&quot;</span><span class="s0">||e.kind===</span><span class="s2">&quot;set&quot;</span><span class="s0">}finishNodeAt(e,s,i){</span><span class="s1">return </span><span class="s0">ze(super.finishNodeAt(e,s,i))}resetStartLocation(e,s){super.resetStartLocation(e,s),ze(e)}resetEndLocation(e){let s=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">1</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">1</span><span class="s0">]:</span><span class="s1">this</span><span class="s0">.state.lastTokEndLoc;super.resetEndLocation(e,s),ze(e)}},Vt=</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">AA</span><span class="s4">\x</span><span class="s2">B5</span><span class="s4">\x</span><span class="s2">BA</span><span class="s4">\x</span><span class="s2">C0-</span><span class="s4">\x</span><span class="s2">D6</span><span class="s4">\x</span><span class="s2">D8-</span><span class="s4">\x</span><span class="s2">F6</span><span class="s4">\x</span><span class="s2">F8-</span><span class="s4">\u02C1\u02C6</span><span class="s2">-</span><span class="s4">\u02D1\u02E0</span><span class="s2">-</span><span class="s4">\u02E4\u02EC\u02EE\u0370</span><span class="s2">-</span><span class="s4">\u0374\u0376\u0377\u037A</span><span class="s2">-</span><span class="s4">\u037D\u037F\u0386\u0388</span><span class="s2">-</span><span class="s4">\u038A\u038C\u038E</span><span class="s2">-</span><span class="s4">\u03A1\u03A3</span><span class="s2">-</span><span class="s4">\u03F5\u03F7</span><span class="s2">-</span><span class="s4">\u0481\u048A</span><span class="s2">-</span><span class="s4">\u052F\u0531</span><span class="s2">-</span><span class="s4">\u0556\u0559\u0560</span><span class="s2">-</span><span class="s4">\u0588\u05D0</span><span class="s2">-</span><span class="s4">\u05EA\u05EF</span><span class="s2">-</span><span class="s4">\u05F2\u0620</span><span class="s2">-</span><span class="s4">\u064A\u066E\u066F\u0671</span><span class="s2">-</span><span class="s4">\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA</span><span class="s2">-</span><span class="s4">\u06FC\u06FF\u0710\u0712</span><span class="s2">-</span><span class="s4">\u072F\u074D</span><span class="s2">-</span><span class="s4">\u07A5\u07B1\u07CA</span><span class="s2">-</span><span class="s4">\u07EA\u07F4\u07F5\u07FA\u0800</span><span class="s2">-</span><span class="s4">\u0815\u081A\u0824\u0828\u0840</span><span class="s2">-</span><span class="s4">\u0858\u0860</span><span class="s2">-</span><span class="s4">\u086A\u0870</span><span class="s2">-</span><span class="s4">\u0887\u0889</span><span class="s2">-</span><span class="s4">\u088E\u08A0</span><span class="s2">-</span><span class="s4">\u08C9\u0904</span><span class="s2">-</span><span class="s4">\u0939\u093D\u0950\u0958</span><span class="s2">-</span><span class="s4">\u0961\u0971</span><span class="s2">-</span><span class="s4">\u0980\u0985</span><span class="s2">-</span><span class="s4">\u098C\u098F\u0990\u0993</span><span class="s2">-</span><span class="s4">\u09A8\u09AA</span><span class="s2">-</span><span class="s4">\u09B0\u09B2\u09B6</span><span class="s2">-</span><span class="s4">\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF</span><span class="s2">-</span><span class="s4">\u09E1\u09F0\u09F1\u09FC\u0A05</span><span class="s2">-</span><span class="s4">\u0A0A\u0A0F\u0A10\u0A13</span><span class="s2">-</span><span class="s4">\u0A28\u0A2A</span><span class="s2">-</span><span class="s4">\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59</span><span class="s2">-</span><span class="s4">\u0A5C\u0A5E\u0A72</span><span class="s2">-</span><span class="s4">\u0A74\u0A85</span><span class="s2">-</span><span class="s4">\u0A8D\u0A8F</span><span class="s2">-</span><span class="s4">\u0A91\u0A93</span><span class="s2">-</span><span class="s4">\u0AA8\u0AAA</span><span class="s2">-</span><span class="s4">\u0AB0\u0AB2\u0AB3\u0AB5</span><span class="s2">-</span><span class="s4">\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05</span><span class="s2">-</span><span class="s4">\u0B0C\u0B0F\u0B10\u0B13</span><span class="s2">-</span><span class="s4">\u0B28\u0B2A</span><span class="s2">-</span><span class="s4">\u0B30\u0B32\u0B33\u0B35</span><span class="s2">-</span><span class="s4">\u0B39\u0B3D\u0B5C\u0B5D\u0B5F</span><span class="s2">-</span><span class="s4">\u0B61\u0B71\u0B83\u0B85</span><span class="s2">-</span><span class="s4">\u0B8A\u0B8E</span><span class="s2">-</span><span class="s4">\u0B90\u0B92</span><span class="s2">-</span><span class="s4">\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8</span><span class="s2">-</span><span class="s4">\u0BAA\u0BAE</span><span class="s2">-</span><span class="s4">\u0BB9\u0BD0\u0C05</span><span class="s2">-</span><span class="s4">\u0C0C\u0C0E</span><span class="s2">-</span><span class="s4">\u0C10\u0C12</span><span class="s2">-</span><span class="s4">\u0C28\u0C2A</span><span class="s2">-</span><span class="s4">\u0C39\u0C3D\u0C58</span><span class="s2">-</span><span class="s4">\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85</span><span class="s2">-</span><span class="s4">\u0C8C\u0C8E</span><span class="s2">-</span><span class="s4">\u0C90\u0C92</span><span class="s2">-</span><span class="s4">\u0CA8\u0CAA</span><span class="s2">-</span><span class="s4">\u0CB3\u0CB5</span><span class="s2">-</span><span class="s4">\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04</span><span class="s2">-</span><span class="s4">\u0D0C\u0D0E</span><span class="s2">-</span><span class="s4">\u0D10\u0D12</span><span class="s2">-</span><span class="s4">\u0D3A\u0D3D\u0D4E\u0D54</span><span class="s2">-</span><span class="s4">\u0D56\u0D5F</span><span class="s2">-</span><span class="s4">\u0D61\u0D7A</span><span class="s2">-</span><span class="s4">\u0D7F\u0D85</span><span class="s2">-</span><span class="s4">\u0D96\u0D9A</span><span class="s2">-</span><span class="s4">\u0DB1\u0DB3</span><span class="s2">-</span><span class="s4">\u0DBB\u0DBD\u0DC0</span><span class="s2">-</span><span class="s4">\u0DC6\u0E01</span><span class="s2">-</span><span class="s4">\u0E30\u0E32\u0E33\u0E40</span><span class="s2">-</span><span class="s4">\u0E46\u0E81\u0E82\u0E84\u0E86</span><span class="s2">-</span><span class="s4">\u0E8A\u0E8C</span><span class="s2">-</span><span class="s4">\u0EA3\u0EA5\u0EA7</span><span class="s2">-</span><span class="s4">\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0</span><span class="s2">-</span><span class="s4">\u0EC4\u0EC6\u0EDC</span><span class="s2">-</span><span class="s4">\u0EDF\u0F00\u0F40</span><span class="s2">-</span><span class="s4">\u0F47\u0F49</span><span class="s2">-</span><span class="s4">\u0F6C\u0F88</span><span class="s2">-</span><span class="s4">\u0F8C\u1000</span><span class="s2">-</span><span class="s4">\u102A\u103F\u1050</span><span class="s2">-</span><span class="s4">\u1055\u105A</span><span class="s2">-</span><span class="s4">\u105D\u1061\u1065\u1066\u106E</span><span class="s2">-</span><span class="s4">\u1070\u1075</span><span class="s2">-</span><span class="s4">\u1081\u108E\u10A0</span><span class="s2">-</span><span class="s4">\u10C5\u10C7\u10CD\u10D0</span><span class="s2">-</span><span class="s4">\u10FA\u10FC</span><span class="s2">-</span><span class="s4">\u1248\u124A</span><span class="s2">-</span><span class="s4">\u124D\u1250</span><span class="s2">-</span><span class="s4">\u1256\u1258\u125A</span><span class="s2">-</span><span class="s4">\u125D\u1260</span><span class="s2">-</span><span class="s4">\u1288\u128A</span><span class="s2">-</span><span class="s4">\u128D\u1290</span><span class="s2">-</span><span class="s4">\u12B0\u12B2</span><span class="s2">-</span><span class="s4">\u12B5\u12B8</span><span class="s2">-</span><span class="s4">\u12BE\u12C0\u12C2</span><span class="s2">-</span><span class="s4">\u12C5\u12C8</span><span class="s2">-</span><span class="s4">\u12D6\u12D8</span><span class="s2">-</span><span class="s4">\u1310\u1312</span><span class="s2">-</span><span class="s4">\u1315\u1318</span><span class="s2">-</span><span class="s4">\u135A\u1380</span><span class="s2">-</span><span class="s4">\u138F\u13A0</span><span class="s2">-</span><span class="s4">\u13F5\u13F8</span><span class="s2">-</span><span class="s4">\u13FD\u1401</span><span class="s2">-</span><span class="s4">\u166C\u166F</span><span class="s2">-</span><span class="s4">\u167F\u1681</span><span class="s2">-</span><span class="s4">\u169A\u16A0</span><span class="s2">-</span><span class="s4">\u16EA\u16EE</span><span class="s2">-</span><span class="s4">\u16F8\u1700</span><span class="s2">-</span><span class="s4">\u1711\u171F</span><span class="s2">-</span><span class="s4">\u1731\u1740</span><span class="s2">-</span><span class="s4">\u1751\u1760</span><span class="s2">-</span><span class="s4">\u176C\u176E</span><span class="s2">-</span><span class="s4">\u1770\u1780</span><span class="s2">-</span><span class="s4">\u17B3\u17D7\u17DC\u1820</span><span class="s2">-</span><span class="s4">\u1878\u1880</span><span class="s2">-</span><span class="s4">\u18A8\u18AA\u18B0</span><span class="s2">-</span><span class="s4">\u18F5\u1900</span><span class="s2">-</span><span class="s4">\u191E\u1950</span><span class="s2">-</span><span class="s4">\u196D\u1970</span><span class="s2">-</span><span class="s4">\u1974\u1980</span><span class="s2">-</span><span class="s4">\u19AB\u19B0</span><span class="s2">-</span><span class="s4">\u19C9\u1A00</span><span class="s2">-</span><span class="s4">\u1A16\u1A20</span><span class="s2">-</span><span class="s4">\u1A54\u1AA7\u1B05</span><span class="s2">-</span><span class="s4">\u1B33\u1B45</span><span class="s2">-</span><span class="s4">\u1B4C\u1B83</span><span class="s2">-</span><span class="s4">\u1BA0\u1BAE\u1BAF\u1BBA</span><span class="s2">-</span><span class="s4">\u1BE5\u1C00</span><span class="s2">-</span><span class="s4">\u1C23\u1C4D</span><span class="s2">-</span><span class="s4">\u1C4F\u1C5A</span><span class="s2">-</span><span class="s4">\u1C7D\u1C80</span><span class="s2">-</span><span class="s4">\u1C88\u1C90</span><span class="s2">-</span><span class="s4">\u1CBA\u1CBD</span><span class="s2">-</span><span class="s4">\u1CBF\u1CE9</span><span class="s2">-</span><span class="s4">\u1CEC\u1CEE</span><span class="s2">-</span><span class="s4">\u1CF3\u1CF5\u1CF6\u1CFA\u1D00</span><span class="s2">-</span><span class="s4">\u1DBF\u1E00</span><span class="s2">-</span><span class="s4">\u1F15\u1F18</span><span class="s2">-</span><span class="s4">\u1F1D\u1F20</span><span class="s2">-</span><span class="s4">\u1F45\u1F48</span><span class="s2">-</span><span class="s4">\u1F4D\u1F50</span><span class="s2">-</span><span class="s4">\u1F57\u1F59\u1F5B\u1F5D\u1F5F</span><span class="s2">-</span><span class="s4">\u1F7D\u1F80</span><span class="s2">-</span><span class="s4">\u1FB4\u1FB6</span><span class="s2">-</span><span class="s4">\u1FBC\u1FBE\u1FC2</span><span class="s2">-</span><span class="s4">\u1FC4\u1FC6</span><span class="s2">-</span><span class="s4">\u1FCC\u1FD0</span><span class="s2">-</span><span class="s4">\u1FD3\u1FD6</span><span class="s2">-</span><span class="s4">\u1FDB\u1FE0</span><span class="s2">-</span><span class="s4">\u1FEC\u1FF2</span><span class="s2">-</span><span class="s4">\u1FF4\u1FF6</span><span class="s2">-</span><span class="s4">\u1FFC\u2071\u207F\u2090</span><span class="s2">-</span><span class="s4">\u209C\u2102\u2107\u210A</span><span class="s2">-</span><span class="s4">\u2113\u2115\u2118</span><span class="s2">-</span><span class="s4">\u211D\u2124\u2126\u2128\u212A</span><span class="s2">-</span><span class="s4">\u2139\u213C</span><span class="s2">-</span><span class="s4">\u213F\u2145</span><span class="s2">-</span><span class="s4">\u2149\u214E\u2160</span><span class="s2">-</span><span class="s4">\u2188\u2C00</span><span class="s2">-</span><span class="s4">\u2CE4\u2CEB</span><span class="s2">-</span><span class="s4">\u2CEE\u2CF2\u2CF3\u2D00</span><span class="s2">-</span><span class="s4">\u2D25\u2D27\u2D2D\u2D30</span><span class="s2">-</span><span class="s4">\u2D67\u2D6F\u2D80</span><span class="s2">-</span><span class="s4">\u2D96\u2DA0</span><span class="s2">-</span><span class="s4">\u2DA6\u2DA8</span><span class="s2">-</span><span class="s4">\u2DAE\u2DB0</span><span class="s2">-</span><span class="s4">\u2DB6\u2DB8</span><span class="s2">-</span><span class="s4">\u2DBE\u2DC0</span><span class="s2">-</span><span class="s4">\u2DC6\u2DC8</span><span class="s2">-</span><span class="s4">\u2DCE\u2DD0</span><span class="s2">-</span><span class="s4">\u2DD6\u2DD8</span><span class="s2">-</span><span class="s4">\u2DDE\u3005</span><span class="s2">-</span><span class="s4">\u3007\u3021</span><span class="s2">-</span><span class="s4">\u3029\u3031</span><span class="s2">-</span><span class="s4">\u3035\u3038</span><span class="s2">-</span><span class="s4">\u303C\u3041</span><span class="s2">-</span><span class="s4">\u3096\u309B</span><span class="s2">-</span><span class="s4">\u309F\u30A1</span><span class="s2">-</span><span class="s4">\u30FA\u30FC</span><span class="s2">-</span><span class="s4">\u30FF\u3105</span><span class="s2">-</span><span class="s4">\u312F\u3131</span><span class="s2">-</span><span class="s4">\u318E\u31A0</span><span class="s2">-</span><span class="s4">\u31BF\u31F0</span><span class="s2">-</span><span class="s4">\u31FF\u3400</span><span class="s2">-</span><span class="s4">\u4DBF\u4E00</span><span class="s2">-</span><span class="s4">\uA48C\uA4D0</span><span class="s2">-</span><span class="s4">\uA4FD\uA500</span><span class="s2">-</span><span class="s4">\uA60C\uA610</span><span class="s2">-</span><span class="s4">\uA61F\uA62A\uA62B\uA640</span><span class="s2">-</span><span class="s4">\uA66E\uA67F</span><span class="s2">-</span><span class="s4">\uA69D\uA6A0</span><span class="s2">-</span><span class="s4">\uA6EF\uA717</span><span class="s2">-</span><span class="s4">\uA71F\uA722</span><span class="s2">-</span><span class="s4">\uA788\uA78B</span><span class="s2">-</span><span class="s4">\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5</span><span class="s2">-</span><span class="s4">\uA7D9\uA7F2</span><span class="s2">-</span><span class="s4">\uA801\uA803</span><span class="s2">-</span><span class="s4">\uA805\uA807</span><span class="s2">-</span><span class="s4">\uA80A\uA80C</span><span class="s2">-</span><span class="s4">\uA822\uA840</span><span class="s2">-</span><span class="s4">\uA873\uA882</span><span class="s2">-</span><span class="s4">\uA8B3\uA8F2</span><span class="s2">-</span><span class="s4">\uA8F7\uA8FB\uA8FD\uA8FE\uA90A</span><span class="s2">-</span><span class="s4">\uA925\uA930</span><span class="s2">-</span><span class="s4">\uA946\uA960</span><span class="s2">-</span><span class="s4">\uA97C\uA984</span><span class="s2">-</span><span class="s4">\uA9B2\uA9CF\uA9E0</span><span class="s2">-</span><span class="s4">\uA9E4\uA9E6</span><span class="s2">-</span><span class="s4">\uA9EF\uA9FA</span><span class="s2">-</span><span class="s4">\uA9FE\uAA00</span><span class="s2">-</span><span class="s4">\uAA28\uAA40</span><span class="s2">-</span><span class="s4">\uAA42\uAA44</span><span class="s2">-</span><span class="s4">\uAA4B\uAA60</span><span class="s2">-</span><span class="s4">\uAA76\uAA7A\uAA7E</span><span class="s2">-</span><span class="s4">\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9</span><span class="s2">-</span><span class="s4">\uAABD\uAAC0\uAAC2\uAADB</span><span class="s2">-</span><span class="s4">\uAADD\uAAE0</span><span class="s2">-</span><span class="s4">\uAAEA\uAAF2</span><span class="s2">-</span><span class="s4">\uAAF4\uAB01</span><span class="s2">-</span><span class="s4">\uAB06\uAB09</span><span class="s2">-</span><span class="s4">\uAB0E\uAB11</span><span class="s2">-</span><span class="s4">\uAB16\uAB20</span><span class="s2">-</span><span class="s4">\uAB26\uAB28</span><span class="s2">-</span><span class="s4">\uAB2E\uAB30</span><span class="s2">-</span><span class="s4">\uAB5A\uAB5C</span><span class="s2">-</span><span class="s4">\uAB69\uAB70</span><span class="s2">-</span><span class="s4">\uABE2\uAC00</span><span class="s2">-</span><span class="s4">\uD7A3\uD7B0</span><span class="s2">-</span><span class="s4">\uD7C6\uD7CB</span><span class="s2">-</span><span class="s4">\uD7FB\uF900</span><span class="s2">-</span><span class="s4">\uFA6D\uFA70</span><span class="s2">-</span><span class="s4">\uFAD9\uFB00</span><span class="s2">-</span><span class="s4">\uFB06\uFB13</span><span class="s2">-</span><span class="s4">\uFB17\uFB1D\uFB1F</span><span class="s2">-</span><span class="s4">\uFB28\uFB2A</span><span class="s2">-</span><span class="s4">\uFB36\uFB38</span><span class="s2">-</span><span class="s4">\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46</span><span class="s2">-</span><span class="s4">\uFBB1\uFBD3</span><span class="s2">-</span><span class="s4">\uFD3D\uFD50</span><span class="s2">-</span><span class="s4">\uFD8F\uFD92</span><span class="s2">-</span><span class="s4">\uFDC7\uFDF0</span><span class="s2">-</span><span class="s4">\uFDFB\uFE70</span><span class="s2">-</span><span class="s4">\uFE74\uFE76</span><span class="s2">-</span><span class="s4">\uFEFC\uFF21</span><span class="s2">-</span><span class="s4">\uFF3A\uFF41</span><span class="s2">-</span><span class="s4">\uFF5A\uFF66</span><span class="s2">-</span><span class="s4">\uFFBE\uFFC2</span><span class="s2">-</span><span class="s4">\uFFC7\uFFCA</span><span class="s2">-</span><span class="s4">\uFFCF\uFFD2</span><span class="s2">-</span><span class="s4">\uFFD7\uFFDA</span><span class="s2">-</span><span class="s4">\uFFDC</span><span class="s2">&quot;</span><span class="s0">,pr=</span><span class="s2">&quot;</span><span class="s4">\u200C\u200D\x</span><span class="s2">B7</span><span class="s4">\u0300</span><span class="s2">-</span><span class="s4">\u036F\u0387\u0483</span><span class="s2">-</span><span class="s4">\u0487\u0591</span><span class="s2">-</span><span class="s4">\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610</span><span class="s2">-</span><span class="s4">\u061A\u064B</span><span class="s2">-</span><span class="s4">\u0669\u0670\u06D6</span><span class="s2">-</span><span class="s4">\u06DC\u06DF</span><span class="s2">-</span><span class="s4">\u06E4\u06E7\u06E8\u06EA</span><span class="s2">-</span><span class="s4">\u06ED\u06F0</span><span class="s2">-</span><span class="s4">\u06F9\u0711\u0730</span><span class="s2">-</span><span class="s4">\u074A\u07A6</span><span class="s2">-</span><span class="s4">\u07B0\u07C0</span><span class="s2">-</span><span class="s4">\u07C9\u07EB</span><span class="s2">-</span><span class="s4">\u07F3\u07FD\u0816</span><span class="s2">-</span><span class="s4">\u0819\u081B</span><span class="s2">-</span><span class="s4">\u0823\u0825</span><span class="s2">-</span><span class="s4">\u0827\u0829</span><span class="s2">-</span><span class="s4">\u082D\u0859</span><span class="s2">-</span><span class="s4">\u085B\u0898</span><span class="s2">-</span><span class="s4">\u089F\u08CA</span><span class="s2">-</span><span class="s4">\u08E1\u08E3</span><span class="s2">-</span><span class="s4">\u0903\u093A</span><span class="s2">-</span><span class="s4">\u093C\u093E</span><span class="s2">-</span><span class="s4">\u094F\u0951</span><span class="s2">-</span><span class="s4">\u0957\u0962\u0963\u0966</span><span class="s2">-</span><span class="s4">\u096F\u0981</span><span class="s2">-</span><span class="s4">\u0983\u09BC\u09BE</span><span class="s2">-</span><span class="s4">\u09C4\u09C7\u09C8\u09CB</span><span class="s2">-</span><span class="s4">\u09CD\u09D7\u09E2\u09E3\u09E6</span><span class="s2">-</span><span class="s4">\u09EF\u09FE\u0A01</span><span class="s2">-</span><span class="s4">\u0A03\u0A3C\u0A3E</span><span class="s2">-</span><span class="s4">\u0A42\u0A47\u0A48\u0A4B</span><span class="s2">-</span><span class="s4">\u0A4D\u0A51\u0A66</span><span class="s2">-</span><span class="s4">\u0A71\u0A75\u0A81</span><span class="s2">-</span><span class="s4">\u0A83\u0ABC\u0ABE</span><span class="s2">-</span><span class="s4">\u0AC5\u0AC7</span><span class="s2">-</span><span class="s4">\u0AC9\u0ACB</span><span class="s2">-</span><span class="s4">\u0ACD\u0AE2\u0AE3\u0AE6</span><span class="s2">-</span><span class="s4">\u0AEF\u0AFA</span><span class="s2">-</span><span class="s4">\u0AFF\u0B01</span><span class="s2">-</span><span class="s4">\u0B03\u0B3C\u0B3E</span><span class="s2">-</span><span class="s4">\u0B44\u0B47\u0B48\u0B4B</span><span class="s2">-</span><span class="s4">\u0B4D\u0B55</span><span class="s2">-</span><span class="s4">\u0B57\u0B62\u0B63\u0B66</span><span class="s2">-</span><span class="s4">\u0B6F\u0B82\u0BBE</span><span class="s2">-</span><span class="s4">\u0BC2\u0BC6</span><span class="s2">-</span><span class="s4">\u0BC8\u0BCA</span><span class="s2">-</span><span class="s4">\u0BCD\u0BD7\u0BE6</span><span class="s2">-</span><span class="s4">\u0BEF\u0C00</span><span class="s2">-</span><span class="s4">\u0C04\u0C3C\u0C3E</span><span class="s2">-</span><span class="s4">\u0C44\u0C46</span><span class="s2">-</span><span class="s4">\u0C48\u0C4A</span><span class="s2">-</span><span class="s4">\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66</span><span class="s2">-</span><span class="s4">\u0C6F\u0C81</span><span class="s2">-</span><span class="s4">\u0C83\u0CBC\u0CBE</span><span class="s2">-</span><span class="s4">\u0CC4\u0CC6</span><span class="s2">-</span><span class="s4">\u0CC8\u0CCA</span><span class="s2">-</span><span class="s4">\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6</span><span class="s2">-</span><span class="s4">\u0CEF\u0CF3\u0D00</span><span class="s2">-</span><span class="s4">\u0D03\u0D3B\u0D3C\u0D3E</span><span class="s2">-</span><span class="s4">\u0D44\u0D46</span><span class="s2">-</span><span class="s4">\u0D48\u0D4A</span><span class="s2">-</span><span class="s4">\u0D4D\u0D57\u0D62\u0D63\u0D66</span><span class="s2">-</span><span class="s4">\u0D6F\u0D81</span><span class="s2">-</span><span class="s4">\u0D83\u0DCA\u0DCF</span><span class="s2">-</span><span class="s4">\u0DD4\u0DD6\u0DD8</span><span class="s2">-</span><span class="s4">\u0DDF\u0DE6</span><span class="s2">-</span><span class="s4">\u0DEF\u0DF2\u0DF3\u0E31\u0E34</span><span class="s2">-</span><span class="s4">\u0E3A\u0E47</span><span class="s2">-</span><span class="s4">\u0E4E\u0E50</span><span class="s2">-</span><span class="s4">\u0E59\u0EB1\u0EB4</span><span class="s2">-</span><span class="s4">\u0EBC\u0EC8</span><span class="s2">-</span><span class="s4">\u0ECE\u0ED0</span><span class="s2">-</span><span class="s4">\u0ED9\u0F18\u0F19\u0F20</span><span class="s2">-</span><span class="s4">\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71</span><span class="s2">-</span><span class="s4">\u0F84\u0F86\u0F87\u0F8D</span><span class="s2">-</span><span class="s4">\u0F97\u0F99</span><span class="s2">-</span><span class="s4">\u0FBC\u0FC6\u102B</span><span class="s2">-</span><span class="s4">\u103E\u1040</span><span class="s2">-</span><span class="s4">\u1049\u1056</span><span class="s2">-</span><span class="s4">\u1059\u105E</span><span class="s2">-</span><span class="s4">\u1060\u1062</span><span class="s2">-</span><span class="s4">\u1064\u1067</span><span class="s2">-</span><span class="s4">\u106D\u1071</span><span class="s2">-</span><span class="s4">\u1074\u1082</span><span class="s2">-</span><span class="s4">\u108D\u108F</span><span class="s2">-</span><span class="s4">\u109D\u135D</span><span class="s2">-</span><span class="s4">\u135F\u1369</span><span class="s2">-</span><span class="s4">\u1371\u1712</span><span class="s2">-</span><span class="s4">\u1715\u1732</span><span class="s2">-</span><span class="s4">\u1734\u1752\u1753\u1772\u1773\u17B4</span><span class="s2">-</span><span class="s4">\u17D3\u17DD\u17E0</span><span class="s2">-</span><span class="s4">\u17E9\u180B</span><span class="s2">-</span><span class="s4">\u180D\u180F</span><span class="s2">-</span><span class="s4">\u1819\u18A9\u1920</span><span class="s2">-</span><span class="s4">\u192B\u1930</span><span class="s2">-</span><span class="s4">\u193B\u1946</span><span class="s2">-</span><span class="s4">\u194F\u19D0</span><span class="s2">-</span><span class="s4">\u19DA\u1A17</span><span class="s2">-</span><span class="s4">\u1A1B\u1A55</span><span class="s2">-</span><span class="s4">\u1A5E\u1A60</span><span class="s2">-</span><span class="s4">\u1A7C\u1A7F</span><span class="s2">-</span><span class="s4">\u1A89\u1A90</span><span class="s2">-</span><span class="s4">\u1A99\u1AB0</span><span class="s2">-</span><span class="s4">\u1ABD\u1ABF</span><span class="s2">-</span><span class="s4">\u1ACE\u1B00</span><span class="s2">-</span><span class="s4">\u1B04\u1B34</span><span class="s2">-</span><span class="s4">\u1B44\u1B50</span><span class="s2">-</span><span class="s4">\u1B59\u1B6B</span><span class="s2">-</span><span class="s4">\u1B73\u1B80</span><span class="s2">-</span><span class="s4">\u1B82\u1BA1</span><span class="s2">-</span><span class="s4">\u1BAD\u1BB0</span><span class="s2">-</span><span class="s4">\u1BB9\u1BE6</span><span class="s2">-</span><span class="s4">\u1BF3\u1C24</span><span class="s2">-</span><span class="s4">\u1C37\u1C40</span><span class="s2">-</span><span class="s4">\u1C49\u1C50</span><span class="s2">-</span><span class="s4">\u1C59\u1CD0</span><span class="s2">-</span><span class="s4">\u1CD2\u1CD4</span><span class="s2">-</span><span class="s4">\u1CE8\u1CED\u1CF4\u1CF7</span><span class="s2">-</span><span class="s4">\u1CF9\u1DC0</span><span class="s2">-</span><span class="s4">\u1DFF\u203F\u2040\u2054\u20D0</span><span class="s2">-</span><span class="s4">\u20DC\u20E1\u20E5</span><span class="s2">-</span><span class="s4">\u20F0\u2CEF</span><span class="s2">-</span><span class="s4">\u2CF1\u2D7F\u2DE0</span><span class="s2">-</span><span class="s4">\u2DFF\u302A</span><span class="s2">-</span><span class="s4">\u302F\u3099\u309A\uA620</span><span class="s2">-</span><span class="s4">\uA629\uA66F\uA674</span><span class="s2">-</span><span class="s4">\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823</span><span class="s2">-</span><span class="s4">\uA827\uA82C\uA880\uA881\uA8B4</span><span class="s2">-</span><span class="s4">\uA8C5\uA8D0</span><span class="s2">-</span><span class="s4">\uA8D9\uA8E0</span><span class="s2">-</span><span class="s4">\uA8F1\uA8FF</span><span class="s2">-</span><span class="s4">\uA909\uA926</span><span class="s2">-</span><span class="s4">\uA92D\uA947</span><span class="s2">-</span><span class="s4">\uA953\uA980</span><span class="s2">-</span><span class="s4">\uA983\uA9B3</span><span class="s2">-</span><span class="s4">\uA9C0\uA9D0</span><span class="s2">-</span><span class="s4">\uA9D9\uA9E5\uA9F0</span><span class="s2">-</span><span class="s4">\uA9F9\uAA29</span><span class="s2">-</span><span class="s4">\uAA36\uAA43\uAA4C\uAA4D\uAA50</span><span class="s2">-</span><span class="s4">\uAA59\uAA7B</span><span class="s2">-</span><span class="s4">\uAA7D\uAAB0\uAAB2</span><span class="s2">-</span><span class="s4">\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB</span><span class="s2">-</span><span class="s4">\uAAEF\uAAF5\uAAF6\uABE3</span><span class="s2">-</span><span class="s4">\uABEA\uABEC\uABED\uABF0</span><span class="s2">-</span><span class="s4">\uABF9\uFB1E\uFE00</span><span class="s2">-</span><span class="s4">\uFE0F\uFE20</span><span class="s2">-</span><span class="s4">\uFE2F\uFE33\uFE34\uFE4D</span><span class="s2">-</span><span class="s4">\uFE4F\uFF10</span><span class="s2">-</span><span class="s4">\uFF19\uFF3F</span><span class="s2">&quot;</span><span class="s0">,tl=</span><span class="s1">new </span><span class="s0">RegExp(</span><span class="s2">&quot;[&quot;</span><span class="s0">+Vt+</span><span class="s2">&quot;]&quot;</span><span class="s0">),sl=</span><span class="s1">new </span><span class="s0">RegExp(</span><span class="s2">&quot;[&quot;</span><span class="s0">+Vt+pr+</span><span class="s2">&quot;]&quot;</span><span class="s0">);Vt=pr=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">var </span><span class="s0">fr=[</span><span class="s3">0</span><span class="s0">,</span><span class="s3">11</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">25</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">18</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">14</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">13</span><span class="s0">,</span><span class="s3">35</span><span class="s0">,</span><span class="s3">122</span><span class="s0">,</span><span class="s3">70</span><span class="s0">,</span><span class="s3">52</span><span class="s0">,</span><span class="s3">268</span><span class="s0">,</span><span class="s3">28</span><span class="s0">,</span><span class="s3">4</span><span class="s0">,</span><span class="s3">48</span><span class="s0">,</span><span class="s3">48</span><span class="s0">,</span><span class="s3">31</span><span class="s0">,</span><span class="s3">14</span><span class="s0">,</span><span class="s3">29</span><span class="s0">,</span><span class="s3">6</span><span class="s0">,</span><span class="s3">37</span><span class="s0">,</span><span class="s3">11</span><span class="s0">,</span><span class="s3">29</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">35</span><span class="s0">,</span><span class="s3">5</span><span class="s0">,</span><span class="s3">7</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">4</span><span class="s0">,</span><span class="s3">43</span><span class="s0">,</span><span class="s3">157</span><span class="s0">,</span><span class="s3">19</span><span class="s0">,</span><span class="s3">35</span><span class="s0">,</span><span class="s3">5</span><span class="s0">,</span><span class="s3">35</span><span class="s0">,</span><span class="s3">5</span><span class="s0">,</span><span class="s3">39</span><span class="s0">,</span><span class="s3">9</span><span class="s0">,</span><span class="s3">51</span><span class="s0">,</span><span class="s3">13</span><span class="s0">,</span><span class="s3">10</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">14</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">6</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">10</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">14</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">6</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">68</span><span class="s0">,</span><span class="s3">310</span><span class="s0">,</span><span class="s3">10</span><span class="s0">,</span><span class="s3">21</span><span class="s0">,</span><span class="s3">11</span><span class="s0">,</span><span class="s3">7</span><span class="s0">,</span><span class="s3">25</span><span class="s0">,</span><span class="s3">5</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">41</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">8</span><span class="s0">,</span><span class="s3">70</span><span class="s0">,</span><span class="s3">5</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">43</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">4</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">22</span><span class="s0">,</span><span class="s3">11</span><span class="s0">,</span><span class="s3">22</span><span class="s0">,</span><span class="s3">10</span><span class="s0">,</span><span class="s3">30</span><span class="s0">,</span><span class="s3">66</span><span class="s0">,</span><span class="s3">18</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">11</span><span class="s0">,</span><span class="s3">21</span><span class="s0">,</span><span class="s3">11</span><span class="s0">,</span><span class="s3">25</span><span class="s0">,</span><span class="s3">71</span><span class="s0">,</span><span class="s3">55</span><span class="s0">,</span><span class="s3">7</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">65</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">16</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">28</span><span class="s0">,</span><span class="s3">43</span><span class="s0">,</span><span class="s3">28</span><span class="s0">,</span><span class="s3">4</span><span class="s0">,</span><span class="s3">28</span><span class="s0">,</span><span class="s3">36</span><span class="s0">,</span><span class="s3">7</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">27</span><span class="s0">,</span><span class="s3">28</span><span class="s0">,</span><span class="s3">53</span><span class="s0">,</span><span class="s3">11</span><span class="s0">,</span><span class="s3">21</span><span class="s0">,</span><span class="s3">11</span><span class="s0">,</span><span class="s3">18</span><span class="s0">,</span><span class="s3">14</span><span class="s0">,</span><span class="s3">17</span><span class="s0">,</span><span class="s3">111</span><span class="s0">,</span><span class="s3">72</span><span class="s0">,</span><span class="s3">56</span><span class="s0">,</span><span class="s3">50</span><span class="s0">,</span><span class="s3">14</span><span class="s0">,</span><span class="s3">50</span><span class="s0">,</span><span class="s3">14</span><span class="s0">,</span><span class="s3">35</span><span class="s0">,</span><span class="s3">349</span><span class="s0">,</span><span class="s3">41</span><span class="s0">,</span><span class="s3">7</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">79</span><span class="s0">,</span><span class="s3">28</span><span class="s0">,</span><span class="s3">11</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">9</span><span class="s0">,</span><span class="s3">21</span><span class="s0">,</span><span class="s3">43</span><span class="s0">,</span><span class="s3">17</span><span class="s0">,</span><span class="s3">47</span><span class="s0">,</span><span class="s3">20</span><span class="s0">,</span><span class="s3">28</span><span class="s0">,</span><span class="s3">22</span><span class="s0">,</span><span class="s3">13</span><span class="s0">,</span><span class="s3">52</span><span class="s0">,</span><span class="s3">58</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">14</span><span class="s0">,</span><span class="s3">44</span><span class="s0">,</span><span class="s3">33</span><span class="s0">,</span><span class="s3">24</span><span class="s0">,</span><span class="s3">27</span><span class="s0">,</span><span class="s3">35</span><span class="s0">,</span><span class="s3">30</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">9</span><span class="s0">,</span><span class="s3">34</span><span class="s0">,</span><span class="s3">4</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">13</span><span class="s0">,</span><span class="s3">47</span><span class="s0">,</span><span class="s3">15</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">22</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">36</span><span class="s0">,</span><span class="s3">17</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">24</span><span class="s0">,</span><span class="s3">20</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">64</span><span class="s0">,</span><span class="s3">6</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">14</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">9</span><span class="s0">,</span><span class="s3">8</span><span class="s0">,</span><span class="s3">46</span><span class="s0">,</span><span class="s3">39</span><span class="s0">,</span><span class="s3">7</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">21</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">6</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">4</span><span class="s0">,</span><span class="s3">4</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">19</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">13</span><span class="s0">,</span><span class="s3">4</span><span class="s0">,</span><span class="s3">159</span><span class="s0">,</span><span class="s3">52</span><span class="s0">,</span><span class="s3">19</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">21</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">31</span><span class="s0">,</span><span class="s3">47</span><span class="s0">,</span><span class="s3">21</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">185</span><span class="s0">,</span><span class="s3">46</span><span class="s0">,</span><span class="s3">42</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">37</span><span class="s0">,</span><span class="s3">47</span><span class="s0">,</span><span class="s3">21</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">60</span><span class="s0">,</span><span class="s3">42</span><span class="s0">,</span><span class="s3">14</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">72</span><span class="s0">,</span><span class="s3">26</span><span class="s0">,</span><span class="s3">38</span><span class="s0">,</span><span class="s3">6</span><span class="s0">,</span><span class="s3">186</span><span class="s0">,</span><span class="s3">43</span><span class="s0">,</span><span class="s3">117</span><span class="s0">,</span><span class="s3">63</span><span class="s0">,</span><span class="s3">32</span><span class="s0">,</span><span class="s3">7</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">7</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">23</span><span class="s0">,</span><span class="s3">16</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">95</span><span class="s0">,</span><span class="s3">7</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">38</span><span class="s0">,</span><span class="s3">17</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">29</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">11</span><span class="s0">,</span><span class="s3">39</span><span class="s0">,</span><span class="s3">8</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">22</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">12</span><span class="s0">,</span><span class="s3">45</span><span class="s0">,</span><span class="s3">20</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">19</span><span class="s0">,</span><span class="s3">72</span><span class="s0">,</span><span class="s3">264</span><span class="s0">,</span><span class="s3">8</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">36</span><span class="s0">,</span><span class="s3">18</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">50</span><span class="s0">,</span><span class="s3">29</span><span class="s0">,</span><span class="s3">113</span><span class="s0">,</span><span class="s3">6</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">37</span><span class="s0">,</span><span class="s3">22</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">26</span><span class="s0">,</span><span class="s3">5</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">31</span><span class="s0">,</span><span class="s3">15</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">328</span><span class="s0">,</span><span class="s3">18</span><span class="s0">,</span><span class="s3">16</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">12</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">33</span><span class="s0">,</span><span class="s3">125</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">80</span><span class="s0">,</span><span class="s3">921</span><span class="s0">,</span><span class="s3">103</span><span class="s0">,</span><span class="s3">110</span><span class="s0">,</span><span class="s3">18</span><span class="s0">,</span><span class="s3">195</span><span class="s0">,</span><span class="s3">2637</span><span class="s0">,</span><span class="s3">96</span><span class="s0">,</span><span class="s3">16</span><span class="s0">,</span><span class="s3">1071</span><span class="s0">,</span><span class="s3">18</span><span class="s0">,</span><span class="s3">5</span><span class="s0">,</span><span class="s3">4026</span><span class="s0">,</span><span class="s3">582</span><span class="s0">,</span><span class="s3">8634</span><span class="s0">,</span><span class="s3">568</span><span class="s0">,</span><span class="s3">8</span><span class="s0">,</span><span class="s3">30</span><span class="s0">,</span><span class="s3">18</span><span class="s0">,</span><span class="s3">78</span><span class="s0">,</span><span class="s3">18</span><span class="s0">,</span><span class="s3">29</span><span class="s0">,</span><span class="s3">19</span><span class="s0">,</span><span class="s3">47</span><span class="s0">,</span><span class="s3">17</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">32</span><span class="s0">,</span><span class="s3">20</span><span class="s0">,</span><span class="s3">6</span><span class="s0">,</span><span class="s3">18</span><span class="s0">,</span><span class="s3">689</span><span class="s0">,</span><span class="s3">63</span><span class="s0">,</span><span class="s3">129</span><span class="s0">,</span><span class="s3">74</span><span class="s0">,</span><span class="s3">6</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">67</span><span class="s0">,</span><span class="s3">12</span><span class="s0">,</span><span class="s3">65</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">29</span><span class="s0">,</span><span class="s3">6135</span><span class="s0">,</span><span class="s3">9</span><span class="s0">,</span><span class="s3">1237</span><span class="s0">,</span><span class="s3">43</span><span class="s0">,</span><span class="s3">8</span><span class="s0">,</span><span class="s3">8936</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">6</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">290</span><span class="s0">,</span><span class="s3">16</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">30</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">15</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">9</span><span class="s0">,</span><span class="s3">395</span><span class="s0">,</span><span class="s3">2309</span><span class="s0">,</span><span class="s3">106</span><span class="s0">,</span><span class="s3">6</span><span class="s0">,</span><span class="s3">12</span><span class="s0">,</span><span class="s3">4</span><span class="s0">,</span><span class="s3">8</span><span class="s0">,</span><span class="s3">8</span><span class="s0">,</span><span class="s3">9</span><span class="s0">,</span><span class="s3">5991</span><span class="s0">,</span><span class="s3">84</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">70</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">11</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">6</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">64</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">7</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">6</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">27</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">4</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">4</span><span class="s0">,</span><span class="s3">6</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">339</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">24</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">24</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">30</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">24</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">30</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">24</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">30</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">24</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">30</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">24</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">7</span><span class="s0">,</span><span class="s3">1845</span><span class="s0">,</span><span class="s3">30</span><span class="s0">,</span><span class="s3">7</span><span class="s0">,</span><span class="s3">5</span><span class="s0">,</span><span class="s3">262</span><span class="s0">,</span><span class="s3">61</span><span class="s0">,</span><span class="s3">147</span><span class="s0">,</span><span class="s3">44</span><span class="s0">,</span><span class="s3">11</span><span class="s0">,</span><span class="s3">6</span><span class="s0">,</span><span class="s3">17</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">322</span><span class="s0">,</span><span class="s3">29</span><span class="s0">,</span><span class="s3">19</span><span class="s0">,</span><span class="s3">43</span><span class="s0">,</span><span class="s3">485</span><span class="s0">,</span><span class="s3">27</span><span class="s0">,</span><span class="s3">757</span><span class="s0">,</span><span class="s3">6</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">14</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">196</span><span class="s0">,</span><span class="s3">60</span><span class="s0">,</span><span class="s3">67</span><span class="s0">,</span><span class="s3">8</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">1205</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">26</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">9</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">7</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">5</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">6</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">9</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">16</span><span class="s0">,</span><span class="s3">6</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">4</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">16</span><span class="s0">,</span><span class="s3">4421</span><span class="s0">,</span><span class="s3">42719</span><span class="s0">,</span><span class="s3">33</span><span class="s0">,</span><span class="s3">4153</span><span class="s0">,</span><span class="s3">7</span><span class="s0">,</span><span class="s3">221</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">5761</span><span class="s0">,</span><span class="s3">15</span><span class="s0">,</span><span class="s3">7472</span><span class="s0">,</span><span class="s3">3104</span><span class="s0">,</span><span class="s3">541</span><span class="s0">,</span><span class="s3">1507</span><span class="s0">,</span><span class="s3">4938</span><span class="s0">,</span><span class="s3">6</span><span class="s0">,</span><span class="s3">4191</span><span class="s0">],rl=[</span><span class="s3">509</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">227</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">150</span><span class="s0">,</span><span class="s3">4</span><span class="s0">,</span><span class="s3">294</span><span class="s0">,</span><span class="s3">9</span><span class="s0">,</span><span class="s3">1368</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">6</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">41</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">5</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">166</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">574</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">9</span><span class="s0">,</span><span class="s3">9</span><span class="s0">,</span><span class="s3">370</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">81</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">71</span><span class="s0">,</span><span class="s3">10</span><span class="s0">,</span><span class="s3">50</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">123</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">54</span><span class="s0">,</span><span class="s3">14</span><span class="s0">,</span><span class="s3">32</span><span class="s0">,</span><span class="s3">10</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">11</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">46</span><span class="s0">,</span><span class="s3">10</span><span class="s0">,</span><span class="s3">8</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">46</span><span class="s0">,</span><span class="s3">9</span><span class="s0">,</span><span class="s3">7</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">37</span><span class="s0">,</span><span class="s3">13</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">9</span><span class="s0">,</span><span class="s3">6</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">45</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">13</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">49</span><span class="s0">,</span><span class="s3">13</span><span class="s0">,</span><span class="s3">9</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">11</span><span class="s0">,</span><span class="s3">83</span><span class="s0">,</span><span class="s3">11</span><span class="s0">,</span><span class="s3">7</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">158</span><span class="s0">,</span><span class="s3">11</span><span class="s0">,</span><span class="s3">6</span><span class="s0">,</span><span class="s3">9</span><span class="s0">,</span><span class="s3">7</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">56</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">6</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">10</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">11</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">6</span><span class="s0">,</span><span class="s3">4</span><span class="s0">,</span><span class="s3">4</span><span class="s0">,</span><span class="s3">193</span><span class="s0">,</span><span class="s3">17</span><span class="s0">,</span><span class="s3">10</span><span class="s0">,</span><span class="s3">9</span><span class="s0">,</span><span class="s3">5</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">82</span><span class="s0">,</span><span class="s3">19</span><span class="s0">,</span><span class="s3">13</span><span class="s0">,</span><span class="s3">9</span><span class="s0">,</span><span class="s3">214</span><span class="s0">,</span><span class="s3">6</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">8</span><span class="s0">,</span><span class="s3">28</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">83</span><span class="s0">,</span><span class="s3">16</span><span class="s0">,</span><span class="s3">16</span><span class="s0">,</span><span class="s3">9</span><span class="s0">,</span><span class="s3">82</span><span class="s0">,</span><span class="s3">12</span><span class="s0">,</span><span class="s3">9</span><span class="s0">,</span><span class="s3">9</span><span class="s0">,</span><span class="s3">84</span><span class="s0">,</span><span class="s3">14</span><span class="s0">,</span><span class="s3">5</span><span class="s0">,</span><span class="s3">9</span><span class="s0">,</span><span class="s3">243</span><span class="s0">,</span><span class="s3">14</span><span class="s0">,</span><span class="s3">166</span><span class="s0">,</span><span class="s3">9</span><span class="s0">,</span><span class="s3">71</span><span class="s0">,</span><span class="s3">5</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">13</span><span class="s0">,</span><span class="s3">9</span><span class="s0">,</span><span class="s3">120</span><span class="s0">,</span><span class="s3">6</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">6</span><span class="s0">,</span><span class="s3">4</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">29</span><span class="s0">,</span><span class="s3">9</span><span class="s0">,</span><span class="s3">41</span><span class="s0">,</span><span class="s3">6</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">9</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">10</span><span class="s0">,</span><span class="s3">10</span><span class="s0">,</span><span class="s3">47</span><span class="s0">,</span><span class="s3">15</span><span class="s0">,</span><span class="s3">406</span><span class="s0">,</span><span class="s3">7</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">7</span><span class="s0">,</span><span class="s3">17</span><span class="s0">,</span><span class="s3">9</span><span class="s0">,</span><span class="s3">57</span><span class="s0">,</span><span class="s3">21</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">13</span><span class="s0">,</span><span class="s3">123</span><span class="s0">,</span><span class="s3">5</span><span class="s0">,</span><span class="s3">4</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">6</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">9</span><span class="s0">,</span><span class="s3">9</span><span class="s0">,</span><span class="s3">49</span><span class="s0">,</span><span class="s3">4</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">4</span><span class="s0">,</span><span class="s3">9</span><span class="s0">,</span><span class="s3">9</span><span class="s0">,</span><span class="s3">330</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">10</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">49</span><span class="s0">,</span><span class="s3">6</span><span class="s0">,</span><span class="s3">4</span><span class="s0">,</span><span class="s3">4</span><span class="s0">,</span><span class="s3">14</span><span class="s0">,</span><span class="s3">9</span><span class="s0">,</span><span class="s3">5351</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">7</span><span class="s0">,</span><span class="s3">14</span><span class="s0">,</span><span class="s3">13835</span><span class="s0">,</span><span class="s3">9</span><span class="s0">,</span><span class="s3">87</span><span class="s0">,</span><span class="s3">9</span><span class="s0">,</span><span class="s3">39</span><span class="s0">,</span><span class="s3">4</span><span class="s0">,</span><span class="s3">60</span><span class="s0">,</span><span class="s3">6</span><span class="s0">,</span><span class="s3">26</span><span class="s0">,</span><span class="s3">9</span><span class="s0">,</span><span class="s3">1014</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">54</span><span class="s0">,</span><span class="s3">8</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">82</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">12</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">19628</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">4706</span><span class="s0">,</span><span class="s3">45</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">22</span><span class="s0">,</span><span class="s3">543</span><span class="s0">,</span><span class="s3">4</span><span class="s0">,</span><span class="s3">4</span><span class="s0">,</span><span class="s3">5</span><span class="s0">,</span><span class="s3">9</span><span class="s0">,</span><span class="s3">7</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">6</span><span class="s0">,</span><span class="s3">31</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">149</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">1418</span><span class="s0">,</span><span class="s3">49</span><span class="s0">,</span><span class="s3">513</span><span class="s0">,</span><span class="s3">54</span><span class="s0">,</span><span class="s3">5</span><span class="s0">,</span><span class="s3">49</span><span class="s0">,</span><span class="s3">9</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">15</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">23</span><span class="s0">,</span><span class="s3">4</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">14</span><span class="s0">,</span><span class="s3">1361</span><span class="s0">,</span><span class="s3">6</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">16</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">6</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">4</span><span class="s0">,</span><span class="s3">101</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">161</span><span class="s0">,</span><span class="s3">6</span><span class="s0">,</span><span class="s3">10</span><span class="s0">,</span><span class="s3">9</span><span class="s0">,</span><span class="s3">357</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">62</span><span class="s0">,</span><span class="s3">13</span><span class="s0">,</span><span class="s3">499</span><span class="s0">,</span><span class="s3">13</span><span class="s0">,</span><span class="s3">983</span><span class="s0">,</span><span class="s3">6</span><span class="s0">,</span><span class="s3">110</span><span class="s0">,</span><span class="s3">6</span><span class="s0">,</span><span class="s3">6</span><span class="s0">,</span><span class="s3">9</span><span class="s0">,</span><span class="s3">4759</span><span class="s0">,</span><span class="s3">9</span><span class="s0">,</span><span class="s3">787719</span><span class="s0">,</span><span class="s3">239</span><span class="s0">];</span><span class="s1">function </span><span class="s0">Kt(t,r){let e=</span><span class="s3">65536</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(let s=</span><span class="s3">0</span><span class="s0">,i=r.length;s&lt;i;s+=</span><span class="s3">2</span><span class="s0">){</span><span class="s1">if</span><span class="s0">(e+=r[s],e&gt;t)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(e+=r[s+</span><span class="s3">1</span><span class="s0">],e&gt;=t)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">0</span><span class="s0">}</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">}</span><span class="s1">function </span><span class="s0">fe(t){</span><span class="s1">return </span><span class="s0">t&lt;</span><span class="s3">65</span><span class="s0">?t===</span><span class="s3">36</span><span class="s0">:t&lt;=</span><span class="s3">90</span><span class="s0">?!</span><span class="s3">0</span><span class="s0">:t&lt;</span><span class="s3">97</span><span class="s0">?t===</span><span class="s3">95</span><span class="s0">:t&lt;=</span><span class="s3">122</span><span class="s0">?!</span><span class="s3">0</span><span class="s0">:t&lt;=</span><span class="s3">65535</span><span class="s0">?t&gt;=</span><span class="s3">170</span><span class="s0">&amp;&amp;tl.test(String.fromCharCode(t)):Kt(t,fr)}</span><span class="s1">function </span><span class="s0">De(t){</span><span class="s1">return </span><span class="s0">t&lt;</span><span class="s3">48</span><span class="s0">?t===</span><span class="s3">36</span><span class="s0">:t&lt;</span><span class="s3">58</span><span class="s0">?!</span><span class="s3">0</span><span class="s0">:t&lt;</span><span class="s3">65</span><span class="s0">?!</span><span class="s3">1</span><span class="s0">:t&lt;=</span><span class="s3">90</span><span class="s0">?!</span><span class="s3">0</span><span class="s0">:t&lt;</span><span class="s3">97</span><span class="s0">?t===</span><span class="s3">95</span><span class="s0">:t&lt;=</span><span class="s3">122</span><span class="s0">?!</span><span class="s3">0</span><span class="s0">:t&lt;=</span><span class="s3">65535</span><span class="s0">?t&gt;=</span><span class="s3">170</span><span class="s0">&amp;&amp;sl.test(String.fromCharCode(t)):Kt(t,fr)||Kt(t,rl)}</span><span class="s1">var </span><span class="s0">Wt={keyword:[</span><span class="s2">&quot;break&quot;</span><span class="s0">,</span><span class="s2">&quot;case&quot;</span><span class="s0">,</span><span class="s2">&quot;catch&quot;</span><span class="s0">,</span><span class="s2">&quot;continue&quot;</span><span class="s0">,</span><span class="s2">&quot;debugger&quot;</span><span class="s0">,</span><span class="s2">&quot;default&quot;</span><span class="s0">,</span><span class="s2">&quot;do&quot;</span><span class="s0">,</span><span class="s2">&quot;else&quot;</span><span class="s0">,</span><span class="s2">&quot;finally&quot;</span><span class="s0">,</span><span class="s2">&quot;for&quot;</span><span class="s0">,</span><span class="s2">&quot;function&quot;</span><span class="s0">,</span><span class="s2">&quot;if&quot;</span><span class="s0">,</span><span class="s2">&quot;return&quot;</span><span class="s0">,</span><span class="s2">&quot;switch&quot;</span><span class="s0">,</span><span class="s2">&quot;throw&quot;</span><span class="s0">,</span><span class="s2">&quot;try&quot;</span><span class="s0">,</span><span class="s2">&quot;var&quot;</span><span class="s0">,</span><span class="s2">&quot;const&quot;</span><span class="s0">,</span><span class="s2">&quot;while&quot;</span><span class="s0">,</span><span class="s2">&quot;with&quot;</span><span class="s0">,</span><span class="s2">&quot;new&quot;</span><span class="s0">,</span><span class="s2">&quot;this&quot;</span><span class="s0">,</span><span class="s2">&quot;super&quot;</span><span class="s0">,</span><span class="s2">&quot;class&quot;</span><span class="s0">,</span><span class="s2">&quot;extends&quot;</span><span class="s0">,</span><span class="s2">&quot;export&quot;</span><span class="s0">,</span><span class="s2">&quot;import&quot;</span><span class="s0">,</span><span class="s2">&quot;null&quot;</span><span class="s0">,</span><span class="s2">&quot;true&quot;</span><span class="s0">,</span><span class="s2">&quot;false&quot;</span><span class="s0">,</span><span class="s2">&quot;in&quot;</span><span class="s0">,</span><span class="s2">&quot;instanceof&quot;</span><span class="s0">,</span><span class="s2">&quot;typeof&quot;</span><span class="s0">,</span><span class="s2">&quot;void&quot;</span><span class="s0">,</span><span class="s2">&quot;delete&quot;</span><span class="s0">],strict:[</span><span class="s2">&quot;implements&quot;</span><span class="s0">,</span><span class="s2">&quot;interface&quot;</span><span class="s0">,</span><span class="s2">&quot;let&quot;</span><span class="s0">,</span><span class="s2">&quot;package&quot;</span><span class="s0">,</span><span class="s2">&quot;private&quot;</span><span class="s0">,</span><span class="s2">&quot;protected&quot;</span><span class="s0">,</span><span class="s2">&quot;public&quot;</span><span class="s0">,</span><span class="s2">&quot;static&quot;</span><span class="s0">,</span><span class="s2">&quot;yield&quot;</span><span class="s0">],strictBind:[</span><span class="s2">&quot;eval&quot;</span><span class="s0">,</span><span class="s2">&quot;arguments&quot;</span><span class="s0">]},il=</span><span class="s1">new </span><span class="s0">Set(Wt.keyword),al=</span><span class="s1">new </span><span class="s0">Set(Wt.strict),nl=</span><span class="s1">new </span><span class="s0">Set(Wt.strictBind);</span><span class="s1">function </span><span class="s0">dr(t,r){</span><span class="s1">return </span><span class="s0">r&amp;&amp;t===</span><span class="s2">&quot;await&quot;</span><span class="s0">||t===</span><span class="s2">&quot;enum&quot;</span><span class="s0">}</span><span class="s1">function </span><span class="s0">mr(t,r){</span><span class="s1">return </span><span class="s0">dr(t,r)||al.has(t)}</span><span class="s1">function </span><span class="s0">yr(t){</span><span class="s1">return </span><span class="s0">nl.has(t)}</span><span class="s1">function </span><span class="s0">xr(t,r){</span><span class="s1">return </span><span class="s0">mr(t,r)||yr(t)}</span><span class="s1">function </span><span class="s0">ol(t){</span><span class="s1">return </span><span class="s0">il.has(t)}</span><span class="s1">function </span><span class="s0">ll(t,r,e){</span><span class="s1">return </span><span class="s0">t===</span><span class="s3">64</span><span class="s0">&amp;&amp;r===</span><span class="s3">64</span><span class="s0">&amp;&amp;fe(e)}</span><span class="s1">var </span><span class="s0">hl=</span><span class="s1">new </span><span class="s0">Set([</span><span class="s2">&quot;break&quot;</span><span class="s0">,</span><span class="s2">&quot;case&quot;</span><span class="s0">,</span><span class="s2">&quot;catch&quot;</span><span class="s0">,</span><span class="s2">&quot;continue&quot;</span><span class="s0">,</span><span class="s2">&quot;debugger&quot;</span><span class="s0">,</span><span class="s2">&quot;default&quot;</span><span class="s0">,</span><span class="s2">&quot;do&quot;</span><span class="s0">,</span><span class="s2">&quot;else&quot;</span><span class="s0">,</span><span class="s2">&quot;finally&quot;</span><span class="s0">,</span><span class="s2">&quot;for&quot;</span><span class="s0">,</span><span class="s2">&quot;function&quot;</span><span class="s0">,</span><span class="s2">&quot;if&quot;</span><span class="s0">,</span><span class="s2">&quot;return&quot;</span><span class="s0">,</span><span class="s2">&quot;switch&quot;</span><span class="s0">,</span><span class="s2">&quot;throw&quot;</span><span class="s0">,</span><span class="s2">&quot;try&quot;</span><span class="s0">,</span><span class="s2">&quot;var&quot;</span><span class="s0">,</span><span class="s2">&quot;const&quot;</span><span class="s0">,</span><span class="s2">&quot;while&quot;</span><span class="s0">,</span><span class="s2">&quot;with&quot;</span><span class="s0">,</span><span class="s2">&quot;new&quot;</span><span class="s0">,</span><span class="s2">&quot;this&quot;</span><span class="s0">,</span><span class="s2">&quot;super&quot;</span><span class="s0">,</span><span class="s2">&quot;class&quot;</span><span class="s0">,</span><span class="s2">&quot;extends&quot;</span><span class="s0">,</span><span class="s2">&quot;export&quot;</span><span class="s0">,</span><span class="s2">&quot;import&quot;</span><span class="s0">,</span><span class="s2">&quot;null&quot;</span><span class="s0">,</span><span class="s2">&quot;true&quot;</span><span class="s0">,</span><span class="s2">&quot;false&quot;</span><span class="s0">,</span><span class="s2">&quot;in&quot;</span><span class="s0">,</span><span class="s2">&quot;instanceof&quot;</span><span class="s0">,</span><span class="s2">&quot;typeof&quot;</span><span class="s0">,</span><span class="s2">&quot;void&quot;</span><span class="s0">,</span><span class="s2">&quot;delete&quot;</span><span class="s0">,</span><span class="s2">&quot;implements&quot;</span><span class="s0">,</span><span class="s2">&quot;interface&quot;</span><span class="s0">,</span><span class="s2">&quot;let&quot;</span><span class="s0">,</span><span class="s2">&quot;package&quot;</span><span class="s0">,</span><span class="s2">&quot;private&quot;</span><span class="s0">,</span><span class="s2">&quot;protected&quot;</span><span class="s0">,</span><span class="s2">&quot;public&quot;</span><span class="s0">,</span><span class="s2">&quot;static&quot;</span><span class="s0">,</span><span class="s2">&quot;yield&quot;</span><span class="s0">,</span><span class="s2">&quot;eval&quot;</span><span class="s0">,</span><span class="s2">&quot;arguments&quot;</span><span class="s0">,</span><span class="s2">&quot;enum&quot;</span><span class="s0">,</span><span class="s2">&quot;await&quot;</span><span class="s0">]);</span><span class="s1">function </span><span class="s0">ul(t){</span><span class="s1">return </span><span class="s0">hl.has(t)}</span><span class="s1">var </span><span class="s0">Fe=</span><span class="s3">0</span><span class="s0">,Le=</span><span class="s3">1</span><span class="s0">,de=</span><span class="s3">2</span><span class="s0">,Gt=</span><span class="s3">4</span><span class="s0">,gr=</span><span class="s3">8</span><span class="s0">,ht=</span><span class="s3">16</span><span class="s0">,Pr=</span><span class="s3">32</span><span class="s0">,Ee=</span><span class="s3">64</span><span class="s0">,ut=</span><span class="s3">128</span><span class="s0">,Oe=</span><span class="s3">256</span><span class="s0">,ct=Le|de|ut|Oe,le=</span><span class="s3">1</span><span class="s0">,Ce=</span><span class="s3">2</span><span class="s0">,Ar=</span><span class="s3">4</span><span class="s0">,be=</span><span class="s3">8</span><span class="s0">,pt=</span><span class="s3">16</span><span class="s0">,Tr=</span><span class="s3">64</span><span class="s0">,ft=</span><span class="s3">128</span><span class="s0">,Jt=</span><span class="s3">256</span><span class="s0">,Xt=</span><span class="s3">512</span><span class="s0">,Yt=</span><span class="s3">1024</span><span class="s0">,Qt=</span><span class="s3">2048</span><span class="s0">,Ve=</span><span class="s3">4096</span><span class="s0">,dt=</span><span class="s3">8192</span><span class="s0">,vr=le|Ce|be|ft|dt,Be=le|</span><span class="s3">0</span><span class="s0">|be|dt,cl=le|</span><span class="s3">0</span><span class="s0">|be|</span><span class="s3">0</span><span class="s0">,mt=le|</span><span class="s3">0</span><span class="s0">|Ar|</span><span class="s3">0</span><span class="s0">,Er=le|</span><span class="s3">0</span><span class="s0">|pt|</span><span class="s3">0</span><span class="s0">,pl=</span><span class="s3">0</span><span class="s0">|Ce|</span><span class="s3">0</span><span class="s0">|ft,fl=</span><span class="s3">0</span><span class="s0">|Ce|</span><span class="s3">0</span><span class="s0">|</span><span class="s3">0</span><span class="s0">,Cr=le|Ce|be|Jt|dt,br=</span><span class="s3">0</span><span class="s0">|Yt,Pe=</span><span class="s3">0</span><span class="s0">|Tr,dl=le|</span><span class="s3">0</span><span class="s0">|</span><span class="s3">0</span><span class="s0">|Tr,ml=Cr|Xt,yl=</span><span class="s3">0</span><span class="s0">|Yt,Sr=</span><span class="s3">0</span><span class="s0">|Ce|</span><span class="s3">0</span><span class="s0">|Ve,xl=Qt,yt=</span><span class="s3">4</span><span class="s0">,Zt=</span><span class="s3">2</span><span class="s0">,es=</span><span class="s3">1</span><span class="s0">,ts=Zt|es,gl=Zt|yt,Pl=es|yt,Al=Zt,Tl=es,ss=</span><span class="s3">0</span><span class="s0">,rs=class{constructor(t){</span><span class="s1">this</span><span class="s0">.</span><span class="s1">var</span><span class="s0">=</span><span class="s1">new </span><span class="s0">Set,</span><span class="s1">this</span><span class="s0">.lexical=</span><span class="s1">new </span><span class="s0">Set,</span><span class="s1">this</span><span class="s0">.functions=</span><span class="s1">new </span><span class="s0">Set,</span><span class="s1">this</span><span class="s0">.flags=t}},is=class{constructor(t,r){</span><span class="s1">this</span><span class="s0">.parser=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.scopeStack=[],</span><span class="s1">this</span><span class="s0">.inModule=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.undefinedExports=</span><span class="s1">new </span><span class="s0">Map,</span><span class="s1">this</span><span class="s0">.parser=t,</span><span class="s1">this</span><span class="s0">.inModule=r}get inTopLevel(){</span><span class="s1">return</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.currentScope().flags&amp;Le)&gt;</span><span class="s3">0</span><span class="s0">}get inFunction(){</span><span class="s1">return</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.currentVarScopeFlags()&amp;de)&gt;</span><span class="s3">0</span><span class="s0">}get allowSuper(){</span><span class="s1">return</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.currentThisScopeFlags()&amp;ht)&gt;</span><span class="s3">0</span><span class="s0">}get allowDirectSuper(){</span><span class="s1">return</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.currentThisScopeFlags()&amp;Pr)&gt;</span><span class="s3">0</span><span class="s0">}get inClass(){</span><span class="s1">return</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.currentThisScopeFlags()&amp;Ee)&gt;</span><span class="s3">0</span><span class="s0">}get inClassAndNotInNonArrowFunction(){let t=</span><span class="s1">this</span><span class="s0">.currentThisScopeFlags();</span><span class="s1">return</span><span class="s0">(t&amp;Ee)&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;(t&amp;de)===</span><span class="s3">0</span><span class="s0">}get inStaticBlock(){</span><span class="s1">for</span><span class="s0">(let t=</span><span class="s1">this</span><span class="s0">.scopeStack.length-1;;t--){let{flags:r}=</span><span class="s1">this</span><span class="s0">.scopeStack[t];</span><span class="s1">if</span><span class="s0">(r&amp;ut)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(r&amp;(ct|Ee))</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">}}get inNonArrowFunction(){</span><span class="s1">return</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.currentThisScopeFlags()&amp;de)&gt;</span><span class="s3">0</span><span class="s0">}get treatFunctionsAsVar(){</span><span class="s1">return this</span><span class="s0">.treatFunctionsAsVarInScope(</span><span class="s1">this</span><span class="s0">.currentScope())}createScope(t){</span><span class="s1">return new </span><span class="s0">rs(t)}enter(t){</span><span class="s1">this</span><span class="s0">.scopeStack.push(</span><span class="s1">this</span><span class="s0">.createScope(t))}exit(){</span><span class="s1">return this</span><span class="s0">.scopeStack.pop().flags}treatFunctionsAsVarInScope(t){</span><span class="s1">return</span><span class="s0">!!(t.flags&amp;(de|ut)||!</span><span class="s1">this</span><span class="s0">.parser.inModule&amp;&amp;t.flags&amp;Le)}declareName(t,r,e){let s=</span><span class="s1">this</span><span class="s0">.currentScope();</span><span class="s1">if</span><span class="s0">(r&amp;be||r&amp;pt)</span><span class="s1">this</span><span class="s0">.checkRedeclarationInScope(s,t,r,e),r&amp;pt?s.functions.add(t):s.lexical.add(t),r&amp;be&amp;&amp;</span><span class="s1">this</span><span class="s0">.maybeExportDefined(s,t);</span><span class="s1">else if</span><span class="s0">(r&amp;Ar)</span><span class="s1">for</span><span class="s0">(let i=</span><span class="s1">this</span><span class="s0">.scopeStack.length-1;i&gt;=</span><span class="s3">0</span><span class="s0">&amp;&amp;(s=</span><span class="s1">this</span><span class="s0">.scopeStack[i],</span><span class="s1">this</span><span class="s0">.checkRedeclarationInScope(s,t,r,e),s.</span><span class="s1">var</span><span class="s0">.add(t),</span><span class="s1">this</span><span class="s0">.maybeExportDefined(s,t),!(s.flags&amp;ct));--i);</span><span class="s1">this</span><span class="s0">.parser.inModule&amp;&amp;s.flags&amp;Le&amp;&amp;</span><span class="s1">this</span><span class="s0">.undefinedExports.</span><span class="s1">delete</span><span class="s0">(t)}maybeExportDefined(t,r){</span><span class="s1">this</span><span class="s0">.parser.inModule&amp;&amp;t.flags&amp;Le&amp;&amp;</span><span class="s1">this</span><span class="s0">.undefinedExports.</span><span class="s1">delete</span><span class="s0">(r)}checkRedeclarationInScope(t,r,e,s){</span><span class="s1">this</span><span class="s0">.isRedeclaredInScope(t,r,e)&amp;&amp;</span><span class="s1">this</span><span class="s0">.parser.raise(f.VarRedeclaration,{at:s,identifierName:r})}isRedeclaredInScope(t,r,e){</span><span class="s1">return </span><span class="s0">e&amp;le?e&amp;be?t.lexical.has(r)||t.functions.has(r)||t.</span><span class="s1">var</span><span class="s0">.has(r):e&amp;pt?t.lexical.has(r)||!</span><span class="s1">this</span><span class="s0">.treatFunctionsAsVarInScope(t)&amp;&amp;t.</span><span class="s1">var</span><span class="s0">.has(r):t.lexical.has(r)&amp;&amp;!(t.flags&amp;gr&amp;&amp;t.lexical.values().next().value===r)||!</span><span class="s1">this</span><span class="s0">.treatFunctionsAsVarInScope(t)&amp;&amp;t.functions.has(r):!</span><span class="s3">1</span><span class="s0">}checkLocalExport(t){let{name:r}=t,e=</span><span class="s1">this</span><span class="s0">.scopeStack[</span><span class="s3">0</span><span class="s0">];!e.lexical.has(r)&amp;&amp;!e.</span><span class="s1">var</span><span class="s0">.has(r)&amp;&amp;!e.functions.has(r)&amp;&amp;</span><span class="s1">this</span><span class="s0">.undefinedExports.set(r,t.loc.start)}currentScope(){</span><span class="s1">return this</span><span class="s0">.scopeStack[</span><span class="s1">this</span><span class="s0">.scopeStack.length-1]}currentVarScopeFlags(){</span><span class="s1">for</span><span class="s0">(let t=</span><span class="s1">this</span><span class="s0">.scopeStack.length-1;;t--){let{flags:r}=</span><span class="s1">this</span><span class="s0">.scopeStack[t];</span><span class="s1">if</span><span class="s0">(r&amp;ct)</span><span class="s1">return </span><span class="s0">r}}currentThisScopeFlags(){</span><span class="s1">for</span><span class="s0">(let t=</span><span class="s1">this</span><span class="s0">.scopeStack.length-1;;t--){let{flags:r}=</span><span class="s1">this</span><span class="s0">.scopeStack[t];</span><span class="s1">if</span><span class="s0">(r&amp;(ct|Ee)&amp;&amp;!(r&amp;Gt))</span><span class="s1">return </span><span class="s0">r}}},vl=class extends rs{constructor(){super(...arguments),</span><span class="s1">this</span><span class="s0">.declareFunctions=</span><span class="s1">new </span><span class="s0">Set}},El=class extends is{createScope(t){</span><span class="s1">return new </span><span class="s0">vl(t)}declareName(t,r,e){let s=</span><span class="s1">this</span><span class="s0">.currentScope();</span><span class="s1">if</span><span class="s0">(r&amp;Qt){</span><span class="s1">this</span><span class="s0">.checkRedeclarationInScope(s,t,r,e),</span><span class="s1">this</span><span class="s0">.maybeExportDefined(s,t),s.declareFunctions.add(t);</span><span class="s1">return</span><span class="s0">}super.declareName(t,r,e)}isRedeclaredInScope(t,r,e){</span><span class="s1">return </span><span class="s0">super.isRedeclaredInScope(t,r,e)?!</span><span class="s3">0</span><span class="s0">:e&amp;Qt?!t.declareFunctions.has(r)&amp;&amp;(t.lexical.has(r)||t.functions.has(r)):!</span><span class="s3">1</span><span class="s0">}checkLocalExport(t){</span><span class="s1">this</span><span class="s0">.scopeStack[</span><span class="s3">0</span><span class="s0">].declareFunctions.has(t.name)||super.checkLocalExport(t)}},Cl=class{constructor(){</span><span class="s1">this</span><span class="s0">.sawUnambiguousESM=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.ambiguousScriptDifferentAst=!</span><span class="s3">1</span><span class="s0">}hasPlugin(t){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">t==</span><span class="s2">&quot;string&quot;</span><span class="s0">)</span><span class="s1">return this</span><span class="s0">.plugins.has(t);{let[r,e]=t;</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.hasPlugin(r))</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;let s=</span><span class="s1">this</span><span class="s0">.plugins.get(r);</span><span class="s1">for</span><span class="s0">(let i of Object.keys(e))</span><span class="s1">if</span><span class="s0">((s==</span><span class="s1">null</span><span class="s0">?</span><span class="s1">void </span><span class="s3">0</span><span class="s0">:s[i])!==e[i])</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">return</span><span class="s0">!</span><span class="s3">0</span><span class="s0">}}getPluginOption(t,r){</span><span class="s1">var </span><span class="s0">e;</span><span class="s1">return</span><span class="s0">(e=</span><span class="s1">this</span><span class="s0">.plugins.get(t))==</span><span class="s1">null</span><span class="s0">?</span><span class="s1">void </span><span class="s3">0</span><span class="s0">:e[r]}};</span><span class="s1">function </span><span class="s0">wr(t,r){t.trailingComments===</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?t.trailingComments=r:t.trailingComments.unshift(...r)}</span><span class="s1">function </span><span class="s0">bl(t,r){t.leadingComments===</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?t.leadingComments=r:t.leadingComments.unshift(...r)}</span><span class="s1">function </span><span class="s0">Ke(t,r){t.innerComments===</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?t.innerComments=r:t.innerComments.unshift(...r)}</span><span class="s1">function </span><span class="s0">We(t,r,e){let s=</span><span class="s1">null</span><span class="s0">,i=r.length;</span><span class="s1">for</span><span class="s0">(;s===</span><span class="s1">null</span><span class="s0">&amp;&amp;i&gt;</span><span class="s3">0</span><span class="s0">;)s=r[--i];s===</span><span class="s1">null</span><span class="s0">||s.start&gt;e.start?Ke(t,e.comments):wr(s,e.comments)}</span><span class="s1">var </span><span class="s0">Sl=class extends Cl{addComment(t){</span><span class="s1">this</span><span class="s0">.filename&amp;&amp;(t.loc.filename=</span><span class="s1">this</span><span class="s0">.filename),</span><span class="s1">this</span><span class="s0">.state.comments.push(t)}processComment(t){let{commentStack:r}=</span><span class="s1">this</span><span class="s0">.state,e=r.length;</span><span class="s1">if</span><span class="s0">(e===</span><span class="s3">0</span><span class="s0">)</span><span class="s1">return</span><span class="s0">;let s=e-1,i=r[s];i.start===t.end&amp;&amp;(i.leadingNode=t,s--);let{start:a}=t;</span><span class="s1">for</span><span class="s0">(;s&gt;=</span><span class="s3">0</span><span class="s0">;s--){let n=r[s],o=n.end;</span><span class="s1">if</span><span class="s0">(o&gt;a)n.containingNode=t,</span><span class="s1">this</span><span class="s0">.finalizeComment(n),r.splice(s,</span><span class="s3">1</span><span class="s0">);</span><span class="s1">else</span><span class="s0">{o===a&amp;&amp;(n.trailingNode=t);</span><span class="s1">break</span><span class="s0">}}}finalizeComment(t){let{comments:r}=t;</span><span class="s1">if</span><span class="s0">(t.leadingNode!==</span><span class="s1">null</span><span class="s0">||t.trailingNode!==</span><span class="s1">null</span><span class="s0">)t.leadingNode!==</span><span class="s1">null</span><span class="s0">&amp;&amp;wr(t.leadingNode,r),t.trailingNode!==</span><span class="s1">null</span><span class="s0">&amp;&amp;bl(t.trailingNode,r);</span><span class="s1">else</span><span class="s0">{let{containingNode:e,start:s}=t;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.input.charCodeAt(s-1)===</span><span class="s3">44</span><span class="s0">)</span><span class="s1">switch</span><span class="s0">(e.type){</span><span class="s1">case</span><span class="s2">&quot;ObjectExpression&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;ObjectPattern&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;RecordExpression&quot;</span><span class="s0">:We(e,e.properties,t);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;CallExpression&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;OptionalCallExpression&quot;</span><span class="s0">:We(e,e.arguments,t);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;FunctionDeclaration&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;FunctionExpression&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;ArrowFunctionExpression&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;ObjectMethod&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;ClassMethod&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;ClassPrivateMethod&quot;</span><span class="s0">:We(e,e.params,t);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;ArrayExpression&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;ArrayPattern&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;TupleExpression&quot;</span><span class="s0">:We(e,e.elements,t);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;ExportNamedDeclaration&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;ImportDeclaration&quot;</span><span class="s0">:We(e,e.specifiers,t);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">default</span><span class="s0">:Ke(e,r)}</span><span class="s1">else </span><span class="s0">Ke(e,r)}}finalizeRemainingComments(){let{commentStack:t}=</span><span class="s1">this</span><span class="s0">.state;</span><span class="s1">for</span><span class="s0">(let r=t.length-1;r&gt;=</span><span class="s3">0</span><span class="s0">;r--)</span><span class="s1">this</span><span class="s0">.finalizeComment(t[r]);</span><span class="s1">this</span><span class="s0">.state.commentStack=[]}resetPreviousNodeTrailingComments(t){let{commentStack:r}=</span><span class="s1">this</span><span class="s0">.state,{length:e}=r;</span><span class="s1">if</span><span class="s0">(e===</span><span class="s3">0</span><span class="s0">)</span><span class="s1">return</span><span class="s0">;let s=r[e-1];s.leadingNode===t&amp;&amp;(s.leadingNode=</span><span class="s1">null</span><span class="s0">)}takeSurroundingComments(t,r,e){let{commentStack:s}=</span><span class="s1">this</span><span class="s0">.state,i=s.length;</span><span class="s1">if</span><span class="s0">(i===</span><span class="s3">0</span><span class="s0">)</span><span class="s1">return</span><span class="s0">;let a=i-1;</span><span class="s1">for</span><span class="s0">(;a&gt;=</span><span class="s3">0</span><span class="s0">;a--){let n=s[a],o=n.end;</span><span class="s1">if</span><span class="s0">(n.start===e)n.leadingNode=t;</span><span class="s1">else if</span><span class="s0">(o===r)n.trailingNode=t;</span><span class="s1">else if</span><span class="s0">(o&lt;r)</span><span class="s1">break</span><span class="s0">}}},as=/\r\n?|[\n\u2028\u2029]/,xt=</span><span class="s1">new </span><span class="s0">RegExp(as.source,</span><span class="s2">&quot;g&quot;</span><span class="s0">);</span><span class="s1">function </span><span class="s0">Ge(t){</span><span class="s1">switch</span><span class="s0">(t){</span><span class="s1">case </span><span class="s3">10</span><span class="s0">:</span><span class="s1">case </span><span class="s3">13</span><span class="s0">:</span><span class="s1">case </span><span class="s3">8232</span><span class="s0">:</span><span class="s1">case </span><span class="s3">8233</span><span class="s0">:</span><span class="s1">return</span><span class="s0">!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">default</span><span class="s0">:</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">}}</span><span class="s1">var </span><span class="s0">ns=/(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g,wl=/(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/y,Ir=</span><span class="s1">new </span><span class="s0">RegExp(</span><span class="s2">&quot;(?=(&quot;</span><span class="s0">+wl.source+</span><span class="s2">&quot;))</span><span class="s4">\\</span><span class="s2">1&quot;</span><span class="s0">+/(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source,</span><span class="s2">&quot;y&quot;</span><span class="s0">);</span><span class="s1">function </span><span class="s0">Il(t){</span><span class="s1">switch</span><span class="s0">(t){</span><span class="s1">case </span><span class="s3">9</span><span class="s0">:</span><span class="s1">case </span><span class="s3">11</span><span class="s0">:</span><span class="s1">case </span><span class="s3">12</span><span class="s0">:</span><span class="s1">case </span><span class="s3">32</span><span class="s0">:</span><span class="s1">case </span><span class="s3">160</span><span class="s0">:</span><span class="s1">case </span><span class="s3">5760</span><span class="s0">:</span><span class="s1">case </span><span class="s3">8192</span><span class="s0">:</span><span class="s1">case </span><span class="s3">8193</span><span class="s0">:</span><span class="s1">case </span><span class="s3">8194</span><span class="s0">:</span><span class="s1">case </span><span class="s3">8195</span><span class="s0">:</span><span class="s1">case </span><span class="s3">8196</span><span class="s0">:</span><span class="s1">case </span><span class="s3">8197</span><span class="s0">:</span><span class="s1">case </span><span class="s3">8198</span><span class="s0">:</span><span class="s1">case </span><span class="s3">8199</span><span class="s0">:</span><span class="s1">case </span><span class="s3">8200</span><span class="s0">:</span><span class="s1">case </span><span class="s3">8201</span><span class="s0">:</span><span class="s1">case </span><span class="s3">8202</span><span class="s0">:</span><span class="s1">case </span><span class="s3">8239</span><span class="s0">:</span><span class="s1">case </span><span class="s3">8287</span><span class="s0">:</span><span class="s1">case </span><span class="s3">12288</span><span class="s0">:</span><span class="s1">case </span><span class="s3">65279</span><span class="s0">:</span><span class="s1">return</span><span class="s0">!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">default</span><span class="s0">:</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">}}</span><span class="s1">var </span><span class="s0">Nr=class{constructor(){</span><span class="s1">this</span><span class="s0">.strict=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.curLine=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.lineStart=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.startLoc=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.endLoc=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.errors=[],</span><span class="s1">this</span><span class="s0">.potentialArrowAt=-</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.noArrowAt=[],</span><span class="s1">this</span><span class="s0">.noArrowParamsConversionAt=[],</span><span class="s1">this</span><span class="s0">.maybeInArrowParameters=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.inType=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.noAnonFunctionType=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.hasFlowComment=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.isAmbientContext=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.inAbstractClass=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.inDisallowConditionalTypesContext=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.topicContext={maxNumOfResolvableTopics:</span><span class="s3">0</span><span class="s0">,maxTopicIndex:</span><span class="s1">null</span><span class="s0">},</span><span class="s1">this</span><span class="s0">.soloAwait=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.inFSharpPipelineDirectBody=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.labels=[],</span><span class="s1">this</span><span class="s0">.comments=[],</span><span class="s1">this</span><span class="s0">.commentStack=[],</span><span class="s1">this</span><span class="s0">.pos=</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.type=</span><span class="s3">137</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.value=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.start=</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.end=</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.lastTokEndLoc=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.lastTokStartLoc=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.lastTokStart=</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.context=[x.brace],</span><span class="s1">this</span><span class="s0">.canStartJSXElement=!</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.containsEsc=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.firstInvalidTemplateEscapePos=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.strictErrors=</span><span class="s1">new </span><span class="s0">Map,</span><span class="s1">this</span><span class="s0">.tokensLength=</span><span class="s3">0</span><span class="s0">}init(t){let{strictMode:r,sourceType:e,startLine:s,startColumn:i}=t;</span><span class="s1">this</span><span class="s0">.strict=r===!</span><span class="s3">1</span><span class="s0">?!</span><span class="s3">1</span><span class="s0">:r===!</span><span class="s3">0</span><span class="s0">?!</span><span class="s3">0</span><span class="s0">:e===</span><span class="s2">&quot;module&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.curLine=s,</span><span class="s1">this</span><span class="s0">.lineStart=-i,</span><span class="s1">this</span><span class="s0">.startLoc=</span><span class="s1">this</span><span class="s0">.endLoc=</span><span class="s1">new </span><span class="s0">ge(s,i,</span><span class="s3">0</span><span class="s0">)}curPosition(){</span><span class="s1">return new </span><span class="s0">ge(</span><span class="s1">this</span><span class="s0">.curLine,</span><span class="s1">this</span><span class="s0">.pos-this.lineStart,</span><span class="s1">this</span><span class="s0">.pos)}clone(t){let r=</span><span class="s1">new </span><span class="s0">Nr,e=Object.keys(</span><span class="s1">this</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(let s=</span><span class="s3">0</span><span class="s0">,i=e.length;s&lt;i;s++){let a=e[s],n=</span><span class="s1">this</span><span class="s0">[a];!t&amp;&amp;Array.isArray(n)&amp;&amp;(n=n.slice()),r[a]=n}</span><span class="s1">return </span><span class="s0">r}},Nl=</span><span class="s1">function</span><span class="s0">(r){</span><span class="s1">return </span><span class="s0">r&gt;=</span><span class="s3">48</span><span class="s0">&amp;&amp;r&lt;=</span><span class="s3">57</span><span class="s0">},kr={decBinOct:</span><span class="s1">new </span><span class="s0">Set([</span><span class="s3">46</span><span class="s0">,</span><span class="s3">66</span><span class="s0">,</span><span class="s3">69</span><span class="s0">,</span><span class="s3">79</span><span class="s0">,</span><span class="s3">95</span><span class="s0">,</span><span class="s3">98</span><span class="s0">,</span><span class="s3">101</span><span class="s0">,</span><span class="s3">111</span><span class="s0">]),hex:</span><span class="s1">new </span><span class="s0">Set([</span><span class="s3">46</span><span class="s0">,</span><span class="s3">88</span><span class="s0">,</span><span class="s3">95</span><span class="s0">,</span><span class="s3">120</span><span class="s0">])},gt={bin:t=&gt;t===</span><span class="s3">48</span><span class="s0">||t===</span><span class="s3">49</span><span class="s0">,oct:t=&gt;t&gt;=</span><span class="s3">48</span><span class="s0">&amp;&amp;t&lt;=</span><span class="s3">55</span><span class="s0">,dec:t=&gt;t&gt;=</span><span class="s3">48</span><span class="s0">&amp;&amp;t&lt;=</span><span class="s3">57</span><span class="s0">,hex:t=&gt;t&gt;=</span><span class="s3">48</span><span class="s0">&amp;&amp;t&lt;=</span><span class="s3">57</span><span class="s0">||t&gt;=</span><span class="s3">65</span><span class="s0">&amp;&amp;t&lt;=</span><span class="s3">70</span><span class="s0">||t&gt;=</span><span class="s3">97</span><span class="s0">&amp;&amp;t&lt;=</span><span class="s3">102</span><span class="s0">};</span><span class="s1">function </span><span class="s0">Dr(t,r,e,s,i,a){let n=e,o=s,u=i,c=</span><span class="s2">&quot;&quot;</span><span class="s0">,y=</span><span class="s1">null</span><span class="s0">,g=e,{length:T}=r;</span><span class="s1">for</span><span class="s0">(;;){</span><span class="s1">if</span><span class="s0">(e&gt;=T){a.unterminated(n,o,u),c+=r.slice(g,e);</span><span class="s1">break</span><span class="s0">}let C=r.charCodeAt(e);</span><span class="s1">if</span><span class="s0">(kl(t,C,r,e)){c+=r.slice(g,e);</span><span class="s1">break</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(C===</span><span class="s3">92</span><span class="s0">){c+=r.slice(g,e);let M=Dl(r,e,s,i,t===</span><span class="s2">&quot;template&quot;</span><span class="s0">,a);M.ch===</span><span class="s1">null</span><span class="s0">&amp;&amp;!y?y={pos:e,lineStart:s,curLine:i}:c+=M.ch,{pos:e,lineStart:s,curLine:i}=M,g=e}</span><span class="s1">else </span><span class="s0">C===</span><span class="s3">8232</span><span class="s0">||C===</span><span class="s3">8233</span><span class="s0">?(++e,++i,s=e):C===</span><span class="s3">10</span><span class="s0">||C===</span><span class="s3">13</span><span class="s0">?t===</span><span class="s2">&quot;template&quot;</span><span class="s0">?(c+=r.slice(g,e)+`</span>
<span class="s0">`,++e,C===</span><span class="s3">13</span><span class="s0">&amp;&amp;r.charCodeAt(e)===</span><span class="s3">10</span><span class="s0">&amp;&amp;++e,++i,g=s=e):a.unterminated(n,o,u):++e}</span><span class="s1">return</span><span class="s0">{pos:e,str:c,firstInvalidLoc:y,lineStart:s,curLine:i,containsInvalid:!!y}}</span><span class="s1">function </span><span class="s0">kl(t,r,e,s){</span><span class="s1">return </span><span class="s0">t===</span><span class="s2">&quot;template&quot;</span><span class="s0">?r===</span><span class="s3">96</span><span class="s0">||r===</span><span class="s3">36</span><span class="s0">&amp;&amp;e.charCodeAt(s+</span><span class="s3">1</span><span class="s0">)===</span><span class="s3">123</span><span class="s0">:r===(t===</span><span class="s2">&quot;double&quot;</span><span class="s0">?</span><span class="s3">34</span><span class="s0">:</span><span class="s3">39</span><span class="s0">)}</span><span class="s1">function </span><span class="s0">Dl(t,r,e,s,i,a){let n=!i;r++;let o=c=&gt;({pos:r,ch:c,lineStart:e,curLine:s}),u=t.charCodeAt(r++);</span><span class="s1">switch</span><span class="s0">(u){</span><span class="s1">case </span><span class="s3">110</span><span class="s0">:</span><span class="s1">return </span><span class="s0">o(`</span>
<span class="s0">`);</span><span class="s1">case </span><span class="s3">114</span><span class="s0">:</span><span class="s1">return </span><span class="s0">o(</span><span class="s2">&quot;</span><span class="s4">\r</span><span class="s2">&quot;</span><span class="s0">);</span><span class="s1">case </span><span class="s3">120</span><span class="s0">:{let c;</span><span class="s1">return</span><span class="s0">{code:c,pos:r}=os(t,r,e,s,</span><span class="s3">2</span><span class="s0">,!</span><span class="s3">1</span><span class="s0">,n,a),o(c===</span><span class="s1">null</span><span class="s0">?</span><span class="s1">null</span><span class="s0">:String.fromCharCode(c))}</span><span class="s1">case </span><span class="s3">117</span><span class="s0">:{let c;</span><span class="s1">return</span><span class="s0">{code:c,pos:r}=Lr(t,r,e,s,n,a),o(c===</span><span class="s1">null</span><span class="s0">?</span><span class="s1">null</span><span class="s0">:String.fromCodePoint(c))}</span><span class="s1">case </span><span class="s3">116</span><span class="s0">:</span><span class="s1">return </span><span class="s0">o(</span><span class="s2">&quot;  &quot;</span><span class="s0">);</span><span class="s1">case </span><span class="s3">98</span><span class="s0">:</span><span class="s1">return </span><span class="s0">o(</span><span class="s2">&quot;</span><span class="s4">\b</span><span class="s2">&quot;</span><span class="s0">);</span><span class="s1">case </span><span class="s3">118</span><span class="s0">:</span><span class="s1">return </span><span class="s0">o(</span><span class="s2">&quot;</span><span class="s5">\v</span><span class="s2">&quot;</span><span class="s0">);</span><span class="s1">case </span><span class="s3">102</span><span class="s0">:</span><span class="s1">return </span><span class="s0">o(</span><span class="s2">&quot;</span><span class="s4">\f</span><span class="s2">&quot;</span><span class="s0">);</span><span class="s1">case </span><span class="s3">13</span><span class="s0">:t.charCodeAt(r)===</span><span class="s3">10</span><span class="s0">&amp;&amp;++r;</span><span class="s1">case </span><span class="s3">10</span><span class="s0">:e=r,++s;</span><span class="s1">case </span><span class="s3">8232</span><span class="s0">:</span><span class="s1">case </span><span class="s3">8233</span><span class="s0">:</span><span class="s1">return </span><span class="s0">o(</span><span class="s2">&quot;&quot;</span><span class="s0">);</span><span class="s1">case </span><span class="s3">56</span><span class="s0">:</span><span class="s1">case </span><span class="s3">57</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(i)</span><span class="s1">return </span><span class="s0">o(</span><span class="s1">null</span><span class="s0">);a.strictNumericEscape(r-1,e,s);</span><span class="s1">default</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(u&gt;=</span><span class="s3">48</span><span class="s0">&amp;&amp;u&lt;=</span><span class="s3">55</span><span class="s0">){let c=r-1,g=t.slice(c,r+</span><span class="s3">2</span><span class="s0">).match(/^[</span><span class="s3">0</span><span class="s0">-</span><span class="s3">7</span><span class="s0">]+/)[</span><span class="s3">0</span><span class="s0">],T=parseInt(g,</span><span class="s3">8</span><span class="s0">);T&gt;</span><span class="s3">255</span><span class="s0">&amp;&amp;(g=g.slice(</span><span class="s3">0</span><span class="s0">,-</span><span class="s3">1</span><span class="s0">),T=parseInt(g,</span><span class="s3">8</span><span class="s0">)),r+=g.length-1;let C=t.charCodeAt(r);</span><span class="s1">if</span><span class="s0">(g!==</span><span class="s2">&quot;0&quot;</span><span class="s0">||C===</span><span class="s3">56</span><span class="s0">||C===</span><span class="s3">57</span><span class="s0">){</span><span class="s1">if</span><span class="s0">(i)</span><span class="s1">return </span><span class="s0">o(</span><span class="s1">null</span><span class="s0">);a.strictNumericEscape(c,e,s)}</span><span class="s1">return </span><span class="s0">o(String.fromCharCode(T))}</span><span class="s1">return </span><span class="s0">o(String.fromCharCode(u))}}</span><span class="s1">function </span><span class="s0">os(t,r,e,s,i,a,n,o){let u=r,c;</span><span class="s1">return</span><span class="s0">{n:c,pos:r}=Fr(t,r,e,s,</span><span class="s3">16</span><span class="s0">,i,a,!</span><span class="s3">1</span><span class="s0">,o,!n),c===</span><span class="s1">null</span><span class="s0">&amp;&amp;(n?o.invalidEscapeSequence(u,e,s):r=u-1),{code:c,pos:r}}</span><span class="s1">function </span><span class="s0">Fr(t,r,e,s,i,a,n,o,u,c){let y=r,g=i===</span><span class="s3">16</span><span class="s0">?kr.hex:kr.decBinOct,T=i===</span><span class="s3">16</span><span class="s0">?gt.hex:i===</span><span class="s3">10</span><span class="s0">?gt.dec:i===</span><span class="s3">8</span><span class="s0">?gt.oct:gt.bin,C=!</span><span class="s3">1</span><span class="s0">,M=</span><span class="s3">0</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(let j=</span><span class="s3">0</span><span class="s0">,K=a==</span><span class="s1">null</span><span class="s0">?</span><span class="s3">1</span><span class="s0">/</span><span class="s3">0</span><span class="s0">:a;j&lt;K;++j){let W=t.charCodeAt(r),V;</span><span class="s1">if</span><span class="s0">(W===</span><span class="s3">95</span><span class="s0">&amp;&amp;o!==</span><span class="s2">&quot;bail&quot;</span><span class="s0">){let X=t.charCodeAt(r-1),je=t.charCodeAt(r+</span><span class="s3">1</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(o){</span><span class="s1">if</span><span class="s0">(Number.isNaN(je)||!T(je)||g.has(X)||g.has(je)){</span><span class="s1">if</span><span class="s0">(c)</span><span class="s1">return</span><span class="s0">{n:</span><span class="s1">null</span><span class="s0">,pos:r};u.unexpectedNumericSeparator(r,e,s)}}</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(c)</span><span class="s1">return</span><span class="s0">{n:</span><span class="s1">null</span><span class="s0">,pos:r};u.numericSeparatorInEscapeSequence(r,e,s)}++r;</span><span class="s1">continue</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(W&gt;=</span><span class="s3">97</span><span class="s0">?V=W-97+</span><span class="s3">10</span><span class="s0">:W&gt;=</span><span class="s3">65</span><span class="s0">?V=W-65+</span><span class="s3">10</span><span class="s0">:Nl(W)?V=W-48:V=</span><span class="s3">1</span><span class="s0">/</span><span class="s3">0</span><span class="s0">,V&gt;=i){</span><span class="s1">if</span><span class="s0">(V&lt;=</span><span class="s3">9</span><span class="s0">&amp;&amp;c)</span><span class="s1">return</span><span class="s0">{n:</span><span class="s1">null</span><span class="s0">,pos:r};</span><span class="s1">if</span><span class="s0">(V&lt;=</span><span class="s3">9</span><span class="s0">&amp;&amp;u.invalidDigit(r,e,s,i))V=</span><span class="s3">0</span><span class="s0">;</span><span class="s1">else if</span><span class="s0">(n)V=</span><span class="s3">0</span><span class="s0">,C=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">else break</span><span class="s0">}++r,M=M*i+V}</span><span class="s1">return </span><span class="s0">r===y||a!=</span><span class="s1">null</span><span class="s0">&amp;&amp;r-y!==a||C?{n:</span><span class="s1">null</span><span class="s0">,pos:r}:{n:M,pos:r}}</span><span class="s1">function </span><span class="s0">Lr(t,r,e,s,i,a){let n=t.charCodeAt(r),o;</span><span class="s1">if</span><span class="s0">(n===</span><span class="s3">123</span><span class="s0">){</span><span class="s1">if</span><span class="s0">(++r,{code:o,pos:r}=os(t,r,e,s,t.indexOf(</span><span class="s2">&quot;}&quot;</span><span class="s0">,r)-r,!</span><span class="s3">0</span><span class="s0">,i,a),++r,o!==</span><span class="s1">null</span><span class="s0">&amp;&amp;o&gt;</span><span class="s3">1114111</span><span class="s0">)</span><span class="s1">if</span><span class="s0">(i)a.invalidCodePoint(r,e,s);</span><span class="s1">else return</span><span class="s0">{code:</span><span class="s1">null</span><span class="s0">,pos:r}}</span><span class="s1">else</span><span class="s0">({code:o,pos:r}=os(t,r,e,s,</span><span class="s3">4</span><span class="s0">,!</span><span class="s3">1</span><span class="s0">,i,a));</span><span class="s1">return</span><span class="s0">{code:o,pos:r}}</span><span class="s1">var </span><span class="s0">Fl=[</span><span class="s2">&quot;at&quot;</span><span class="s0">],Ll=[</span><span class="s2">&quot;at&quot;</span><span class="s0">];</span><span class="s1">function </span><span class="s0">Je(t,r,e){</span><span class="s1">return new </span><span class="s0">ge(e,t-r,t)}</span><span class="s1">var </span><span class="s0">Ol=</span><span class="s1">new </span><span class="s0">Set([</span><span class="s3">103</span><span class="s0">,</span><span class="s3">109</span><span class="s0">,</span><span class="s3">115</span><span class="s0">,</span><span class="s3">105</span><span class="s0">,</span><span class="s3">121</span><span class="s0">,</span><span class="s3">117</span><span class="s0">,</span><span class="s3">100</span><span class="s0">,</span><span class="s3">118</span><span class="s0">]),Ae=class{constructor(t){</span><span class="s1">this</span><span class="s0">.type=t.type,</span><span class="s1">this</span><span class="s0">.value=t.value,</span><span class="s1">this</span><span class="s0">.start=t.start,</span><span class="s1">this</span><span class="s0">.end=t.end,</span><span class="s1">this</span><span class="s0">.loc=</span><span class="s1">new </span><span class="s0">lt(t.startLoc,t.endLoc)}},Bl=class extends Sl{constructor(t,r){super(),</span><span class="s1">this</span><span class="s0">.isLookahead=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.tokens=[],</span><span class="s1">this</span><span class="s0">.errorHandlers_readInt={invalidDigit:(e,s,i,a)=&gt;</span><span class="s1">this</span><span class="s0">.options.errorRecovery?(</span><span class="s1">this</span><span class="s0">.raise(f.InvalidDigit,{at:Je(e,s,i),radix:a}),!</span><span class="s3">0</span><span class="s0">):!</span><span class="s3">1</span><span class="s0">,numericSeparatorInEscapeSequence:</span><span class="s1">this</span><span class="s0">.errorBuilder(f.NumericSeparatorInEscapeSequence),unexpectedNumericSeparator:</span><span class="s1">this</span><span class="s0">.errorBuilder(f.UnexpectedNumericSeparator)},</span><span class="s1">this</span><span class="s0">.errorHandlers_readCodePoint=Object.assign({},</span><span class="s1">this</span><span class="s0">.errorHandlers_readInt,{invalidEscapeSequence:</span><span class="s1">this</span><span class="s0">.errorBuilder(f.InvalidEscapeSequence),invalidCodePoint:</span><span class="s1">this</span><span class="s0">.errorBuilder(f.InvalidCodePoint)}),</span><span class="s1">this</span><span class="s0">.errorHandlers_readStringContents_string=Object.assign({},</span><span class="s1">this</span><span class="s0">.errorHandlers_readCodePoint,{strictNumericEscape:(e,s,i)=&gt;{</span><span class="s1">this</span><span class="s0">.recordStrictModeErrors(f.StrictNumericEscape,{at:Je(e,s,i)})},unterminated:(e,s,i)=&gt;{</span><span class="s1">throw this</span><span class="s0">.raise(f.UnterminatedString,{at:Je(e-1,s,i)})}}),</span><span class="s1">this</span><span class="s0">.errorHandlers_readStringContents_template=Object.assign({},</span><span class="s1">this</span><span class="s0">.errorHandlers_readCodePoint,{strictNumericEscape:</span><span class="s1">this</span><span class="s0">.errorBuilder(f.StrictNumericEscape),unterminated:(e,s,i)=&gt;{</span><span class="s1">throw this</span><span class="s0">.raise(f.UnterminatedTemplate,{at:Je(e,s,i)})}}),</span><span class="s1">this</span><span class="s0">.state=</span><span class="s1">new </span><span class="s0">Nr,</span><span class="s1">this</span><span class="s0">.state.init(t),</span><span class="s1">this</span><span class="s0">.input=r,</span><span class="s1">this</span><span class="s0">.length=r.length,</span><span class="s1">this</span><span class="s0">.isLookahead=!</span><span class="s3">1</span><span class="s0">}pushToken(t){</span><span class="s1">this</span><span class="s0">.tokens.length=</span><span class="s1">this</span><span class="s0">.state.tokensLength,</span><span class="s1">this</span><span class="s0">.tokens.push(t),++</span><span class="s1">this</span><span class="s0">.state.tokensLength}next(){</span><span class="s1">this</span><span class="s0">.checkKeywordEscapes(),</span><span class="s1">this</span><span class="s0">.options.tokens&amp;&amp;</span><span class="s1">this</span><span class="s0">.pushToken(</span><span class="s1">new </span><span class="s0">Ae(</span><span class="s1">this</span><span class="s0">.state)),</span><span class="s1">this</span><span class="s0">.state.lastTokStart=</span><span class="s1">this</span><span class="s0">.state.start,</span><span class="s1">this</span><span class="s0">.state.lastTokEndLoc=</span><span class="s1">this</span><span class="s0">.state.endLoc,</span><span class="s1">this</span><span class="s0">.state.lastTokStartLoc=</span><span class="s1">this</span><span class="s0">.state.startLoc,</span><span class="s1">this</span><span class="s0">.nextToken()}eat(t){</span><span class="s1">return this</span><span class="s0">.match(t)?(</span><span class="s1">this</span><span class="s0">.next(),!</span><span class="s3">0</span><span class="s0">):!</span><span class="s3">1</span><span class="s0">}match(t){</span><span class="s1">return this</span><span class="s0">.state.type===t}createLookaheadState(t){</span><span class="s1">return</span><span class="s0">{pos:t.pos,value:</span><span class="s1">null</span><span class="s0">,type:t.type,start:t.start,end:t.end,context:[</span><span class="s1">this</span><span class="s0">.curContext()],inType:t.inType,startLoc:t.startLoc,lastTokEndLoc:t.lastTokEndLoc,curLine:t.curLine,lineStart:t.lineStart,curPosition:t.curPosition}}lookahead(){let t=</span><span class="s1">this</span><span class="s0">.state;</span><span class="s1">this</span><span class="s0">.state=</span><span class="s1">this</span><span class="s0">.createLookaheadState(t),</span><span class="s1">this</span><span class="s0">.isLookahead=!</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.nextToken(),</span><span class="s1">this</span><span class="s0">.isLookahead=!</span><span class="s3">1</span><span class="s0">;let r=</span><span class="s1">this</span><span class="s0">.state;</span><span class="s1">return this</span><span class="s0">.state=t,r}nextTokenStart(){</span><span class="s1">return this</span><span class="s0">.nextTokenStartSince(</span><span class="s1">this</span><span class="s0">.state.pos)}nextTokenStartSince(t){</span><span class="s1">return </span><span class="s0">ns.lastIndex=t,ns.test(</span><span class="s1">this</span><span class="s0">.input)?ns.lastIndex:t}lookaheadCharCode(){</span><span class="s1">return this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.nextTokenStart())}codePointAtPos(t){let r=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(t);</span><span class="s1">if</span><span class="s0">((r&amp;</span><span class="s3">64512</span><span class="s0">)===</span><span class="s3">55296</span><span class="s0">&amp;&amp;++t&lt;</span><span class="s1">this</span><span class="s0">.input.length){let e=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(t);(e&amp;</span><span class="s3">64512</span><span class="s0">)===</span><span class="s3">56320</span><span class="s0">&amp;&amp;(r=</span><span class="s3">65536</span><span class="s0">+((r&amp;</span><span class="s3">1023</span><span class="s0">)&lt;&lt;</span><span class="s3">10</span><span class="s0">)+(e&amp;</span><span class="s3">1023</span><span class="s0">))}</span><span class="s1">return </span><span class="s0">r}setStrict(t){</span><span class="s1">this</span><span class="s0">.state.strict=t,t&amp;&amp;(</span><span class="s1">this</span><span class="s0">.state.strictErrors.forEach(r=&gt;{let[e,s]=r;</span><span class="s1">return this</span><span class="s0">.raise(e,{at:s})}),</span><span class="s1">this</span><span class="s0">.state.strictErrors.clear())}curContext(){</span><span class="s1">return this</span><span class="s0">.state.context[</span><span class="s1">this</span><span class="s0">.state.context.length-1]}nextToken(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.skipSpace(),</span><span class="s1">this</span><span class="s0">.state.start=</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">this</span><span class="s0">.isLookahead||(</span><span class="s1">this</span><span class="s0">.state.startLoc=</span><span class="s1">this</span><span class="s0">.state.curPosition()),</span><span class="s1">this</span><span class="s0">.state.pos&gt;=</span><span class="s1">this</span><span class="s0">.length){</span><span class="s1">this</span><span class="s0">.finishToken(</span><span class="s3">137</span><span class="s0">);</span><span class="s1">return</span><span class="s0">}</span><span class="s1">this</span><span class="s0">.getTokenFromCode(</span><span class="s1">this</span><span class="s0">.codePointAtPos(</span><span class="s1">this</span><span class="s0">.state.pos))}skipBlockComment(t){let r;</span><span class="s1">this</span><span class="s0">.isLookahead||(r=</span><span class="s1">this</span><span class="s0">.state.curPosition());let e=</span><span class="s1">this</span><span class="s0">.state.pos,s=</span><span class="s1">this</span><span class="s0">.input.indexOf(t,e+</span><span class="s3">2</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(s===-</span><span class="s3">1</span><span class="s0">)</span><span class="s1">throw this</span><span class="s0">.raise(f.UnterminatedComment,{at:</span><span class="s1">this</span><span class="s0">.state.curPosition()});</span><span class="s1">for</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.pos=s+t.length,xt.lastIndex=e+</span><span class="s3">2</span><span class="s0">;xt.test(</span><span class="s1">this</span><span class="s0">.input)&amp;&amp;xt.lastIndex&lt;=s;)++</span><span class="s1">this</span><span class="s0">.state.curLine,</span><span class="s1">this</span><span class="s0">.state.lineStart=xt.lastIndex;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isLookahead)</span><span class="s1">return</span><span class="s0">;let i={type:</span><span class="s2">&quot;CommentBlock&quot;</span><span class="s0">,value:</span><span class="s1">this</span><span class="s0">.input.slice(e+</span><span class="s3">2</span><span class="s0">,s),start:e,end:s+t.length,loc:</span><span class="s1">new </span><span class="s0">lt(r,</span><span class="s1">this</span><span class="s0">.state.curPosition())};</span><span class="s1">return this</span><span class="s0">.options.tokens&amp;&amp;</span><span class="s1">this</span><span class="s0">.pushToken(i),i}skipLineComment(t){let r=</span><span class="s1">this</span><span class="s0">.state.pos,e;</span><span class="s1">this</span><span class="s0">.isLookahead||(e=</span><span class="s1">this</span><span class="s0">.state.curPosition());let s=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+=t);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.pos&lt;</span><span class="s1">this</span><span class="s0">.length)</span><span class="s1">for</span><span class="s0">(;!Ge(s)&amp;&amp;++</span><span class="s1">this</span><span class="s0">.state.pos&lt;</span><span class="s1">this</span><span class="s0">.length;)s=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isLookahead)</span><span class="s1">return</span><span class="s0">;let i=</span><span class="s1">this</span><span class="s0">.state.pos,n={type:</span><span class="s2">&quot;CommentLine&quot;</span><span class="s0">,value:</span><span class="s1">this</span><span class="s0">.input.slice(r+t,i),start:r,end:i,loc:</span><span class="s1">new </span><span class="s0">lt(e,</span><span class="s1">this</span><span class="s0">.state.curPosition())};</span><span class="s1">return this</span><span class="s0">.options.tokens&amp;&amp;</span><span class="s1">this</span><span class="s0">.pushToken(n),n}skipSpace(){let t=</span><span class="s1">this</span><span class="s0">.state.pos,r=[];e:</span><span class="s1">for</span><span class="s0">(;</span><span class="s1">this</span><span class="s0">.state.pos&lt;</span><span class="s1">this</span><span class="s0">.length;){let e=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos);</span><span class="s1">switch</span><span class="s0">(e){</span><span class="s1">case </span><span class="s3">32</span><span class="s0">:</span><span class="s1">case </span><span class="s3">160</span><span class="s0">:</span><span class="s1">case </span><span class="s3">9</span><span class="s0">:++</span><span class="s1">this</span><span class="s0">.state.pos;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case </span><span class="s3">13</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s3">1</span><span class="s0">)===</span><span class="s3">10</span><span class="s0">&amp;&amp;++</span><span class="s1">this</span><span class="s0">.state.pos;</span><span class="s1">case </span><span class="s3">10</span><span class="s0">:</span><span class="s1">case </span><span class="s3">8232</span><span class="s0">:</span><span class="s1">case </span><span class="s3">8233</span><span class="s0">:++</span><span class="s1">this</span><span class="s0">.state.pos,++</span><span class="s1">this</span><span class="s0">.state.curLine,</span><span class="s1">this</span><span class="s0">.state.lineStart=</span><span class="s1">this</span><span class="s0">.state.pos;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case </span><span class="s3">47</span><span class="s0">:</span><span class="s1">switch</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s3">1</span><span class="s0">)){</span><span class="s1">case </span><span class="s3">42</span><span class="s0">:{let s=</span><span class="s1">this</span><span class="s0">.skipBlockComment(</span><span class="s2">&quot;*/&quot;</span><span class="s0">);s!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">&amp;&amp;(</span><span class="s1">this</span><span class="s0">.addComment(s),</span><span class="s1">this</span><span class="s0">.options.attachComment&amp;&amp;r.push(s));</span><span class="s1">break</span><span class="s0">}</span><span class="s1">case </span><span class="s3">47</span><span class="s0">:{let s=</span><span class="s1">this</span><span class="s0">.skipLineComment(</span><span class="s3">2</span><span class="s0">);s!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">&amp;&amp;(</span><span class="s1">this</span><span class="s0">.addComment(s),</span><span class="s1">this</span><span class="s0">.options.attachComment&amp;&amp;r.push(s));</span><span class="s1">break</span><span class="s0">}</span><span class="s1">default</span><span class="s0">:</span><span class="s1">break </span><span class="s0">e}</span><span class="s1">break</span><span class="s0">;</span><span class="s1">default</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(Il(e))++</span><span class="s1">this</span><span class="s0">.state.pos;</span><span class="s1">else if</span><span class="s0">(e===</span><span class="s3">45</span><span class="s0">&amp;&amp;!</span><span class="s1">this</span><span class="s0">.inModule&amp;&amp;</span><span class="s1">this</span><span class="s0">.options.annexB){let s=</span><span class="s1">this</span><span class="s0">.state.pos;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.input.charCodeAt(s+</span><span class="s3">1</span><span class="s0">)===</span><span class="s3">45</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.input.charCodeAt(s+</span><span class="s3">2</span><span class="s0">)===</span><span class="s3">62</span><span class="s0">&amp;&amp;(t===</span><span class="s3">0</span><span class="s0">||</span><span class="s1">this</span><span class="s0">.state.lineStart&gt;t)){let i=</span><span class="s1">this</span><span class="s0">.skipLineComment(</span><span class="s3">3</span><span class="s0">);i!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">&amp;&amp;(</span><span class="s1">this</span><span class="s0">.addComment(i),</span><span class="s1">this</span><span class="s0">.options.attachComment&amp;&amp;r.push(i))}</span><span class="s1">else break </span><span class="s0">e}</span><span class="s1">else if</span><span class="s0">(e===</span><span class="s3">60</span><span class="s0">&amp;&amp;!</span><span class="s1">this</span><span class="s0">.inModule&amp;&amp;</span><span class="s1">this</span><span class="s0">.options.annexB){let s=</span><span class="s1">this</span><span class="s0">.state.pos;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.input.charCodeAt(s+</span><span class="s3">1</span><span class="s0">)===</span><span class="s3">33</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.input.charCodeAt(s+</span><span class="s3">2</span><span class="s0">)===</span><span class="s3">45</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.input.charCodeAt(s+</span><span class="s3">3</span><span class="s0">)===</span><span class="s3">45</span><span class="s0">){let i=</span><span class="s1">this</span><span class="s0">.skipLineComment(</span><span class="s3">4</span><span class="s0">);i!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">&amp;&amp;(</span><span class="s1">this</span><span class="s0">.addComment(i),</span><span class="s1">this</span><span class="s0">.options.attachComment&amp;&amp;r.push(i))}</span><span class="s1">else break </span><span class="s0">e}</span><span class="s1">else break </span><span class="s0">e}}</span><span class="s1">if</span><span class="s0">(r.length&gt;</span><span class="s3">0</span><span class="s0">){let e=</span><span class="s1">this</span><span class="s0">.state.pos,s={start:t,end:e,comments:r,leadingNode:</span><span class="s1">null</span><span class="s0">,trailingNode:</span><span class="s1">null</span><span class="s0">,containingNode:</span><span class="s1">null</span><span class="s0">};</span><span class="s1">this</span><span class="s0">.state.commentStack.push(s)}}finishToken(t,r){</span><span class="s1">this</span><span class="s0">.state.end=</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">this</span><span class="s0">.state.endLoc=</span><span class="s1">this</span><span class="s0">.state.curPosition();let e=</span><span class="s1">this</span><span class="s0">.state.type;</span><span class="s1">this</span><span class="s0">.state.type=t,</span><span class="s1">this</span><span class="s0">.state.value=r,</span><span class="s1">this</span><span class="s0">.isLookahead||</span><span class="s1">this</span><span class="s0">.updateContext(e)}replaceToken(t){</span><span class="s1">this</span><span class="s0">.state.type=t,</span><span class="s1">this</span><span class="s0">.updateContext()}readToken_numberSign(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.pos===</span><span class="s3">0</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.readToken_interpreter())</span><span class="s1">return</span><span class="s0">;let t=</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s3">1</span><span class="s0">,r=</span><span class="s1">this</span><span class="s0">.codePointAtPos(t);</span><span class="s1">if</span><span class="s0">(r&gt;=</span><span class="s3">48</span><span class="s0">&amp;&amp;r&lt;=</span><span class="s3">57</span><span class="s0">)</span><span class="s1">throw this</span><span class="s0">.raise(f.UnexpectedDigitAfterHash,{at:</span><span class="s1">this</span><span class="s0">.state.curPosition()});</span><span class="s1">if</span><span class="s0">(r===</span><span class="s3">123</span><span class="s0">||r===</span><span class="s3">91</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s2">&quot;recordAndTuple&quot;</span><span class="s0">)){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s2">&quot;recordAndTuple&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.getPluginOption(</span><span class="s2">&quot;recordAndTuple&quot;</span><span class="s0">,</span><span class="s2">&quot;syntaxType&quot;</span><span class="s0">)===</span><span class="s2">&quot;bar&quot;</span><span class="s0">)</span><span class="s1">throw this</span><span class="s0">.raise(r===</span><span class="s3">123</span><span class="s0">?f.RecordExpressionHashIncorrectStartSyntaxType:f.TupleExpressionHashIncorrectStartSyntaxType,{at:</span><span class="s1">this</span><span class="s0">.state.curPosition()});</span><span class="s1">this</span><span class="s0">.state.pos+=</span><span class="s3">2</span><span class="s0">,r===</span><span class="s3">123</span><span class="s0">?</span><span class="s1">this</span><span class="s0">.finishToken(</span><span class="s3">7</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.finishToken(</span><span class="s3">1</span><span class="s0">)}</span><span class="s1">else </span><span class="s0">fe(r)?(++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">this</span><span class="s0">.finishToken(</span><span class="s3">136</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.readWord1(r))):r===</span><span class="s3">92</span><span class="s0">?(++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">this</span><span class="s0">.finishToken(</span><span class="s3">136</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.readWord1())):</span><span class="s1">this</span><span class="s0">.finishOp(</span><span class="s3">27</span><span class="s0">,</span><span class="s3">1</span><span class="s0">)}readToken_dot(){let t=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s3">1</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(t&gt;=</span><span class="s3">48</span><span class="s0">&amp;&amp;t&lt;=</span><span class="s3">57</span><span class="s0">){</span><span class="s1">this</span><span class="s0">.readNumber(!</span><span class="s3">0</span><span class="s0">);</span><span class="s1">return</span><span class="s0">}t===</span><span class="s3">46</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s3">2</span><span class="s0">)===</span><span class="s3">46</span><span class="s0">?(</span><span class="s1">this</span><span class="s0">.state.pos+=</span><span class="s3">3</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.finishToken(</span><span class="s3">21</span><span class="s0">)):(++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">this</span><span class="s0">.finishToken(</span><span class="s3">16</span><span class="s0">))}readToken_slash(){</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s3">1</span><span class="s0">)===</span><span class="s3">61</span><span class="s0">?</span><span class="s1">this</span><span class="s0">.finishOp(</span><span class="s3">31</span><span class="s0">,</span><span class="s3">2</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.finishOp(</span><span class="s3">56</span><span class="s0">,</span><span class="s3">1</span><span class="s0">)}readToken_interpreter(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.pos!==</span><span class="s3">0</span><span class="s0">||</span><span class="s1">this</span><span class="s0">.length&lt;</span><span class="s3">2</span><span class="s0">)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;let t=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s3">1</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(t!==</span><span class="s3">33</span><span class="s0">)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;let r=</span><span class="s1">this</span><span class="s0">.state.pos;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.pos+=</span><span class="s3">1</span><span class="s0">;!Ge(t)&amp;&amp;++</span><span class="s1">this</span><span class="s0">.state.pos&lt;</span><span class="s1">this</span><span class="s0">.length;)t=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos);let e=</span><span class="s1">this</span><span class="s0">.input.slice(r+</span><span class="s3">2</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.state.pos);</span><span class="s1">return this</span><span class="s0">.finishToken(</span><span class="s3">28</span><span class="s0">,e),!</span><span class="s3">0</span><span class="s0">}readToken_mult_modulo(t){let r=t===</span><span class="s3">42</span><span class="s0">?</span><span class="s3">55</span><span class="s0">:</span><span class="s3">54</span><span class="s0">,e=</span><span class="s3">1</span><span class="s0">,s=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s3">1</span><span class="s0">);t===</span><span class="s3">42</span><span class="s0">&amp;&amp;s===</span><span class="s3">42</span><span class="s0">&amp;&amp;(e++,s=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s3">2</span><span class="s0">),r=</span><span class="s3">57</span><span class="s0">),s===</span><span class="s3">61</span><span class="s0">&amp;&amp;!</span><span class="s1">this</span><span class="s0">.state.inType&amp;&amp;(e++,r=t===</span><span class="s3">37</span><span class="s0">?</span><span class="s3">33</span><span class="s0">:</span><span class="s3">30</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishOp(r,e)}readToken_pipe_amp(t){let r=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s3">1</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(r===t){</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s3">2</span><span class="s0">)===</span><span class="s3">61</span><span class="s0">?</span><span class="s1">this</span><span class="s0">.finishOp(</span><span class="s3">30</span><span class="s0">,</span><span class="s3">3</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.finishOp(t===</span><span class="s3">124</span><span class="s0">?</span><span class="s3">41</span><span class="s0">:</span><span class="s3">42</span><span class="s0">,</span><span class="s3">2</span><span class="s0">);</span><span class="s1">return</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(t===</span><span class="s3">124</span><span class="s0">){</span><span class="s1">if</span><span class="s0">(r===</span><span class="s3">62</span><span class="s0">){</span><span class="s1">this</span><span class="s0">.finishOp(</span><span class="s3">39</span><span class="s0">,</span><span class="s3">2</span><span class="s0">);</span><span class="s1">return</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s2">&quot;recordAndTuple&quot;</span><span class="s0">)&amp;&amp;r===</span><span class="s3">125</span><span class="s0">){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.getPluginOption(</span><span class="s2">&quot;recordAndTuple&quot;</span><span class="s0">,</span><span class="s2">&quot;syntaxType&quot;</span><span class="s0">)!==</span><span class="s2">&quot;bar&quot;</span><span class="s0">)</span><span class="s1">throw this</span><span class="s0">.raise(f.RecordExpressionBarIncorrectEndSyntaxType,{at:</span><span class="s1">this</span><span class="s0">.state.curPosition()});</span><span class="s1">this</span><span class="s0">.state.pos+=</span><span class="s3">2</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.finishToken(</span><span class="s3">9</span><span class="s0">);</span><span class="s1">return</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s2">&quot;recordAndTuple&quot;</span><span class="s0">)&amp;&amp;r===</span><span class="s3">93</span><span class="s0">){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.getPluginOption(</span><span class="s2">&quot;recordAndTuple&quot;</span><span class="s0">,</span><span class="s2">&quot;syntaxType&quot;</span><span class="s0">)!==</span><span class="s2">&quot;bar&quot;</span><span class="s0">)</span><span class="s1">throw this</span><span class="s0">.raise(f.TupleExpressionBarIncorrectEndSyntaxType,{at:</span><span class="s1">this</span><span class="s0">.state.curPosition()});</span><span class="s1">this</span><span class="s0">.state.pos+=</span><span class="s3">2</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.finishToken(</span><span class="s3">4</span><span class="s0">);</span><span class="s1">return</span><span class="s0">}}</span><span class="s1">if</span><span class="s0">(r===</span><span class="s3">61</span><span class="s0">){</span><span class="s1">this</span><span class="s0">.finishOp(</span><span class="s3">30</span><span class="s0">,</span><span class="s3">2</span><span class="s0">);</span><span class="s1">return</span><span class="s0">}</span><span class="s1">this</span><span class="s0">.finishOp(t===</span><span class="s3">124</span><span class="s0">?</span><span class="s3">43</span><span class="s0">:</span><span class="s3">45</span><span class="s0">,</span><span class="s3">1</span><span class="s0">)}readToken_caret(){let t=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s3">1</span><span class="s0">);t===</span><span class="s3">61</span><span class="s0">&amp;&amp;!</span><span class="s1">this</span><span class="s0">.state.inType?</span><span class="s1">this</span><span class="s0">.finishOp(</span><span class="s3">32</span><span class="s0">,</span><span class="s3">2</span><span class="s0">):t===</span><span class="s3">94</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.hasPlugin([</span><span class="s2">&quot;pipelineOperator&quot;</span><span class="s0">,{proposal:</span><span class="s2">&quot;hack&quot;</span><span class="s0">,topicToken:</span><span class="s2">&quot;^^&quot;</span><span class="s0">}])?(</span><span class="s1">this</span><span class="s0">.finishOp(</span><span class="s3">37</span><span class="s0">,</span><span class="s3">2</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.input.codePointAt(</span><span class="s1">this</span><span class="s0">.state.pos)===</span><span class="s3">94</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected()):</span><span class="s1">this</span><span class="s0">.finishOp(</span><span class="s3">44</span><span class="s0">,</span><span class="s3">1</span><span class="s0">)}readToken_atSign(){</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s3">1</span><span class="s0">)===</span><span class="s3">64</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.hasPlugin([</span><span class="s2">&quot;pipelineOperator&quot;</span><span class="s0">,{proposal:</span><span class="s2">&quot;hack&quot;</span><span class="s0">,topicToken:</span><span class="s2">&quot;@@&quot;</span><span class="s0">}])?</span><span class="s1">this</span><span class="s0">.finishOp(</span><span class="s3">38</span><span class="s0">,</span><span class="s3">2</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.finishOp(</span><span class="s3">26</span><span class="s0">,</span><span class="s3">1</span><span class="s0">)}readToken_plus_min(t){let r=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s3">1</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(r===t){</span><span class="s1">this</span><span class="s0">.finishOp(</span><span class="s3">34</span><span class="s0">,</span><span class="s3">2</span><span class="s0">);</span><span class="s1">return</span><span class="s0">}r===</span><span class="s3">61</span><span class="s0">?</span><span class="s1">this</span><span class="s0">.finishOp(</span><span class="s3">30</span><span class="s0">,</span><span class="s3">2</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.finishOp(</span><span class="s3">53</span><span class="s0">,</span><span class="s3">1</span><span class="s0">)}readToken_lt(){let{pos:t}=</span><span class="s1">this</span><span class="s0">.state,r=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(t+</span><span class="s3">1</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(r===</span><span class="s3">60</span><span class="s0">){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.input.charCodeAt(t+</span><span class="s3">2</span><span class="s0">)===</span><span class="s3">61</span><span class="s0">){</span><span class="s1">this</span><span class="s0">.finishOp(</span><span class="s3">30</span><span class="s0">,</span><span class="s3">3</span><span class="s0">);</span><span class="s1">return</span><span class="s0">}</span><span class="s1">this</span><span class="s0">.finishOp(</span><span class="s3">51</span><span class="s0">,</span><span class="s3">2</span><span class="s0">);</span><span class="s1">return</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(r===</span><span class="s3">61</span><span class="s0">){</span><span class="s1">this</span><span class="s0">.finishOp(</span><span class="s3">49</span><span class="s0">,</span><span class="s3">2</span><span class="s0">);</span><span class="s1">return</span><span class="s0">}</span><span class="s1">this</span><span class="s0">.finishOp(</span><span class="s3">47</span><span class="s0">,</span><span class="s3">1</span><span class="s0">)}readToken_gt(){let{pos:t}=</span><span class="s1">this</span><span class="s0">.state,r=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(t+</span><span class="s3">1</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(r===</span><span class="s3">62</span><span class="s0">){let e=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(t+</span><span class="s3">2</span><span class="s0">)===</span><span class="s3">62</span><span class="s0">?</span><span class="s3">3</span><span class="s0">:</span><span class="s3">2</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.input.charCodeAt(t+e)===</span><span class="s3">61</span><span class="s0">){</span><span class="s1">this</span><span class="s0">.finishOp(</span><span class="s3">30</span><span class="s0">,e+</span><span class="s3">1</span><span class="s0">);</span><span class="s1">return</span><span class="s0">}</span><span class="s1">this</span><span class="s0">.finishOp(</span><span class="s3">52</span><span class="s0">,e);</span><span class="s1">return</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(r===</span><span class="s3">61</span><span class="s0">){</span><span class="s1">this</span><span class="s0">.finishOp(</span><span class="s3">49</span><span class="s0">,</span><span class="s3">2</span><span class="s0">);</span><span class="s1">return</span><span class="s0">}</span><span class="s1">this</span><span class="s0">.finishOp(</span><span class="s3">48</span><span class="s0">,</span><span class="s3">1</span><span class="s0">)}readToken_eq_excl(t){let r=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s3">1</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(r===</span><span class="s3">61</span><span class="s0">){</span><span class="s1">this</span><span class="s0">.finishOp(</span><span class="s3">46</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s3">2</span><span class="s0">)===</span><span class="s3">61</span><span class="s0">?</span><span class="s3">3</span><span class="s0">:</span><span class="s3">2</span><span class="s0">);</span><span class="s1">return</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(t===</span><span class="s3">61</span><span class="s0">&amp;&amp;r===</span><span class="s3">62</span><span class="s0">){</span><span class="s1">this</span><span class="s0">.state.pos+=</span><span class="s3">2</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.finishToken(</span><span class="s3">19</span><span class="s0">);</span><span class="s1">return</span><span class="s0">}</span><span class="s1">this</span><span class="s0">.finishOp(t===</span><span class="s3">61</span><span class="s0">?</span><span class="s3">29</span><span class="s0">:</span><span class="s3">35</span><span class="s0">,</span><span class="s3">1</span><span class="s0">)}readToken_question(){let t=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s3">1</span><span class="s0">),r=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s3">2</span><span class="s0">);t===</span><span class="s3">63</span><span class="s0">?r===</span><span class="s3">61</span><span class="s0">?</span><span class="s1">this</span><span class="s0">.finishOp(</span><span class="s3">30</span><span class="s0">,</span><span class="s3">3</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.finishOp(</span><span class="s3">40</span><span class="s0">,</span><span class="s3">2</span><span class="s0">):t===</span><span class="s3">46</span><span class="s0">&amp;&amp;!(r&gt;=</span><span class="s3">48</span><span class="s0">&amp;&amp;r&lt;=</span><span class="s3">57</span><span class="s0">)?(</span><span class="s1">this</span><span class="s0">.state.pos+=</span><span class="s3">2</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.finishToken(</span><span class="s3">18</span><span class="s0">)):(++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">this</span><span class="s0">.finishToken(</span><span class="s3">17</span><span class="s0">))}getTokenFromCode(t){</span><span class="s1">switch</span><span class="s0">(t){</span><span class="s1">case </span><span class="s3">46</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.readToken_dot();</span><span class="s1">return</span><span class="s0">;</span><span class="s1">case </span><span class="s3">40</span><span class="s0">:++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">this</span><span class="s0">.finishToken(</span><span class="s3">10</span><span class="s0">);</span><span class="s1">return</span><span class="s0">;</span><span class="s1">case </span><span class="s3">41</span><span class="s0">:++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">this</span><span class="s0">.finishToken(</span><span class="s3">11</span><span class="s0">);</span><span class="s1">return</span><span class="s0">;</span><span class="s1">case </span><span class="s3">59</span><span class="s0">:++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">this</span><span class="s0">.finishToken(</span><span class="s3">13</span><span class="s0">);</span><span class="s1">return</span><span class="s0">;</span><span class="s1">case </span><span class="s3">44</span><span class="s0">:++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">this</span><span class="s0">.finishToken(</span><span class="s3">12</span><span class="s0">);</span><span class="s1">return</span><span class="s0">;</span><span class="s1">case </span><span class="s3">91</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s2">&quot;recordAndTuple&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s3">1</span><span class="s0">)===</span><span class="s3">124</span><span class="s0">){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.getPluginOption(</span><span class="s2">&quot;recordAndTuple&quot;</span><span class="s0">,</span><span class="s2">&quot;syntaxType&quot;</span><span class="s0">)!==</span><span class="s2">&quot;bar&quot;</span><span class="s0">)</span><span class="s1">throw this</span><span class="s0">.raise(f.TupleExpressionBarIncorrectStartSyntaxType,{at:</span><span class="s1">this</span><span class="s0">.state.curPosition()});</span><span class="s1">this</span><span class="s0">.state.pos+=</span><span class="s3">2</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.finishToken(</span><span class="s3">2</span><span class="s0">)}</span><span class="s1">else</span><span class="s0">++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">this</span><span class="s0">.finishToken(</span><span class="s3">0</span><span class="s0">);</span><span class="s1">return</span><span class="s0">;</span><span class="s1">case </span><span class="s3">93</span><span class="s0">:++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">this</span><span class="s0">.finishToken(</span><span class="s3">3</span><span class="s0">);</span><span class="s1">return</span><span class="s0">;</span><span class="s1">case </span><span class="s3">123</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s2">&quot;recordAndTuple&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s3">1</span><span class="s0">)===</span><span class="s3">124</span><span class="s0">){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.getPluginOption(</span><span class="s2">&quot;recordAndTuple&quot;</span><span class="s0">,</span><span class="s2">&quot;syntaxType&quot;</span><span class="s0">)!==</span><span class="s2">&quot;bar&quot;</span><span class="s0">)</span><span class="s1">throw this</span><span class="s0">.raise(f.RecordExpressionBarIncorrectStartSyntaxType,{at:</span><span class="s1">this</span><span class="s0">.state.curPosition()});</span><span class="s1">this</span><span class="s0">.state.pos+=</span><span class="s3">2</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.finishToken(</span><span class="s3">6</span><span class="s0">)}</span><span class="s1">else</span><span class="s0">++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">this</span><span class="s0">.finishToken(</span><span class="s3">5</span><span class="s0">);</span><span class="s1">return</span><span class="s0">;</span><span class="s1">case </span><span class="s3">125</span><span class="s0">:++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">this</span><span class="s0">.finishToken(</span><span class="s3">8</span><span class="s0">);</span><span class="s1">return</span><span class="s0">;</span><span class="s1">case </span><span class="s3">58</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s2">&quot;functionBind&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s3">1</span><span class="s0">)===</span><span class="s3">58</span><span class="s0">?</span><span class="s1">this</span><span class="s0">.finishOp(</span><span class="s3">15</span><span class="s0">,</span><span class="s3">2</span><span class="s0">):(++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">this</span><span class="s0">.finishToken(</span><span class="s3">14</span><span class="s0">));</span><span class="s1">return</span><span class="s0">;</span><span class="s1">case </span><span class="s3">63</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.readToken_question();</span><span class="s1">return</span><span class="s0">;</span><span class="s1">case </span><span class="s3">96</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.readTemplateToken();</span><span class="s1">return</span><span class="s0">;</span><span class="s1">case </span><span class="s3">48</span><span class="s0">:{let r=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s3">1</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(r===</span><span class="s3">120</span><span class="s0">||r===</span><span class="s3">88</span><span class="s0">){</span><span class="s1">this</span><span class="s0">.readRadixNumber(</span><span class="s3">16</span><span class="s0">);</span><span class="s1">return</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(r===</span><span class="s3">111</span><span class="s0">||r===</span><span class="s3">79</span><span class="s0">){</span><span class="s1">this</span><span class="s0">.readRadixNumber(</span><span class="s3">8</span><span class="s0">);</span><span class="s1">return</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(r===</span><span class="s3">98</span><span class="s0">||r===</span><span class="s3">66</span><span class="s0">){</span><span class="s1">this</span><span class="s0">.readRadixNumber(</span><span class="s3">2</span><span class="s0">);</span><span class="s1">return</span><span class="s0">}}</span><span class="s1">case </span><span class="s3">49</span><span class="s0">:</span><span class="s1">case </span><span class="s3">50</span><span class="s0">:</span><span class="s1">case </span><span class="s3">51</span><span class="s0">:</span><span class="s1">case </span><span class="s3">52</span><span class="s0">:</span><span class="s1">case </span><span class="s3">53</span><span class="s0">:</span><span class="s1">case </span><span class="s3">54</span><span class="s0">:</span><span class="s1">case </span><span class="s3">55</span><span class="s0">:</span><span class="s1">case </span><span class="s3">56</span><span class="s0">:</span><span class="s1">case </span><span class="s3">57</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.readNumber(!</span><span class="s3">1</span><span class="s0">);</span><span class="s1">return</span><span class="s0">;</span><span class="s1">case </span><span class="s3">34</span><span class="s0">:</span><span class="s1">case </span><span class="s3">39</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.readString(t);</span><span class="s1">return</span><span class="s0">;</span><span class="s1">case </span><span class="s3">47</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.readToken_slash();</span><span class="s1">return</span><span class="s0">;</span><span class="s1">case </span><span class="s3">37</span><span class="s0">:</span><span class="s1">case </span><span class="s3">42</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.readToken_mult_modulo(t);</span><span class="s1">return</span><span class="s0">;</span><span class="s1">case </span><span class="s3">124</span><span class="s0">:</span><span class="s1">case </span><span class="s3">38</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.readToken_pipe_amp(t);</span><span class="s1">return</span><span class="s0">;</span><span class="s1">case </span><span class="s3">94</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.readToken_caret();</span><span class="s1">return</span><span class="s0">;</span><span class="s1">case </span><span class="s3">43</span><span class="s0">:</span><span class="s1">case </span><span class="s3">45</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.readToken_plus_min(t);</span><span class="s1">return</span><span class="s0">;</span><span class="s1">case </span><span class="s3">60</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.readToken_lt();</span><span class="s1">return</span><span class="s0">;</span><span class="s1">case </span><span class="s3">62</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.readToken_gt();</span><span class="s1">return</span><span class="s0">;</span><span class="s1">case </span><span class="s3">61</span><span class="s0">:</span><span class="s1">case </span><span class="s3">33</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.readToken_eq_excl(t);</span><span class="s1">return</span><span class="s0">;</span><span class="s1">case </span><span class="s3">126</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.finishOp(</span><span class="s3">36</span><span class="s0">,</span><span class="s3">1</span><span class="s0">);</span><span class="s1">return</span><span class="s0">;</span><span class="s1">case </span><span class="s3">64</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.readToken_atSign();</span><span class="s1">return</span><span class="s0">;</span><span class="s1">case </span><span class="s3">35</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.readToken_numberSign();</span><span class="s1">return</span><span class="s0">;</span><span class="s1">case </span><span class="s3">92</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.readWord();</span><span class="s1">return</span><span class="s0">;</span><span class="s1">default</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(fe(t)){</span><span class="s1">this</span><span class="s0">.readWord(t);</span><span class="s1">return</span><span class="s0">}}</span><span class="s1">throw this</span><span class="s0">.raise(f.InvalidOrUnexpectedToken,{at:</span><span class="s1">this</span><span class="s0">.state.curPosition(),unexpected:String.fromCodePoint(t)})}finishOp(t,r){let e=</span><span class="s1">this</span><span class="s0">.input.slice(</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">this</span><span class="s0">.state.pos+r);</span><span class="s1">this</span><span class="s0">.state.pos+=r,</span><span class="s1">this</span><span class="s0">.finishToken(t,e)}readRegexp(){let t=</span><span class="s1">this</span><span class="s0">.state.startLoc,r=</span><span class="s1">this</span><span class="s0">.state.start+</span><span class="s3">1</span><span class="s0">,e,s,{pos:i}=</span><span class="s1">this</span><span class="s0">.state;</span><span class="s1">for</span><span class="s0">(;;++i){</span><span class="s1">if</span><span class="s0">(i&gt;=</span><span class="s1">this</span><span class="s0">.length)</span><span class="s1">throw this</span><span class="s0">.raise(f.UnterminatedRegExp,{at:Y(t,</span><span class="s3">1</span><span class="s0">)});let u=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(i);</span><span class="s1">if</span><span class="s0">(Ge(u))</span><span class="s1">throw this</span><span class="s0">.raise(f.UnterminatedRegExp,{at:Y(t,</span><span class="s3">1</span><span class="s0">)});</span><span class="s1">if</span><span class="s0">(e)e=!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(u===</span><span class="s3">91</span><span class="s0">)s=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">else if</span><span class="s0">(u===</span><span class="s3">93</span><span class="s0">&amp;&amp;s)s=!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">else if</span><span class="s0">(u===</span><span class="s3">47</span><span class="s0">&amp;&amp;!s)</span><span class="s1">break</span><span class="s0">;e=u===</span><span class="s3">92</span><span class="s0">}}let a=</span><span class="s1">this</span><span class="s0">.input.slice(r,i);++i;let n=</span><span class="s2">&quot;&quot;</span><span class="s0">,o=()=&gt;Y(t,i+</span><span class="s3">2</span><span class="s0">-r);</span><span class="s1">for</span><span class="s0">(;i&lt;</span><span class="s1">this</span><span class="s0">.length;){let u=</span><span class="s1">this</span><span class="s0">.codePointAtPos(i),c=String.fromCharCode(u);</span><span class="s1">if</span><span class="s0">(Ol.has(u))u===</span><span class="s3">118</span><span class="s0">?(</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s2">&quot;regexpUnicodeSets&quot;</span><span class="s0">,o()),n.includes(</span><span class="s2">&quot;u&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.IncompatibleRegExpUVFlags,{at:o()})):u===</span><span class="s3">117</span><span class="s0">&amp;&amp;n.includes(</span><span class="s2">&quot;v&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.IncompatibleRegExpUVFlags,{at:o()}),n.includes(c)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.DuplicateRegExpFlags,{at:o()});</span><span class="s1">else if</span><span class="s0">(De(u)||u===</span><span class="s3">92</span><span class="s0">)</span><span class="s1">this</span><span class="s0">.raise(f.MalformedRegExpFlags,{at:o()});</span><span class="s1">else break</span><span class="s0">;++i,n+=c}</span><span class="s1">this</span><span class="s0">.state.pos=i,</span><span class="s1">this</span><span class="s0">.finishToken(</span><span class="s3">135</span><span class="s0">,{pattern:a,flags:n})}readInt(t,r){let e=arguments.length&gt;</span><span class="s3">2</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">2</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">2</span><span class="s0">]:!</span><span class="s3">1</span><span class="s0">,s=arguments.length&gt;</span><span class="s3">3</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">3</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">3</span><span class="s0">]:!</span><span class="s3">0</span><span class="s0">,{n:i,pos:a}=Fr(</span><span class="s1">this</span><span class="s0">.input,</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">this</span><span class="s0">.state.lineStart,</span><span class="s1">this</span><span class="s0">.state.curLine,t,r,e,s,</span><span class="s1">this</span><span class="s0">.errorHandlers_readInt,!</span><span class="s3">1</span><span class="s0">);</span><span class="s1">return this</span><span class="s0">.state.pos=a,i}readRadixNumber(t){let r=</span><span class="s1">this</span><span class="s0">.state.curPosition(),e=!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.state.pos+=</span><span class="s3">2</span><span class="s0">;let s=</span><span class="s1">this</span><span class="s0">.readInt(t);s==</span><span class="s1">null</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.InvalidDigit,{at:Y(r,</span><span class="s3">2</span><span class="s0">),radix:t});let i=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos);</span><span class="s1">if</span><span class="s0">(i===</span><span class="s3">110</span><span class="s0">)++</span><span class="s1">this</span><span class="s0">.state.pos,e=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">else if</span><span class="s0">(i===</span><span class="s3">109</span><span class="s0">)</span><span class="s1">throw this</span><span class="s0">.raise(f.InvalidDecimal,{at:r});</span><span class="s1">if</span><span class="s0">(fe(</span><span class="s1">this</span><span class="s0">.codePointAtPos(</span><span class="s1">this</span><span class="s0">.state.pos)))</span><span class="s1">throw this</span><span class="s0">.raise(f.NumberIdentifier,{at:</span><span class="s1">this</span><span class="s0">.state.curPosition()});</span><span class="s1">if</span><span class="s0">(e){let a=</span><span class="s1">this</span><span class="s0">.input.slice(r.index,</span><span class="s1">this</span><span class="s0">.state.pos).replace(/[_n]/g,</span><span class="s2">&quot;&quot;</span><span class="s0">);</span><span class="s1">this</span><span class="s0">.finishToken(</span><span class="s3">133</span><span class="s0">,a);</span><span class="s1">return</span><span class="s0">}</span><span class="s1">this</span><span class="s0">.finishToken(</span><span class="s3">132</span><span class="s0">,s)}readNumber(t){let r=</span><span class="s1">this</span><span class="s0">.state.pos,e=</span><span class="s1">this</span><span class="s0">.state.curPosition(),s=!</span><span class="s3">1</span><span class="s0">,i=!</span><span class="s3">1</span><span class="s0">,a=!</span><span class="s3">1</span><span class="s0">,n=!</span><span class="s3">1</span><span class="s0">,o=!</span><span class="s3">1</span><span class="s0">;!t&amp;&amp;</span><span class="s1">this</span><span class="s0">.readInt(</span><span class="s3">10</span><span class="s0">)===</span><span class="s1">null</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.InvalidNumber,{at:</span><span class="s1">this</span><span class="s0">.state.curPosition()});let u=</span><span class="s1">this</span><span class="s0">.state.pos-r&gt;=</span><span class="s3">2</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.input.charCodeAt(r)===</span><span class="s3">48</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(u){let T=</span><span class="s1">this</span><span class="s0">.input.slice(r,</span><span class="s1">this</span><span class="s0">.state.pos);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.recordStrictModeErrors(f.StrictOctalLiteral,{at:e}),!</span><span class="s1">this</span><span class="s0">.state.strict){let C=T.indexOf(</span><span class="s2">&quot;_&quot;</span><span class="s0">);C&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.ZeroDigitNumericSeparator,{at:Y(e,C)})}o=u&amp;&amp;!/[</span><span class="s3">89</span><span class="s0">]/.test(T)}let c=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos);</span><span class="s1">if</span><span class="s0">(c===</span><span class="s3">46</span><span class="s0">&amp;&amp;!o&amp;&amp;(++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">this</span><span class="s0">.readInt(</span><span class="s3">10</span><span class="s0">),s=!</span><span class="s3">0</span><span class="s0">,c=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos)),(c===</span><span class="s3">69</span><span class="s0">||c===</span><span class="s3">101</span><span class="s0">)&amp;&amp;!o&amp;&amp;(c=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(++</span><span class="s1">this</span><span class="s0">.state.pos),(c===</span><span class="s3">43</span><span class="s0">||c===</span><span class="s3">45</span><span class="s0">)&amp;&amp;++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">this</span><span class="s0">.readInt(</span><span class="s3">10</span><span class="s0">)===</span><span class="s1">null</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.InvalidOrMissingExponent,{at:e}),s=!</span><span class="s3">0</span><span class="s0">,n=!</span><span class="s3">0</span><span class="s0">,c=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos)),c===</span><span class="s3">110</span><span class="s0">&amp;&amp;((s||u)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.InvalidBigIntLiteral,{at:e}),++</span><span class="s1">this</span><span class="s0">.state.pos,i=!</span><span class="s3">0</span><span class="s0">),c===</span><span class="s3">109</span><span class="s0">&amp;&amp;(</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s2">&quot;decimal&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.state.curPosition()),(n||u)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.InvalidDecimal,{at:e}),++</span><span class="s1">this</span><span class="s0">.state.pos,a=!</span><span class="s3">0</span><span class="s0">),fe(</span><span class="s1">this</span><span class="s0">.codePointAtPos(</span><span class="s1">this</span><span class="s0">.state.pos)))</span><span class="s1">throw this</span><span class="s0">.raise(f.NumberIdentifier,{at:</span><span class="s1">this</span><span class="s0">.state.curPosition()});let y=</span><span class="s1">this</span><span class="s0">.input.slice(r,</span><span class="s1">this</span><span class="s0">.state.pos).replace(/[_mn]/g,</span><span class="s2">&quot;&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(i){</span><span class="s1">this</span><span class="s0">.finishToken(</span><span class="s3">133</span><span class="s0">,y);</span><span class="s1">return</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(a){</span><span class="s1">this</span><span class="s0">.finishToken(</span><span class="s3">134</span><span class="s0">,y);</span><span class="s1">return</span><span class="s0">}let g=o?parseInt(y,</span><span class="s3">8</span><span class="s0">):parseFloat(y);</span><span class="s1">this</span><span class="s0">.finishToken(</span><span class="s3">132</span><span class="s0">,g)}readCodePoint(t){let{code:r,pos:e}=Lr(</span><span class="s1">this</span><span class="s0">.input,</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">this</span><span class="s0">.state.lineStart,</span><span class="s1">this</span><span class="s0">.state.curLine,t,</span><span class="s1">this</span><span class="s0">.errorHandlers_readCodePoint);</span><span class="s1">return this</span><span class="s0">.state.pos=e,r}readString(t){let{str:r,pos:e,curLine:s,lineStart:i}=Dr(t===</span><span class="s3">34</span><span class="s0">?</span><span class="s2">&quot;double&quot;</span><span class="s0">:</span><span class="s2">&quot;single&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.input,</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.state.lineStart,</span><span class="s1">this</span><span class="s0">.state.curLine,</span><span class="s1">this</span><span class="s0">.errorHandlers_readStringContents_string);</span><span class="s1">this</span><span class="s0">.state.pos=e+</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.state.lineStart=i,</span><span class="s1">this</span><span class="s0">.state.curLine=s,</span><span class="s1">this</span><span class="s0">.finishToken(</span><span class="s3">131</span><span class="s0">,r)}readTemplateContinuation(){</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">8</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.unexpected(</span><span class="s1">null</span><span class="s0">,</span><span class="s3">8</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.state.pos--,</span><span class="s1">this</span><span class="s0">.readTemplateToken()}readTemplateToken(){let t=</span><span class="s1">this</span><span class="s0">.input[</span><span class="s1">this</span><span class="s0">.state.pos],{str:r,firstInvalidLoc:e,pos:s,curLine:i,lineStart:a}=Dr(</span><span class="s2">&quot;template&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.input,</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.state.lineStart,</span><span class="s1">this</span><span class="s0">.state.curLine,</span><span class="s1">this</span><span class="s0">.errorHandlers_readStringContents_template);</span><span class="s1">this</span><span class="s0">.state.pos=s+</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.state.lineStart=a,</span><span class="s1">this</span><span class="s0">.state.curLine=i,e&amp;&amp;(</span><span class="s1">this</span><span class="s0">.state.firstInvalidTemplateEscapePos=</span><span class="s1">new </span><span class="s0">ge(e.curLine,e.pos-e.lineStart,e.pos)),</span><span class="s1">this</span><span class="s0">.input.codePointAt(s)===</span><span class="s3">96</span><span class="s0">?</span><span class="s1">this</span><span class="s0">.finishToken(</span><span class="s3">24</span><span class="s0">,e?</span><span class="s1">null</span><span class="s0">:t+r+</span><span class="s2">&quot;`&quot;</span><span class="s0">):(</span><span class="s1">this</span><span class="s0">.state.pos++,</span><span class="s1">this</span><span class="s0">.finishToken(</span><span class="s3">25</span><span class="s0">,e?</span><span class="s1">null</span><span class="s0">:t+r+</span><span class="s2">&quot;${&quot;</span><span class="s0">))}recordStrictModeErrors(t,r){let{at:e}=r,s=e.index;</span><span class="s1">this</span><span class="s0">.state.strict&amp;&amp;!</span><span class="s1">this</span><span class="s0">.state.strictErrors.has(s)?</span><span class="s1">this</span><span class="s0">.raise(t,{at:e}):</span><span class="s1">this</span><span class="s0">.state.strictErrors.set(s,[t,e])}readWord1(t){</span><span class="s1">this</span><span class="s0">.state.containsEsc=!</span><span class="s3">1</span><span class="s0">;let r=</span><span class="s2">&quot;&quot;</span><span class="s0">,e=</span><span class="s1">this</span><span class="s0">.state.pos,s=</span><span class="s1">this</span><span class="s0">.state.pos;</span><span class="s1">for</span><span class="s0">(t!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">&amp;&amp;(</span><span class="s1">this</span><span class="s0">.state.pos+=t&lt;=</span><span class="s3">65535</span><span class="s0">?</span><span class="s3">1</span><span class="s0">:</span><span class="s3">2</span><span class="s0">);</span><span class="s1">this</span><span class="s0">.state.pos&lt;</span><span class="s1">this</span><span class="s0">.length;){let i=</span><span class="s1">this</span><span class="s0">.codePointAtPos(</span><span class="s1">this</span><span class="s0">.state.pos);</span><span class="s1">if</span><span class="s0">(De(i))</span><span class="s1">this</span><span class="s0">.state.pos+=i&lt;=</span><span class="s3">65535</span><span class="s0">?</span><span class="s3">1</span><span class="s0">:</span><span class="s3">2</span><span class="s0">;</span><span class="s1">else if</span><span class="s0">(i===</span><span class="s3">92</span><span class="s0">){</span><span class="s1">this</span><span class="s0">.state.containsEsc=!</span><span class="s3">0</span><span class="s0">,r+=</span><span class="s1">this</span><span class="s0">.input.slice(s,</span><span class="s1">this</span><span class="s0">.state.pos);let a=</span><span class="s1">this</span><span class="s0">.state.curPosition(),n=</span><span class="s1">this</span><span class="s0">.state.pos===e?fe:De;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.input.charCodeAt(++</span><span class="s1">this</span><span class="s0">.state.pos)!==</span><span class="s3">117</span><span class="s0">){</span><span class="s1">this</span><span class="s0">.raise(f.MissingUnicodeEscape,{at:</span><span class="s1">this</span><span class="s0">.state.curPosition()}),s=</span><span class="s1">this</span><span class="s0">.state.pos-1;</span><span class="s1">continue</span><span class="s0">}++</span><span class="s1">this</span><span class="s0">.state.pos;let o=</span><span class="s1">this</span><span class="s0">.readCodePoint(!</span><span class="s3">0</span><span class="s0">);o!==</span><span class="s1">null</span><span class="s0">&amp;&amp;(n(o)||</span><span class="s1">this</span><span class="s0">.raise(f.EscapedCharNotAnIdentifier,{at:a}),r+=String.fromCodePoint(o)),s=</span><span class="s1">this</span><span class="s0">.state.pos}</span><span class="s1">else break</span><span class="s0">}</span><span class="s1">return </span><span class="s0">r+</span><span class="s1">this</span><span class="s0">.input.slice(s,</span><span class="s1">this</span><span class="s0">.state.pos)}readWord(t){let r=</span><span class="s1">this</span><span class="s0">.readWord1(t),e=L.get(r);e!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?</span><span class="s1">this</span><span class="s0">.finishToken(e,xe(e)):</span><span class="s1">this</span><span class="s0">.finishToken(</span><span class="s3">130</span><span class="s0">,r)}checkKeywordEscapes(){let{type:t}=</span><span class="s1">this</span><span class="s0">.state;$t(t)&amp;&amp;</span><span class="s1">this</span><span class="s0">.state.containsEsc&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.InvalidEscapedReservedWord,{at:</span><span class="s1">this</span><span class="s0">.state.startLoc,reservedWord:xe(t)})}raise(t,r){let{at:e}=r,s=ot(r,Fl),i=e </span><span class="s1">instanceof </span><span class="s0">ge?e:e.loc.start,a=t({loc:i,details:s});</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.options.errorRecovery)</span><span class="s1">throw </span><span class="s0">a;</span><span class="s1">return this</span><span class="s0">.isLookahead||</span><span class="s1">this</span><span class="s0">.state.errors.push(a),a}raiseOverwrite(t,r){let{at:e}=r,s=ot(r,Ll),i=e </span><span class="s1">instanceof </span><span class="s0">ge?e:e.loc.start,a=i.index,n=</span><span class="s1">this</span><span class="s0">.state.errors;</span><span class="s1">for</span><span class="s0">(let o=n.length-1;o&gt;=</span><span class="s3">0</span><span class="s0">;o--){let u=n[o];</span><span class="s1">if</span><span class="s0">(u.loc.index===a)</span><span class="s1">return </span><span class="s0">n[o]=t({loc:i,details:s});</span><span class="s1">if</span><span class="s0">(u.loc.index&lt;a)</span><span class="s1">break</span><span class="s0">}</span><span class="s1">return this</span><span class="s0">.raise(t,r)}updateContext(t){}unexpected(t,r){</span><span class="s1">throw this</span><span class="s0">.raise(f.UnexpectedToken,{expected:r?xe(r):</span><span class="s1">null</span><span class="s0">,at:t!=</span><span class="s1">null</span><span class="s0">?t:</span><span class="s1">this</span><span class="s0">.state.startLoc})}expectPlugin(t,r){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.hasPlugin(t))</span><span class="s1">return</span><span class="s0">!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">throw this</span><span class="s0">.raise(f.MissingPlugin,{at:r!=</span><span class="s1">null</span><span class="s0">?r:</span><span class="s1">this</span><span class="s0">.state.startLoc,missingPlugin:[t]})}expectOnePlugin(t){</span><span class="s1">if</span><span class="s0">(!t.some(r=&gt;</span><span class="s1">this</span><span class="s0">.hasPlugin(r)))</span><span class="s1">throw this</span><span class="s0">.raise(f.MissingOneOfPlugins,{at:</span><span class="s1">this</span><span class="s0">.state.startLoc,missingPlugin:t})}errorBuilder(t){</span><span class="s1">return</span><span class="s0">(r,e,s)=&gt;{</span><span class="s1">this</span><span class="s0">.raise(t,{at:Je(r,e,s)})}}},Ml=class{constructor(){</span><span class="s1">this</span><span class="s0">.privateNames=</span><span class="s1">new </span><span class="s0">Set,</span><span class="s1">this</span><span class="s0">.loneAccessors=</span><span class="s1">new </span><span class="s0">Map,</span><span class="s1">this</span><span class="s0">.undefinedPrivateNames=</span><span class="s1">new </span><span class="s0">Map}},_l=class{constructor(t){</span><span class="s1">this</span><span class="s0">.parser=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.stack=[],</span><span class="s1">this</span><span class="s0">.undefinedPrivateNames=</span><span class="s1">new </span><span class="s0">Map,</span><span class="s1">this</span><span class="s0">.parser=t}current(){</span><span class="s1">return this</span><span class="s0">.stack[</span><span class="s1">this</span><span class="s0">.stack.length-1]}enter(){</span><span class="s1">this</span><span class="s0">.stack.push(</span><span class="s1">new </span><span class="s0">Ml)}exit(){let t=</span><span class="s1">this</span><span class="s0">.stack.pop(),r=</span><span class="s1">this</span><span class="s0">.current();</span><span class="s1">for</span><span class="s0">(let[e,s]of Array.from(t.undefinedPrivateNames))r?r.undefinedPrivateNames.has(e)||r.undefinedPrivateNames.set(e,s):</span><span class="s1">this</span><span class="s0">.parser.raise(f.InvalidPrivateFieldResolution,{at:s,identifierName:e})}declarePrivateName(t,r,e){let{privateNames:s,loneAccessors:i,undefinedPrivateNames:a}=</span><span class="s1">this</span><span class="s0">.current(),n=s.has(t);</span><span class="s1">if</span><span class="s0">(r&amp;ts){let o=n&amp;&amp;i.get(t);</span><span class="s1">if</span><span class="s0">(o){let u=o&amp;yt,c=r&amp;yt,y=o&amp;ts,g=r&amp;ts;n=y===g||u!==c,n||i.</span><span class="s1">delete</span><span class="s0">(t)}</span><span class="s1">else </span><span class="s0">n||i.set(t,r)}n&amp;&amp;</span><span class="s1">this</span><span class="s0">.parser.raise(f.PrivateNameRedeclaration,{at:e,identifierName:t}),s.add(t),a.</span><span class="s1">delete</span><span class="s0">(t)}usePrivateName(t,r){let e;</span><span class="s1">for</span><span class="s0">(e of </span><span class="s1">this</span><span class="s0">.stack)</span><span class="s1">if</span><span class="s0">(e.privateNames.has(t))</span><span class="s1">return</span><span class="s0">;e?e.undefinedPrivateNames.set(t,r):</span><span class="s1">this</span><span class="s0">.parser.raise(f.InvalidPrivateFieldResolution,{at:r,identifierName:t})}},Rl=</span><span class="s3">0</span><span class="s0">,Or=</span><span class="s3">1</span><span class="s0">,ls=</span><span class="s3">2</span><span class="s0">,Br=</span><span class="s3">3</span><span class="s0">,Pt=class{constructor(){let t=arguments.length&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">0</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">0</span><span class="s0">]:Rl;</span><span class="s1">this</span><span class="s0">.type=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.type=t}canBeArrowParameterDeclaration(){</span><span class="s1">return this</span><span class="s0">.type===ls||</span><span class="s1">this</span><span class="s0">.type===Or}isCertainlyParameterDeclaration(){</span><span class="s1">return this</span><span class="s0">.type===Br}},Mr=class extends Pt{constructor(t){super(t),</span><span class="s1">this</span><span class="s0">.declarationErrors=</span><span class="s1">new </span><span class="s0">Map}recordDeclarationError(t,r){let{at:e}=r,s=e.index;</span><span class="s1">this</span><span class="s0">.declarationErrors.set(s,[t,e])}clearDeclarationError(t){</span><span class="s1">this</span><span class="s0">.declarationErrors.</span><span class="s1">delete</span><span class="s0">(t)}iterateErrors(t){</span><span class="s1">this</span><span class="s0">.declarationErrors.forEach(t)}},jl=class{constructor(t){</span><span class="s1">this</span><span class="s0">.parser=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.stack=[</span><span class="s1">new </span><span class="s0">Pt],</span><span class="s1">this</span><span class="s0">.parser=t}enter(t){</span><span class="s1">this</span><span class="s0">.stack.push(t)}exit(){</span><span class="s1">this</span><span class="s0">.stack.pop()}recordParameterInitializerError(t,r){let{at:e}=r,s={at:e.loc.start},{stack:i}=</span><span class="s1">this</span><span class="s0">,a=i.length-1,n=i[a];</span><span class="s1">for</span><span class="s0">(;!n.isCertainlyParameterDeclaration();){</span><span class="s1">if</span><span class="s0">(n.canBeArrowParameterDeclaration())n.recordDeclarationError(t,s);</span><span class="s1">else return</span><span class="s0">;n=i[--a]}</span><span class="s1">this</span><span class="s0">.parser.raise(t,s)}recordArrowParameterBindingError(t,r){let{at:e}=r,{stack:s}=</span><span class="s1">this</span><span class="s0">,i=s[s.length-1],a={at:e.loc.start};</span><span class="s1">if</span><span class="s0">(i.isCertainlyParameterDeclaration())</span><span class="s1">this</span><span class="s0">.parser.raise(t,a);</span><span class="s1">else if</span><span class="s0">(i.canBeArrowParameterDeclaration())i.recordDeclarationError(t,a);</span><span class="s1">else return</span><span class="s0">}recordAsyncArrowParametersError(t){let{at:r}=t,{stack:e}=</span><span class="s1">this</span><span class="s0">,s=e.length-1,i=e[s];</span><span class="s1">for</span><span class="s0">(;i.canBeArrowParameterDeclaration();)i.type===ls&amp;&amp;i.recordDeclarationError(f.AwaitBindingIdentifier,{at:r}),i=e[--s]}validateAsPattern(){let{stack:t}=</span><span class="s1">this</span><span class="s0">,r=t[t.length-1];r.canBeArrowParameterDeclaration()&amp;&amp;r.iterateErrors(e=&gt;{let[s,i]=e;</span><span class="s1">this</span><span class="s0">.parser.raise(s,{at:i});let a=t.length-2,n=t[a];</span><span class="s1">for</span><span class="s0">(;n.canBeArrowParameterDeclaration();)n.clearDeclarationError(i.index),n=t[--a]})}};</span><span class="s1">function </span><span class="s0">ql(){</span><span class="s1">return new </span><span class="s0">Pt(Br)}</span><span class="s1">function </span><span class="s0">Ul(){</span><span class="s1">return new </span><span class="s0">Mr(Or)}</span><span class="s1">function </span><span class="s0">$l(){</span><span class="s1">return new </span><span class="s0">Mr(ls)}</span><span class="s1">function </span><span class="s0">_r(){</span><span class="s1">return new </span><span class="s0">Pt}</span><span class="s1">var </span><span class="s0">Me=</span><span class="s3">0</span><span class="s0">,Rr=</span><span class="s3">1</span><span class="s0">,At=</span><span class="s3">2</span><span class="s0">,jr=</span><span class="s3">4</span><span class="s0">,_e=</span><span class="s3">8</span><span class="s0">,Hl=class{constructor(){</span><span class="s1">this</span><span class="s0">.stacks=[]}enter(t){</span><span class="s1">this</span><span class="s0">.stacks.push(t)}exit(){</span><span class="s1">this</span><span class="s0">.stacks.pop()}currentFlags(){</span><span class="s1">return this</span><span class="s0">.stacks[</span><span class="s1">this</span><span class="s0">.stacks.length-1]}get hasAwait(){</span><span class="s1">return</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.currentFlags()&amp;At)&gt;</span><span class="s3">0</span><span class="s0">}get hasYield(){</span><span class="s1">return</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.currentFlags()&amp;Rr)&gt;</span><span class="s3">0</span><span class="s0">}get hasReturn(){</span><span class="s1">return</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.currentFlags()&amp;jr)&gt;</span><span class="s3">0</span><span class="s0">}get hasIn(){</span><span class="s1">return</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.currentFlags()&amp;_e)&gt;</span><span class="s3">0</span><span class="s0">}};</span><span class="s1">function </span><span class="s0">Tt(t,r){</span><span class="s1">return</span><span class="s0">(t?At:</span><span class="s3">0</span><span class="s0">)|(r?Rr:</span><span class="s3">0</span><span class="s0">)}</span><span class="s1">var </span><span class="s0">zl=class extends Bl{addExtra(t,r,e){let s=arguments.length&gt;</span><span class="s3">3</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">3</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">3</span><span class="s0">]:!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(!t)</span><span class="s1">return</span><span class="s0">;let i=t.extra=t.extra||{};s?i[r]=e:Object.defineProperty(i,r,{enumerable:s,value:e})}isContextual(t){</span><span class="s1">return this</span><span class="s0">.state.type===t&amp;&amp;!</span><span class="s1">this</span><span class="s0">.state.containsEsc}isUnparsedContextual(t,r){let e=t+r.length;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.input.slice(t,e)===r){let s=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(e);</span><span class="s1">return</span><span class="s0">!(De(s)||(s&amp;</span><span class="s3">64512</span><span class="s0">)===</span><span class="s3">55296</span><span class="s0">)}</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">}isLookaheadContextual(t){let r=</span><span class="s1">this</span><span class="s0">.nextTokenStart();</span><span class="s1">return this</span><span class="s0">.isUnparsedContextual(r,t)}eatContextual(t){</span><span class="s1">return this</span><span class="s0">.isContextual(t)?(</span><span class="s1">this</span><span class="s0">.next(),!</span><span class="s3">0</span><span class="s0">):!</span><span class="s3">1</span><span class="s0">}expectContextual(t,r){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.eatContextual(t)){</span><span class="s1">if</span><span class="s0">(r!=</span><span class="s1">null</span><span class="s0">)</span><span class="s1">throw this</span><span class="s0">.raise(r,{at:</span><span class="s1">this</span><span class="s0">.state.startLoc});</span><span class="s1">this</span><span class="s0">.unexpected(</span><span class="s1">null</span><span class="s0">,t)}}canInsertSemicolon(){</span><span class="s1">return this</span><span class="s0">.match(</span><span class="s3">137</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">8</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.hasPrecedingLineBreak()}hasPrecedingLineBreak(){</span><span class="s1">return </span><span class="s0">as.test(</span><span class="s1">this</span><span class="s0">.input.slice(</span><span class="s1">this</span><span class="s0">.state.lastTokEndLoc.index,</span><span class="s1">this</span><span class="s0">.state.start))}hasFollowingLineBreak(){</span><span class="s1">return </span><span class="s0">Ir.lastIndex=</span><span class="s1">this</span><span class="s0">.state.end,Ir.test(</span><span class="s1">this</span><span class="s0">.input)}isLineTerminator(){</span><span class="s1">return this</span><span class="s0">.eat(</span><span class="s3">13</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.canInsertSemicolon()}semicolon(){((arguments.length&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">0</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">0</span><span class="s0">]:!</span><span class="s3">0</span><span class="s0">)?</span><span class="s1">this</span><span class="s0">.isLineTerminator():</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">13</span><span class="s0">))||</span><span class="s1">this</span><span class="s0">.raise(f.MissingSemicolon,{at:</span><span class="s1">this</span><span class="s0">.state.lastTokEndLoc})}expect(t,r){</span><span class="s1">this</span><span class="s0">.eat(t)||</span><span class="s1">this</span><span class="s0">.unexpected(r,t)}tryParse(t){let r=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">1</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">1</span><span class="s0">]:</span><span class="s1">this</span><span class="s0">.state.clone(),e={node:</span><span class="s1">null</span><span class="s0">};</span><span class="s1">try</span><span class="s0">{let s=t(</span><span class="s1">function</span><span class="s0">(){let i=arguments.length&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">0</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">0</span><span class="s0">]:</span><span class="s1">null</span><span class="s0">;</span><span class="s1">throw </span><span class="s0">e.node=i,e});</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.errors.length&gt;r.errors.length){let i=</span><span class="s1">this</span><span class="s0">.state;</span><span class="s1">return this</span><span class="s0">.state=r,</span><span class="s1">this</span><span class="s0">.state.tokensLength=i.tokensLength,{node:s,error:i.errors[r.errors.length],thrown:!</span><span class="s3">1</span><span class="s0">,aborted:!</span><span class="s3">1</span><span class="s0">,failState:i}}</span><span class="s1">return</span><span class="s0">{node:s,error:</span><span class="s1">null</span><span class="s0">,thrown:!</span><span class="s3">1</span><span class="s0">,aborted:!</span><span class="s3">1</span><span class="s0">,failState:</span><span class="s1">null</span><span class="s0">}}</span><span class="s1">catch</span><span class="s0">(s){let i=</span><span class="s1">this</span><span class="s0">.state;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state=r,s </span><span class="s1">instanceof </span><span class="s0">SyntaxError)</span><span class="s1">return</span><span class="s0">{node:</span><span class="s1">null</span><span class="s0">,error:s,thrown:!</span><span class="s3">0</span><span class="s0">,aborted:!</span><span class="s3">1</span><span class="s0">,failState:i};</span><span class="s1">if</span><span class="s0">(s===e)</span><span class="s1">return</span><span class="s0">{node:e.node,error:</span><span class="s1">null</span><span class="s0">,thrown:!</span><span class="s3">1</span><span class="s0">,aborted:!</span><span class="s3">0</span><span class="s0">,failState:i};</span><span class="s1">throw </span><span class="s0">s}}checkExpressionErrors(t,r){</span><span class="s1">if</span><span class="s0">(!t)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;let{shorthandAssignLoc:e,doubleProtoLoc:s,privateKeyLoc:i,optionalParametersLoc:a}=t,n=!!e||!!s||!!a||!!i;</span><span class="s1">if</span><span class="s0">(!r)</span><span class="s1">return </span><span class="s0">n;e!=</span><span class="s1">null</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.InvalidCoverInitializedName,{at:e}),s!=</span><span class="s1">null</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.DuplicateProto,{at:s}),i!=</span><span class="s1">null</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.UnexpectedPrivateField,{at:i}),a!=</span><span class="s1">null</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(a)}isLiteralPropertyName(){</span><span class="s1">return </span><span class="s0">it(</span><span class="s1">this</span><span class="s0">.state.type)}isPrivateName(t){</span><span class="s1">return </span><span class="s0">t.type===</span><span class="s2">&quot;PrivateName&quot;</span><span class="s0">}getPrivateNameSV(t){</span><span class="s1">return </span><span class="s0">t.id.name}hasPropertyAsPrivateName(t){</span><span class="s1">return</span><span class="s0">(t.type===</span><span class="s2">&quot;MemberExpression&quot;</span><span class="s0">||t.type===</span><span class="s2">&quot;OptionalMemberExpression&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.isPrivateName(t.property)}isObjectProperty(t){</span><span class="s1">return </span><span class="s0">t.type===</span><span class="s2">&quot;ObjectProperty&quot;</span><span class="s0">}isObjectMethod(t){</span><span class="s1">return </span><span class="s0">t.type===</span><span class="s2">&quot;ObjectMethod&quot;</span><span class="s0">}initializeScopes(){let t=arguments.length&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">0</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">0</span><span class="s0">]:</span><span class="s1">this</span><span class="s0">.options.sourceType===</span><span class="s2">&quot;module&quot;</span><span class="s0">,r=</span><span class="s1">this</span><span class="s0">.state.labels;</span><span class="s1">this</span><span class="s0">.state.labels=[];let e=</span><span class="s1">this</span><span class="s0">.exportedIdentifiers;</span><span class="s1">this</span><span class="s0">.exportedIdentifiers=</span><span class="s1">new </span><span class="s0">Set;let s=</span><span class="s1">this</span><span class="s0">.inModule;</span><span class="s1">this</span><span class="s0">.inModule=t;let i=</span><span class="s1">this</span><span class="s0">.scope,a=</span><span class="s1">this</span><span class="s0">.getScopeHandler();</span><span class="s1">this</span><span class="s0">.scope=</span><span class="s1">new </span><span class="s0">a(</span><span class="s1">this</span><span class="s0">,t);let n=</span><span class="s1">this</span><span class="s0">.prodParam;</span><span class="s1">this</span><span class="s0">.prodParam=</span><span class="s1">new </span><span class="s0">Hl;let o=</span><span class="s1">this</span><span class="s0">.classScope;</span><span class="s1">this</span><span class="s0">.classScope=</span><span class="s1">new </span><span class="s0">_l(</span><span class="s1">this</span><span class="s0">);let u=</span><span class="s1">this</span><span class="s0">.expressionScope;</span><span class="s1">return this</span><span class="s0">.expressionScope=</span><span class="s1">new </span><span class="s0">jl(</span><span class="s1">this</span><span class="s0">),()=&gt;{</span><span class="s1">this</span><span class="s0">.state.labels=r,</span><span class="s1">this</span><span class="s0">.exportedIdentifiers=e,</span><span class="s1">this</span><span class="s0">.inModule=s,</span><span class="s1">this</span><span class="s0">.scope=i,</span><span class="s1">this</span><span class="s0">.prodParam=n,</span><span class="s1">this</span><span class="s0">.classScope=o,</span><span class="s1">this</span><span class="s0">.expressionScope=u}}enterInitialScopes(){let t=Me;</span><span class="s1">this</span><span class="s0">.inModule&amp;&amp;(t|=At),</span><span class="s1">this</span><span class="s0">.scope.enter(Le),</span><span class="s1">this</span><span class="s0">.prodParam.enter(t)}checkDestructuringPrivate(t){let{privateKeyLoc:r}=t;r!==</span><span class="s1">null</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s2">&quot;destructuringPrivate&quot;</span><span class="s0">,r)}},vt=class{constructor(){</span><span class="s1">this</span><span class="s0">.shorthandAssignLoc=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.doubleProtoLoc=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.privateKeyLoc=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.optionalParametersLoc=</span><span class="s1">null</span><span class="s0">}},Et=class{constructor(t,r,e){</span><span class="s1">this</span><span class="s0">.type=</span><span class="s2">&quot;&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.start=r,</span><span class="s1">this</span><span class="s0">.end=</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.loc=</span><span class="s1">new </span><span class="s0">lt(e),t!=</span><span class="s1">null</span><span class="s0">&amp;&amp;t.options.ranges&amp;&amp;(</span><span class="s1">this</span><span class="s0">.range=[r,</span><span class="s3">0</span><span class="s0">]),t!=</span><span class="s1">null</span><span class="s0">&amp;&amp;t.filename&amp;&amp;(</span><span class="s1">this</span><span class="s0">.loc.filename=t.filename)}},hs=Et.prototype;hs.__clone=</span><span class="s1">function</span><span class="s0">(){let t=</span><span class="s1">new </span><span class="s0">Et(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.start,</span><span class="s1">this</span><span class="s0">.loc.start),r=Object.keys(</span><span class="s1">this</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(let e=</span><span class="s3">0</span><span class="s0">,s=r.length;e&lt;s;e++){let i=r[e];i!==</span><span class="s2">&quot;leadingComments&quot;</span><span class="s0">&amp;&amp;i!==</span><span class="s2">&quot;trailingComments&quot;</span><span class="s0">&amp;&amp;i!==</span><span class="s2">&quot;innerComments&quot;</span><span class="s0">&amp;&amp;(t[i]=</span><span class="s1">this</span><span class="s0">[i])}</span><span class="s1">return </span><span class="s0">t};</span><span class="s1">function </span><span class="s0">Vl(t){</span><span class="s1">return </span><span class="s0">me(t)}</span><span class="s1">function </span><span class="s0">me(t){let{type:r,start:e,end:s,loc:i,range:a,extra:n,name:o}=t,u=Object.create(hs);</span><span class="s1">return </span><span class="s0">u.type=r,u.start=e,u.end=s,u.loc=i,u.range=a,u.extra=n,u.name=o,r===</span><span class="s2">&quot;Placeholder&quot;</span><span class="s0">&amp;&amp;(u.expectedNode=t.expectedNode),u}</span><span class="s1">function </span><span class="s0">Kl(t){let{type:r,start:e,end:s,loc:i,range:a,extra:n}=t;</span><span class="s1">if</span><span class="s0">(r===</span><span class="s2">&quot;Placeholder&quot;</span><span class="s0">)</span><span class="s1">return </span><span class="s0">Vl(t);let o=Object.create(hs);</span><span class="s1">return </span><span class="s0">o.type=r,o.start=e,o.end=s,o.loc=i,o.range=a,t.raw!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?o.raw=t.raw:o.extra=n,o.value=t.value,o}</span><span class="s1">var </span><span class="s0">Wl=class extends zl{startNode(){</span><span class="s1">return new </span><span class="s0">Et(</span><span class="s1">this</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.state.start,</span><span class="s1">this</span><span class="s0">.state.startLoc)}startNodeAt(t){</span><span class="s1">return new </span><span class="s0">Et(</span><span class="s1">this</span><span class="s0">,t.index,t)}startNodeAtNode(t){</span><span class="s1">return this</span><span class="s0">.startNodeAt(t.loc.start)}finishNode(t,r){</span><span class="s1">return this</span><span class="s0">.finishNodeAt(t,r,</span><span class="s1">this</span><span class="s0">.state.lastTokEndLoc)}finishNodeAt(t,r,e){</span><span class="s1">return </span><span class="s0">t.type=r,t.end=e.index,t.loc.end=e,</span><span class="s1">this</span><span class="s0">.options.ranges&amp;&amp;(t.range[</span><span class="s3">1</span><span class="s0">]=e.index),</span><span class="s1">this</span><span class="s0">.options.attachComment&amp;&amp;</span><span class="s1">this</span><span class="s0">.processComment(t),t}resetStartLocation(t,r){t.start=r.index,t.loc.start=r,</span><span class="s1">this</span><span class="s0">.options.ranges&amp;&amp;(t.range[</span><span class="s3">0</span><span class="s0">]=r.index)}resetEndLocation(t){let r=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">1</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">1</span><span class="s0">]:</span><span class="s1">this</span><span class="s0">.state.lastTokEndLoc;t.end=r.index,t.loc.end=r,</span><span class="s1">this</span><span class="s0">.options.ranges&amp;&amp;(t.range[</span><span class="s3">1</span><span class="s0">]=r.index)}resetStartLocationFromNode(t,r){</span><span class="s1">this</span><span class="s0">.resetStartLocation(t,r.loc.start)}},Gl=</span><span class="s1">new </span><span class="s0">Set([</span><span class="s2">&quot;_&quot;</span><span class="s0">,</span><span class="s2">&quot;any&quot;</span><span class="s0">,</span><span class="s2">&quot;bool&quot;</span><span class="s0">,</span><span class="s2">&quot;boolean&quot;</span><span class="s0">,</span><span class="s2">&quot;empty&quot;</span><span class="s0">,</span><span class="s2">&quot;extends&quot;</span><span class="s0">,</span><span class="s2">&quot;false&quot;</span><span class="s0">,</span><span class="s2">&quot;interface&quot;</span><span class="s0">,</span><span class="s2">&quot;mixed&quot;</span><span class="s0">,</span><span class="s2">&quot;null&quot;</span><span class="s0">,</span><span class="s2">&quot;number&quot;</span><span class="s0">,</span><span class="s2">&quot;static&quot;</span><span class="s0">,</span><span class="s2">&quot;string&quot;</span><span class="s0">,</span><span class="s2">&quot;true&quot;</span><span class="s0">,</span><span class="s2">&quot;typeof&quot;</span><span class="s0">,</span><span class="s2">&quot;void&quot;</span><span class="s0">]),D=pe`flow`({AmbiguousConditionalArrow:</span><span class="s2">&quot;Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.&quot;</span><span class="s0">,AmbiguousDeclareModuleKind:</span><span class="s2">&quot;Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.&quot;</span><span class="s0">,AssignReservedType:t=&gt;{let{reservedType:r}=t;</span><span class="s1">return</span><span class="s0">`Cannot overwrite reserved type ${r}.`},DeclareClassElement:</span><span class="s2">&quot;The `declare` modifier can only appear on class fields.&quot;</span><span class="s0">,DeclareClassFieldInitializer:</span><span class="s2">&quot;Initializers are not allowed in fields with the `declare` modifier.&quot;</span><span class="s0">,DuplicateDeclareModuleExports:</span><span class="s2">&quot;Duplicate `declare module.exports` statement.&quot;</span><span class="s0">,EnumBooleanMemberNotInitialized:t=&gt;{let{memberName:r,enumName:e}=t;</span><span class="s1">return</span><span class="s0">`Boolean enum members need to be initialized. Use either \`${r} = </span><span class="s1">true</span><span class="s0">,\` or \`${r} = </span><span class="s1">false</span><span class="s0">,\` </span><span class="s1">in </span><span class="s0">enum \`${e}\`.`},EnumDuplicateMemberName:t=&gt;{let{memberName:r,enumName:e}=t;</span><span class="s1">return</span><span class="s0">`Enum member names need to be unique, but the name \`${r}\` has already been used before </span><span class="s1">in </span><span class="s0">enum \`${e}\`.`},EnumInconsistentMemberValues:t=&gt;{let{enumName:r}=t;</span><span class="s1">return</span><span class="s0">`Enum \`${r}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) </span><span class="s1">for </span><span class="s0">all member initializers.`},EnumInvalidExplicitType:t=&gt;{let{invalidEnumType:r,enumName:e}=t;</span><span class="s1">return</span><span class="s0">`Enum type \`${r}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` </span><span class="s1">in </span><span class="s0">enum \`${e}\`.`},EnumInvalidExplicitTypeUnknownSupplied:t=&gt;{let{enumName:r}=t;</span><span class="s1">return</span><span class="s0">`Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` </span><span class="s1">in </span><span class="s0">enum \`${r}\`.`},EnumInvalidMemberInitializerPrimaryType:t=&gt;{let{enumName:r,memberName:e,explicitType:s}=t;</span><span class="s1">return</span><span class="s0">`Enum \`${r}\` has type \`${s}\`, so the initializer of \`${e}\` needs to be a ${s} literal.`},EnumInvalidMemberInitializerSymbolType:t=&gt;{let{enumName:r,memberName:e}=t;</span><span class="s1">return</span><span class="s0">`Symbol enum members cannot be initialized. Use \`${e},\` </span><span class="s1">in </span><span class="s0">enum \`${r}\`.`},EnumInvalidMemberInitializerUnknownType:t=&gt;{let{enumName:r,memberName:e}=t;</span><span class="s1">return</span><span class="s0">`The enum member initializer </span><span class="s1">for </span><span class="s0">\`${e}\` needs to be a literal (either a boolean, number, or string) </span><span class="s1">in </span><span class="s0">enum \`${r}\`.`},EnumInvalidMemberName:t=&gt;{let{enumName:r,memberName:e,suggestion:s}=t;</span><span class="s1">return</span><span class="s0">`Enum member names cannot start </span><span class="s1">with </span><span class="s0">lowercase </span><span class="s2">'a' </span><span class="s0">through </span><span class="s2">'z'</span><span class="s0">. Instead of using \`${e}\`, consider using \`${s}\`, </span><span class="s1">in </span><span class="s0">enum \`${r}\`.`},EnumNumberMemberNotInitialized:t=&gt;{let{enumName:r,memberName:e}=t;</span><span class="s1">return</span><span class="s0">`Number enum members need to be initialized, e.g. \`${e} = </span><span class="s3">1</span><span class="s0">\` </span><span class="s1">in </span><span class="s0">enum \`${r}\`.`},EnumStringMemberInconsistentlyInitailized:t=&gt;{let{enumName:r}=t;</span><span class="s1">return</span><span class="s0">`String enum members need to consistently either all use initializers, or use no initializers, </span><span class="s1">in </span><span class="s0">enum \`${r}\`.`},GetterMayNotHaveThisParam:</span><span class="s2">&quot;A getter cannot have a `this` parameter.&quot;</span><span class="s0">,ImportReflectionHasImportType:</span><span class="s2">&quot;An `import module` declaration can not use `type` or `typeof` keyword.&quot;</span><span class="s0">,ImportTypeShorthandOnlyInPureImport:</span><span class="s2">&quot;The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.&quot;</span><span class="s0">,InexactInsideExact:</span><span class="s2">&quot;Explicit inexact syntax cannot appear inside an explicit exact object type.&quot;</span><span class="s0">,InexactInsideNonObject:</span><span class="s2">&quot;Explicit inexact syntax cannot appear in class or interface definitions.&quot;</span><span class="s0">,InexactVariance:</span><span class="s2">&quot;Explicit inexact syntax cannot have variance.&quot;</span><span class="s0">,InvalidNonTypeImportInDeclareModule:</span><span class="s2">&quot;Imports within a `declare module` body must always be `import type` or `import typeof`.&quot;</span><span class="s0">,MissingTypeParamDefault:</span><span class="s2">&quot;Type parameter declaration needs a default, since a preceding type parameter declaration has a default.&quot;</span><span class="s0">,NestedDeclareModule:</span><span class="s2">&quot;`declare module` cannot be used inside another `declare module`.&quot;</span><span class="s0">,NestedFlowComment:</span><span class="s2">&quot;Cannot have a flow comment inside another flow comment.&quot;</span><span class="s0">,PatternIsOptional:Object.assign({message:</span><span class="s2">&quot;A binding pattern parameter cannot be optional in an implementation signature.&quot;</span><span class="s0">},{reasonCode:</span><span class="s2">&quot;OptionalBindingPattern&quot;</span><span class="s0">}),SetterMayNotHaveThisParam:</span><span class="s2">&quot;A setter cannot have a `this` parameter.&quot;</span><span class="s0">,SpreadVariance:</span><span class="s2">&quot;Spread properties cannot have variance.&quot;</span><span class="s0">,ThisParamAnnotationRequired:</span><span class="s2">&quot;A type annotation is required for the `this` parameter.&quot;</span><span class="s0">,ThisParamBannedInConstructor:</span><span class="s2">&quot;Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.&quot;</span><span class="s0">,ThisParamMayNotBeOptional:</span><span class="s2">&quot;The `this` parameter cannot be optional.&quot;</span><span class="s0">,ThisParamMustBeFirst:</span><span class="s2">&quot;The `this` parameter must be the first function parameter.&quot;</span><span class="s0">,ThisParamNoDefault:</span><span class="s2">&quot;The `this` parameter may not have a default value.&quot;</span><span class="s0">,TypeBeforeInitializer:</span><span class="s2">&quot;Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.&quot;</span><span class="s0">,TypeCastInPattern:</span><span class="s2">&quot;The type cast expression is expected to be wrapped with parenthesis.&quot;</span><span class="s0">,UnexpectedExplicitInexactInObject:</span><span class="s2">&quot;Explicit inexact syntax must appear at the end of an inexact object.&quot;</span><span class="s0">,UnexpectedReservedType:t=&gt;{let{reservedType:r}=t;</span><span class="s1">return</span><span class="s0">`Unexpected reserved type ${r}.`},UnexpectedReservedUnderscore:</span><span class="s2">&quot;`_` is only allowed as a type argument to call or new.&quot;</span><span class="s0">,UnexpectedSpaceBetweenModuloChecks:</span><span class="s2">&quot;Spaces between `%` and `checks` are not allowed here.&quot;</span><span class="s0">,UnexpectedSpreadType:</span><span class="s2">&quot;Spread operator cannot appear in class or interface definitions.&quot;</span><span class="s0">,UnexpectedSubtractionOperand:</span><span class="s2">'Unexpected token, expected &quot;number&quot; or &quot;bigint&quot;.'</span><span class="s0">,UnexpectedTokenAfterTypeParameter:</span><span class="s2">&quot;Expected an arrow function after this type parameter declaration.&quot;</span><span class="s0">,UnexpectedTypeParameterBeforeAsyncArrowFunction:</span><span class="s2">&quot;Type parameters must come after the async keyword, e.g. instead of `&lt;T&gt; async () =&gt; {}`, use `async &lt;T&gt;() =&gt; {}`.&quot;</span><span class="s0">,UnsupportedDeclareExportKind:t=&gt;{let{unsupportedExportKind:r,suggestion:e}=t;</span><span class="s1">return</span><span class="s0">`\`declare export ${r}\` is not supported. Use \`${e}\` instead.`},UnsupportedStatementInDeclareModule:</span><span class="s2">&quot;Only declares and type imports are allowed inside declare module.&quot;</span><span class="s0">,UnterminatedFlowComment:</span><span class="s2">&quot;Unterminated flow-comment.&quot;</span><span class="s0">});</span><span class="s1">function </span><span class="s0">Jl(t){</span><span class="s1">return </span><span class="s0">t.type===</span><span class="s2">&quot;DeclareExportAllDeclaration&quot;</span><span class="s0">||t.type===</span><span class="s2">&quot;DeclareExportDeclaration&quot;</span><span class="s0">&amp;&amp;(!t.declaration||t.declaration.type!==</span><span class="s2">&quot;TypeAlias&quot;</span><span class="s0">&amp;&amp;t.declaration.type!==</span><span class="s2">&quot;InterfaceDeclaration&quot;</span><span class="s0">)}</span><span class="s1">function </span><span class="s0">us(t){</span><span class="s1">return </span><span class="s0">t.importKind===</span><span class="s2">&quot;type&quot;</span><span class="s0">||t.importKind===</span><span class="s2">&quot;typeof&quot;</span><span class="s0">}</span><span class="s1">function </span><span class="s0">qr(t){</span><span class="s1">return </span><span class="s0">te(t)&amp;&amp;t!==</span><span class="s3">97</span><span class="s0">}</span><span class="s1">var </span><span class="s0">Xl={const:</span><span class="s2">&quot;declare export var&quot;</span><span class="s0">,let:</span><span class="s2">&quot;declare export var&quot;</span><span class="s0">,type:</span><span class="s2">&quot;export type&quot;</span><span class="s0">,interface:</span><span class="s2">&quot;export interface&quot;</span><span class="s0">};</span><span class="s1">function </span><span class="s0">Yl(t,r){let e=[],s=[];</span><span class="s1">for</span><span class="s0">(let i=</span><span class="s3">0</span><span class="s0">;i&lt;t.length;i++)(r(t[i],i,t)?e:s).push(t[i]);</span><span class="s1">return</span><span class="s0">[e,s]}</span><span class="s1">var </span><span class="s0">Ql=/\*?\s*@((?:no)?flow)\b/,Zl=t=&gt;class extends t{constructor(){super(...arguments),</span><span class="s1">this</span><span class="s0">.flowPragma=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">}getScopeHandler(){</span><span class="s1">return </span><span class="s0">El}shouldParseTypes(){</span><span class="s1">return this</span><span class="s0">.getPluginOption(</span><span class="s2">&quot;flow&quot;</span><span class="s0">,</span><span class="s2">&quot;all&quot;</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.flowPragma===</span><span class="s2">&quot;flow&quot;</span><span class="s0">}shouldParseEnums(){</span><span class="s1">return</span><span class="s0">!!</span><span class="s1">this</span><span class="s0">.getPluginOption(</span><span class="s2">&quot;flow&quot;</span><span class="s0">,</span><span class="s2">&quot;enums&quot;</span><span class="s0">)}finishToken(e,s){e!==</span><span class="s3">131</span><span class="s0">&amp;&amp;e!==</span><span class="s3">13</span><span class="s0">&amp;&amp;e!==</span><span class="s3">28</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.flowPragma===</span><span class="s1">void </span><span class="s3">0</span><span class="s0">&amp;&amp;(</span><span class="s1">this</span><span class="s0">.flowPragma=</span><span class="s1">null</span><span class="s0">),super.finishToken(e,s)}addComment(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.flowPragma===</span><span class="s1">void </span><span class="s3">0</span><span class="s0">){let s=Ql.exec(e.value);</span><span class="s1">if</span><span class="s0">(s)</span><span class="s1">if</span><span class="s0">(s[</span><span class="s3">1</span><span class="s0">]===</span><span class="s2">&quot;flow&quot;</span><span class="s0">)</span><span class="s1">this</span><span class="s0">.flowPragma=</span><span class="s2">&quot;flow&quot;</span><span class="s0">;</span><span class="s1">else if</span><span class="s0">(s[</span><span class="s3">1</span><span class="s0">]===</span><span class="s2">&quot;noflow&quot;</span><span class="s0">)</span><span class="s1">this</span><span class="s0">.flowPragma=</span><span class="s2">&quot;noflow&quot;</span><span class="s0">;</span><span class="s1">else throw new </span><span class="s0">Error(</span><span class="s2">&quot;Unexpected flow pragma&quot;</span><span class="s0">)}super.addComment(e)}flowParseTypeInitialiser(e){let s=</span><span class="s1">this</span><span class="s0">.state.inType;</span><span class="s1">this</span><span class="s0">.state.inType=!</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.expect(e||</span><span class="s3">14</span><span class="s0">);let i=</span><span class="s1">this</span><span class="s0">.flowParseType();</span><span class="s1">return this</span><span class="s0">.state.inType=s,i}flowParsePredicate(){let e=</span><span class="s1">this</span><span class="s0">.startNode(),s=</span><span class="s1">this</span><span class="s0">.state.startLoc;</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.expectContextual(</span><span class="s3">108</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.state.lastTokStart&gt;s.index+</span><span class="s3">1</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(D.UnexpectedSpaceBetweenModuloChecks,{at:s}),</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">10</span><span class="s0">)?(e.value=super.parseExpression(),</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">11</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;DeclaredPredicate&quot;</span><span class="s0">)):</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;InferredPredicate&quot;</span><span class="s0">)}flowParseTypeAndPredicateInitialiser(){let e=</span><span class="s1">this</span><span class="s0">.state.inType;</span><span class="s1">this</span><span class="s0">.state.inType=!</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">14</span><span class="s0">);let s=</span><span class="s1">null</span><span class="s0">,i=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">return this</span><span class="s0">.match(</span><span class="s3">54</span><span class="s0">)?(</span><span class="s1">this</span><span class="s0">.state.inType=e,i=</span><span class="s1">this</span><span class="s0">.flowParsePredicate()):(s=</span><span class="s1">this</span><span class="s0">.flowParseType(),</span><span class="s1">this</span><span class="s0">.state.inType=e,</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">54</span><span class="s0">)&amp;&amp;(i=</span><span class="s1">this</span><span class="s0">.flowParsePredicate())),[s,i]}flowParseDeclareClass(e){</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.flowParseInterfaceish(e,!</span><span class="s3">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;DeclareClass&quot;</span><span class="s0">)}flowParseDeclareFunction(e){</span><span class="s1">this</span><span class="s0">.next();let s=e.id=</span><span class="s1">this</span><span class="s0">.parseIdentifier(),i=</span><span class="s1">this</span><span class="s0">.startNode(),a=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">47</span><span class="s0">)?i.typeParameters=</span><span class="s1">this</span><span class="s0">.flowParseTypeParameterDeclaration():i.typeParameters=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">10</span><span class="s0">);let n=</span><span class="s1">this</span><span class="s0">.flowParseFunctionTypeParams();</span><span class="s1">return </span><span class="s0">i.params=n.params,i.rest=n.rest,i.</span><span class="s1">this</span><span class="s0">=n._this,</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">11</span><span class="s0">),[i.returnType,e.predicate]=</span><span class="s1">this</span><span class="s0">.flowParseTypeAndPredicateInitialiser(),a.typeAnnotation=</span><span class="s1">this</span><span class="s0">.finishNode(i,</span><span class="s2">&quot;FunctionTypeAnnotation&quot;</span><span class="s0">),s.typeAnnotation=</span><span class="s1">this</span><span class="s0">.finishNode(a,</span><span class="s2">&quot;TypeAnnotation&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.resetEndLocation(s),</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.scope.declareName(e.id.name,xl,e.id.loc.start),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;DeclareFunction&quot;</span><span class="s0">)}flowParseDeclare(e,s){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">80</span><span class="s0">))</span><span class="s1">return this</span><span class="s0">.flowParseDeclareClass(e);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">68</span><span class="s0">))</span><span class="s1">return this</span><span class="s0">.flowParseDeclareFunction(e);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">74</span><span class="s0">))</span><span class="s1">return this</span><span class="s0">.flowParseDeclareVariable(e);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eatContextual(</span><span class="s3">125</span><span class="s0">))</span><span class="s1">return this</span><span class="s0">.match(</span><span class="s3">16</span><span class="s0">)?</span><span class="s1">this</span><span class="s0">.flowParseDeclareModuleExports(e):(s&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(D.NestedDeclareModule,{at:</span><span class="s1">this</span><span class="s0">.state.lastTokStartLoc}),</span><span class="s1">this</span><span class="s0">.flowParseDeclareModule(e));</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">128</span><span class="s0">))</span><span class="s1">return this</span><span class="s0">.flowParseDeclareTypeAlias(e);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">129</span><span class="s0">))</span><span class="s1">return this</span><span class="s0">.flowParseDeclareOpaqueType(e);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">127</span><span class="s0">))</span><span class="s1">return this</span><span class="s0">.flowParseDeclareInterface(e);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">82</span><span class="s0">))</span><span class="s1">return this</span><span class="s0">.flowParseDeclareExportDeclaration(e,s);</span><span class="s1">this</span><span class="s0">.unexpected()}flowParseDeclareVariable(e){</span><span class="s1">return this</span><span class="s0">.next(),e.id=</span><span class="s1">this</span><span class="s0">.flowParseTypeAnnotatableIdentifier(!</span><span class="s3">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.scope.declareName(e.id.name,mt,e.id.loc.start),</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;DeclareVariable&quot;</span><span class="s0">)}flowParseDeclareModule(e){</span><span class="s1">this</span><span class="s0">.scope.enter(Fe),</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">131</span><span class="s0">)?e.id=super.parseExprAtom():e.id=</span><span class="s1">this</span><span class="s0">.parseIdentifier();let s=e.body=</span><span class="s1">this</span><span class="s0">.startNode(),i=s.body=[];</span><span class="s1">for</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">5</span><span class="s0">);!</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">8</span><span class="s0">);){let o=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">83</span><span class="s0">)?(</span><span class="s1">this</span><span class="s0">.next(),!</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">128</span><span class="s0">)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">87</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(D.InvalidNonTypeImportInDeclareModule,{at:</span><span class="s1">this</span><span class="s0">.state.lastTokStartLoc}),super.parseImport(o)):(</span><span class="s1">this</span><span class="s0">.expectContextual(</span><span class="s3">123</span><span class="s0">,D.UnsupportedStatementInDeclareModule),o=</span><span class="s1">this</span><span class="s0">.flowParseDeclare(o,!</span><span class="s3">0</span><span class="s0">)),i.push(o)}</span><span class="s1">this</span><span class="s0">.scope.exit(),</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">8</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(s,</span><span class="s2">&quot;BlockStatement&quot;</span><span class="s0">);let a=</span><span class="s1">null</span><span class="s0">,n=!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">return </span><span class="s0">i.forEach(o=&gt;{Jl(o)?(a===</span><span class="s2">&quot;CommonJS&quot;</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(D.AmbiguousDeclareModuleKind,{at:o}),a=</span><span class="s2">&quot;ES&quot;</span><span class="s0">):o.type===</span><span class="s2">&quot;DeclareModuleExports&quot;</span><span class="s0">&amp;&amp;(n&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(D.DuplicateDeclareModuleExports,{at:o}),a===</span><span class="s2">&quot;ES&quot;</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(D.AmbiguousDeclareModuleKind,{at:o}),a=</span><span class="s2">&quot;CommonJS&quot;</span><span class="s0">,n=!</span><span class="s3">0</span><span class="s0">)}),e.kind=a||</span><span class="s2">&quot;CommonJS&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;DeclareModule&quot;</span><span class="s0">)}flowParseDeclareExportDeclaration(e,s){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">82</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">65</span><span class="s0">))</span><span class="s1">return this</span><span class="s0">.match(</span><span class="s3">68</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">80</span><span class="s0">)?e.declaration=</span><span class="s1">this</span><span class="s0">.flowParseDeclare(</span><span class="s1">this</span><span class="s0">.startNode()):(e.declaration=</span><span class="s1">this</span><span class="s0">.flowParseType(),</span><span class="s1">this</span><span class="s0">.semicolon()),e.</span><span class="s1">default</span><span class="s0">=!</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;DeclareExportDeclaration&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">75</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.isLet()||(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">128</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">127</span><span class="s0">))&amp;&amp;!s){let i=</span><span class="s1">this</span><span class="s0">.state.value;</span><span class="s1">throw this</span><span class="s0">.raise(D.UnsupportedDeclareExportKind,{at:</span><span class="s1">this</span><span class="s0">.state.startLoc,unsupportedExportKind:i,suggestion:Xl[i]})}</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">74</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">68</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">80</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">129</span><span class="s0">))</span><span class="s1">return </span><span class="s0">e.declaration=</span><span class="s1">this</span><span class="s0">.flowParseDeclare(</span><span class="s1">this</span><span class="s0">.startNode()),e.</span><span class="s1">default</span><span class="s0">=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;DeclareExportDeclaration&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">55</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">5</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">127</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">128</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">129</span><span class="s0">))</span><span class="s1">return </span><span class="s0">e=</span><span class="s1">this</span><span class="s0">.parseExport(e,</span><span class="s1">null</span><span class="s0">),e.type===</span><span class="s2">&quot;ExportNamedDeclaration&quot;</span><span class="s0">&amp;&amp;(e.type=</span><span class="s2">&quot;ExportDeclaration&quot;</span><span class="s0">,e.</span><span class="s1">default</span><span class="s0">=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">delete </span><span class="s0">e.exportKind),e.type=</span><span class="s2">&quot;Declare&quot;</span><span class="s0">+e.type,e;</span><span class="s1">this</span><span class="s0">.unexpected()}flowParseDeclareModuleExports(e){</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.expectContextual(</span><span class="s3">109</span><span class="s0">),e.typeAnnotation=</span><span class="s1">this</span><span class="s0">.flowParseTypeAnnotation(),</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;DeclareModuleExports&quot;</span><span class="s0">)}flowParseDeclareTypeAlias(e){</span><span class="s1">this</span><span class="s0">.next();let s=</span><span class="s1">this</span><span class="s0">.flowParseTypeAlias(e);</span><span class="s1">return </span><span class="s0">s.type=</span><span class="s2">&quot;DeclareTypeAlias&quot;</span><span class="s0">,s}flowParseDeclareOpaqueType(e){</span><span class="s1">this</span><span class="s0">.next();let s=</span><span class="s1">this</span><span class="s0">.flowParseOpaqueType(e,!</span><span class="s3">0</span><span class="s0">);</span><span class="s1">return </span><span class="s0">s.type=</span><span class="s2">&quot;DeclareOpaqueType&quot;</span><span class="s0">,s}flowParseDeclareInterface(e){</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.flowParseInterfaceish(e,!</span><span class="s3">1</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;DeclareInterface&quot;</span><span class="s0">)}flowParseInterfaceish(e,s){</span><span class="s1">if</span><span class="s0">(e.id=</span><span class="s1">this</span><span class="s0">.flowParseRestrictedIdentifier(!s,!</span><span class="s3">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.scope.declareName(e.id.name,s?Er:Be,e.id.loc.start),</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">47</span><span class="s0">)?e.typeParameters=</span><span class="s1">this</span><span class="s0">.flowParseTypeParameterDeclaration():e.typeParameters=</span><span class="s1">null</span><span class="s0">,e.extends=[],e.implements=[],e.mixins=[],</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">81</span><span class="s0">))</span><span class="s1">do </span><span class="s0">e.extends.push(</span><span class="s1">this</span><span class="s0">.flowParseInterfaceExtends());</span><span class="s1">while</span><span class="s0">(!s&amp;&amp;</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">12</span><span class="s0">));</span><span class="s1">if</span><span class="s0">(s){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eatContextual(</span><span class="s3">115</span><span class="s0">))</span><span class="s1">do </span><span class="s0">e.mixins.push(</span><span class="s1">this</span><span class="s0">.flowParseInterfaceExtends());</span><span class="s1">while</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">12</span><span class="s0">));</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eatContextual(</span><span class="s3">111</span><span class="s0">))</span><span class="s1">do </span><span class="s0">e.implements.push(</span><span class="s1">this</span><span class="s0">.flowParseInterfaceExtends());</span><span class="s1">while</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">12</span><span class="s0">))}e.body=</span><span class="s1">this</span><span class="s0">.flowParseObjectType({allowStatic:s,allowExact:!</span><span class="s3">1</span><span class="s0">,allowSpread:!</span><span class="s3">1</span><span class="s0">,allowProto:s,allowInexact:!</span><span class="s3">1</span><span class="s0">})}flowParseInterfaceExtends(){let e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">e.id=</span><span class="s1">this</span><span class="s0">.flowParseQualifiedTypeIdentifier(),</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">47</span><span class="s0">)?e.typeParameters=</span><span class="s1">this</span><span class="s0">.flowParseTypeParameterInstantiation():e.typeParameters=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;InterfaceExtends&quot;</span><span class="s0">)}flowParseInterface(e){</span><span class="s1">return this</span><span class="s0">.flowParseInterfaceish(e,!</span><span class="s3">1</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;InterfaceDeclaration&quot;</span><span class="s0">)}checkNotUnderscore(e){e===</span><span class="s2">&quot;_&quot;</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(D.UnexpectedReservedUnderscore,{at:</span><span class="s1">this</span><span class="s0">.state.startLoc})}checkReservedType(e,s,i){Gl.has(e)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(i?D.AssignReservedType:D.UnexpectedReservedType,{at:s,reservedType:e})}flowParseRestrictedIdentifier(e,s){</span><span class="s1">return this</span><span class="s0">.checkReservedType(</span><span class="s1">this</span><span class="s0">.state.value,</span><span class="s1">this</span><span class="s0">.state.startLoc,s),</span><span class="s1">this</span><span class="s0">.parseIdentifier(e)}flowParseTypeAlias(e){</span><span class="s1">return </span><span class="s0">e.id=</span><span class="s1">this</span><span class="s0">.flowParseRestrictedIdentifier(!</span><span class="s3">1</span><span class="s0">,!</span><span class="s3">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.scope.declareName(e.id.name,Be,e.id.loc.start),</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">47</span><span class="s0">)?e.typeParameters=</span><span class="s1">this</span><span class="s0">.flowParseTypeParameterDeclaration():e.typeParameters=</span><span class="s1">null</span><span class="s0">,e.right=</span><span class="s1">this</span><span class="s0">.flowParseTypeInitialiser(</span><span class="s3">29</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;TypeAlias&quot;</span><span class="s0">)}flowParseOpaqueType(e,s){</span><span class="s1">return this</span><span class="s0">.expectContextual(</span><span class="s3">128</span><span class="s0">),e.id=</span><span class="s1">this</span><span class="s0">.flowParseRestrictedIdentifier(!</span><span class="s3">0</span><span class="s0">,!</span><span class="s3">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.scope.declareName(e.id.name,Be,e.id.loc.start),</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">47</span><span class="s0">)?e.typeParameters=</span><span class="s1">this</span><span class="s0">.flowParseTypeParameterDeclaration():e.typeParameters=</span><span class="s1">null</span><span class="s0">,e.supertype=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">14</span><span class="s0">)&amp;&amp;(e.supertype=</span><span class="s1">this</span><span class="s0">.flowParseTypeInitialiser(</span><span class="s3">14</span><span class="s0">)),e.impltype=</span><span class="s1">null</span><span class="s0">,s||(e.impltype=</span><span class="s1">this</span><span class="s0">.flowParseTypeInitialiser(</span><span class="s3">29</span><span class="s0">)),</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;OpaqueType&quot;</span><span class="s0">)}flowParseTypeParameter(){let e=arguments.length&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">0</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">0</span><span class="s0">]:!</span><span class="s3">1</span><span class="s0">,s=</span><span class="s1">this</span><span class="s0">.state.startLoc,i=</span><span class="s1">this</span><span class="s0">.startNode(),a=</span><span class="s1">this</span><span class="s0">.flowParseVariance(),n=</span><span class="s1">this</span><span class="s0">.flowParseTypeAnnotatableIdentifier();</span><span class="s1">return </span><span class="s0">i.name=n.name,i.variance=a,i.bound=n.typeAnnotation,</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">29</span><span class="s0">)?(</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">29</span><span class="s0">),i.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">this</span><span class="s0">.flowParseType()):e&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(D.MissingTypeParamDefault,{at:s}),</span><span class="s1">this</span><span class="s0">.finishNode(i,</span><span class="s2">&quot;TypeParameter&quot;</span><span class="s0">)}flowParseTypeParameterDeclaration(){let e=</span><span class="s1">this</span><span class="s0">.state.inType,s=</span><span class="s1">this</span><span class="s0">.startNode();s.params=[],</span><span class="s1">this</span><span class="s0">.state.inType=!</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">47</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">140</span><span class="s0">)?</span><span class="s1">this</span><span class="s0">.next():</span><span class="s1">this</span><span class="s0">.unexpected();let i=!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">do</span><span class="s0">{let a=</span><span class="s1">this</span><span class="s0">.flowParseTypeParameter(i);s.params.push(a),a.</span><span class="s1">default</span><span class="s0">&amp;&amp;(i=!</span><span class="s3">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">48</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">12</span><span class="s0">)}</span><span class="s1">while</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">48</span><span class="s0">));</span><span class="s1">return this</span><span class="s0">.expect(</span><span class="s3">48</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.state.inType=e,</span><span class="s1">this</span><span class="s0">.finishNode(s,</span><span class="s2">&quot;TypeParameterDeclaration&quot;</span><span class="s0">)}flowParseTypeParameterInstantiation(){let e=</span><span class="s1">this</span><span class="s0">.startNode(),s=</span><span class="s1">this</span><span class="s0">.state.inType;e.params=[],</span><span class="s1">this</span><span class="s0">.state.inType=!</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">47</span><span class="s0">);let i=</span><span class="s1">this</span><span class="s0">.state.noAnonFunctionType;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.noAnonFunctionType=!</span><span class="s3">1</span><span class="s0">;!</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">48</span><span class="s0">);)e.params.push(</span><span class="s1">this</span><span class="s0">.flowParseType()),</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">48</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">12</span><span class="s0">);</span><span class="s1">return this</span><span class="s0">.state.noAnonFunctionType=i,</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">48</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.state.inType=s,</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;TypeParameterInstantiation&quot;</span><span class="s0">)}flowParseTypeParameterInstantiationCallOrNew(){let e=</span><span class="s1">this</span><span class="s0">.startNode(),s=</span><span class="s1">this</span><span class="s0">.state.inType;</span><span class="s1">for</span><span class="s0">(e.params=[],</span><span class="s1">this</span><span class="s0">.state.inType=!</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">47</span><span class="s0">);!</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">48</span><span class="s0">);)e.params.push(</span><span class="s1">this</span><span class="s0">.flowParseTypeOrImplicitInstantiation()),</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">48</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">12</span><span class="s0">);</span><span class="s1">return this</span><span class="s0">.expect(</span><span class="s3">48</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.state.inType=s,</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;TypeParameterInstantiation&quot;</span><span class="s0">)}flowParseInterfaceType(){let e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.expectContextual(</span><span class="s3">127</span><span class="s0">),e.extends=[],</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">81</span><span class="s0">))</span><span class="s1">do </span><span class="s0">e.extends.push(</span><span class="s1">this</span><span class="s0">.flowParseInterfaceExtends());</span><span class="s1">while</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">12</span><span class="s0">));</span><span class="s1">return </span><span class="s0">e.body=</span><span class="s1">this</span><span class="s0">.flowParseObjectType({allowStatic:!</span><span class="s3">1</span><span class="s0">,allowExact:!</span><span class="s3">1</span><span class="s0">,allowSpread:!</span><span class="s3">1</span><span class="s0">,allowProto:!</span><span class="s3">1</span><span class="s0">,allowInexact:!</span><span class="s3">1</span><span class="s0">}),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;InterfaceTypeAnnotation&quot;</span><span class="s0">)}flowParseObjectPropertyKey(){</span><span class="s1">return this</span><span class="s0">.match(</span><span class="s3">132</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">131</span><span class="s0">)?super.parseExprAtom():</span><span class="s1">this</span><span class="s0">.parseIdentifier(!</span><span class="s3">0</span><span class="s0">)}flowParseObjectTypeIndexer(e,s,i){</span><span class="s1">return </span><span class="s0">e.static=s,</span><span class="s1">this</span><span class="s0">.lookahead().type===</span><span class="s3">14</span><span class="s0">?(e.id=</span><span class="s1">this</span><span class="s0">.flowParseObjectPropertyKey(),e.key=</span><span class="s1">this</span><span class="s0">.flowParseTypeInitialiser()):(e.id=</span><span class="s1">null</span><span class="s0">,e.key=</span><span class="s1">this</span><span class="s0">.flowParseType()),</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">3</span><span class="s0">),e.value=</span><span class="s1">this</span><span class="s0">.flowParseTypeInitialiser(),e.variance=i,</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;ObjectTypeIndexer&quot;</span><span class="s0">)}flowParseObjectTypeInternalSlot(e,s){</span><span class="s1">return </span><span class="s0">e.static=s,e.id=</span><span class="s1">this</span><span class="s0">.flowParseObjectPropertyKey(),</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">3</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">3</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">47</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">10</span><span class="s0">)?(e.method=!</span><span class="s3">0</span><span class="s0">,e.optional=!</span><span class="s3">1</span><span class="s0">,e.value=</span><span class="s1">this</span><span class="s0">.flowParseObjectTypeMethodish(</span><span class="s1">this</span><span class="s0">.startNodeAt(e.loc.start))):(e.method=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">17</span><span class="s0">)&amp;&amp;(e.optional=!</span><span class="s3">0</span><span class="s0">),e.value=</span><span class="s1">this</span><span class="s0">.flowParseTypeInitialiser()),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;ObjectTypeInternalSlot&quot;</span><span class="s0">)}flowParseObjectTypeMethodish(e){</span><span class="s1">for</span><span class="s0">(e.params=[],e.rest=</span><span class="s1">null</span><span class="s0">,e.typeParameters=</span><span class="s1">null</span><span class="s0">,e.</span><span class="s1">this</span><span class="s0">=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">47</span><span class="s0">)&amp;&amp;(e.typeParameters=</span><span class="s1">this</span><span class="s0">.flowParseTypeParameterDeclaration()),</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">10</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">78</span><span class="s0">)&amp;&amp;(e.</span><span class="s1">this</span><span class="s0">=</span><span class="s1">this</span><span class="s0">.flowParseFunctionTypeParam(!</span><span class="s3">0</span><span class="s0">),e.</span><span class="s1">this</span><span class="s0">.name=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">11</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">12</span><span class="s0">));!</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">11</span><span class="s0">)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">21</span><span class="s0">);)e.params.push(</span><span class="s1">this</span><span class="s0">.flowParseFunctionTypeParam(!</span><span class="s3">1</span><span class="s0">)),</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">11</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">12</span><span class="s0">);</span><span class="s1">return this</span><span class="s0">.eat(</span><span class="s3">21</span><span class="s0">)&amp;&amp;(e.rest=</span><span class="s1">this</span><span class="s0">.flowParseFunctionTypeParam(!</span><span class="s3">1</span><span class="s0">)),</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">11</span><span class="s0">),e.returnType=</span><span class="s1">this</span><span class="s0">.flowParseTypeInitialiser(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;FunctionTypeAnnotation&quot;</span><span class="s0">)}flowParseObjectTypeCallProperty(e,s){let i=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">e.static=s,e.value=</span><span class="s1">this</span><span class="s0">.flowParseObjectTypeMethodish(i),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;ObjectTypeCallProperty&quot;</span><span class="s0">)}flowParseObjectType(e){let{allowStatic:s,allowExact:i,allowSpread:a,allowProto:n,allowInexact:o}=e,u=</span><span class="s1">this</span><span class="s0">.state.inType;</span><span class="s1">this</span><span class="s0">.state.inType=!</span><span class="s3">0</span><span class="s0">;let c=</span><span class="s1">this</span><span class="s0">.startNode();c.callProperties=[],c.properties=[],c.indexers=[],c.internalSlots=[];let y,g,T=!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(i&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">6</span><span class="s0">)?(</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">6</span><span class="s0">),y=</span><span class="s3">9</span><span class="s0">,g=!</span><span class="s3">0</span><span class="s0">):(</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">5</span><span class="s0">),y=</span><span class="s3">8</span><span class="s0">,g=!</span><span class="s3">1</span><span class="s0">),c.exact=g;!</span><span class="s1">this</span><span class="s0">.match(y);){let M=!</span><span class="s3">1</span><span class="s0">,j=</span><span class="s1">null</span><span class="s0">,K=</span><span class="s1">null</span><span class="s0">,W=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">if</span><span class="s0">(n&amp;&amp;</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">116</span><span class="s0">)){let X=</span><span class="s1">this</span><span class="s0">.lookahead();X.type!==</span><span class="s3">14</span><span class="s0">&amp;&amp;X.type!==</span><span class="s3">17</span><span class="s0">&amp;&amp;(</span><span class="s1">this</span><span class="s0">.next(),j=</span><span class="s1">this</span><span class="s0">.state.startLoc,s=!</span><span class="s3">1</span><span class="s0">)}</span><span class="s1">if</span><span class="s0">(s&amp;&amp;</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">104</span><span class="s0">)){let X=</span><span class="s1">this</span><span class="s0">.lookahead();X.type!==</span><span class="s3">14</span><span class="s0">&amp;&amp;X.type!==</span><span class="s3">17</span><span class="s0">&amp;&amp;(</span><span class="s1">this</span><span class="s0">.next(),M=!</span><span class="s3">0</span><span class="s0">)}let V=</span><span class="s1">this</span><span class="s0">.flowParseVariance();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">0</span><span class="s0">))j!=</span><span class="s1">null</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(j),</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">0</span><span class="s0">)?(V&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(V.loc.start),c.internalSlots.push(</span><span class="s1">this</span><span class="s0">.flowParseObjectTypeInternalSlot(W,M))):c.indexers.push(</span><span class="s1">this</span><span class="s0">.flowParseObjectTypeIndexer(W,M,V));</span><span class="s1">else if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">10</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">47</span><span class="s0">))j!=</span><span class="s1">null</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(j),V&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(V.loc.start),c.callProperties.push(</span><span class="s1">this</span><span class="s0">.flowParseObjectTypeCallProperty(W,M));</span><span class="s1">else</span><span class="s0">{let X=</span><span class="s2">&quot;init&quot;</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">98</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">103</span><span class="s0">)){let Nh=</span><span class="s1">this</span><span class="s0">.lookahead();it(Nh.type)&amp;&amp;(X=</span><span class="s1">this</span><span class="s0">.state.value,</span><span class="s1">this</span><span class="s0">.next())}let je=</span><span class="s1">this</span><span class="s0">.flowParseObjectTypeProperty(W,M,j,V,X,a,o!=</span><span class="s1">null</span><span class="s0">?o:!g);je===</span><span class="s1">null</span><span class="s0">?(T=!</span><span class="s3">0</span><span class="s0">,K=</span><span class="s1">this</span><span class="s0">.state.lastTokStartLoc):c.properties.push(je)}</span><span class="s1">this</span><span class="s0">.flowObjectTypeSemicolon(),K&amp;&amp;!</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">8</span><span class="s0">)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">9</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(D.UnexpectedExplicitInexactInObject,{at:K})}</span><span class="s1">this</span><span class="s0">.expect(y),a&amp;&amp;(c.inexact=T);let C=</span><span class="s1">this</span><span class="s0">.finishNode(c,</span><span class="s2">&quot;ObjectTypeAnnotation&quot;</span><span class="s0">);</span><span class="s1">return this</span><span class="s0">.state.inType=u,C}flowParseObjectTypeProperty(e,s,i,a,n,o,u){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">21</span><span class="s0">))</span><span class="s1">return this</span><span class="s0">.match(</span><span class="s3">12</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">13</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">8</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">9</span><span class="s0">)?(o?u||</span><span class="s1">this</span><span class="s0">.raise(D.InexactInsideExact,{at:</span><span class="s1">this</span><span class="s0">.state.lastTokStartLoc}):</span><span class="s1">this</span><span class="s0">.raise(D.InexactInsideNonObject,{at:</span><span class="s1">this</span><span class="s0">.state.lastTokStartLoc}),a&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(D.InexactVariance,{at:a}),</span><span class="s1">null</span><span class="s0">):(o||</span><span class="s1">this</span><span class="s0">.raise(D.UnexpectedSpreadType,{at:</span><span class="s1">this</span><span class="s0">.state.lastTokStartLoc}),i!=</span><span class="s1">null</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(i),a&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(D.SpreadVariance,{at:a}),e.argument=</span><span class="s1">this</span><span class="s0">.flowParseType(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;ObjectTypeSpreadProperty&quot;</span><span class="s0">));{e.key=</span><span class="s1">this</span><span class="s0">.flowParseObjectPropertyKey(),e.static=s,e.proto=i!=</span><span class="s1">null</span><span class="s0">,e.kind=n;let c=!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">return this</span><span class="s0">.match(</span><span class="s3">47</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">10</span><span class="s0">)?(e.method=!</span><span class="s3">0</span><span class="s0">,i!=</span><span class="s1">null</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(i),a&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(a.loc.start),e.value=</span><span class="s1">this</span><span class="s0">.flowParseObjectTypeMethodish(</span><span class="s1">this</span><span class="s0">.startNodeAt(e.loc.start)),(n===</span><span class="s2">&quot;get&quot;</span><span class="s0">||n===</span><span class="s2">&quot;set&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.flowCheckGetterSetterParams(e),!o&amp;&amp;e.key.name===</span><span class="s2">&quot;constructor&quot;</span><span class="s0">&amp;&amp;e.value.</span><span class="s1">this</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(D.ThisParamBannedInConstructor,{at:e.value.</span><span class="s1">this</span><span class="s0">})):(n!==</span><span class="s2">&quot;init&quot;</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(),e.method=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">17</span><span class="s0">)&amp;&amp;(c=!</span><span class="s3">0</span><span class="s0">),e.value=</span><span class="s1">this</span><span class="s0">.flowParseTypeInitialiser(),e.variance=a),e.optional=c,</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;ObjectTypeProperty&quot;</span><span class="s0">)}}flowCheckGetterSetterParams(e){let s=e.kind===</span><span class="s2">&quot;get&quot;</span><span class="s0">?</span><span class="s3">0</span><span class="s0">:</span><span class="s3">1</span><span class="s0">,i=e.value.params.length+(e.value.rest?</span><span class="s3">1</span><span class="s0">:</span><span class="s3">0</span><span class="s0">);e.value.</span><span class="s1">this</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.kind===</span><span class="s2">&quot;get&quot;</span><span class="s0">?D.GetterMayNotHaveThisParam:D.SetterMayNotHaveThisParam,{at:e.value.</span><span class="s1">this</span><span class="s0">}),i!==s&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(e.kind===</span><span class="s2">&quot;get&quot;</span><span class="s0">?f.BadGetterArity:f.BadSetterArity,{at:e}),e.kind===</span><span class="s2">&quot;set&quot;</span><span class="s0">&amp;&amp;e.value.rest&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.BadSetterRestParameter,{at:e})}flowObjectTypeSemicolon(){!</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">13</span><span class="s0">)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">12</span><span class="s0">)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">8</span><span class="s0">)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">9</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected()}flowParseQualifiedTypeIdentifier(e,s){</span><span class="s1">var </span><span class="s0">i;(i=e)!=</span><span class="s1">null</span><span class="s0">||(e=</span><span class="s1">this</span><span class="s0">.state.startLoc);let a=s||</span><span class="s1">this</span><span class="s0">.flowParseRestrictedIdentifier(!</span><span class="s3">0</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(;</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">16</span><span class="s0">);){let n=</span><span class="s1">this</span><span class="s0">.startNodeAt(e);n.qualification=a,n.id=</span><span class="s1">this</span><span class="s0">.flowParseRestrictedIdentifier(!</span><span class="s3">0</span><span class="s0">),a=</span><span class="s1">this</span><span class="s0">.finishNode(n,</span><span class="s2">&quot;QualifiedTypeIdentifier&quot;</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">a}flowParseGenericType(e,s){let i=</span><span class="s1">this</span><span class="s0">.startNodeAt(e);</span><span class="s1">return </span><span class="s0">i.typeParameters=</span><span class="s1">null</span><span class="s0">,i.id=</span><span class="s1">this</span><span class="s0">.flowParseQualifiedTypeIdentifier(e,s),</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">47</span><span class="s0">)&amp;&amp;(i.typeParameters=</span><span class="s1">this</span><span class="s0">.flowParseTypeParameterInstantiation()),</span><span class="s1">this</span><span class="s0">.finishNode(i,</span><span class="s2">&quot;GenericTypeAnnotation&quot;</span><span class="s0">)}flowParseTypeofType(){let e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.expect(</span><span class="s3">87</span><span class="s0">),e.argument=</span><span class="s1">this</span><span class="s0">.flowParsePrimaryType(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;TypeofTypeAnnotation&quot;</span><span class="s0">)}flowParseTupleType(){let e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">for</span><span class="s0">(e.types=[],</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">0</span><span class="s0">);</span><span class="s1">this</span><span class="s0">.state.pos&lt;</span><span class="s1">this</span><span class="s0">.length&amp;&amp;!</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">3</span><span class="s0">)&amp;&amp;(e.types.push(</span><span class="s1">this</span><span class="s0">.flowParseType()),!</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">3</span><span class="s0">));)</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">12</span><span class="s0">);</span><span class="s1">return this</span><span class="s0">.expect(</span><span class="s3">3</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;TupleTypeAnnotation&quot;</span><span class="s0">)}flowParseFunctionTypeParam(e){let s=</span><span class="s1">null</span><span class="s0">,i=!</span><span class="s3">1</span><span class="s0">,a=</span><span class="s1">null</span><span class="s0">,n=</span><span class="s1">this</span><span class="s0">.startNode(),o=</span><span class="s1">this</span><span class="s0">.lookahead(),u=</span><span class="s1">this</span><span class="s0">.state.type===</span><span class="s3">78</span><span class="s0">;</span><span class="s1">return </span><span class="s0">o.type===</span><span class="s3">14</span><span class="s0">||o.type===</span><span class="s3">17</span><span class="s0">?(u&amp;&amp;!e&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(D.ThisParamMustBeFirst,{at:n}),s=</span><span class="s1">this</span><span class="s0">.parseIdentifier(u),</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">17</span><span class="s0">)&amp;&amp;(i=!</span><span class="s3">0</span><span class="s0">,u&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(D.ThisParamMayNotBeOptional,{at:n})),a=</span><span class="s1">this</span><span class="s0">.flowParseTypeInitialiser()):a=</span><span class="s1">this</span><span class="s0">.flowParseType(),n.name=s,n.optional=i,n.typeAnnotation=a,</span><span class="s1">this</span><span class="s0">.finishNode(n,</span><span class="s2">&quot;FunctionTypeParam&quot;</span><span class="s0">)}reinterpretTypeAsFunctionTypeParam(e){let s=</span><span class="s1">this</span><span class="s0">.startNodeAt(e.loc.start);</span><span class="s1">return </span><span class="s0">s.name=</span><span class="s1">null</span><span class="s0">,s.optional=!</span><span class="s3">1</span><span class="s0">,s.typeAnnotation=e,</span><span class="s1">this</span><span class="s0">.finishNode(s,</span><span class="s2">&quot;FunctionTypeParam&quot;</span><span class="s0">)}flowParseFunctionTypeParams(){let e=arguments.length&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">0</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">0</span><span class="s0">]:[],s=</span><span class="s1">null</span><span class="s0">,i=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">78</span><span class="s0">)&amp;&amp;(i=</span><span class="s1">this</span><span class="s0">.flowParseFunctionTypeParam(!</span><span class="s3">0</span><span class="s0">),i.name=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">11</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">12</span><span class="s0">));!</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">11</span><span class="s0">)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">21</span><span class="s0">);)e.push(</span><span class="s1">this</span><span class="s0">.flowParseFunctionTypeParam(!</span><span class="s3">1</span><span class="s0">)),</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">11</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">12</span><span class="s0">);</span><span class="s1">return this</span><span class="s0">.eat(</span><span class="s3">21</span><span class="s0">)&amp;&amp;(s=</span><span class="s1">this</span><span class="s0">.flowParseFunctionTypeParam(!</span><span class="s3">1</span><span class="s0">)),{params:e,rest:s,_this:i}}flowIdentToTypeAnnotation(e,s,i){</span><span class="s1">switch</span><span class="s0">(i.name){</span><span class="s1">case</span><span class="s2">&quot;any&quot;</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.finishNode(s,</span><span class="s2">&quot;AnyTypeAnnotation&quot;</span><span class="s0">);</span><span class="s1">case</span><span class="s2">&quot;bool&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;boolean&quot;</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.finishNode(s,</span><span class="s2">&quot;BooleanTypeAnnotation&quot;</span><span class="s0">);</span><span class="s1">case</span><span class="s2">&quot;mixed&quot;</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.finishNode(s,</span><span class="s2">&quot;MixedTypeAnnotation&quot;</span><span class="s0">);</span><span class="s1">case</span><span class="s2">&quot;empty&quot;</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.finishNode(s,</span><span class="s2">&quot;EmptyTypeAnnotation&quot;</span><span class="s0">);</span><span class="s1">case</span><span class="s2">&quot;number&quot;</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.finishNode(s,</span><span class="s2">&quot;NumberTypeAnnotation&quot;</span><span class="s0">);</span><span class="s1">case</span><span class="s2">&quot;string&quot;</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.finishNode(s,</span><span class="s2">&quot;StringTypeAnnotation&quot;</span><span class="s0">);</span><span class="s1">case</span><span class="s2">&quot;symbol&quot;</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.finishNode(s,</span><span class="s2">&quot;SymbolTypeAnnotation&quot;</span><span class="s0">);</span><span class="s1">default</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.checkNotUnderscore(i.name),</span><span class="s1">this</span><span class="s0">.flowParseGenericType(e,i)}}flowParsePrimaryType(){let e=</span><span class="s1">this</span><span class="s0">.state.startLoc,s=</span><span class="s1">this</span><span class="s0">.startNode(),i,a,n=!</span><span class="s3">1</span><span class="s0">,o=</span><span class="s1">this</span><span class="s0">.state.noAnonFunctionType;</span><span class="s1">switch</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.type){</span><span class="s1">case </span><span class="s3">5</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.flowParseObjectType({allowStatic:!</span><span class="s3">1</span><span class="s0">,allowExact:!</span><span class="s3">1</span><span class="s0">,allowSpread:!</span><span class="s3">0</span><span class="s0">,allowProto:!</span><span class="s3">1</span><span class="s0">,allowInexact:!</span><span class="s3">0</span><span class="s0">});</span><span class="s1">case </span><span class="s3">6</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.flowParseObjectType({allowStatic:!</span><span class="s3">1</span><span class="s0">,allowExact:!</span><span class="s3">0</span><span class="s0">,allowSpread:!</span><span class="s3">0</span><span class="s0">,allowProto:!</span><span class="s3">1</span><span class="s0">,allowInexact:!</span><span class="s3">1</span><span class="s0">});</span><span class="s1">case </span><span class="s3">0</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.state.noAnonFunctionType=!</span><span class="s3">1</span><span class="s0">,a=</span><span class="s1">this</span><span class="s0">.flowParseTupleType(),</span><span class="s1">this</span><span class="s0">.state.noAnonFunctionType=o,a;</span><span class="s1">case </span><span class="s3">47</span><span class="s0">:</span><span class="s1">return </span><span class="s0">s.typeParameters=</span><span class="s1">this</span><span class="s0">.flowParseTypeParameterDeclaration(),</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">10</span><span class="s0">),i=</span><span class="s1">this</span><span class="s0">.flowParseFunctionTypeParams(),s.params=i.params,s.rest=i.rest,s.</span><span class="s1">this</span><span class="s0">=i._this,</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">11</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">19</span><span class="s0">),s.returnType=</span><span class="s1">this</span><span class="s0">.flowParseType(),</span><span class="s1">this</span><span class="s0">.finishNode(s,</span><span class="s2">&quot;FunctionTypeAnnotation&quot;</span><span class="s0">);</span><span class="s1">case </span><span class="s3">10</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.next(),!</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">11</span><span class="s0">)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">21</span><span class="s0">))</span><span class="s1">if</span><span class="s0">(q(</span><span class="s1">this</span><span class="s0">.state.type)||</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">78</span><span class="s0">)){let u=</span><span class="s1">this</span><span class="s0">.lookahead().type;n=u!==</span><span class="s3">17</span><span class="s0">&amp;&amp;u!==</span><span class="s3">14</span><span class="s0">}</span><span class="s1">else </span><span class="s0">n=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(n){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.noAnonFunctionType=!</span><span class="s3">1</span><span class="s0">,a=</span><span class="s1">this</span><span class="s0">.flowParseType(),</span><span class="s1">this</span><span class="s0">.state.noAnonFunctionType=o,</span><span class="s1">this</span><span class="s0">.state.noAnonFunctionType||!(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">12</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">11</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.lookahead().type===</span><span class="s3">19</span><span class="s0">))</span><span class="s1">return this</span><span class="s0">.expect(</span><span class="s3">11</span><span class="s0">),a;</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">12</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">a?i=</span><span class="s1">this</span><span class="s0">.flowParseFunctionTypeParams([</span><span class="s1">this</span><span class="s0">.reinterpretTypeAsFunctionTypeParam(a)]):i=</span><span class="s1">this</span><span class="s0">.flowParseFunctionTypeParams(),s.params=i.params,s.rest=i.rest,s.</span><span class="s1">this</span><span class="s0">=i._this,</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">11</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">19</span><span class="s0">),s.returnType=</span><span class="s1">this</span><span class="s0">.flowParseType(),s.typeParameters=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.finishNode(s,</span><span class="s2">&quot;FunctionTypeAnnotation&quot;</span><span class="s0">);</span><span class="s1">case </span><span class="s3">131</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.parseLiteral(</span><span class="s1">this</span><span class="s0">.state.value,</span><span class="s2">&quot;StringLiteralTypeAnnotation&quot;</span><span class="s0">);</span><span class="s1">case </span><span class="s3">85</span><span class="s0">:</span><span class="s1">case </span><span class="s3">86</span><span class="s0">:</span><span class="s1">return </span><span class="s0">s.value=</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">85</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.finishNode(s,</span><span class="s2">&quot;BooleanLiteralTypeAnnotation&quot;</span><span class="s0">);</span><span class="s1">case </span><span class="s3">53</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.value===</span><span class="s2">&quot;-&quot;</span><span class="s0">){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">132</span><span class="s0">))</span><span class="s1">return this</span><span class="s0">.parseLiteralAtNode(-</span><span class="s1">this</span><span class="s0">.state.value,</span><span class="s2">&quot;NumberLiteralTypeAnnotation&quot;</span><span class="s0">,s);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">133</span><span class="s0">))</span><span class="s1">return this</span><span class="s0">.parseLiteralAtNode(-</span><span class="s1">this</span><span class="s0">.state.value,</span><span class="s2">&quot;BigIntLiteralTypeAnnotation&quot;</span><span class="s0">,s);</span><span class="s1">throw this</span><span class="s0">.raise(D.UnexpectedSubtractionOperand,{at:</span><span class="s1">this</span><span class="s0">.state.startLoc})}</span><span class="s1">this</span><span class="s0">.unexpected();</span><span class="s1">return</span><span class="s0">;</span><span class="s1">case </span><span class="s3">132</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.parseLiteral(</span><span class="s1">this</span><span class="s0">.state.value,</span><span class="s2">&quot;NumberLiteralTypeAnnotation&quot;</span><span class="s0">);</span><span class="s1">case </span><span class="s3">133</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.parseLiteral(</span><span class="s1">this</span><span class="s0">.state.value,</span><span class="s2">&quot;BigIntLiteralTypeAnnotation&quot;</span><span class="s0">);</span><span class="s1">case </span><span class="s3">88</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.finishNode(s,</span><span class="s2">&quot;VoidTypeAnnotation&quot;</span><span class="s0">);</span><span class="s1">case </span><span class="s3">84</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.finishNode(s,</span><span class="s2">&quot;NullLiteralTypeAnnotation&quot;</span><span class="s0">);</span><span class="s1">case </span><span class="s3">78</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.finishNode(s,</span><span class="s2">&quot;ThisTypeAnnotation&quot;</span><span class="s0">);</span><span class="s1">case </span><span class="s3">55</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.finishNode(s,</span><span class="s2">&quot;ExistsTypeAnnotation&quot;</span><span class="s0">);</span><span class="s1">case </span><span class="s3">87</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.flowParseTypeofType();</span><span class="s1">default</span><span class="s0">:</span><span class="s1">if</span><span class="s0">($t(</span><span class="s1">this</span><span class="s0">.state.type)){let u=xe(</span><span class="s1">this</span><span class="s0">.state.type);</span><span class="s1">return this</span><span class="s0">.next(),super.createIdentifier(s,u)}</span><span class="s1">else if</span><span class="s0">(q(</span><span class="s1">this</span><span class="s0">.state.type))</span><span class="s1">return this</span><span class="s0">.isContextual(</span><span class="s3">127</span><span class="s0">)?</span><span class="s1">this</span><span class="s0">.flowParseInterfaceType():</span><span class="s1">this</span><span class="s0">.flowIdentToTypeAnnotation(e,s,</span><span class="s1">this</span><span class="s0">.parseIdentifier())}</span><span class="s1">this</span><span class="s0">.unexpected()}flowParsePostfixType(){let e=</span><span class="s1">this</span><span class="s0">.state.startLoc,s=</span><span class="s1">this</span><span class="s0">.flowParsePrimaryType(),i=!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(;(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">0</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">18</span><span class="s0">))&amp;&amp;!</span><span class="s1">this</span><span class="s0">.canInsertSemicolon();){let a=</span><span class="s1">this</span><span class="s0">.startNodeAt(e),n=</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">18</span><span class="s0">);i=i||n,</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">0</span><span class="s0">),!n&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">3</span><span class="s0">)?(a.elementType=s,</span><span class="s1">this</span><span class="s0">.next(),s=</span><span class="s1">this</span><span class="s0">.finishNode(a,</span><span class="s2">&quot;ArrayTypeAnnotation&quot;</span><span class="s0">)):(a.objectType=s,a.indexType=</span><span class="s1">this</span><span class="s0">.flowParseType(),</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">3</span><span class="s0">),i?(a.optional=n,s=</span><span class="s1">this</span><span class="s0">.finishNode(a,</span><span class="s2">&quot;OptionalIndexedAccessType&quot;</span><span class="s0">)):s=</span><span class="s1">this</span><span class="s0">.finishNode(a,</span><span class="s2">&quot;IndexedAccessType&quot;</span><span class="s0">))}</span><span class="s1">return </span><span class="s0">s}flowParsePrefixType(){let e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.eat(</span><span class="s3">17</span><span class="s0">)?(e.typeAnnotation=</span><span class="s1">this</span><span class="s0">.flowParsePrefixType(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;NullableTypeAnnotation&quot;</span><span class="s0">)):</span><span class="s1">this</span><span class="s0">.flowParsePostfixType()}flowParseAnonFunctionWithoutParens(){let e=</span><span class="s1">this</span><span class="s0">.flowParsePrefixType();</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.state.noAnonFunctionType&amp;&amp;</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">19</span><span class="s0">)){let s=</span><span class="s1">this</span><span class="s0">.startNodeAt(e.loc.start);</span><span class="s1">return </span><span class="s0">s.params=[</span><span class="s1">this</span><span class="s0">.reinterpretTypeAsFunctionTypeParam(e)],s.rest=</span><span class="s1">null</span><span class="s0">,s.</span><span class="s1">this</span><span class="s0">=</span><span class="s1">null</span><span class="s0">,s.returnType=</span><span class="s1">this</span><span class="s0">.flowParseType(),s.typeParameters=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.finishNode(s,</span><span class="s2">&quot;FunctionTypeAnnotation&quot;</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">e}flowParseIntersectionType(){let e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">45</span><span class="s0">);let s=</span><span class="s1">this</span><span class="s0">.flowParseAnonFunctionWithoutParens();</span><span class="s1">for</span><span class="s0">(e.types=[s];</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">45</span><span class="s0">);)e.types.push(</span><span class="s1">this</span><span class="s0">.flowParseAnonFunctionWithoutParens());</span><span class="s1">return </span><span class="s0">e.types.length===</span><span class="s3">1</span><span class="s0">?s:</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;IntersectionTypeAnnotation&quot;</span><span class="s0">)}flowParseUnionType(){let e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">43</span><span class="s0">);let s=</span><span class="s1">this</span><span class="s0">.flowParseIntersectionType();</span><span class="s1">for</span><span class="s0">(e.types=[s];</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">43</span><span class="s0">);)e.types.push(</span><span class="s1">this</span><span class="s0">.flowParseIntersectionType());</span><span class="s1">return </span><span class="s0">e.types.length===</span><span class="s3">1</span><span class="s0">?s:</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;UnionTypeAnnotation&quot;</span><span class="s0">)}flowParseType(){let e=</span><span class="s1">this</span><span class="s0">.state.inType;</span><span class="s1">this</span><span class="s0">.state.inType=!</span><span class="s3">0</span><span class="s0">;let s=</span><span class="s1">this</span><span class="s0">.flowParseUnionType();</span><span class="s1">return this</span><span class="s0">.state.inType=e,s}flowParseTypeOrImplicitInstantiation(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.type===</span><span class="s3">130</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.state.value===</span><span class="s2">&quot;_&quot;</span><span class="s0">){let e=</span><span class="s1">this</span><span class="s0">.state.startLoc,s=</span><span class="s1">this</span><span class="s0">.parseIdentifier();</span><span class="s1">return this</span><span class="s0">.flowParseGenericType(e,s)}</span><span class="s1">else return this</span><span class="s0">.flowParseType()}flowParseTypeAnnotation(){let e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">e.typeAnnotation=</span><span class="s1">this</span><span class="s0">.flowParseTypeInitialiser(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;TypeAnnotation&quot;</span><span class="s0">)}flowParseTypeAnnotatableIdentifier(e){let s=e?</span><span class="s1">this</span><span class="s0">.parseIdentifier():</span><span class="s1">this</span><span class="s0">.flowParseRestrictedIdentifier();</span><span class="s1">return this</span><span class="s0">.match(</span><span class="s3">14</span><span class="s0">)&amp;&amp;(s.typeAnnotation=</span><span class="s1">this</span><span class="s0">.flowParseTypeAnnotation(),</span><span class="s1">this</span><span class="s0">.resetEndLocation(s)),s}typeCastToParameter(e){</span><span class="s1">return </span><span class="s0">e.expression.typeAnnotation=e.typeAnnotation,</span><span class="s1">this</span><span class="s0">.resetEndLocation(e.expression,e.typeAnnotation.loc.end),e.expression}flowParseVariance(){let e=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">return this</span><span class="s0">.match(</span><span class="s3">53</span><span class="s0">)?(e=</span><span class="s1">this</span><span class="s0">.startNode(),</span><span class="s1">this</span><span class="s0">.state.value===</span><span class="s2">&quot;+&quot;</span><span class="s0">?e.kind=</span><span class="s2">&quot;plus&quot;</span><span class="s0">:e.kind=</span><span class="s2">&quot;minus&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;Variance&quot;</span><span class="s0">)):e}parseFunctionBody(e,s){let i=arguments.length&gt;</span><span class="s3">2</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">2</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">2</span><span class="s0">]:!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(s){</span><span class="s1">this</span><span class="s0">.forwardNoArrowParamsConversionAt(e,()=&gt;super.parseFunctionBody(e,!</span><span class="s3">0</span><span class="s0">,i));</span><span class="s1">return</span><span class="s0">}super.parseFunctionBody(e,!</span><span class="s3">1</span><span class="s0">,i)}parseFunctionBodyAndFinish(e,s){let i=arguments.length&gt;</span><span class="s3">2</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">2</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">2</span><span class="s0">]:!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">14</span><span class="s0">)){let a=</span><span class="s1">this</span><span class="s0">.startNode();[a.typeAnnotation,e.predicate]=</span><span class="s1">this</span><span class="s0">.flowParseTypeAndPredicateInitialiser(),e.returnType=a.typeAnnotation?</span><span class="s1">this</span><span class="s0">.finishNode(a,</span><span class="s2">&quot;TypeAnnotation&quot;</span><span class="s0">):</span><span class="s1">null</span><span class="s0">}</span><span class="s1">return </span><span class="s0">super.parseFunctionBodyAndFinish(e,s,i)}parseStatementLike(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.strict&amp;&amp;</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">127</span><span class="s0">)){let i=</span><span class="s1">this</span><span class="s0">.lookahead();</span><span class="s1">if</span><span class="s0">(te(i.type)){let a=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.flowParseInterface(a)}}</span><span class="s1">else if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.shouldParseEnums()&amp;&amp;</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">124</span><span class="s0">)){let i=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.flowParseEnumDeclaration(i)}let s=super.parseStatementLike(e);</span><span class="s1">return this</span><span class="s0">.flowPragma===</span><span class="s1">void </span><span class="s3">0</span><span class="s0">&amp;&amp;!</span><span class="s1">this</span><span class="s0">.isValidDirective(s)&amp;&amp;(</span><span class="s1">this</span><span class="s0">.flowPragma=</span><span class="s1">null</span><span class="s0">),s}parseExpressionStatement(e,s,i){</span><span class="s1">if</span><span class="s0">(s.type===</span><span class="s2">&quot;Identifier&quot;</span><span class="s0">){</span><span class="s1">if</span><span class="s0">(s.name===</span><span class="s2">&quot;declare&quot;</span><span class="s0">){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">80</span><span class="s0">)||q(</span><span class="s1">this</span><span class="s0">.state.type)||</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">68</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">74</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">82</span><span class="s0">))</span><span class="s1">return this</span><span class="s0">.flowParseDeclare(e)}</span><span class="s1">else if</span><span class="s0">(q(</span><span class="s1">this</span><span class="s0">.state.type)){</span><span class="s1">if</span><span class="s0">(s.name===</span><span class="s2">&quot;interface&quot;</span><span class="s0">)</span><span class="s1">return this</span><span class="s0">.flowParseInterface(e);</span><span class="s1">if</span><span class="s0">(s.name===</span><span class="s2">&quot;type&quot;</span><span class="s0">)</span><span class="s1">return this</span><span class="s0">.flowParseTypeAlias(e);</span><span class="s1">if</span><span class="s0">(s.name===</span><span class="s2">&quot;opaque&quot;</span><span class="s0">)</span><span class="s1">return this</span><span class="s0">.flowParseOpaqueType(e,!</span><span class="s3">1</span><span class="s0">)}}</span><span class="s1">return </span><span class="s0">super.parseExpressionStatement(e,s,i)}shouldParseExportDeclaration(){let{type:e}=</span><span class="s1">this</span><span class="s0">.state;</span><span class="s1">return </span><span class="s0">hr(e)||</span><span class="s1">this</span><span class="s0">.shouldParseEnums()&amp;&amp;e===</span><span class="s3">124</span><span class="s0">?!</span><span class="s1">this</span><span class="s0">.state.containsEsc:super.shouldParseExportDeclaration()}isExportDefaultSpecifier(){let{type:e}=</span><span class="s1">this</span><span class="s0">.state;</span><span class="s1">return </span><span class="s0">hr(e)||</span><span class="s1">this</span><span class="s0">.shouldParseEnums()&amp;&amp;e===</span><span class="s3">124</span><span class="s0">?</span><span class="s1">this</span><span class="s0">.state.containsEsc:super.isExportDefaultSpecifier()}parseExportDefaultExpression(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.shouldParseEnums()&amp;&amp;</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">124</span><span class="s0">)){let e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.flowParseEnumDeclaration(e)}</span><span class="s1">return </span><span class="s0">super.parseExportDefaultExpression()}parseConditional(e,s,i){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">17</span><span class="s0">))</span><span class="s1">return </span><span class="s0">e;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.maybeInArrowParameters){let T=</span><span class="s1">this</span><span class="s0">.lookaheadCharCode();</span><span class="s1">if</span><span class="s0">(T===</span><span class="s3">44</span><span class="s0">||T===</span><span class="s3">61</span><span class="s0">||T===</span><span class="s3">58</span><span class="s0">||T===</span><span class="s3">41</span><span class="s0">)</span><span class="s1">return this</span><span class="s0">.setOptionalParametersError(i),e}</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">17</span><span class="s0">);let a=</span><span class="s1">this</span><span class="s0">.state.clone(),n=</span><span class="s1">this</span><span class="s0">.state.noArrowAt,o=</span><span class="s1">this</span><span class="s0">.startNodeAt(s),{consequent:u,failed:c}=</span><span class="s1">this</span><span class="s0">.tryParseConditionalConsequent(),[y,g]=</span><span class="s1">this</span><span class="s0">.getArrowLikeExpressions(u);</span><span class="s1">if</span><span class="s0">(c||g.length&gt;</span><span class="s3">0</span><span class="s0">){let T=[...n];</span><span class="s1">if</span><span class="s0">(g.length&gt;</span><span class="s3">0</span><span class="s0">){</span><span class="s1">this</span><span class="s0">.state=a,</span><span class="s1">this</span><span class="s0">.state.noArrowAt=T;</span><span class="s1">for</span><span class="s0">(let C=</span><span class="s3">0</span><span class="s0">;C&lt;g.length;C++)T.push(g[C].start);({consequent:u,failed:c}=</span><span class="s1">this</span><span class="s0">.tryParseConditionalConsequent()),[y,g]=</span><span class="s1">this</span><span class="s0">.getArrowLikeExpressions(u)}c&amp;&amp;y.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(D.AmbiguousConditionalArrow,{at:a.startLoc}),c&amp;&amp;y.length===</span><span class="s3">1</span><span class="s0">&amp;&amp;(</span><span class="s1">this</span><span class="s0">.state=a,T.push(y[</span><span class="s3">0</span><span class="s0">].start),</span><span class="s1">this</span><span class="s0">.state.noArrowAt=T,{consequent:u,failed:c}=</span><span class="s1">this</span><span class="s0">.tryParseConditionalConsequent())}</span><span class="s1">return this</span><span class="s0">.getArrowLikeExpressions(u,!</span><span class="s3">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.state.noArrowAt=n,</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">14</span><span class="s0">),o.test=e,o.consequent=u,o.alternate=</span><span class="s1">this</span><span class="s0">.forwardNoArrowParamsConversionAt(o,()=&gt;</span><span class="s1">this</span><span class="s0">.parseMaybeAssign(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,</span><span class="s1">void </span><span class="s3">0</span><span class="s0">)),</span><span class="s1">this</span><span class="s0">.finishNode(o,</span><span class="s2">&quot;ConditionalExpression&quot;</span><span class="s0">)}tryParseConditionalConsequent(){</span><span class="s1">this</span><span class="s0">.state.noArrowParamsConversionAt.push(</span><span class="s1">this</span><span class="s0">.state.start);let e=</span><span class="s1">this</span><span class="s0">.parseMaybeAssignAllowIn(),s=!</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">14</span><span class="s0">);</span><span class="s1">return this</span><span class="s0">.state.noArrowParamsConversionAt.pop(),{consequent:e,failed:s}}getArrowLikeExpressions(e,s){let i=[e],a=[];</span><span class="s1">for</span><span class="s0">(;i.length!==</span><span class="s3">0</span><span class="s0">;){let n=i.pop();n.type===</span><span class="s2">&quot;ArrowFunctionExpression&quot;</span><span class="s0">?(n.typeParameters||!n.returnType?</span><span class="s1">this</span><span class="s0">.finishArrowValidation(n):a.push(n),i.push(n.body)):n.type===</span><span class="s2">&quot;ConditionalExpression&quot;</span><span class="s0">&amp;&amp;(i.push(n.consequent),i.push(n.alternate))}</span><span class="s1">return </span><span class="s0">s?(a.forEach(n=&gt;</span><span class="s1">this</span><span class="s0">.finishArrowValidation(n)),[a,[]]):Yl(a,n=&gt;n.params.every(o=&gt;</span><span class="s1">this</span><span class="s0">.isAssignable(o,!</span><span class="s3">0</span><span class="s0">)))}finishArrowValidation(e){</span><span class="s1">var </span><span class="s0">s;</span><span class="s1">this</span><span class="s0">.toAssignableList(e.params,(s=e.extra)==</span><span class="s1">null</span><span class="s0">?</span><span class="s1">void </span><span class="s3">0</span><span class="s0">:s.trailingCommaLoc,!</span><span class="s3">1</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.scope.enter(de|Gt),super.checkParams(e,!</span><span class="s3">1</span><span class="s0">,!</span><span class="s3">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.scope.exit()}forwardNoArrowParamsConversionAt(e,s){let i;</span><span class="s1">return this</span><span class="s0">.state.noArrowParamsConversionAt.indexOf(e.start)!==-</span><span class="s3">1</span><span class="s0">?(</span><span class="s1">this</span><span class="s0">.state.noArrowParamsConversionAt.push(</span><span class="s1">this</span><span class="s0">.state.start),i=s(),</span><span class="s1">this</span><span class="s0">.state.noArrowParamsConversionAt.pop()):i=s(),i}parseParenItem(e,s){</span><span class="s1">if</span><span class="s0">(e=super.parseParenItem(e,s),</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">17</span><span class="s0">)&amp;&amp;(e.optional=!</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.resetEndLocation(e)),</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">14</span><span class="s0">)){let i=</span><span class="s1">this</span><span class="s0">.startNodeAt(s);</span><span class="s1">return </span><span class="s0">i.expression=e,i.typeAnnotation=</span><span class="s1">this</span><span class="s0">.flowParseTypeAnnotation(),</span><span class="s1">this</span><span class="s0">.finishNode(i,</span><span class="s2">&quot;TypeCastExpression&quot;</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">e}assertModuleNodeAllowed(e){e.type===</span><span class="s2">&quot;ImportDeclaration&quot;</span><span class="s0">&amp;&amp;(e.importKind===</span><span class="s2">&quot;type&quot;</span><span class="s0">||e.importKind===</span><span class="s2">&quot;typeof&quot;</span><span class="s0">)||e.type===</span><span class="s2">&quot;ExportNamedDeclaration&quot;</span><span class="s0">&amp;&amp;e.exportKind===</span><span class="s2">&quot;type&quot;</span><span class="s0">||e.type===</span><span class="s2">&quot;ExportAllDeclaration&quot;</span><span class="s0">&amp;&amp;e.exportKind===</span><span class="s2">&quot;type&quot;</span><span class="s0">||super.assertModuleNodeAllowed(e)}parseExport(e,s){let i=super.parseExport(e,s);</span><span class="s1">return</span><span class="s0">(i.type===</span><span class="s2">&quot;ExportNamedDeclaration&quot;</span><span class="s0">||i.type===</span><span class="s2">&quot;ExportAllDeclaration&quot;</span><span class="s0">)&amp;&amp;(i.exportKind=i.exportKind||</span><span class="s2">&quot;value&quot;</span><span class="s0">),i}parseExportDeclaration(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">128</span><span class="s0">)){e.exportKind=</span><span class="s2">&quot;type&quot;</span><span class="s0">;let s=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">5</span><span class="s0">)?(e.specifiers=</span><span class="s1">this</span><span class="s0">.parseExportSpecifiers(!</span><span class="s3">0</span><span class="s0">),super.parseExportFrom(e),</span><span class="s1">null</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.flowParseTypeAlias(s)}</span><span class="s1">else if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">129</span><span class="s0">)){e.exportKind=</span><span class="s2">&quot;type&quot;</span><span class="s0">;let s=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.flowParseOpaqueType(s,!</span><span class="s3">1</span><span class="s0">)}</span><span class="s1">else if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">127</span><span class="s0">)){e.exportKind=</span><span class="s2">&quot;type&quot;</span><span class="s0">;let s=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.flowParseInterface(s)}</span><span class="s1">else if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.shouldParseEnums()&amp;&amp;</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">124</span><span class="s0">)){e.exportKind=</span><span class="s2">&quot;value&quot;</span><span class="s0">;let s=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.flowParseEnumDeclaration(s)}</span><span class="s1">else return </span><span class="s0">super.parseExportDeclaration(e)}eatExportStar(e){</span><span class="s1">return </span><span class="s0">super.eatExportStar(e)?!</span><span class="s3">0</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">128</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.lookahead().type===</span><span class="s3">55</span><span class="s0">?(e.exportKind=</span><span class="s2">&quot;type&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.next(),!</span><span class="s3">0</span><span class="s0">):!</span><span class="s3">1</span><span class="s0">}maybeParseExportNamespaceSpecifier(e){let{startLoc:s}=</span><span class="s1">this</span><span class="s0">.state,i=super.maybeParseExportNamespaceSpecifier(e);</span><span class="s1">return </span><span class="s0">i&amp;&amp;e.exportKind===</span><span class="s2">&quot;type&quot;</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(s),i}parseClassId(e,s,i){super.parseClassId(e,s,i),</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">47</span><span class="s0">)&amp;&amp;(e.typeParameters=</span><span class="s1">this</span><span class="s0">.flowParseTypeParameterDeclaration())}parseClassMember(e,s,i){let{startLoc:a}=</span><span class="s1">this</span><span class="s0">.state;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">123</span><span class="s0">)){</span><span class="s1">if</span><span class="s0">(super.parseClassMemberFromModifier(e,s))</span><span class="s1">return</span><span class="s0">;s.declare=!</span><span class="s3">0</span><span class="s0">}super.parseClassMember(e,s,i),s.declare&amp;&amp;(s.type!==</span><span class="s2">&quot;ClassProperty&quot;</span><span class="s0">&amp;&amp;s.type!==</span><span class="s2">&quot;ClassPrivateProperty&quot;</span><span class="s0">&amp;&amp;s.type!==</span><span class="s2">&quot;PropertyDefinition&quot;</span><span class="s0">?</span><span class="s1">this</span><span class="s0">.raise(D.DeclareClassElement,{at:a}):s.value&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(D.DeclareClassFieldInitializer,{at:s.value}))}isIterator(e){</span><span class="s1">return </span><span class="s0">e===</span><span class="s2">&quot;iterator&quot;</span><span class="s0">||e===</span><span class="s2">&quot;asyncIterator&quot;</span><span class="s0">}readIterator(){let e=super.readWord1(),s=</span><span class="s2">&quot;@@&quot;</span><span class="s0">+e;(!</span><span class="s1">this</span><span class="s0">.isIterator(e)||!</span><span class="s1">this</span><span class="s0">.state.inType)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.InvalidIdentifier,{at:</span><span class="s1">this</span><span class="s0">.state.curPosition(),identifierName:s}),</span><span class="s1">this</span><span class="s0">.finishToken(</span><span class="s3">130</span><span class="s0">,s)}getTokenFromCode(e){let s=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s3">1</span><span class="s0">);e===</span><span class="s3">123</span><span class="s0">&amp;&amp;s===</span><span class="s3">124</span><span class="s0">?</span><span class="s1">this</span><span class="s0">.finishOp(</span><span class="s3">6</span><span class="s0">,</span><span class="s3">2</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.state.inType&amp;&amp;(e===</span><span class="s3">62</span><span class="s0">||e===</span><span class="s3">60</span><span class="s0">)?</span><span class="s1">this</span><span class="s0">.finishOp(e===</span><span class="s3">62</span><span class="s0">?</span><span class="s3">48</span><span class="s0">:</span><span class="s3">47</span><span class="s0">,</span><span class="s3">1</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.state.inType&amp;&amp;e===</span><span class="s3">63</span><span class="s0">?s===</span><span class="s3">46</span><span class="s0">?</span><span class="s1">this</span><span class="s0">.finishOp(</span><span class="s3">18</span><span class="s0">,</span><span class="s3">2</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.finishOp(</span><span class="s3">17</span><span class="s0">,</span><span class="s3">1</span><span class="s0">):ll(e,s,</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s3">2</span><span class="s0">))?(</span><span class="s1">this</span><span class="s0">.state.pos+=</span><span class="s3">2</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.readIterator()):super.getTokenFromCode(e)}isAssignable(e,s){</span><span class="s1">return </span><span class="s0">e.type===</span><span class="s2">&quot;TypeCastExpression&quot;</span><span class="s0">?</span><span class="s1">this</span><span class="s0">.isAssignable(e.expression,s):super.isAssignable(e,s)}toAssignable(e){let s=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">1</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">1</span><span class="s0">]:!</span><span class="s3">1</span><span class="s0">;!s&amp;&amp;e.type===</span><span class="s2">&quot;AssignmentExpression&quot;</span><span class="s0">&amp;&amp;e.left.type===</span><span class="s2">&quot;TypeCastExpression&quot;</span><span class="s0">&amp;&amp;(e.left=</span><span class="s1">this</span><span class="s0">.typeCastToParameter(e.left)),super.toAssignable(e,s)}toAssignableList(e,s,i){</span><span class="s1">for</span><span class="s0">(let a=</span><span class="s3">0</span><span class="s0">;a&lt;e.length;a++){let n=e[a];(n==</span><span class="s1">null</span><span class="s0">?</span><span class="s1">void </span><span class="s3">0</span><span class="s0">:n.type)===</span><span class="s2">&quot;TypeCastExpression&quot;</span><span class="s0">&amp;&amp;(e[a]=</span><span class="s1">this</span><span class="s0">.typeCastToParameter(n))}super.toAssignableList(e,s,i)}toReferencedList(e,s){</span><span class="s1">for</span><span class="s0">(let a=</span><span class="s3">0</span><span class="s0">;a&lt;e.length;a++){</span><span class="s1">var </span><span class="s0">i;let n=e[a];n&amp;&amp;n.type===</span><span class="s2">&quot;TypeCastExpression&quot;</span><span class="s0">&amp;&amp;!((i=n.extra)!=</span><span class="s1">null</span><span class="s0">&amp;&amp;i.parenthesized)&amp;&amp;(e.length&gt;</span><span class="s3">1</span><span class="s0">||!s)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(D.TypeCastInPattern,{at:n.typeAnnotation})}</span><span class="s1">return </span><span class="s0">e}parseArrayLike(e,s,i,a){let n=super.parseArrayLike(e,s,i,a);</span><span class="s1">return </span><span class="s0">s&amp;&amp;!</span><span class="s1">this</span><span class="s0">.state.maybeInArrowParameters&amp;&amp;</span><span class="s1">this</span><span class="s0">.toReferencedList(n.elements),n}isValidLVal(e,s,i){</span><span class="s1">return </span><span class="s0">e===</span><span class="s2">&quot;TypeCastExpression&quot;</span><span class="s0">||super.isValidLVal(e,s,i)}parseClassProperty(e){</span><span class="s1">return this</span><span class="s0">.match(</span><span class="s3">14</span><span class="s0">)&amp;&amp;(e.typeAnnotation=</span><span class="s1">this</span><span class="s0">.flowParseTypeAnnotation()),super.parseClassProperty(e)}parseClassPrivateProperty(e){</span><span class="s1">return this</span><span class="s0">.match(</span><span class="s3">14</span><span class="s0">)&amp;&amp;(e.typeAnnotation=</span><span class="s1">this</span><span class="s0">.flowParseTypeAnnotation()),super.parseClassPrivateProperty(e)}isClassMethod(){</span><span class="s1">return this</span><span class="s0">.match(</span><span class="s3">47</span><span class="s0">)||super.isClassMethod()}isClassProperty(){</span><span class="s1">return this</span><span class="s0">.match(</span><span class="s3">14</span><span class="s0">)||super.isClassProperty()}isNonstaticConstructor(e){</span><span class="s1">return</span><span class="s0">!</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">14</span><span class="s0">)&amp;&amp;super.isNonstaticConstructor(e)}pushClassMethod(e,s,i,a,n,o){</span><span class="s1">if</span><span class="s0">(s.variance&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(s.variance.loc.start),</span><span class="s1">delete </span><span class="s0">s.variance,</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">47</span><span class="s0">)&amp;&amp;(s.typeParameters=</span><span class="s1">this</span><span class="s0">.flowParseTypeParameterDeclaration()),super.pushClassMethod(e,s,i,a,n,o),s.params&amp;&amp;n){let u=s.params;u.length&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.isThisParam(u[</span><span class="s3">0</span><span class="s0">])&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(D.ThisParamBannedInConstructor,{at:s})}</span><span class="s1">else if</span><span class="s0">(s.type===</span><span class="s2">&quot;MethodDefinition&quot;</span><span class="s0">&amp;&amp;n&amp;&amp;s.value.params){let u=s.value.params;u.length&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.isThisParam(u[</span><span class="s3">0</span><span class="s0">])&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(D.ThisParamBannedInConstructor,{at:s})}}pushClassPrivateMethod(e,s,i,a){s.variance&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(s.variance.loc.start),</span><span class="s1">delete </span><span class="s0">s.variance,</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">47</span><span class="s0">)&amp;&amp;(s.typeParameters=</span><span class="s1">this</span><span class="s0">.flowParseTypeParameterDeclaration()),super.pushClassPrivateMethod(e,s,i,a)}parseClassSuper(e){</span><span class="s1">if</span><span class="s0">(super.parseClassSuper(e),e.superClass&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">47</span><span class="s0">)&amp;&amp;(e.superTypeParameters=</span><span class="s1">this</span><span class="s0">.flowParseTypeParameterInstantiation()),</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">111</span><span class="s0">)){</span><span class="s1">this</span><span class="s0">.next();let s=e.implements=[];</span><span class="s1">do</span><span class="s0">{let i=</span><span class="s1">this</span><span class="s0">.startNode();i.id=</span><span class="s1">this</span><span class="s0">.flowParseRestrictedIdentifier(!</span><span class="s3">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">47</span><span class="s0">)?i.typeParameters=</span><span class="s1">this</span><span class="s0">.flowParseTypeParameterInstantiation():i.typeParameters=</span><span class="s1">null</span><span class="s0">,s.push(</span><span class="s1">this</span><span class="s0">.finishNode(i,</span><span class="s2">&quot;ClassImplements&quot;</span><span class="s0">))}</span><span class="s1">while</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">12</span><span class="s0">))}}checkGetterSetterParams(e){super.checkGetterSetterParams(e);let s=</span><span class="s1">this</span><span class="s0">.getObjectOrClassMethodParams(e);</span><span class="s1">if</span><span class="s0">(s.length&gt;</span><span class="s3">0</span><span class="s0">){let i=s[</span><span class="s3">0</span><span class="s0">];</span><span class="s1">this</span><span class="s0">.isThisParam(i)&amp;&amp;e.kind===</span><span class="s2">&quot;get&quot;</span><span class="s0">?</span><span class="s1">this</span><span class="s0">.raise(D.GetterMayNotHaveThisParam,{at:i}):</span><span class="s1">this</span><span class="s0">.isThisParam(i)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(D.SetterMayNotHaveThisParam,{at:i})}}parsePropertyNamePrefixOperator(e){e.variance=</span><span class="s1">this</span><span class="s0">.flowParseVariance()}parseObjPropValue(e,s,i,a,n,o,u){e.variance&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(e.variance.loc.start),</span><span class="s1">delete </span><span class="s0">e.variance;let c;</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">47</span><span class="s0">)&amp;&amp;!o&amp;&amp;(c=</span><span class="s1">this</span><span class="s0">.flowParseTypeParameterDeclaration(),</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">10</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.unexpected());let y=super.parseObjPropValue(e,s,i,a,n,o,u);</span><span class="s1">return </span><span class="s0">c&amp;&amp;((y.value||y).typeParameters=c),y}parseAssignableListItemTypes(e){</span><span class="s1">return this</span><span class="s0">.eat(</span><span class="s3">17</span><span class="s0">)&amp;&amp;(e.type!==</span><span class="s2">&quot;Identifier&quot;</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(D.PatternIsOptional,{at:e}),</span><span class="s1">this</span><span class="s0">.isThisParam(e)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(D.ThisParamMayNotBeOptional,{at:e}),e.optional=!</span><span class="s3">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">14</span><span class="s0">)?e.typeAnnotation=</span><span class="s1">this</span><span class="s0">.flowParseTypeAnnotation():</span><span class="s1">this</span><span class="s0">.isThisParam(e)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(D.ThisParamAnnotationRequired,{at:e}),</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">29</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.isThisParam(e)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(D.ThisParamNoDefault,{at:e}),</span><span class="s1">this</span><span class="s0">.resetEndLocation(e),e}parseMaybeDefault(e,s){let i=super.parseMaybeDefault(e,s);</span><span class="s1">return </span><span class="s0">i.type===</span><span class="s2">&quot;AssignmentPattern&quot;</span><span class="s0">&amp;&amp;i.typeAnnotation&amp;&amp;i.right.start&lt;i.typeAnnotation.start&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(D.TypeBeforeInitializer,{at:i.typeAnnotation}),i}shouldParseDefaultImport(e){</span><span class="s1">return </span><span class="s0">us(e)?qr(</span><span class="s1">this</span><span class="s0">.state.type):super.shouldParseDefaultImport(e)}checkImportReflection(e){super.checkImportReflection(e),e.module&amp;&amp;e.importKind!==</span><span class="s2">&quot;value&quot;</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(D.ImportReflectionHasImportType,{at:e.specifiers[</span><span class="s3">0</span><span class="s0">].loc.start})}parseImportSpecifierLocal(e,s,i){s.local=us(e)?</span><span class="s1">this</span><span class="s0">.flowParseRestrictedIdentifier(!</span><span class="s3">0</span><span class="s0">,!</span><span class="s3">0</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.parseIdentifier(),e.specifiers.push(</span><span class="s1">this</span><span class="s0">.finishImportSpecifier(s,i))}maybeParseDefaultImportSpecifier(e){e.importKind=</span><span class="s2">&quot;value&quot;</span><span class="s0">;let s=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">87</span><span class="s0">)?s=</span><span class="s2">&quot;typeof&quot;</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">128</span><span class="s0">)&amp;&amp;(s=</span><span class="s2">&quot;type&quot;</span><span class="s0">),s){let i=</span><span class="s1">this</span><span class="s0">.lookahead(),{type:a}=i;s===</span><span class="s2">&quot;type&quot;</span><span class="s0">&amp;&amp;a===</span><span class="s3">55</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(</span><span class="s1">null</span><span class="s0">,i.type),(qr(a)||a===</span><span class="s3">5</span><span class="s0">||a===</span><span class="s3">55</span><span class="s0">)&amp;&amp;(</span><span class="s1">this</span><span class="s0">.next(),e.importKind=s)}</span><span class="s1">return </span><span class="s0">super.maybeParseDefaultImportSpecifier(e)}parseImportSpecifier(e,s,i,a,n){let o=e.imported,u=</span><span class="s1">null</span><span class="s0">;o.type===</span><span class="s2">&quot;Identifier&quot;</span><span class="s0">&amp;&amp;(o.name===</span><span class="s2">&quot;type&quot;</span><span class="s0">?u=</span><span class="s2">&quot;type&quot;</span><span class="s0">:o.name===</span><span class="s2">&quot;typeof&quot;</span><span class="s0">&amp;&amp;(u=</span><span class="s2">&quot;typeof&quot;</span><span class="s0">));let c=!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">93</span><span class="s0">)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.isLookaheadContextual(</span><span class="s2">&quot;as&quot;</span><span class="s0">)){let g=</span><span class="s1">this</span><span class="s0">.parseIdentifier(!</span><span class="s3">0</span><span class="s0">);u!==</span><span class="s1">null</span><span class="s0">&amp;&amp;!te(</span><span class="s1">this</span><span class="s0">.state.type)?(e.imported=g,e.importKind=u,e.local=me(g)):(e.imported=o,e.importKind=</span><span class="s1">null</span><span class="s0">,e.local=</span><span class="s1">this</span><span class="s0">.parseIdentifier())}</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(u!==</span><span class="s1">null</span><span class="s0">&amp;&amp;te(</span><span class="s1">this</span><span class="s0">.state.type))e.imported=</span><span class="s1">this</span><span class="s0">.parseIdentifier(!</span><span class="s3">0</span><span class="s0">),e.importKind=u;</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(s)</span><span class="s1">throw this</span><span class="s0">.raise(f.ImportBindingIsString,{at:e,importName:o.value});e.imported=o,e.importKind=</span><span class="s1">null</span><span class="s0">}</span><span class="s1">this</span><span class="s0">.eatContextual(</span><span class="s3">93</span><span class="s0">)?e.local=</span><span class="s1">this</span><span class="s0">.parseIdentifier():(c=!</span><span class="s3">0</span><span class="s0">,e.local=me(e.imported))}let y=us(e);</span><span class="s1">return </span><span class="s0">i&amp;&amp;y&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(D.ImportTypeShorthandOnlyInPureImport,{at:e}),(i||y)&amp;&amp;</span><span class="s1">this</span><span class="s0">.checkReservedType(e.local.name,e.local.loc.start,!</span><span class="s3">0</span><span class="s0">),c&amp;&amp;!i&amp;&amp;!y&amp;&amp;</span><span class="s1">this</span><span class="s0">.checkReservedWord(e.local.name,e.loc.start,!</span><span class="s3">0</span><span class="s0">,!</span><span class="s3">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishImportSpecifier(e,</span><span class="s2">&quot;ImportSpecifier&quot;</span><span class="s0">)}parseBindingAtom(){</span><span class="s1">switch</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.type){</span><span class="s1">case </span><span class="s3">78</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.parseIdentifier(!</span><span class="s3">0</span><span class="s0">);</span><span class="s1">default</span><span class="s0">:</span><span class="s1">return </span><span class="s0">super.parseBindingAtom()}}parseFunctionParams(e,s){let i=e.kind;i!==</span><span class="s2">&quot;get&quot;</span><span class="s0">&amp;&amp;i!==</span><span class="s2">&quot;set&quot;</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">47</span><span class="s0">)&amp;&amp;(e.typeParameters=</span><span class="s1">this</span><span class="s0">.flowParseTypeParameterDeclaration()),super.parseFunctionParams(e,s)}parseVarId(e,s){super.parseVarId(e,s),</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">14</span><span class="s0">)&amp;&amp;(e.id.typeAnnotation=</span><span class="s1">this</span><span class="s0">.flowParseTypeAnnotation(),</span><span class="s1">this</span><span class="s0">.resetEndLocation(e.id))}parseAsyncArrowFromCallExpression(e,s){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">14</span><span class="s0">)){let i=</span><span class="s1">this</span><span class="s0">.state.noAnonFunctionType;</span><span class="s1">this</span><span class="s0">.state.noAnonFunctionType=!</span><span class="s3">0</span><span class="s0">,e.returnType=</span><span class="s1">this</span><span class="s0">.flowParseTypeAnnotation(),</span><span class="s1">this</span><span class="s0">.state.noAnonFunctionType=i}</span><span class="s1">return </span><span class="s0">super.parseAsyncArrowFromCallExpression(e,s)}shouldParseAsyncArrow(){</span><span class="s1">return this</span><span class="s0">.match(</span><span class="s3">14</span><span class="s0">)||super.shouldParseAsyncArrow()}parseMaybeAssign(e,s){</span><span class="s1">var </span><span class="s0">i;let a=</span><span class="s1">null</span><span class="s0">,n;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s2">&quot;jsx&quot;</span><span class="s0">)&amp;&amp;(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">140</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">47</span><span class="s0">))){</span><span class="s1">if</span><span class="s0">(a=</span><span class="s1">this</span><span class="s0">.state.clone(),n=</span><span class="s1">this</span><span class="s0">.tryParse(()=&gt;super.parseMaybeAssign(e,s),a),!n.error)</span><span class="s1">return </span><span class="s0">n.node;let{context:c}=</span><span class="s1">this</span><span class="s0">.state,y=c[c.length-1];(y===x.j_oTag||y===x.j_expr)&amp;&amp;c.pop()}</span><span class="s1">if</span><span class="s0">((i=n)!=</span><span class="s1">null</span><span class="s0">&amp;&amp;i.error||</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">47</span><span class="s0">)){</span><span class="s1">var </span><span class="s0">o,u;a=a||</span><span class="s1">this</span><span class="s0">.state.clone();let c,y=</span><span class="s1">this</span><span class="s0">.tryParse(T=&gt;{</span><span class="s1">var </span><span class="s0">C;c=</span><span class="s1">this</span><span class="s0">.flowParseTypeParameterDeclaration();let M=</span><span class="s1">this</span><span class="s0">.forwardNoArrowParamsConversionAt(c,()=&gt;{let K=super.parseMaybeAssign(e,s);</span><span class="s1">return this</span><span class="s0">.resetStartLocationFromNode(K,c),K});(C=M.extra)!=</span><span class="s1">null</span><span class="s0">&amp;&amp;C.parenthesized&amp;&amp;T();let j=</span><span class="s1">this</span><span class="s0">.maybeUnwrapTypeCastExpression(M);</span><span class="s1">return </span><span class="s0">j.type!==</span><span class="s2">&quot;ArrowFunctionExpression&quot;</span><span class="s0">&amp;&amp;T(),j.typeParameters=c,</span><span class="s1">this</span><span class="s0">.resetStartLocationFromNode(j,c),M},a),g=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(y.node&amp;&amp;</span><span class="s1">this</span><span class="s0">.maybeUnwrapTypeCastExpression(y.node).type===</span><span class="s2">&quot;ArrowFunctionExpression&quot;</span><span class="s0">){</span><span class="s1">if</span><span class="s0">(!y.error&amp;&amp;!y.aborted)</span><span class="s1">return </span><span class="s0">y.node.async&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(D.UnexpectedTypeParameterBeforeAsyncArrowFunction,{at:c}),y.node;g=y.node}</span><span class="s1">if</span><span class="s0">((o=n)!=</span><span class="s1">null</span><span class="s0">&amp;&amp;o.node)</span><span class="s1">return this</span><span class="s0">.state=n.failState,n.node;</span><span class="s1">if</span><span class="s0">(g)</span><span class="s1">return this</span><span class="s0">.state=y.failState,g;</span><span class="s1">throw</span><span class="s0">(u=n)!=</span><span class="s1">null</span><span class="s0">&amp;&amp;u.thrown?n.error:y.thrown?y.error:</span><span class="s1">this</span><span class="s0">.raise(D.UnexpectedTokenAfterTypeParameter,{at:c})}</span><span class="s1">return </span><span class="s0">super.parseMaybeAssign(e,s)}parseArrow(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">14</span><span class="s0">)){let s=</span><span class="s1">this</span><span class="s0">.tryParse(()=&gt;{let i=</span><span class="s1">this</span><span class="s0">.state.noAnonFunctionType;</span><span class="s1">this</span><span class="s0">.state.noAnonFunctionType=!</span><span class="s3">0</span><span class="s0">;let a=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return</span><span class="s0">[a.typeAnnotation,e.predicate]=</span><span class="s1">this</span><span class="s0">.flowParseTypeAndPredicateInitialiser(),</span><span class="s1">this</span><span class="s0">.state.noAnonFunctionType=i,</span><span class="s1">this</span><span class="s0">.canInsertSemicolon()&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(),</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">19</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.unexpected(),a});</span><span class="s1">if</span><span class="s0">(s.thrown)</span><span class="s1">return null</span><span class="s0">;s.error&amp;&amp;(</span><span class="s1">this</span><span class="s0">.state=s.failState),e.returnType=s.node.typeAnnotation?</span><span class="s1">this</span><span class="s0">.finishNode(s.node,</span><span class="s2">&quot;TypeAnnotation&quot;</span><span class="s0">):</span><span class="s1">null</span><span class="s0">}</span><span class="s1">return </span><span class="s0">super.parseArrow(e)}shouldParseArrow(e){</span><span class="s1">return this</span><span class="s0">.match(</span><span class="s3">14</span><span class="s0">)||super.shouldParseArrow(e)}setArrowFunctionParameters(e,s){</span><span class="s1">this</span><span class="s0">.state.noArrowParamsConversionAt.indexOf(e.start)!==-</span><span class="s3">1</span><span class="s0">?e.params=s:super.setArrowFunctionParameters(e,s)}checkParams(e,s,i){let a=arguments.length&gt;</span><span class="s3">3</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">3</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">3</span><span class="s0">]:!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(!(i&amp;&amp;</span><span class="s1">this</span><span class="s0">.state.noArrowParamsConversionAt.indexOf(e.start)!==-</span><span class="s3">1</span><span class="s0">)){</span><span class="s1">for</span><span class="s0">(let n=</span><span class="s3">0</span><span class="s0">;n&lt;e.params.length;n++)</span><span class="s1">this</span><span class="s0">.isThisParam(e.params[n])&amp;&amp;n&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(D.ThisParamMustBeFirst,{at:e.params[n]});super.checkParams(e,s,i,a)}}parseParenAndDistinguishExpression(e){</span><span class="s1">return </span><span class="s0">super.parseParenAndDistinguishExpression(e&amp;&amp;</span><span class="s1">this</span><span class="s0">.state.noArrowAt.indexOf(</span><span class="s1">this</span><span class="s0">.state.start)===-</span><span class="s3">1</span><span class="s0">)}parseSubscripts(e,s,i){</span><span class="s1">if</span><span class="s0">(e.type===</span><span class="s2">&quot;Identifier&quot;</span><span class="s0">&amp;&amp;e.name===</span><span class="s2">&quot;async&quot;</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.state.noArrowAt.indexOf(s.index)!==-</span><span class="s3">1</span><span class="s0">){</span><span class="s1">this</span><span class="s0">.next();let a=</span><span class="s1">this</span><span class="s0">.startNodeAt(s);a.callee=e,a.arguments=super.parseCallExpressionArguments(</span><span class="s3">11</span><span class="s0">,!</span><span class="s3">1</span><span class="s0">),e=</span><span class="s1">this</span><span class="s0">.finishNode(a,</span><span class="s2">&quot;CallExpression&quot;</span><span class="s0">)}</span><span class="s1">else if</span><span class="s0">(e.type===</span><span class="s2">&quot;Identifier&quot;</span><span class="s0">&amp;&amp;e.name===</span><span class="s2">&quot;async&quot;</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">47</span><span class="s0">)){let a=</span><span class="s1">this</span><span class="s0">.state.clone(),n=</span><span class="s1">this</span><span class="s0">.tryParse(u=&gt;</span><span class="s1">this</span><span class="s0">.parseAsyncArrowWithTypeParameters(s)||u(),a);</span><span class="s1">if</span><span class="s0">(!n.error&amp;&amp;!n.aborted)</span><span class="s1">return </span><span class="s0">n.node;let o=</span><span class="s1">this</span><span class="s0">.tryParse(()=&gt;super.parseSubscripts(e,s,i),a);</span><span class="s1">if</span><span class="s0">(o.node&amp;&amp;!o.error)</span><span class="s1">return </span><span class="s0">o.node;</span><span class="s1">if</span><span class="s0">(n.node)</span><span class="s1">return this</span><span class="s0">.state=n.failState,n.node;</span><span class="s1">if</span><span class="s0">(o.node)</span><span class="s1">return this</span><span class="s0">.state=o.failState,o.node;</span><span class="s1">throw </span><span class="s0">n.error||o.error}</span><span class="s1">return </span><span class="s0">super.parseSubscripts(e,s,i)}parseSubscript(e,s,i,a){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">18</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.isLookaheadToken_lt()){</span><span class="s1">if</span><span class="s0">(a.optionalChainMember=!</span><span class="s3">0</span><span class="s0">,i)</span><span class="s1">return </span><span class="s0">a.stop=!</span><span class="s3">0</span><span class="s0">,e;</span><span class="s1">this</span><span class="s0">.next();let n=</span><span class="s1">this</span><span class="s0">.startNodeAt(s);</span><span class="s1">return </span><span class="s0">n.callee=e,n.typeArguments=</span><span class="s1">this</span><span class="s0">.flowParseTypeParameterInstantiation(),</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">10</span><span class="s0">),n.arguments=</span><span class="s1">this</span><span class="s0">.parseCallExpressionArguments(</span><span class="s3">11</span><span class="s0">,!</span><span class="s3">1</span><span class="s0">),n.optional=!</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.finishCallExpression(n,!</span><span class="s3">0</span><span class="s0">)}</span><span class="s1">else if</span><span class="s0">(!i&amp;&amp;</span><span class="s1">this</span><span class="s0">.shouldParseTypes()&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">47</span><span class="s0">)){let n=</span><span class="s1">this</span><span class="s0">.startNodeAt(s);n.callee=e;let o=</span><span class="s1">this</span><span class="s0">.tryParse(()=&gt;(n.typeArguments=</span><span class="s1">this</span><span class="s0">.flowParseTypeParameterInstantiationCallOrNew(),</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">10</span><span class="s0">),n.arguments=super.parseCallExpressionArguments(</span><span class="s3">11</span><span class="s0">,!</span><span class="s3">1</span><span class="s0">),a.optionalChainMember&amp;&amp;(n.optional=!</span><span class="s3">1</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishCallExpression(n,a.optionalChainMember)));</span><span class="s1">if</span><span class="s0">(o.node)</span><span class="s1">return </span><span class="s0">o.error&amp;&amp;(</span><span class="s1">this</span><span class="s0">.state=o.failState),o.node}</span><span class="s1">return </span><span class="s0">super.parseSubscript(e,s,i,a)}parseNewCallee(e){super.parseNewCallee(e);let s=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.shouldParseTypes()&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">47</span><span class="s0">)&amp;&amp;(s=</span><span class="s1">this</span><span class="s0">.tryParse(()=&gt;</span><span class="s1">this</span><span class="s0">.flowParseTypeParameterInstantiationCallOrNew()).node),e.typeArguments=s}parseAsyncArrowWithTypeParameters(e){let s=</span><span class="s1">this</span><span class="s0">.startNodeAt(e);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.parseFunctionParams(s,!</span><span class="s3">1</span><span class="s0">),!!</span><span class="s1">this</span><span class="s0">.parseArrow(s))</span><span class="s1">return </span><span class="s0">super.parseArrowExpression(s,</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,!</span><span class="s3">0</span><span class="s0">)}readToken_mult_modulo(e){let s=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s3">1</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(e===</span><span class="s3">42</span><span class="s0">&amp;&amp;s===</span><span class="s3">47</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.state.hasFlowComment){</span><span class="s1">this</span><span class="s0">.state.hasFlowComment=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.state.pos+=</span><span class="s3">2</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.nextToken();</span><span class="s1">return</span><span class="s0">}super.readToken_mult_modulo(e)}readToken_pipe_amp(e){let s=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s3">1</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(e===</span><span class="s3">124</span><span class="s0">&amp;&amp;s===</span><span class="s3">125</span><span class="s0">){</span><span class="s1">this</span><span class="s0">.finishOp(</span><span class="s3">9</span><span class="s0">,</span><span class="s3">2</span><span class="s0">);</span><span class="s1">return</span><span class="s0">}super.readToken_pipe_amp(e)}parseTopLevel(e,s){let i=super.parseTopLevel(e,s);</span><span class="s1">return this</span><span class="s0">.state.hasFlowComment&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(D.UnterminatedFlowComment,{at:</span><span class="s1">this</span><span class="s0">.state.curPosition()}),i}skipBlockComment(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s2">&quot;flowComments&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.skipFlowComment()){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.hasFlowComment)</span><span class="s1">throw this</span><span class="s0">.raise(D.NestedFlowComment,{at:</span><span class="s1">this</span><span class="s0">.state.startLoc});</span><span class="s1">this</span><span class="s0">.hasFlowCommentCompletion();let e=</span><span class="s1">this</span><span class="s0">.skipFlowComment();e&amp;&amp;(</span><span class="s1">this</span><span class="s0">.state.pos+=e,</span><span class="s1">this</span><span class="s0">.state.hasFlowComment=!</span><span class="s3">0</span><span class="s0">);</span><span class="s1">return</span><span class="s0">}</span><span class="s1">return </span><span class="s0">super.skipBlockComment(</span><span class="s1">this</span><span class="s0">.state.hasFlowComment?</span><span class="s2">&quot;*-/&quot;</span><span class="s0">:</span><span class="s2">&quot;*/&quot;</span><span class="s0">)}skipFlowComment(){let{pos:e}=</span><span class="s1">this</span><span class="s0">.state,s=</span><span class="s3">2</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(;[</span><span class="s3">32</span><span class="s0">,</span><span class="s3">9</span><span class="s0">].includes(</span><span class="s1">this</span><span class="s0">.input.charCodeAt(e+s));)s++;let i=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(s+e),a=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(s+e+</span><span class="s3">1</span><span class="s0">);</span><span class="s1">return </span><span class="s0">i===</span><span class="s3">58</span><span class="s0">&amp;&amp;a===</span><span class="s3">58</span><span class="s0">?s+</span><span class="s3">2</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.input.slice(s+e,s+e+</span><span class="s3">12</span><span class="s0">)===</span><span class="s2">&quot;flow-include&quot;</span><span class="s0">?s+</span><span class="s3">12</span><span class="s0">:i===</span><span class="s3">58</span><span class="s0">&amp;&amp;a!==</span><span class="s3">58</span><span class="s0">?s:!</span><span class="s3">1</span><span class="s0">}hasFlowCommentCompletion(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.input.indexOf(</span><span class="s2">&quot;*/&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.state.pos)===-</span><span class="s3">1</span><span class="s0">)</span><span class="s1">throw this</span><span class="s0">.raise(f.UnterminatedComment,{at:</span><span class="s1">this</span><span class="s0">.state.curPosition()})}flowEnumErrorBooleanMemberNotInitialized(e,s){let{enumName:i,memberName:a}=s;</span><span class="s1">this</span><span class="s0">.raise(D.EnumBooleanMemberNotInitialized,{at:e,memberName:a,enumName:i})}flowEnumErrorInvalidMemberInitializer(e,s){</span><span class="s1">return this</span><span class="s0">.raise(s.explicitType?s.explicitType===</span><span class="s2">&quot;symbol&quot;</span><span class="s0">?D.EnumInvalidMemberInitializerSymbolType:D.EnumInvalidMemberInitializerPrimaryType:D.EnumInvalidMemberInitializerUnknownType,Object.assign({at:e},s))}flowEnumErrorNumberMemberNotInitialized(e,s){let{enumName:i,memberName:a}=s;</span><span class="s1">this</span><span class="s0">.raise(D.EnumNumberMemberNotInitialized,{at:e,enumName:i,memberName:a})}flowEnumErrorStringMemberInconsistentlyInitailized(e,s){let{enumName:i}=s;</span><span class="s1">this</span><span class="s0">.raise(D.EnumStringMemberInconsistentlyInitailized,{at:e,enumName:i})}flowEnumMemberInit(){let e=</span><span class="s1">this</span><span class="s0">.state.startLoc,s=()=&gt;</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">12</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">8</span><span class="s0">);</span><span class="s1">switch</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.type){</span><span class="s1">case </span><span class="s3">132</span><span class="s0">:{let i=</span><span class="s1">this</span><span class="s0">.parseNumericLiteral(</span><span class="s1">this</span><span class="s0">.state.value);</span><span class="s1">return </span><span class="s0">s()?{type:</span><span class="s2">&quot;number&quot;</span><span class="s0">,loc:i.loc.start,value:i}:{type:</span><span class="s2">&quot;invalid&quot;</span><span class="s0">,loc:e}}</span><span class="s1">case </span><span class="s3">131</span><span class="s0">:{let i=</span><span class="s1">this</span><span class="s0">.parseStringLiteral(</span><span class="s1">this</span><span class="s0">.state.value);</span><span class="s1">return </span><span class="s0">s()?{type:</span><span class="s2">&quot;string&quot;</span><span class="s0">,loc:i.loc.start,value:i}:{type:</span><span class="s2">&quot;invalid&quot;</span><span class="s0">,loc:e}}</span><span class="s1">case </span><span class="s3">85</span><span class="s0">:</span><span class="s1">case </span><span class="s3">86</span><span class="s0">:{let i=</span><span class="s1">this</span><span class="s0">.parseBooleanLiteral(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">85</span><span class="s0">));</span><span class="s1">return </span><span class="s0">s()?{type:</span><span class="s2">&quot;boolean&quot;</span><span class="s0">,loc:i.loc.start,value:i}:{type:</span><span class="s2">&quot;invalid&quot;</span><span class="s0">,loc:e}}</span><span class="s1">default</span><span class="s0">:</span><span class="s1">return</span><span class="s0">{type:</span><span class="s2">&quot;invalid&quot;</span><span class="s0">,loc:e}}}flowEnumMemberRaw(){let e=</span><span class="s1">this</span><span class="s0">.state.startLoc,s=</span><span class="s1">this</span><span class="s0">.parseIdentifier(!</span><span class="s3">0</span><span class="s0">),i=</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">29</span><span class="s0">)?</span><span class="s1">this</span><span class="s0">.flowEnumMemberInit():{type:</span><span class="s2">&quot;none&quot;</span><span class="s0">,loc:e};</span><span class="s1">return</span><span class="s0">{id:s,init:i}}flowEnumCheckExplicitTypeMismatch(e,s,i){let{explicitType:a}=s;a!==</span><span class="s1">null</span><span class="s0">&amp;&amp;a!==i&amp;&amp;</span><span class="s1">this</span><span class="s0">.flowEnumErrorInvalidMemberInitializer(e,s)}flowEnumMembers(e){let{enumName:s,explicitType:i}=e,a=</span><span class="s1">new </span><span class="s0">Set,n={booleanMembers:[],numberMembers:[],stringMembers:[],defaultedMembers:[]},o=!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(;!</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">8</span><span class="s0">);){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">21</span><span class="s0">)){o=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">break</span><span class="s0">}let u=</span><span class="s1">this</span><span class="s0">.startNode(),{id:c,init:y}=</span><span class="s1">this</span><span class="s0">.flowEnumMemberRaw(),g=c.name;</span><span class="s1">if</span><span class="s0">(g===</span><span class="s2">&quot;&quot;</span><span class="s0">)</span><span class="s1">continue</span><span class="s0">;/^[a-z]/.test(g)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(D.EnumInvalidMemberName,{at:c,memberName:g,suggestion:g[</span><span class="s3">0</span><span class="s0">].toUpperCase()+g.slice(</span><span class="s3">1</span><span class="s0">),enumName:s}),a.has(g)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(D.EnumDuplicateMemberName,{at:c,memberName:g,enumName:s}),a.add(g);let T={enumName:s,explicitType:i,memberName:g};</span><span class="s1">switch</span><span class="s0">(u.id=c,y.type){</span><span class="s1">case</span><span class="s2">&quot;boolean&quot;</span><span class="s0">:{</span><span class="s1">this</span><span class="s0">.flowEnumCheckExplicitTypeMismatch(y.loc,T,</span><span class="s2">&quot;boolean&quot;</span><span class="s0">),u.init=y.value,n.booleanMembers.push(</span><span class="s1">this</span><span class="s0">.finishNode(u,</span><span class="s2">&quot;EnumBooleanMember&quot;</span><span class="s0">));</span><span class="s1">break</span><span class="s0">}</span><span class="s1">case</span><span class="s2">&quot;number&quot;</span><span class="s0">:{</span><span class="s1">this</span><span class="s0">.flowEnumCheckExplicitTypeMismatch(y.loc,T,</span><span class="s2">&quot;number&quot;</span><span class="s0">),u.init=y.value,n.numberMembers.push(</span><span class="s1">this</span><span class="s0">.finishNode(u,</span><span class="s2">&quot;EnumNumberMember&quot;</span><span class="s0">));</span><span class="s1">break</span><span class="s0">}</span><span class="s1">case</span><span class="s2">&quot;string&quot;</span><span class="s0">:{</span><span class="s1">this</span><span class="s0">.flowEnumCheckExplicitTypeMismatch(y.loc,T,</span><span class="s2">&quot;string&quot;</span><span class="s0">),u.init=y.value,n.stringMembers.push(</span><span class="s1">this</span><span class="s0">.finishNode(u,</span><span class="s2">&quot;EnumStringMember&quot;</span><span class="s0">));</span><span class="s1">break</span><span class="s0">}</span><span class="s1">case</span><span class="s2">&quot;invalid&quot;</span><span class="s0">:</span><span class="s1">throw this</span><span class="s0">.flowEnumErrorInvalidMemberInitializer(y.loc,T);</span><span class="s1">case</span><span class="s2">&quot;none&quot;</span><span class="s0">:</span><span class="s1">switch</span><span class="s0">(i){</span><span class="s1">case</span><span class="s2">&quot;boolean&quot;</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.flowEnumErrorBooleanMemberNotInitialized(y.loc,T);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;number&quot;</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.flowEnumErrorNumberMemberNotInitialized(y.loc,T);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">default</span><span class="s0">:n.defaultedMembers.push(</span><span class="s1">this</span><span class="s0">.finishNode(u,</span><span class="s2">&quot;EnumDefaultedMember&quot;</span><span class="s0">))}}</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">8</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">12</span><span class="s0">)}</span><span class="s1">return</span><span class="s0">{members:n,hasUnknownMembers:o}}flowEnumStringMembers(e,s,i){let{enumName:a}=i;</span><span class="s1">if</span><span class="s0">(e.length===</span><span class="s3">0</span><span class="s0">)</span><span class="s1">return </span><span class="s0">s;</span><span class="s1">if</span><span class="s0">(s.length===</span><span class="s3">0</span><span class="s0">)</span><span class="s1">return </span><span class="s0">e;</span><span class="s1">if</span><span class="s0">(s.length&gt;e.length){</span><span class="s1">for</span><span class="s0">(let n of e)</span><span class="s1">this</span><span class="s0">.flowEnumErrorStringMemberInconsistentlyInitailized(n,{enumName:a});</span><span class="s1">return </span><span class="s0">s}</span><span class="s1">else</span><span class="s0">{</span><span class="s1">for</span><span class="s0">(let n of s)</span><span class="s1">this</span><span class="s0">.flowEnumErrorStringMemberInconsistentlyInitailized(n,{enumName:a});</span><span class="s1">return </span><span class="s0">e}}flowEnumParseExplicitType(e){let{enumName:s}=e;</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.eatContextual(</span><span class="s3">101</span><span class="s0">))</span><span class="s1">return null</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(!q(</span><span class="s1">this</span><span class="s0">.state.type))</span><span class="s1">throw this</span><span class="s0">.raise(D.EnumInvalidExplicitTypeUnknownSupplied,{at:</span><span class="s1">this</span><span class="s0">.state.startLoc,enumName:s});let{value:i}=</span><span class="s1">this</span><span class="s0">.state;</span><span class="s1">return this</span><span class="s0">.next(),i!==</span><span class="s2">&quot;boolean&quot;</span><span class="s0">&amp;&amp;i!==</span><span class="s2">&quot;number&quot;</span><span class="s0">&amp;&amp;i!==</span><span class="s2">&quot;string&quot;</span><span class="s0">&amp;&amp;i!==</span><span class="s2">&quot;symbol&quot;</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(D.EnumInvalidExplicitType,{at:</span><span class="s1">this</span><span class="s0">.state.startLoc,enumName:s,invalidEnumType:i}),i}flowEnumBody(e,s){let i=s.name,a=s.loc.start,n=</span><span class="s1">this</span><span class="s0">.flowEnumParseExplicitType({enumName:i});</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">5</span><span class="s0">);let{members:o,hasUnknownMembers:u}=</span><span class="s1">this</span><span class="s0">.flowEnumMembers({enumName:i,explicitType:n});</span><span class="s1">switch</span><span class="s0">(e.hasUnknownMembers=u,n){</span><span class="s1">case</span><span class="s2">&quot;boolean&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">e.explicitType=!</span><span class="s3">0</span><span class="s0">,e.members=o.booleanMembers,</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">8</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;EnumBooleanBody&quot;</span><span class="s0">);</span><span class="s1">case</span><span class="s2">&quot;number&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">e.explicitType=!</span><span class="s3">0</span><span class="s0">,e.members=o.numberMembers,</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">8</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;EnumNumberBody&quot;</span><span class="s0">);</span><span class="s1">case</span><span class="s2">&quot;string&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">e.explicitType=!</span><span class="s3">0</span><span class="s0">,e.members=</span><span class="s1">this</span><span class="s0">.flowEnumStringMembers(o.stringMembers,o.defaultedMembers,{enumName:i}),</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">8</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;EnumStringBody&quot;</span><span class="s0">);</span><span class="s1">case</span><span class="s2">&quot;symbol&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">e.members=o.defaultedMembers,</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">8</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;EnumSymbolBody&quot;</span><span class="s0">);</span><span class="s1">default</span><span class="s0">:{let c=()=&gt;(e.members=[],</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">8</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;EnumStringBody&quot;</span><span class="s0">));e.explicitType=!</span><span class="s3">1</span><span class="s0">;let y=o.booleanMembers.length,g=o.numberMembers.length,T=o.stringMembers.length,C=o.defaultedMembers.length;</span><span class="s1">if</span><span class="s0">(!y&amp;&amp;!g&amp;&amp;!T&amp;&amp;!C)</span><span class="s1">return </span><span class="s0">c();</span><span class="s1">if</span><span class="s0">(!y&amp;&amp;!g)</span><span class="s1">return </span><span class="s0">e.members=</span><span class="s1">this</span><span class="s0">.flowEnumStringMembers(o.stringMembers,o.defaultedMembers,{enumName:i}),</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">8</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;EnumStringBody&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(!g&amp;&amp;!T&amp;&amp;y&gt;=C){</span><span class="s1">for</span><span class="s0">(let M of o.defaultedMembers)</span><span class="s1">this</span><span class="s0">.flowEnumErrorBooleanMemberNotInitialized(M.loc.start,{enumName:i,memberName:M.id.name});</span><span class="s1">return </span><span class="s0">e.members=o.booleanMembers,</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">8</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;EnumBooleanBody&quot;</span><span class="s0">)}</span><span class="s1">else if</span><span class="s0">(!y&amp;&amp;!T&amp;&amp;g&gt;=C){</span><span class="s1">for</span><span class="s0">(let M of o.defaultedMembers)</span><span class="s1">this</span><span class="s0">.flowEnumErrorNumberMemberNotInitialized(M.loc.start,{enumName:i,memberName:M.id.name});</span><span class="s1">return </span><span class="s0">e.members=o.numberMembers,</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">8</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;EnumNumberBody&quot;</span><span class="s0">)}</span><span class="s1">else return this</span><span class="s0">.raise(D.EnumInconsistentMemberValues,{at:a,enumName:i}),c()}}}flowParseEnumDeclaration(e){let s=</span><span class="s1">this</span><span class="s0">.parseIdentifier();</span><span class="s1">return </span><span class="s0">e.id=s,e.body=</span><span class="s1">this</span><span class="s0">.flowEnumBody(</span><span class="s1">this</span><span class="s0">.startNode(),s),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;EnumDeclaration&quot;</span><span class="s0">)}isLookaheadToken_lt(){let e=</span><span class="s1">this</span><span class="s0">.nextTokenStart();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.input.charCodeAt(e)===</span><span class="s3">60</span><span class="s0">){let s=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(e+</span><span class="s3">1</span><span class="s0">);</span><span class="s1">return </span><span class="s0">s!==</span><span class="s3">60</span><span class="s0">&amp;&amp;s!==</span><span class="s3">61</span><span class="s0">}</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">}maybeUnwrapTypeCastExpression(e){</span><span class="s1">return </span><span class="s0">e.type===</span><span class="s2">&quot;TypeCastExpression&quot;</span><span class="s0">?e.expression:e}},eh={__proto__:</span><span class="s1">null</span><span class="s0">,quot:</span><span class="s2">'&quot;'</span><span class="s0">,amp:</span><span class="s2">&quot;&amp;&quot;</span><span class="s0">,apos:</span><span class="s2">&quot;'&quot;</span><span class="s0">,lt:</span><span class="s2">&quot;&lt;&quot;</span><span class="s0">,gt:</span><span class="s2">&quot;&gt;&quot;</span><span class="s0">,nbsp:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">A0&quot;</span><span class="s0">,iexcl:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">A1&quot;</span><span class="s0">,cent:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">A2&quot;</span><span class="s0">,pound:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">A3&quot;</span><span class="s0">,curren:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">A4&quot;</span><span class="s0">,yen:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">A5&quot;</span><span class="s0">,brvbar:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">A6&quot;</span><span class="s0">,sect:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">A7&quot;</span><span class="s0">,uml:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">A8&quot;</span><span class="s0">,copy:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">A9&quot;</span><span class="s0">,ordf:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">AA&quot;</span><span class="s0">,laquo:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">AB&quot;</span><span class="s0">,not:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">AC&quot;</span><span class="s0">,shy:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">AD&quot;</span><span class="s0">,reg:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">AE&quot;</span><span class="s0">,macr:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">AF&quot;</span><span class="s0">,deg:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">B0&quot;</span><span class="s0">,plusmn:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">B1&quot;</span><span class="s0">,sup2:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">B2&quot;</span><span class="s0">,sup3:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">B3&quot;</span><span class="s0">,acute:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">B4&quot;</span><span class="s0">,micro:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">B5&quot;</span><span class="s0">,para:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">B6&quot;</span><span class="s0">,middot:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">B7&quot;</span><span class="s0">,cedil:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">B8&quot;</span><span class="s0">,sup1:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">B9&quot;</span><span class="s0">,ordm:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">BA&quot;</span><span class="s0">,raquo:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">BB&quot;</span><span class="s0">,frac14:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">BC&quot;</span><span class="s0">,frac12:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">BD&quot;</span><span class="s0">,frac34:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">BE&quot;</span><span class="s0">,iquest:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">BF&quot;</span><span class="s0">,Agrave:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">C0&quot;</span><span class="s0">,Aacute:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">C1&quot;</span><span class="s0">,Acirc:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">C2&quot;</span><span class="s0">,Atilde:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">C3&quot;</span><span class="s0">,Auml:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">C4&quot;</span><span class="s0">,Aring:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">C5&quot;</span><span class="s0">,AElig:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">C6&quot;</span><span class="s0">,Ccedil:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">C7&quot;</span><span class="s0">,Egrave:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">C8&quot;</span><span class="s0">,Eacute:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">C9&quot;</span><span class="s0">,Ecirc:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">CA&quot;</span><span class="s0">,Euml:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">CB&quot;</span><span class="s0">,Igrave:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">CC&quot;</span><span class="s0">,Iacute:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">CD&quot;</span><span class="s0">,Icirc:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">CE&quot;</span><span class="s0">,Iuml:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">CF&quot;</span><span class="s0">,ETH:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">D0&quot;</span><span class="s0">,Ntilde:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">D1&quot;</span><span class="s0">,Ograve:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">D2&quot;</span><span class="s0">,Oacute:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">D3&quot;</span><span class="s0">,Ocirc:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">D4&quot;</span><span class="s0">,Otilde:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">D5&quot;</span><span class="s0">,Ouml:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">D6&quot;</span><span class="s0">,times:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">D7&quot;</span><span class="s0">,Oslash:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">D8&quot;</span><span class="s0">,Ugrave:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">D9&quot;</span><span class="s0">,Uacute:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">DA&quot;</span><span class="s0">,Ucirc:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">DB&quot;</span><span class="s0">,Uuml:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">DC&quot;</span><span class="s0">,Yacute:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">DD&quot;</span><span class="s0">,THORN:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">DE&quot;</span><span class="s0">,szlig:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">DF&quot;</span><span class="s0">,agrave:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">E0&quot;</span><span class="s0">,aacute:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">E1&quot;</span><span class="s0">,acirc:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">E2&quot;</span><span class="s0">,atilde:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">E3&quot;</span><span class="s0">,auml:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">E4&quot;</span><span class="s0">,aring:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">E5&quot;</span><span class="s0">,aelig:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">E6&quot;</span><span class="s0">,ccedil:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">E7&quot;</span><span class="s0">,egrave:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">E8&quot;</span><span class="s0">,eacute:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">E9&quot;</span><span class="s0">,ecirc:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">EA&quot;</span><span class="s0">,euml:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">EB&quot;</span><span class="s0">,igrave:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">EC&quot;</span><span class="s0">,iacute:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">ED&quot;</span><span class="s0">,icirc:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">EE&quot;</span><span class="s0">,iuml:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">EF&quot;</span><span class="s0">,eth:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">F0&quot;</span><span class="s0">,ntilde:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">F1&quot;</span><span class="s0">,ograve:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">F2&quot;</span><span class="s0">,oacute:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">F3&quot;</span><span class="s0">,ocirc:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">F4&quot;</span><span class="s0">,otilde:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">F5&quot;</span><span class="s0">,ouml:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">F6&quot;</span><span class="s0">,divide:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">F7&quot;</span><span class="s0">,oslash:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">F8&quot;</span><span class="s0">,ugrave:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">F9&quot;</span><span class="s0">,uacute:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">FA&quot;</span><span class="s0">,ucirc:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">FB&quot;</span><span class="s0">,uuml:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">FC&quot;</span><span class="s0">,yacute:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">FD&quot;</span><span class="s0">,thorn:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">FE&quot;</span><span class="s0">,yuml:</span><span class="s2">&quot;</span><span class="s4">\x</span><span class="s2">FF&quot;</span><span class="s0">,OElig:</span><span class="s2">&quot;</span><span class="s4">\u0152</span><span class="s2">&quot;</span><span class="s0">,oelig:</span><span class="s2">&quot;</span><span class="s4">\u0153</span><span class="s2">&quot;</span><span class="s0">,Scaron:</span><span class="s2">&quot;</span><span class="s4">\u0160</span><span class="s2">&quot;</span><span class="s0">,scaron:</span><span class="s2">&quot;</span><span class="s4">\u0161</span><span class="s2">&quot;</span><span class="s0">,Yuml:</span><span class="s2">&quot;</span><span class="s4">\u0178</span><span class="s2">&quot;</span><span class="s0">,fnof:</span><span class="s2">&quot;</span><span class="s4">\u0192</span><span class="s2">&quot;</span><span class="s0">,circ:</span><span class="s2">&quot;</span><span class="s4">\u02C6</span><span class="s2">&quot;</span><span class="s0">,tilde:</span><span class="s2">&quot;</span><span class="s4">\u02DC</span><span class="s2">&quot;</span><span class="s0">,Alpha:</span><span class="s2">&quot;</span><span class="s4">\u0391</span><span class="s2">&quot;</span><span class="s0">,Beta:</span><span class="s2">&quot;</span><span class="s4">\u0392</span><span class="s2">&quot;</span><span class="s0">,Gamma:</span><span class="s2">&quot;</span><span class="s4">\u0393</span><span class="s2">&quot;</span><span class="s0">,Delta:</span><span class="s2">&quot;</span><span class="s4">\u0394</span><span class="s2">&quot;</span><span class="s0">,Epsilon:</span><span class="s2">&quot;</span><span class="s4">\u0395</span><span class="s2">&quot;</span><span class="s0">,Zeta:</span><span class="s2">&quot;</span><span class="s4">\u0396</span><span class="s2">&quot;</span><span class="s0">,Eta:</span><span class="s2">&quot;</span><span class="s4">\u0397</span><span class="s2">&quot;</span><span class="s0">,Theta:</span><span class="s2">&quot;</span><span class="s4">\u0398</span><span class="s2">&quot;</span><span class="s0">,Iota:</span><span class="s2">&quot;</span><span class="s4">\u0399</span><span class="s2">&quot;</span><span class="s0">,Kappa:</span><span class="s2">&quot;</span><span class="s4">\u039A</span><span class="s2">&quot;</span><span class="s0">,Lambda:</span><span class="s2">&quot;</span><span class="s4">\u039B</span><span class="s2">&quot;</span><span class="s0">,Mu:</span><span class="s2">&quot;</span><span class="s4">\u039C</span><span class="s2">&quot;</span><span class="s0">,Nu:</span><span class="s2">&quot;</span><span class="s4">\u039D</span><span class="s2">&quot;</span><span class="s0">,Xi:</span><span class="s2">&quot;</span><span class="s4">\u039E</span><span class="s2">&quot;</span><span class="s0">,Omicron:</span><span class="s2">&quot;</span><span class="s4">\u039F</span><span class="s2">&quot;</span><span class="s0">,Pi:</span><span class="s2">&quot;</span><span class="s4">\u03A0</span><span class="s2">&quot;</span><span class="s0">,Rho:</span><span class="s2">&quot;</span><span class="s4">\u03A1</span><span class="s2">&quot;</span><span class="s0">,Sigma:</span><span class="s2">&quot;</span><span class="s4">\u03A3</span><span class="s2">&quot;</span><span class="s0">,Tau:</span><span class="s2">&quot;</span><span class="s4">\u03A4</span><span class="s2">&quot;</span><span class="s0">,Upsilon:</span><span class="s2">&quot;</span><span class="s4">\u03A5</span><span class="s2">&quot;</span><span class="s0">,Phi:</span><span class="s2">&quot;</span><span class="s4">\u03A6</span><span class="s2">&quot;</span><span class="s0">,Chi:</span><span class="s2">&quot;</span><span class="s4">\u03A7</span><span class="s2">&quot;</span><span class="s0">,Psi:</span><span class="s2">&quot;</span><span class="s4">\u03A8</span><span class="s2">&quot;</span><span class="s0">,Omega:</span><span class="s2">&quot;</span><span class="s4">\u03A9</span><span class="s2">&quot;</span><span class="s0">,alpha:</span><span class="s2">&quot;</span><span class="s4">\u03B1</span><span class="s2">&quot;</span><span class="s0">,beta:</span><span class="s2">&quot;</span><span class="s4">\u03B2</span><span class="s2">&quot;</span><span class="s0">,gamma:</span><span class="s2">&quot;</span><span class="s4">\u03B3</span><span class="s2">&quot;</span><span class="s0">,delta:</span><span class="s2">&quot;</span><span class="s4">\u03B4</span><span class="s2">&quot;</span><span class="s0">,epsilon:</span><span class="s2">&quot;</span><span class="s4">\u03B5</span><span class="s2">&quot;</span><span class="s0">,zeta:</span><span class="s2">&quot;</span><span class="s4">\u03B6</span><span class="s2">&quot;</span><span class="s0">,eta:</span><span class="s2">&quot;</span><span class="s4">\u03B7</span><span class="s2">&quot;</span><span class="s0">,theta:</span><span class="s2">&quot;</span><span class="s4">\u03B8</span><span class="s2">&quot;</span><span class="s0">,iota:</span><span class="s2">&quot;</span><span class="s4">\u03B9</span><span class="s2">&quot;</span><span class="s0">,kappa:</span><span class="s2">&quot;</span><span class="s4">\u03BA</span><span class="s2">&quot;</span><span class="s0">,lambda:</span><span class="s2">&quot;</span><span class="s4">\u03BB</span><span class="s2">&quot;</span><span class="s0">,mu:</span><span class="s2">&quot;</span><span class="s4">\u03BC</span><span class="s2">&quot;</span><span class="s0">,nu:</span><span class="s2">&quot;</span><span class="s4">\u03BD</span><span class="s2">&quot;</span><span class="s0">,xi:</span><span class="s2">&quot;</span><span class="s4">\u03BE</span><span class="s2">&quot;</span><span class="s0">,omicron:</span><span class="s2">&quot;</span><span class="s4">\u03BF</span><span class="s2">&quot;</span><span class="s0">,pi:</span><span class="s2">&quot;</span><span class="s4">\u03C0</span><span class="s2">&quot;</span><span class="s0">,rho:</span><span class="s2">&quot;</span><span class="s4">\u03C1</span><span class="s2">&quot;</span><span class="s0">,sigmaf:</span><span class="s2">&quot;</span><span class="s4">\u03C2</span><span class="s2">&quot;</span><span class="s0">,sigma:</span><span class="s2">&quot;</span><span class="s4">\u03C3</span><span class="s2">&quot;</span><span class="s0">,tau:</span><span class="s2">&quot;</span><span class="s4">\u03C4</span><span class="s2">&quot;</span><span class="s0">,upsilon:</span><span class="s2">&quot;</span><span class="s4">\u03C5</span><span class="s2">&quot;</span><span class="s0">,phi:</span><span class="s2">&quot;</span><span class="s4">\u03C6</span><span class="s2">&quot;</span><span class="s0">,chi:</span><span class="s2">&quot;</span><span class="s4">\u03C7</span><span class="s2">&quot;</span><span class="s0">,psi:</span><span class="s2">&quot;</span><span class="s4">\u03C8</span><span class="s2">&quot;</span><span class="s0">,omega:</span><span class="s2">&quot;</span><span class="s4">\u03C9</span><span class="s2">&quot;</span><span class="s0">,thetasym:</span><span class="s2">&quot;</span><span class="s4">\u03D1</span><span class="s2">&quot;</span><span class="s0">,upsih:</span><span class="s2">&quot;</span><span class="s4">\u03D2</span><span class="s2">&quot;</span><span class="s0">,piv:</span><span class="s2">&quot;</span><span class="s4">\u03D6</span><span class="s2">&quot;</span><span class="s0">,ensp:</span><span class="s2">&quot;</span><span class="s4">\u2002</span><span class="s2">&quot;</span><span class="s0">,emsp:</span><span class="s2">&quot;</span><span class="s4">\u2003</span><span class="s2">&quot;</span><span class="s0">,thinsp:</span><span class="s2">&quot;</span><span class="s4">\u2009</span><span class="s2">&quot;</span><span class="s0">,zwnj:</span><span class="s2">&quot;</span><span class="s4">\u200C</span><span class="s2">&quot;</span><span class="s0">,zwj:</span><span class="s2">&quot;</span><span class="s4">\u200D</span><span class="s2">&quot;</span><span class="s0">,lrm:</span><span class="s2">&quot;</span><span class="s4">\u200E</span><span class="s2">&quot;</span><span class="s0">,rlm:</span><span class="s2">&quot;</span><span class="s4">\u200F</span><span class="s2">&quot;</span><span class="s0">,ndash:</span><span class="s2">&quot;</span><span class="s4">\u2013</span><span class="s2">&quot;</span><span class="s0">,mdash:</span><span class="s2">&quot;</span><span class="s4">\u2014</span><span class="s2">&quot;</span><span class="s0">,lsquo:</span><span class="s2">&quot;</span><span class="s4">\u2018</span><span class="s2">&quot;</span><span class="s0">,rsquo:</span><span class="s2">&quot;</span><span class="s4">\u2019</span><span class="s2">&quot;</span><span class="s0">,sbquo:</span><span class="s2">&quot;</span><span class="s4">\u201A</span><span class="s2">&quot;</span><span class="s0">,ldquo:</span><span class="s2">&quot;</span><span class="s4">\u201C</span><span class="s2">&quot;</span><span class="s0">,rdquo:</span><span class="s2">&quot;</span><span class="s4">\u201D</span><span class="s2">&quot;</span><span class="s0">,bdquo:</span><span class="s2">&quot;</span><span class="s4">\u201E</span><span class="s2">&quot;</span><span class="s0">,dagger:</span><span class="s2">&quot;</span><span class="s4">\u2020</span><span class="s2">&quot;</span><span class="s0">,Dagger:</span><span class="s2">&quot;</span><span class="s4">\u2021</span><span class="s2">&quot;</span><span class="s0">,bull:</span><span class="s2">&quot;</span><span class="s4">\u2022</span><span class="s2">&quot;</span><span class="s0">,hellip:</span><span class="s2">&quot;</span><span class="s4">\u2026</span><span class="s2">&quot;</span><span class="s0">,permil:</span><span class="s2">&quot;</span><span class="s4">\u2030</span><span class="s2">&quot;</span><span class="s0">,prime:</span><span class="s2">&quot;</span><span class="s4">\u2032</span><span class="s2">&quot;</span><span class="s0">,Prime:</span><span class="s2">&quot;</span><span class="s4">\u2033</span><span class="s2">&quot;</span><span class="s0">,lsaquo:</span><span class="s2">&quot;</span><span class="s4">\u2039</span><span class="s2">&quot;</span><span class="s0">,rsaquo:</span><span class="s2">&quot;</span><span class="s4">\u203A</span><span class="s2">&quot;</span><span class="s0">,oline:</span><span class="s2">&quot;</span><span class="s4">\u203E</span><span class="s2">&quot;</span><span class="s0">,frasl:</span><span class="s2">&quot;</span><span class="s4">\u2044</span><span class="s2">&quot;</span><span class="s0">,euro:</span><span class="s2">&quot;</span><span class="s4">\u20AC</span><span class="s2">&quot;</span><span class="s0">,image:</span><span class="s2">&quot;</span><span class="s4">\u2111</span><span class="s2">&quot;</span><span class="s0">,weierp:</span><span class="s2">&quot;</span><span class="s4">\u2118</span><span class="s2">&quot;</span><span class="s0">,real:</span><span class="s2">&quot;</span><span class="s4">\u211C</span><span class="s2">&quot;</span><span class="s0">,trade:</span><span class="s2">&quot;</span><span class="s4">\u2122</span><span class="s2">&quot;</span><span class="s0">,alefsym:</span><span class="s2">&quot;</span><span class="s4">\u2135</span><span class="s2">&quot;</span><span class="s0">,larr:</span><span class="s2">&quot;</span><span class="s4">\u2190</span><span class="s2">&quot;</span><span class="s0">,uarr:</span><span class="s2">&quot;</span><span class="s4">\u2191</span><span class="s2">&quot;</span><span class="s0">,rarr:</span><span class="s2">&quot;</span><span class="s4">\u2192</span><span class="s2">&quot;</span><span class="s0">,darr:</span><span class="s2">&quot;</span><span class="s4">\u2193</span><span class="s2">&quot;</span><span class="s0">,harr:</span><span class="s2">&quot;</span><span class="s4">\u2194</span><span class="s2">&quot;</span><span class="s0">,crarr:</span><span class="s2">&quot;</span><span class="s4">\u21B5</span><span class="s2">&quot;</span><span class="s0">,lArr:</span><span class="s2">&quot;</span><span class="s4">\u21D0</span><span class="s2">&quot;</span><span class="s0">,uArr:</span><span class="s2">&quot;</span><span class="s4">\u21D1</span><span class="s2">&quot;</span><span class="s0">,rArr:</span><span class="s2">&quot;</span><span class="s4">\u21D2</span><span class="s2">&quot;</span><span class="s0">,dArr:</span><span class="s2">&quot;</span><span class="s4">\u21D3</span><span class="s2">&quot;</span><span class="s0">,hArr:</span><span class="s2">&quot;</span><span class="s4">\u21D4</span><span class="s2">&quot;</span><span class="s0">,forall:</span><span class="s2">&quot;</span><span class="s4">\u2200</span><span class="s2">&quot;</span><span class="s0">,part:</span><span class="s2">&quot;</span><span class="s4">\u2202</span><span class="s2">&quot;</span><span class="s0">,exist:</span><span class="s2">&quot;</span><span class="s4">\u2203</span><span class="s2">&quot;</span><span class="s0">,empty:</span><span class="s2">&quot;</span><span class="s4">\u2205</span><span class="s2">&quot;</span><span class="s0">,nabla:</span><span class="s2">&quot;</span><span class="s4">\u2207</span><span class="s2">&quot;</span><span class="s0">,isin:</span><span class="s2">&quot;</span><span class="s4">\u2208</span><span class="s2">&quot;</span><span class="s0">,notin:</span><span class="s2">&quot;</span><span class="s4">\u2209</span><span class="s2">&quot;</span><span class="s0">,ni:</span><span class="s2">&quot;</span><span class="s4">\u220B</span><span class="s2">&quot;</span><span class="s0">,prod:</span><span class="s2">&quot;</span><span class="s4">\u220F</span><span class="s2">&quot;</span><span class="s0">,sum:</span><span class="s2">&quot;</span><span class="s4">\u2211</span><span class="s2">&quot;</span><span class="s0">,minus:</span><span class="s2">&quot;</span><span class="s4">\u2212</span><span class="s2">&quot;</span><span class="s0">,lowast:</span><span class="s2">&quot;</span><span class="s4">\u2217</span><span class="s2">&quot;</span><span class="s0">,radic:</span><span class="s2">&quot;</span><span class="s4">\u221A</span><span class="s2">&quot;</span><span class="s0">,prop:</span><span class="s2">&quot;</span><span class="s4">\u221D</span><span class="s2">&quot;</span><span class="s0">,infin:</span><span class="s2">&quot;</span><span class="s4">\u221E</span><span class="s2">&quot;</span><span class="s0">,ang:</span><span class="s2">&quot;</span><span class="s4">\u2220</span><span class="s2">&quot;</span><span class="s0">,and:</span><span class="s2">&quot;</span><span class="s4">\u2227</span><span class="s2">&quot;</span><span class="s0">,or:</span><span class="s2">&quot;</span><span class="s4">\u2228</span><span class="s2">&quot;</span><span class="s0">,cap:</span><span class="s2">&quot;</span><span class="s4">\u2229</span><span class="s2">&quot;</span><span class="s0">,cup:</span><span class="s2">&quot;</span><span class="s4">\u222A</span><span class="s2">&quot;</span><span class="s0">,int:</span><span class="s2">&quot;</span><span class="s4">\u222B</span><span class="s2">&quot;</span><span class="s0">,there4:</span><span class="s2">&quot;</span><span class="s4">\u2234</span><span class="s2">&quot;</span><span class="s0">,sim:</span><span class="s2">&quot;</span><span class="s4">\u223C</span><span class="s2">&quot;</span><span class="s0">,cong:</span><span class="s2">&quot;</span><span class="s4">\u2245</span><span class="s2">&quot;</span><span class="s0">,asymp:</span><span class="s2">&quot;</span><span class="s4">\u2248</span><span class="s2">&quot;</span><span class="s0">,ne:</span><span class="s2">&quot;</span><span class="s4">\u2260</span><span class="s2">&quot;</span><span class="s0">,equiv:</span><span class="s2">&quot;</span><span class="s4">\u2261</span><span class="s2">&quot;</span><span class="s0">,le:</span><span class="s2">&quot;</span><span class="s4">\u2264</span><span class="s2">&quot;</span><span class="s0">,ge:</span><span class="s2">&quot;</span><span class="s4">\u2265</span><span class="s2">&quot;</span><span class="s0">,sub:</span><span class="s2">&quot;</span><span class="s4">\u2282</span><span class="s2">&quot;</span><span class="s0">,sup:</span><span class="s2">&quot;</span><span class="s4">\u2283</span><span class="s2">&quot;</span><span class="s0">,nsub:</span><span class="s2">&quot;</span><span class="s4">\u2284</span><span class="s2">&quot;</span><span class="s0">,sube:</span><span class="s2">&quot;</span><span class="s4">\u2286</span><span class="s2">&quot;</span><span class="s0">,supe:</span><span class="s2">&quot;</span><span class="s4">\u2287</span><span class="s2">&quot;</span><span class="s0">,oplus:</span><span class="s2">&quot;</span><span class="s4">\u2295</span><span class="s2">&quot;</span><span class="s0">,otimes:</span><span class="s2">&quot;</span><span class="s4">\u2297</span><span class="s2">&quot;</span><span class="s0">,perp:</span><span class="s2">&quot;</span><span class="s4">\u22A5</span><span class="s2">&quot;</span><span class="s0">,sdot:</span><span class="s2">&quot;</span><span class="s4">\u22C5</span><span class="s2">&quot;</span><span class="s0">,lceil:</span><span class="s2">&quot;</span><span class="s4">\u2308</span><span class="s2">&quot;</span><span class="s0">,rceil:</span><span class="s2">&quot;</span><span class="s4">\u2309</span><span class="s2">&quot;</span><span class="s0">,lfloor:</span><span class="s2">&quot;</span><span class="s4">\u230A</span><span class="s2">&quot;</span><span class="s0">,rfloor:</span><span class="s2">&quot;</span><span class="s4">\u230B</span><span class="s2">&quot;</span><span class="s0">,lang:</span><span class="s2">&quot;</span><span class="s4">\u2329</span><span class="s2">&quot;</span><span class="s0">,rang:</span><span class="s2">&quot;</span><span class="s4">\u232A</span><span class="s2">&quot;</span><span class="s0">,loz:</span><span class="s2">&quot;</span><span class="s4">\u25CA</span><span class="s2">&quot;</span><span class="s0">,spades:</span><span class="s2">&quot;</span><span class="s4">\u2660</span><span class="s2">&quot;</span><span class="s0">,clubs:</span><span class="s2">&quot;</span><span class="s4">\u2663</span><span class="s2">&quot;</span><span class="s0">,hearts:</span><span class="s2">&quot;</span><span class="s4">\u2665</span><span class="s2">&quot;</span><span class="s0">,diams:</span><span class="s2">&quot;</span><span class="s4">\u2666</span><span class="s2">&quot;</span><span class="s0">},Se=pe`jsx`({AttributeIsEmpty:</span><span class="s2">&quot;JSX attributes must only be assigned a non-empty expression.&quot;</span><span class="s0">,MissingClosingTagElement:t=&gt;{let{openingTagName:r}=t;</span><span class="s1">return</span><span class="s0">`Expected corresponding JSX closing tag </span><span class="s1">for </span><span class="s0">&lt;${r}&gt;.`},MissingClosingTagFragment:</span><span class="s2">&quot;Expected corresponding JSX closing tag for &lt;&gt;.&quot;</span><span class="s0">,UnexpectedSequenceExpression:</span><span class="s2">&quot;Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?&quot;</span><span class="s0">,UnexpectedToken:t=&gt;{let{unexpected:r,HTMLEntity:e}=t;</span><span class="s1">return</span><span class="s0">`Unexpected token \`${r}\`. Did you mean \`${e}\` or \`{</span><span class="s2">'${r}'</span><span class="s0">}\`?`},UnsupportedJsxValue:</span><span class="s2">&quot;JSX value should be either an expression or a quoted JSX text.&quot;</span><span class="s0">,UnterminatedJsxContent:</span><span class="s2">&quot;Unterminated JSX contents.&quot;</span><span class="s0">,UnwrappedAdjacentJSXElements:</span><span class="s2">&quot;Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment &lt;&gt;...&lt;/&gt;?&quot;</span><span class="s0">});</span><span class="s1">function </span><span class="s0">Te(t){</span><span class="s1">return </span><span class="s0">t?t.type===</span><span class="s2">&quot;JSXOpeningFragment&quot;</span><span class="s0">||t.type===</span><span class="s2">&quot;JSXClosingFragment&quot;</span><span class="s0">:!</span><span class="s3">1</span><span class="s0">}</span><span class="s1">function </span><span class="s0">Re(t){</span><span class="s1">if</span><span class="s0">(t.type===</span><span class="s2">&quot;JSXIdentifier&quot;</span><span class="s0">)</span><span class="s1">return </span><span class="s0">t.name;</span><span class="s1">if</span><span class="s0">(t.type===</span><span class="s2">&quot;JSXNamespacedName&quot;</span><span class="s0">)</span><span class="s1">return </span><span class="s0">t.namespace.name+</span><span class="s2">&quot;:&quot;</span><span class="s0">+t.name.name;</span><span class="s1">if</span><span class="s0">(t.type===</span><span class="s2">&quot;JSXMemberExpression&quot;</span><span class="s0">)</span><span class="s1">return </span><span class="s0">Re(t.object)+</span><span class="s2">&quot;.&quot;</span><span class="s0">+Re(t.property);</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;Node had unexpected type: &quot;</span><span class="s0">+t.type)}</span><span class="s1">var </span><span class="s0">th=t=&gt;class extends t{jsxReadToken(){let e=</span><span class="s2">&quot;&quot;</span><span class="s0">,s=</span><span class="s1">this</span><span class="s0">.state.pos;</span><span class="s1">for</span><span class="s0">(;;){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.pos&gt;=</span><span class="s1">this</span><span class="s0">.length)</span><span class="s1">throw this</span><span class="s0">.raise(Se.UnterminatedJsxContent,{at:</span><span class="s1">this</span><span class="s0">.state.startLoc});let i=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos);</span><span class="s1">switch</span><span class="s0">(i){</span><span class="s1">case </span><span class="s3">60</span><span class="s0">:</span><span class="s1">case </span><span class="s3">123</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.pos===</span><span class="s1">this</span><span class="s0">.state.start){i===</span><span class="s3">60</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.state.canStartJSXElement?(++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">this</span><span class="s0">.finishToken(</span><span class="s3">140</span><span class="s0">)):super.getTokenFromCode(i);</span><span class="s1">return</span><span class="s0">}e+=</span><span class="s1">this</span><span class="s0">.input.slice(s,</span><span class="s1">this</span><span class="s0">.state.pos),</span><span class="s1">this</span><span class="s0">.finishToken(</span><span class="s3">139</span><span class="s0">,e);</span><span class="s1">return</span><span class="s0">;</span><span class="s1">case </span><span class="s3">38</span><span class="s0">:e+=</span><span class="s1">this</span><span class="s0">.input.slice(s,</span><span class="s1">this</span><span class="s0">.state.pos),e+=</span><span class="s1">this</span><span class="s0">.jsxReadEntity(),s=</span><span class="s1">this</span><span class="s0">.state.pos;</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case </span><span class="s3">62</span><span class="s0">:</span><span class="s1">case </span><span class="s3">125</span><span class="s0">:</span><span class="s1">default</span><span class="s0">:Ge(i)?(e+=</span><span class="s1">this</span><span class="s0">.input.slice(s,</span><span class="s1">this</span><span class="s0">.state.pos),e+=</span><span class="s1">this</span><span class="s0">.jsxReadNewLine(!</span><span class="s3">0</span><span class="s0">),s=</span><span class="s1">this</span><span class="s0">.state.pos):++</span><span class="s1">this</span><span class="s0">.state.pos}}}jsxReadNewLine(e){let s=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos),i;</span><span class="s1">return</span><span class="s0">++</span><span class="s1">this</span><span class="s0">.state.pos,s===</span><span class="s3">13</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos)===</span><span class="s3">10</span><span class="s0">?(++</span><span class="s1">this</span><span class="s0">.state.pos,i=e?`</span>
<span class="s0">`:`\r</span>
<span class="s0">`):i=String.fromCharCode(s),++</span><span class="s1">this</span><span class="s0">.state.curLine,</span><span class="s1">this</span><span class="s0">.state.lineStart=</span><span class="s1">this</span><span class="s0">.state.pos,i}jsxReadString(e){let s=</span><span class="s2">&quot;&quot;</span><span class="s0">,i=++</span><span class="s1">this</span><span class="s0">.state.pos;</span><span class="s1">for</span><span class="s0">(;;){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.pos&gt;=</span><span class="s1">this</span><span class="s0">.length)</span><span class="s1">throw this</span><span class="s0">.raise(f.UnterminatedString,{at:</span><span class="s1">this</span><span class="s0">.state.startLoc});let a=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos);</span><span class="s1">if</span><span class="s0">(a===e)</span><span class="s1">break</span><span class="s0">;a===</span><span class="s3">38</span><span class="s0">?(s+=</span><span class="s1">this</span><span class="s0">.input.slice(i,</span><span class="s1">this</span><span class="s0">.state.pos),s+=</span><span class="s1">this</span><span class="s0">.jsxReadEntity(),i=</span><span class="s1">this</span><span class="s0">.state.pos):Ge(a)?(s+=</span><span class="s1">this</span><span class="s0">.input.slice(i,</span><span class="s1">this</span><span class="s0">.state.pos),s+=</span><span class="s1">this</span><span class="s0">.jsxReadNewLine(!</span><span class="s3">1</span><span class="s0">),i=</span><span class="s1">this</span><span class="s0">.state.pos):++</span><span class="s1">this</span><span class="s0">.state.pos}s+=</span><span class="s1">this</span><span class="s0">.input.slice(i,</span><span class="s1">this</span><span class="s0">.state.pos++),</span><span class="s1">this</span><span class="s0">.finishToken(</span><span class="s3">131</span><span class="s0">,s)}jsxReadEntity(){let e=++</span><span class="s1">this</span><span class="s0">.state.pos;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.codePointAtPos(</span><span class="s1">this</span><span class="s0">.state.pos)===</span><span class="s3">35</span><span class="s0">){++</span><span class="s1">this</span><span class="s0">.state.pos;let s=</span><span class="s3">10</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.codePointAtPos(</span><span class="s1">this</span><span class="s0">.state.pos)===</span><span class="s3">120</span><span class="s0">&amp;&amp;(s=</span><span class="s3">16</span><span class="s0">,++</span><span class="s1">this</span><span class="s0">.state.pos);let i=</span><span class="s1">this</span><span class="s0">.readInt(s,</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,!</span><span class="s3">1</span><span class="s0">,</span><span class="s2">&quot;bail&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(i!==</span><span class="s1">null</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.codePointAtPos(</span><span class="s1">this</span><span class="s0">.state.pos)===</span><span class="s3">59</span><span class="s0">)</span><span class="s1">return</span><span class="s0">++</span><span class="s1">this</span><span class="s0">.state.pos,String.fromCodePoint(i)}</span><span class="s1">else</span><span class="s0">{let s=</span><span class="s3">0</span><span class="s0">,i=!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(;s++&lt;</span><span class="s3">10</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.state.pos&lt;</span><span class="s1">this</span><span class="s0">.length&amp;&amp;!(i=</span><span class="s1">this</span><span class="s0">.codePointAtPos(</span><span class="s1">this</span><span class="s0">.state.pos)==</span><span class="s3">59</span><span class="s0">);)++</span><span class="s1">this</span><span class="s0">.state.pos;</span><span class="s1">if</span><span class="s0">(i){let a=</span><span class="s1">this</span><span class="s0">.input.slice(e,</span><span class="s1">this</span><span class="s0">.state.pos),n=eh[a];</span><span class="s1">if</span><span class="s0">(++</span><span class="s1">this</span><span class="s0">.state.pos,n)</span><span class="s1">return </span><span class="s0">n}}</span><span class="s1">return this</span><span class="s0">.state.pos=e,</span><span class="s2">&quot;&amp;&quot;</span><span class="s0">}jsxReadWord(){let e,s=</span><span class="s1">this</span><span class="s0">.state.pos;</span><span class="s1">do </span><span class="s0">e=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(++</span><span class="s1">this</span><span class="s0">.state.pos);</span><span class="s1">while</span><span class="s0">(De(e)||e===</span><span class="s3">45</span><span class="s0">);</span><span class="s1">this</span><span class="s0">.finishToken(</span><span class="s3">138</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.input.slice(s,</span><span class="s1">this</span><span class="s0">.state.pos))}jsxParseIdentifier(){let e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.match(</span><span class="s3">138</span><span class="s0">)?e.name=</span><span class="s1">this</span><span class="s0">.state.value:$t(</span><span class="s1">this</span><span class="s0">.state.type)?e.name=xe(</span><span class="s1">this</span><span class="s0">.state.type):</span><span class="s1">this</span><span class="s0">.unexpected(),</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;JSXIdentifier&quot;</span><span class="s0">)}jsxParseNamespacedName(){let e=</span><span class="s1">this</span><span class="s0">.state.startLoc,s=</span><span class="s1">this</span><span class="s0">.jsxParseIdentifier();</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">14</span><span class="s0">))</span><span class="s1">return </span><span class="s0">s;let i=</span><span class="s1">this</span><span class="s0">.startNodeAt(e);</span><span class="s1">return </span><span class="s0">i.namespace=s,i.name=</span><span class="s1">this</span><span class="s0">.jsxParseIdentifier(),</span><span class="s1">this</span><span class="s0">.finishNode(i,</span><span class="s2">&quot;JSXNamespacedName&quot;</span><span class="s0">)}jsxParseElementName(){let e=</span><span class="s1">this</span><span class="s0">.state.startLoc,s=</span><span class="s1">this</span><span class="s0">.jsxParseNamespacedName();</span><span class="s1">if</span><span class="s0">(s.type===</span><span class="s2">&quot;JSXNamespacedName&quot;</span><span class="s0">)</span><span class="s1">return </span><span class="s0">s;</span><span class="s1">for</span><span class="s0">(;</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">16</span><span class="s0">);){let i=</span><span class="s1">this</span><span class="s0">.startNodeAt(e);i.object=s,i.property=</span><span class="s1">this</span><span class="s0">.jsxParseIdentifier(),s=</span><span class="s1">this</span><span class="s0">.finishNode(i,</span><span class="s2">&quot;JSXMemberExpression&quot;</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">s}jsxParseAttributeValue(){let e;</span><span class="s1">switch</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.type){</span><span class="s1">case </span><span class="s3">5</span><span class="s0">:</span><span class="s1">return </span><span class="s0">e=</span><span class="s1">this</span><span class="s0">.startNode(),</span><span class="s1">this</span><span class="s0">.setContext(x.brace),</span><span class="s1">this</span><span class="s0">.next(),e=</span><span class="s1">this</span><span class="s0">.jsxParseExpressionContainer(e,x.j_oTag),e.expression.type===</span><span class="s2">&quot;JSXEmptyExpression&quot;</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(Se.AttributeIsEmpty,{at:e}),e;</span><span class="s1">case </span><span class="s3">140</span><span class="s0">:</span><span class="s1">case </span><span class="s3">131</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.parseExprAtom();</span><span class="s1">default</span><span class="s0">:</span><span class="s1">throw this</span><span class="s0">.raise(Se.UnsupportedJsxValue,{at:</span><span class="s1">this</span><span class="s0">.state.startLoc})}}jsxParseEmptyExpression(){let e=</span><span class="s1">this</span><span class="s0">.startNodeAt(</span><span class="s1">this</span><span class="s0">.state.lastTokEndLoc);</span><span class="s1">return this</span><span class="s0">.finishNodeAt(e,</span><span class="s2">&quot;JSXEmptyExpression&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.state.startLoc)}jsxParseSpreadChild(e){</span><span class="s1">return this</span><span class="s0">.next(),e.expression=</span><span class="s1">this</span><span class="s0">.parseExpression(),</span><span class="s1">this</span><span class="s0">.setContext(x.j_expr),</span><span class="s1">this</span><span class="s0">.state.canStartJSXElement=!</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">8</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;JSXSpreadChild&quot;</span><span class="s0">)}jsxParseExpressionContainer(e,s){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">8</span><span class="s0">))e.expression=</span><span class="s1">this</span><span class="s0">.jsxParseEmptyExpression();</span><span class="s1">else</span><span class="s0">{let i=</span><span class="s1">this</span><span class="s0">.parseExpression();e.expression=i}</span><span class="s1">return this</span><span class="s0">.setContext(s),</span><span class="s1">this</span><span class="s0">.state.canStartJSXElement=!</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">8</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;JSXExpressionContainer&quot;</span><span class="s0">)}jsxParseAttribute(){let e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.match(</span><span class="s3">5</span><span class="s0">)?(</span><span class="s1">this</span><span class="s0">.setContext(x.brace),</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">21</span><span class="s0">),e.argument=</span><span class="s1">this</span><span class="s0">.parseMaybeAssignAllowIn(),</span><span class="s1">this</span><span class="s0">.setContext(x.j_oTag),</span><span class="s1">this</span><span class="s0">.state.canStartJSXElement=!</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">8</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;JSXSpreadAttribute&quot;</span><span class="s0">)):(e.name=</span><span class="s1">this</span><span class="s0">.jsxParseNamespacedName(),e.value=</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">29</span><span class="s0">)?</span><span class="s1">this</span><span class="s0">.jsxParseAttributeValue():</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;JSXAttribute&quot;</span><span class="s0">))}jsxParseOpeningElementAt(e){let s=</span><span class="s1">this</span><span class="s0">.startNodeAt(e);</span><span class="s1">return this</span><span class="s0">.eat(</span><span class="s3">141</span><span class="s0">)?</span><span class="s1">this</span><span class="s0">.finishNode(s,</span><span class="s2">&quot;JSXOpeningFragment&quot;</span><span class="s0">):(s.name=</span><span class="s1">this</span><span class="s0">.jsxParseElementName(),</span><span class="s1">this</span><span class="s0">.jsxParseOpeningElementAfterName(s))}jsxParseOpeningElementAfterName(e){let s=[];</span><span class="s1">for</span><span class="s0">(;!</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">56</span><span class="s0">)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">141</span><span class="s0">);)s.push(</span><span class="s1">this</span><span class="s0">.jsxParseAttribute());</span><span class="s1">return </span><span class="s0">e.attributes=s,e.selfClosing=</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">56</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">141</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;JSXOpeningElement&quot;</span><span class="s0">)}jsxParseClosingElementAt(e){let s=</span><span class="s1">this</span><span class="s0">.startNodeAt(e);</span><span class="s1">return this</span><span class="s0">.eat(</span><span class="s3">141</span><span class="s0">)?</span><span class="s1">this</span><span class="s0">.finishNode(s,</span><span class="s2">&quot;JSXClosingFragment&quot;</span><span class="s0">):(s.name=</span><span class="s1">this</span><span class="s0">.jsxParseElementName(),</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">141</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(s,</span><span class="s2">&quot;JSXClosingElement&quot;</span><span class="s0">))}jsxParseElementAt(e){let s=</span><span class="s1">this</span><span class="s0">.startNodeAt(e),i=[],a=</span><span class="s1">this</span><span class="s0">.jsxParseOpeningElementAt(e),n=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(!a.selfClosing){e:</span><span class="s1">for</span><span class="s0">(;;)</span><span class="s1">switch</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.type){</span><span class="s1">case </span><span class="s3">140</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(e=</span><span class="s1">this</span><span class="s0">.state.startLoc,</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">56</span><span class="s0">)){n=</span><span class="s1">this</span><span class="s0">.jsxParseClosingElementAt(e);</span><span class="s1">break </span><span class="s0">e}i.push(</span><span class="s1">this</span><span class="s0">.jsxParseElementAt(e));</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case </span><span class="s3">139</span><span class="s0">:i.push(</span><span class="s1">this</span><span class="s0">.parseExprAtom());</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case </span><span class="s3">5</span><span class="s0">:{let o=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">this</span><span class="s0">.setContext(x.brace),</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">21</span><span class="s0">)?i.push(</span><span class="s1">this</span><span class="s0">.jsxParseSpreadChild(o)):i.push(</span><span class="s1">this</span><span class="s0">.jsxParseExpressionContainer(o,x.j_expr));</span><span class="s1">break</span><span class="s0">}</span><span class="s1">default</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.unexpected()}Te(a)&amp;&amp;!Te(n)&amp;&amp;n!==</span><span class="s1">null</span><span class="s0">?</span><span class="s1">this</span><span class="s0">.raise(Se.MissingClosingTagFragment,{at:n}):!Te(a)&amp;&amp;Te(n)?</span><span class="s1">this</span><span class="s0">.raise(Se.MissingClosingTagElement,{at:n,openingTagName:Re(a.name)}):!Te(a)&amp;&amp;!Te(n)&amp;&amp;Re(n.name)!==Re(a.name)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(Se.MissingClosingTagElement,{at:n,openingTagName:Re(a.name)})}</span><span class="s1">if</span><span class="s0">(Te(a)?(s.openingFragment=a,s.closingFragment=n):(s.openingElement=a,s.closingElement=n),s.children=i,</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">47</span><span class="s0">))</span><span class="s1">throw this</span><span class="s0">.raise(Se.UnwrappedAdjacentJSXElements,{at:</span><span class="s1">this</span><span class="s0">.state.startLoc});</span><span class="s1">return </span><span class="s0">Te(a)?</span><span class="s1">this</span><span class="s0">.finishNode(s,</span><span class="s2">&quot;JSXFragment&quot;</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.finishNode(s,</span><span class="s2">&quot;JSXElement&quot;</span><span class="s0">)}jsxParseElement(){let e=</span><span class="s1">this</span><span class="s0">.state.startLoc;</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.jsxParseElementAt(e)}setContext(e){let{context:s}=</span><span class="s1">this</span><span class="s0">.state;s[s.length-1]=e}parseExprAtom(e){</span><span class="s1">return this</span><span class="s0">.match(</span><span class="s3">139</span><span class="s0">)?</span><span class="s1">this</span><span class="s0">.parseLiteral(</span><span class="s1">this</span><span class="s0">.state.value,</span><span class="s2">&quot;JSXText&quot;</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">140</span><span class="s0">)?</span><span class="s1">this</span><span class="s0">.jsxParseElement():</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">47</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos)!==</span><span class="s3">33</span><span class="s0">?(</span><span class="s1">this</span><span class="s0">.replaceToken(</span><span class="s3">140</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.jsxParseElement()):super.parseExprAtom(e)}skipSpace(){</span><span class="s1">this</span><span class="s0">.curContext().preserveSpace||super.skipSpace()}getTokenFromCode(e){let s=</span><span class="s1">this</span><span class="s0">.curContext();</span><span class="s1">if</span><span class="s0">(s===x.j_expr){</span><span class="s1">this</span><span class="s0">.jsxReadToken();</span><span class="s1">return</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(s===x.j_oTag||s===x.j_cTag){</span><span class="s1">if</span><span class="s0">(fe(e)){</span><span class="s1">this</span><span class="s0">.jsxReadWord();</span><span class="s1">return</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(e===</span><span class="s3">62</span><span class="s0">){++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">this</span><span class="s0">.finishToken(</span><span class="s3">141</span><span class="s0">);</span><span class="s1">return</span><span class="s0">}</span><span class="s1">if</span><span class="s0">((e===</span><span class="s3">34</span><span class="s0">||e===</span><span class="s3">39</span><span class="s0">)&amp;&amp;s===x.j_oTag){</span><span class="s1">this</span><span class="s0">.jsxReadString(e);</span><span class="s1">return</span><span class="s0">}}</span><span class="s1">if</span><span class="s0">(e===</span><span class="s3">60</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.state.canStartJSXElement&amp;&amp;</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s3">1</span><span class="s0">)!==</span><span class="s3">33</span><span class="s0">){++</span><span class="s1">this</span><span class="s0">.state.pos,</span><span class="s1">this</span><span class="s0">.finishToken(</span><span class="s3">140</span><span class="s0">);</span><span class="s1">return</span><span class="s0">}super.getTokenFromCode(e)}updateContext(e){let{context:s,type:i}=</span><span class="s1">this</span><span class="s0">.state;</span><span class="s1">if</span><span class="s0">(i===</span><span class="s3">56</span><span class="s0">&amp;&amp;e===</span><span class="s3">140</span><span class="s0">)s.splice(-</span><span class="s3">2</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,x.j_cTag),</span><span class="s1">this</span><span class="s0">.state.canStartJSXElement=!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">else if</span><span class="s0">(i===</span><span class="s3">140</span><span class="s0">)s.push(x.j_oTag);</span><span class="s1">else if</span><span class="s0">(i===</span><span class="s3">141</span><span class="s0">){let a=s[s.length-1];a===x.j_oTag&amp;&amp;e===</span><span class="s3">56</span><span class="s0">||a===x.j_cTag?(s.pop(),</span><span class="s1">this</span><span class="s0">.state.canStartJSXElement=s[s.length-1]===x.j_expr):(</span><span class="s1">this</span><span class="s0">.setContext(x.j_expr),</span><span class="s1">this</span><span class="s0">.state.canStartJSXElement=!</span><span class="s3">0</span><span class="s0">)}</span><span class="s1">else this</span><span class="s0">.state.canStartJSXElement=se(i)}},sh=class extends rs{constructor(){super(...arguments),</span><span class="s1">this</span><span class="s0">.types=</span><span class="s1">new </span><span class="s0">Set,</span><span class="s1">this</span><span class="s0">.enums=</span><span class="s1">new </span><span class="s0">Set,</span><span class="s1">this</span><span class="s0">.constEnums=</span><span class="s1">new </span><span class="s0">Set,</span><span class="s1">this</span><span class="s0">.classes=</span><span class="s1">new </span><span class="s0">Set,</span><span class="s1">this</span><span class="s0">.exportOnlyBindings=</span><span class="s1">new </span><span class="s0">Set}},rh=class extends is{constructor(){super(...arguments),</span><span class="s1">this</span><span class="s0">.importsStack=[]}createScope(t){</span><span class="s1">return this</span><span class="s0">.importsStack.push(</span><span class="s1">new </span><span class="s0">Set),</span><span class="s1">new </span><span class="s0">sh(t)}enter(t){t==Oe&amp;&amp;</span><span class="s1">this</span><span class="s0">.importsStack.push(</span><span class="s1">new </span><span class="s0">Set),super.enter(t)}exit(){let t=super.exit();</span><span class="s1">return </span><span class="s0">t==Oe&amp;&amp;</span><span class="s1">this</span><span class="s0">.importsStack.pop(),t}hasImport(t,r){let e=</span><span class="s1">this</span><span class="s0">.importsStack.length;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.importsStack[e-1].has(t))</span><span class="s1">return</span><span class="s0">!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(!r&amp;&amp;e&gt;</span><span class="s3">1</span><span class="s0">){</span><span class="s1">for</span><span class="s0">(let s=</span><span class="s3">0</span><span class="s0">;s&lt;e-1;s++)</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.importsStack[s].has(t))</span><span class="s1">return</span><span class="s0">!</span><span class="s3">0</span><span class="s0">}</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">}declareName(t,r,e){</span><span class="s1">if</span><span class="s0">(r&amp;Ve){</span><span class="s1">this</span><span class="s0">.hasImport(t,!</span><span class="s3">0</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.parser.raise(f.VarRedeclaration,{at:e,identifierName:t}),</span><span class="s1">this</span><span class="s0">.importsStack[</span><span class="s1">this</span><span class="s0">.importsStack.length-1].add(t);</span><span class="s1">return</span><span class="s0">}let s=</span><span class="s1">this</span><span class="s0">.currentScope();</span><span class="s1">if</span><span class="s0">(r&amp;Yt){</span><span class="s1">this</span><span class="s0">.maybeExportDefined(s,t),s.exportOnlyBindings.add(t);</span><span class="s1">return</span><span class="s0">}super.declareName(t,r,e),r&amp;Ce&amp;&amp;(r&amp;le||(</span><span class="s1">this</span><span class="s0">.checkRedeclarationInScope(s,t,r,e),</span><span class="s1">this</span><span class="s0">.maybeExportDefined(s,t)),s.types.add(t)),r&amp;Jt&amp;&amp;s.enums.add(t),r&amp;Xt&amp;&amp;s.constEnums.add(t),r&amp;ft&amp;&amp;s.classes.add(t)}isRedeclaredInScope(t,r,e){</span><span class="s1">if</span><span class="s0">(t.enums.has(r)){</span><span class="s1">if</span><span class="s0">(e&amp;Jt){let s=!!(e&amp;Xt),i=t.constEnums.has(r);</span><span class="s1">return </span><span class="s0">s!==i}</span><span class="s1">return</span><span class="s0">!</span><span class="s3">0</span><span class="s0">}</span><span class="s1">return </span><span class="s0">e&amp;ft&amp;&amp;t.classes.has(r)?t.lexical.has(r)?!!(e&amp;le):!</span><span class="s3">1</span><span class="s0">:e&amp;Ce&amp;&amp;t.types.has(r)?!</span><span class="s3">0</span><span class="s0">:super.isRedeclaredInScope(t,r,e)}checkLocalExport(t){let{name:r}=t;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.hasImport(r))</span><span class="s1">return</span><span class="s0">;let e=</span><span class="s1">this</span><span class="s0">.scopeStack.length;</span><span class="s1">for</span><span class="s0">(let s=e-1;s&gt;=</span><span class="s3">0</span><span class="s0">;s--){let i=</span><span class="s1">this</span><span class="s0">.scopeStack[s];</span><span class="s1">if</span><span class="s0">(i.types.has(r)||i.exportOnlyBindings.has(r))</span><span class="s1">return</span><span class="s0">}super.checkLocalExport(t)}},ih=(t,r)=&gt;Object.hasOwnProperty.call(t,r)&amp;&amp;t[r],Ur=t=&gt;t.type===</span><span class="s2">&quot;ParenthesizedExpression&quot;</span><span class="s0">?Ur(t.expression):t,ah=class extends Wl{toAssignable(t){let r=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">1</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">1</span><span class="s0">]:!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">var </span><span class="s0">e,s;let i;</span><span class="s1">switch</span><span class="s0">((t.type===</span><span class="s2">&quot;ParenthesizedExpression&quot;</span><span class="s0">||(e=t.extra)!=</span><span class="s1">null</span><span class="s0">&amp;&amp;e.parenthesized)&amp;&amp;(i=Ur(t),r?i.type===</span><span class="s2">&quot;Identifier&quot;</span><span class="s0">?</span><span class="s1">this</span><span class="s0">.expressionScope.recordArrowParameterBindingError(f.InvalidParenthesizedAssignment,{at:t}):i.type!==</span><span class="s2">&quot;MemberExpression&quot;</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.InvalidParenthesizedAssignment,{at:t}):</span><span class="s1">this</span><span class="s0">.raise(f.InvalidParenthesizedAssignment,{at:t})),t.type){</span><span class="s1">case</span><span class="s2">&quot;Identifier&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;ObjectPattern&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;ArrayPattern&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;AssignmentPattern&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;RestElement&quot;</span><span class="s0">:</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;ObjectExpression&quot;</span><span class="s0">:t.type=</span><span class="s2">&quot;ObjectPattern&quot;</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(let n=</span><span class="s3">0</span><span class="s0">,o=t.properties.length,u=o-1;n&lt;o;n++){</span><span class="s1">var </span><span class="s0">a;let c=t.properties[n],y=n===u;</span><span class="s1">this</span><span class="s0">.toAssignableObjectExpressionProp(c,y,r),y&amp;&amp;c.type===</span><span class="s2">&quot;RestElement&quot;</span><span class="s0">&amp;&amp;(a=t.extra)!=</span><span class="s1">null</span><span class="s0">&amp;&amp;a.trailingCommaLoc&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.RestTrailingComma,{at:t.extra.trailingCommaLoc})}</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;ObjectProperty&quot;</span><span class="s0">:{let{key:n,value:o}=t;</span><span class="s1">this</span><span class="s0">.isPrivateName(n)&amp;&amp;</span><span class="s1">this</span><span class="s0">.classScope.usePrivateName(</span><span class="s1">this</span><span class="s0">.getPrivateNameSV(n),n.loc.start),</span><span class="s1">this</span><span class="s0">.toAssignable(o,r);</span><span class="s1">break</span><span class="s0">}</span><span class="s1">case</span><span class="s2">&quot;SpreadElement&quot;</span><span class="s0">:</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.&quot;</span><span class="s0">);</span><span class="s1">case</span><span class="s2">&quot;ArrayExpression&quot;</span><span class="s0">:t.type=</span><span class="s2">&quot;ArrayPattern&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.toAssignableList(t.elements,(s=t.extra)==</span><span class="s1">null</span><span class="s0">?</span><span class="s1">void </span><span class="s3">0</span><span class="s0">:s.trailingCommaLoc,r);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;AssignmentExpression&quot;</span><span class="s0">:t.operator!==</span><span class="s2">&quot;=&quot;</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.MissingEqInAssignment,{at:t.left.loc.end}),t.type=</span><span class="s2">&quot;AssignmentPattern&quot;</span><span class="s0">,</span><span class="s1">delete </span><span class="s0">t.operator,</span><span class="s1">this</span><span class="s0">.toAssignable(t.left,r);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;ParenthesizedExpression&quot;</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.toAssignable(i,r);</span><span class="s1">break</span><span class="s0">}}toAssignableObjectExpressionProp(t,r,e){</span><span class="s1">if</span><span class="s0">(t.type===</span><span class="s2">&quot;ObjectMethod&quot;</span><span class="s0">)</span><span class="s1">this</span><span class="s0">.raise(t.kind===</span><span class="s2">&quot;get&quot;</span><span class="s0">||t.kind===</span><span class="s2">&quot;set&quot;</span><span class="s0">?f.PatternHasAccessor:f.PatternHasMethod,{at:t.key});</span><span class="s1">else if</span><span class="s0">(t.type===</span><span class="s2">&quot;SpreadElement&quot;</span><span class="s0">){t.type=</span><span class="s2">&quot;RestElement&quot;</span><span class="s0">;let s=t.argument;</span><span class="s1">this</span><span class="s0">.checkToRestConversion(s,!</span><span class="s3">1</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.toAssignable(s,e),r||</span><span class="s1">this</span><span class="s0">.raise(f.RestTrailingComma,{at:t})}</span><span class="s1">else this</span><span class="s0">.toAssignable(t,e)}toAssignableList(t,r,e){let s=t.length-1;</span><span class="s1">for</span><span class="s0">(let i=</span><span class="s3">0</span><span class="s0">;i&lt;=s;i++){let a=t[i];</span><span class="s1">if</span><span class="s0">(a){</span><span class="s1">if</span><span class="s0">(a.type===</span><span class="s2">&quot;SpreadElement&quot;</span><span class="s0">){a.type=</span><span class="s2">&quot;RestElement&quot;</span><span class="s0">;let n=a.argument;</span><span class="s1">this</span><span class="s0">.checkToRestConversion(n,!</span><span class="s3">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.toAssignable(n,e)}</span><span class="s1">else this</span><span class="s0">.toAssignable(a,e);a.type===</span><span class="s2">&quot;RestElement&quot;</span><span class="s0">&amp;&amp;(i&lt;s?</span><span class="s1">this</span><span class="s0">.raise(f.RestTrailingComma,{at:a}):r&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.RestTrailingComma,{at:r}))}}}isAssignable(t,r){</span><span class="s1">switch</span><span class="s0">(t.type){</span><span class="s1">case</span><span class="s2">&quot;Identifier&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;ObjectPattern&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;ArrayPattern&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;AssignmentPattern&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;RestElement&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s0">!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;ObjectExpression&quot;</span><span class="s0">:{let e=t.properties.length-1;</span><span class="s1">return </span><span class="s0">t.properties.every((s,i)=&gt;s.type!==</span><span class="s2">&quot;ObjectMethod&quot;</span><span class="s0">&amp;&amp;(i===e||s.type!==</span><span class="s2">&quot;SpreadElement&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.isAssignable(s))}</span><span class="s1">case</span><span class="s2">&quot;ObjectProperty&quot;</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.isAssignable(t.value);</span><span class="s1">case</span><span class="s2">&quot;SpreadElement&quot;</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.isAssignable(t.argument);</span><span class="s1">case</span><span class="s2">&quot;ArrayExpression&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">t.elements.every(e=&gt;e===</span><span class="s1">null</span><span class="s0">||</span><span class="s1">this</span><span class="s0">.isAssignable(e));</span><span class="s1">case</span><span class="s2">&quot;AssignmentExpression&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">t.operator===</span><span class="s2">&quot;=&quot;</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;ParenthesizedExpression&quot;</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.isAssignable(t.expression);</span><span class="s1">case</span><span class="s2">&quot;MemberExpression&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;OptionalMemberExpression&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s0">!r;</span><span class="s1">default</span><span class="s0">:</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">}}toReferencedList(t,r){</span><span class="s1">return </span><span class="s0">t}toReferencedListDeep(t,r){</span><span class="s1">this</span><span class="s0">.toReferencedList(t,r);</span><span class="s1">for</span><span class="s0">(let e of t)(e==</span><span class="s1">null</span><span class="s0">?</span><span class="s1">void </span><span class="s3">0</span><span class="s0">:e.type)===</span><span class="s2">&quot;ArrayExpression&quot;</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.toReferencedListDeep(e.elements)}parseSpread(t){let r=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),r.argument=</span><span class="s1">this</span><span class="s0">.parseMaybeAssignAllowIn(t,</span><span class="s1">void </span><span class="s3">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s2">&quot;SpreadElement&quot;</span><span class="s0">)}parseRestBinding(){let t=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),t.argument=</span><span class="s1">this</span><span class="s0">.parseBindingAtom(),</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s2">&quot;RestElement&quot;</span><span class="s0">)}parseBindingAtom(){</span><span class="s1">switch</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.type){</span><span class="s1">case </span><span class="s3">0</span><span class="s0">:{let t=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),t.elements=</span><span class="s1">this</span><span class="s0">.parseBindingList(</span><span class="s3">3</span><span class="s0">,</span><span class="s3">93</span><span class="s0">,</span><span class="s3">1</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s2">&quot;ArrayPattern&quot;</span><span class="s0">)}</span><span class="s1">case </span><span class="s3">5</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.parseObjectLike(</span><span class="s3">8</span><span class="s0">,!</span><span class="s3">0</span><span class="s0">)}</span><span class="s1">return this</span><span class="s0">.parseIdentifier()}parseBindingList(t,r,e){let s=e&amp;</span><span class="s3">1</span><span class="s0">,i=[],a=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(;!</span><span class="s1">this</span><span class="s0">.eat(t);)</span><span class="s1">if</span><span class="s0">(a?a=!</span><span class="s3">1</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">12</span><span class="s0">),s&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">12</span><span class="s0">))i.push(</span><span class="s1">null</span><span class="s0">);</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(t))</span><span class="s1">break</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">21</span><span class="s0">)){</span><span class="s1">if</span><span class="s0">(i.push(</span><span class="s1">this</span><span class="s0">.parseAssignableListItemTypes(</span><span class="s1">this</span><span class="s0">.parseRestBinding(),e)),!</span><span class="s1">this</span><span class="s0">.checkCommaAfterRest(r)){</span><span class="s1">this</span><span class="s0">.expect(t);</span><span class="s1">break</span><span class="s0">}}</span><span class="s1">else</span><span class="s0">{let n=[];</span><span class="s1">for</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">26</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s2">&quot;decorators&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.UnsupportedParameterDecorator,{at:</span><span class="s1">this</span><span class="s0">.state.startLoc});</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">26</span><span class="s0">);)n.push(</span><span class="s1">this</span><span class="s0">.parseDecorator());i.push(</span><span class="s1">this</span><span class="s0">.parseAssignableListItem(e,n))}}</span><span class="s1">return </span><span class="s0">i}parseBindingRestProperty(t){</span><span class="s1">return this</span><span class="s0">.next(),t.argument=</span><span class="s1">this</span><span class="s0">.parseIdentifier(),</span><span class="s1">this</span><span class="s0">.checkCommaAfterRest(</span><span class="s3">125</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s2">&quot;RestElement&quot;</span><span class="s0">)}parseBindingProperty(){let t=</span><span class="s1">this</span><span class="s0">.startNode(),{type:r,startLoc:e}=</span><span class="s1">this</span><span class="s0">.state;</span><span class="s1">return </span><span class="s0">r===</span><span class="s3">21</span><span class="s0">?</span><span class="s1">this</span><span class="s0">.parseBindingRestProperty(t):(r===</span><span class="s3">136</span><span class="s0">?(</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s2">&quot;destructuringPrivate&quot;</span><span class="s0">,e),</span><span class="s1">this</span><span class="s0">.classScope.usePrivateName(</span><span class="s1">this</span><span class="s0">.state.value,e),t.key=</span><span class="s1">this</span><span class="s0">.parsePrivateName()):</span><span class="s1">this</span><span class="s0">.parsePropertyName(t),t.method=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.parseObjPropValue(t,e,!</span><span class="s3">1</span><span class="s0">,!</span><span class="s3">1</span><span class="s0">,!</span><span class="s3">0</span><span class="s0">,!</span><span class="s3">1</span><span class="s0">))}parseAssignableListItem(t,r){let e=</span><span class="s1">this</span><span class="s0">.parseMaybeDefault();</span><span class="s1">this</span><span class="s0">.parseAssignableListItemTypes(e,t);let s=</span><span class="s1">this</span><span class="s0">.parseMaybeDefault(e.loc.start,e);</span><span class="s1">return </span><span class="s0">r.length&amp;&amp;(e.decorators=r),s}parseAssignableListItemTypes(t,r){</span><span class="s1">return </span><span class="s0">t}parseMaybeDefault(t,r){</span><span class="s1">var </span><span class="s0">e,s;</span><span class="s1">if</span><span class="s0">((e=t)!=</span><span class="s1">null</span><span class="s0">||(t=</span><span class="s1">this</span><span class="s0">.state.startLoc),r=(s=r)!=</span><span class="s1">null</span><span class="s0">?s:</span><span class="s1">this</span><span class="s0">.parseBindingAtom(),!</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">29</span><span class="s0">))</span><span class="s1">return </span><span class="s0">r;let i=</span><span class="s1">this</span><span class="s0">.startNodeAt(t);</span><span class="s1">return </span><span class="s0">i.left=r,i.right=</span><span class="s1">this</span><span class="s0">.parseMaybeAssignAllowIn(),</span><span class="s1">this</span><span class="s0">.finishNode(i,</span><span class="s2">&quot;AssignmentPattern&quot;</span><span class="s0">)}isValidLVal(t,r,e){</span><span class="s1">return </span><span class="s0">ih({AssignmentPattern:</span><span class="s2">&quot;left&quot;</span><span class="s0">,RestElement:</span><span class="s2">&quot;argument&quot;</span><span class="s0">,ObjectProperty:</span><span class="s2">&quot;value&quot;</span><span class="s0">,ParenthesizedExpression:</span><span class="s2">&quot;expression&quot;</span><span class="s0">,ArrayPattern:</span><span class="s2">&quot;elements&quot;</span><span class="s0">,ObjectPattern:</span><span class="s2">&quot;properties&quot;</span><span class="s0">},t)}checkLVal(t,r){let{</span><span class="s1">in</span><span class="s0">:e,binding:s=Pe,checkClashes:i=!</span><span class="s3">1</span><span class="s0">,strictModeChanged:a=!</span><span class="s3">1</span><span class="s0">,hasParenthesizedAncestor:n=!</span><span class="s3">1</span><span class="s0">}=r;</span><span class="s1">var </span><span class="s0">o;let u=t.type;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isObjectMethod(t))</span><span class="s1">return</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(u===</span><span class="s2">&quot;MemberExpression&quot;</span><span class="s0">){s!==Pe&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.InvalidPropertyBindingPattern,{at:t});</span><span class="s1">return</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(u===</span><span class="s2">&quot;Identifier&quot;</span><span class="s0">){</span><span class="s1">this</span><span class="s0">.checkIdentifier(t,s,a);let{name:C}=t;i&amp;&amp;(i.has(C)?</span><span class="s1">this</span><span class="s0">.raise(f.ParamDupe,{at:t}):i.add(C));</span><span class="s1">return</span><span class="s0">}let c=</span><span class="s1">this</span><span class="s0">.isValidLVal(u,!(n||(o=t.extra)!=</span><span class="s1">null</span><span class="s0">&amp;&amp;o.parenthesized)&amp;&amp;e.type===</span><span class="s2">&quot;AssignmentExpression&quot;</span><span class="s0">,s);</span><span class="s1">if</span><span class="s0">(c===!</span><span class="s3">0</span><span class="s0">)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(c===!</span><span class="s3">1</span><span class="s0">){let C=s===Pe?f.InvalidLhs:f.InvalidLhsBinding;</span><span class="s1">this</span><span class="s0">.raise(C,{at:t,ancestor:e});</span><span class="s1">return</span><span class="s0">}let[y,g]=Array.isArray(c)?c:[c,u===</span><span class="s2">&quot;ParenthesizedExpression&quot;</span><span class="s0">],T=u===</span><span class="s2">&quot;ArrayPattern&quot;</span><span class="s0">||u===</span><span class="s2">&quot;ObjectPattern&quot;</span><span class="s0">||u===</span><span class="s2">&quot;ParenthesizedExpression&quot;</span><span class="s0">?{type:u}:e;</span><span class="s1">for</span><span class="s0">(let C of[].concat(t[y]))C&amp;&amp;</span><span class="s1">this</span><span class="s0">.checkLVal(C,{</span><span class="s1">in</span><span class="s0">:T,binding:s,checkClashes:i,strictModeChanged:a,hasParenthesizedAncestor:g})}checkIdentifier(t,r){let e=arguments.length&gt;</span><span class="s3">2</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">2</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">2</span><span class="s0">]:!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.state.strict&amp;&amp;(e?xr(t.name,</span><span class="s1">this</span><span class="s0">.inModule):yr(t.name))&amp;&amp;(r===Pe?</span><span class="s1">this</span><span class="s0">.raise(f.StrictEvalArguments,{at:t,referenceName:t.name}):</span><span class="s1">this</span><span class="s0">.raise(f.StrictEvalArgumentsBinding,{at:t,bindingName:t.name})),r&amp;dt&amp;&amp;t.name===</span><span class="s2">&quot;let&quot;</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.LetInLexicalBinding,{at:t}),r&amp;Pe||</span><span class="s1">this</span><span class="s0">.declareNameFromIdentifier(t,r)}declareNameFromIdentifier(t,r){</span><span class="s1">this</span><span class="s0">.scope.declareName(t.name,r,t.loc.start)}checkToRestConversion(t,r){</span><span class="s1">switch</span><span class="s0">(t.type){</span><span class="s1">case</span><span class="s2">&quot;ParenthesizedExpression&quot;</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.checkToRestConversion(t.expression,r);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;Identifier&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;MemberExpression&quot;</span><span class="s0">:</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;ArrayExpression&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;ObjectExpression&quot;</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(r)</span><span class="s1">break</span><span class="s0">;</span><span class="s1">default</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.raise(f.InvalidRestAssignmentPattern,{at:t})}}checkCommaAfterRest(t){</span><span class="s1">return this</span><span class="s0">.match(</span><span class="s3">12</span><span class="s0">)?(</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.lookaheadCharCode()===t?f.RestTrailingComma:f.ElementAfterRest,{at:</span><span class="s1">this</span><span class="s0">.state.startLoc}),!</span><span class="s3">0</span><span class="s0">):!</span><span class="s3">1</span><span class="s0">}},nh=(t,r)=&gt;Object.hasOwnProperty.call(t,r)&amp;&amp;t[r];</span><span class="s1">function </span><span class="s0">oh(t){</span><span class="s1">if</span><span class="s0">(t==</span><span class="s1">null</span><span class="s0">)</span><span class="s1">throw new </span><span class="s0">Error(`Unexpected ${t} value.`);</span><span class="s1">return </span><span class="s0">t}</span><span class="s1">function </span><span class="s0">$r(t){</span><span class="s1">if</span><span class="s0">(!t)</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;Assert fail&quot;</span><span class="s0">)}</span><span class="s1">var </span><span class="s0">I=pe`typescript`({AbstractMethodHasImplementation:t=&gt;{let{methodName:r}=t;</span><span class="s1">return</span><span class="s0">`Method </span><span class="s2">'${r}' </span><span class="s0">cannot have an implementation because it is marked abstract.`},AbstractPropertyHasInitializer:t=&gt;{let{propertyName:r}=t;</span><span class="s1">return</span><span class="s0">`Property </span><span class="s2">'${r}' </span><span class="s0">cannot have an initializer because it is marked abstract.`},AccesorCannotDeclareThisParameter:</span><span class="s2">&quot;'get' and 'set' accessors cannot declare 'this' parameters.&quot;</span><span class="s0">,AccesorCannotHaveTypeParameters:</span><span class="s2">&quot;An accessor cannot have type parameters.&quot;</span><span class="s0">,AccessorCannotBeOptional:</span><span class="s2">&quot;An 'accessor' property cannot be declared optional.&quot;</span><span class="s0">,ClassMethodHasDeclare:</span><span class="s2">&quot;Class methods cannot have the 'declare' modifier.&quot;</span><span class="s0">,ClassMethodHasReadonly:</span><span class="s2">&quot;Class methods cannot have the 'readonly' modifier.&quot;</span><span class="s0">,ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference:</span><span class="s2">&quot;A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.&quot;</span><span class="s0">,ConstructorHasTypeParameters:</span><span class="s2">&quot;Type parameters cannot appear on a constructor declaration.&quot;</span><span class="s0">,DeclareAccessor:t=&gt;{let{kind:r}=t;</span><span class="s1">return</span><span class="s0">`</span><span class="s2">'declare' </span><span class="s0">is not allowed </span><span class="s1">in </span><span class="s0">${r}ters.`},DeclareClassFieldHasInitializer:</span><span class="s2">&quot;Initializers are not allowed in ambient contexts.&quot;</span><span class="s0">,DeclareFunctionHasImplementation:</span><span class="s2">&quot;An implementation cannot be declared in ambient contexts.&quot;</span><span class="s0">,DuplicateAccessibilityModifier:t=&gt;{let{modifier:r}=t;</span><span class="s1">return</span><span class="s2">&quot;Accessibility modifier already seen.&quot;</span><span class="s0">},DuplicateModifier:t=&gt;{let{modifier:r}=t;</span><span class="s1">return</span><span class="s0">`Duplicate modifier: </span><span class="s2">'${r}'</span><span class="s0">.`},EmptyHeritageClauseType:t=&gt;{let{token:r}=t;</span><span class="s1">return</span><span class="s0">`</span><span class="s2">'${r}' </span><span class="s0">list cannot be empty.`},EmptyTypeArguments:</span><span class="s2">&quot;Type argument list cannot be empty.&quot;</span><span class="s0">,EmptyTypeParameters:</span><span class="s2">&quot;Type parameter list cannot be empty.&quot;</span><span class="s0">,ExpectedAmbientAfterExportDeclare:</span><span class="s2">&quot;'export declare' must be followed by an ambient declaration.&quot;</span><span class="s0">,ImportAliasHasImportType:</span><span class="s2">&quot;An import alias can not use 'import type'.&quot;</span><span class="s0">,ImportReflectionHasImportType:</span><span class="s2">&quot;An `import module` declaration can not use `type` modifier&quot;</span><span class="s0">,IncompatibleModifiers:t=&gt;{let{modifiers:r}=t;</span><span class="s1">return</span><span class="s0">`</span><span class="s2">'${r[0]}' </span><span class="s0">modifier cannot be used </span><span class="s1">with </span><span class="s2">'${r[1]}' </span><span class="s0">modifier.`},IndexSignatureHasAbstract:</span><span class="s2">&quot;Index signatures cannot have the 'abstract' modifier.&quot;</span><span class="s0">,IndexSignatureHasAccessibility:t=&gt;{let{modifier:r}=t;</span><span class="s1">return</span><span class="s0">`Index signatures cannot have an accessibility modifier (</span><span class="s2">'${r}'</span><span class="s0">).`},IndexSignatureHasDeclare:</span><span class="s2">&quot;Index signatures cannot have the 'declare' modifier.&quot;</span><span class="s0">,IndexSignatureHasOverride:</span><span class="s2">&quot;'override' modifier cannot appear on an index signature.&quot;</span><span class="s0">,IndexSignatureHasStatic:</span><span class="s2">&quot;Index signatures cannot have the 'static' modifier.&quot;</span><span class="s0">,InitializerNotAllowedInAmbientContext:</span><span class="s2">&quot;Initializers are not allowed in ambient contexts.&quot;</span><span class="s0">,InvalidModifierOnTypeMember:t=&gt;{let{modifier:r}=t;</span><span class="s1">return</span><span class="s0">`</span><span class="s2">'${r}' </span><span class="s0">modifier cannot appear on a type member.`},InvalidModifierOnTypeParameter:t=&gt;{let{modifier:r}=t;</span><span class="s1">return</span><span class="s0">`</span><span class="s2">'${r}' </span><span class="s0">modifier cannot appear on a type parameter.`},InvalidModifierOnTypeParameterPositions:t=&gt;{let{modifier:r}=t;</span><span class="s1">return</span><span class="s0">`</span><span class="s2">'${r}' </span><span class="s0">modifier can only appear on a type parameter of a class, interface or type alias.`},InvalidModifiersOrder:t=&gt;{let{orderedModifiers:r}=t;</span><span class="s1">return</span><span class="s0">`</span><span class="s2">'${r[0]}' </span><span class="s0">modifier must precede </span><span class="s2">'${r[1]}' </span><span class="s0">modifier.`},InvalidPropertyAccessAfterInstantiationExpression:</span><span class="s2">&quot;Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.&quot;</span><span class="s0">,InvalidTupleMemberLabel:</span><span class="s2">&quot;Tuple members must be labeled with a simple identifier.&quot;</span><span class="s0">,MissingInterfaceName:</span><span class="s2">&quot;'interface' declarations must be followed by an identifier.&quot;</span><span class="s0">,MixedLabeledAndUnlabeledElements:</span><span class="s2">&quot;Tuple members must all have names or all not have names.&quot;</span><span class="s0">,NonAbstractClassHasAbstractMethod:</span><span class="s2">&quot;Abstract methods can only appear within an abstract class.&quot;</span><span class="s0">,NonClassMethodPropertyHasAbstractModifer:</span><span class="s2">&quot;'abstract' modifier can only appear on a class, method, or property declaration.&quot;</span><span class="s0">,OptionalTypeBeforeRequired:</span><span class="s2">&quot;A required element cannot follow an optional element.&quot;</span><span class="s0">,OverrideNotInSubClass:</span><span class="s2">&quot;This member cannot have an 'override' modifier because its containing class does not extend another class.&quot;</span><span class="s0">,PatternIsOptional:</span><span class="s2">&quot;A binding pattern parameter cannot be optional in an implementation signature.&quot;</span><span class="s0">,PrivateElementHasAbstract:</span><span class="s2">&quot;Private elements cannot have the 'abstract' modifier.&quot;</span><span class="s0">,PrivateElementHasAccessibility:t=&gt;{let{modifier:r}=t;</span><span class="s1">return</span><span class="s0">`Private elements cannot have an accessibility modifier (</span><span class="s2">'${r}'</span><span class="s0">).`},ReadonlyForMethodSignature:</span><span class="s2">&quot;'readonly' modifier can only appear on a property declaration or index signature.&quot;</span><span class="s0">,ReservedArrowTypeParam:</span><span class="s2">&quot;This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `&lt;T,&gt;() =&gt; ...`.&quot;</span><span class="s0">,ReservedTypeAssertion:</span><span class="s2">&quot;This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.&quot;</span><span class="s0">,SetAccesorCannotHaveOptionalParameter:</span><span class="s2">&quot;A 'set' accessor cannot have an optional parameter.&quot;</span><span class="s0">,SetAccesorCannotHaveRestParameter:</span><span class="s2">&quot;A 'set' accessor cannot have rest parameter.&quot;</span><span class="s0">,SetAccesorCannotHaveReturnType:</span><span class="s2">&quot;A 'set' accessor cannot have a return type annotation.&quot;</span><span class="s0">,SingleTypeParameterWithoutTrailingComma:t=&gt;{let{typeParameterName:r}=t;</span><span class="s1">return</span><span class="s0">`Single type parameter ${r} should have a trailing comma. Example usage: &lt;${r},&gt;.`},StaticBlockCannotHaveModifier:</span><span class="s2">&quot;Static class blocks cannot have any modifier.&quot;</span><span class="s0">,TupleOptionalAfterType:</span><span class="s2">&quot;A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).&quot;</span><span class="s0">,TypeAnnotationAfterAssign:</span><span class="s2">&quot;Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.&quot;</span><span class="s0">,TypeImportCannotSpecifyDefaultAndNamed:</span><span class="s2">&quot;A type-only import can specify a default import or named bindings, but not both.&quot;</span><span class="s0">,TypeModifierIsUsedInTypeExports:</span><span class="s2">&quot;The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.&quot;</span><span class="s0">,TypeModifierIsUsedInTypeImports:</span><span class="s2">&quot;The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.&quot;</span><span class="s0">,UnexpectedParameterModifier:</span><span class="s2">&quot;A parameter property is only allowed in a constructor implementation.&quot;</span><span class="s0">,UnexpectedReadonly:</span><span class="s2">&quot;'readonly' type modifier is only permitted on array and tuple literal types.&quot;</span><span class="s0">,UnexpectedTypeAnnotation:</span><span class="s2">&quot;Did not expect a type annotation here.&quot;</span><span class="s0">,UnexpectedTypeCastInParameter:</span><span class="s2">&quot;Unexpected type cast in parameter position.&quot;</span><span class="s0">,UnsupportedImportTypeArgument:</span><span class="s2">&quot;Argument in a type import must be a string literal.&quot;</span><span class="s0">,UnsupportedParameterPropertyKind:</span><span class="s2">&quot;A parameter property may not be declared using a binding pattern.&quot;</span><span class="s0">,UnsupportedSignatureParameterKind:t=&gt;{let{type:r}=t;</span><span class="s1">return</span><span class="s0">`Name </span><span class="s1">in </span><span class="s0">a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${r}.`}});</span><span class="s1">function </span><span class="s0">lh(t){</span><span class="s1">switch</span><span class="s0">(t){</span><span class="s1">case</span><span class="s2">&quot;any&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s2">&quot;TSAnyKeyword&quot;</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;boolean&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s2">&quot;TSBooleanKeyword&quot;</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;bigint&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s2">&quot;TSBigIntKeyword&quot;</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;never&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s2">&quot;TSNeverKeyword&quot;</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;number&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s2">&quot;TSNumberKeyword&quot;</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;object&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s2">&quot;TSObjectKeyword&quot;</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;string&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s2">&quot;TSStringKeyword&quot;</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;symbol&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s2">&quot;TSSymbolKeyword&quot;</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;undefined&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s2">&quot;TSUndefinedKeyword&quot;</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;unknown&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s2">&quot;TSUnknownKeyword&quot;</span><span class="s0">;</span><span class="s1">default</span><span class="s0">:</span><span class="s1">return</span><span class="s0">}}</span><span class="s1">function </span><span class="s0">Hr(t){</span><span class="s1">return </span><span class="s0">t===</span><span class="s2">&quot;private&quot;</span><span class="s0">||t===</span><span class="s2">&quot;public&quot;</span><span class="s0">||t===</span><span class="s2">&quot;protected&quot;</span><span class="s0">}</span><span class="s1">function </span><span class="s0">hh(t){</span><span class="s1">return </span><span class="s0">t===</span><span class="s2">&quot;in&quot;</span><span class="s0">||t===</span><span class="s2">&quot;out&quot;</span><span class="s0">}</span><span class="s1">var </span><span class="s0">uh=t=&gt;class extends t{constructor(){super(...arguments),</span><span class="s1">this</span><span class="s0">.tsParseInOutModifiers=</span><span class="s1">this</span><span class="s0">.tsParseModifiers.bind(</span><span class="s1">this</span><span class="s0">,{allowedModifiers:[</span><span class="s2">&quot;in&quot;</span><span class="s0">,</span><span class="s2">&quot;out&quot;</span><span class="s0">],disallowedModifiers:[</span><span class="s2">&quot;const&quot;</span><span class="s0">,</span><span class="s2">&quot;public&quot;</span><span class="s0">,</span><span class="s2">&quot;private&quot;</span><span class="s0">,</span><span class="s2">&quot;protected&quot;</span><span class="s0">,</span><span class="s2">&quot;readonly&quot;</span><span class="s0">,</span><span class="s2">&quot;declare&quot;</span><span class="s0">,</span><span class="s2">&quot;abstract&quot;</span><span class="s0">,</span><span class="s2">&quot;override&quot;</span><span class="s0">],errorTemplate:I.InvalidModifierOnTypeParameter}),</span><span class="s1">this</span><span class="s0">.tsParseConstModifier=</span><span class="s1">this</span><span class="s0">.tsParseModifiers.bind(</span><span class="s1">this</span><span class="s0">,{allowedModifiers:[</span><span class="s2">&quot;const&quot;</span><span class="s0">],disallowedModifiers:[</span><span class="s2">&quot;in&quot;</span><span class="s0">,</span><span class="s2">&quot;out&quot;</span><span class="s0">],errorTemplate:I.InvalidModifierOnTypeParameterPositions}),</span><span class="s1">this</span><span class="s0">.tsParseInOutConstModifiers=</span><span class="s1">this</span><span class="s0">.tsParseModifiers.bind(</span><span class="s1">this</span><span class="s0">,{allowedModifiers:[</span><span class="s2">&quot;in&quot;</span><span class="s0">,</span><span class="s2">&quot;out&quot;</span><span class="s0">,</span><span class="s2">&quot;const&quot;</span><span class="s0">],disallowedModifiers:[</span><span class="s2">&quot;public&quot;</span><span class="s0">,</span><span class="s2">&quot;private&quot;</span><span class="s0">,</span><span class="s2">&quot;protected&quot;</span><span class="s0">,</span><span class="s2">&quot;readonly&quot;</span><span class="s0">,</span><span class="s2">&quot;declare&quot;</span><span class="s0">,</span><span class="s2">&quot;abstract&quot;</span><span class="s0">,</span><span class="s2">&quot;override&quot;</span><span class="s0">],errorTemplate:I.InvalidModifierOnTypeParameter})}getScopeHandler(){</span><span class="s1">return </span><span class="s0">rh}tsIsIdentifier(){</span><span class="s1">return </span><span class="s0">q(</span><span class="s1">this</span><span class="s0">.state.type)}tsTokenCanFollowModifier(){</span><span class="s1">return</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">0</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">5</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">55</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">21</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">136</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.isLiteralPropertyName())&amp;&amp;!</span><span class="s1">this</span><span class="s0">.hasPrecedingLineBreak()}tsNextTokenCanFollowModifier(){</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.tsTokenCanFollowModifier()}tsParseModifier(e,s){</span><span class="s1">if</span><span class="s0">(!q(</span><span class="s1">this</span><span class="s0">.state.type)&amp;&amp;</span><span class="s1">this</span><span class="s0">.state.type!==</span><span class="s3">58</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.state.type!==</span><span class="s3">75</span><span class="s0">)</span><span class="s1">return</span><span class="s0">;let i=</span><span class="s1">this</span><span class="s0">.state.value;</span><span class="s1">if</span><span class="s0">(e.indexOf(i)!==-</span><span class="s3">1</span><span class="s0">){</span><span class="s1">if</span><span class="s0">(s&amp;&amp;</span><span class="s1">this</span><span class="s0">.tsIsStartOfStaticBlocks())</span><span class="s1">return</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.tsTryParse(</span><span class="s1">this</span><span class="s0">.tsNextTokenCanFollowModifier.bind(</span><span class="s1">this</span><span class="s0">)))</span><span class="s1">return </span><span class="s0">i}}tsParseModifiers(e,s){let{allowedModifiers:i,disallowedModifiers:a,stopOnStartOfClassStaticBlock:n,errorTemplate:o=I.InvalidModifierOnTypeMember}=e,u=(y,g,T,C)=&gt;{g===T&amp;&amp;s[C]&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(I.InvalidModifiersOrder,{at:y,orderedModifiers:[T,C]})},c=(y,g,T,C)=&gt;{(s[T]&amp;&amp;g===C||s[C]&amp;&amp;g===T)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(I.IncompatibleModifiers,{at:y,modifiers:[T,C]})};</span><span class="s1">for</span><span class="s0">(;;){let{startLoc:y}=</span><span class="s1">this</span><span class="s0">.state,g=</span><span class="s1">this</span><span class="s0">.tsParseModifier(i.concat(a!=</span><span class="s1">null</span><span class="s0">?a:[]),n);</span><span class="s1">if</span><span class="s0">(!g)</span><span class="s1">break</span><span class="s0">;Hr(g)?s.accessibility?</span><span class="s1">this</span><span class="s0">.raise(I.DuplicateAccessibilityModifier,{at:y,modifier:g}):(u(y,g,g,</span><span class="s2">&quot;override&quot;</span><span class="s0">),u(y,g,g,</span><span class="s2">&quot;static&quot;</span><span class="s0">),u(y,g,g,</span><span class="s2">&quot;readonly&quot;</span><span class="s0">),s.accessibility=g):hh(g)?(s[g]&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(I.DuplicateModifier,{at:y,modifier:g}),s[g]=!</span><span class="s3">0</span><span class="s0">,u(y,g,</span><span class="s2">&quot;in&quot;</span><span class="s0">,</span><span class="s2">&quot;out&quot;</span><span class="s0">)):(Object.hasOwnProperty.call(s,g)?</span><span class="s1">this</span><span class="s0">.raise(I.DuplicateModifier,{at:y,modifier:g}):(u(y,g,</span><span class="s2">&quot;static&quot;</span><span class="s0">,</span><span class="s2">&quot;readonly&quot;</span><span class="s0">),u(y,g,</span><span class="s2">&quot;static&quot;</span><span class="s0">,</span><span class="s2">&quot;override&quot;</span><span class="s0">),u(y,g,</span><span class="s2">&quot;override&quot;</span><span class="s0">,</span><span class="s2">&quot;readonly&quot;</span><span class="s0">),u(y,g,</span><span class="s2">&quot;abstract&quot;</span><span class="s0">,</span><span class="s2">&quot;override&quot;</span><span class="s0">),c(y,g,</span><span class="s2">&quot;declare&quot;</span><span class="s0">,</span><span class="s2">&quot;override&quot;</span><span class="s0">),c(y,g,</span><span class="s2">&quot;static&quot;</span><span class="s0">,</span><span class="s2">&quot;abstract&quot;</span><span class="s0">)),s[g]=!</span><span class="s3">0</span><span class="s0">),a!=</span><span class="s1">null</span><span class="s0">&amp;&amp;a.includes(g)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(o,{at:y,modifier:g})}}tsIsListTerminator(e){</span><span class="s1">switch</span><span class="s0">(e){</span><span class="s1">case</span><span class="s2">&quot;EnumMembers&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;TypeMembers&quot;</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.match(</span><span class="s3">8</span><span class="s0">);</span><span class="s1">case</span><span class="s2">&quot;HeritageClauseElement&quot;</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.match(</span><span class="s3">5</span><span class="s0">);</span><span class="s1">case</span><span class="s2">&quot;TupleElementTypes&quot;</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.match(</span><span class="s3">3</span><span class="s0">);</span><span class="s1">case</span><span class="s2">&quot;TypeParametersOrArguments&quot;</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.match(</span><span class="s3">48</span><span class="s0">)}}tsParseList(e,s){let i=[];</span><span class="s1">for</span><span class="s0">(;!</span><span class="s1">this</span><span class="s0">.tsIsListTerminator(e);)i.push(s());</span><span class="s1">return </span><span class="s0">i}tsParseDelimitedList(e,s,i){</span><span class="s1">return </span><span class="s0">oh(</span><span class="s1">this</span><span class="s0">.tsParseDelimitedListWorker(e,s,!</span><span class="s3">0</span><span class="s0">,i))}tsParseDelimitedListWorker(e,s,i,a){let n=[],o=-</span><span class="s3">1</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(;!</span><span class="s1">this</span><span class="s0">.tsIsListTerminator(e);){o=-</span><span class="s3">1</span><span class="s0">;let u=s();</span><span class="s1">if</span><span class="s0">(u==</span><span class="s1">null</span><span class="s0">)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(n.push(u),</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">12</span><span class="s0">)){o=</span><span class="s1">this</span><span class="s0">.state.lastTokStart;</span><span class="s1">continue</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.tsIsListTerminator(e))</span><span class="s1">break</span><span class="s0">;i&amp;&amp;</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">12</span><span class="s0">);</span><span class="s1">return</span><span class="s0">}</span><span class="s1">return </span><span class="s0">a&amp;&amp;(a.value=o),n}tsParseBracketedList(e,s,i,a,n){a||(i?</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">0</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">47</span><span class="s0">));let o=</span><span class="s1">this</span><span class="s0">.tsParseDelimitedList(e,s,n);</span><span class="s1">return </span><span class="s0">i?</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">3</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">48</span><span class="s0">),o}tsParseImportType(){let e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.expect(</span><span class="s3">83</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">10</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">131</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.raise(I.UnsupportedImportTypeArgument,{at:</span><span class="s1">this</span><span class="s0">.state.startLoc}),e.argument=super.parseExprAtom(),</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">11</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">16</span><span class="s0">)&amp;&amp;(e.qualifier=</span><span class="s1">this</span><span class="s0">.tsParseEntityName()),</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">47</span><span class="s0">)&amp;&amp;(e.typeParameters=</span><span class="s1">this</span><span class="s0">.tsParseTypeArguments()),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;TSImportType&quot;</span><span class="s0">)}tsParseEntityName(){let e=arguments.length&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">0</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">0</span><span class="s0">]:!</span><span class="s3">0</span><span class="s0">,s=</span><span class="s1">this</span><span class="s0">.parseIdentifier(e);</span><span class="s1">for</span><span class="s0">(;</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">16</span><span class="s0">);){let i=</span><span class="s1">this</span><span class="s0">.startNodeAtNode(s);i.left=s,i.right=</span><span class="s1">this</span><span class="s0">.parseIdentifier(e),s=</span><span class="s1">this</span><span class="s0">.finishNode(i,</span><span class="s2">&quot;TSQualifiedName&quot;</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">s}tsParseTypeReference(){let e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">e.typeName=</span><span class="s1">this</span><span class="s0">.tsParseEntityName(),!</span><span class="s1">this</span><span class="s0">.hasPrecedingLineBreak()&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">47</span><span class="s0">)&amp;&amp;(e.typeParameters=</span><span class="s1">this</span><span class="s0">.tsParseTypeArguments()),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;TSTypeReference&quot;</span><span class="s0">)}tsParseThisTypePredicate(e){</span><span class="s1">this</span><span class="s0">.next();let s=</span><span class="s1">this</span><span class="s0">.startNodeAtNode(e);</span><span class="s1">return </span><span class="s0">s.parameterName=e,s.typeAnnotation=</span><span class="s1">this</span><span class="s0">.tsParseTypeAnnotation(!</span><span class="s3">1</span><span class="s0">),s.asserts=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.finishNode(s,</span><span class="s2">&quot;TSTypePredicate&quot;</span><span class="s0">)}tsParseThisTypeNode(){let e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;TSThisType&quot;</span><span class="s0">)}tsParseTypeQuery(){let e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.expect(</span><span class="s3">87</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">83</span><span class="s0">)?e.exprName=</span><span class="s1">this</span><span class="s0">.tsParseImportType():e.exprName=</span><span class="s1">this</span><span class="s0">.tsParseEntityName(),!</span><span class="s1">this</span><span class="s0">.hasPrecedingLineBreak()&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">47</span><span class="s0">)&amp;&amp;(e.typeParameters=</span><span class="s1">this</span><span class="s0">.tsParseTypeArguments()),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;TSTypeQuery&quot;</span><span class="s0">)}tsParseTypeParameter(e){let s=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">e(s),s.name=</span><span class="s1">this</span><span class="s0">.tsParseTypeParameterName(),s.constraint=</span><span class="s1">this</span><span class="s0">.tsEatThenParseType(</span><span class="s3">81</span><span class="s0">),s.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">this</span><span class="s0">.tsEatThenParseType(</span><span class="s3">29</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(s,</span><span class="s2">&quot;TSTypeParameter&quot;</span><span class="s0">)}tsTryParseTypeParameters(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">47</span><span class="s0">))</span><span class="s1">return this</span><span class="s0">.tsParseTypeParameters(e)}tsParseTypeParameters(e){let s=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">47</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">140</span><span class="s0">)?</span><span class="s1">this</span><span class="s0">.next():</span><span class="s1">this</span><span class="s0">.unexpected();let i={value:-</span><span class="s3">1</span><span class="s0">};</span><span class="s1">return </span><span class="s0">s.params=</span><span class="s1">this</span><span class="s0">.tsParseBracketedList(</span><span class="s2">&quot;TypeParametersOrArguments&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.tsParseTypeParameter.bind(</span><span class="s1">this</span><span class="s0">,e),!</span><span class="s3">1</span><span class="s0">,!</span><span class="s3">0</span><span class="s0">,i),s.params.length===</span><span class="s3">0</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(I.EmptyTypeParameters,{at:s}),i.value!==-</span><span class="s3">1</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.addExtra(s,</span><span class="s2">&quot;trailingComma&quot;</span><span class="s0">,i.value),</span><span class="s1">this</span><span class="s0">.finishNode(s,</span><span class="s2">&quot;TSTypeParameterDeclaration&quot;</span><span class="s0">)}tsFillSignature(e,s){let i=e===</span><span class="s3">19</span><span class="s0">,a=</span><span class="s2">&quot;parameters&quot;</span><span class="s0">,n=</span><span class="s2">&quot;typeAnnotation&quot;</span><span class="s0">;s.typeParameters=</span><span class="s1">this</span><span class="s0">.tsTryParseTypeParameters(</span><span class="s1">this</span><span class="s0">.tsParseConstModifier),</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">10</span><span class="s0">),s[a]=</span><span class="s1">this</span><span class="s0">.tsParseBindingListForSignature(),i?s[n]=</span><span class="s1">this</span><span class="s0">.tsParseTypeOrTypePredicateAnnotation(e):</span><span class="s1">this</span><span class="s0">.match(e)&amp;&amp;(s[n]=</span><span class="s1">this</span><span class="s0">.tsParseTypeOrTypePredicateAnnotation(e))}tsParseBindingListForSignature(){</span><span class="s1">return </span><span class="s0">super.parseBindingList(</span><span class="s3">11</span><span class="s0">,</span><span class="s3">41</span><span class="s0">,</span><span class="s3">2</span><span class="s0">).map(e=&gt;(e.type!==</span><span class="s2">&quot;Identifier&quot;</span><span class="s0">&amp;&amp;e.type!==</span><span class="s2">&quot;RestElement&quot;</span><span class="s0">&amp;&amp;e.type!==</span><span class="s2">&quot;ObjectPattern&quot;</span><span class="s0">&amp;&amp;e.type!==</span><span class="s2">&quot;ArrayPattern&quot;</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(I.UnsupportedSignatureParameterKind,{at:e,type:e.type}),e))}tsParseTypeMemberSemicolon(){!</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">12</span><span class="s0">)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.isLineTerminator()&amp;&amp;</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">13</span><span class="s0">)}tsParseSignatureMember(e,s){</span><span class="s1">return this</span><span class="s0">.tsFillSignature(</span><span class="s3">14</span><span class="s0">,s),</span><span class="s1">this</span><span class="s0">.tsParseTypeMemberSemicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(s,e)}tsIsUnambiguouslyIndexSignature(){</span><span class="s1">return this</span><span class="s0">.next(),q(</span><span class="s1">this</span><span class="s0">.state.type)?(</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">14</span><span class="s0">)):!</span><span class="s3">1</span><span class="s0">}tsTryParseIndexSignature(e){</span><span class="s1">if</span><span class="s0">(!(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">0</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.tsLookAhead(</span><span class="s1">this</span><span class="s0">.tsIsUnambiguouslyIndexSignature.bind(</span><span class="s1">this</span><span class="s0">))))</span><span class="s1">return</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">0</span><span class="s0">);let s=</span><span class="s1">this</span><span class="s0">.parseIdentifier();s.typeAnnotation=</span><span class="s1">this</span><span class="s0">.tsParseTypeAnnotation(),</span><span class="s1">this</span><span class="s0">.resetEndLocation(s),</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">3</span><span class="s0">),e.parameters=[s];let i=</span><span class="s1">this</span><span class="s0">.tsTryParseTypeAnnotation();</span><span class="s1">return </span><span class="s0">i&amp;&amp;(e.typeAnnotation=i),</span><span class="s1">this</span><span class="s0">.tsParseTypeMemberSemicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;TSIndexSignature&quot;</span><span class="s0">)}tsParsePropertyOrMethodSignature(e,s){</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">17</span><span class="s0">)&amp;&amp;(e.optional=!</span><span class="s3">0</span><span class="s0">);let i=e;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">10</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">47</span><span class="s0">)){s&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(I.ReadonlyForMethodSignature,{at:e});let a=i;a.kind&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">47</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(I.AccesorCannotHaveTypeParameters,{at:</span><span class="s1">this</span><span class="s0">.state.curPosition()}),</span><span class="s1">this</span><span class="s0">.tsFillSignature(</span><span class="s3">14</span><span class="s0">,a),</span><span class="s1">this</span><span class="s0">.tsParseTypeMemberSemicolon();let n=</span><span class="s2">&quot;parameters&quot;</span><span class="s0">,o=</span><span class="s2">&quot;typeAnnotation&quot;</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(a.kind===</span><span class="s2">&quot;get&quot;</span><span class="s0">)a[n].length&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;(</span><span class="s1">this</span><span class="s0">.raise(f.BadGetterArity,{at:</span><span class="s1">this</span><span class="s0">.state.curPosition()}),</span><span class="s1">this</span><span class="s0">.isThisParam(a[n][</span><span class="s3">0</span><span class="s0">])&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(I.AccesorCannotDeclareThisParameter,{at:</span><span class="s1">this</span><span class="s0">.state.curPosition()}));</span><span class="s1">else if</span><span class="s0">(a.kind===</span><span class="s2">&quot;set&quot;</span><span class="s0">){</span><span class="s1">if</span><span class="s0">(a[n].length!==</span><span class="s3">1</span><span class="s0">)</span><span class="s1">this</span><span class="s0">.raise(f.BadSetterArity,{at:</span><span class="s1">this</span><span class="s0">.state.curPosition()});</span><span class="s1">else</span><span class="s0">{let u=a[n][</span><span class="s3">0</span><span class="s0">];</span><span class="s1">this</span><span class="s0">.isThisParam(u)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(I.AccesorCannotDeclareThisParameter,{at:</span><span class="s1">this</span><span class="s0">.state.curPosition()}),u.type===</span><span class="s2">&quot;Identifier&quot;</span><span class="s0">&amp;&amp;u.optional&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(I.SetAccesorCannotHaveOptionalParameter,{at:</span><span class="s1">this</span><span class="s0">.state.curPosition()}),u.type===</span><span class="s2">&quot;RestElement&quot;</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(I.SetAccesorCannotHaveRestParameter,{at:</span><span class="s1">this</span><span class="s0">.state.curPosition()})}a[o]&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(I.SetAccesorCannotHaveReturnType,{at:a[o]})}</span><span class="s1">else </span><span class="s0">a.kind=</span><span class="s2">&quot;method&quot;</span><span class="s0">;</span><span class="s1">return this</span><span class="s0">.finishNode(a,</span><span class="s2">&quot;TSMethodSignature&quot;</span><span class="s0">)}</span><span class="s1">else</span><span class="s0">{let a=i;s&amp;&amp;(a.readonly=!</span><span class="s3">0</span><span class="s0">);let n=</span><span class="s1">this</span><span class="s0">.tsTryParseTypeAnnotation();</span><span class="s1">return </span><span class="s0">n&amp;&amp;(a.typeAnnotation=n),</span><span class="s1">this</span><span class="s0">.tsParseTypeMemberSemicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(a,</span><span class="s2">&quot;TSPropertySignature&quot;</span><span class="s0">)}}tsParseTypeMember(){let e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">10</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">47</span><span class="s0">))</span><span class="s1">return this</span><span class="s0">.tsParseSignatureMember(</span><span class="s2">&quot;TSCallSignatureDeclaration&quot;</span><span class="s0">,e);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">77</span><span class="s0">)){let i=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">10</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">47</span><span class="s0">)?</span><span class="s1">this</span><span class="s0">.tsParseSignatureMember(</span><span class="s2">&quot;TSConstructSignatureDeclaration&quot;</span><span class="s0">,e):(e.key=</span><span class="s1">this</span><span class="s0">.createIdentifier(i,</span><span class="s2">&quot;new&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.tsParsePropertyOrMethodSignature(e,!</span><span class="s3">1</span><span class="s0">))}</span><span class="s1">this</span><span class="s0">.tsParseModifiers({allowedModifiers:[</span><span class="s2">&quot;readonly&quot;</span><span class="s0">],disallowedModifiers:[</span><span class="s2">&quot;declare&quot;</span><span class="s0">,</span><span class="s2">&quot;abstract&quot;</span><span class="s0">,</span><span class="s2">&quot;private&quot;</span><span class="s0">,</span><span class="s2">&quot;protected&quot;</span><span class="s0">,</span><span class="s2">&quot;public&quot;</span><span class="s0">,</span><span class="s2">&quot;static&quot;</span><span class="s0">,</span><span class="s2">&quot;override&quot;</span><span class="s0">]},e);let s=</span><span class="s1">this</span><span class="s0">.tsTryParseIndexSignature(e);</span><span class="s1">return </span><span class="s0">s||(super.parsePropertyName(e),!e.computed&amp;&amp;e.key.type===</span><span class="s2">&quot;Identifier&quot;</span><span class="s0">&amp;&amp;(e.key.name===</span><span class="s2">&quot;get&quot;</span><span class="s0">||e.key.name===</span><span class="s2">&quot;set&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.tsTokenCanFollowModifier()&amp;&amp;(e.kind=e.key.name,super.parsePropertyName(e)),</span><span class="s1">this</span><span class="s0">.tsParsePropertyOrMethodSignature(e,!!e.readonly))}tsParseTypeLiteral(){let e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">e.members=</span><span class="s1">this</span><span class="s0">.tsParseObjectTypeMembers(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;TSTypeLiteral&quot;</span><span class="s0">)}tsParseObjectTypeMembers(){</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">5</span><span class="s0">);let e=</span><span class="s1">this</span><span class="s0">.tsParseList(</span><span class="s2">&quot;TypeMembers&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.tsParseTypeMember.bind(</span><span class="s1">this</span><span class="s0">));</span><span class="s1">return this</span><span class="s0">.expect(</span><span class="s3">8</span><span class="s0">),e}tsIsStartOfMappedType(){</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">53</span><span class="s0">)?</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">120</span><span class="s0">):(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">120</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.next(),!</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">0</span><span class="s0">)||(</span><span class="s1">this</span><span class="s0">.next(),!</span><span class="s1">this</span><span class="s0">.tsIsIdentifier())?!</span><span class="s3">1</span><span class="s0">:(</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">58</span><span class="s0">)))}tsParseMappedTypeParameter(){let e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">e.name=</span><span class="s1">this</span><span class="s0">.tsParseTypeParameterName(),e.constraint=</span><span class="s1">this</span><span class="s0">.tsExpectThenParseType(</span><span class="s3">58</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;TSTypeParameter&quot;</span><span class="s0">)}tsParseMappedType(){let e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.expect(</span><span class="s3">5</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">53</span><span class="s0">)?(e.readonly=</span><span class="s1">this</span><span class="s0">.state.value,</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.expectContextual(</span><span class="s3">120</span><span class="s0">)):</span><span class="s1">this</span><span class="s0">.eatContextual(</span><span class="s3">120</span><span class="s0">)&amp;&amp;(e.readonly=!</span><span class="s3">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">0</span><span class="s0">),e.typeParameter=</span><span class="s1">this</span><span class="s0">.tsParseMappedTypeParameter(),e.nameType=</span><span class="s1">this</span><span class="s0">.eatContextual(</span><span class="s3">93</span><span class="s0">)?</span><span class="s1">this</span><span class="s0">.tsParseType():</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">3</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">53</span><span class="s0">)?(e.optional=</span><span class="s1">this</span><span class="s0">.state.value,</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">17</span><span class="s0">)):</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">17</span><span class="s0">)&amp;&amp;(e.optional=!</span><span class="s3">0</span><span class="s0">),e.typeAnnotation=</span><span class="s1">this</span><span class="s0">.tsTryParseType(),</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">8</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;TSMappedType&quot;</span><span class="s0">)}tsParseTupleType(){let e=</span><span class="s1">this</span><span class="s0">.startNode();e.elementTypes=</span><span class="s1">this</span><span class="s0">.tsParseBracketedList(</span><span class="s2">&quot;TupleElementTypes&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.tsParseTupleElementType.bind(</span><span class="s1">this</span><span class="s0">),!</span><span class="s3">0</span><span class="s0">,!</span><span class="s3">1</span><span class="s0">);let s=!</span><span class="s3">1</span><span class="s0">,i=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">return </span><span class="s0">e.elementTypes.forEach(a=&gt;{</span><span class="s1">var </span><span class="s0">n;let{type:o}=a;s&amp;&amp;o!==</span><span class="s2">&quot;TSRestType&quot;</span><span class="s0">&amp;&amp;o!==</span><span class="s2">&quot;TSOptionalType&quot;</span><span class="s0">&amp;&amp;!(o===</span><span class="s2">&quot;TSNamedTupleMember&quot;</span><span class="s0">&amp;&amp;a.optional)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(I.OptionalTypeBeforeRequired,{at:a}),s||(s=o===</span><span class="s2">&quot;TSNamedTupleMember&quot;</span><span class="s0">&amp;&amp;a.optional||o===</span><span class="s2">&quot;TSOptionalType&quot;</span><span class="s0">);let u=o;o===</span><span class="s2">&quot;TSRestType&quot;</span><span class="s0">&amp;&amp;(a=a.typeAnnotation,u=a.type);let c=u===</span><span class="s2">&quot;TSNamedTupleMember&quot;</span><span class="s0">;(n=i)!=</span><span class="s1">null</span><span class="s0">||(i=c),i!==c&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(I.MixedLabeledAndUnlabeledElements,{at:a})}),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;TSTupleType&quot;</span><span class="s0">)}tsParseTupleElementType(){let{startLoc:e}=</span><span class="s1">this</span><span class="s0">.state,s=</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">21</span><span class="s0">),i,a,n,o,c=te(</span><span class="s1">this</span><span class="s0">.state.type)?</span><span class="s1">this</span><span class="s0">.lookaheadCharCode():</span><span class="s1">null</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(c===</span><span class="s3">58</span><span class="s0">)i=!</span><span class="s3">0</span><span class="s0">,n=!</span><span class="s3">1</span><span class="s0">,a=</span><span class="s1">this</span><span class="s0">.parseIdentifier(!</span><span class="s3">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">14</span><span class="s0">),o=</span><span class="s1">this</span><span class="s0">.tsParseType();</span><span class="s1">else if</span><span class="s0">(c===</span><span class="s3">63</span><span class="s0">){n=!</span><span class="s3">0</span><span class="s0">;let y=</span><span class="s1">this</span><span class="s0">.state.startLoc,g=</span><span class="s1">this</span><span class="s0">.state.value,T=</span><span class="s1">this</span><span class="s0">.tsParseNonArrayType();</span><span class="s1">this</span><span class="s0">.lookaheadCharCode()===</span><span class="s3">58</span><span class="s0">?(i=!</span><span class="s3">0</span><span class="s0">,a=</span><span class="s1">this</span><span class="s0">.createIdentifier(</span><span class="s1">this</span><span class="s0">.startNodeAt(y),g),</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">17</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">14</span><span class="s0">),o=</span><span class="s1">this</span><span class="s0">.tsParseType()):(i=!</span><span class="s3">1</span><span class="s0">,o=T,</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">17</span><span class="s0">))}</span><span class="s1">else </span><span class="s0">o=</span><span class="s1">this</span><span class="s0">.tsParseType(),n=</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">17</span><span class="s0">),i=</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">14</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(i){let y;a?(y=</span><span class="s1">this</span><span class="s0">.startNodeAtNode(a),y.optional=n,y.label=a,y.elementType=o,</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">17</span><span class="s0">)&amp;&amp;(y.optional=!</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.raise(I.TupleOptionalAfterType,{at:</span><span class="s1">this</span><span class="s0">.state.lastTokStartLoc}))):(y=</span><span class="s1">this</span><span class="s0">.startNodeAtNode(o),y.optional=n,</span><span class="s1">this</span><span class="s0">.raise(I.InvalidTupleMemberLabel,{at:o}),y.label=o,y.elementType=</span><span class="s1">this</span><span class="s0">.tsParseType()),o=</span><span class="s1">this</span><span class="s0">.finishNode(y,</span><span class="s2">&quot;TSNamedTupleMember&quot;</span><span class="s0">)}</span><span class="s1">else if</span><span class="s0">(n){let y=</span><span class="s1">this</span><span class="s0">.startNodeAtNode(o);y.typeAnnotation=o,o=</span><span class="s1">this</span><span class="s0">.finishNode(y,</span><span class="s2">&quot;TSOptionalType&quot;</span><span class="s0">)}</span><span class="s1">if</span><span class="s0">(s){let y=</span><span class="s1">this</span><span class="s0">.startNodeAt(e);y.typeAnnotation=o,o=</span><span class="s1">this</span><span class="s0">.finishNode(y,</span><span class="s2">&quot;TSRestType&quot;</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">o}tsParseParenthesizedType(){let e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.expect(</span><span class="s3">10</span><span class="s0">),e.typeAnnotation=</span><span class="s1">this</span><span class="s0">.tsParseType(),</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">11</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;TSParenthesizedType&quot;</span><span class="s0">)}tsParseFunctionOrConstructorType(e,s){let i=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">e===</span><span class="s2">&quot;TSConstructorType&quot;</span><span class="s0">&amp;&amp;(i.abstract=!!s,s&amp;&amp;</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.next()),</span><span class="s1">this</span><span class="s0">.tsInAllowConditionalTypesContext(()=&gt;</span><span class="s1">this</span><span class="s0">.tsFillSignature(</span><span class="s3">19</span><span class="s0">,i)),</span><span class="s1">this</span><span class="s0">.finishNode(i,e)}tsParseLiteralTypeNode(){let e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">e.literal=(()=&gt;{</span><span class="s1">switch</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.type){</span><span class="s1">case </span><span class="s3">132</span><span class="s0">:</span><span class="s1">case </span><span class="s3">133</span><span class="s0">:</span><span class="s1">case </span><span class="s3">131</span><span class="s0">:</span><span class="s1">case </span><span class="s3">85</span><span class="s0">:</span><span class="s1">case </span><span class="s3">86</span><span class="s0">:</span><span class="s1">return </span><span class="s0">super.parseExprAtom();</span><span class="s1">default</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.unexpected()}})(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;TSLiteralType&quot;</span><span class="s0">)}tsParseTemplateLiteralType(){let e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">e.literal=super.parseTemplate(!</span><span class="s3">1</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;TSLiteralType&quot;</span><span class="s0">)}parseTemplateSubstitution(){</span><span class="s1">return this</span><span class="s0">.state.inType?</span><span class="s1">this</span><span class="s0">.tsParseType():super.parseTemplateSubstitution()}tsParseThisTypeOrThisTypePredicate(){let e=</span><span class="s1">this</span><span class="s0">.tsParseThisTypeNode();</span><span class="s1">return this</span><span class="s0">.isContextual(</span><span class="s3">114</span><span class="s0">)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.hasPrecedingLineBreak()?</span><span class="s1">this</span><span class="s0">.tsParseThisTypePredicate(e):e}tsParseNonArrayType(){</span><span class="s1">switch</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.type){</span><span class="s1">case </span><span class="s3">131</span><span class="s0">:</span><span class="s1">case </span><span class="s3">132</span><span class="s0">:</span><span class="s1">case </span><span class="s3">133</span><span class="s0">:</span><span class="s1">case </span><span class="s3">85</span><span class="s0">:</span><span class="s1">case </span><span class="s3">86</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.tsParseLiteralTypeNode();</span><span class="s1">case </span><span class="s3">53</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.value===</span><span class="s2">&quot;-&quot;</span><span class="s0">){let e=</span><span class="s1">this</span><span class="s0">.startNode(),s=</span><span class="s1">this</span><span class="s0">.lookahead();</span><span class="s1">return </span><span class="s0">s.type!==</span><span class="s3">132</span><span class="s0">&amp;&amp;s.type!==</span><span class="s3">133</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(),e.literal=</span><span class="s1">this</span><span class="s0">.parseMaybeUnary(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;TSLiteralType&quot;</span><span class="s0">)}</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case </span><span class="s3">78</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.tsParseThisTypeOrThisTypePredicate();</span><span class="s1">case </span><span class="s3">87</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.tsParseTypeQuery();</span><span class="s1">case </span><span class="s3">83</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.tsParseImportType();</span><span class="s1">case </span><span class="s3">5</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.tsLookAhead(</span><span class="s1">this</span><span class="s0">.tsIsStartOfMappedType.bind(</span><span class="s1">this</span><span class="s0">))?</span><span class="s1">this</span><span class="s0">.tsParseMappedType():</span><span class="s1">this</span><span class="s0">.tsParseTypeLiteral();</span><span class="s1">case </span><span class="s3">0</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.tsParseTupleType();</span><span class="s1">case </span><span class="s3">10</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.tsParseParenthesizedType();</span><span class="s1">case </span><span class="s3">25</span><span class="s0">:</span><span class="s1">case </span><span class="s3">24</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.tsParseTemplateLiteralType();</span><span class="s1">default</span><span class="s0">:{let{type:e}=</span><span class="s1">this</span><span class="s0">.state;</span><span class="s1">if</span><span class="s0">(q(e)||e===</span><span class="s3">88</span><span class="s0">||e===</span><span class="s3">84</span><span class="s0">){let s=e===</span><span class="s3">88</span><span class="s0">?</span><span class="s2">&quot;TSVoidKeyword&quot;</span><span class="s0">:e===</span><span class="s3">84</span><span class="s0">?</span><span class="s2">&quot;TSNullKeyword&quot;</span><span class="s0">:lh(</span><span class="s1">this</span><span class="s0">.state.value);</span><span class="s1">if</span><span class="s0">(s!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.lookaheadCharCode()!==</span><span class="s3">46</span><span class="s0">){let i=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.finishNode(i,s)}</span><span class="s1">return this</span><span class="s0">.tsParseTypeReference()}}}</span><span class="s1">this</span><span class="s0">.unexpected()}tsParseArrayTypeOrHigher(){let e=</span><span class="s1">this</span><span class="s0">.tsParseNonArrayType();</span><span class="s1">for</span><span class="s0">(;!</span><span class="s1">this</span><span class="s0">.hasPrecedingLineBreak()&amp;&amp;</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">0</span><span class="s0">);)</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">3</span><span class="s0">)){let s=</span><span class="s1">this</span><span class="s0">.startNodeAtNode(e);s.elementType=e,</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">3</span><span class="s0">),e=</span><span class="s1">this</span><span class="s0">.finishNode(s,</span><span class="s2">&quot;TSArrayType&quot;</span><span class="s0">)}</span><span class="s1">else</span><span class="s0">{let s=</span><span class="s1">this</span><span class="s0">.startNodeAtNode(e);s.objectType=e,s.indexType=</span><span class="s1">this</span><span class="s0">.tsParseType(),</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">3</span><span class="s0">),e=</span><span class="s1">this</span><span class="s0">.finishNode(s,</span><span class="s2">&quot;TSIndexedAccessType&quot;</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">e}tsParseTypeOperator(){let e=</span><span class="s1">this</span><span class="s0">.startNode(),s=</span><span class="s1">this</span><span class="s0">.state.value;</span><span class="s1">return this</span><span class="s0">.next(),e.operator=s,e.typeAnnotation=</span><span class="s1">this</span><span class="s0">.tsParseTypeOperatorOrHigher(),s===</span><span class="s2">&quot;readonly&quot;</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.tsCheckTypeAnnotationForReadOnly(e),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;TSTypeOperator&quot;</span><span class="s0">)}tsCheckTypeAnnotationForReadOnly(e){</span><span class="s1">switch</span><span class="s0">(e.typeAnnotation.type){</span><span class="s1">case</span><span class="s2">&quot;TSTupleType&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;TSArrayType&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s0">;</span><span class="s1">default</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.raise(I.UnexpectedReadonly,{at:e})}}tsParseInferType(){let e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">this</span><span class="s0">.expectContextual(</span><span class="s3">113</span><span class="s0">);let s=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">s.name=</span><span class="s1">this</span><span class="s0">.tsParseTypeParameterName(),s.constraint=</span><span class="s1">this</span><span class="s0">.tsTryParse(()=&gt;</span><span class="s1">this</span><span class="s0">.tsParseConstraintForInferType()),e.typeParameter=</span><span class="s1">this</span><span class="s0">.finishNode(s,</span><span class="s2">&quot;TSTypeParameter&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;TSInferType&quot;</span><span class="s0">)}tsParseConstraintForInferType(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">81</span><span class="s0">)){let e=</span><span class="s1">this</span><span class="s0">.tsInDisallowConditionalTypesContext(()=&gt;</span><span class="s1">this</span><span class="s0">.tsParseType());</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.inDisallowConditionalTypesContext||!</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">17</span><span class="s0">))</span><span class="s1">return </span><span class="s0">e}}tsParseTypeOperatorOrHigher(){</span><span class="s1">return </span><span class="s0">qo(</span><span class="s1">this</span><span class="s0">.state.type)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.state.containsEsc?</span><span class="s1">this</span><span class="s0">.tsParseTypeOperator():</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">113</span><span class="s0">)?</span><span class="s1">this</span><span class="s0">.tsParseInferType():</span><span class="s1">this</span><span class="s0">.tsInAllowConditionalTypesContext(()=&gt;</span><span class="s1">this</span><span class="s0">.tsParseArrayTypeOrHigher())}tsParseUnionOrIntersectionType(e,s,i){let a=</span><span class="s1">this</span><span class="s0">.startNode(),n=</span><span class="s1">this</span><span class="s0">.eat(i),o=[];</span><span class="s1">do </span><span class="s0">o.push(s());</span><span class="s1">while</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(i));</span><span class="s1">return </span><span class="s0">o.length===</span><span class="s3">1</span><span class="s0">&amp;&amp;!n?o[</span><span class="s3">0</span><span class="s0">]:(a.types=o,</span><span class="s1">this</span><span class="s0">.finishNode(a,e))}tsParseIntersectionTypeOrHigher(){</span><span class="s1">return this</span><span class="s0">.tsParseUnionOrIntersectionType(</span><span class="s2">&quot;TSIntersectionType&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.tsParseTypeOperatorOrHigher.bind(</span><span class="s1">this</span><span class="s0">),</span><span class="s3">45</span><span class="s0">)}tsParseUnionTypeOrHigher(){</span><span class="s1">return this</span><span class="s0">.tsParseUnionOrIntersectionType(</span><span class="s2">&quot;TSUnionType&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.tsParseIntersectionTypeOrHigher.bind(</span><span class="s1">this</span><span class="s0">),</span><span class="s3">43</span><span class="s0">)}tsIsStartOfFunctionType(){</span><span class="s1">return this</span><span class="s0">.match(</span><span class="s3">47</span><span class="s0">)?!</span><span class="s3">0</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">10</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.tsLookAhead(</span><span class="s1">this</span><span class="s0">.tsIsUnambiguouslyStartOfFunctionType.bind(</span><span class="s1">this</span><span class="s0">))}tsSkipParameterStart(){</span><span class="s1">if</span><span class="s0">(q(</span><span class="s1">this</span><span class="s0">.state.type)||</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">78</span><span class="s0">))</span><span class="s1">return this</span><span class="s0">.next(),!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">5</span><span class="s0">)){let{errors:e}=</span><span class="s1">this</span><span class="s0">.state,s=e.length;</span><span class="s1">try</span><span class="s0">{</span><span class="s1">return this</span><span class="s0">.parseObjectLike(</span><span class="s3">8</span><span class="s0">,!</span><span class="s3">0</span><span class="s0">),e.length===s}</span><span class="s1">catch</span><span class="s0">{</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">}}</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">0</span><span class="s0">)){</span><span class="s1">this</span><span class="s0">.next();let{errors:e}=</span><span class="s1">this</span><span class="s0">.state,s=e.length;</span><span class="s1">try</span><span class="s0">{</span><span class="s1">return </span><span class="s0">super.parseBindingList(</span><span class="s3">3</span><span class="s0">,</span><span class="s3">93</span><span class="s0">,</span><span class="s3">1</span><span class="s0">),e.length===s}</span><span class="s1">catch</span><span class="s0">{</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">}}</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">}tsIsUnambiguouslyStartOfFunctionType(){</span><span class="s1">return this</span><span class="s0">.next(),!!(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">11</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">21</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.tsSkipParameterStart()&amp;&amp;(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">14</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">12</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">17</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">29</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">11</span><span class="s0">)&amp;&amp;(</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">19</span><span class="s0">))))}tsParseTypeOrTypePredicateAnnotation(e){</span><span class="s1">return this</span><span class="s0">.tsInType(()=&gt;{let s=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">this</span><span class="s0">.expect(e);let i=</span><span class="s1">this</span><span class="s0">.startNode(),a=!!</span><span class="s1">this</span><span class="s0">.tsTryParse(</span><span class="s1">this</span><span class="s0">.tsParseTypePredicateAsserts.bind(</span><span class="s1">this</span><span class="s0">));</span><span class="s1">if</span><span class="s0">(a&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">78</span><span class="s0">)){let u=</span><span class="s1">this</span><span class="s0">.tsParseThisTypeOrThisTypePredicate();</span><span class="s1">return </span><span class="s0">u.type===</span><span class="s2">&quot;TSThisType&quot;</span><span class="s0">?(i.parameterName=u,i.asserts=!</span><span class="s3">0</span><span class="s0">,i.typeAnnotation=</span><span class="s1">null</span><span class="s0">,u=</span><span class="s1">this</span><span class="s0">.finishNode(i,</span><span class="s2">&quot;TSTypePredicate&quot;</span><span class="s0">)):(</span><span class="s1">this</span><span class="s0">.resetStartLocationFromNode(u,i),u.asserts=!</span><span class="s3">0</span><span class="s0">),s.typeAnnotation=u,</span><span class="s1">this</span><span class="s0">.finishNode(s,</span><span class="s2">&quot;TSTypeAnnotation&quot;</span><span class="s0">)}let n=</span><span class="s1">this</span><span class="s0">.tsIsIdentifier()&amp;&amp;</span><span class="s1">this</span><span class="s0">.tsTryParse(</span><span class="s1">this</span><span class="s0">.tsParseTypePredicatePrefix.bind(</span><span class="s1">this</span><span class="s0">));</span><span class="s1">if</span><span class="s0">(!n)</span><span class="s1">return </span><span class="s0">a?(i.parameterName=</span><span class="s1">this</span><span class="s0">.parseIdentifier(),i.asserts=a,i.typeAnnotation=</span><span class="s1">null</span><span class="s0">,s.typeAnnotation=</span><span class="s1">this</span><span class="s0">.finishNode(i,</span><span class="s2">&quot;TSTypePredicate&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(s,</span><span class="s2">&quot;TSTypeAnnotation&quot;</span><span class="s0">)):</span><span class="s1">this</span><span class="s0">.tsParseTypeAnnotation(!</span><span class="s3">1</span><span class="s0">,s);let o=</span><span class="s1">this</span><span class="s0">.tsParseTypeAnnotation(!</span><span class="s3">1</span><span class="s0">);</span><span class="s1">return </span><span class="s0">i.parameterName=n,i.typeAnnotation=o,i.asserts=a,s.typeAnnotation=</span><span class="s1">this</span><span class="s0">.finishNode(i,</span><span class="s2">&quot;TSTypePredicate&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(s,</span><span class="s2">&quot;TSTypeAnnotation&quot;</span><span class="s0">)})}tsTryParseTypeOrTypePredicateAnnotation(){</span><span class="s1">return this</span><span class="s0">.match(</span><span class="s3">14</span><span class="s0">)?</span><span class="s1">this</span><span class="s0">.tsParseTypeOrTypePredicateAnnotation(</span><span class="s3">14</span><span class="s0">):</span><span class="s1">void </span><span class="s3">0</span><span class="s0">}tsTryParseTypeAnnotation(){</span><span class="s1">return this</span><span class="s0">.match(</span><span class="s3">14</span><span class="s0">)?</span><span class="s1">this</span><span class="s0">.tsParseTypeAnnotation():</span><span class="s1">void </span><span class="s3">0</span><span class="s0">}tsTryParseType(){</span><span class="s1">return this</span><span class="s0">.tsEatThenParseType(</span><span class="s3">14</span><span class="s0">)}tsParseTypePredicatePrefix(){let e=</span><span class="s1">this</span><span class="s0">.parseIdentifier();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">114</span><span class="s0">)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.hasPrecedingLineBreak())</span><span class="s1">return this</span><span class="s0">.next(),e}tsParseTypePredicateAsserts(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.type!==</span><span class="s3">107</span><span class="s0">)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;let e=</span><span class="s1">this</span><span class="s0">.state.containsEsc;</span><span class="s1">return this</span><span class="s0">.next(),!q(</span><span class="s1">this</span><span class="s0">.state.type)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">78</span><span class="s0">)?!</span><span class="s3">1</span><span class="s0">:(e&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.InvalidEscapedReservedWord,{at:</span><span class="s1">this</span><span class="s0">.state.lastTokStartLoc,reservedWord:</span><span class="s2">&quot;asserts&quot;</span><span class="s0">}),!</span><span class="s3">0</span><span class="s0">)}tsParseTypeAnnotation(){let e=arguments.length&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">0</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">0</span><span class="s0">]:!</span><span class="s3">0</span><span class="s0">,s=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">1</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">1</span><span class="s0">]:</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.tsInType(()=&gt;{e&amp;&amp;</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">14</span><span class="s0">),s.typeAnnotation=</span><span class="s1">this</span><span class="s0">.tsParseType()}),</span><span class="s1">this</span><span class="s0">.finishNode(s,</span><span class="s2">&quot;TSTypeAnnotation&quot;</span><span class="s0">)}tsParseType(){$r(</span><span class="s1">this</span><span class="s0">.state.inType);let e=</span><span class="s1">this</span><span class="s0">.tsParseNonConditionalType();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.inDisallowConditionalTypesContext||</span><span class="s1">this</span><span class="s0">.hasPrecedingLineBreak()||!</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">81</span><span class="s0">))</span><span class="s1">return </span><span class="s0">e;let s=</span><span class="s1">this</span><span class="s0">.startNodeAtNode(e);</span><span class="s1">return </span><span class="s0">s.checkType=e,s.extendsType=</span><span class="s1">this</span><span class="s0">.tsInDisallowConditionalTypesContext(()=&gt;</span><span class="s1">this</span><span class="s0">.tsParseNonConditionalType()),</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">17</span><span class="s0">),s.trueType=</span><span class="s1">this</span><span class="s0">.tsInAllowConditionalTypesContext(()=&gt;</span><span class="s1">this</span><span class="s0">.tsParseType()),</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">14</span><span class="s0">),s.falseType=</span><span class="s1">this</span><span class="s0">.tsInAllowConditionalTypesContext(()=&gt;</span><span class="s1">this</span><span class="s0">.tsParseType()),</span><span class="s1">this</span><span class="s0">.finishNode(s,</span><span class="s2">&quot;TSConditionalType&quot;</span><span class="s0">)}isAbstractConstructorSignature(){</span><span class="s1">return this</span><span class="s0">.isContextual(</span><span class="s3">122</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.lookahead().type===</span><span class="s3">77</span><span class="s0">}tsParseNonConditionalType(){</span><span class="s1">return this</span><span class="s0">.tsIsStartOfFunctionType()?</span><span class="s1">this</span><span class="s0">.tsParseFunctionOrConstructorType(</span><span class="s2">&quot;TSFunctionType&quot;</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">77</span><span class="s0">)?</span><span class="s1">this</span><span class="s0">.tsParseFunctionOrConstructorType(</span><span class="s2">&quot;TSConstructorType&quot;</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.isAbstractConstructorSignature()?</span><span class="s1">this</span><span class="s0">.tsParseFunctionOrConstructorType(</span><span class="s2">&quot;TSConstructorType&quot;</span><span class="s0">,!</span><span class="s3">0</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.tsParseUnionTypeOrHigher()}tsParseTypeAssertion(){</span><span class="s1">this</span><span class="s0">.getPluginOption(</span><span class="s2">&quot;typescript&quot;</span><span class="s0">,</span><span class="s2">&quot;disallowAmbiguousJSXLike&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(I.ReservedTypeAssertion,{at:</span><span class="s1">this</span><span class="s0">.state.startLoc});let e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">e.typeAnnotation=</span><span class="s1">this</span><span class="s0">.tsInType(()=&gt;(</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">75</span><span class="s0">)?</span><span class="s1">this</span><span class="s0">.tsParseTypeReference():</span><span class="s1">this</span><span class="s0">.tsParseType())),</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">48</span><span class="s0">),e.expression=</span><span class="s1">this</span><span class="s0">.parseMaybeUnary(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;TSTypeAssertion&quot;</span><span class="s0">)}tsParseHeritageClause(e){let s=</span><span class="s1">this</span><span class="s0">.state.startLoc,i=</span><span class="s1">this</span><span class="s0">.tsParseDelimitedList(</span><span class="s2">&quot;HeritageClauseElement&quot;</span><span class="s0">,()=&gt;{let a=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">a.expression=</span><span class="s1">this</span><span class="s0">.tsParseEntityName(),</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">47</span><span class="s0">)&amp;&amp;(a.typeParameters=</span><span class="s1">this</span><span class="s0">.tsParseTypeArguments()),</span><span class="s1">this</span><span class="s0">.finishNode(a,</span><span class="s2">&quot;TSExpressionWithTypeArguments&quot;</span><span class="s0">)});</span><span class="s1">return </span><span class="s0">i.length||</span><span class="s1">this</span><span class="s0">.raise(I.EmptyHeritageClauseType,{at:s,token:e}),i}tsParseInterfaceDeclaration(e){let s=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">1</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">1</span><span class="s0">]:{};</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.hasFollowingLineBreak())</span><span class="s1">return null</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.expectContextual(</span><span class="s3">127</span><span class="s0">),s.declare&amp;&amp;(e.declare=!</span><span class="s3">0</span><span class="s0">),q(</span><span class="s1">this</span><span class="s0">.state.type)?(e.id=</span><span class="s1">this</span><span class="s0">.parseIdentifier(),</span><span class="s1">this</span><span class="s0">.checkIdentifier(e.id,pl)):(e.id=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.raise(I.MissingInterfaceName,{at:</span><span class="s1">this</span><span class="s0">.state.startLoc})),e.typeParameters=</span><span class="s1">this</span><span class="s0">.tsTryParseTypeParameters(</span><span class="s1">this</span><span class="s0">.tsParseInOutConstModifiers),</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">81</span><span class="s0">)&amp;&amp;(e.extends=</span><span class="s1">this</span><span class="s0">.tsParseHeritageClause(</span><span class="s2">&quot;extends&quot;</span><span class="s0">));let i=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">i.body=</span><span class="s1">this</span><span class="s0">.tsInType(</span><span class="s1">this</span><span class="s0">.tsParseObjectTypeMembers.bind(</span><span class="s1">this</span><span class="s0">)),e.body=</span><span class="s1">this</span><span class="s0">.finishNode(i,</span><span class="s2">&quot;TSInterfaceBody&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;TSInterfaceDeclaration&quot;</span><span class="s0">)}tsParseTypeAliasDeclaration(e){</span><span class="s1">return </span><span class="s0">e.id=</span><span class="s1">this</span><span class="s0">.parseIdentifier(),</span><span class="s1">this</span><span class="s0">.checkIdentifier(e.id,fl),e.typeAnnotation=</span><span class="s1">this</span><span class="s0">.tsInType(()=&gt;{</span><span class="s1">if</span><span class="s0">(e.typeParameters=</span><span class="s1">this</span><span class="s0">.tsTryParseTypeParameters(</span><span class="s1">this</span><span class="s0">.tsParseInOutModifiers),</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">29</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">112</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.lookahead().type!==</span><span class="s3">16</span><span class="s0">){let s=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.finishNode(s,</span><span class="s2">&quot;TSIntrinsicKeyword&quot;</span><span class="s0">)}</span><span class="s1">return this</span><span class="s0">.tsParseType()}),</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;TSTypeAliasDeclaration&quot;</span><span class="s0">)}tsInNoContext(e){let s=</span><span class="s1">this</span><span class="s0">.state.context;</span><span class="s1">this</span><span class="s0">.state.context=[s[</span><span class="s3">0</span><span class="s0">]];</span><span class="s1">try</span><span class="s0">{</span><span class="s1">return </span><span class="s0">e()}</span><span class="s1">finally</span><span class="s0">{</span><span class="s1">this</span><span class="s0">.state.context=s}}tsInType(e){let s=</span><span class="s1">this</span><span class="s0">.state.inType;</span><span class="s1">this</span><span class="s0">.state.inType=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">try</span><span class="s0">{</span><span class="s1">return </span><span class="s0">e()}</span><span class="s1">finally</span><span class="s0">{</span><span class="s1">this</span><span class="s0">.state.inType=s}}tsInDisallowConditionalTypesContext(e){let s=</span><span class="s1">this</span><span class="s0">.state.inDisallowConditionalTypesContext;</span><span class="s1">this</span><span class="s0">.state.inDisallowConditionalTypesContext=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">try</span><span class="s0">{</span><span class="s1">return </span><span class="s0">e()}</span><span class="s1">finally</span><span class="s0">{</span><span class="s1">this</span><span class="s0">.state.inDisallowConditionalTypesContext=s}}tsInAllowConditionalTypesContext(e){let s=</span><span class="s1">this</span><span class="s0">.state.inDisallowConditionalTypesContext;</span><span class="s1">this</span><span class="s0">.state.inDisallowConditionalTypesContext=!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">try</span><span class="s0">{</span><span class="s1">return </span><span class="s0">e()}</span><span class="s1">finally</span><span class="s0">{</span><span class="s1">this</span><span class="s0">.state.inDisallowConditionalTypesContext=s}}tsEatThenParseType(e){</span><span class="s1">return this</span><span class="s0">.match(e)?</span><span class="s1">this</span><span class="s0">.tsNextThenParseType():</span><span class="s1">void </span><span class="s3">0</span><span class="s0">}tsExpectThenParseType(e){</span><span class="s1">return this</span><span class="s0">.tsDoThenParseType(()=&gt;</span><span class="s1">this</span><span class="s0">.expect(e))}tsNextThenParseType(){</span><span class="s1">return this</span><span class="s0">.tsDoThenParseType(()=&gt;</span><span class="s1">this</span><span class="s0">.next())}tsDoThenParseType(e){</span><span class="s1">return this</span><span class="s0">.tsInType(()=&gt;(e(),</span><span class="s1">this</span><span class="s0">.tsParseType()))}tsParseEnumMember(){let e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">e.id=</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">131</span><span class="s0">)?super.parseStringLiteral(</span><span class="s1">this</span><span class="s0">.state.value):</span><span class="s1">this</span><span class="s0">.parseIdentifier(!</span><span class="s3">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">29</span><span class="s0">)&amp;&amp;(e.initializer=super.parseMaybeAssignAllowIn()),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;TSEnumMember&quot;</span><span class="s0">)}tsParseEnumDeclaration(e){let s=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">1</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">1</span><span class="s0">]:{};</span><span class="s1">return </span><span class="s0">s.const&amp;&amp;(e.const=!</span><span class="s3">0</span><span class="s0">),s.declare&amp;&amp;(e.declare=!</span><span class="s3">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.expectContextual(</span><span class="s3">124</span><span class="s0">),e.id=</span><span class="s1">this</span><span class="s0">.parseIdentifier(),</span><span class="s1">this</span><span class="s0">.checkIdentifier(e.id,e.const?ml:Cr),</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">5</span><span class="s0">),e.members=</span><span class="s1">this</span><span class="s0">.tsParseDelimitedList(</span><span class="s2">&quot;EnumMembers&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.tsParseEnumMember.bind(</span><span class="s1">this</span><span class="s0">)),</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">8</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;TSEnumDeclaration&quot;</span><span class="s0">)}tsParseModuleBlock(){let e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.scope.enter(Fe),</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">5</span><span class="s0">),super.parseBlockOrModuleBlockBody(e.body=[],</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,!</span><span class="s3">0</span><span class="s0">,</span><span class="s3">8</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.scope.exit(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;TSModuleBlock&quot;</span><span class="s0">)}tsParseModuleOrNamespaceDeclaration(e){let s=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">1</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">1</span><span class="s0">]:!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(e.id=</span><span class="s1">this</span><span class="s0">.parseIdentifier(),s||</span><span class="s1">this</span><span class="s0">.checkIdentifier(e.id,yl),</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">16</span><span class="s0">)){let i=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">this</span><span class="s0">.tsParseModuleOrNamespaceDeclaration(i,!</span><span class="s3">0</span><span class="s0">),e.body=i}</span><span class="s1">else this</span><span class="s0">.scope.enter(Oe),</span><span class="s1">this</span><span class="s0">.prodParam.enter(Me),e.body=</span><span class="s1">this</span><span class="s0">.tsParseModuleBlock(),</span><span class="s1">this</span><span class="s0">.prodParam.exit(),</span><span class="s1">this</span><span class="s0">.scope.exit();</span><span class="s1">return this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;TSModuleDeclaration&quot;</span><span class="s0">)}tsParseAmbientExternalModuleDeclaration(e){</span><span class="s1">return this</span><span class="s0">.isContextual(</span><span class="s3">110</span><span class="s0">)?(e.global=!</span><span class="s3">0</span><span class="s0">,e.id=</span><span class="s1">this</span><span class="s0">.parseIdentifier()):</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">131</span><span class="s0">)?e.id=super.parseStringLiteral(</span><span class="s1">this</span><span class="s0">.state.value):</span><span class="s1">this</span><span class="s0">.unexpected(),</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">5</span><span class="s0">)?(</span><span class="s1">this</span><span class="s0">.scope.enter(Oe),</span><span class="s1">this</span><span class="s0">.prodParam.enter(Me),e.body=</span><span class="s1">this</span><span class="s0">.tsParseModuleBlock(),</span><span class="s1">this</span><span class="s0">.prodParam.exit(),</span><span class="s1">this</span><span class="s0">.scope.exit()):</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;TSModuleDeclaration&quot;</span><span class="s0">)}tsParseImportEqualsDeclaration(e,s){e.isExport=s||!</span><span class="s3">1</span><span class="s0">,e.id=</span><span class="s1">this</span><span class="s0">.parseIdentifier(),</span><span class="s1">this</span><span class="s0">.checkIdentifier(e.id,Ve),</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">29</span><span class="s0">);let i=</span><span class="s1">this</span><span class="s0">.tsParseModuleReference();</span><span class="s1">return </span><span class="s0">e.importKind===</span><span class="s2">&quot;type&quot;</span><span class="s0">&amp;&amp;i.type!==</span><span class="s2">&quot;TSExternalModuleReference&quot;</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(I.ImportAliasHasImportType,{at:i}),e.moduleReference=i,</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;TSImportEqualsDeclaration&quot;</span><span class="s0">)}tsIsExternalModuleReference(){</span><span class="s1">return this</span><span class="s0">.isContextual(</span><span class="s3">117</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.lookaheadCharCode()===</span><span class="s3">40</span><span class="s0">}tsParseModuleReference(){</span><span class="s1">return this</span><span class="s0">.tsIsExternalModuleReference()?</span><span class="s1">this</span><span class="s0">.tsParseExternalModuleReference():</span><span class="s1">this</span><span class="s0">.tsParseEntityName(!</span><span class="s3">1</span><span class="s0">)}tsParseExternalModuleReference(){let e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.expectContextual(</span><span class="s3">117</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">10</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">131</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.unexpected(),e.expression=super.parseExprAtom(),</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">11</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;TSExternalModuleReference&quot;</span><span class="s0">)}tsLookAhead(e){let s=</span><span class="s1">this</span><span class="s0">.state.clone(),i=e();</span><span class="s1">return this</span><span class="s0">.state=s,i}tsTryParseAndCatch(e){let s=</span><span class="s1">this</span><span class="s0">.tryParse(i=&gt;e()||i());</span><span class="s1">if</span><span class="s0">(!(s.aborted||!s.node))</span><span class="s1">return </span><span class="s0">s.error&amp;&amp;(</span><span class="s1">this</span><span class="s0">.state=s.failState),s.node}tsTryParse(e){let s=</span><span class="s1">this</span><span class="s0">.state.clone(),i=e();</span><span class="s1">if</span><span class="s0">(i!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">&amp;&amp;i!==!</span><span class="s3">1</span><span class="s0">)</span><span class="s1">return </span><span class="s0">i;</span><span class="s1">this</span><span class="s0">.state=s}tsTryParseDeclare(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isLineTerminator())</span><span class="s1">return</span><span class="s0">;let s=</span><span class="s1">this</span><span class="s0">.state.type,i;</span><span class="s1">return this</span><span class="s0">.isContextual(</span><span class="s3">99</span><span class="s0">)&amp;&amp;(s=</span><span class="s3">74</span><span class="s0">,i=</span><span class="s2">&quot;let&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.tsInAmbientContext(()=&gt;{</span><span class="s1">if</span><span class="s0">(s===</span><span class="s3">68</span><span class="s0">)</span><span class="s1">return </span><span class="s0">e.declare=!</span><span class="s3">0</span><span class="s0">,super.parseFunctionStatement(e,!</span><span class="s3">1</span><span class="s0">,!</span><span class="s3">1</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(s===</span><span class="s3">80</span><span class="s0">)</span><span class="s1">return </span><span class="s0">e.declare=!</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.parseClass(e,!</span><span class="s3">0</span><span class="s0">,!</span><span class="s3">1</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(s===</span><span class="s3">124</span><span class="s0">)</span><span class="s1">return this</span><span class="s0">.tsParseEnumDeclaration(e,{declare:!</span><span class="s3">0</span><span class="s0">});</span><span class="s1">if</span><span class="s0">(s===</span><span class="s3">110</span><span class="s0">)</span><span class="s1">return this</span><span class="s0">.tsParseAmbientExternalModuleDeclaration(e);</span><span class="s1">if</span><span class="s0">(s===</span><span class="s3">75</span><span class="s0">||s===</span><span class="s3">74</span><span class="s0">)</span><span class="s1">return</span><span class="s0">!</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">75</span><span class="s0">)||!</span><span class="s1">this</span><span class="s0">.isLookaheadContextual(</span><span class="s2">&quot;enum&quot;</span><span class="s0">)?(e.declare=!</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.parseVarStatement(e,i||</span><span class="s1">this</span><span class="s0">.state.value,!</span><span class="s3">0</span><span class="s0">)):(</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">75</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.tsParseEnumDeclaration(e,{const:!</span><span class="s3">0</span><span class="s0">,declare:!</span><span class="s3">0</span><span class="s0">}));</span><span class="s1">if</span><span class="s0">(s===</span><span class="s3">127</span><span class="s0">){let a=</span><span class="s1">this</span><span class="s0">.tsParseInterfaceDeclaration(e,{declare:!</span><span class="s3">0</span><span class="s0">});</span><span class="s1">if</span><span class="s0">(a)</span><span class="s1">return </span><span class="s0">a}</span><span class="s1">if</span><span class="s0">(q(s))</span><span class="s1">return this</span><span class="s0">.tsParseDeclaration(e,</span><span class="s1">this</span><span class="s0">.state.value,!</span><span class="s3">0</span><span class="s0">,</span><span class="s1">null</span><span class="s0">)})}tsTryParseExportDeclaration(){</span><span class="s1">return this</span><span class="s0">.tsParseDeclaration(</span><span class="s1">this</span><span class="s0">.startNode(),</span><span class="s1">this</span><span class="s0">.state.value,!</span><span class="s3">0</span><span class="s0">,</span><span class="s1">null</span><span class="s0">)}tsParseExpressionStatement(e,s,i){</span><span class="s1">switch</span><span class="s0">(s.name){</span><span class="s1">case</span><span class="s2">&quot;declare&quot;</span><span class="s0">:{let a=</span><span class="s1">this</span><span class="s0">.tsTryParseDeclare(e);</span><span class="s1">if</span><span class="s0">(a)</span><span class="s1">return </span><span class="s0">a.declare=!</span><span class="s3">0</span><span class="s0">,a;</span><span class="s1">break</span><span class="s0">}</span><span class="s1">case</span><span class="s2">&quot;global&quot;</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">5</span><span class="s0">)){</span><span class="s1">this</span><span class="s0">.scope.enter(Oe),</span><span class="s1">this</span><span class="s0">.prodParam.enter(Me);let a=e;</span><span class="s1">return </span><span class="s0">a.global=!</span><span class="s3">0</span><span class="s0">,a.id=s,a.body=</span><span class="s1">this</span><span class="s0">.tsParseModuleBlock(),</span><span class="s1">this</span><span class="s0">.scope.exit(),</span><span class="s1">this</span><span class="s0">.prodParam.exit(),</span><span class="s1">this</span><span class="s0">.finishNode(a,</span><span class="s2">&quot;TSModuleDeclaration&quot;</span><span class="s0">)}</span><span class="s1">break</span><span class="s0">;</span><span class="s1">default</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.tsParseDeclaration(e,s.name,!</span><span class="s3">1</span><span class="s0">,i)}}tsParseDeclaration(e,s,i,a){</span><span class="s1">switch</span><span class="s0">(s){</span><span class="s1">case</span><span class="s2">&quot;abstract&quot;</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.tsCheckLineTerminator(i)&amp;&amp;(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">80</span><span class="s0">)||q(</span><span class="s1">this</span><span class="s0">.state.type)))</span><span class="s1">return this</span><span class="s0">.tsParseAbstractDeclaration(e,a);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;module&quot;</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.tsCheckLineTerminator(i)){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">131</span><span class="s0">))</span><span class="s1">return this</span><span class="s0">.tsParseAmbientExternalModuleDeclaration(e);</span><span class="s1">if</span><span class="s0">(q(</span><span class="s1">this</span><span class="s0">.state.type))</span><span class="s1">return this</span><span class="s0">.tsParseModuleOrNamespaceDeclaration(e)}</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;namespace&quot;</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.tsCheckLineTerminator(i)&amp;&amp;q(</span><span class="s1">this</span><span class="s0">.state.type))</span><span class="s1">return this</span><span class="s0">.tsParseModuleOrNamespaceDeclaration(e);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;type&quot;</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.tsCheckLineTerminator(i)&amp;&amp;q(</span><span class="s1">this</span><span class="s0">.state.type))</span><span class="s1">return this</span><span class="s0">.tsParseTypeAliasDeclaration(e);</span><span class="s1">break</span><span class="s0">}}tsCheckLineTerminator(e){</span><span class="s1">return </span><span class="s0">e?</span><span class="s1">this</span><span class="s0">.hasFollowingLineBreak()?!</span><span class="s3">1</span><span class="s0">:(</span><span class="s1">this</span><span class="s0">.next(),!</span><span class="s3">0</span><span class="s0">):!</span><span class="s1">this</span><span class="s0">.isLineTerminator()}tsTryParseGenericAsyncArrowFunction(e){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">47</span><span class="s0">))</span><span class="s1">return</span><span class="s0">;let s=</span><span class="s1">this</span><span class="s0">.state.maybeInArrowParameters;</span><span class="s1">this</span><span class="s0">.state.maybeInArrowParameters=!</span><span class="s3">0</span><span class="s0">;let i=</span><span class="s1">this</span><span class="s0">.tsTryParseAndCatch(()=&gt;{let a=</span><span class="s1">this</span><span class="s0">.startNodeAt(e);</span><span class="s1">return </span><span class="s0">a.typeParameters=</span><span class="s1">this</span><span class="s0">.tsParseTypeParameters(</span><span class="s1">this</span><span class="s0">.tsParseConstModifier),super.parseFunctionParams(a),a.returnType=</span><span class="s1">this</span><span class="s0">.tsTryParseTypeOrTypePredicateAnnotation(),</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">19</span><span class="s0">),a});</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.maybeInArrowParameters=s,!!i)</span><span class="s1">return </span><span class="s0">super.parseArrowExpression(i,</span><span class="s1">null</span><span class="s0">,!</span><span class="s3">0</span><span class="s0">)}tsParseTypeArgumentsInExpression(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.reScan_lt()===</span><span class="s3">47</span><span class="s0">)</span><span class="s1">return this</span><span class="s0">.tsParseTypeArguments()}tsParseTypeArguments(){let e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">e.params=</span><span class="s1">this</span><span class="s0">.tsInType(()=&gt;</span><span class="s1">this</span><span class="s0">.tsInNoContext(()=&gt;(</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">47</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.tsParseDelimitedList(</span><span class="s2">&quot;TypeParametersOrArguments&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.tsParseType.bind(</span><span class="s1">this</span><span class="s0">))))),e.params.length===</span><span class="s3">0</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(I.EmptyTypeArguments,{at:e}),</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">48</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;TSTypeParameterInstantiation&quot;</span><span class="s0">)}tsIsDeclarationStart(){</span><span class="s1">return </span><span class="s0">Uo(</span><span class="s1">this</span><span class="s0">.state.type)}isExportDefaultSpecifier(){</span><span class="s1">return this</span><span class="s0">.tsIsDeclarationStart()?!</span><span class="s3">1</span><span class="s0">:super.isExportDefaultSpecifier()}parseAssignableListItem(e,s){let i=</span><span class="s1">this</span><span class="s0">.state.startLoc,a={};</span><span class="s1">this</span><span class="s0">.tsParseModifiers({allowedModifiers:[</span><span class="s2">&quot;public&quot;</span><span class="s0">,</span><span class="s2">&quot;private&quot;</span><span class="s0">,</span><span class="s2">&quot;protected&quot;</span><span class="s0">,</span><span class="s2">&quot;override&quot;</span><span class="s0">,</span><span class="s2">&quot;readonly&quot;</span><span class="s0">]},a);let n=a.accessibility,o=a.override,u=a.readonly;!(e&amp;</span><span class="s3">4</span><span class="s0">)&amp;&amp;(n||u||o)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(I.UnexpectedParameterModifier,{at:i});let c=</span><span class="s1">this</span><span class="s0">.parseMaybeDefault();</span><span class="s1">this</span><span class="s0">.parseAssignableListItemTypes(c,e);let y=</span><span class="s1">this</span><span class="s0">.parseMaybeDefault(c.loc.start,c);</span><span class="s1">if</span><span class="s0">(n||u||o){let g=</span><span class="s1">this</span><span class="s0">.startNodeAt(i);</span><span class="s1">return </span><span class="s0">s.length&amp;&amp;(g.decorators=s),n&amp;&amp;(g.accessibility=n),u&amp;&amp;(g.readonly=u),o&amp;&amp;(g.override=o),y.type!==</span><span class="s2">&quot;Identifier&quot;</span><span class="s0">&amp;&amp;y.type!==</span><span class="s2">&quot;AssignmentPattern&quot;</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(I.UnsupportedParameterPropertyKind,{at:g}),g.parameter=y,</span><span class="s1">this</span><span class="s0">.finishNode(g,</span><span class="s2">&quot;TSParameterProperty&quot;</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">s.length&amp;&amp;(c.decorators=s),y}isSimpleParameter(e){</span><span class="s1">return </span><span class="s0">e.type===</span><span class="s2">&quot;TSParameterProperty&quot;</span><span class="s0">&amp;&amp;super.isSimpleParameter(e.parameter)||super.isSimpleParameter(e)}tsDisallowOptionalPattern(e){</span><span class="s1">for</span><span class="s0">(let s of e.params)s.type!==</span><span class="s2">&quot;Identifier&quot;</span><span class="s0">&amp;&amp;s.optional&amp;&amp;!</span><span class="s1">this</span><span class="s0">.state.isAmbientContext&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(I.PatternIsOptional,{at:s})}setArrowFunctionParameters(e,s,i){super.setArrowFunctionParameters(e,s,i),</span><span class="s1">this</span><span class="s0">.tsDisallowOptionalPattern(e)}parseFunctionBodyAndFinish(e,s){let i=arguments.length&gt;</span><span class="s3">2</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">2</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">2</span><span class="s0">]:!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">14</span><span class="s0">)&amp;&amp;(e.returnType=</span><span class="s1">this</span><span class="s0">.tsParseTypeOrTypePredicateAnnotation(</span><span class="s3">14</span><span class="s0">));let a=s===</span><span class="s2">&quot;FunctionDeclaration&quot;</span><span class="s0">?</span><span class="s2">&quot;TSDeclareFunction&quot;</span><span class="s0">:s===</span><span class="s2">&quot;ClassMethod&quot;</span><span class="s0">||s===</span><span class="s2">&quot;ClassPrivateMethod&quot;</span><span class="s0">?</span><span class="s2">&quot;TSDeclareMethod&quot;</span><span class="s0">:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">;</span><span class="s1">return </span><span class="s0">a&amp;&amp;!</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">5</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.isLineTerminator()?</span><span class="s1">this</span><span class="s0">.finishNode(e,a):a===</span><span class="s2">&quot;TSDeclareFunction&quot;</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.state.isAmbientContext&amp;&amp;(</span><span class="s1">this</span><span class="s0">.raise(I.DeclareFunctionHasImplementation,{at:e}),e.declare)?super.parseFunctionBodyAndFinish(e,a,i):(</span><span class="s1">this</span><span class="s0">.tsDisallowOptionalPattern(e),super.parseFunctionBodyAndFinish(e,s,i))}registerFunctionStatementId(e){!e.body&amp;&amp;e.id?</span><span class="s1">this</span><span class="s0">.checkIdentifier(e.id,br):super.registerFunctionStatementId(e)}tsCheckForInvalidTypeCasts(e){e.forEach(s=&gt;{(s==</span><span class="s1">null</span><span class="s0">?</span><span class="s1">void </span><span class="s3">0</span><span class="s0">:s.type)===</span><span class="s2">&quot;TSTypeCastExpression&quot;</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(I.UnexpectedTypeAnnotation,{at:s.typeAnnotation})})}toReferencedList(e,s){</span><span class="s1">return this</span><span class="s0">.tsCheckForInvalidTypeCasts(e),e}parseArrayLike(e,s,i,a){let n=super.parseArrayLike(e,s,i,a);</span><span class="s1">return </span><span class="s0">n.type===</span><span class="s2">&quot;ArrayExpression&quot;</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.tsCheckForInvalidTypeCasts(n.elements),n}parseSubscript(e,s,i,a){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.hasPrecedingLineBreak()&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">35</span><span class="s0">)){</span><span class="s1">this</span><span class="s0">.state.canStartJSXElement=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.next();let o=</span><span class="s1">this</span><span class="s0">.startNodeAt(s);</span><span class="s1">return </span><span class="s0">o.expression=e,</span><span class="s1">this</span><span class="s0">.finishNode(o,</span><span class="s2">&quot;TSNonNullExpression&quot;</span><span class="s0">)}let n=!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">18</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.lookaheadCharCode()===</span><span class="s3">60</span><span class="s0">){</span><span class="s1">if</span><span class="s0">(i)</span><span class="s1">return </span><span class="s0">a.stop=!</span><span class="s3">0</span><span class="s0">,e;a.optionalChainMember=n=!</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.next()}</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">47</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">51</span><span class="s0">)){let o,u=</span><span class="s1">this</span><span class="s0">.tsTryParseAndCatch(()=&gt;{</span><span class="s1">if</span><span class="s0">(!i&amp;&amp;</span><span class="s1">this</span><span class="s0">.atPossibleAsyncArrow(e)){let T=</span><span class="s1">this</span><span class="s0">.tsTryParseGenericAsyncArrowFunction(s);</span><span class="s1">if</span><span class="s0">(T)</span><span class="s1">return </span><span class="s0">T}let c=</span><span class="s1">this</span><span class="s0">.tsParseTypeArgumentsInExpression();</span><span class="s1">if</span><span class="s0">(!c)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(n&amp;&amp;!</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">10</span><span class="s0">)){o=</span><span class="s1">this</span><span class="s0">.state.curPosition();</span><span class="s1">return</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(nt(</span><span class="s1">this</span><span class="s0">.state.type)){let T=super.parseTaggedTemplateExpression(e,s,a);</span><span class="s1">return </span><span class="s0">T.typeParameters=c,T}</span><span class="s1">if</span><span class="s0">(!i&amp;&amp;</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">10</span><span class="s0">)){let T=</span><span class="s1">this</span><span class="s0">.startNodeAt(s);</span><span class="s1">return </span><span class="s0">T.callee=e,T.arguments=</span><span class="s1">this</span><span class="s0">.parseCallExpressionArguments(</span><span class="s3">11</span><span class="s0">,!</span><span class="s3">1</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.tsCheckForInvalidTypeCasts(T.arguments),T.typeParameters=c,a.optionalChainMember&amp;&amp;(T.optional=n),</span><span class="s1">this</span><span class="s0">.finishCallExpression(T,a.optionalChainMember)}let y=</span><span class="s1">this</span><span class="s0">.state.type;</span><span class="s1">if</span><span class="s0">(y===</span><span class="s3">48</span><span class="s0">||y===</span><span class="s3">52</span><span class="s0">||y!==</span><span class="s3">10</span><span class="s0">&amp;&amp;He(y)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.hasPrecedingLineBreak())</span><span class="s1">return</span><span class="s0">;let g=</span><span class="s1">this</span><span class="s0">.startNodeAt(s);</span><span class="s1">return </span><span class="s0">g.expression=e,g.typeParameters=c,</span><span class="s1">this</span><span class="s0">.finishNode(g,</span><span class="s2">&quot;TSInstantiationExpression&quot;</span><span class="s0">)});</span><span class="s1">if</span><span class="s0">(o&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(o,</span><span class="s3">10</span><span class="s0">),u)</span><span class="s1">return </span><span class="s0">u.type===</span><span class="s2">&quot;TSInstantiationExpression&quot;</span><span class="s0">&amp;&amp;(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">16</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">18</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.lookaheadCharCode()!==</span><span class="s3">40</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(I.InvalidPropertyAccessAfterInstantiationExpression,{at:</span><span class="s1">this</span><span class="s0">.state.startLoc}),u}</span><span class="s1">return </span><span class="s0">super.parseSubscript(e,s,i,a)}parseNewCallee(e){</span><span class="s1">var </span><span class="s0">s;super.parseNewCallee(e);let{callee:i}=e;i.type===</span><span class="s2">&quot;TSInstantiationExpression&quot;</span><span class="s0">&amp;&amp;!((s=i.extra)!=</span><span class="s1">null</span><span class="s0">&amp;&amp;s.parenthesized)&amp;&amp;(e.typeParameters=i.typeParameters,e.callee=i.expression)}parseExprOp(e,s,i){let a;</span><span class="s1">if</span><span class="s0">(at(</span><span class="s3">58</span><span class="s0">)&gt;i&amp;&amp;!</span><span class="s1">this</span><span class="s0">.hasPrecedingLineBreak()&amp;&amp;(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">93</span><span class="s0">)||(a=</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">118</span><span class="s0">)))){let n=</span><span class="s1">this</span><span class="s0">.startNodeAt(s);</span><span class="s1">return </span><span class="s0">n.expression=e,n.typeAnnotation=</span><span class="s1">this</span><span class="s0">.tsInType(()=&gt;(</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">75</span><span class="s0">)?(a&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.UnexpectedKeyword,{at:</span><span class="s1">this</span><span class="s0">.state.startLoc,keyword:</span><span class="s2">&quot;const&quot;</span><span class="s0">}),</span><span class="s1">this</span><span class="s0">.tsParseTypeReference()):</span><span class="s1">this</span><span class="s0">.tsParseType())),</span><span class="s1">this</span><span class="s0">.finishNode(n,a?</span><span class="s2">&quot;TSSatisfiesExpression&quot;</span><span class="s0">:</span><span class="s2">&quot;TSAsExpression&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.reScan_lt_gt(),</span><span class="s1">this</span><span class="s0">.parseExprOp(n,s,i)}</span><span class="s1">return </span><span class="s0">super.parseExprOp(e,s,i)}checkReservedWord(e,s,i,a){</span><span class="s1">this</span><span class="s0">.state.isAmbientContext||super.checkReservedWord(e,s,i,a)}checkImportReflection(e){super.checkImportReflection(e),e.module&amp;&amp;e.importKind!==</span><span class="s2">&quot;value&quot;</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(I.ImportReflectionHasImportType,{at:e.specifiers[</span><span class="s3">0</span><span class="s0">].loc.start})}checkDuplicateExports(){}parseImport(e){</span><span class="s1">if</span><span class="s0">(e.importKind=</span><span class="s2">&quot;value&quot;</span><span class="s0">,q(</span><span class="s1">this</span><span class="s0">.state.type)||</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">55</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">5</span><span class="s0">)){let i=</span><span class="s1">this</span><span class="s0">.lookahead();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">128</span><span class="s0">)&amp;&amp;i.type!==</span><span class="s3">12</span><span class="s0">&amp;&amp;i.type!==</span><span class="s3">97</span><span class="s0">&amp;&amp;i.type!==</span><span class="s3">29</span><span class="s0">&amp;&amp;(e.importKind=</span><span class="s2">&quot;type&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.next(),i=</span><span class="s1">this</span><span class="s0">.lookahead()),q(</span><span class="s1">this</span><span class="s0">.state.type)&amp;&amp;i.type===</span><span class="s3">29</span><span class="s0">)</span><span class="s1">return this</span><span class="s0">.tsParseImportEqualsDeclaration(e)}let s=super.parseImport(e);</span><span class="s1">return </span><span class="s0">s.importKind===</span><span class="s2">&quot;type&quot;</span><span class="s0">&amp;&amp;s.specifiers.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;s.specifiers[</span><span class="s3">0</span><span class="s0">].type===</span><span class="s2">&quot;ImportDefaultSpecifier&quot;</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(I.TypeImportCannotSpecifyDefaultAndNamed,{at:s}),s}parseExport(e,s){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">83</span><span class="s0">))</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">128</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.lookaheadCharCode()!==</span><span class="s3">61</span><span class="s0">?(e.importKind=</span><span class="s2">&quot;type&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.next()):e.importKind=</span><span class="s2">&quot;value&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.tsParseImportEqualsDeclaration(e,!</span><span class="s3">0</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">29</span><span class="s0">)){let i=e;</span><span class="s1">return </span><span class="s0">i.expression=super.parseExpression(),</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(i,</span><span class="s2">&quot;TSExportAssignment&quot;</span><span class="s0">)}</span><span class="s1">else if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eatContextual(</span><span class="s3">93</span><span class="s0">)){let i=e;</span><span class="s1">return this</span><span class="s0">.expectContextual(</span><span class="s3">126</span><span class="s0">),i.id=</span><span class="s1">this</span><span class="s0">.parseIdentifier(),</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(i,</span><span class="s2">&quot;TSNamespaceExportDeclaration&quot;</span><span class="s0">)}</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(e.exportKind=</span><span class="s2">&quot;value&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">128</span><span class="s0">)){let i=</span><span class="s1">this</span><span class="s0">.lookaheadCharCode();(i===</span><span class="s3">123</span><span class="s0">||i===</span><span class="s3">42</span><span class="s0">)&amp;&amp;(</span><span class="s1">this</span><span class="s0">.next(),e.exportKind=</span><span class="s2">&quot;type&quot;</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">super.parseExport(e,s)}}isAbstractClass(){</span><span class="s1">return this</span><span class="s0">.isContextual(</span><span class="s3">122</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.lookahead().type===</span><span class="s3">80</span><span class="s0">}parseExportDefaultExpression(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isAbstractClass()){let e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),e.abstract=!</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.parseClass(e,!</span><span class="s3">0</span><span class="s0">,!</span><span class="s3">0</span><span class="s0">)}</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">127</span><span class="s0">)){let e=</span><span class="s1">this</span><span class="s0">.tsParseInterfaceDeclaration(</span><span class="s1">this</span><span class="s0">.startNode());</span><span class="s1">if</span><span class="s0">(e)</span><span class="s1">return </span><span class="s0">e}</span><span class="s1">return </span><span class="s0">super.parseExportDefaultExpression()}parseVarStatement(e,s){let i=arguments.length&gt;</span><span class="s3">2</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">2</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">2</span><span class="s0">]:!</span><span class="s3">1</span><span class="s0">,{isAmbientContext:a}=</span><span class="s1">this</span><span class="s0">.state,n=super.parseVarStatement(e,s,i||a);</span><span class="s1">if</span><span class="s0">(!a)</span><span class="s1">return </span><span class="s0">n;</span><span class="s1">for</span><span class="s0">(let{id:o,init:u}of n.declarations)u&amp;&amp;(s!==</span><span class="s2">&quot;const&quot;</span><span class="s0">||o.typeAnnotation?</span><span class="s1">this</span><span class="s0">.raise(I.InitializerNotAllowedInAmbientContext,{at:u}):ph(u,</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s2">&quot;estree&quot;</span><span class="s0">))||</span><span class="s1">this</span><span class="s0">.raise(I.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference,{at:u}));</span><span class="s1">return </span><span class="s0">n}parseStatementContent(e,s){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">75</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.isLookaheadContextual(</span><span class="s2">&quot;enum&quot;</span><span class="s0">)){let i=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.expect(</span><span class="s3">75</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.tsParseEnumDeclaration(i,{const:!</span><span class="s3">0</span><span class="s0">})}</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">124</span><span class="s0">))</span><span class="s1">return this</span><span class="s0">.tsParseEnumDeclaration(</span><span class="s1">this</span><span class="s0">.startNode());</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">127</span><span class="s0">)){let i=</span><span class="s1">this</span><span class="s0">.tsParseInterfaceDeclaration(</span><span class="s1">this</span><span class="s0">.startNode());</span><span class="s1">if</span><span class="s0">(i)</span><span class="s1">return </span><span class="s0">i}</span><span class="s1">return </span><span class="s0">super.parseStatementContent(e,s)}parseAccessModifier(){</span><span class="s1">return this</span><span class="s0">.tsParseModifier([</span><span class="s2">&quot;public&quot;</span><span class="s0">,</span><span class="s2">&quot;protected&quot;</span><span class="s0">,</span><span class="s2">&quot;private&quot;</span><span class="s0">])}tsHasSomeModifiers(e,s){</span><span class="s1">return </span><span class="s0">s.some(i=&gt;Hr(i)?e.accessibility===i:!!e[i])}tsIsStartOfStaticBlocks(){</span><span class="s1">return this</span><span class="s0">.isContextual(</span><span class="s3">104</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.lookaheadCharCode()===</span><span class="s3">123</span><span class="s0">}parseClassMember(e,s,i){let a=[</span><span class="s2">&quot;declare&quot;</span><span class="s0">,</span><span class="s2">&quot;private&quot;</span><span class="s0">,</span><span class="s2">&quot;public&quot;</span><span class="s0">,</span><span class="s2">&quot;protected&quot;</span><span class="s0">,</span><span class="s2">&quot;override&quot;</span><span class="s0">,</span><span class="s2">&quot;abstract&quot;</span><span class="s0">,</span><span class="s2">&quot;readonly&quot;</span><span class="s0">,</span><span class="s2">&quot;static&quot;</span><span class="s0">];</span><span class="s1">this</span><span class="s0">.tsParseModifiers({allowedModifiers:a,disallowedModifiers:[</span><span class="s2">&quot;in&quot;</span><span class="s0">,</span><span class="s2">&quot;out&quot;</span><span class="s0">],stopOnStartOfClassStaticBlock:!</span><span class="s3">0</span><span class="s0">,errorTemplate:I.InvalidModifierOnTypeParameterPositions},s);let n=()=&gt;{</span><span class="s1">this</span><span class="s0">.tsIsStartOfStaticBlocks()?(</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.tsHasSomeModifiers(s,a)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(I.StaticBlockCannotHaveModifier,{at:</span><span class="s1">this</span><span class="s0">.state.curPosition()}),super.parseClassStaticBlock(e,s)):</span><span class="s1">this</span><span class="s0">.parseClassMemberWithIsStatic(e,s,i,!!s.static)};s.declare?</span><span class="s1">this</span><span class="s0">.tsInAmbientContext(n):n()}parseClassMemberWithIsStatic(e,s,i,a){let n=</span><span class="s1">this</span><span class="s0">.tsTryParseIndexSignature(s);</span><span class="s1">if</span><span class="s0">(n){e.body.push(n),s.abstract&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(I.IndexSignatureHasAbstract,{at:s}),s.accessibility&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(I.IndexSignatureHasAccessibility,{at:s,modifier:s.accessibility}),s.declare&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(I.IndexSignatureHasDeclare,{at:s}),s.override&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(I.IndexSignatureHasOverride,{at:s});</span><span class="s1">return</span><span class="s0">}!</span><span class="s1">this</span><span class="s0">.state.inAbstractClass&amp;&amp;s.abstract&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(I.NonAbstractClassHasAbstractMethod,{at:s}),s.override&amp;&amp;(i.hadSuperClass||</span><span class="s1">this</span><span class="s0">.raise(I.OverrideNotInSubClass,{at:s})),super.parseClassMemberWithIsStatic(e,s,i,a)}parsePostMemberNameModifiers(e){</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">17</span><span class="s0">)&amp;&amp;(e.optional=!</span><span class="s3">0</span><span class="s0">),e.readonly&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">10</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(I.ClassMethodHasReadonly,{at:e}),e.declare&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">10</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(I.ClassMethodHasDeclare,{at:e})}parseExpressionStatement(e,s,i){</span><span class="s1">return</span><span class="s0">(s.type===</span><span class="s2">&quot;Identifier&quot;</span><span class="s0">?</span><span class="s1">this</span><span class="s0">.tsParseExpressionStatement(e,s,i):</span><span class="s1">void </span><span class="s3">0</span><span class="s0">)||super.parseExpressionStatement(e,s,i)}shouldParseExportDeclaration(){</span><span class="s1">return this</span><span class="s0">.tsIsDeclarationStart()?!</span><span class="s3">0</span><span class="s0">:super.shouldParseExportDeclaration()}parseConditional(e,s,i){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.state.maybeInArrowParameters||!</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">17</span><span class="s0">))</span><span class="s1">return </span><span class="s0">super.parseConditional(e,s,i);let a=</span><span class="s1">this</span><span class="s0">.tryParse(()=&gt;super.parseConditional(e,s));</span><span class="s1">return </span><span class="s0">a.node?(a.error&amp;&amp;(</span><span class="s1">this</span><span class="s0">.state=a.failState),a.node):(a.error&amp;&amp;super.setOptionalParametersError(i,a.error),e)}parseParenItem(e,s){</span><span class="s1">if</span><span class="s0">(e=super.parseParenItem(e,s),</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">17</span><span class="s0">)&amp;&amp;(e.optional=!</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.resetEndLocation(e)),</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">14</span><span class="s0">)){let i=</span><span class="s1">this</span><span class="s0">.startNodeAt(s);</span><span class="s1">return </span><span class="s0">i.expression=e,i.typeAnnotation=</span><span class="s1">this</span><span class="s0">.tsParseTypeAnnotation(),</span><span class="s1">this</span><span class="s0">.finishNode(i,</span><span class="s2">&quot;TSTypeCastExpression&quot;</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">e}parseExportDeclaration(e){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.state.isAmbientContext&amp;&amp;</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">123</span><span class="s0">))</span><span class="s1">return this</span><span class="s0">.tsInAmbientContext(()=&gt;</span><span class="s1">this</span><span class="s0">.parseExportDeclaration(e));let s=</span><span class="s1">this</span><span class="s0">.state.startLoc,i=</span><span class="s1">this</span><span class="s0">.eatContextual(</span><span class="s3">123</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(i&amp;&amp;(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">123</span><span class="s0">)||!</span><span class="s1">this</span><span class="s0">.shouldParseExportDeclaration()))</span><span class="s1">throw this</span><span class="s0">.raise(I.ExpectedAmbientAfterExportDeclare,{at:</span><span class="s1">this</span><span class="s0">.state.startLoc});let n=q(</span><span class="s1">this</span><span class="s0">.state.type)&amp;&amp;</span><span class="s1">this</span><span class="s0">.tsTryParseExportDeclaration()||super.parseExportDeclaration(e);</span><span class="s1">return </span><span class="s0">n?((n.type===</span><span class="s2">&quot;TSInterfaceDeclaration&quot;</span><span class="s0">||n.type===</span><span class="s2">&quot;TSTypeAliasDeclaration&quot;</span><span class="s0">||i)&amp;&amp;(e.exportKind=</span><span class="s2">&quot;type&quot;</span><span class="s0">),i&amp;&amp;(</span><span class="s1">this</span><span class="s0">.resetStartLocation(n,s),n.declare=!</span><span class="s3">0</span><span class="s0">),n):</span><span class="s1">null</span><span class="s0">}parseClassId(e,s,i,a){</span><span class="s1">if</span><span class="s0">((!s||i)&amp;&amp;</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">111</span><span class="s0">))</span><span class="s1">return</span><span class="s0">;super.parseClassId(e,s,i,e.declare?br:vr);let n=</span><span class="s1">this</span><span class="s0">.tsTryParseTypeParameters(</span><span class="s1">this</span><span class="s0">.tsParseInOutConstModifiers);n&amp;&amp;(e.typeParameters=n)}parseClassPropertyAnnotation(e){e.optional||(</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">35</span><span class="s0">)?e.definite=!</span><span class="s3">0</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">17</span><span class="s0">)&amp;&amp;(e.optional=!</span><span class="s3">0</span><span class="s0">));let s=</span><span class="s1">this</span><span class="s0">.tsTryParseTypeAnnotation();s&amp;&amp;(e.typeAnnotation=s)}parseClassProperty(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.parseClassPropertyAnnotation(e),</span><span class="s1">this</span><span class="s0">.state.isAmbientContext&amp;&amp;!(e.readonly&amp;&amp;!e.typeAnnotation)&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">29</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(I.DeclareClassFieldHasInitializer,{at:</span><span class="s1">this</span><span class="s0">.state.startLoc}),e.abstract&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">29</span><span class="s0">)){let{key:s}=e;</span><span class="s1">this</span><span class="s0">.raise(I.AbstractPropertyHasInitializer,{at:</span><span class="s1">this</span><span class="s0">.state.startLoc,propertyName:s.type===</span><span class="s2">&quot;Identifier&quot;</span><span class="s0">&amp;&amp;!e.computed?s.name:`[${</span><span class="s1">this</span><span class="s0">.input.slice(s.start,s.end)}]`})}</span><span class="s1">return </span><span class="s0">super.parseClassProperty(e)}parseClassPrivateProperty(e){</span><span class="s1">return </span><span class="s0">e.abstract&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(I.PrivateElementHasAbstract,{at:e}),e.accessibility&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(I.PrivateElementHasAccessibility,{at:e,modifier:e.accessibility}),</span><span class="s1">this</span><span class="s0">.parseClassPropertyAnnotation(e),super.parseClassPrivateProperty(e)}parseClassAccessorProperty(e){</span><span class="s1">return this</span><span class="s0">.parseClassPropertyAnnotation(e),e.optional&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(I.AccessorCannotBeOptional,{at:e}),super.parseClassAccessorProperty(e)}pushClassMethod(e,s,i,a,n,o){let u=</span><span class="s1">this</span><span class="s0">.tsTryParseTypeParameters(</span><span class="s1">this</span><span class="s0">.tsParseConstModifier);u&amp;&amp;n&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(I.ConstructorHasTypeParameters,{at:u});let{declare:c=!</span><span class="s3">1</span><span class="s0">,kind:y}=s;c&amp;&amp;(y===</span><span class="s2">&quot;get&quot;</span><span class="s0">||y===</span><span class="s2">&quot;set&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(I.DeclareAccessor,{at:s,kind:y}),u&amp;&amp;(s.typeParameters=u),super.pushClassMethod(e,s,i,a,n,o)}pushClassPrivateMethod(e,s,i,a){let n=</span><span class="s1">this</span><span class="s0">.tsTryParseTypeParameters(</span><span class="s1">this</span><span class="s0">.tsParseConstModifier);n&amp;&amp;(s.typeParameters=n),super.pushClassPrivateMethod(e,s,i,a)}declareClassPrivateMethodInScope(e,s){e.type!==</span><span class="s2">&quot;TSDeclareMethod&quot;</span><span class="s0">&amp;&amp;(e.type===</span><span class="s2">&quot;MethodDefinition&quot;</span><span class="s0">&amp;&amp;!e.value.body||super.declareClassPrivateMethodInScope(e,s))}parseClassSuper(e){super.parseClassSuper(e),e.superClass&amp;&amp;(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">47</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">51</span><span class="s0">))&amp;&amp;(e.superTypeParameters=</span><span class="s1">this</span><span class="s0">.tsParseTypeArgumentsInExpression()),</span><span class="s1">this</span><span class="s0">.eatContextual(</span><span class="s3">111</span><span class="s0">)&amp;&amp;(e.implements=</span><span class="s1">this</span><span class="s0">.tsParseHeritageClause(</span><span class="s2">&quot;implements&quot;</span><span class="s0">))}parseObjPropValue(e,s,i,a,n,o,u){let c=</span><span class="s1">this</span><span class="s0">.tsTryParseTypeParameters(</span><span class="s1">this</span><span class="s0">.tsParseConstModifier);</span><span class="s1">return </span><span class="s0">c&amp;&amp;(e.typeParameters=c),super.parseObjPropValue(e,s,i,a,n,o,u)}parseFunctionParams(e,s){let i=</span><span class="s1">this</span><span class="s0">.tsTryParseTypeParameters(</span><span class="s1">this</span><span class="s0">.tsParseConstModifier);i&amp;&amp;(e.typeParameters=i),super.parseFunctionParams(e,s)}parseVarId(e,s){super.parseVarId(e,s),e.id.type===</span><span class="s2">&quot;Identifier&quot;</span><span class="s0">&amp;&amp;!</span><span class="s1">this</span><span class="s0">.hasPrecedingLineBreak()&amp;&amp;</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">35</span><span class="s0">)&amp;&amp;(e.definite=!</span><span class="s3">0</span><span class="s0">);let i=</span><span class="s1">this</span><span class="s0">.tsTryParseTypeAnnotation();i&amp;&amp;(e.id.typeAnnotation=i,</span><span class="s1">this</span><span class="s0">.resetEndLocation(e.id))}parseAsyncArrowFromCallExpression(e,s){</span><span class="s1">return this</span><span class="s0">.match(</span><span class="s3">14</span><span class="s0">)&amp;&amp;(e.returnType=</span><span class="s1">this</span><span class="s0">.tsParseTypeAnnotation()),super.parseAsyncArrowFromCallExpression(e,s)}parseMaybeAssign(e,s){</span><span class="s1">var </span><span class="s0">i,a,n,o,u,c,y;let g,T,C;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s2">&quot;jsx&quot;</span><span class="s0">)&amp;&amp;(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">140</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">47</span><span class="s0">))){</span><span class="s1">if</span><span class="s0">(g=</span><span class="s1">this</span><span class="s0">.state.clone(),T=</span><span class="s1">this</span><span class="s0">.tryParse(()=&gt;super.parseMaybeAssign(e,s),g),!T.error)</span><span class="s1">return </span><span class="s0">T.node;let{context:K}=</span><span class="s1">this</span><span class="s0">.state,W=K[K.length-1];(W===x.j_oTag||W===x.j_expr)&amp;&amp;K.pop()}</span><span class="s1">if</span><span class="s0">(!((i=T)!=</span><span class="s1">null</span><span class="s0">&amp;&amp;i.error)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">47</span><span class="s0">))</span><span class="s1">return </span><span class="s0">super.parseMaybeAssign(e,s);(!g||g===</span><span class="s1">this</span><span class="s0">.state)&amp;&amp;(g=</span><span class="s1">this</span><span class="s0">.state.clone());let M,j=</span><span class="s1">this</span><span class="s0">.tryParse(K=&gt;{</span><span class="s1">var </span><span class="s0">W,V;M=</span><span class="s1">this</span><span class="s0">.tsParseTypeParameters(</span><span class="s1">this</span><span class="s0">.tsParseConstModifier);let X=super.parseMaybeAssign(e,s);</span><span class="s1">return</span><span class="s0">(X.type!==</span><span class="s2">&quot;ArrowFunctionExpression&quot;</span><span class="s0">||(W=X.extra)!=</span><span class="s1">null</span><span class="s0">&amp;&amp;W.parenthesized)&amp;&amp;K(),((V=M)==</span><span class="s1">null</span><span class="s0">?</span><span class="s1">void </span><span class="s3">0</span><span class="s0">:V.params.length)!==</span><span class="s3">0</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.resetStartLocationFromNode(X,M),X.typeParameters=M,X},g);</span><span class="s1">if</span><span class="s0">(!j.error&amp;&amp;!j.aborted)</span><span class="s1">return </span><span class="s0">M&amp;&amp;</span><span class="s1">this</span><span class="s0">.reportReservedArrowTypeParam(M),j.node;</span><span class="s1">if</span><span class="s0">(!T&amp;&amp;($r(!</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s2">&quot;jsx&quot;</span><span class="s0">)),C=</span><span class="s1">this</span><span class="s0">.tryParse(()=&gt;super.parseMaybeAssign(e,s),g),!C.error))</span><span class="s1">return </span><span class="s0">C.node;</span><span class="s1">if</span><span class="s0">((a=T)!=</span><span class="s1">null</span><span class="s0">&amp;&amp;a.node)</span><span class="s1">return this</span><span class="s0">.state=T.failState,T.node;</span><span class="s1">if</span><span class="s0">(j.node)</span><span class="s1">return this</span><span class="s0">.state=j.failState,M&amp;&amp;</span><span class="s1">this</span><span class="s0">.reportReservedArrowTypeParam(M),j.node;</span><span class="s1">if</span><span class="s0">((n=C)!=</span><span class="s1">null</span><span class="s0">&amp;&amp;n.node)</span><span class="s1">return this</span><span class="s0">.state=C.failState,C.node;</span><span class="s1">throw</span><span class="s0">(o=T)!=</span><span class="s1">null</span><span class="s0">&amp;&amp;o.thrown?T.error:j.thrown?j.error:(u=C)!=</span><span class="s1">null</span><span class="s0">&amp;&amp;u.thrown?C.error:((c=T)==</span><span class="s1">null</span><span class="s0">?</span><span class="s1">void </span><span class="s3">0</span><span class="s0">:c.error)||j.error||((y=C)==</span><span class="s1">null</span><span class="s0">?</span><span class="s1">void </span><span class="s3">0</span><span class="s0">:y.error)}reportReservedArrowTypeParam(e){</span><span class="s1">var </span><span class="s0">s;e.params.length===</span><span class="s3">1</span><span class="s0">&amp;&amp;!e.params[</span><span class="s3">0</span><span class="s0">].constraint&amp;&amp;!((s=e.extra)!=</span><span class="s1">null</span><span class="s0">&amp;&amp;s.trailingComma)&amp;&amp;</span><span class="s1">this</span><span class="s0">.getPluginOption(</span><span class="s2">&quot;typescript&quot;</span><span class="s0">,</span><span class="s2">&quot;disallowAmbiguousJSXLike&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(I.ReservedArrowTypeParam,{at:e})}parseMaybeUnary(e,s){</span><span class="s1">return</span><span class="s0">!</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s2">&quot;jsx&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">47</span><span class="s0">)?</span><span class="s1">this</span><span class="s0">.tsParseTypeAssertion():super.parseMaybeUnary(e,s)}parseArrow(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">14</span><span class="s0">)){let s=</span><span class="s1">this</span><span class="s0">.tryParse(i=&gt;{let a=</span><span class="s1">this</span><span class="s0">.tsParseTypeOrTypePredicateAnnotation(</span><span class="s3">14</span><span class="s0">);</span><span class="s1">return</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.canInsertSemicolon()||!</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">19</span><span class="s0">))&amp;&amp;i(),a});</span><span class="s1">if</span><span class="s0">(s.aborted)</span><span class="s1">return</span><span class="s0">;s.thrown||(s.error&amp;&amp;(</span><span class="s1">this</span><span class="s0">.state=s.failState),e.returnType=s.node)}</span><span class="s1">return </span><span class="s0">super.parseArrow(e)}parseAssignableListItemTypes(e,s){</span><span class="s1">if</span><span class="s0">(!(s&amp;</span><span class="s3">2</span><span class="s0">))</span><span class="s1">return </span><span class="s0">e;</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">17</span><span class="s0">)&amp;&amp;(e.optional=!</span><span class="s3">0</span><span class="s0">);let i=</span><span class="s1">this</span><span class="s0">.tsTryParseTypeAnnotation();</span><span class="s1">return </span><span class="s0">i&amp;&amp;(e.typeAnnotation=i),</span><span class="s1">this</span><span class="s0">.resetEndLocation(e),e}isAssignable(e,s){</span><span class="s1">switch</span><span class="s0">(e.type){</span><span class="s1">case</span><span class="s2">&quot;TSTypeCastExpression&quot;</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.isAssignable(e.expression,s);</span><span class="s1">case</span><span class="s2">&quot;TSParameterProperty&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s0">!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">default</span><span class="s0">:</span><span class="s1">return </span><span class="s0">super.isAssignable(e,s)}}toAssignable(e){let s=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">1</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">1</span><span class="s0">]:!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">switch</span><span class="s0">(e.type){</span><span class="s1">case</span><span class="s2">&quot;ParenthesizedExpression&quot;</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.toAssignableParenthesizedExpression(e,s);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;TSAsExpression&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;TSSatisfiesExpression&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;TSNonNullExpression&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;TSTypeAssertion&quot;</span><span class="s0">:s?</span><span class="s1">this</span><span class="s0">.expressionScope.recordArrowParameterBindingError(I.UnexpectedTypeCastInParameter,{at:e}):</span><span class="s1">this</span><span class="s0">.raise(I.UnexpectedTypeCastInParameter,{at:e}),</span><span class="s1">this</span><span class="s0">.toAssignable(e.expression,s);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;AssignmentExpression&quot;</span><span class="s0">:!s&amp;&amp;e.left.type===</span><span class="s2">&quot;TSTypeCastExpression&quot;</span><span class="s0">&amp;&amp;(e.left=</span><span class="s1">this</span><span class="s0">.typeCastToParameter(e.left));</span><span class="s1">default</span><span class="s0">:super.toAssignable(e,s)}}toAssignableParenthesizedExpression(e,s){</span><span class="s1">switch</span><span class="s0">(e.expression.type){</span><span class="s1">case</span><span class="s2">&quot;TSAsExpression&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;TSSatisfiesExpression&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;TSNonNullExpression&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;TSTypeAssertion&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;ParenthesizedExpression&quot;</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.toAssignable(e.expression,s);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">default</span><span class="s0">:super.toAssignable(e,s)}}checkToRestConversion(e,s){</span><span class="s1">switch</span><span class="s0">(e.type){</span><span class="s1">case</span><span class="s2">&quot;TSAsExpression&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;TSSatisfiesExpression&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;TSTypeAssertion&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;TSNonNullExpression&quot;</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.checkToRestConversion(e.expression,!</span><span class="s3">1</span><span class="s0">);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">default</span><span class="s0">:super.checkToRestConversion(e,s)}}isValidLVal(e,s,i){</span><span class="s1">return </span><span class="s0">nh({TSTypeCastExpression:!</span><span class="s3">0</span><span class="s0">,TSParameterProperty:</span><span class="s2">&quot;parameter&quot;</span><span class="s0">,TSNonNullExpression:</span><span class="s2">&quot;expression&quot;</span><span class="s0">,TSAsExpression:(i!==Pe||!s)&amp;&amp;[</span><span class="s2">&quot;expression&quot;</span><span class="s0">,!</span><span class="s3">0</span><span class="s0">],TSSatisfiesExpression:(i!==Pe||!s)&amp;&amp;[</span><span class="s2">&quot;expression&quot;</span><span class="s0">,!</span><span class="s3">0</span><span class="s0">],TSTypeAssertion:(i!==Pe||!s)&amp;&amp;[</span><span class="s2">&quot;expression&quot;</span><span class="s0">,!</span><span class="s3">0</span><span class="s0">]},e)||super.isValidLVal(e,s,i)}parseBindingAtom(){</span><span class="s1">switch</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.type){</span><span class="s1">case </span><span class="s3">78</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.parseIdentifier(!</span><span class="s3">0</span><span class="s0">);</span><span class="s1">default</span><span class="s0">:</span><span class="s1">return </span><span class="s0">super.parseBindingAtom()}}parseMaybeDecoratorArguments(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">47</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">51</span><span class="s0">)){let s=</span><span class="s1">this</span><span class="s0">.tsParseTypeArgumentsInExpression();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">10</span><span class="s0">)){let i=super.parseMaybeDecoratorArguments(e);</span><span class="s1">return </span><span class="s0">i.typeParameters=s,i}</span><span class="s1">this</span><span class="s0">.unexpected(</span><span class="s1">null</span><span class="s0">,</span><span class="s3">10</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">super.parseMaybeDecoratorArguments(e)}checkCommaAfterRest(e){</span><span class="s1">return this</span><span class="s0">.state.isAmbientContext&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">12</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.lookaheadCharCode()===e?(</span><span class="s1">this</span><span class="s0">.next(),!</span><span class="s3">1</span><span class="s0">):super.checkCommaAfterRest(e)}isClassMethod(){</span><span class="s1">return this</span><span class="s0">.match(</span><span class="s3">47</span><span class="s0">)||super.isClassMethod()}isClassProperty(){</span><span class="s1">return this</span><span class="s0">.match(</span><span class="s3">35</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">14</span><span class="s0">)||super.isClassProperty()}parseMaybeDefault(e,s){let i=super.parseMaybeDefault(e,s);</span><span class="s1">return </span><span class="s0">i.type===</span><span class="s2">&quot;AssignmentPattern&quot;</span><span class="s0">&amp;&amp;i.typeAnnotation&amp;&amp;i.right.start&lt;i.typeAnnotation.start&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(I.TypeAnnotationAfterAssign,{at:i.typeAnnotation}),i}getTokenFromCode(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.inType){</span><span class="s1">if</span><span class="s0">(e===</span><span class="s3">62</span><span class="s0">){</span><span class="s1">this</span><span class="s0">.finishOp(</span><span class="s3">48</span><span class="s0">,</span><span class="s3">1</span><span class="s0">);</span><span class="s1">return</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(e===</span><span class="s3">60</span><span class="s0">){</span><span class="s1">this</span><span class="s0">.finishOp(</span><span class="s3">47</span><span class="s0">,</span><span class="s3">1</span><span class="s0">);</span><span class="s1">return</span><span class="s0">}}super.getTokenFromCode(e)}reScan_lt_gt(){let{type:e}=</span><span class="s1">this</span><span class="s0">.state;e===</span><span class="s3">47</span><span class="s0">?(</span><span class="s1">this</span><span class="s0">.state.pos-=</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.readToken_lt()):e===</span><span class="s3">48</span><span class="s0">&amp;&amp;(</span><span class="s1">this</span><span class="s0">.state.pos-=</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.readToken_gt())}reScan_lt(){let{type:e}=</span><span class="s1">this</span><span class="s0">.state;</span><span class="s1">return </span><span class="s0">e===</span><span class="s3">51</span><span class="s0">?(</span><span class="s1">this</span><span class="s0">.state.pos-=</span><span class="s3">2</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.finishOp(</span><span class="s3">47</span><span class="s0">,</span><span class="s3">1</span><span class="s0">),</span><span class="s3">47</span><span class="s0">):e}toAssignableList(e,s,i){</span><span class="s1">for</span><span class="s0">(let a=</span><span class="s3">0</span><span class="s0">;a&lt;e.length;a++){let n=e[a];(n==</span><span class="s1">null</span><span class="s0">?</span><span class="s1">void </span><span class="s3">0</span><span class="s0">:n.type)===</span><span class="s2">&quot;TSTypeCastExpression&quot;</span><span class="s0">&amp;&amp;(e[a]=</span><span class="s1">this</span><span class="s0">.typeCastToParameter(n))}super.toAssignableList(e,s,i)}typeCastToParameter(e){</span><span class="s1">return </span><span class="s0">e.expression.typeAnnotation=e.typeAnnotation,</span><span class="s1">this</span><span class="s0">.resetEndLocation(e.expression,e.typeAnnotation.loc.end),e.expression}shouldParseArrow(e){</span><span class="s1">return this</span><span class="s0">.match(</span><span class="s3">14</span><span class="s0">)?e.every(s=&gt;</span><span class="s1">this</span><span class="s0">.isAssignable(s,!</span><span class="s3">0</span><span class="s0">)):super.shouldParseArrow(e)}shouldParseAsyncArrow(){</span><span class="s1">return this</span><span class="s0">.match(</span><span class="s3">14</span><span class="s0">)||super.shouldParseAsyncArrow()}canHaveLeadingDecorator(){</span><span class="s1">return </span><span class="s0">super.canHaveLeadingDecorator()||</span><span class="s1">this</span><span class="s0">.isAbstractClass()}jsxParseOpeningElementAfterName(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">47</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">51</span><span class="s0">)){let s=</span><span class="s1">this</span><span class="s0">.tsTryParseAndCatch(()=&gt;</span><span class="s1">this</span><span class="s0">.tsParseTypeArgumentsInExpression());s&amp;&amp;(e.typeParameters=s)}</span><span class="s1">return </span><span class="s0">super.jsxParseOpeningElementAfterName(e)}getGetterSetterExpectedParamCount(e){let s=super.getGetterSetterExpectedParamCount(e),a=</span><span class="s1">this</span><span class="s0">.getObjectOrClassMethodParams(e)[</span><span class="s3">0</span><span class="s0">];</span><span class="s1">return </span><span class="s0">a&amp;&amp;</span><span class="s1">this</span><span class="s0">.isThisParam(a)?s+</span><span class="s3">1</span><span class="s0">:s}parseCatchClauseParam(){let e=super.parseCatchClauseParam(),s=</span><span class="s1">this</span><span class="s0">.tsTryParseTypeAnnotation();</span><span class="s1">return </span><span class="s0">s&amp;&amp;(e.typeAnnotation=s,</span><span class="s1">this</span><span class="s0">.resetEndLocation(e)),e}tsInAmbientContext(e){let s=</span><span class="s1">this</span><span class="s0">.state.isAmbientContext;</span><span class="s1">this</span><span class="s0">.state.isAmbientContext=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">try</span><span class="s0">{</span><span class="s1">return </span><span class="s0">e()}</span><span class="s1">finally</span><span class="s0">{</span><span class="s1">this</span><span class="s0">.state.isAmbientContext=s}}parseClass(e,s,i){let a=</span><span class="s1">this</span><span class="s0">.state.inAbstractClass;</span><span class="s1">this</span><span class="s0">.state.inAbstractClass=!!e.abstract;</span><span class="s1">try</span><span class="s0">{</span><span class="s1">return </span><span class="s0">super.parseClass(e,s,i)}</span><span class="s1">finally</span><span class="s0">{</span><span class="s1">this</span><span class="s0">.state.inAbstractClass=a}}tsParseAbstractDeclaration(e,s){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">80</span><span class="s0">))</span><span class="s1">return </span><span class="s0">e.abstract=!</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.maybeTakeDecorators(s,</span><span class="s1">this</span><span class="s0">.parseClass(e,!</span><span class="s3">0</span><span class="s0">,!</span><span class="s3">1</span><span class="s0">));</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">127</span><span class="s0">)){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.hasFollowingLineBreak())</span><span class="s1">return </span><span class="s0">e.abstract=!</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.raise(I.NonClassMethodPropertyHasAbstractModifer,{at:e}),</span><span class="s1">this</span><span class="s0">.tsParseInterfaceDeclaration(e)}</span><span class="s1">else this</span><span class="s0">.unexpected(</span><span class="s1">null</span><span class="s0">,</span><span class="s3">80</span><span class="s0">)}parseMethod(e,s,i,a,n,o,u){let c=super.parseMethod(e,s,i,a,n,o,u);</span><span class="s1">if</span><span class="s0">(c.abstract&amp;&amp;(</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s2">&quot;estree&quot;</span><span class="s0">)?!!c.value.body:!!c.body)){let{key:g}=c;</span><span class="s1">this</span><span class="s0">.raise(I.AbstractMethodHasImplementation,{at:c,methodName:g.type===</span><span class="s2">&quot;Identifier&quot;</span><span class="s0">&amp;&amp;!c.computed?g.name:`[${</span><span class="s1">this</span><span class="s0">.input.slice(g.start,g.end)}]`})}</span><span class="s1">return </span><span class="s0">c}tsParseTypeParameterName(){</span><span class="s1">return this</span><span class="s0">.parseIdentifier().name}shouldParseAsAmbientContext(){</span><span class="s1">return</span><span class="s0">!!</span><span class="s1">this</span><span class="s0">.getPluginOption(</span><span class="s2">&quot;typescript&quot;</span><span class="s0">,</span><span class="s2">&quot;dts&quot;</span><span class="s0">)}parse(){</span><span class="s1">return this</span><span class="s0">.shouldParseAsAmbientContext()&amp;&amp;(</span><span class="s1">this</span><span class="s0">.state.isAmbientContext=!</span><span class="s3">0</span><span class="s0">),super.parse()}getExpression(){</span><span class="s1">return this</span><span class="s0">.shouldParseAsAmbientContext()&amp;&amp;(</span><span class="s1">this</span><span class="s0">.state.isAmbientContext=!</span><span class="s3">0</span><span class="s0">),super.getExpression()}parseExportSpecifier(e,s,i,a){</span><span class="s1">return</span><span class="s0">!s&amp;&amp;a?(</span><span class="s1">this</span><span class="s0">.parseTypeOnlyImportExportSpecifier(e,!</span><span class="s3">1</span><span class="s0">,i),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;ExportSpecifier&quot;</span><span class="s0">)):(e.exportKind=</span><span class="s2">&quot;value&quot;</span><span class="s0">,super.parseExportSpecifier(e,s,i,a))}parseImportSpecifier(e,s,i,a,n){</span><span class="s1">return</span><span class="s0">!s&amp;&amp;a?(</span><span class="s1">this</span><span class="s0">.parseTypeOnlyImportExportSpecifier(e,!</span><span class="s3">0</span><span class="s0">,i),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;ImportSpecifier&quot;</span><span class="s0">)):(e.importKind=</span><span class="s2">&quot;value&quot;</span><span class="s0">,super.parseImportSpecifier(e,s,i,a,i?Sr:Ve))}parseTypeOnlyImportExportSpecifier(e,s,i){let a=s?</span><span class="s2">&quot;imported&quot;</span><span class="s0">:</span><span class="s2">&quot;local&quot;</span><span class="s0">,n=s?</span><span class="s2">&quot;local&quot;</span><span class="s0">:</span><span class="s2">&quot;exported&quot;</span><span class="s0">,o=e[a],u,c=!</span><span class="s3">1</span><span class="s0">,y=!</span><span class="s3">0</span><span class="s0">,g=o.loc.start;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">93</span><span class="s0">)){let C=</span><span class="s1">this</span><span class="s0">.parseIdentifier();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">93</span><span class="s0">)){let M=</span><span class="s1">this</span><span class="s0">.parseIdentifier();te(</span><span class="s1">this</span><span class="s0">.state.type)?(c=!</span><span class="s3">0</span><span class="s0">,o=C,u=s?</span><span class="s1">this</span><span class="s0">.parseIdentifier():</span><span class="s1">this</span><span class="s0">.parseModuleExportName(),y=!</span><span class="s3">1</span><span class="s0">):(u=M,y=!</span><span class="s3">1</span><span class="s0">)}</span><span class="s1">else </span><span class="s0">te(</span><span class="s1">this</span><span class="s0">.state.type)?(y=!</span><span class="s3">1</span><span class="s0">,u=s?</span><span class="s1">this</span><span class="s0">.parseIdentifier():</span><span class="s1">this</span><span class="s0">.parseModuleExportName()):(c=!</span><span class="s3">0</span><span class="s0">,o=C)}</span><span class="s1">else </span><span class="s0">te(</span><span class="s1">this</span><span class="s0">.state.type)&amp;&amp;(c=!</span><span class="s3">0</span><span class="s0">,s?(o=</span><span class="s1">this</span><span class="s0">.parseIdentifier(!</span><span class="s3">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">93</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.checkReservedWord(o.name,o.loc.start,!</span><span class="s3">0</span><span class="s0">,!</span><span class="s3">0</span><span class="s0">)):o=</span><span class="s1">this</span><span class="s0">.parseModuleExportName());c&amp;&amp;i&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(s?I.TypeModifierIsUsedInTypeImports:I.TypeModifierIsUsedInTypeExports,{at:g}),e[a]=o,e[n]=u;let T=s?</span><span class="s2">&quot;importKind&quot;</span><span class="s0">:</span><span class="s2">&quot;exportKind&quot;</span><span class="s0">;e[T]=c?</span><span class="s2">&quot;type&quot;</span><span class="s0">:</span><span class="s2">&quot;value&quot;</span><span class="s0">,y&amp;&amp;</span><span class="s1">this</span><span class="s0">.eatContextual(</span><span class="s3">93</span><span class="s0">)&amp;&amp;(e[n]=s?</span><span class="s1">this</span><span class="s0">.parseIdentifier():</span><span class="s1">this</span><span class="s0">.parseModuleExportName()),e[n]||(e[n]=me(e[a])),s&amp;&amp;</span><span class="s1">this</span><span class="s0">.checkIdentifier(e[n],c?Sr:Ve)}};</span><span class="s1">function </span><span class="s0">ch(t){</span><span class="s1">if</span><span class="s0">(t.type!==</span><span class="s2">&quot;MemberExpression&quot;</span><span class="s0">)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;let{computed:r,property:e}=t;</span><span class="s1">return </span><span class="s0">r&amp;&amp;e.type!==</span><span class="s2">&quot;StringLiteral&quot;</span><span class="s0">&amp;&amp;(e.type!==</span><span class="s2">&quot;TemplateLiteral&quot;</span><span class="s0">||e.expressions.length&gt;</span><span class="s3">0</span><span class="s0">)?!</span><span class="s3">1</span><span class="s0">:Vr(t.object)}</span><span class="s1">function </span><span class="s0">ph(t,r){</span><span class="s1">var </span><span class="s0">e;let{type:s}=t;</span><span class="s1">if</span><span class="s0">((e=t.extra)!=</span><span class="s1">null</span><span class="s0">&amp;&amp;e.parenthesized)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(r){</span><span class="s1">if</span><span class="s0">(s===</span><span class="s2">&quot;Literal&quot;</span><span class="s0">){let{value:i}=t;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">i==</span><span class="s2">&quot;string&quot;</span><span class="s0">||</span><span class="s1">typeof </span><span class="s0">i==</span><span class="s2">&quot;boolean&quot;</span><span class="s0">)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">0</span><span class="s0">}}</span><span class="s1">else if</span><span class="s0">(s===</span><span class="s2">&quot;StringLiteral&quot;</span><span class="s0">||s===</span><span class="s2">&quot;BooleanLiteral&quot;</span><span class="s0">)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">return</span><span class="s0">!!(zr(t,r)||fh(t,r)||s===</span><span class="s2">&quot;TemplateLiteral&quot;</span><span class="s0">&amp;&amp;t.expressions.length===</span><span class="s3">0</span><span class="s0">||ch(t))}</span><span class="s1">function </span><span class="s0">zr(t,r){</span><span class="s1">return </span><span class="s0">r?t.type===</span><span class="s2">&quot;Literal&quot;</span><span class="s0">&amp;&amp;(</span><span class="s1">typeof </span><span class="s0">t.value==</span><span class="s2">&quot;number&quot;</span><span class="s0">||</span><span class="s2">&quot;bigint&quot;</span><span class="s1">in </span><span class="s0">t):t.type===</span><span class="s2">&quot;NumericLiteral&quot;</span><span class="s0">||t.type===</span><span class="s2">&quot;BigIntLiteral&quot;</span><span class="s0">}</span><span class="s1">function </span><span class="s0">fh(t,r){</span><span class="s1">if</span><span class="s0">(t.type===</span><span class="s2">&quot;UnaryExpression&quot;</span><span class="s0">){let{operator:e,argument:s}=t;</span><span class="s1">if</span><span class="s0">(e===</span><span class="s2">&quot;-&quot;</span><span class="s0">&amp;&amp;zr(s,r))</span><span class="s1">return</span><span class="s0">!</span><span class="s3">0</span><span class="s0">}</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">}</span><span class="s1">function </span><span class="s0">Vr(t){</span><span class="s1">return </span><span class="s0">t.type===</span><span class="s2">&quot;Identifier&quot;</span><span class="s0">?!</span><span class="s3">0</span><span class="s0">:t.type!==</span><span class="s2">&quot;MemberExpression&quot;</span><span class="s0">||t.computed?!</span><span class="s3">1</span><span class="s0">:Vr(t.object)}</span><span class="s1">var </span><span class="s0">Kr=pe`placeholders`({ClassNameIsRequired:</span><span class="s2">&quot;A class name is required.&quot;</span><span class="s0">,UnexpectedSpace:</span><span class="s2">&quot;Unexpected space in placeholder.&quot;</span><span class="s0">}),dh=t=&gt;class extends t{parsePlaceholder(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">142</span><span class="s0">)){let s=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.assertNoSpace(),s.name=super.parseIdentifier(!</span><span class="s3">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.assertNoSpace(),</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">142</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishPlaceholder(s,e)}}finishPlaceholder(e,s){let i=!!(e.expectedNode&amp;&amp;e.type===</span><span class="s2">&quot;Placeholder&quot;</span><span class="s0">);</span><span class="s1">return </span><span class="s0">e.expectedNode=s,i?e:</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;Placeholder&quot;</span><span class="s0">)}getTokenFromCode(e){e===</span><span class="s3">37</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.state.pos+</span><span class="s3">1</span><span class="s0">)===</span><span class="s3">37</span><span class="s0">?</span><span class="s1">this</span><span class="s0">.finishOp(</span><span class="s3">142</span><span class="s0">,</span><span class="s3">2</span><span class="s0">):super.getTokenFromCode(e)}parseExprAtom(e){</span><span class="s1">return this</span><span class="s0">.parsePlaceholder(</span><span class="s2">&quot;Expression&quot;</span><span class="s0">)||super.parseExprAtom(e)}parseIdentifier(e){</span><span class="s1">return this</span><span class="s0">.parsePlaceholder(</span><span class="s2">&quot;Identifier&quot;</span><span class="s0">)||super.parseIdentifier(e)}checkReservedWord(e,s,i,a){e!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">&amp;&amp;super.checkReservedWord(e,s,i,a)}parseBindingAtom(){</span><span class="s1">return this</span><span class="s0">.parsePlaceholder(</span><span class="s2">&quot;Pattern&quot;</span><span class="s0">)||super.parseBindingAtom()}isValidLVal(e,s,i){</span><span class="s1">return </span><span class="s0">e===</span><span class="s2">&quot;Placeholder&quot;</span><span class="s0">||super.isValidLVal(e,s,i)}toAssignable(e,s){e&amp;&amp;e.type===</span><span class="s2">&quot;Placeholder&quot;</span><span class="s0">&amp;&amp;e.expectedNode===</span><span class="s2">&quot;Expression&quot;</span><span class="s0">?e.expectedNode=</span><span class="s2">&quot;Pattern&quot;</span><span class="s0">:super.toAssignable(e,s)}chStartsBindingIdentifier(e,s){</span><span class="s1">return</span><span class="s0">!!(super.chStartsBindingIdentifier(e,s)||</span><span class="s1">this</span><span class="s0">.lookahead().type===</span><span class="s3">142</span><span class="s0">)}verifyBreakContinue(e,s){e.label&amp;&amp;e.label.type===</span><span class="s2">&quot;Placeholder&quot;</span><span class="s0">||super.verifyBreakContinue(e,s)}parseExpressionStatement(e,s){</span><span class="s1">if</span><span class="s0">(s.type!==</span><span class="s2">&quot;Placeholder&quot;</span><span class="s0">||s.extra&amp;&amp;s.extra.parenthesized)</span><span class="s1">return </span><span class="s0">super.parseExpressionStatement(e,s);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">14</span><span class="s0">)){let i=e;</span><span class="s1">return </span><span class="s0">i.label=</span><span class="s1">this</span><span class="s0">.finishPlaceholder(s,</span><span class="s2">&quot;Identifier&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.next(),i.body=super.parseStatementOrSloppyAnnexBFunctionDeclaration(),</span><span class="s1">this</span><span class="s0">.finishNode(i,</span><span class="s2">&quot;LabeledStatement&quot;</span><span class="s0">)}</span><span class="s1">return this</span><span class="s0">.semicolon(),e.name=s.name,</span><span class="s1">this</span><span class="s0">.finishPlaceholder(e,</span><span class="s2">&quot;Statement&quot;</span><span class="s0">)}parseBlock(e,s,i){</span><span class="s1">return this</span><span class="s0">.parsePlaceholder(</span><span class="s2">&quot;BlockStatement&quot;</span><span class="s0">)||super.parseBlock(e,s,i)}parseFunctionId(e){</span><span class="s1">return this</span><span class="s0">.parsePlaceholder(</span><span class="s2">&quot;Identifier&quot;</span><span class="s0">)||super.parseFunctionId(e)}parseClass(e,s,i){let a=s?</span><span class="s2">&quot;ClassDeclaration&quot;</span><span class="s0">:</span><span class="s2">&quot;ClassExpression&quot;</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.next();let n=</span><span class="s1">this</span><span class="s0">.state.strict,o=</span><span class="s1">this</span><span class="s0">.parsePlaceholder(</span><span class="s2">&quot;Identifier&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(o)</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">81</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">142</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">5</span><span class="s0">))e.id=o;</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(i||!s)</span><span class="s1">return </span><span class="s0">e.id=</span><span class="s1">null</span><span class="s0">,e.body=</span><span class="s1">this</span><span class="s0">.finishPlaceholder(o,</span><span class="s2">&quot;ClassBody&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(e,a);</span><span class="s1">throw this</span><span class="s0">.raise(Kr.ClassNameIsRequired,{at:</span><span class="s1">this</span><span class="s0">.state.startLoc})}</span><span class="s1">else this</span><span class="s0">.parseClassId(e,s,i);</span><span class="s1">return </span><span class="s0">super.parseClassSuper(e),e.body=</span><span class="s1">this</span><span class="s0">.parsePlaceholder(</span><span class="s2">&quot;ClassBody&quot;</span><span class="s0">)||super.parseClassBody(!!e.superClass,n),</span><span class="s1">this</span><span class="s0">.finishNode(e,a)}parseExport(e,s){let i=</span><span class="s1">this</span><span class="s0">.parsePlaceholder(</span><span class="s2">&quot;Identifier&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(!i)</span><span class="s1">return </span><span class="s0">super.parseExport(e,s);</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">97</span><span class="s0">)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">12</span><span class="s0">))</span><span class="s1">return </span><span class="s0">e.specifiers=[],e.source=</span><span class="s1">null</span><span class="s0">,e.declaration=</span><span class="s1">this</span><span class="s0">.finishPlaceholder(i,</span><span class="s2">&quot;Declaration&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;ExportNamedDeclaration&quot;</span><span class="s0">);</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s2">&quot;exportDefaultFrom&quot;</span><span class="s0">);let a=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">a.exported=i,e.specifiers=[</span><span class="s1">this</span><span class="s0">.finishNode(a,</span><span class="s2">&quot;ExportDefaultSpecifier&quot;</span><span class="s0">)],super.parseExport(e,s)}isExportDefaultSpecifier(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">65</span><span class="s0">)){let e=</span><span class="s1">this</span><span class="s0">.nextTokenStart();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isUnparsedContextual(e,</span><span class="s2">&quot;from&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.input.startsWith(xe(</span><span class="s3">142</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.nextTokenStartSince(e+</span><span class="s3">4</span><span class="s0">)))</span><span class="s1">return</span><span class="s0">!</span><span class="s3">0</span><span class="s0">}</span><span class="s1">return </span><span class="s0">super.isExportDefaultSpecifier()}maybeParseExportDefaultSpecifier(e){</span><span class="s1">return </span><span class="s0">e.specifiers&amp;&amp;e.specifiers.length&gt;</span><span class="s3">0</span><span class="s0">?!</span><span class="s3">0</span><span class="s0">:super.maybeParseExportDefaultSpecifier(e)}checkExport(e){let{specifiers:s}=e;s!=</span><span class="s1">null</span><span class="s0">&amp;&amp;s.length&amp;&amp;(e.specifiers=s.filter(i=&gt;i.exported.type===</span><span class="s2">&quot;Placeholder&quot;</span><span class="s0">)),super.checkExport(e),e.specifiers=s}parseImport(e){let s=</span><span class="s1">this</span><span class="s0">.parsePlaceholder(</span><span class="s2">&quot;Identifier&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(!s)</span><span class="s1">return </span><span class="s0">super.parseImport(e);</span><span class="s1">if</span><span class="s0">(e.specifiers=[],!</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">97</span><span class="s0">)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">12</span><span class="s0">))</span><span class="s1">return </span><span class="s0">e.source=</span><span class="s1">this</span><span class="s0">.finishPlaceholder(s,</span><span class="s2">&quot;StringLiteral&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;ImportDeclaration&quot;</span><span class="s0">);let i=</span><span class="s1">this</span><span class="s0">.startNodeAtNode(s);</span><span class="s1">return </span><span class="s0">i.local=s,e.specifiers.push(</span><span class="s1">this</span><span class="s0">.finishNode(i,</span><span class="s2">&quot;ImportDefaultSpecifier&quot;</span><span class="s0">)),</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">12</span><span class="s0">)&amp;&amp;(</span><span class="s1">this</span><span class="s0">.maybeParseStarImportSpecifier(e)||</span><span class="s1">this</span><span class="s0">.parseNamedImportSpecifiers(e)),</span><span class="s1">this</span><span class="s0">.expectContextual(</span><span class="s3">97</span><span class="s0">),e.source=</span><span class="s1">this</span><span class="s0">.parseImportSource(),</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;ImportDeclaration&quot;</span><span class="s0">)}parseImportSource(){</span><span class="s1">return this</span><span class="s0">.parsePlaceholder(</span><span class="s2">&quot;StringLiteral&quot;</span><span class="s0">)||super.parseImportSource()}assertNoSpace(){</span><span class="s1">this</span><span class="s0">.state.start&gt;</span><span class="s1">this</span><span class="s0">.state.lastTokEndLoc.index&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(Kr.UnexpectedSpace,{at:</span><span class="s1">this</span><span class="s0">.state.lastTokEndLoc})}},mh=t=&gt;class extends t{parseV8Intrinsic(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">54</span><span class="s0">)){let e=</span><span class="s1">this</span><span class="s0">.state.startLoc,s=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.next(),q(</span><span class="s1">this</span><span class="s0">.state.type)){let i=</span><span class="s1">this</span><span class="s0">.parseIdentifierName(),a=</span><span class="s1">this</span><span class="s0">.createIdentifier(s,i);</span><span class="s1">if</span><span class="s0">(a.type=</span><span class="s2">&quot;V8IntrinsicIdentifier&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">10</span><span class="s0">))</span><span class="s1">return </span><span class="s0">a}</span><span class="s1">this</span><span class="s0">.unexpected(e)}}parseExprAtom(e){</span><span class="s1">return this</span><span class="s0">.parseV8Intrinsic()||super.parseExprAtom(e)}};</span><span class="s1">function </span><span class="s0">J(t,r){let[e,s]=</span><span class="s1">typeof </span><span class="s0">r==</span><span class="s2">&quot;string&quot;</span><span class="s0">?[r,{}]:r,i=Object.keys(s),a=i.length===</span><span class="s3">0</span><span class="s0">;</span><span class="s1">return </span><span class="s0">t.some(n=&gt;{</span><span class="s1">if</span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">n==</span><span class="s2">&quot;string&quot;</span><span class="s0">)</span><span class="s1">return </span><span class="s0">a&amp;&amp;n===e;{let[o,u]=n;</span><span class="s1">if</span><span class="s0">(o!==e)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(let c of i)</span><span class="s1">if</span><span class="s0">(u[c]!==s[c])</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">return</span><span class="s0">!</span><span class="s3">0</span><span class="s0">}})}</span><span class="s1">function </span><span class="s0">we(t,r,e){let s=t.find(i=&gt;Array.isArray(i)?i[</span><span class="s3">0</span><span class="s0">]===r:i===r);</span><span class="s1">return </span><span class="s0">s&amp;&amp;Array.isArray(s)&amp;&amp;s.length&gt;</span><span class="s3">1</span><span class="s0">?s[</span><span class="s3">1</span><span class="s0">][e]:</span><span class="s1">null</span><span class="s0">}</span><span class="s1">var </span><span class="s0">Wr=[</span><span class="s2">&quot;minimal&quot;</span><span class="s0">,</span><span class="s2">&quot;fsharp&quot;</span><span class="s0">,</span><span class="s2">&quot;hack&quot;</span><span class="s0">,</span><span class="s2">&quot;smart&quot;</span><span class="s0">],Gr=[</span><span class="s2">&quot;^^&quot;</span><span class="s0">,</span><span class="s2">&quot;@@&quot;</span><span class="s0">,</span><span class="s2">&quot;^&quot;</span><span class="s0">,</span><span class="s2">&quot;%&quot;</span><span class="s0">,</span><span class="s2">&quot;#&quot;</span><span class="s0">],Jr=[</span><span class="s2">&quot;hash&quot;</span><span class="s0">,</span><span class="s2">&quot;bar&quot;</span><span class="s0">];</span><span class="s1">function </span><span class="s0">yh(t){</span><span class="s1">if</span><span class="s0">(J(t,</span><span class="s2">&quot;decorators&quot;</span><span class="s0">)){</span><span class="s1">if</span><span class="s0">(J(t,</span><span class="s2">&quot;decorators-legacy&quot;</span><span class="s0">))</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;Cannot use the decorators and decorators-legacy plugin together&quot;</span><span class="s0">);let r=we(t,</span><span class="s2">&quot;decorators&quot;</span><span class="s0">,</span><span class="s2">&quot;decoratorsBeforeExport&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(r!=</span><span class="s1">null</span><span class="s0">&amp;&amp;</span><span class="s1">typeof </span><span class="s0">r!=</span><span class="s2">&quot;boolean&quot;</span><span class="s0">)</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;'decoratorsBeforeExport' must be a boolean, if specified.&quot;</span><span class="s0">);let e=we(t,</span><span class="s2">&quot;decorators&quot;</span><span class="s0">,</span><span class="s2">&quot;allowCallParenthesized&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(e!=</span><span class="s1">null</span><span class="s0">&amp;&amp;</span><span class="s1">typeof </span><span class="s0">e!=</span><span class="s2">&quot;boolean&quot;</span><span class="s0">)</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;'allowCallParenthesized' must be a boolean.&quot;</span><span class="s0">)}</span><span class="s1">if</span><span class="s0">(J(t,</span><span class="s2">&quot;flow&quot;</span><span class="s0">)&amp;&amp;J(t,</span><span class="s2">&quot;typescript&quot;</span><span class="s0">))</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;Cannot combine flow and typescript plugins.&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(J(t,</span><span class="s2">&quot;placeholders&quot;</span><span class="s0">)&amp;&amp;J(t,</span><span class="s2">&quot;v8intrinsic&quot;</span><span class="s0">))</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;Cannot combine placeholders and v8intrinsic plugins.&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(J(t,</span><span class="s2">&quot;pipelineOperator&quot;</span><span class="s0">)){let r=we(t,</span><span class="s2">&quot;pipelineOperator&quot;</span><span class="s0">,</span><span class="s2">&quot;proposal&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(!Wr.includes(r)){let s=Wr.map(i=&gt;`</span><span class="s2">&quot;${i}&quot;</span><span class="s0">`).join(</span><span class="s2">&quot;, &quot;</span><span class="s0">);</span><span class="s1">throw new </span><span class="s0">Error(`</span><span class="s2">&quot;pipelineOperator&quot; </span><span class="s0">requires </span><span class="s2">&quot;proposal&quot; </span><span class="s0">option whose value must be one of: ${s}.`)}let e=J(t,[</span><span class="s2">&quot;recordAndTuple&quot;</span><span class="s0">,{syntaxType:</span><span class="s2">&quot;hash&quot;</span><span class="s0">}]);</span><span class="s1">if</span><span class="s0">(r===</span><span class="s2">&quot;hack&quot;</span><span class="s0">){</span><span class="s1">if</span><span class="s0">(J(t,</span><span class="s2">&quot;placeholders&quot;</span><span class="s0">))</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;Cannot combine placeholders plugin and Hack-style pipes.&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(J(t,</span><span class="s2">&quot;v8intrinsic&quot;</span><span class="s0">))</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;Cannot combine v8intrinsic plugin and Hack-style pipes.&quot;</span><span class="s0">);let s=we(t,</span><span class="s2">&quot;pipelineOperator&quot;</span><span class="s0">,</span><span class="s2">&quot;topicToken&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(!Gr.includes(s)){let i=Gr.map(a=&gt;`</span><span class="s2">&quot;${a}&quot;</span><span class="s0">`).join(</span><span class="s2">&quot;, &quot;</span><span class="s0">);</span><span class="s1">throw new </span><span class="s0">Error(`</span><span class="s2">&quot;pipelineOperator&quot; </span><span class="s1">in </span><span class="s2">&quot;proposal&quot;</span><span class="s0">: </span><span class="s2">&quot;hack&quot; </span><span class="s0">mode also requires a </span><span class="s2">&quot;topicToken&quot; </span><span class="s0">option whose value must be one of: ${i}.`)}</span><span class="s1">if</span><span class="s0">(s===</span><span class="s2">&quot;#&quot;</span><span class="s0">&amp;&amp;e)</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'Plugin conflict between `[&quot;pipelineOperator&quot;, { proposal: &quot;hack&quot;, topicToken: &quot;#&quot; }]` and `[&quot;recordAndtuple&quot;, { syntaxType: &quot;hash&quot;}]`.'</span><span class="s0">)}</span><span class="s1">else if</span><span class="s0">(r===</span><span class="s2">&quot;smart&quot;</span><span class="s0">&amp;&amp;e)</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'Plugin conflict between `[&quot;pipelineOperator&quot;, { proposal: &quot;smart&quot; }]` and `[&quot;recordAndtuple&quot;, { syntaxType: &quot;hash&quot;}]`.'</span><span class="s0">)}</span><span class="s1">if</span><span class="s0">(J(t,</span><span class="s2">&quot;moduleAttributes&quot;</span><span class="s0">)){</span><span class="s1">if</span><span class="s0">(J(t,</span><span class="s2">&quot;importAssertions&quot;</span><span class="s0">))</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;Cannot combine importAssertions and moduleAttributes plugins.&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(we(t,</span><span class="s2">&quot;moduleAttributes&quot;</span><span class="s0">,</span><span class="s2">&quot;version&quot;</span><span class="s0">)!==</span><span class="s2">&quot;may-2020&quot;</span><span class="s0">)</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.&quot;</span><span class="s0">)}</span><span class="s1">if</span><span class="s0">(J(t,</span><span class="s2">&quot;recordAndTuple&quot;</span><span class="s0">)&amp;&amp;we(t,</span><span class="s2">&quot;recordAndTuple&quot;</span><span class="s0">,</span><span class="s2">&quot;syntaxType&quot;</span><span class="s0">)!=</span><span class="s1">null</span><span class="s0">&amp;&amp;!Jr.includes(we(t,</span><span class="s2">&quot;recordAndTuple&quot;</span><span class="s0">,</span><span class="s2">&quot;syntaxType&quot;</span><span class="s0">)))</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: &quot;</span><span class="s0">+Jr.map(r=&gt;`</span><span class="s2">'${r}'</span><span class="s0">`).join(</span><span class="s2">&quot;, &quot;</span><span class="s0">));</span><span class="s1">if</span><span class="s0">(J(t,</span><span class="s2">&quot;asyncDoExpressions&quot;</span><span class="s0">)&amp;&amp;!J(t,</span><span class="s2">&quot;doExpressions&quot;</span><span class="s0">)){let r=</span><span class="s1">new </span><span class="s0">Error(</span><span class="s2">&quot;'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.&quot;</span><span class="s0">);</span><span class="s1">throw </span><span class="s0">r.missingPlugins=</span><span class="s2">&quot;doExpressions&quot;</span><span class="s0">,r}}</span><span class="s1">var </span><span class="s0">Xr={estree:el,jsx:th,flow:Zl,typescript:uh,v8intrinsic:mh,placeholders:dh},xh=Object.keys(Xr),gh=class extends ah{checkProto(t,r,e,s){</span><span class="s1">if</span><span class="s0">(t.type===</span><span class="s2">&quot;SpreadElement&quot;</span><span class="s0">||</span><span class="s1">this</span><span class="s0">.isObjectMethod(t)||t.computed||t.shorthand)</span><span class="s1">return</span><span class="s0">;let i=t.key;</span><span class="s1">if</span><span class="s0">((i.type===</span><span class="s2">&quot;Identifier&quot;</span><span class="s0">?i.name:i.value)===</span><span class="s2">&quot;__proto__&quot;</span><span class="s0">){</span><span class="s1">if</span><span class="s0">(r){</span><span class="s1">this</span><span class="s0">.raise(f.RecordNoProto,{at:i});</span><span class="s1">return</span><span class="s0">}e.used&amp;&amp;(s?s.doubleProtoLoc===</span><span class="s1">null</span><span class="s0">&amp;&amp;(s.doubleProtoLoc=i.loc.start):</span><span class="s1">this</span><span class="s0">.raise(f.DuplicateProto,{at:i})),e.used=!</span><span class="s3">0</span><span class="s0">}}shouldExitDescending(t,r){</span><span class="s1">return </span><span class="s0">t.type===</span><span class="s2">&quot;ArrowFunctionExpression&quot;</span><span class="s0">&amp;&amp;t.start===r}getExpression(){</span><span class="s1">this</span><span class="s0">.enterInitialScopes(),</span><span class="s1">this</span><span class="s0">.nextToken();let t=</span><span class="s1">this</span><span class="s0">.parseExpression();</span><span class="s1">return this</span><span class="s0">.match(</span><span class="s3">137</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.unexpected(),</span><span class="s1">this</span><span class="s0">.finalizeRemainingComments(),t.comments=</span><span class="s1">this</span><span class="s0">.state.comments,t.errors=</span><span class="s1">this</span><span class="s0">.state.errors,</span><span class="s1">this</span><span class="s0">.options.tokens&amp;&amp;(t.tokens=</span><span class="s1">this</span><span class="s0">.tokens),t}parseExpression(t,r){</span><span class="s1">return </span><span class="s0">t?</span><span class="s1">this</span><span class="s0">.disallowInAnd(()=&gt;</span><span class="s1">this</span><span class="s0">.parseExpressionBase(r)):</span><span class="s1">this</span><span class="s0">.allowInAnd(()=&gt;</span><span class="s1">this</span><span class="s0">.parseExpressionBase(r))}parseExpressionBase(t){let r=</span><span class="s1">this</span><span class="s0">.state.startLoc,e=</span><span class="s1">this</span><span class="s0">.parseMaybeAssign(t);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">12</span><span class="s0">)){let s=</span><span class="s1">this</span><span class="s0">.startNodeAt(r);</span><span class="s1">for</span><span class="s0">(s.expressions=[e];</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">12</span><span class="s0">);)s.expressions.push(</span><span class="s1">this</span><span class="s0">.parseMaybeAssign(t));</span><span class="s1">return this</span><span class="s0">.toReferencedList(s.expressions),</span><span class="s1">this</span><span class="s0">.finishNode(s,</span><span class="s2">&quot;SequenceExpression&quot;</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">e}parseMaybeAssignDisallowIn(t,r){</span><span class="s1">return this</span><span class="s0">.disallowInAnd(()=&gt;</span><span class="s1">this</span><span class="s0">.parseMaybeAssign(t,r))}parseMaybeAssignAllowIn(t,r){</span><span class="s1">return this</span><span class="s0">.allowInAnd(()=&gt;</span><span class="s1">this</span><span class="s0">.parseMaybeAssign(t,r))}setOptionalParametersError(t,r){</span><span class="s1">var </span><span class="s0">e;t.optionalParametersLoc=(e=r==</span><span class="s1">null</span><span class="s0">?</span><span class="s1">void </span><span class="s3">0</span><span class="s0">:r.loc)!=</span><span class="s1">null</span><span class="s0">?e:</span><span class="s1">this</span><span class="s0">.state.startLoc}parseMaybeAssign(t,r){let e=</span><span class="s1">this</span><span class="s0">.state.startLoc;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">106</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.prodParam.hasYield){let n=</span><span class="s1">this</span><span class="s0">.parseYield();</span><span class="s1">return </span><span class="s0">r&amp;&amp;(n=r.call(</span><span class="s1">this</span><span class="s0">,n,e)),n}let s;t?s=!</span><span class="s3">1</span><span class="s0">:(t=</span><span class="s1">new </span><span class="s0">vt,s=!</span><span class="s3">0</span><span class="s0">);let{type:i}=</span><span class="s1">this</span><span class="s0">.state;(i===</span><span class="s3">10</span><span class="s0">||q(i))&amp;&amp;(</span><span class="s1">this</span><span class="s0">.state.potentialArrowAt=</span><span class="s1">this</span><span class="s0">.state.start);let a=</span><span class="s1">this</span><span class="s0">.parseMaybeConditional(t);</span><span class="s1">if</span><span class="s0">(r&amp;&amp;(a=r.call(</span><span class="s1">this</span><span class="s0">,a,e)),Bo(</span><span class="s1">this</span><span class="s0">.state.type)){let n=</span><span class="s1">this</span><span class="s0">.startNodeAt(e),o=</span><span class="s1">this</span><span class="s0">.state.value;</span><span class="s1">if</span><span class="s0">(n.operator=o,</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">29</span><span class="s0">)){</span><span class="s1">this</span><span class="s0">.toAssignable(a,!</span><span class="s3">0</span><span class="s0">),n.left=a;let u=e.index;t.doubleProtoLoc!=</span><span class="s1">null</span><span class="s0">&amp;&amp;t.doubleProtoLoc.index&gt;=u&amp;&amp;(t.doubleProtoLoc=</span><span class="s1">null</span><span class="s0">),t.shorthandAssignLoc!=</span><span class="s1">null</span><span class="s0">&amp;&amp;t.shorthandAssignLoc.index&gt;=u&amp;&amp;(t.shorthandAssignLoc=</span><span class="s1">null</span><span class="s0">),t.privateKeyLoc!=</span><span class="s1">null</span><span class="s0">&amp;&amp;t.privateKeyLoc.index&gt;=u&amp;&amp;(</span><span class="s1">this</span><span class="s0">.checkDestructuringPrivate(t),t.privateKeyLoc=</span><span class="s1">null</span><span class="s0">)}</span><span class="s1">else </span><span class="s0">n.left=a;</span><span class="s1">return this</span><span class="s0">.next(),n.right=</span><span class="s1">this</span><span class="s0">.parseMaybeAssign(),</span><span class="s1">this</span><span class="s0">.checkLVal(a,{</span><span class="s1">in</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.finishNode(n,</span><span class="s2">&quot;AssignmentExpression&quot;</span><span class="s0">)}),n}</span><span class="s1">else </span><span class="s0">s&amp;&amp;</span><span class="s1">this</span><span class="s0">.checkExpressionErrors(t,!</span><span class="s3">0</span><span class="s0">);</span><span class="s1">return </span><span class="s0">a}parseMaybeConditional(t){let r=</span><span class="s1">this</span><span class="s0">.state.startLoc,e=</span><span class="s1">this</span><span class="s0">.state.potentialArrowAt,s=</span><span class="s1">this</span><span class="s0">.parseExprOps(t);</span><span class="s1">return this</span><span class="s0">.shouldExitDescending(s,e)?s:</span><span class="s1">this</span><span class="s0">.parseConditional(s,r,t)}parseConditional(t,r,e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">17</span><span class="s0">)){let s=</span><span class="s1">this</span><span class="s0">.startNodeAt(r);</span><span class="s1">return </span><span class="s0">s.test=t,s.consequent=</span><span class="s1">this</span><span class="s0">.parseMaybeAssignAllowIn(),</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">14</span><span class="s0">),s.alternate=</span><span class="s1">this</span><span class="s0">.parseMaybeAssign(),</span><span class="s1">this</span><span class="s0">.finishNode(s,</span><span class="s2">&quot;ConditionalExpression&quot;</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">t}parseMaybeUnaryOrPrivate(t){</span><span class="s1">return this</span><span class="s0">.match(</span><span class="s3">136</span><span class="s0">)?</span><span class="s1">this</span><span class="s0">.parsePrivateName():</span><span class="s1">this</span><span class="s0">.parseMaybeUnary(t)}parseExprOps(t){let r=</span><span class="s1">this</span><span class="s0">.state.startLoc,e=</span><span class="s1">this</span><span class="s0">.state.potentialArrowAt,s=</span><span class="s1">this</span><span class="s0">.parseMaybeUnaryOrPrivate(t);</span><span class="s1">return this</span><span class="s0">.shouldExitDescending(s,e)?s:</span><span class="s1">this</span><span class="s0">.parseExprOp(s,r,-</span><span class="s3">1</span><span class="s0">)}parseExprOp(t,r,e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isPrivateName(t)){let i=</span><span class="s1">this</span><span class="s0">.getPrivateNameSV(t);(e&gt;=at(</span><span class="s3">58</span><span class="s0">)||!</span><span class="s1">this</span><span class="s0">.prodParam.hasIn||!</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">58</span><span class="s0">))&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.PrivateInExpectedIn,{at:t,identifierName:i}),</span><span class="s1">this</span><span class="s0">.classScope.usePrivateName(i,t.loc.start)}let s=</span><span class="s1">this</span><span class="s0">.state.type;</span><span class="s1">if</span><span class="s0">(_o(s)&amp;&amp;(</span><span class="s1">this</span><span class="s0">.prodParam.hasIn||!</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">58</span><span class="s0">))){let i=at(s);</span><span class="s1">if</span><span class="s0">(i&gt;e){</span><span class="s1">if</span><span class="s0">(s===</span><span class="s3">39</span><span class="s0">){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s2">&quot;pipelineOperator&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.state.inFSharpPipelineDirectBody)</span><span class="s1">return </span><span class="s0">t;</span><span class="s1">this</span><span class="s0">.checkPipelineAtInfixOperator(t,r)}let a=</span><span class="s1">this</span><span class="s0">.startNodeAt(r);a.left=t,a.operator=</span><span class="s1">this</span><span class="s0">.state.value;let n=s===</span><span class="s3">41</span><span class="s0">||s===</span><span class="s3">42</span><span class="s0">,o=s===</span><span class="s3">40</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(o&amp;&amp;(i=at(</span><span class="s3">42</span><span class="s0">)),</span><span class="s1">this</span><span class="s0">.next(),s===</span><span class="s3">39</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.hasPlugin([</span><span class="s2">&quot;pipelineOperator&quot;</span><span class="s0">,{proposal:</span><span class="s2">&quot;minimal&quot;</span><span class="s0">}])&amp;&amp;</span><span class="s1">this</span><span class="s0">.state.type===</span><span class="s3">96</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.prodParam.hasAwait)</span><span class="s1">throw this</span><span class="s0">.raise(f.UnexpectedAwaitAfterPipelineBody,{at:</span><span class="s1">this</span><span class="s0">.state.startLoc});a.right=</span><span class="s1">this</span><span class="s0">.parseExprOpRightExpr(s,i);let u=</span><span class="s1">this</span><span class="s0">.finishNode(a,n||o?</span><span class="s2">&quot;LogicalExpression&quot;</span><span class="s0">:</span><span class="s2">&quot;BinaryExpression&quot;</span><span class="s0">),c=</span><span class="s1">this</span><span class="s0">.state.type;</span><span class="s1">if</span><span class="s0">(o&amp;&amp;(c===</span><span class="s3">41</span><span class="s0">||c===</span><span class="s3">42</span><span class="s0">)||n&amp;&amp;c===</span><span class="s3">40</span><span class="s0">)</span><span class="s1">throw this</span><span class="s0">.raise(f.MixingCoalesceWithLogical,{at:</span><span class="s1">this</span><span class="s0">.state.startLoc});</span><span class="s1">return this</span><span class="s0">.parseExprOp(u,r,e)}}</span><span class="s1">return </span><span class="s0">t}parseExprOpRightExpr(t,r){let e=</span><span class="s1">this</span><span class="s0">.state.startLoc;</span><span class="s1">switch</span><span class="s0">(t){</span><span class="s1">case </span><span class="s3">39</span><span class="s0">:</span><span class="s1">switch</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.getPluginOption(</span><span class="s2">&quot;pipelineOperator&quot;</span><span class="s0">,</span><span class="s2">&quot;proposal&quot;</span><span class="s0">)){</span><span class="s1">case</span><span class="s2">&quot;hack&quot;</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.withTopicBindingContext(()=&gt;</span><span class="s1">this</span><span class="s0">.parseHackPipeBody());</span><span class="s1">case</span><span class="s2">&quot;smart&quot;</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.withTopicBindingContext(()=&gt;{</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.prodParam.hasYield&amp;&amp;</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">106</span><span class="s0">))</span><span class="s1">throw this</span><span class="s0">.raise(f.PipeBodyIsTighter,{at:</span><span class="s1">this</span><span class="s0">.state.startLoc});</span><span class="s1">return this</span><span class="s0">.parseSmartPipelineBodyInStyle(</span><span class="s1">this</span><span class="s0">.parseExprOpBaseRightExpr(t,r),e)});</span><span class="s1">case</span><span class="s2">&quot;fsharp&quot;</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.withSoloAwaitPermittingContext(()=&gt;</span><span class="s1">this</span><span class="s0">.parseFSharpPipelineBody(r))}</span><span class="s1">default</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.parseExprOpBaseRightExpr(t,r)}}parseExprOpBaseRightExpr(t,r){let e=</span><span class="s1">this</span><span class="s0">.state.startLoc;</span><span class="s1">return this</span><span class="s0">.parseExprOp(</span><span class="s1">this</span><span class="s0">.parseMaybeUnaryOrPrivate(),e,$o(t)?r-1:r)}parseHackPipeBody(){</span><span class="s1">var </span><span class="s0">t;let{startLoc:r}=</span><span class="s1">this</span><span class="s0">.state,e=</span><span class="s1">this</span><span class="s0">.parseMaybeAssign();</span><span class="s1">return </span><span class="s0">Go.has(e.type)&amp;&amp;!((t=e.extra)!=</span><span class="s1">null</span><span class="s0">&amp;&amp;t.parenthesized)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.PipeUnparenthesizedBody,{at:r,type:e.type}),</span><span class="s1">this</span><span class="s0">.topicReferenceWasUsedInCurrentContext()||</span><span class="s1">this</span><span class="s0">.raise(f.PipeTopicUnused,{at:r}),e}checkExponentialAfterUnary(t){</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">57</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.UnexpectedTokenUnaryExponentiation,{at:t.argument})}parseMaybeUnary(t,r){let e=</span><span class="s1">this</span><span class="s0">.state.startLoc,s=</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">96</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(s&amp;&amp;</span><span class="s1">this</span><span class="s0">.isAwaitAllowed()){</span><span class="s1">this</span><span class="s0">.next();let o=</span><span class="s1">this</span><span class="s0">.parseAwait(e);</span><span class="s1">return </span><span class="s0">r||</span><span class="s1">this</span><span class="s0">.checkExponentialAfterUnary(o),o}let i=</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">34</span><span class="s0">),a=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">if</span><span class="s0">(jo(</span><span class="s1">this</span><span class="s0">.state.type)){a.operator=</span><span class="s1">this</span><span class="s0">.state.value,a.prefix=!</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">72</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s2">&quot;throwExpressions&quot;</span><span class="s0">);let o=</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">89</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.next(),a.argument=</span><span class="s1">this</span><span class="s0">.parseMaybeUnary(</span><span class="s1">null</span><span class="s0">,!</span><span class="s3">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.checkExpressionErrors(t,!</span><span class="s3">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.state.strict&amp;&amp;o){let u=a.argument;u.type===</span><span class="s2">&quot;Identifier&quot;</span><span class="s0">?</span><span class="s1">this</span><span class="s0">.raise(f.StrictDelete,{at:a}):</span><span class="s1">this</span><span class="s0">.hasPropertyAsPrivateName(u)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.DeletePrivateField,{at:a})}</span><span class="s1">if</span><span class="s0">(!i)</span><span class="s1">return </span><span class="s0">r||</span><span class="s1">this</span><span class="s0">.checkExponentialAfterUnary(a),</span><span class="s1">this</span><span class="s0">.finishNode(a,</span><span class="s2">&quot;UnaryExpression&quot;</span><span class="s0">)}let n=</span><span class="s1">this</span><span class="s0">.parseUpdate(a,i,t);</span><span class="s1">if</span><span class="s0">(s){let{type:o}=</span><span class="s1">this</span><span class="s0">.state;</span><span class="s1">if</span><span class="s0">((</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s2">&quot;v8intrinsic&quot;</span><span class="s0">)?He(o):He(o)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">54</span><span class="s0">))&amp;&amp;!</span><span class="s1">this</span><span class="s0">.isAmbiguousAwait())</span><span class="s1">return this</span><span class="s0">.raiseOverwrite(f.AwaitNotInAsyncContext,{at:e}),</span><span class="s1">this</span><span class="s0">.parseAwait(e)}</span><span class="s1">return </span><span class="s0">n}parseUpdate(t,r,e){</span><span class="s1">if</span><span class="s0">(r){let a=t;</span><span class="s1">return this</span><span class="s0">.checkLVal(a.argument,{</span><span class="s1">in</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.finishNode(a,</span><span class="s2">&quot;UpdateExpression&quot;</span><span class="s0">)}),t}let s=</span><span class="s1">this</span><span class="s0">.state.startLoc,i=</span><span class="s1">this</span><span class="s0">.parseExprSubscripts(e);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.checkExpressionErrors(e,!</span><span class="s3">1</span><span class="s0">))</span><span class="s1">return </span><span class="s0">i;</span><span class="s1">for</span><span class="s0">(;Ro(</span><span class="s1">this</span><span class="s0">.state.type)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.canInsertSemicolon();){let a=</span><span class="s1">this</span><span class="s0">.startNodeAt(s);a.operator=</span><span class="s1">this</span><span class="s0">.state.value,a.prefix=!</span><span class="s3">1</span><span class="s0">,a.argument=i,</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.checkLVal(i,{</span><span class="s1">in</span><span class="s0">:i=</span><span class="s1">this</span><span class="s0">.finishNode(a,</span><span class="s2">&quot;UpdateExpression&quot;</span><span class="s0">)})}</span><span class="s1">return </span><span class="s0">i}parseExprSubscripts(t){let r=</span><span class="s1">this</span><span class="s0">.state.startLoc,e=</span><span class="s1">this</span><span class="s0">.state.potentialArrowAt,s=</span><span class="s1">this</span><span class="s0">.parseExprAtom(t);</span><span class="s1">return this</span><span class="s0">.shouldExitDescending(s,e)?s:</span><span class="s1">this</span><span class="s0">.parseSubscripts(s,r)}parseSubscripts(t,r,e){let s={optionalChainMember:!</span><span class="s3">1</span><span class="s0">,maybeAsyncArrow:</span><span class="s1">this</span><span class="s0">.atPossibleAsyncArrow(t),stop:!</span><span class="s3">1</span><span class="s0">};</span><span class="s1">do </span><span class="s0">t=</span><span class="s1">this</span><span class="s0">.parseSubscript(t,r,e,s),s.maybeAsyncArrow=!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">while</span><span class="s0">(!s.stop);</span><span class="s1">return </span><span class="s0">t}parseSubscript(t,r,e,s){let{type:i}=</span><span class="s1">this</span><span class="s0">.state;</span><span class="s1">if</span><span class="s0">(!e&amp;&amp;i===</span><span class="s3">15</span><span class="s0">)</span><span class="s1">return this</span><span class="s0">.parseBind(t,r,e,s);</span><span class="s1">if</span><span class="s0">(nt(i))</span><span class="s1">return this</span><span class="s0">.parseTaggedTemplateExpression(t,r,s);let a=!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(i===</span><span class="s3">18</span><span class="s0">){</span><span class="s1">if</span><span class="s0">(e&amp;&amp;(</span><span class="s1">this</span><span class="s0">.raise(f.OptionalChainingNoNew,{at:</span><span class="s1">this</span><span class="s0">.state.startLoc}),</span><span class="s1">this</span><span class="s0">.lookaheadCharCode()===</span><span class="s3">40</span><span class="s0">))</span><span class="s1">return </span><span class="s0">s.stop=!</span><span class="s3">0</span><span class="s0">,t;s.optionalChainMember=a=!</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.next()}</span><span class="s1">if</span><span class="s0">(!e&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">10</span><span class="s0">))</span><span class="s1">return this</span><span class="s0">.parseCoverCallAndAsyncArrowHead(t,r,s,a);{let n=</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">0</span><span class="s0">);</span><span class="s1">return </span><span class="s0">n||a||</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">16</span><span class="s0">)?</span><span class="s1">this</span><span class="s0">.parseMember(t,r,s,n,a):(s.stop=!</span><span class="s3">0</span><span class="s0">,t)}}parseMember(t,r,e,s,i){let a=</span><span class="s1">this</span><span class="s0">.startNodeAt(r);</span><span class="s1">return </span><span class="s0">a.object=t,a.computed=s,s?(a.property=</span><span class="s1">this</span><span class="s0">.parseExpression(),</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">3</span><span class="s0">)):</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">136</span><span class="s0">)?(t.type===</span><span class="s2">&quot;Super&quot;</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.SuperPrivateField,{at:r}),</span><span class="s1">this</span><span class="s0">.classScope.usePrivateName(</span><span class="s1">this</span><span class="s0">.state.value,</span><span class="s1">this</span><span class="s0">.state.startLoc),a.property=</span><span class="s1">this</span><span class="s0">.parsePrivateName()):a.property=</span><span class="s1">this</span><span class="s0">.parseIdentifier(!</span><span class="s3">0</span><span class="s0">),e.optionalChainMember?(a.optional=i,</span><span class="s1">this</span><span class="s0">.finishNode(a,</span><span class="s2">&quot;OptionalMemberExpression&quot;</span><span class="s0">)):</span><span class="s1">this</span><span class="s0">.finishNode(a,</span><span class="s2">&quot;MemberExpression&quot;</span><span class="s0">)}parseBind(t,r,e,s){let i=</span><span class="s1">this</span><span class="s0">.startNodeAt(r);</span><span class="s1">return </span><span class="s0">i.object=t,</span><span class="s1">this</span><span class="s0">.next(),i.callee=</span><span class="s1">this</span><span class="s0">.parseNoCallExpr(),s.stop=!</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.parseSubscripts(</span><span class="s1">this</span><span class="s0">.finishNode(i,</span><span class="s2">&quot;BindExpression&quot;</span><span class="s0">),r,e)}parseCoverCallAndAsyncArrowHead(t,r,e,s){let i=</span><span class="s1">this</span><span class="s0">.state.maybeInArrowParameters,a=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.state.maybeInArrowParameters=!</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.next();let n=</span><span class="s1">this</span><span class="s0">.startNodeAt(r);n.callee=t;let{maybeAsyncArrow:o,optionalChainMember:u}=e;o&amp;&amp;(</span><span class="s1">this</span><span class="s0">.expressionScope.enter($l()),a=</span><span class="s1">new </span><span class="s0">vt),u&amp;&amp;(n.optional=s),s?n.arguments=</span><span class="s1">this</span><span class="s0">.parseCallExpressionArguments(</span><span class="s3">11</span><span class="s0">):n.arguments=</span><span class="s1">this</span><span class="s0">.parseCallExpressionArguments(</span><span class="s3">11</span><span class="s0">,t.type===</span><span class="s2">&quot;Import&quot;</span><span class="s0">,t.type!==</span><span class="s2">&quot;Super&quot;</span><span class="s0">,n,a);let c=</span><span class="s1">this</span><span class="s0">.finishCallExpression(n,u);</span><span class="s1">return </span><span class="s0">o&amp;&amp;</span><span class="s1">this</span><span class="s0">.shouldParseAsyncArrow()&amp;&amp;!s?(e.stop=!</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.checkDestructuringPrivate(a),</span><span class="s1">this</span><span class="s0">.expressionScope.validateAsPattern(),</span><span class="s1">this</span><span class="s0">.expressionScope.exit(),c=</span><span class="s1">this</span><span class="s0">.parseAsyncArrowFromCallExpression(</span><span class="s1">this</span><span class="s0">.startNodeAt(r),c)):(o&amp;&amp;(</span><span class="s1">this</span><span class="s0">.checkExpressionErrors(a,!</span><span class="s3">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.expressionScope.exit()),</span><span class="s1">this</span><span class="s0">.toReferencedArguments(c)),</span><span class="s1">this</span><span class="s0">.state.maybeInArrowParameters=i,c}toReferencedArguments(t,r){</span><span class="s1">this</span><span class="s0">.toReferencedListDeep(t.arguments,r)}parseTaggedTemplateExpression(t,r,e){let s=</span><span class="s1">this</span><span class="s0">.startNodeAt(r);</span><span class="s1">return </span><span class="s0">s.tag=t,s.quasi=</span><span class="s1">this</span><span class="s0">.parseTemplate(!</span><span class="s3">0</span><span class="s0">),e.optionalChainMember&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.OptionalChainingNoTemplate,{at:r}),</span><span class="s1">this</span><span class="s0">.finishNode(s,</span><span class="s2">&quot;TaggedTemplateExpression&quot;</span><span class="s0">)}atPossibleAsyncArrow(t){</span><span class="s1">return </span><span class="s0">t.type===</span><span class="s2">&quot;Identifier&quot;</span><span class="s0">&amp;&amp;t.name===</span><span class="s2">&quot;async&quot;</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.state.lastTokEndLoc.index===t.end&amp;&amp;!</span><span class="s1">this</span><span class="s0">.canInsertSemicolon()&amp;&amp;t.end-t.start===</span><span class="s3">5</span><span class="s0">&amp;&amp;t.start===</span><span class="s1">this</span><span class="s0">.state.potentialArrowAt}finishCallExpression(t,r){</span><span class="s1">if</span><span class="s0">(t.callee.type===</span><span class="s2">&quot;Import&quot;</span><span class="s0">)</span><span class="s1">if</span><span class="s0">(t.arguments.length===</span><span class="s3">2</span><span class="s0">&amp;&amp;(</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s2">&quot;moduleAttributes&quot;</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s2">&quot;importAssertions&quot;</span><span class="s0">)),t.arguments.length===</span><span class="s3">0</span><span class="s0">||t.arguments.length&gt;</span><span class="s3">2</span><span class="s0">)</span><span class="s1">this</span><span class="s0">.raise(f.ImportCallArity,{at:t,maxArgumentCount:</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s2">&quot;importAssertions&quot;</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s2">&quot;moduleAttributes&quot;</span><span class="s0">)?</span><span class="s3">2</span><span class="s0">:</span><span class="s3">1</span><span class="s0">});</span><span class="s1">else for</span><span class="s0">(let e of t.arguments)e.type===</span><span class="s2">&quot;SpreadElement&quot;</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.ImportCallSpreadArgument,{at:e});</span><span class="s1">return this</span><span class="s0">.finishNode(t,r?</span><span class="s2">&quot;OptionalCallExpression&quot;</span><span class="s0">:</span><span class="s2">&quot;CallExpression&quot;</span><span class="s0">)}parseCallExpressionArguments(t,r,e,s,i){let a=[],n=!</span><span class="s3">0</span><span class="s0">,o=</span><span class="s1">this</span><span class="s0">.state.inFSharpPipelineDirectBody;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.inFSharpPipelineDirectBody=!</span><span class="s3">1</span><span class="s0">;!</span><span class="s1">this</span><span class="s0">.eat(t);){</span><span class="s1">if</span><span class="s0">(n)n=!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">else if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">12</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.match(t)){r&amp;&amp;!</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s2">&quot;importAssertions&quot;</span><span class="s0">)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s2">&quot;moduleAttributes&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.ImportCallArgumentTrailingComma,{at:</span><span class="s1">this</span><span class="s0">.state.lastTokStartLoc}),s&amp;&amp;</span><span class="s1">this</span><span class="s0">.addTrailingCommaExtraToNode(s),</span><span class="s1">this</span><span class="s0">.next();</span><span class="s1">break</span><span class="s0">}a.push(</span><span class="s1">this</span><span class="s0">.parseExprListItem(!</span><span class="s3">1</span><span class="s0">,i,e))}</span><span class="s1">return this</span><span class="s0">.state.inFSharpPipelineDirectBody=o,a}shouldParseAsyncArrow(){</span><span class="s1">return this</span><span class="s0">.match(</span><span class="s3">19</span><span class="s0">)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.canInsertSemicolon()}parseAsyncArrowFromCallExpression(t,r){</span><span class="s1">var </span><span class="s0">e;</span><span class="s1">return this</span><span class="s0">.resetPreviousNodeTrailingComments(r),</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">19</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.parseArrowExpression(t,r.arguments,!</span><span class="s3">0</span><span class="s0">,(e=r.extra)==</span><span class="s1">null</span><span class="s0">?</span><span class="s1">void </span><span class="s3">0</span><span class="s0">:e.trailingCommaLoc),r.innerComments&amp;&amp;Ke(t,r.innerComments),r.callee.trailingComments&amp;&amp;Ke(t,r.callee.trailingComments),t}parseNoCallExpr(){let t=</span><span class="s1">this</span><span class="s0">.state.startLoc;</span><span class="s1">return this</span><span class="s0">.parseSubscripts(</span><span class="s1">this</span><span class="s0">.parseExprAtom(),t,!</span><span class="s3">0</span><span class="s0">)}parseExprAtom(t){let r,e=</span><span class="s1">null</span><span class="s0">,{type:s}=</span><span class="s1">this</span><span class="s0">.state;</span><span class="s1">switch</span><span class="s0">(s){</span><span class="s1">case </span><span class="s3">79</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.parseSuper();</span><span class="s1">case </span><span class="s3">83</span><span class="s0">:</span><span class="s1">return </span><span class="s0">r=</span><span class="s1">this</span><span class="s0">.startNode(),</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">16</span><span class="s0">)?</span><span class="s1">this</span><span class="s0">.parseImportMetaProperty(r):(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">10</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.raise(f.UnsupportedImport,{at:</span><span class="s1">this</span><span class="s0">.state.lastTokStartLoc}),</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s2">&quot;Import&quot;</span><span class="s0">));</span><span class="s1">case </span><span class="s3">78</span><span class="s0">:</span><span class="s1">return </span><span class="s0">r=</span><span class="s1">this</span><span class="s0">.startNode(),</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s2">&quot;ThisExpression&quot;</span><span class="s0">);</span><span class="s1">case </span><span class="s3">90</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.parseDo(</span><span class="s1">this</span><span class="s0">.startNode(),!</span><span class="s3">1</span><span class="s0">);</span><span class="s1">case </span><span class="s3">56</span><span class="s0">:</span><span class="s1">case </span><span class="s3">31</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.readRegexp(),</span><span class="s1">this</span><span class="s0">.parseRegExpLiteral(</span><span class="s1">this</span><span class="s0">.state.value);</span><span class="s1">case </span><span class="s3">132</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.parseNumericLiteral(</span><span class="s1">this</span><span class="s0">.state.value);</span><span class="s1">case </span><span class="s3">133</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.parseBigIntLiteral(</span><span class="s1">this</span><span class="s0">.state.value);</span><span class="s1">case </span><span class="s3">134</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.parseDecimalLiteral(</span><span class="s1">this</span><span class="s0">.state.value);</span><span class="s1">case </span><span class="s3">131</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.parseStringLiteral(</span><span class="s1">this</span><span class="s0">.state.value);</span><span class="s1">case </span><span class="s3">84</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.parseNullLiteral();</span><span class="s1">case </span><span class="s3">85</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.parseBooleanLiteral(!</span><span class="s3">0</span><span class="s0">);</span><span class="s1">case </span><span class="s3">86</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.parseBooleanLiteral(!</span><span class="s3">1</span><span class="s0">);</span><span class="s1">case </span><span class="s3">10</span><span class="s0">:{let i=</span><span class="s1">this</span><span class="s0">.state.potentialArrowAt===</span><span class="s1">this</span><span class="s0">.state.start;</span><span class="s1">return this</span><span class="s0">.parseParenAndDistinguishExpression(i)}</span><span class="s1">case </span><span class="s3">2</span><span class="s0">:</span><span class="s1">case </span><span class="s3">1</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.parseArrayLike(</span><span class="s1">this</span><span class="s0">.state.type===</span><span class="s3">2</span><span class="s0">?</span><span class="s3">4</span><span class="s0">:</span><span class="s3">3</span><span class="s0">,!</span><span class="s3">1</span><span class="s0">,!</span><span class="s3">0</span><span class="s0">);</span><span class="s1">case </span><span class="s3">0</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.parseArrayLike(</span><span class="s3">3</span><span class="s0">,!</span><span class="s3">0</span><span class="s0">,!</span><span class="s3">1</span><span class="s0">,t);</span><span class="s1">case </span><span class="s3">6</span><span class="s0">:</span><span class="s1">case </span><span class="s3">7</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.parseObjectLike(</span><span class="s1">this</span><span class="s0">.state.type===</span><span class="s3">6</span><span class="s0">?</span><span class="s3">9</span><span class="s0">:</span><span class="s3">8</span><span class="s0">,!</span><span class="s3">1</span><span class="s0">,!</span><span class="s3">0</span><span class="s0">);</span><span class="s1">case </span><span class="s3">5</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.parseObjectLike(</span><span class="s3">8</span><span class="s0">,!</span><span class="s3">1</span><span class="s0">,!</span><span class="s3">1</span><span class="s0">,t);</span><span class="s1">case </span><span class="s3">68</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.parseFunctionOrFunctionSent();</span><span class="s1">case </span><span class="s3">26</span><span class="s0">:e=</span><span class="s1">this</span><span class="s0">.parseDecorators();</span><span class="s1">case </span><span class="s3">80</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.parseClass(</span><span class="s1">this</span><span class="s0">.maybeTakeDecorators(e,</span><span class="s1">this</span><span class="s0">.startNode()),!</span><span class="s3">1</span><span class="s0">);</span><span class="s1">case </span><span class="s3">77</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.parseNewOrNewTarget();</span><span class="s1">case </span><span class="s3">25</span><span class="s0">:</span><span class="s1">case </span><span class="s3">24</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.parseTemplate(!</span><span class="s3">1</span><span class="s0">);</span><span class="s1">case </span><span class="s3">15</span><span class="s0">:{r=</span><span class="s1">this</span><span class="s0">.startNode(),</span><span class="s1">this</span><span class="s0">.next(),r.object=</span><span class="s1">null</span><span class="s0">;let i=r.callee=</span><span class="s1">this</span><span class="s0">.parseNoCallExpr();</span><span class="s1">if</span><span class="s0">(i.type===</span><span class="s2">&quot;MemberExpression&quot;</span><span class="s0">)</span><span class="s1">return this</span><span class="s0">.finishNode(r,</span><span class="s2">&quot;BindExpression&quot;</span><span class="s0">);</span><span class="s1">throw this</span><span class="s0">.raise(f.UnsupportedBind,{at:i})}</span><span class="s1">case </span><span class="s3">136</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.raise(f.PrivateInExpectedIn,{at:</span><span class="s1">this</span><span class="s0">.state.startLoc,identifierName:</span><span class="s1">this</span><span class="s0">.state.value}),</span><span class="s1">this</span><span class="s0">.parsePrivateName();</span><span class="s1">case </span><span class="s3">33</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.parseTopicReferenceThenEqualsSign(</span><span class="s3">54</span><span class="s0">,</span><span class="s2">&quot;%&quot;</span><span class="s0">);</span><span class="s1">case </span><span class="s3">32</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.parseTopicReferenceThenEqualsSign(</span><span class="s3">44</span><span class="s0">,</span><span class="s2">&quot;^&quot;</span><span class="s0">);</span><span class="s1">case </span><span class="s3">37</span><span class="s0">:</span><span class="s1">case </span><span class="s3">38</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.parseTopicReference(</span><span class="s2">&quot;hack&quot;</span><span class="s0">);</span><span class="s1">case </span><span class="s3">44</span><span class="s0">:</span><span class="s1">case </span><span class="s3">54</span><span class="s0">:</span><span class="s1">case </span><span class="s3">27</span><span class="s0">:{let i=</span><span class="s1">this</span><span class="s0">.getPluginOption(</span><span class="s2">&quot;pipelineOperator&quot;</span><span class="s0">,</span><span class="s2">&quot;proposal&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(i)</span><span class="s1">return this</span><span class="s0">.parseTopicReference(i);</span><span class="s1">this</span><span class="s0">.unexpected();</span><span class="s1">break</span><span class="s0">}</span><span class="s1">case </span><span class="s3">47</span><span class="s0">:{let i=</span><span class="s1">this</span><span class="s0">.input.codePointAt(</span><span class="s1">this</span><span class="s0">.nextTokenStart());fe(i)||i===</span><span class="s3">62</span><span class="s0">?</span><span class="s1">this</span><span class="s0">.expectOnePlugin([</span><span class="s2">&quot;jsx&quot;</span><span class="s0">,</span><span class="s2">&quot;flow&quot;</span><span class="s0">,</span><span class="s2">&quot;typescript&quot;</span><span class="s0">]):</span><span class="s1">this</span><span class="s0">.unexpected();</span><span class="s1">break</span><span class="s0">}</span><span class="s1">default</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(q(s)){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">125</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.lookaheadCharCode()===</span><span class="s3">123</span><span class="s0">&amp;&amp;!</span><span class="s1">this</span><span class="s0">.hasFollowingLineBreak())</span><span class="s1">return this</span><span class="s0">.parseModuleExpression();let i=</span><span class="s1">this</span><span class="s0">.state.potentialArrowAt===</span><span class="s1">this</span><span class="s0">.state.start,a=</span><span class="s1">this</span><span class="s0">.state.containsEsc,n=</span><span class="s1">this</span><span class="s0">.parseIdentifier();</span><span class="s1">if</span><span class="s0">(!a&amp;&amp;n.name===</span><span class="s2">&quot;async&quot;</span><span class="s0">&amp;&amp;!</span><span class="s1">this</span><span class="s0">.canInsertSemicolon()){let{type:o}=</span><span class="s1">this</span><span class="s0">.state;</span><span class="s1">if</span><span class="s0">(o===</span><span class="s3">68</span><span class="s0">)</span><span class="s1">return this</span><span class="s0">.resetPreviousNodeTrailingComments(n),</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.parseAsyncFunctionExpression(</span><span class="s1">this</span><span class="s0">.startNodeAtNode(n));</span><span class="s1">if</span><span class="s0">(q(o))</span><span class="s1">return this</span><span class="s0">.lookaheadCharCode()===</span><span class="s3">61</span><span class="s0">?</span><span class="s1">this</span><span class="s0">.parseAsyncArrowUnaryFunction(</span><span class="s1">this</span><span class="s0">.startNodeAtNode(n)):n;</span><span class="s1">if</span><span class="s0">(o===</span><span class="s3">90</span><span class="s0">)</span><span class="s1">return this</span><span class="s0">.resetPreviousNodeTrailingComments(n),</span><span class="s1">this</span><span class="s0">.parseDo(</span><span class="s1">this</span><span class="s0">.startNodeAtNode(n),!</span><span class="s3">0</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">i&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">19</span><span class="s0">)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.canInsertSemicolon()?(</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.parseArrowExpression(</span><span class="s1">this</span><span class="s0">.startNodeAtNode(n),[n],!</span><span class="s3">1</span><span class="s0">)):n}</span><span class="s1">else this</span><span class="s0">.unexpected()}}parseTopicReferenceThenEqualsSign(t,r){let e=</span><span class="s1">this</span><span class="s0">.getPluginOption(</span><span class="s2">&quot;pipelineOperator&quot;</span><span class="s0">,</span><span class="s2">&quot;proposal&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(e)</span><span class="s1">return this</span><span class="s0">.state.type=t,</span><span class="s1">this</span><span class="s0">.state.value=r,</span><span class="s1">this</span><span class="s0">.state.pos--,</span><span class="s1">this</span><span class="s0">.state.end--,</span><span class="s1">this</span><span class="s0">.state.endLoc=Y(</span><span class="s1">this</span><span class="s0">.state.endLoc,-</span><span class="s3">1</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.parseTopicReference(e);</span><span class="s1">this</span><span class="s0">.unexpected()}parseTopicReference(t){let r=</span><span class="s1">this</span><span class="s0">.startNode(),e=</span><span class="s1">this</span><span class="s0">.state.startLoc,s=</span><span class="s1">this</span><span class="s0">.state.type;</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.finishTopicReference(r,e,t,s)}finishTopicReference(t,r,e,s){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.testTopicReferenceConfiguration(e,r,s)){let i=e===</span><span class="s2">&quot;smart&quot;</span><span class="s0">?</span><span class="s2">&quot;PipelinePrimaryTopicReference&quot;</span><span class="s0">:</span><span class="s2">&quot;TopicReference&quot;</span><span class="s0">;</span><span class="s1">return this</span><span class="s0">.topicReferenceIsAllowedInCurrentContext()||</span><span class="s1">this</span><span class="s0">.raise(e===</span><span class="s2">&quot;smart&quot;</span><span class="s0">?f.PrimaryTopicNotAllowed:f.PipeTopicUnbound,{at:r}),</span><span class="s1">this</span><span class="s0">.registerTopicReference(),</span><span class="s1">this</span><span class="s0">.finishNode(t,i)}</span><span class="s1">else throw this</span><span class="s0">.raise(f.PipeTopicUnconfiguredToken,{at:r,token:xe(s)})}testTopicReferenceConfiguration(t,r,e){</span><span class="s1">switch</span><span class="s0">(t){</span><span class="s1">case</span><span class="s2">&quot;hack&quot;</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.hasPlugin([</span><span class="s2">&quot;pipelineOperator&quot;</span><span class="s0">,{topicToken:xe(e)}]);</span><span class="s1">case</span><span class="s2">&quot;smart&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">e===</span><span class="s3">27</span><span class="s0">;</span><span class="s1">default</span><span class="s0">:</span><span class="s1">throw this</span><span class="s0">.raise(f.PipeTopicRequiresHackPipes,{at:r})}}parseAsyncArrowUnaryFunction(t){</span><span class="s1">this</span><span class="s0">.prodParam.enter(Tt(!</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.prodParam.hasYield));let r=[</span><span class="s1">this</span><span class="s0">.parseIdentifier()];</span><span class="s1">return this</span><span class="s0">.prodParam.exit(),</span><span class="s1">this</span><span class="s0">.hasPrecedingLineBreak()&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.LineTerminatorBeforeArrow,{at:</span><span class="s1">this</span><span class="s0">.state.curPosition()}),</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">19</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.parseArrowExpression(t,r,!</span><span class="s3">0</span><span class="s0">)}parseDo(t,r){</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s2">&quot;doExpressions&quot;</span><span class="s0">),r&amp;&amp;</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s2">&quot;asyncDoExpressions&quot;</span><span class="s0">),t.async=r,</span><span class="s1">this</span><span class="s0">.next();let e=</span><span class="s1">this</span><span class="s0">.state.labels;</span><span class="s1">return this</span><span class="s0">.state.labels=[],r?(</span><span class="s1">this</span><span class="s0">.prodParam.enter(At),t.body=</span><span class="s1">this</span><span class="s0">.parseBlock(),</span><span class="s1">this</span><span class="s0">.prodParam.exit()):t.body=</span><span class="s1">this</span><span class="s0">.parseBlock(),</span><span class="s1">this</span><span class="s0">.state.labels=e,</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s2">&quot;DoExpression&quot;</span><span class="s0">)}parseSuper(){let t=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">10</span><span class="s0">)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.scope.allowDirectSuper&amp;&amp;!</span><span class="s1">this</span><span class="s0">.options.allowSuperOutsideMethod?</span><span class="s1">this</span><span class="s0">.raise(f.SuperNotAllowed,{at:t}):!</span><span class="s1">this</span><span class="s0">.scope.allowSuper&amp;&amp;!</span><span class="s1">this</span><span class="s0">.options.allowSuperOutsideMethod&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.UnexpectedSuper,{at:t}),!</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">10</span><span class="s0">)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">0</span><span class="s0">)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">16</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.UnsupportedSuper,{at:t}),</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s2">&quot;Super&quot;</span><span class="s0">)}parsePrivateName(){let t=</span><span class="s1">this</span><span class="s0">.startNode(),r=</span><span class="s1">this</span><span class="s0">.startNodeAt(Y(</span><span class="s1">this</span><span class="s0">.state.startLoc,</span><span class="s3">1</span><span class="s0">)),e=</span><span class="s1">this</span><span class="s0">.state.value;</span><span class="s1">return this</span><span class="s0">.next(),t.id=</span><span class="s1">this</span><span class="s0">.createIdentifier(r,e),</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s2">&quot;PrivateName&quot;</span><span class="s0">)}parseFunctionOrFunctionSent(){let t=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.prodParam.hasYield&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">16</span><span class="s0">)){let r=</span><span class="s1">this</span><span class="s0">.createIdentifier(</span><span class="s1">this</span><span class="s0">.startNodeAtNode(t),</span><span class="s2">&quot;function&quot;</span><span class="s0">);</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">102</span><span class="s0">)?</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s2">&quot;functionSent&quot;</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s2">&quot;functionSent&quot;</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.unexpected(),</span><span class="s1">this</span><span class="s0">.parseMetaProperty(t,r,</span><span class="s2">&quot;sent&quot;</span><span class="s0">)}</span><span class="s1">return this</span><span class="s0">.parseFunction(t)}parseMetaProperty(t,r,e){t.meta=r;let s=</span><span class="s1">this</span><span class="s0">.state.containsEsc;</span><span class="s1">return </span><span class="s0">t.property=</span><span class="s1">this</span><span class="s0">.parseIdentifier(!</span><span class="s3">0</span><span class="s0">),(t.property.name!==e||s)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.UnsupportedMetaProperty,{at:t.property,target:r.name,onlyValidPropertyName:e}),</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s2">&quot;MetaProperty&quot;</span><span class="s0">)}parseImportMetaProperty(t){let r=</span><span class="s1">this</span><span class="s0">.createIdentifier(</span><span class="s1">this</span><span class="s0">.startNodeAtNode(t),</span><span class="s2">&quot;import&quot;</span><span class="s0">);</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">100</span><span class="s0">)&amp;&amp;(</span><span class="s1">this</span><span class="s0">.inModule||</span><span class="s1">this</span><span class="s0">.raise(f.ImportMetaOutsideModule,{at:r}),</span><span class="s1">this</span><span class="s0">.sawUnambiguousESM=!</span><span class="s3">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.parseMetaProperty(t,r,</span><span class="s2">&quot;meta&quot;</span><span class="s0">)}parseLiteralAtNode(t,r,e){</span><span class="s1">return this</span><span class="s0">.addExtra(e,</span><span class="s2">&quot;rawValue&quot;</span><span class="s0">,t),</span><span class="s1">this</span><span class="s0">.addExtra(e,</span><span class="s2">&quot;raw&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.input.slice(e.start,</span><span class="s1">this</span><span class="s0">.state.end)),e.value=t,</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.finishNode(e,r)}parseLiteral(t,r){let e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.parseLiteralAtNode(t,r,e)}parseStringLiteral(t){</span><span class="s1">return this</span><span class="s0">.parseLiteral(t,</span><span class="s2">&quot;StringLiteral&quot;</span><span class="s0">)}parseNumericLiteral(t){</span><span class="s1">return this</span><span class="s0">.parseLiteral(t,</span><span class="s2">&quot;NumericLiteral&quot;</span><span class="s0">)}parseBigIntLiteral(t){</span><span class="s1">return this</span><span class="s0">.parseLiteral(t,</span><span class="s2">&quot;BigIntLiteral&quot;</span><span class="s0">)}parseDecimalLiteral(t){</span><span class="s1">return this</span><span class="s0">.parseLiteral(t,</span><span class="s2">&quot;DecimalLiteral&quot;</span><span class="s0">)}parseRegExpLiteral(t){let r=</span><span class="s1">this</span><span class="s0">.parseLiteral(t.value,</span><span class="s2">&quot;RegExpLiteral&quot;</span><span class="s0">);</span><span class="s1">return </span><span class="s0">r.pattern=t.pattern,r.flags=t.flags,r}parseBooleanLiteral(t){let r=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">r.value=t,</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s2">&quot;BooleanLiteral&quot;</span><span class="s0">)}parseNullLiteral(){let t=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s2">&quot;NullLiteral&quot;</span><span class="s0">)}parseParenAndDistinguishExpression(t){let r=</span><span class="s1">this</span><span class="s0">.state.startLoc,e;</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.expressionScope.enter(Ul());let s=</span><span class="s1">this</span><span class="s0">.state.maybeInArrowParameters,i=</span><span class="s1">this</span><span class="s0">.state.inFSharpPipelineDirectBody;</span><span class="s1">this</span><span class="s0">.state.maybeInArrowParameters=!</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.state.inFSharpPipelineDirectBody=!</span><span class="s3">1</span><span class="s0">;let a=</span><span class="s1">this</span><span class="s0">.state.startLoc,n=[],o=</span><span class="s1">new </span><span class="s0">vt,u=!</span><span class="s3">0</span><span class="s0">,c,y;</span><span class="s1">for</span><span class="s0">(;!</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">11</span><span class="s0">);){</span><span class="s1">if</span><span class="s0">(u)u=!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">else if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">12</span><span class="s0">,o.optionalParametersLoc===</span><span class="s1">null</span><span class="s0">?</span><span class="s1">null</span><span class="s0">:o.optionalParametersLoc),</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">11</span><span class="s0">)){y=</span><span class="s1">this</span><span class="s0">.state.startLoc;</span><span class="s1">break</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">21</span><span class="s0">)){let C=</span><span class="s1">this</span><span class="s0">.state.startLoc;</span><span class="s1">if</span><span class="s0">(c=</span><span class="s1">this</span><span class="s0">.state.startLoc,n.push(</span><span class="s1">this</span><span class="s0">.parseParenItem(</span><span class="s1">this</span><span class="s0">.parseRestBinding(),C)),!</span><span class="s1">this</span><span class="s0">.checkCommaAfterRest(</span><span class="s3">41</span><span class="s0">))</span><span class="s1">break</span><span class="s0">}</span><span class="s1">else </span><span class="s0">n.push(</span><span class="s1">this</span><span class="s0">.parseMaybeAssignAllowIn(o,</span><span class="s1">this</span><span class="s0">.parseParenItem))}let g=</span><span class="s1">this</span><span class="s0">.state.lastTokEndLoc;</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">11</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.state.maybeInArrowParameters=s,</span><span class="s1">this</span><span class="s0">.state.inFSharpPipelineDirectBody=i;let T=</span><span class="s1">this</span><span class="s0">.startNodeAt(r);</span><span class="s1">return </span><span class="s0">t&amp;&amp;</span><span class="s1">this</span><span class="s0">.shouldParseArrow(n)&amp;&amp;(T=</span><span class="s1">this</span><span class="s0">.parseArrow(T))?(</span><span class="s1">this</span><span class="s0">.checkDestructuringPrivate(o),</span><span class="s1">this</span><span class="s0">.expressionScope.validateAsPattern(),</span><span class="s1">this</span><span class="s0">.expressionScope.exit(),</span><span class="s1">this</span><span class="s0">.parseArrowExpression(T,n,!</span><span class="s3">1</span><span class="s0">),T):(</span><span class="s1">this</span><span class="s0">.expressionScope.exit(),n.length||</span><span class="s1">this</span><span class="s0">.unexpected(</span><span class="s1">this</span><span class="s0">.state.lastTokStartLoc),y&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(y),c&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(c),</span><span class="s1">this</span><span class="s0">.checkExpressionErrors(o,!</span><span class="s3">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.toReferencedListDeep(n,!</span><span class="s3">0</span><span class="s0">),n.length&gt;</span><span class="s3">1</span><span class="s0">?(e=</span><span class="s1">this</span><span class="s0">.startNodeAt(a),e.expressions=n,</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;SequenceExpression&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.resetEndLocation(e,g)):e=n[</span><span class="s3">0</span><span class="s0">],</span><span class="s1">this</span><span class="s0">.wrapParenthesis(r,e))}wrapParenthesis(t,r){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.options.createParenthesizedExpressions)</span><span class="s1">return this</span><span class="s0">.addExtra(r,</span><span class="s2">&quot;parenthesized&quot;</span><span class="s0">,!</span><span class="s3">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.addExtra(r,</span><span class="s2">&quot;parenStart&quot;</span><span class="s0">,t.index),</span><span class="s1">this</span><span class="s0">.takeSurroundingComments(r,t.index,</span><span class="s1">this</span><span class="s0">.state.lastTokEndLoc.index),r;let e=</span><span class="s1">this</span><span class="s0">.startNodeAt(t);</span><span class="s1">return </span><span class="s0">e.expression=r,</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;ParenthesizedExpression&quot;</span><span class="s0">)}shouldParseArrow(t){</span><span class="s1">return</span><span class="s0">!</span><span class="s1">this</span><span class="s0">.canInsertSemicolon()}parseArrow(t){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">19</span><span class="s0">))</span><span class="s1">return </span><span class="s0">t}parseParenItem(t,r){</span><span class="s1">return </span><span class="s0">t}parseNewOrNewTarget(){let t=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">16</span><span class="s0">)){let r=</span><span class="s1">this</span><span class="s0">.createIdentifier(</span><span class="s1">this</span><span class="s0">.startNodeAtNode(t),</span><span class="s2">&quot;new&quot;</span><span class="s0">);</span><span class="s1">this</span><span class="s0">.next();let e=</span><span class="s1">this</span><span class="s0">.parseMetaProperty(t,r,</span><span class="s2">&quot;target&quot;</span><span class="s0">);</span><span class="s1">return</span><span class="s0">!</span><span class="s1">this</span><span class="s0">.scope.inNonArrowFunction&amp;&amp;!</span><span class="s1">this</span><span class="s0">.scope.inClass&amp;&amp;!</span><span class="s1">this</span><span class="s0">.options.allowNewTargetOutsideFunction&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.UnexpectedNewTarget,{at:e}),e}</span><span class="s1">return this</span><span class="s0">.parseNew(t)}parseNew(t){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.parseNewCallee(t),</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">10</span><span class="s0">)){let r=</span><span class="s1">this</span><span class="s0">.parseExprList(</span><span class="s3">11</span><span class="s0">);</span><span class="s1">this</span><span class="s0">.toReferencedList(r),t.arguments=r}</span><span class="s1">else </span><span class="s0">t.arguments=[];</span><span class="s1">return this</span><span class="s0">.finishNode(t,</span><span class="s2">&quot;NewExpression&quot;</span><span class="s0">)}parseNewCallee(t){t.callee=</span><span class="s1">this</span><span class="s0">.parseNoCallExpr(),t.callee.type===</span><span class="s2">&quot;Import&quot;</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.ImportCallNotNewExpression,{at:t.callee})}parseTemplateElement(t){let{start:r,startLoc:e,end:s,value:i}=</span><span class="s1">this</span><span class="s0">.state,a=r+</span><span class="s3">1</span><span class="s0">,n=</span><span class="s1">this</span><span class="s0">.startNodeAt(Y(e,</span><span class="s3">1</span><span class="s0">));i===</span><span class="s1">null</span><span class="s0">&amp;&amp;(t||</span><span class="s1">this</span><span class="s0">.raise(f.InvalidEscapeSequenceTemplate,{at:Y(</span><span class="s1">this</span><span class="s0">.state.firstInvalidTemplateEscapePos,</span><span class="s3">1</span><span class="s0">)}));let o=</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">24</span><span class="s0">),u=o?-</span><span class="s3">1</span><span class="s0">:-</span><span class="s3">2</span><span class="s0">,c=s+u;n.value={raw:</span><span class="s1">this</span><span class="s0">.input.slice(a,c).replace(/\r\n?/g,`</span>
<span class="s0">`),cooked:i===</span><span class="s1">null</span><span class="s0">?</span><span class="s1">null</span><span class="s0">:i.slice(</span><span class="s3">1</span><span class="s0">,u)},n.tail=o,</span><span class="s1">this</span><span class="s0">.next();let y=</span><span class="s1">this</span><span class="s0">.finishNode(n,</span><span class="s2">&quot;TemplateElement&quot;</span><span class="s0">);</span><span class="s1">return this</span><span class="s0">.resetEndLocation(y,Y(</span><span class="s1">this</span><span class="s0">.state.lastTokEndLoc,u)),y}parseTemplate(t){let r=</span><span class="s1">this</span><span class="s0">.startNode();r.expressions=[];let e=</span><span class="s1">this</span><span class="s0">.parseTemplateElement(t);</span><span class="s1">for</span><span class="s0">(r.quasis=[e];!e.tail;)r.expressions.push(</span><span class="s1">this</span><span class="s0">.parseTemplateSubstitution()),</span><span class="s1">this</span><span class="s0">.readTemplateContinuation(),r.quasis.push(e=</span><span class="s1">this</span><span class="s0">.parseTemplateElement(t));</span><span class="s1">return this</span><span class="s0">.finishNode(r,</span><span class="s2">&quot;TemplateLiteral&quot;</span><span class="s0">)}parseTemplateSubstitution(){</span><span class="s1">return this</span><span class="s0">.parseExpression()}parseObjectLike(t,r,e,s){e&amp;&amp;</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s2">&quot;recordAndTuple&quot;</span><span class="s0">);let i=</span><span class="s1">this</span><span class="s0">.state.inFSharpPipelineDirectBody;</span><span class="s1">this</span><span class="s0">.state.inFSharpPipelineDirectBody=!</span><span class="s3">1</span><span class="s0">;let a=Object.create(</span><span class="s1">null</span><span class="s0">),n=!</span><span class="s3">0</span><span class="s0">,o=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">for</span><span class="s0">(o.properties=[],</span><span class="s1">this</span><span class="s0">.next();!</span><span class="s1">this</span><span class="s0">.match(t);){</span><span class="s1">if</span><span class="s0">(n)n=!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">else if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">12</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.match(t)){</span><span class="s1">this</span><span class="s0">.addTrailingCommaExtraToNode(o);</span><span class="s1">break</span><span class="s0">}let c;r?c=</span><span class="s1">this</span><span class="s0">.parseBindingProperty():(c=</span><span class="s1">this</span><span class="s0">.parsePropertyDefinition(s),</span><span class="s1">this</span><span class="s0">.checkProto(c,e,a,s)),e&amp;&amp;!</span><span class="s1">this</span><span class="s0">.isObjectProperty(c)&amp;&amp;c.type!==</span><span class="s2">&quot;SpreadElement&quot;</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.InvalidRecordProperty,{at:c}),c.shorthand&amp;&amp;</span><span class="s1">this</span><span class="s0">.addExtra(c,</span><span class="s2">&quot;shorthand&quot;</span><span class="s0">,!</span><span class="s3">0</span><span class="s0">),o.properties.push(c)}</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.state.inFSharpPipelineDirectBody=i;let u=</span><span class="s2">&quot;ObjectExpression&quot;</span><span class="s0">;</span><span class="s1">return </span><span class="s0">r?u=</span><span class="s2">&quot;ObjectPattern&quot;</span><span class="s0">:e&amp;&amp;(u=</span><span class="s2">&quot;RecordExpression&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(o,u)}addTrailingCommaExtraToNode(t){</span><span class="s1">this</span><span class="s0">.addExtra(t,</span><span class="s2">&quot;trailingComma&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.state.lastTokStart),</span><span class="s1">this</span><span class="s0">.addExtra(t,</span><span class="s2">&quot;trailingCommaLoc&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.state.lastTokStartLoc,!</span><span class="s3">1</span><span class="s0">)}maybeAsyncOrAccessorProp(t){</span><span class="s1">return</span><span class="s0">!t.computed&amp;&amp;t.key.type===</span><span class="s2">&quot;Identifier&quot;</span><span class="s0">&amp;&amp;(</span><span class="s1">this</span><span class="s0">.isLiteralPropertyName()||</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">0</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">55</span><span class="s0">))}parsePropertyDefinition(t){let r=[];</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">26</span><span class="s0">))</span><span class="s1">for</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s2">&quot;decorators&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.UnsupportedPropertyDecorator,{at:</span><span class="s1">this</span><span class="s0">.state.startLoc});</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">26</span><span class="s0">);)r.push(</span><span class="s1">this</span><span class="s0">.parseDecorator());let e=</span><span class="s1">this</span><span class="s0">.startNode(),s=!</span><span class="s3">1</span><span class="s0">,i=!</span><span class="s3">1</span><span class="s0">,a;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">21</span><span class="s0">))</span><span class="s1">return </span><span class="s0">r.length&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(),</span><span class="s1">this</span><span class="s0">.parseSpread();r.length&amp;&amp;(e.decorators=r,r=[]),e.method=!</span><span class="s3">1</span><span class="s0">,t&amp;&amp;(a=</span><span class="s1">this</span><span class="s0">.state.startLoc);let n=</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">55</span><span class="s0">);</span><span class="s1">this</span><span class="s0">.parsePropertyNamePrefixOperator(e);let o=</span><span class="s1">this</span><span class="s0">.state.containsEsc,u=</span><span class="s1">this</span><span class="s0">.parsePropertyName(e,t);</span><span class="s1">if</span><span class="s0">(!n&amp;&amp;!o&amp;&amp;</span><span class="s1">this</span><span class="s0">.maybeAsyncOrAccessorProp(e)){let c=u.name;c===</span><span class="s2">&quot;async&quot;</span><span class="s0">&amp;&amp;!</span><span class="s1">this</span><span class="s0">.hasPrecedingLineBreak()&amp;&amp;(s=!</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.resetPreviousNodeTrailingComments(u),n=</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">55</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.parsePropertyName(e)),(c===</span><span class="s2">&quot;get&quot;</span><span class="s0">||c===</span><span class="s2">&quot;set&quot;</span><span class="s0">)&amp;&amp;(i=!</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.resetPreviousNodeTrailingComments(u),e.kind=c,</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">55</span><span class="s0">)&amp;&amp;(n=!</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.raise(f.AccessorIsGenerator,{at:</span><span class="s1">this</span><span class="s0">.state.curPosition(),kind:c}),</span><span class="s1">this</span><span class="s0">.next()),</span><span class="s1">this</span><span class="s0">.parsePropertyName(e))}</span><span class="s1">return this</span><span class="s0">.parseObjPropValue(e,a,n,s,!</span><span class="s3">1</span><span class="s0">,i,t)}getGetterSetterExpectedParamCount(t){</span><span class="s1">return </span><span class="s0">t.kind===</span><span class="s2">&quot;get&quot;</span><span class="s0">?</span><span class="s3">0</span><span class="s0">:</span><span class="s3">1</span><span class="s0">}getObjectOrClassMethodParams(t){</span><span class="s1">return </span><span class="s0">t.params}checkGetterSetterParams(t){</span><span class="s1">var </span><span class="s0">r;let e=</span><span class="s1">this</span><span class="s0">.getGetterSetterExpectedParamCount(t),s=</span><span class="s1">this</span><span class="s0">.getObjectOrClassMethodParams(t);s.length!==e&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(t.kind===</span><span class="s2">&quot;get&quot;</span><span class="s0">?f.BadGetterArity:f.BadSetterArity,{at:t}),t.kind===</span><span class="s2">&quot;set&quot;</span><span class="s0">&amp;&amp;((r=s[s.length-1])==</span><span class="s1">null</span><span class="s0">?</span><span class="s1">void </span><span class="s3">0</span><span class="s0">:r.type)===</span><span class="s2">&quot;RestElement&quot;</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.BadSetterRestParameter,{at:t})}parseObjectMethod(t,r,e,s,i){</span><span class="s1">if</span><span class="s0">(i){let a=</span><span class="s1">this</span><span class="s0">.parseMethod(t,r,!</span><span class="s3">1</span><span class="s0">,!</span><span class="s3">1</span><span class="s0">,!</span><span class="s3">1</span><span class="s0">,</span><span class="s2">&quot;ObjectMethod&quot;</span><span class="s0">);</span><span class="s1">return this</span><span class="s0">.checkGetterSetterParams(a),a}</span><span class="s1">if</span><span class="s0">(e||r||</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">10</span><span class="s0">))</span><span class="s1">return </span><span class="s0">s&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(),t.kind=</span><span class="s2">&quot;method&quot;</span><span class="s0">,t.method=!</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.parseMethod(t,r,e,!</span><span class="s3">1</span><span class="s0">,!</span><span class="s3">1</span><span class="s0">,</span><span class="s2">&quot;ObjectMethod&quot;</span><span class="s0">)}parseObjectProperty(t,r,e,s){</span><span class="s1">if</span><span class="s0">(t.shorthand=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">14</span><span class="s0">))</span><span class="s1">return </span><span class="s0">t.value=e?</span><span class="s1">this</span><span class="s0">.parseMaybeDefault(</span><span class="s1">this</span><span class="s0">.state.startLoc):</span><span class="s1">this</span><span class="s0">.parseMaybeAssignAllowIn(s),</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s2">&quot;ObjectProperty&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(!t.computed&amp;&amp;t.key.type===</span><span class="s2">&quot;Identifier&quot;</span><span class="s0">){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.checkReservedWord(t.key.name,t.key.loc.start,!</span><span class="s3">0</span><span class="s0">,!</span><span class="s3">1</span><span class="s0">),e)t.value=</span><span class="s1">this</span><span class="s0">.parseMaybeDefault(r,me(t.key));</span><span class="s1">else if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">29</span><span class="s0">)){let i=</span><span class="s1">this</span><span class="s0">.state.startLoc;s!=</span><span class="s1">null</span><span class="s0">?s.shorthandAssignLoc===</span><span class="s1">null</span><span class="s0">&amp;&amp;(s.shorthandAssignLoc=i):</span><span class="s1">this</span><span class="s0">.raise(f.InvalidCoverInitializedName,{at:i}),t.value=</span><span class="s1">this</span><span class="s0">.parseMaybeDefault(r,me(t.key))}</span><span class="s1">else </span><span class="s0">t.value=me(t.key);</span><span class="s1">return </span><span class="s0">t.shorthand=!</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s2">&quot;ObjectProperty&quot;</span><span class="s0">)}}parseObjPropValue(t,r,e,s,i,a,n){let o=</span><span class="s1">this</span><span class="s0">.parseObjectMethod(t,e,s,i,a)||</span><span class="s1">this</span><span class="s0">.parseObjectProperty(t,r,i,n);</span><span class="s1">return </span><span class="s0">o||</span><span class="s1">this</span><span class="s0">.unexpected(),o}parsePropertyName(t,r){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">0</span><span class="s0">))t.computed=!</span><span class="s3">0</span><span class="s0">,t.key=</span><span class="s1">this</span><span class="s0">.parseMaybeAssignAllowIn(),</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">3</span><span class="s0">);</span><span class="s1">else</span><span class="s0">{let{type:e,value:s}=</span><span class="s1">this</span><span class="s0">.state,i;</span><span class="s1">if</span><span class="s0">(te(e))i=</span><span class="s1">this</span><span class="s0">.parseIdentifier(!</span><span class="s3">0</span><span class="s0">);</span><span class="s1">else switch</span><span class="s0">(e){</span><span class="s1">case </span><span class="s3">132</span><span class="s0">:i=</span><span class="s1">this</span><span class="s0">.parseNumericLiteral(s);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case </span><span class="s3">131</span><span class="s0">:i=</span><span class="s1">this</span><span class="s0">.parseStringLiteral(s);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case </span><span class="s3">133</span><span class="s0">:i=</span><span class="s1">this</span><span class="s0">.parseBigIntLiteral(s);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case </span><span class="s3">134</span><span class="s0">:i=</span><span class="s1">this</span><span class="s0">.parseDecimalLiteral(s);</span><span class="s1">break</span><span class="s0">;</span><span class="s1">case </span><span class="s3">136</span><span class="s0">:{let a=</span><span class="s1">this</span><span class="s0">.state.startLoc;r!=</span><span class="s1">null</span><span class="s0">?r.privateKeyLoc===</span><span class="s1">null</span><span class="s0">&amp;&amp;(r.privateKeyLoc=a):</span><span class="s1">this</span><span class="s0">.raise(f.UnexpectedPrivateField,{at:a}),i=</span><span class="s1">this</span><span class="s0">.parsePrivateName();</span><span class="s1">break</span><span class="s0">}</span><span class="s1">default</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.unexpected()}t.key=i,e!==</span><span class="s3">136</span><span class="s0">&amp;&amp;(t.computed=!</span><span class="s3">1</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">t.key}initFunction(t,r){t.id=</span><span class="s1">null</span><span class="s0">,t.generator=!</span><span class="s3">1</span><span class="s0">,t.async=r}parseMethod(t,r,e,s,i,a){let n=arguments.length&gt;</span><span class="s3">6</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">6</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">6</span><span class="s0">]:!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.initFunction(t,e),t.generator=r,</span><span class="s1">this</span><span class="s0">.scope.enter(de|ht|(n?Ee:</span><span class="s3">0</span><span class="s0">)|(i?Pr:</span><span class="s3">0</span><span class="s0">)),</span><span class="s1">this</span><span class="s0">.prodParam.enter(Tt(e,t.generator)),</span><span class="s1">this</span><span class="s0">.parseFunctionParams(t,s);let o=</span><span class="s1">this</span><span class="s0">.parseFunctionBodyAndFinish(t,a,!</span><span class="s3">0</span><span class="s0">);</span><span class="s1">return this</span><span class="s0">.prodParam.exit(),</span><span class="s1">this</span><span class="s0">.scope.exit(),o}parseArrayLike(t,r,e,s){e&amp;&amp;</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s2">&quot;recordAndTuple&quot;</span><span class="s0">);let i=</span><span class="s1">this</span><span class="s0">.state.inFSharpPipelineDirectBody;</span><span class="s1">this</span><span class="s0">.state.inFSharpPipelineDirectBody=!</span><span class="s3">1</span><span class="s0">;let a=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),a.elements=</span><span class="s1">this</span><span class="s0">.parseExprList(t,!e,s,a),</span><span class="s1">this</span><span class="s0">.state.inFSharpPipelineDirectBody=i,</span><span class="s1">this</span><span class="s0">.finishNode(a,e?</span><span class="s2">&quot;TupleExpression&quot;</span><span class="s0">:</span><span class="s2">&quot;ArrayExpression&quot;</span><span class="s0">)}parseArrowExpression(t,r,e,s){</span><span class="s1">this</span><span class="s0">.scope.enter(de|Gt);let i=Tt(e,!</span><span class="s3">1</span><span class="s0">);!</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">5</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.prodParam.hasIn&amp;&amp;(i|=_e),</span><span class="s1">this</span><span class="s0">.prodParam.enter(i),</span><span class="s1">this</span><span class="s0">.initFunction(t,e);let a=</span><span class="s1">this</span><span class="s0">.state.maybeInArrowParameters;</span><span class="s1">return </span><span class="s0">r&amp;&amp;(</span><span class="s1">this</span><span class="s0">.state.maybeInArrowParameters=!</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.setArrowFunctionParameters(t,r,s)),</span><span class="s1">this</span><span class="s0">.state.maybeInArrowParameters=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.parseFunctionBody(t,!</span><span class="s3">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.prodParam.exit(),</span><span class="s1">this</span><span class="s0">.scope.exit(),</span><span class="s1">this</span><span class="s0">.state.maybeInArrowParameters=a,</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s2">&quot;ArrowFunctionExpression&quot;</span><span class="s0">)}setArrowFunctionParameters(t,r,e){</span><span class="s1">this</span><span class="s0">.toAssignableList(r,e,!</span><span class="s3">1</span><span class="s0">),t.params=r}parseFunctionBodyAndFinish(t,r){let e=arguments.length&gt;</span><span class="s3">2</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">2</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">2</span><span class="s0">]:!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">return this</span><span class="s0">.parseFunctionBody(t,!</span><span class="s3">1</span><span class="s0">,e),</span><span class="s1">this</span><span class="s0">.finishNode(t,r)}parseFunctionBody(t,r){let e=arguments.length&gt;</span><span class="s3">2</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">2</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">2</span><span class="s0">]:!</span><span class="s3">1</span><span class="s0">,s=r&amp;&amp;!</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">5</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.expressionScope.enter(_r()),s)t.body=</span><span class="s1">this</span><span class="s0">.parseMaybeAssign(),</span><span class="s1">this</span><span class="s0">.checkParams(t,!</span><span class="s3">1</span><span class="s0">,r,!</span><span class="s3">1</span><span class="s0">);</span><span class="s1">else</span><span class="s0">{let i=</span><span class="s1">this</span><span class="s0">.state.strict,a=</span><span class="s1">this</span><span class="s0">.state.labels;</span><span class="s1">this</span><span class="s0">.state.labels=[],</span><span class="s1">this</span><span class="s0">.prodParam.enter(</span><span class="s1">this</span><span class="s0">.prodParam.currentFlags()|jr),t.body=</span><span class="s1">this</span><span class="s0">.parseBlock(!</span><span class="s3">0</span><span class="s0">,!</span><span class="s3">1</span><span class="s0">,n=&gt;{let o=!</span><span class="s1">this</span><span class="s0">.isSimpleParamList(t.params);n&amp;&amp;o&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.IllegalLanguageModeDirective,{at:(t.kind===</span><span class="s2">&quot;method&quot;</span><span class="s0">||t.kind===</span><span class="s2">&quot;constructor&quot;</span><span class="s0">)&amp;&amp;t.key?t.key.loc.end:t});let u=!i&amp;&amp;</span><span class="s1">this</span><span class="s0">.state.strict;</span><span class="s1">this</span><span class="s0">.checkParams(t,!</span><span class="s1">this</span><span class="s0">.state.strict&amp;&amp;!r&amp;&amp;!e&amp;&amp;!o,r,u),</span><span class="s1">this</span><span class="s0">.state.strict&amp;&amp;t.id&amp;&amp;</span><span class="s1">this</span><span class="s0">.checkIdentifier(t.id,dl,u)}),</span><span class="s1">this</span><span class="s0">.prodParam.exit(),</span><span class="s1">this</span><span class="s0">.state.labels=a}</span><span class="s1">this</span><span class="s0">.expressionScope.exit()}isSimpleParameter(t){</span><span class="s1">return </span><span class="s0">t.type===</span><span class="s2">&quot;Identifier&quot;</span><span class="s0">}isSimpleParamList(t){</span><span class="s1">for</span><span class="s0">(let r=</span><span class="s3">0</span><span class="s0">,e=t.length;r&lt;e;r++)</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.isSimpleParameter(t[r]))</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">return</span><span class="s0">!</span><span class="s3">0</span><span class="s0">}checkParams(t,r,e){let s=arguments.length&gt;</span><span class="s3">3</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">3</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">3</span><span class="s0">]:!</span><span class="s3">0</span><span class="s0">,i=!r&amp;&amp;</span><span class="s1">new </span><span class="s0">Set,a={type:</span><span class="s2">&quot;FormalParameters&quot;</span><span class="s0">};</span><span class="s1">for</span><span class="s0">(let n of t.params)</span><span class="s1">this</span><span class="s0">.checkLVal(n,{</span><span class="s1">in</span><span class="s0">:a,binding:mt,checkClashes:i,strictModeChanged:s})}parseExprList(t,r,e,s){let i=[],a=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(;!</span><span class="s1">this</span><span class="s0">.eat(t);){</span><span class="s1">if</span><span class="s0">(a)a=!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">else if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">12</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.match(t)){s&amp;&amp;</span><span class="s1">this</span><span class="s0">.addTrailingCommaExtraToNode(s),</span><span class="s1">this</span><span class="s0">.next();</span><span class="s1">break</span><span class="s0">}i.push(</span><span class="s1">this</span><span class="s0">.parseExprListItem(r,e))}</span><span class="s1">return </span><span class="s0">i}parseExprListItem(t,r,e){let s;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">12</span><span class="s0">))t||</span><span class="s1">this</span><span class="s0">.raise(f.UnexpectedToken,{at:</span><span class="s1">this</span><span class="s0">.state.curPosition(),unexpected:</span><span class="s2">&quot;,&quot;</span><span class="s0">}),s=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">else if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">21</span><span class="s0">)){let i=</span><span class="s1">this</span><span class="s0">.state.startLoc;s=</span><span class="s1">this</span><span class="s0">.parseParenItem(</span><span class="s1">this</span><span class="s0">.parseSpread(r),i)}</span><span class="s1">else if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">17</span><span class="s0">)){</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s2">&quot;partialApplication&quot;</span><span class="s0">),e||</span><span class="s1">this</span><span class="s0">.raise(f.UnexpectedArgumentPlaceholder,{at:</span><span class="s1">this</span><span class="s0">.state.startLoc});let i=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">this</span><span class="s0">.next(),s=</span><span class="s1">this</span><span class="s0">.finishNode(i,</span><span class="s2">&quot;ArgumentPlaceholder&quot;</span><span class="s0">)}</span><span class="s1">else </span><span class="s0">s=</span><span class="s1">this</span><span class="s0">.parseMaybeAssignAllowIn(r,</span><span class="s1">this</span><span class="s0">.parseParenItem);</span><span class="s1">return </span><span class="s0">s}parseIdentifier(t){let r=</span><span class="s1">this</span><span class="s0">.startNode(),e=</span><span class="s1">this</span><span class="s0">.parseIdentifierName(t);</span><span class="s1">return this</span><span class="s0">.createIdentifier(r,e)}createIdentifier(t,r){</span><span class="s1">return </span><span class="s0">t.name=r,t.loc.identifierName=r,</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s2">&quot;Identifier&quot;</span><span class="s0">)}parseIdentifierName(t){let r,{startLoc:e,type:s}=</span><span class="s1">this</span><span class="s0">.state;te(s)?r=</span><span class="s1">this</span><span class="s0">.state.value:</span><span class="s1">this</span><span class="s0">.unexpected();let i=ue(s);</span><span class="s1">return </span><span class="s0">t?i&amp;&amp;</span><span class="s1">this</span><span class="s0">.replaceToken(</span><span class="s3">130</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.checkReservedWord(r,e,i,!</span><span class="s3">1</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.next(),r}checkReservedWord(t,r,e,s){</span><span class="s1">if</span><span class="s0">(t.length&gt;</span><span class="s3">10</span><span class="s0">||!ul(t))</span><span class="s1">return</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(e&amp;&amp;ol(t)){</span><span class="s1">this</span><span class="s0">.raise(f.UnexpectedKeyword,{at:r,keyword:t});</span><span class="s1">return</span><span class="s0">}</span><span class="s1">if</span><span class="s0">((</span><span class="s1">this</span><span class="s0">.state.strict?s?xr:mr:dr)(t,</span><span class="s1">this</span><span class="s0">.inModule)){</span><span class="s1">this</span><span class="s0">.raise(f.UnexpectedReservedWord,{at:r,reservedWord:t});</span><span class="s1">return</span><span class="s0">}</span><span class="s1">else if</span><span class="s0">(t===</span><span class="s2">&quot;yield&quot;</span><span class="s0">){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.prodParam.hasYield){</span><span class="s1">this</span><span class="s0">.raise(f.YieldBindingIdentifier,{at:r});</span><span class="s1">return</span><span class="s0">}}</span><span class="s1">else if</span><span class="s0">(t===</span><span class="s2">&quot;await&quot;</span><span class="s0">){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.prodParam.hasAwait){</span><span class="s1">this</span><span class="s0">.raise(f.AwaitBindingIdentifier,{at:r});</span><span class="s1">return</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.scope.inStaticBlock){</span><span class="s1">this</span><span class="s0">.raise(f.AwaitBindingIdentifierInStaticBlock,{at:r});</span><span class="s1">return</span><span class="s0">}</span><span class="s1">this</span><span class="s0">.expressionScope.recordAsyncArrowParametersError({at:r})}</span><span class="s1">else if</span><span class="s0">(t===</span><span class="s2">&quot;arguments&quot;</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.scope.inClassAndNotInNonArrowFunction){</span><span class="s1">this</span><span class="s0">.raise(f.ArgumentsInClass,{at:r});</span><span class="s1">return</span><span class="s0">}}isAwaitAllowed(){</span><span class="s1">return</span><span class="s0">!!(</span><span class="s1">this</span><span class="s0">.prodParam.hasAwait||</span><span class="s1">this</span><span class="s0">.options.allowAwaitOutsideFunction&amp;&amp;!</span><span class="s1">this</span><span class="s0">.scope.inFunction)}parseAwait(t){let r=</span><span class="s1">this</span><span class="s0">.startNodeAt(t);</span><span class="s1">return this</span><span class="s0">.expressionScope.recordParameterInitializerError(f.AwaitExpressionFormalParameter,{at:r}),</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">55</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.ObsoleteAwaitStar,{at:r}),!</span><span class="s1">this</span><span class="s0">.scope.inFunction&amp;&amp;!</span><span class="s1">this</span><span class="s0">.options.allowAwaitOutsideFunction&amp;&amp;(</span><span class="s1">this</span><span class="s0">.isAmbiguousAwait()?</span><span class="s1">this</span><span class="s0">.ambiguousScriptDifferentAst=!</span><span class="s3">0</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.sawUnambiguousESM=!</span><span class="s3">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.state.soloAwait||(r.argument=</span><span class="s1">this</span><span class="s0">.parseMaybeUnary(</span><span class="s1">null</span><span class="s0">,!</span><span class="s3">0</span><span class="s0">)),</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s2">&quot;AwaitExpression&quot;</span><span class="s0">)}isAmbiguousAwait(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.hasPrecedingLineBreak())</span><span class="s1">return</span><span class="s0">!</span><span class="s3">0</span><span class="s0">;let{type:t}=</span><span class="s1">this</span><span class="s0">.state;</span><span class="s1">return </span><span class="s0">t===</span><span class="s3">53</span><span class="s0">||t===</span><span class="s3">10</span><span class="s0">||t===</span><span class="s3">0</span><span class="s0">||nt(t)||t===</span><span class="s3">101</span><span class="s0">&amp;&amp;!</span><span class="s1">this</span><span class="s0">.state.containsEsc||t===</span><span class="s3">135</span><span class="s0">||t===</span><span class="s3">56</span><span class="s0">||</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s2">&quot;v8intrinsic&quot;</span><span class="s0">)&amp;&amp;t===</span><span class="s3">54</span><span class="s0">}parseYield(){let t=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">this</span><span class="s0">.expressionScope.recordParameterInitializerError(f.YieldInParameter,{at:t}),</span><span class="s1">this</span><span class="s0">.next();let r=!</span><span class="s3">1</span><span class="s0">,e=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.hasPrecedingLineBreak())</span><span class="s1">switch</span><span class="s0">(r=</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">55</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.state.type){</span><span class="s1">case </span><span class="s3">13</span><span class="s0">:</span><span class="s1">case </span><span class="s3">137</span><span class="s0">:</span><span class="s1">case </span><span class="s3">8</span><span class="s0">:</span><span class="s1">case </span><span class="s3">11</span><span class="s0">:</span><span class="s1">case </span><span class="s3">3</span><span class="s0">:</span><span class="s1">case </span><span class="s3">9</span><span class="s0">:</span><span class="s1">case </span><span class="s3">14</span><span class="s0">:</span><span class="s1">case </span><span class="s3">12</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(!r)</span><span class="s1">break</span><span class="s0">;</span><span class="s1">default</span><span class="s0">:e=</span><span class="s1">this</span><span class="s0">.parseMaybeAssign()}</span><span class="s1">return </span><span class="s0">t.delegate=r,t.argument=e,</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s2">&quot;YieldExpression&quot;</span><span class="s0">)}checkPipelineAtInfixOperator(t,r){</span><span class="s1">this</span><span class="s0">.hasPlugin([</span><span class="s2">&quot;pipelineOperator&quot;</span><span class="s0">,{proposal:</span><span class="s2">&quot;smart&quot;</span><span class="s0">}])&amp;&amp;t.type===</span><span class="s2">&quot;SequenceExpression&quot;</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.PipelineHeadSequenceExpression,{at:r})}parseSmartPipelineBodyInStyle(t,r){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isSimpleReference(t)){let e=</span><span class="s1">this</span><span class="s0">.startNodeAt(r);</span><span class="s1">return </span><span class="s0">e.callee=t,</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;PipelineBareFunction&quot;</span><span class="s0">)}</span><span class="s1">else</span><span class="s0">{let e=</span><span class="s1">this</span><span class="s0">.startNodeAt(r);</span><span class="s1">return this</span><span class="s0">.checkSmartPipeTopicBodyEarlyErrors(r),e.expression=t,</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;PipelineTopicExpression&quot;</span><span class="s0">)}}isSimpleReference(t){</span><span class="s1">switch</span><span class="s0">(t.type){</span><span class="s1">case</span><span class="s2">&quot;MemberExpression&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s0">!t.computed&amp;&amp;</span><span class="s1">this</span><span class="s0">.isSimpleReference(t.object);</span><span class="s1">case</span><span class="s2">&quot;Identifier&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s0">!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">default</span><span class="s0">:</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">}}checkSmartPipeTopicBodyEarlyErrors(t){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">19</span><span class="s0">))</span><span class="s1">throw this</span><span class="s0">.raise(f.PipelineBodyNoArrow,{at:</span><span class="s1">this</span><span class="s0">.state.startLoc});</span><span class="s1">this</span><span class="s0">.topicReferenceWasUsedInCurrentContext()||</span><span class="s1">this</span><span class="s0">.raise(f.PipelineTopicUnused,{at:t})}withTopicBindingContext(t){let r=</span><span class="s1">this</span><span class="s0">.state.topicContext;</span><span class="s1">this</span><span class="s0">.state.topicContext={maxNumOfResolvableTopics:</span><span class="s3">1</span><span class="s0">,maxTopicIndex:</span><span class="s1">null</span><span class="s0">};</span><span class="s1">try</span><span class="s0">{</span><span class="s1">return </span><span class="s0">t()}</span><span class="s1">finally</span><span class="s0">{</span><span class="s1">this</span><span class="s0">.state.topicContext=r}}withSmartMixTopicForbiddingContext(t){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.hasPlugin([</span><span class="s2">&quot;pipelineOperator&quot;</span><span class="s0">,{proposal:</span><span class="s2">&quot;smart&quot;</span><span class="s0">}])){let r=</span><span class="s1">this</span><span class="s0">.state.topicContext;</span><span class="s1">this</span><span class="s0">.state.topicContext={maxNumOfResolvableTopics:</span><span class="s3">0</span><span class="s0">,maxTopicIndex:</span><span class="s1">null</span><span class="s0">};</span><span class="s1">try</span><span class="s0">{</span><span class="s1">return </span><span class="s0">t()}</span><span class="s1">finally</span><span class="s0">{</span><span class="s1">this</span><span class="s0">.state.topicContext=r}}</span><span class="s1">else return </span><span class="s0">t()}withSoloAwaitPermittingContext(t){let r=</span><span class="s1">this</span><span class="s0">.state.soloAwait;</span><span class="s1">this</span><span class="s0">.state.soloAwait=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">try</span><span class="s0">{</span><span class="s1">return </span><span class="s0">t()}</span><span class="s1">finally</span><span class="s0">{</span><span class="s1">this</span><span class="s0">.state.soloAwait=r}}allowInAnd(t){let r=</span><span class="s1">this</span><span class="s0">.prodParam.currentFlags();</span><span class="s1">if</span><span class="s0">(_e&amp;~r){</span><span class="s1">this</span><span class="s0">.prodParam.enter(r|_e);</span><span class="s1">try</span><span class="s0">{</span><span class="s1">return </span><span class="s0">t()}</span><span class="s1">finally</span><span class="s0">{</span><span class="s1">this</span><span class="s0">.prodParam.exit()}}</span><span class="s1">return </span><span class="s0">t()}disallowInAnd(t){let r=</span><span class="s1">this</span><span class="s0">.prodParam.currentFlags();</span><span class="s1">if</span><span class="s0">(_e&amp;r){</span><span class="s1">this</span><span class="s0">.prodParam.enter(r&amp;~_e);</span><span class="s1">try</span><span class="s0">{</span><span class="s1">return </span><span class="s0">t()}</span><span class="s1">finally</span><span class="s0">{</span><span class="s1">this</span><span class="s0">.prodParam.exit()}}</span><span class="s1">return </span><span class="s0">t()}registerTopicReference(){</span><span class="s1">this</span><span class="s0">.state.topicContext.maxTopicIndex=</span><span class="s3">0</span><span class="s0">}topicReferenceIsAllowedInCurrentContext(){</span><span class="s1">return this</span><span class="s0">.state.topicContext.maxNumOfResolvableTopics&gt;=</span><span class="s3">1</span><span class="s0">}topicReferenceWasUsedInCurrentContext(){</span><span class="s1">return this</span><span class="s0">.state.topicContext.maxTopicIndex!=</span><span class="s1">null</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.state.topicContext.maxTopicIndex&gt;=</span><span class="s3">0</span><span class="s0">}parseFSharpPipelineBody(t){let r=</span><span class="s1">this</span><span class="s0">.state.startLoc;</span><span class="s1">this</span><span class="s0">.state.potentialArrowAt=</span><span class="s1">this</span><span class="s0">.state.start;let e=</span><span class="s1">this</span><span class="s0">.state.inFSharpPipelineDirectBody;</span><span class="s1">this</span><span class="s0">.state.inFSharpPipelineDirectBody=!</span><span class="s3">0</span><span class="s0">;let s=</span><span class="s1">this</span><span class="s0">.parseExprOp(</span><span class="s1">this</span><span class="s0">.parseMaybeUnaryOrPrivate(),r,t);</span><span class="s1">return this</span><span class="s0">.state.inFSharpPipelineDirectBody=e,s}parseModuleExpression(){</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s2">&quot;moduleBlocks&quot;</span><span class="s0">);let t=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">5</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.unexpected(</span><span class="s1">null</span><span class="s0">,</span><span class="s3">5</span><span class="s0">);let r=</span><span class="s1">this</span><span class="s0">.startNodeAt(</span><span class="s1">this</span><span class="s0">.state.endLoc);</span><span class="s1">this</span><span class="s0">.next();let e=</span><span class="s1">this</span><span class="s0">.initializeScopes(!</span><span class="s3">0</span><span class="s0">);</span><span class="s1">this</span><span class="s0">.enterInitialScopes();</span><span class="s1">try</span><span class="s0">{t.body=</span><span class="s1">this</span><span class="s0">.parseProgram(r,</span><span class="s3">8</span><span class="s0">,</span><span class="s2">&quot;module&quot;</span><span class="s0">)}</span><span class="s1">finally</span><span class="s0">{e()}</span><span class="s1">return this</span><span class="s0">.finishNode(t,</span><span class="s2">&quot;ModuleExpression&quot;</span><span class="s0">)}parsePropertyNamePrefixOperator(t){}},cs={kind:</span><span class="s2">&quot;loop&quot;</span><span class="s0">},Ph={kind:</span><span class="s2">&quot;switch&quot;</span><span class="s0">},Ah=/[\uD800-\uDFFF]/u,ps=/</span><span class="s1">in</span><span class="s0">(?:stanceof)?/y;</span><span class="s1">function </span><span class="s0">Th(t,r){</span><span class="s1">for</span><span class="s0">(let e=</span><span class="s3">0</span><span class="s0">;e&lt;t.length;e++){let s=t[e],{type:i}=s;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">i==</span><span class="s2">&quot;number&quot;</span><span class="s0">){{</span><span class="s1">if</span><span class="s0">(i===</span><span class="s3">136</span><span class="s0">){let{loc:a,start:n,value:o,end:u}=s,c=n+</span><span class="s3">1</span><span class="s0">,y=Y(a.start,</span><span class="s3">1</span><span class="s0">);t.splice(e,</span><span class="s3">1</span><span class="s0">,</span><span class="s1">new </span><span class="s0">Ae({type:ce(</span><span class="s3">27</span><span class="s0">),value:</span><span class="s2">&quot;#&quot;</span><span class="s0">,start:n,end:c,startLoc:a.start,endLoc:y}),</span><span class="s1">new </span><span class="s0">Ae({type:ce(</span><span class="s3">130</span><span class="s0">),value:o,start:c,end:u,startLoc:y,endLoc:a.end})),e++;</span><span class="s1">continue</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(nt(i)){let{loc:a,start:n,value:o,end:u}=s,c=n+</span><span class="s3">1</span><span class="s0">,y=Y(a.start,</span><span class="s3">1</span><span class="s0">),g;r.charCodeAt(n)===</span><span class="s3">96</span><span class="s0">?g=</span><span class="s1">new </span><span class="s0">Ae({type:ce(</span><span class="s3">22</span><span class="s0">),value:</span><span class="s2">&quot;`&quot;</span><span class="s0">,start:n,end:c,startLoc:a.start,endLoc:y}):g=</span><span class="s1">new </span><span class="s0">Ae({type:ce(</span><span class="s3">8</span><span class="s0">),value:</span><span class="s2">&quot;}&quot;</span><span class="s0">,start:n,end:c,startLoc:a.start,endLoc:y});let T,C,M,j;i===</span><span class="s3">24</span><span class="s0">?(C=u-1,M=Y(a.end,-</span><span class="s3">1</span><span class="s0">),T=o===</span><span class="s1">null</span><span class="s0">?</span><span class="s1">null</span><span class="s0">:o.slice(</span><span class="s3">1</span><span class="s0">,-</span><span class="s3">1</span><span class="s0">),j=</span><span class="s1">new </span><span class="s0">Ae({type:ce(</span><span class="s3">22</span><span class="s0">),value:</span><span class="s2">&quot;`&quot;</span><span class="s0">,start:C,end:u,startLoc:M,endLoc:a.end})):(C=u-2,M=Y(a.end,-</span><span class="s3">2</span><span class="s0">),T=o===</span><span class="s1">null</span><span class="s0">?</span><span class="s1">null</span><span class="s0">:o.slice(</span><span class="s3">1</span><span class="s0">,-</span><span class="s3">2</span><span class="s0">),j=</span><span class="s1">new </span><span class="s0">Ae({type:ce(</span><span class="s3">23</span><span class="s0">),value:</span><span class="s2">&quot;${&quot;</span><span class="s0">,start:C,end:u,startLoc:M,endLoc:a.end})),t.splice(e,</span><span class="s3">1</span><span class="s0">,g,</span><span class="s1">new </span><span class="s0">Ae({type:ce(</span><span class="s3">20</span><span class="s0">),value:T,start:c,end:C,startLoc:y,endLoc:M}),j),e+=</span><span class="s3">2</span><span class="s0">;</span><span class="s1">continue</span><span class="s0">}}s.type=ce(i)}}</span><span class="s1">return </span><span class="s0">t}</span><span class="s1">var </span><span class="s0">vh=class extends gh{parseTopLevel(t,r){</span><span class="s1">return </span><span class="s0">t.program=</span><span class="s1">this</span><span class="s0">.parseProgram(r),t.comments=</span><span class="s1">this</span><span class="s0">.state.comments,</span><span class="s1">this</span><span class="s0">.options.tokens&amp;&amp;(t.tokens=Th(</span><span class="s1">this</span><span class="s0">.tokens,</span><span class="s1">this</span><span class="s0">.input)),</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s2">&quot;File&quot;</span><span class="s0">)}parseProgram(t){let r=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">1</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">1</span><span class="s0">]:</span><span class="s3">137</span><span class="s0">,e=arguments.length&gt;</span><span class="s3">2</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">2</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">2</span><span class="s0">]:</span><span class="s1">this</span><span class="s0">.options.sourceType;</span><span class="s1">if</span><span class="s0">(t.sourceType=e,t.interpreter=</span><span class="s1">this</span><span class="s0">.parseInterpreterDirective(),</span><span class="s1">this</span><span class="s0">.parseBlockBody(t,!</span><span class="s3">0</span><span class="s0">,!</span><span class="s3">0</span><span class="s0">,r),</span><span class="s1">this</span><span class="s0">.inModule&amp;&amp;!</span><span class="s1">this</span><span class="s0">.options.allowUndeclaredExports&amp;&amp;</span><span class="s1">this</span><span class="s0">.scope.undefinedExports.size&gt;</span><span class="s3">0</span><span class="s0">)</span><span class="s1">for</span><span class="s0">(let[i,a]of Array.from(</span><span class="s1">this</span><span class="s0">.scope.undefinedExports))</span><span class="s1">this</span><span class="s0">.raise(f.ModuleExportUndefined,{at:a,localName:i});let s;</span><span class="s1">return </span><span class="s0">r===</span><span class="s3">137</span><span class="s0">?s=</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s2">&quot;Program&quot;</span><span class="s0">):s=</span><span class="s1">this</span><span class="s0">.finishNodeAt(t,</span><span class="s2">&quot;Program&quot;</span><span class="s0">,Y(</span><span class="s1">this</span><span class="s0">.state.startLoc,-</span><span class="s3">1</span><span class="s0">)),s}stmtToDirective(t){let r=t;r.type=</span><span class="s2">&quot;Directive&quot;</span><span class="s0">,r.value=r.expression,</span><span class="s1">delete </span><span class="s0">r.expression;let e=r.value,s=e.value,i=</span><span class="s1">this</span><span class="s0">.input.slice(e.start,e.end),a=e.value=i.slice(</span><span class="s3">1</span><span class="s0">,-</span><span class="s3">1</span><span class="s0">);</span><span class="s1">return this</span><span class="s0">.addExtra(e,</span><span class="s2">&quot;raw&quot;</span><span class="s0">,i),</span><span class="s1">this</span><span class="s0">.addExtra(e,</span><span class="s2">&quot;rawValue&quot;</span><span class="s0">,a),</span><span class="s1">this</span><span class="s0">.addExtra(e,</span><span class="s2">&quot;expressionValue&quot;</span><span class="s0">,s),e.type=</span><span class="s2">&quot;DirectiveLiteral&quot;</span><span class="s0">,r}parseInterpreterDirective(){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">28</span><span class="s0">))</span><span class="s1">return null</span><span class="s0">;let t=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">t.value=</span><span class="s1">this</span><span class="s0">.state.value,</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s2">&quot;InterpreterDirective&quot;</span><span class="s0">)}isLet(){</span><span class="s1">return this</span><span class="s0">.isContextual(</span><span class="s3">99</span><span class="s0">)?</span><span class="s1">this</span><span class="s0">.hasFollowingBindingAtom():!</span><span class="s3">1</span><span class="s0">}chStartsBindingIdentifier(t,r){</span><span class="s1">if</span><span class="s0">(fe(t)){</span><span class="s1">if</span><span class="s0">(ps.lastIndex=r,ps.test(</span><span class="s1">this</span><span class="s0">.input)){let e=</span><span class="s1">this</span><span class="s0">.codePointAtPos(ps.lastIndex);</span><span class="s1">if</span><span class="s0">(!De(e)&amp;&amp;e!==</span><span class="s3">92</span><span class="s0">)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">}</span><span class="s1">return</span><span class="s0">!</span><span class="s3">0</span><span class="s0">}</span><span class="s1">else return </span><span class="s0">t===</span><span class="s3">92</span><span class="s0">}chStartsBindingPattern(t){</span><span class="s1">return </span><span class="s0">t===</span><span class="s3">91</span><span class="s0">||t===</span><span class="s3">123</span><span class="s0">}hasFollowingBindingAtom(){let t=</span><span class="s1">this</span><span class="s0">.nextTokenStart(),r=</span><span class="s1">this</span><span class="s0">.codePointAtPos(t);</span><span class="s1">return this</span><span class="s0">.chStartsBindingPattern(r)||</span><span class="s1">this</span><span class="s0">.chStartsBindingIdentifier(r,t)}hasFollowingBindingIdentifier(){let t=</span><span class="s1">this</span><span class="s0">.nextTokenStart(),r=</span><span class="s1">this</span><span class="s0">.codePointAtPos(t);</span><span class="s1">return this</span><span class="s0">.chStartsBindingIdentifier(r,t)}startsUsingForOf(){let t=</span><span class="s1">this</span><span class="s0">.lookahead();</span><span class="s1">return </span><span class="s0">t.type===</span><span class="s3">101</span><span class="s0">&amp;&amp;!t.containsEsc?!</span><span class="s3">1</span><span class="s0">:(</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s2">&quot;explicitResourceManagement&quot;</span><span class="s0">),!</span><span class="s3">0</span><span class="s0">)}parseModuleItem(){</span><span class="s1">return this</span><span class="s0">.parseStatementLike(</span><span class="s3">15</span><span class="s0">)}parseStatementListItem(){</span><span class="s1">return this</span><span class="s0">.parseStatementLike(</span><span class="s3">6</span><span class="s0">|(!</span><span class="s1">this</span><span class="s0">.options.annexB||</span><span class="s1">this</span><span class="s0">.state.strict?</span><span class="s3">0</span><span class="s0">:</span><span class="s3">8</span><span class="s0">))}parseStatementOrSloppyAnnexBFunctionDeclaration(){let t=arguments.length&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">0</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">0</span><span class="s0">]:!</span><span class="s3">1</span><span class="s0">,r=</span><span class="s3">0</span><span class="s0">;</span><span class="s1">return this</span><span class="s0">.options.annexB&amp;&amp;!</span><span class="s1">this</span><span class="s0">.state.strict&amp;&amp;(r|=</span><span class="s3">4</span><span class="s0">,t&amp;&amp;(r|=</span><span class="s3">8</span><span class="s0">)),</span><span class="s1">this</span><span class="s0">.parseStatementLike(r)}parseStatement(){</span><span class="s1">return this</span><span class="s0">.parseStatementLike(</span><span class="s3">0</span><span class="s0">)}parseStatementLike(t){let r=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">return this</span><span class="s0">.match(</span><span class="s3">26</span><span class="s0">)&amp;&amp;(r=</span><span class="s1">this</span><span class="s0">.parseDecorators(!</span><span class="s3">0</span><span class="s0">)),</span><span class="s1">this</span><span class="s0">.parseStatementContent(t,r)}parseStatementContent(t,r){let e=</span><span class="s1">this</span><span class="s0">.state.type,s=</span><span class="s1">this</span><span class="s0">.startNode(),i=!!(t&amp;</span><span class="s3">2</span><span class="s0">),a=!!(t&amp;</span><span class="s3">4</span><span class="s0">),n=t&amp;</span><span class="s3">1</span><span class="s0">;</span><span class="s1">switch</span><span class="s0">(e){</span><span class="s1">case </span><span class="s3">60</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.parseBreakContinueStatement(s,!</span><span class="s3">0</span><span class="s0">);</span><span class="s1">case </span><span class="s3">63</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.parseBreakContinueStatement(s,!</span><span class="s3">1</span><span class="s0">);</span><span class="s1">case </span><span class="s3">64</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.parseDebuggerStatement(s);</span><span class="s1">case </span><span class="s3">90</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.parseDoWhileStatement(s);</span><span class="s1">case </span><span class="s3">91</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.parseForStatement(s);</span><span class="s1">case </span><span class="s3">68</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.lookaheadCharCode()===</span><span class="s3">46</span><span class="s0">)</span><span class="s1">break</span><span class="s0">;</span><span class="s1">return </span><span class="s0">a||</span><span class="s1">this</span><span class="s0">.raise(</span><span class="s1">this</span><span class="s0">.state.strict?f.StrictFunction:</span><span class="s1">this</span><span class="s0">.options.annexB?f.SloppyFunctionAnnexB:f.SloppyFunction,{at:</span><span class="s1">this</span><span class="s0">.state.startLoc}),</span><span class="s1">this</span><span class="s0">.parseFunctionStatement(s,!</span><span class="s3">1</span><span class="s0">,!i&amp;&amp;a);</span><span class="s1">case </span><span class="s3">80</span><span class="s0">:</span><span class="s1">return </span><span class="s0">i||</span><span class="s1">this</span><span class="s0">.unexpected(),</span><span class="s1">this</span><span class="s0">.parseClass(</span><span class="s1">this</span><span class="s0">.maybeTakeDecorators(r,s),!</span><span class="s3">0</span><span class="s0">);</span><span class="s1">case </span><span class="s3">69</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.parseIfStatement(s);</span><span class="s1">case </span><span class="s3">70</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.parseReturnStatement(s);</span><span class="s1">case </span><span class="s3">71</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.parseSwitchStatement(s);</span><span class="s1">case </span><span class="s3">72</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.parseThrowStatement(s);</span><span class="s1">case </span><span class="s3">73</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.parseTryStatement(s);</span><span class="s1">case </span><span class="s3">105</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.hasFollowingLineBreak()||</span><span class="s1">this</span><span class="s0">.state.containsEsc||!</span><span class="s1">this</span><span class="s0">.hasFollowingBindingIdentifier())</span><span class="s1">break</span><span class="s0">;</span><span class="s1">return this</span><span class="s0">.expectPlugin(</span><span class="s2">&quot;explicitResourceManagement&quot;</span><span class="s0">),!</span><span class="s1">this</span><span class="s0">.scope.inModule&amp;&amp;</span><span class="s1">this</span><span class="s0">.scope.inTopLevel?</span><span class="s1">this</span><span class="s0">.raise(f.UnexpectedUsingDeclaration,{at:</span><span class="s1">this</span><span class="s0">.state.startLoc}):i||</span><span class="s1">this</span><span class="s0">.raise(f.UnexpectedLexicalDeclaration,{at:</span><span class="s1">this</span><span class="s0">.state.startLoc}),</span><span class="s1">this</span><span class="s0">.parseVarStatement(s,</span><span class="s2">&quot;using&quot;</span><span class="s0">);</span><span class="s1">case </span><span class="s3">99</span><span class="s0">:{</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.containsEsc)</span><span class="s1">break</span><span class="s0">;let c=</span><span class="s1">this</span><span class="s0">.nextTokenStart(),y=</span><span class="s1">this</span><span class="s0">.codePointAtPos(c);</span><span class="s1">if</span><span class="s0">(y!==</span><span class="s3">91</span><span class="s0">&amp;&amp;(!i&amp;&amp;</span><span class="s1">this</span><span class="s0">.hasFollowingLineBreak()||!</span><span class="s1">this</span><span class="s0">.chStartsBindingIdentifier(y,c)&amp;&amp;y!==</span><span class="s3">123</span><span class="s0">))</span><span class="s1">break</span><span class="s0">}</span><span class="s1">case </span><span class="s3">75</span><span class="s0">:i||</span><span class="s1">this</span><span class="s0">.raise(f.UnexpectedLexicalDeclaration,{at:</span><span class="s1">this</span><span class="s0">.state.startLoc});</span><span class="s1">case </span><span class="s3">74</span><span class="s0">:{let c=</span><span class="s1">this</span><span class="s0">.state.value;</span><span class="s1">return this</span><span class="s0">.parseVarStatement(s,c)}</span><span class="s1">case </span><span class="s3">92</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.parseWhileStatement(s);</span><span class="s1">case </span><span class="s3">76</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.parseWithStatement(s);</span><span class="s1">case </span><span class="s3">5</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.parseBlock();</span><span class="s1">case </span><span class="s3">13</span><span class="s0">:</span><span class="s1">return this</span><span class="s0">.parseEmptyStatement(s);</span><span class="s1">case </span><span class="s3">83</span><span class="s0">:{let c=</span><span class="s1">this</span><span class="s0">.lookaheadCharCode();</span><span class="s1">if</span><span class="s0">(c===</span><span class="s3">40</span><span class="s0">||c===</span><span class="s3">46</span><span class="s0">)</span><span class="s1">break</span><span class="s0">}</span><span class="s1">case </span><span class="s3">82</span><span class="s0">:{!</span><span class="s1">this</span><span class="s0">.options.allowImportExportEverywhere&amp;&amp;!n&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.UnexpectedImportExport,{at:</span><span class="s1">this</span><span class="s0">.state.startLoc}),</span><span class="s1">this</span><span class="s0">.next();let c;</span><span class="s1">return </span><span class="s0">e===</span><span class="s3">83</span><span class="s0">?(c=</span><span class="s1">this</span><span class="s0">.parseImport(s),c.type===</span><span class="s2">&quot;ImportDeclaration&quot;</span><span class="s0">&amp;&amp;(!c.importKind||c.importKind===</span><span class="s2">&quot;value&quot;</span><span class="s0">)&amp;&amp;(</span><span class="s1">this</span><span class="s0">.sawUnambiguousESM=!</span><span class="s3">0</span><span class="s0">)):(c=</span><span class="s1">this</span><span class="s0">.parseExport(s,r),(c.type===</span><span class="s2">&quot;ExportNamedDeclaration&quot;</span><span class="s0">&amp;&amp;(!c.exportKind||c.exportKind===</span><span class="s2">&quot;value&quot;</span><span class="s0">)||c.type===</span><span class="s2">&quot;ExportAllDeclaration&quot;</span><span class="s0">&amp;&amp;(!c.exportKind||c.exportKind===</span><span class="s2">&quot;value&quot;</span><span class="s0">)||c.type===</span><span class="s2">&quot;ExportDefaultDeclaration&quot;</span><span class="s0">)&amp;&amp;(</span><span class="s1">this</span><span class="s0">.sawUnambiguousESM=!</span><span class="s3">0</span><span class="s0">)),</span><span class="s1">this</span><span class="s0">.assertModuleNodeAllowed(c),c}</span><span class="s1">default</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isAsyncFunction())</span><span class="s1">return </span><span class="s0">i||</span><span class="s1">this</span><span class="s0">.raise(f.AsyncFunctionInSingleStatementContext,{at:</span><span class="s1">this</span><span class="s0">.state.startLoc}),</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.parseFunctionStatement(s,!</span><span class="s3">0</span><span class="s0">,!i&amp;&amp;a)}let o=</span><span class="s1">this</span><span class="s0">.state.value,u=</span><span class="s1">this</span><span class="s0">.parseExpression();</span><span class="s1">return </span><span class="s0">q(e)&amp;&amp;u.type===</span><span class="s2">&quot;Identifier&quot;</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">14</span><span class="s0">)?</span><span class="s1">this</span><span class="s0">.parseLabeledStatement(s,o,u,t):</span><span class="s1">this</span><span class="s0">.parseExpressionStatement(s,u,r)}assertModuleNodeAllowed(t){!</span><span class="s1">this</span><span class="s0">.options.allowImportExportEverywhere&amp;&amp;!</span><span class="s1">this</span><span class="s0">.inModule&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.ImportOutsideModule,{at:t})}decoratorsEnabledBeforeExport(){</span><span class="s1">return this</span><span class="s0">.hasPlugin(</span><span class="s2">&quot;decorators-legacy&quot;</span><span class="s0">)?!</span><span class="s3">0</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s2">&quot;decorators&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.getPluginOption(</span><span class="s2">&quot;decorators&quot;</span><span class="s0">,</span><span class="s2">&quot;decoratorsBeforeExport&quot;</span><span class="s0">)!==!</span><span class="s3">1</span><span class="s0">}maybeTakeDecorators(t,r,e){</span><span class="s1">return </span><span class="s0">t&amp;&amp;(r.decorators&amp;&amp;r.decorators.length&gt;</span><span class="s3">0</span><span class="s0">?(</span><span class="s1">typeof this</span><span class="s0">.getPluginOption(</span><span class="s2">&quot;decorators&quot;</span><span class="s0">,</span><span class="s2">&quot;decoratorsBeforeExport&quot;</span><span class="s0">)!=</span><span class="s2">&quot;boolean&quot;</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.DecoratorsBeforeAfterExport,{at:r.decorators[</span><span class="s3">0</span><span class="s0">]}),r.decorators.unshift(...t)):r.decorators=t,</span><span class="s1">this</span><span class="s0">.resetStartLocationFromNode(r,t[</span><span class="s3">0</span><span class="s0">]),e&amp;&amp;</span><span class="s1">this</span><span class="s0">.resetStartLocationFromNode(e,r)),r}canHaveLeadingDecorator(){</span><span class="s1">return this</span><span class="s0">.match(</span><span class="s3">80</span><span class="s0">)}parseDecorators(t){let r=[];</span><span class="s1">do </span><span class="s0">r.push(</span><span class="s1">this</span><span class="s0">.parseDecorator());</span><span class="s1">while</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">26</span><span class="s0">));</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">82</span><span class="s0">))t||</span><span class="s1">this</span><span class="s0">.unexpected(),</span><span class="s1">this</span><span class="s0">.decoratorsEnabledBeforeExport()||</span><span class="s1">this</span><span class="s0">.raise(f.DecoratorExportClass,{at:</span><span class="s1">this</span><span class="s0">.state.startLoc});</span><span class="s1">else if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.canHaveLeadingDecorator())</span><span class="s1">throw this</span><span class="s0">.raise(f.UnexpectedLeadingDecorator,{at:</span><span class="s1">this</span><span class="s0">.state.startLoc});</span><span class="s1">return </span><span class="s0">r}parseDecorator(){</span><span class="s1">this</span><span class="s0">.expectOnePlugin([</span><span class="s2">&quot;decorators&quot;</span><span class="s0">,</span><span class="s2">&quot;decorators-legacy&quot;</span><span class="s0">]);let t=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s2">&quot;decorators&quot;</span><span class="s0">)){let r=</span><span class="s1">this</span><span class="s0">.state.startLoc,e;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">10</span><span class="s0">)){let s=</span><span class="s1">this</span><span class="s0">.state.startLoc;</span><span class="s1">this</span><span class="s0">.next(),e=</span><span class="s1">this</span><span class="s0">.parseExpression(),</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">11</span><span class="s0">),e=</span><span class="s1">this</span><span class="s0">.wrapParenthesis(s,e);let i=</span><span class="s1">this</span><span class="s0">.state.startLoc;t.expression=</span><span class="s1">this</span><span class="s0">.parseMaybeDecoratorArguments(e),</span><span class="s1">this</span><span class="s0">.getPluginOption(</span><span class="s2">&quot;decorators&quot;</span><span class="s0">,</span><span class="s2">&quot;allowCallParenthesized&quot;</span><span class="s0">)===!</span><span class="s3">1</span><span class="s0">&amp;&amp;t.expression!==e&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.DecoratorArgumentsOutsideParentheses,{at:i})}</span><span class="s1">else</span><span class="s0">{</span><span class="s1">for</span><span class="s0">(e=</span><span class="s1">this</span><span class="s0">.parseIdentifier(!</span><span class="s3">1</span><span class="s0">);</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">16</span><span class="s0">);){let s=</span><span class="s1">this</span><span class="s0">.startNodeAt(r);s.object=e,</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">136</span><span class="s0">)?(</span><span class="s1">this</span><span class="s0">.classScope.usePrivateName(</span><span class="s1">this</span><span class="s0">.state.value,</span><span class="s1">this</span><span class="s0">.state.startLoc),s.property=</span><span class="s1">this</span><span class="s0">.parsePrivateName()):s.property=</span><span class="s1">this</span><span class="s0">.parseIdentifier(!</span><span class="s3">0</span><span class="s0">),s.computed=!</span><span class="s3">1</span><span class="s0">,e=</span><span class="s1">this</span><span class="s0">.finishNode(s,</span><span class="s2">&quot;MemberExpression&quot;</span><span class="s0">)}t.expression=</span><span class="s1">this</span><span class="s0">.parseMaybeDecoratorArguments(e)}}</span><span class="s1">else </span><span class="s0">t.expression=</span><span class="s1">this</span><span class="s0">.parseExprSubscripts();</span><span class="s1">return this</span><span class="s0">.finishNode(t,</span><span class="s2">&quot;Decorator&quot;</span><span class="s0">)}parseMaybeDecoratorArguments(t){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">10</span><span class="s0">)){let r=</span><span class="s1">this</span><span class="s0">.startNodeAtNode(t);</span><span class="s1">return </span><span class="s0">r.callee=t,r.arguments=</span><span class="s1">this</span><span class="s0">.parseCallExpressionArguments(</span><span class="s3">11</span><span class="s0">,!</span><span class="s3">1</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.toReferencedList(r.arguments),</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s2">&quot;CallExpression&quot;</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">t}parseBreakContinueStatement(t,r){</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.isLineTerminator()?t.label=</span><span class="s1">null</span><span class="s0">:(t.label=</span><span class="s1">this</span><span class="s0">.parseIdentifier(),</span><span class="s1">this</span><span class="s0">.semicolon()),</span><span class="s1">this</span><span class="s0">.verifyBreakContinue(t,r),</span><span class="s1">this</span><span class="s0">.finishNode(t,r?</span><span class="s2">&quot;BreakStatement&quot;</span><span class="s0">:</span><span class="s2">&quot;ContinueStatement&quot;</span><span class="s0">)}verifyBreakContinue(t,r){let e;</span><span class="s1">for</span><span class="s0">(e=</span><span class="s3">0</span><span class="s0">;e&lt;</span><span class="s1">this</span><span class="s0">.state.labels.length;++e){let s=</span><span class="s1">this</span><span class="s0">.state.labels[e];</span><span class="s1">if</span><span class="s0">((t.label==</span><span class="s1">null</span><span class="s0">||s.name===t.label.name)&amp;&amp;(s.kind!=</span><span class="s1">null</span><span class="s0">&amp;&amp;(r||s.kind===</span><span class="s2">&quot;loop&quot;</span><span class="s0">)||t.label&amp;&amp;r))</span><span class="s1">break</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(e===</span><span class="s1">this</span><span class="s0">.state.labels.length){let s=r?</span><span class="s2">&quot;BreakStatement&quot;</span><span class="s0">:</span><span class="s2">&quot;ContinueStatement&quot;</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.raise(f.IllegalBreakContinue,{at:t,type:s})}}parseDebuggerStatement(t){</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s2">&quot;DebuggerStatement&quot;</span><span class="s0">)}parseHeaderExpression(){</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">10</span><span class="s0">);let t=</span><span class="s1">this</span><span class="s0">.parseExpression();</span><span class="s1">return this</span><span class="s0">.expect(</span><span class="s3">11</span><span class="s0">),t}parseDoWhileStatement(t){</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.state.labels.push(cs),t.body=</span><span class="s1">this</span><span class="s0">.withSmartMixTopicForbiddingContext(()=&gt;</span><span class="s1">this</span><span class="s0">.parseStatement()),</span><span class="s1">this</span><span class="s0">.state.labels.pop(),</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">92</span><span class="s0">),t.test=</span><span class="s1">this</span><span class="s0">.parseHeaderExpression(),</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">13</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s2">&quot;DoWhileStatement&quot;</span><span class="s0">)}parseForStatement(t){</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.state.labels.push(cs);let r=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isAwaitAllowed()&amp;&amp;</span><span class="s1">this</span><span class="s0">.eatContextual(</span><span class="s3">96</span><span class="s0">)&amp;&amp;(r=</span><span class="s1">this</span><span class="s0">.state.lastTokStartLoc),</span><span class="s1">this</span><span class="s0">.scope.enter(Fe),</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">10</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">13</span><span class="s0">))</span><span class="s1">return </span><span class="s0">r!==</span><span class="s1">null</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(r),</span><span class="s1">this</span><span class="s0">.parseFor(t,</span><span class="s1">null</span><span class="s0">);let e=</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">99</span><span class="s0">),s=</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">105</span><span class="s0">)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.hasFollowingLineBreak(),i=e&amp;&amp;</span><span class="s1">this</span><span class="s0">.hasFollowingBindingAtom()||s&amp;&amp;</span><span class="s1">this</span><span class="s0">.hasFollowingBindingIdentifier()&amp;&amp;</span><span class="s1">this</span><span class="s0">.startsUsingForOf();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">74</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">75</span><span class="s0">)||i){let c=</span><span class="s1">this</span><span class="s0">.startNode(),y=</span><span class="s1">this</span><span class="s0">.state.value;</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.parseVar(c,!</span><span class="s3">0</span><span class="s0">,y);let g=</span><span class="s1">this</span><span class="s0">.finishNode(c,</span><span class="s2">&quot;VariableDeclaration&quot;</span><span class="s0">),T=</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">58</span><span class="s0">);</span><span class="s1">return </span><span class="s0">T&amp;&amp;s&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.ForInUsing,{at:g}),(T||</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">101</span><span class="s0">))&amp;&amp;g.declarations.length===</span><span class="s3">1</span><span class="s0">?</span><span class="s1">this</span><span class="s0">.parseForIn(t,g,r):(r!==</span><span class="s1">null</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(r),</span><span class="s1">this</span><span class="s0">.parseFor(t,g))}let a=</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">95</span><span class="s0">),n=</span><span class="s1">new </span><span class="s0">vt,o=</span><span class="s1">this</span><span class="s0">.parseExpression(!</span><span class="s3">0</span><span class="s0">,n),u=</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">101</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(u&amp;&amp;(e&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.ForOfLet,{at:o}),r===</span><span class="s1">null</span><span class="s0">&amp;&amp;a&amp;&amp;o.type===</span><span class="s2">&quot;Identifier&quot;</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.ForOfAsync,{at:o})),u||</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">58</span><span class="s0">)){</span><span class="s1">this</span><span class="s0">.checkDestructuringPrivate(n),</span><span class="s1">this</span><span class="s0">.toAssignable(o,!</span><span class="s3">0</span><span class="s0">);let c=u?</span><span class="s2">&quot;ForOfStatement&quot;</span><span class="s0">:</span><span class="s2">&quot;ForInStatement&quot;</span><span class="s0">;</span><span class="s1">return this</span><span class="s0">.checkLVal(o,{</span><span class="s1">in</span><span class="s0">:{type:c}}),</span><span class="s1">this</span><span class="s0">.parseForIn(t,o,r)}</span><span class="s1">else this</span><span class="s0">.checkExpressionErrors(n,!</span><span class="s3">0</span><span class="s0">);</span><span class="s1">return </span><span class="s0">r!==</span><span class="s1">null</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(r),</span><span class="s1">this</span><span class="s0">.parseFor(t,o)}parseFunctionStatement(t,r,e){</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.parseFunction(t,</span><span class="s3">1</span><span class="s0">|(e?</span><span class="s3">2</span><span class="s0">:</span><span class="s3">0</span><span class="s0">)|(r?</span><span class="s3">8</span><span class="s0">:</span><span class="s3">0</span><span class="s0">))}parseIfStatement(t){</span><span class="s1">return this</span><span class="s0">.next(),t.test=</span><span class="s1">this</span><span class="s0">.parseHeaderExpression(),t.consequent=</span><span class="s1">this</span><span class="s0">.parseStatementOrSloppyAnnexBFunctionDeclaration(),t.alternate=</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">66</span><span class="s0">)?</span><span class="s1">this</span><span class="s0">.parseStatementOrSloppyAnnexBFunctionDeclaration():</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s2">&quot;IfStatement&quot;</span><span class="s0">)}parseReturnStatement(t){</span><span class="s1">return</span><span class="s0">!</span><span class="s1">this</span><span class="s0">.prodParam.hasReturn&amp;&amp;!</span><span class="s1">this</span><span class="s0">.options.allowReturnOutsideFunction&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.IllegalReturn,{at:</span><span class="s1">this</span><span class="s0">.state.startLoc}),</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.isLineTerminator()?t.argument=</span><span class="s1">null</span><span class="s0">:(t.argument=</span><span class="s1">this</span><span class="s0">.parseExpression(),</span><span class="s1">this</span><span class="s0">.semicolon()),</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s2">&quot;ReturnStatement&quot;</span><span class="s0">)}parseSwitchStatement(t){</span><span class="s1">this</span><span class="s0">.next(),t.discriminant=</span><span class="s1">this</span><span class="s0">.parseHeaderExpression();let r=t.cases=[];</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">5</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.state.labels.push(Ph),</span><span class="s1">this</span><span class="s0">.scope.enter(Fe);let e;</span><span class="s1">for</span><span class="s0">(let s;!</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">8</span><span class="s0">);)</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">61</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">65</span><span class="s0">)){let i=</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">61</span><span class="s0">);e&amp;&amp;</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;SwitchCase&quot;</span><span class="s0">),r.push(e=</span><span class="s1">this</span><span class="s0">.startNode()),e.consequent=[],</span><span class="s1">this</span><span class="s0">.next(),i?e.test=</span><span class="s1">this</span><span class="s0">.parseExpression():(s&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.MultipleDefaultsInSwitch,{at:</span><span class="s1">this</span><span class="s0">.state.lastTokStartLoc}),s=!</span><span class="s3">0</span><span class="s0">,e.test=</span><span class="s1">null</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">14</span><span class="s0">)}</span><span class="s1">else </span><span class="s0">e?e.consequent.push(</span><span class="s1">this</span><span class="s0">.parseStatementListItem()):</span><span class="s1">this</span><span class="s0">.unexpected();</span><span class="s1">return this</span><span class="s0">.scope.exit(),e&amp;&amp;</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;SwitchCase&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.state.labels.pop(),</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s2">&quot;SwitchStatement&quot;</span><span class="s0">)}parseThrowStatement(t){</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.hasPrecedingLineBreak()&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.NewlineAfterThrow,{at:</span><span class="s1">this</span><span class="s0">.state.lastTokEndLoc}),t.argument=</span><span class="s1">this</span><span class="s0">.parseExpression(),</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s2">&quot;ThrowStatement&quot;</span><span class="s0">)}parseCatchClauseParam(){let t=</span><span class="s1">this</span><span class="s0">.parseBindingAtom();</span><span class="s1">return this</span><span class="s0">.scope.enter(</span><span class="s1">this</span><span class="s0">.options.annexB&amp;&amp;t.type===</span><span class="s2">&quot;Identifier&quot;</span><span class="s0">?gr:</span><span class="s3">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.checkLVal(t,{</span><span class="s1">in</span><span class="s0">:{type:</span><span class="s2">&quot;CatchClause&quot;</span><span class="s0">},binding:cl}),t}parseTryStatement(t){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.next(),t.block=</span><span class="s1">this</span><span class="s0">.parseBlock(),t.handler=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">62</span><span class="s0">)){let r=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">10</span><span class="s0">)?(</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">10</span><span class="s0">),r.param=</span><span class="s1">this</span><span class="s0">.parseCatchClauseParam(),</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">11</span><span class="s0">)):(r.param=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.scope.enter(Fe)),r.body=</span><span class="s1">this</span><span class="s0">.withSmartMixTopicForbiddingContext(()=&gt;</span><span class="s1">this</span><span class="s0">.parseBlock(!</span><span class="s3">1</span><span class="s0">,!</span><span class="s3">1</span><span class="s0">)),</span><span class="s1">this</span><span class="s0">.scope.exit(),t.handler=</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s2">&quot;CatchClause&quot;</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">t.finalizer=</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">67</span><span class="s0">)?</span><span class="s1">this</span><span class="s0">.parseBlock():</span><span class="s1">null</span><span class="s0">,!t.handler&amp;&amp;!t.finalizer&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.NoCatchOrFinally,{at:t}),</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s2">&quot;TryStatement&quot;</span><span class="s0">)}parseVarStatement(t,r){let e=arguments.length&gt;</span><span class="s3">2</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">2</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">2</span><span class="s0">]:!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.parseVar(t,!</span><span class="s3">1</span><span class="s0">,r,e),</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s2">&quot;VariableDeclaration&quot;</span><span class="s0">)}parseWhileStatement(t){</span><span class="s1">return this</span><span class="s0">.next(),t.test=</span><span class="s1">this</span><span class="s0">.parseHeaderExpression(),</span><span class="s1">this</span><span class="s0">.state.labels.push(cs),t.body=</span><span class="s1">this</span><span class="s0">.withSmartMixTopicForbiddingContext(()=&gt;</span><span class="s1">this</span><span class="s0">.parseStatement()),</span><span class="s1">this</span><span class="s0">.state.labels.pop(),</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s2">&quot;WhileStatement&quot;</span><span class="s0">)}parseWithStatement(t){</span><span class="s1">return this</span><span class="s0">.state.strict&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.StrictWith,{at:</span><span class="s1">this</span><span class="s0">.state.startLoc}),</span><span class="s1">this</span><span class="s0">.next(),t.object=</span><span class="s1">this</span><span class="s0">.parseHeaderExpression(),t.body=</span><span class="s1">this</span><span class="s0">.withSmartMixTopicForbiddingContext(()=&gt;</span><span class="s1">this</span><span class="s0">.parseStatement()),</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s2">&quot;WithStatement&quot;</span><span class="s0">)}parseEmptyStatement(t){</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s2">&quot;EmptyStatement&quot;</span><span class="s0">)}parseLabeledStatement(t,r,e,s){</span><span class="s1">for</span><span class="s0">(let a of </span><span class="s1">this</span><span class="s0">.state.labels)a.name===r&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.LabelRedeclaration,{at:e,labelName:r});let i=Mo(</span><span class="s1">this</span><span class="s0">.state.type)?</span><span class="s2">&quot;loop&quot;</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">71</span><span class="s0">)?</span><span class="s2">&quot;switch&quot;</span><span class="s0">:</span><span class="s1">null</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(let a=</span><span class="s1">this</span><span class="s0">.state.labels.length-1;a&gt;=</span><span class="s3">0</span><span class="s0">;a--){let n=</span><span class="s1">this</span><span class="s0">.state.labels[a];</span><span class="s1">if</span><span class="s0">(n.statementStart===t.start)n.statementStart=</span><span class="s1">this</span><span class="s0">.state.start,n.kind=i;</span><span class="s1">else break</span><span class="s0">}</span><span class="s1">return this</span><span class="s0">.state.labels.push({name:r,kind:i,statementStart:</span><span class="s1">this</span><span class="s0">.state.start}),t.body=s&amp;</span><span class="s3">8</span><span class="s0">?</span><span class="s1">this</span><span class="s0">.parseStatementOrSloppyAnnexBFunctionDeclaration(!</span><span class="s3">0</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.parseStatement(),</span><span class="s1">this</span><span class="s0">.state.labels.pop(),t.label=e,</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s2">&quot;LabeledStatement&quot;</span><span class="s0">)}parseExpressionStatement(t,r,e){</span><span class="s1">return </span><span class="s0">t.expression=r,</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s2">&quot;ExpressionStatement&quot;</span><span class="s0">)}parseBlock(){let t=arguments.length&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">0</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">0</span><span class="s0">]:!</span><span class="s3">1</span><span class="s0">,r=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">1</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">1</span><span class="s0">]:!</span><span class="s3">0</span><span class="s0">,e=arguments.length&gt;</span><span class="s3">2</span><span class="s0">?arguments[</span><span class="s3">2</span><span class="s0">]:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,s=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">t&amp;&amp;</span><span class="s1">this</span><span class="s0">.state.strictErrors.clear(),</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">5</span><span class="s0">),r&amp;&amp;</span><span class="s1">this</span><span class="s0">.scope.enter(Fe),</span><span class="s1">this</span><span class="s0">.parseBlockBody(s,t,!</span><span class="s3">1</span><span class="s0">,</span><span class="s3">8</span><span class="s0">,e),r&amp;&amp;</span><span class="s1">this</span><span class="s0">.scope.exit(),</span><span class="s1">this</span><span class="s0">.finishNode(s,</span><span class="s2">&quot;BlockStatement&quot;</span><span class="s0">)}isValidDirective(t){</span><span class="s1">return </span><span class="s0">t.type===</span><span class="s2">&quot;ExpressionStatement&quot;</span><span class="s0">&amp;&amp;t.expression.type===</span><span class="s2">&quot;StringLiteral&quot;</span><span class="s0">&amp;&amp;!t.expression.extra.parenthesized}parseBlockBody(t,r,e,s,i){let a=t.body=[],n=t.directives=[];</span><span class="s1">this</span><span class="s0">.parseBlockOrModuleBlockBody(a,r?n:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,e,s,i)}parseBlockOrModuleBlockBody(t,r,e,s,i){let a=</span><span class="s1">this</span><span class="s0">.state.strict,n=!</span><span class="s3">1</span><span class="s0">,o=!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(;!</span><span class="s1">this</span><span class="s0">.match(s);){let u=e?</span><span class="s1">this</span><span class="s0">.parseModuleItem():</span><span class="s1">this</span><span class="s0">.parseStatementListItem();</span><span class="s1">if</span><span class="s0">(r&amp;&amp;!o){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isValidDirective(u)){let c=</span><span class="s1">this</span><span class="s0">.stmtToDirective(u);r.push(c),!n&amp;&amp;c.value.value===</span><span class="s2">&quot;use strict&quot;</span><span class="s0">&amp;&amp;(n=!</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.setStrict(!</span><span class="s3">0</span><span class="s0">));</span><span class="s1">continue</span><span class="s0">}o=!</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.state.strictErrors.clear()}t.push(u)}i&amp;&amp;i.call(</span><span class="s1">this</span><span class="s0">,n),a||</span><span class="s1">this</span><span class="s0">.setStrict(!</span><span class="s3">1</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.next()}parseFor(t,r){</span><span class="s1">return </span><span class="s0">t.init=r,</span><span class="s1">this</span><span class="s0">.semicolon(!</span><span class="s3">1</span><span class="s0">),t.test=</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">13</span><span class="s0">)?</span><span class="s1">null</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.parseExpression(),</span><span class="s1">this</span><span class="s0">.semicolon(!</span><span class="s3">1</span><span class="s0">),t.update=</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">11</span><span class="s0">)?</span><span class="s1">null</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.parseExpression(),</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">11</span><span class="s0">),t.body=</span><span class="s1">this</span><span class="s0">.withSmartMixTopicForbiddingContext(()=&gt;</span><span class="s1">this</span><span class="s0">.parseStatement()),</span><span class="s1">this</span><span class="s0">.scope.exit(),</span><span class="s1">this</span><span class="s0">.state.labels.pop(),</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s2">&quot;ForStatement&quot;</span><span class="s0">)}parseForIn(t,r,e){let s=</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">58</span><span class="s0">);</span><span class="s1">return this</span><span class="s0">.next(),s?e!==</span><span class="s1">null</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(e):t.await=e!==</span><span class="s1">null</span><span class="s0">,r.type===</span><span class="s2">&quot;VariableDeclaration&quot;</span><span class="s0">&amp;&amp;r.declarations[</span><span class="s3">0</span><span class="s0">].init!=</span><span class="s1">null</span><span class="s0">&amp;&amp;(!s||!</span><span class="s1">this</span><span class="s0">.options.annexB||</span><span class="s1">this</span><span class="s0">.state.strict||r.kind!==</span><span class="s2">&quot;var&quot;</span><span class="s0">||r.declarations[</span><span class="s3">0</span><span class="s0">].id.type!==</span><span class="s2">&quot;Identifier&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.ForInOfLoopInitializer,{at:r,type:s?</span><span class="s2">&quot;ForInStatement&quot;</span><span class="s0">:</span><span class="s2">&quot;ForOfStatement&quot;</span><span class="s0">}),r.type===</span><span class="s2">&quot;AssignmentPattern&quot;</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.InvalidLhs,{at:r,ancestor:{type:</span><span class="s2">&quot;ForStatement&quot;</span><span class="s0">}}),t.left=r,t.right=s?</span><span class="s1">this</span><span class="s0">.parseExpression():</span><span class="s1">this</span><span class="s0">.parseMaybeAssignAllowIn(),</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">11</span><span class="s0">),t.body=</span><span class="s1">this</span><span class="s0">.withSmartMixTopicForbiddingContext(()=&gt;</span><span class="s1">this</span><span class="s0">.parseStatement()),</span><span class="s1">this</span><span class="s0">.scope.exit(),</span><span class="s1">this</span><span class="s0">.state.labels.pop(),</span><span class="s1">this</span><span class="s0">.finishNode(t,s?</span><span class="s2">&quot;ForInStatement&quot;</span><span class="s0">:</span><span class="s2">&quot;ForOfStatement&quot;</span><span class="s0">)}parseVar(t,r,e){let s=arguments.length&gt;</span><span class="s3">3</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">3</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">3</span><span class="s0">]:!</span><span class="s3">1</span><span class="s0">,i=t.declarations=[];</span><span class="s1">for</span><span class="s0">(t.kind=e;;){let a=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.parseVarId(a,e),a.init=</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">29</span><span class="s0">)?r?</span><span class="s1">this</span><span class="s0">.parseMaybeAssignDisallowIn():</span><span class="s1">this</span><span class="s0">.parseMaybeAssignAllowIn():</span><span class="s1">null</span><span class="s0">,a.init===</span><span class="s1">null</span><span class="s0">&amp;&amp;!s&amp;&amp;(a.id.type!==</span><span class="s2">&quot;Identifier&quot;</span><span class="s0">&amp;&amp;!(r&amp;&amp;(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">58</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">101</span><span class="s0">)))?</span><span class="s1">this</span><span class="s0">.raise(f.DeclarationMissingInitializer,{at:</span><span class="s1">this</span><span class="s0">.state.lastTokEndLoc,kind:</span><span class="s2">&quot;destructuring&quot;</span><span class="s0">}):e===</span><span class="s2">&quot;const&quot;</span><span class="s0">&amp;&amp;!(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">58</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">101</span><span class="s0">))&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.DeclarationMissingInitializer,{at:</span><span class="s1">this</span><span class="s0">.state.lastTokEndLoc,kind:</span><span class="s2">&quot;const&quot;</span><span class="s0">})),i.push(</span><span class="s1">this</span><span class="s0">.finishNode(a,</span><span class="s2">&quot;VariableDeclarator&quot;</span><span class="s0">)),!</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">12</span><span class="s0">))</span><span class="s1">break</span><span class="s0">}</span><span class="s1">return </span><span class="s0">t}parseVarId(t,r){r===</span><span class="s2">&quot;using&quot;</span><span class="s0">&amp;&amp;!</span><span class="s1">this</span><span class="s0">.inModule&amp;&amp;</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">96</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.AwaitInUsingBinding,{at:</span><span class="s1">this</span><span class="s0">.state.startLoc});let e=</span><span class="s1">this</span><span class="s0">.parseBindingAtom();</span><span class="s1">this</span><span class="s0">.checkLVal(e,{</span><span class="s1">in</span><span class="s0">:{type:</span><span class="s2">&quot;VariableDeclarator&quot;</span><span class="s0">},binding:r===</span><span class="s2">&quot;var&quot;</span><span class="s0">?mt:Be}),t.id=e}parseAsyncFunctionExpression(t){</span><span class="s1">return this</span><span class="s0">.parseFunction(t,</span><span class="s3">8</span><span class="s0">)}parseFunction(t){let r=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">1</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">1</span><span class="s0">]:</span><span class="s3">0</span><span class="s0">,e=r&amp;</span><span class="s3">2</span><span class="s0">,s=!!(r&amp;</span><span class="s3">1</span><span class="s0">),i=s&amp;&amp;!(r&amp;</span><span class="s3">4</span><span class="s0">),a=!!(r&amp;</span><span class="s3">8</span><span class="s0">);</span><span class="s1">this</span><span class="s0">.initFunction(t,a),</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">55</span><span class="s0">)&amp;&amp;(e&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.GeneratorInSingleStatementContext,{at:</span><span class="s1">this</span><span class="s0">.state.startLoc}),</span><span class="s1">this</span><span class="s0">.next(),t.generator=!</span><span class="s3">0</span><span class="s0">),s&amp;&amp;(t.id=</span><span class="s1">this</span><span class="s0">.parseFunctionId(i));let n=</span><span class="s1">this</span><span class="s0">.state.maybeInArrowParameters;</span><span class="s1">return this</span><span class="s0">.state.maybeInArrowParameters=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.scope.enter(de),</span><span class="s1">this</span><span class="s0">.prodParam.enter(Tt(a,t.generator)),s||(t.id=</span><span class="s1">this</span><span class="s0">.parseFunctionId()),</span><span class="s1">this</span><span class="s0">.parseFunctionParams(t,!</span><span class="s3">1</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.withSmartMixTopicForbiddingContext(()=&gt;{</span><span class="s1">this</span><span class="s0">.parseFunctionBodyAndFinish(t,s?</span><span class="s2">&quot;FunctionDeclaration&quot;</span><span class="s0">:</span><span class="s2">&quot;FunctionExpression&quot;</span><span class="s0">)}),</span><span class="s1">this</span><span class="s0">.prodParam.exit(),</span><span class="s1">this</span><span class="s0">.scope.exit(),s&amp;&amp;!e&amp;&amp;</span><span class="s1">this</span><span class="s0">.registerFunctionStatementId(t),</span><span class="s1">this</span><span class="s0">.state.maybeInArrowParameters=n,t}parseFunctionId(t){</span><span class="s1">return </span><span class="s0">t||q(</span><span class="s1">this</span><span class="s0">.state.type)?</span><span class="s1">this</span><span class="s0">.parseIdentifier():</span><span class="s1">null</span><span class="s0">}parseFunctionParams(t,r){</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">10</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.expressionScope.enter(ql()),t.params=</span><span class="s1">this</span><span class="s0">.parseBindingList(</span><span class="s3">11</span><span class="s0">,</span><span class="s3">41</span><span class="s0">,</span><span class="s3">2</span><span class="s0">|(r?</span><span class="s3">4</span><span class="s0">:</span><span class="s3">0</span><span class="s0">)),</span><span class="s1">this</span><span class="s0">.expressionScope.exit()}registerFunctionStatementId(t){t.id&amp;&amp;</span><span class="s1">this</span><span class="s0">.scope.declareName(t.id.name,!</span><span class="s1">this</span><span class="s0">.options.annexB||</span><span class="s1">this</span><span class="s0">.state.strict||t.generator||t.async?</span><span class="s1">this</span><span class="s0">.scope.treatFunctionsAsVar?mt:Be:Er,t.id.loc.start)}parseClass(t,r,e){</span><span class="s1">this</span><span class="s0">.next();let s=</span><span class="s1">this</span><span class="s0">.state.strict;</span><span class="s1">return this</span><span class="s0">.state.strict=!</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.parseClassId(t,r,e),</span><span class="s1">this</span><span class="s0">.parseClassSuper(t),t.body=</span><span class="s1">this</span><span class="s0">.parseClassBody(!!t.superClass,s),</span><span class="s1">this</span><span class="s0">.finishNode(t,r?</span><span class="s2">&quot;ClassDeclaration&quot;</span><span class="s0">:</span><span class="s2">&quot;ClassExpression&quot;</span><span class="s0">)}isClassProperty(){</span><span class="s1">return this</span><span class="s0">.match(</span><span class="s3">29</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">13</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">8</span><span class="s0">)}isClassMethod(){</span><span class="s1">return this</span><span class="s0">.match(</span><span class="s3">10</span><span class="s0">)}isNonstaticConstructor(t){</span><span class="s1">return</span><span class="s0">!t.computed&amp;&amp;!t.static&amp;&amp;(t.key.name===</span><span class="s2">&quot;constructor&quot;</span><span class="s0">||t.key.value===</span><span class="s2">&quot;constructor&quot;</span><span class="s0">)}parseClassBody(t,r){</span><span class="s1">this</span><span class="s0">.classScope.enter();let e={hadConstructor:!</span><span class="s3">1</span><span class="s0">,hadSuperClass:t},s=[],i=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">if</span><span class="s0">(i.body=[],</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">5</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.withSmartMixTopicForbiddingContext(()=&gt;{</span><span class="s1">for</span><span class="s0">(;!</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">8</span><span class="s0">);){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">13</span><span class="s0">)){</span><span class="s1">if</span><span class="s0">(s.length&gt;</span><span class="s3">0</span><span class="s0">)</span><span class="s1">throw this</span><span class="s0">.raise(f.DecoratorSemicolon,{at:</span><span class="s1">this</span><span class="s0">.state.lastTokEndLoc});</span><span class="s1">continue</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">26</span><span class="s0">)){s.push(</span><span class="s1">this</span><span class="s0">.parseDecorator());</span><span class="s1">continue</span><span class="s0">}let a=</span><span class="s1">this</span><span class="s0">.startNode();s.length&amp;&amp;(a.decorators=s,</span><span class="s1">this</span><span class="s0">.resetStartLocationFromNode(a,s[</span><span class="s3">0</span><span class="s0">]),s=[]),</span><span class="s1">this</span><span class="s0">.parseClassMember(i,a,e),a.kind===</span><span class="s2">&quot;constructor&quot;</span><span class="s0">&amp;&amp;a.decorators&amp;&amp;a.decorators.length&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.DecoratorConstructor,{at:a})}}),</span><span class="s1">this</span><span class="s0">.state.strict=r,</span><span class="s1">this</span><span class="s0">.next(),s.length)</span><span class="s1">throw this</span><span class="s0">.raise(f.TrailingDecorator,{at:</span><span class="s1">this</span><span class="s0">.state.startLoc});</span><span class="s1">return this</span><span class="s0">.classScope.exit(),</span><span class="s1">this</span><span class="s0">.finishNode(i,</span><span class="s2">&quot;ClassBody&quot;</span><span class="s0">)}parseClassMemberFromModifier(t,r){let e=</span><span class="s1">this</span><span class="s0">.parseIdentifier(!</span><span class="s3">0</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isClassMethod()){let s=r;</span><span class="s1">return </span><span class="s0">s.kind=</span><span class="s2">&quot;method&quot;</span><span class="s0">,s.computed=!</span><span class="s3">1</span><span class="s0">,s.key=e,s.static=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.pushClassMethod(t,s,!</span><span class="s3">1</span><span class="s0">,!</span><span class="s3">1</span><span class="s0">,!</span><span class="s3">1</span><span class="s0">,!</span><span class="s3">1</span><span class="s0">),!</span><span class="s3">0</span><span class="s0">}</span><span class="s1">else if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isClassProperty()){let s=r;</span><span class="s1">return </span><span class="s0">s.computed=!</span><span class="s3">1</span><span class="s0">,s.key=e,s.static=!</span><span class="s3">1</span><span class="s0">,t.body.push(</span><span class="s1">this</span><span class="s0">.parseClassProperty(s)),!</span><span class="s3">0</span><span class="s0">}</span><span class="s1">return this</span><span class="s0">.resetPreviousNodeTrailingComments(e),!</span><span class="s3">1</span><span class="s0">}parseClassMember(t,r,e){let s=</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">104</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(s){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.parseClassMemberFromModifier(t,r))</span><span class="s1">return</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">5</span><span class="s0">)){</span><span class="s1">this</span><span class="s0">.parseClassStaticBlock(t,r);</span><span class="s1">return</span><span class="s0">}}</span><span class="s1">this</span><span class="s0">.parseClassMemberWithIsStatic(t,r,e,s)}parseClassMemberWithIsStatic(t,r,e,s){let i=r,a=r,n=r,o=r,u=r,c=i,y=i;</span><span class="s1">if</span><span class="s0">(r.static=s,</span><span class="s1">this</span><span class="s0">.parsePropertyNamePrefixOperator(r),</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">55</span><span class="s0">)){c.kind=</span><span class="s2">&quot;method&quot;</span><span class="s0">;let j=</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">136</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.parseClassElementName(c),j){</span><span class="s1">this</span><span class="s0">.pushClassPrivateMethod(t,a,!</span><span class="s3">0</span><span class="s0">,!</span><span class="s3">1</span><span class="s0">);</span><span class="s1">return</span><span class="s0">}</span><span class="s1">this</span><span class="s0">.isNonstaticConstructor(i)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.ConstructorIsGenerator,{at:i.key}),</span><span class="s1">this</span><span class="s0">.pushClassMethod(t,i,!</span><span class="s3">0</span><span class="s0">,!</span><span class="s3">1</span><span class="s0">,!</span><span class="s3">1</span><span class="s0">,!</span><span class="s3">1</span><span class="s0">);</span><span class="s1">return</span><span class="s0">}let g=q(</span><span class="s1">this</span><span class="s0">.state.type)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.state.containsEsc,T=</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">136</span><span class="s0">),C=</span><span class="s1">this</span><span class="s0">.parseClassElementName(r),M=</span><span class="s1">this</span><span class="s0">.state.startLoc;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.parsePostMemberNameModifiers(y),</span><span class="s1">this</span><span class="s0">.isClassMethod()){</span><span class="s1">if</span><span class="s0">(c.kind=</span><span class="s2">&quot;method&quot;</span><span class="s0">,T){</span><span class="s1">this</span><span class="s0">.pushClassPrivateMethod(t,a,!</span><span class="s3">1</span><span class="s0">,!</span><span class="s3">1</span><span class="s0">);</span><span class="s1">return</span><span class="s0">}let j=</span><span class="s1">this</span><span class="s0">.isNonstaticConstructor(i),K=!</span><span class="s3">1</span><span class="s0">;j&amp;&amp;(i.kind=</span><span class="s2">&quot;constructor&quot;</span><span class="s0">,e.hadConstructor&amp;&amp;!</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s2">&quot;typescript&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.DuplicateConstructor,{at:C}),j&amp;&amp;</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s2">&quot;typescript&quot;</span><span class="s0">)&amp;&amp;r.override&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.OverrideOnConstructor,{at:C}),e.hadConstructor=!</span><span class="s3">0</span><span class="s0">,K=e.hadSuperClass),</span><span class="s1">this</span><span class="s0">.pushClassMethod(t,i,!</span><span class="s3">1</span><span class="s0">,!</span><span class="s3">1</span><span class="s0">,j,K)}</span><span class="s1">else if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isClassProperty())T?</span><span class="s1">this</span><span class="s0">.pushClassPrivateProperty(t,o):</span><span class="s1">this</span><span class="s0">.pushClassProperty(t,n);</span><span class="s1">else if</span><span class="s0">(g&amp;&amp;C.name===</span><span class="s2">&quot;async&quot;</span><span class="s0">&amp;&amp;!</span><span class="s1">this</span><span class="s0">.isLineTerminator()){</span><span class="s1">this</span><span class="s0">.resetPreviousNodeTrailingComments(C);let j=</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">55</span><span class="s0">);y.optional&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(M),c.kind=</span><span class="s2">&quot;method&quot;</span><span class="s0">;let K=</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">136</span><span class="s0">);</span><span class="s1">this</span><span class="s0">.parseClassElementName(c),</span><span class="s1">this</span><span class="s0">.parsePostMemberNameModifiers(y),K?</span><span class="s1">this</span><span class="s0">.pushClassPrivateMethod(t,a,j,!</span><span class="s3">0</span><span class="s0">):(</span><span class="s1">this</span><span class="s0">.isNonstaticConstructor(i)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.ConstructorIsAsync,{at:i.key}),</span><span class="s1">this</span><span class="s0">.pushClassMethod(t,i,j,!</span><span class="s3">0</span><span class="s0">,!</span><span class="s3">1</span><span class="s0">,!</span><span class="s3">1</span><span class="s0">))}</span><span class="s1">else if</span><span class="s0">(g&amp;&amp;(C.name===</span><span class="s2">&quot;get&quot;</span><span class="s0">||C.name===</span><span class="s2">&quot;set&quot;</span><span class="s0">)&amp;&amp;!(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">55</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.isLineTerminator())){</span><span class="s1">this</span><span class="s0">.resetPreviousNodeTrailingComments(C),c.kind=C.name;let j=</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">136</span><span class="s0">);</span><span class="s1">this</span><span class="s0">.parseClassElementName(i),j?</span><span class="s1">this</span><span class="s0">.pushClassPrivateMethod(t,a,!</span><span class="s3">1</span><span class="s0">,!</span><span class="s3">1</span><span class="s0">):(</span><span class="s1">this</span><span class="s0">.isNonstaticConstructor(i)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.ConstructorIsAccessor,{at:i.key}),</span><span class="s1">this</span><span class="s0">.pushClassMethod(t,i,!</span><span class="s3">1</span><span class="s0">,!</span><span class="s3">1</span><span class="s0">,!</span><span class="s3">1</span><span class="s0">,!</span><span class="s3">1</span><span class="s0">)),</span><span class="s1">this</span><span class="s0">.checkGetterSetterParams(i)}</span><span class="s1">else if</span><span class="s0">(g&amp;&amp;C.name===</span><span class="s2">&quot;accessor&quot;</span><span class="s0">&amp;&amp;!</span><span class="s1">this</span><span class="s0">.isLineTerminator()){</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s2">&quot;decoratorAutoAccessors&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.resetPreviousNodeTrailingComments(C);let j=</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">136</span><span class="s0">);</span><span class="s1">this</span><span class="s0">.parseClassElementName(n),</span><span class="s1">this</span><span class="s0">.pushClassAccessorProperty(t,u,j)}</span><span class="s1">else this</span><span class="s0">.isLineTerminator()?T?</span><span class="s1">this</span><span class="s0">.pushClassPrivateProperty(t,o):</span><span class="s1">this</span><span class="s0">.pushClassProperty(t,n):</span><span class="s1">this</span><span class="s0">.unexpected()}parseClassElementName(t){let{type:r,value:e}=</span><span class="s1">this</span><span class="s0">.state;</span><span class="s1">if</span><span class="s0">((r===</span><span class="s3">130</span><span class="s0">||r===</span><span class="s3">131</span><span class="s0">)&amp;&amp;t.static&amp;&amp;e===</span><span class="s2">&quot;prototype&quot;</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.StaticPrototype,{at:</span><span class="s1">this</span><span class="s0">.state.startLoc}),r===</span><span class="s3">136</span><span class="s0">){e===</span><span class="s2">&quot;constructor&quot;</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.ConstructorClassPrivateField,{at:</span><span class="s1">this</span><span class="s0">.state.startLoc});let s=</span><span class="s1">this</span><span class="s0">.parsePrivateName();</span><span class="s1">return </span><span class="s0">t.key=s,s}</span><span class="s1">return this</span><span class="s0">.parsePropertyName(t)}parseClassStaticBlock(t,r){</span><span class="s1">var </span><span class="s0">e;</span><span class="s1">this</span><span class="s0">.scope.enter(Ee|ut|ht);let s=</span><span class="s1">this</span><span class="s0">.state.labels;</span><span class="s1">this</span><span class="s0">.state.labels=[],</span><span class="s1">this</span><span class="s0">.prodParam.enter(Me);let i=r.body=[];</span><span class="s1">this</span><span class="s0">.parseBlockOrModuleBlockBody(i,</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,!</span><span class="s3">1</span><span class="s0">,</span><span class="s3">8</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.prodParam.exit(),</span><span class="s1">this</span><span class="s0">.scope.exit(),</span><span class="s1">this</span><span class="s0">.state.labels=s,t.body.push(</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s2">&quot;StaticBlock&quot;</span><span class="s0">)),(e=r.decorators)!=</span><span class="s1">null</span><span class="s0">&amp;&amp;e.length&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.DecoratorStaticBlock,{at:r})}pushClassProperty(t,r){!r.computed&amp;&amp;(r.key.name===</span><span class="s2">&quot;constructor&quot;</span><span class="s0">||r.key.value===</span><span class="s2">&quot;constructor&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.ConstructorClassField,{at:r.key}),t.body.push(</span><span class="s1">this</span><span class="s0">.parseClassProperty(r))}pushClassPrivateProperty(t,r){let e=</span><span class="s1">this</span><span class="s0">.parseClassPrivateProperty(r);t.body.push(e),</span><span class="s1">this</span><span class="s0">.classScope.declarePrivateName(</span><span class="s1">this</span><span class="s0">.getPrivateNameSV(e.key),ss,e.key.loc.start)}pushClassAccessorProperty(t,r,e){</span><span class="s1">if</span><span class="s0">(!e&amp;&amp;!r.computed){let i=r.key;(i.name===</span><span class="s2">&quot;constructor&quot;</span><span class="s0">||i.value===</span><span class="s2">&quot;constructor&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.ConstructorClassField,{at:i})}let s=</span><span class="s1">this</span><span class="s0">.parseClassAccessorProperty(r);t.body.push(s),e&amp;&amp;</span><span class="s1">this</span><span class="s0">.classScope.declarePrivateName(</span><span class="s1">this</span><span class="s0">.getPrivateNameSV(s.key),ss,s.key.loc.start)}pushClassMethod(t,r,e,s,i,a){t.body.push(</span><span class="s1">this</span><span class="s0">.parseMethod(r,e,s,i,a,</span><span class="s2">&quot;ClassMethod&quot;</span><span class="s0">,!</span><span class="s3">0</span><span class="s0">))}pushClassPrivateMethod(t,r,e,s){let i=</span><span class="s1">this</span><span class="s0">.parseMethod(r,e,s,!</span><span class="s3">1</span><span class="s0">,!</span><span class="s3">1</span><span class="s0">,</span><span class="s2">&quot;ClassPrivateMethod&quot;</span><span class="s0">,!</span><span class="s3">0</span><span class="s0">);t.body.push(i);let a=i.kind===</span><span class="s2">&quot;get&quot;</span><span class="s0">?i.static?gl:Al:i.kind===</span><span class="s2">&quot;set&quot;</span><span class="s0">?i.static?Pl:Tl:ss;</span><span class="s1">this</span><span class="s0">.declareClassPrivateMethodInScope(i,a)}declareClassPrivateMethodInScope(t,r){</span><span class="s1">this</span><span class="s0">.classScope.declarePrivateName(</span><span class="s1">this</span><span class="s0">.getPrivateNameSV(t.key),r,t.key.loc.start)}parsePostMemberNameModifiers(t){}parseClassPrivateProperty(t){</span><span class="s1">return this</span><span class="s0">.parseInitializer(t),</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s2">&quot;ClassPrivateProperty&quot;</span><span class="s0">)}parseClassProperty(t){</span><span class="s1">return this</span><span class="s0">.parseInitializer(t),</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s2">&quot;ClassProperty&quot;</span><span class="s0">)}parseClassAccessorProperty(t){</span><span class="s1">return this</span><span class="s0">.parseInitializer(t),</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s2">&quot;ClassAccessorProperty&quot;</span><span class="s0">)}parseInitializer(t){</span><span class="s1">this</span><span class="s0">.scope.enter(Ee|ht),</span><span class="s1">this</span><span class="s0">.expressionScope.enter(_r()),</span><span class="s1">this</span><span class="s0">.prodParam.enter(Me),t.value=</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">29</span><span class="s0">)?</span><span class="s1">this</span><span class="s0">.parseMaybeAssignAllowIn():</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.expressionScope.exit(),</span><span class="s1">this</span><span class="s0">.prodParam.exit(),</span><span class="s1">this</span><span class="s0">.scope.exit()}parseClassId(t,r,e){let s=arguments.length&gt;</span><span class="s3">3</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">3</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">3</span><span class="s0">]:vr;</span><span class="s1">if</span><span class="s0">(q(</span><span class="s1">this</span><span class="s0">.state.type))t.id=</span><span class="s1">this</span><span class="s0">.parseIdentifier(),r&amp;&amp;</span><span class="s1">this</span><span class="s0">.declareNameFromIdentifier(t.id,s);</span><span class="s1">else if</span><span class="s0">(e||!r)t.id=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">else throw this</span><span class="s0">.raise(f.MissingClassName,{at:</span><span class="s1">this</span><span class="s0">.state.startLoc})}parseClassSuper(t){t.superClass=</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">81</span><span class="s0">)?</span><span class="s1">this</span><span class="s0">.parseExprSubscripts():</span><span class="s1">null</span><span class="s0">}parseExport(t,r){let e=</span><span class="s1">this</span><span class="s0">.maybeParseExportDefaultSpecifier(t),s=!e||</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">12</span><span class="s0">),i=s&amp;&amp;</span><span class="s1">this</span><span class="s0">.eatExportStar(t),a=i&amp;&amp;</span><span class="s1">this</span><span class="s0">.maybeParseExportNamespaceSpecifier(t),n=s&amp;&amp;(!a||</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">12</span><span class="s0">)),o=e||i;</span><span class="s1">if</span><span class="s0">(i&amp;&amp;!a){</span><span class="s1">if</span><span class="s0">(e&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(),r)</span><span class="s1">throw this</span><span class="s0">.raise(f.UnsupportedDecoratorExport,{at:t});</span><span class="s1">return this</span><span class="s0">.parseExportFrom(t,!</span><span class="s3">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s2">&quot;ExportAllDeclaration&quot;</span><span class="s0">)}let u=</span><span class="s1">this</span><span class="s0">.maybeParseExportNamedSpecifiers(t);e&amp;&amp;s&amp;&amp;!i&amp;&amp;!u&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(</span><span class="s1">null</span><span class="s0">,</span><span class="s3">5</span><span class="s0">),a&amp;&amp;n&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected(</span><span class="s1">null</span><span class="s0">,</span><span class="s3">97</span><span class="s0">);let c;</span><span class="s1">if</span><span class="s0">(o||u){</span><span class="s1">if</span><span class="s0">(c=!</span><span class="s3">1</span><span class="s0">,r)</span><span class="s1">throw this</span><span class="s0">.raise(f.UnsupportedDecoratorExport,{at:t});</span><span class="s1">this</span><span class="s0">.parseExportFrom(t,o)}</span><span class="s1">else </span><span class="s0">c=</span><span class="s1">this</span><span class="s0">.maybeParseExportDeclaration(t);</span><span class="s1">if</span><span class="s0">(o||u||c){</span><span class="s1">var </span><span class="s0">y;let g=t;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.checkExport(g,!</span><span class="s3">0</span><span class="s0">,!</span><span class="s3">1</span><span class="s0">,!!g.source),((y=g.declaration)==</span><span class="s1">null</span><span class="s0">?</span><span class="s1">void </span><span class="s3">0</span><span class="s0">:y.type)===</span><span class="s2">&quot;ClassDeclaration&quot;</span><span class="s0">)</span><span class="s1">this</span><span class="s0">.maybeTakeDecorators(r,g.declaration,g);</span><span class="s1">else if</span><span class="s0">(r)</span><span class="s1">throw this</span><span class="s0">.raise(f.UnsupportedDecoratorExport,{at:t});</span><span class="s1">return this</span><span class="s0">.finishNode(g,</span><span class="s2">&quot;ExportNamedDeclaration&quot;</span><span class="s0">)}</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">65</span><span class="s0">)){let g=t,T=</span><span class="s1">this</span><span class="s0">.parseExportDefaultExpression();</span><span class="s1">if</span><span class="s0">(g.declaration=T,T.type===</span><span class="s2">&quot;ClassDeclaration&quot;</span><span class="s0">)</span><span class="s1">this</span><span class="s0">.maybeTakeDecorators(r,T,g);</span><span class="s1">else if</span><span class="s0">(r)</span><span class="s1">throw this</span><span class="s0">.raise(f.UnsupportedDecoratorExport,{at:t});</span><span class="s1">return this</span><span class="s0">.checkExport(g,!</span><span class="s3">0</span><span class="s0">,!</span><span class="s3">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.finishNode(g,</span><span class="s2">&quot;ExportDefaultDeclaration&quot;</span><span class="s0">)}</span><span class="s1">this</span><span class="s0">.unexpected(</span><span class="s1">null</span><span class="s0">,</span><span class="s3">5</span><span class="s0">)}eatExportStar(t){</span><span class="s1">return this</span><span class="s0">.eat(</span><span class="s3">55</span><span class="s0">)}maybeParseExportDefaultSpecifier(t){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isExportDefaultSpecifier()){</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s2">&quot;exportDefaultFrom&quot;</span><span class="s0">);let r=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return </span><span class="s0">r.exported=</span><span class="s1">this</span><span class="s0">.parseIdentifier(!</span><span class="s3">0</span><span class="s0">),t.specifiers=[</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s2">&quot;ExportDefaultSpecifier&quot;</span><span class="s0">)],!</span><span class="s3">0</span><span class="s0">}</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">}maybeParseExportNamespaceSpecifier(t){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">93</span><span class="s0">)){t.specifiers||(t.specifiers=[]);let r=</span><span class="s1">this</span><span class="s0">.startNodeAt(</span><span class="s1">this</span><span class="s0">.state.lastTokStartLoc);</span><span class="s1">return this</span><span class="s0">.next(),r.exported=</span><span class="s1">this</span><span class="s0">.parseModuleExportName(),t.specifiers.push(</span><span class="s1">this</span><span class="s0">.finishNode(r,</span><span class="s2">&quot;ExportNamespaceSpecifier&quot;</span><span class="s0">)),!</span><span class="s3">0</span><span class="s0">}</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">}maybeParseExportNamedSpecifiers(t){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">5</span><span class="s0">)){t.specifiers||(t.specifiers=[]);let r=t.exportKind===</span><span class="s2">&quot;type&quot;</span><span class="s0">;</span><span class="s1">return </span><span class="s0">t.specifiers.push(...</span><span class="s1">this</span><span class="s0">.parseExportSpecifiers(r)),t.source=</span><span class="s1">null</span><span class="s0">,t.declaration=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s2">&quot;importAssertions&quot;</span><span class="s0">)&amp;&amp;(t.assertions=[]),!</span><span class="s3">0</span><span class="s0">}</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">}maybeParseExportDeclaration(t){</span><span class="s1">return this</span><span class="s0">.shouldParseExportDeclaration()?(t.specifiers=[],t.source=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s2">&quot;importAssertions&quot;</span><span class="s0">)&amp;&amp;(t.assertions=[]),t.declaration=</span><span class="s1">this</span><span class="s0">.parseExportDeclaration(t),!</span><span class="s3">0</span><span class="s0">):!</span><span class="s3">1</span><span class="s0">}isAsyncFunction(){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">95</span><span class="s0">))</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;let t=</span><span class="s1">this</span><span class="s0">.nextTokenStart();</span><span class="s1">return</span><span class="s0">!as.test(</span><span class="s1">this</span><span class="s0">.input.slice(</span><span class="s1">this</span><span class="s0">.state.pos,t))&amp;&amp;</span><span class="s1">this</span><span class="s0">.isUnparsedContextual(t,</span><span class="s2">&quot;function&quot;</span><span class="s0">)}parseExportDefaultExpression(){let t=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">68</span><span class="s0">))</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.parseFunction(t,</span><span class="s3">5</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isAsyncFunction())</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.parseFunction(t,</span><span class="s3">13</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">80</span><span class="s0">))</span><span class="s1">return this</span><span class="s0">.parseClass(t,!</span><span class="s3">0</span><span class="s0">,!</span><span class="s3">0</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">26</span><span class="s0">))</span><span class="s1">return this</span><span class="s0">.hasPlugin(</span><span class="s2">&quot;decorators&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.getPluginOption(</span><span class="s2">&quot;decorators&quot;</span><span class="s0">,</span><span class="s2">&quot;decoratorsBeforeExport&quot;</span><span class="s0">)===!</span><span class="s3">0</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.DecoratorBeforeExport,{at:</span><span class="s1">this</span><span class="s0">.state.startLoc}),</span><span class="s1">this</span><span class="s0">.parseClass(</span><span class="s1">this</span><span class="s0">.maybeTakeDecorators(</span><span class="s1">this</span><span class="s0">.parseDecorators(!</span><span class="s3">1</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.startNode()),!</span><span class="s3">0</span><span class="s0">,!</span><span class="s3">0</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">75</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">74</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.isLet())</span><span class="s1">throw this</span><span class="s0">.raise(f.UnsupportedDefaultExport,{at:</span><span class="s1">this</span><span class="s0">.state.startLoc});let r=</span><span class="s1">this</span><span class="s0">.parseMaybeAssignAllowIn();</span><span class="s1">return this</span><span class="s0">.semicolon(),r}parseExportDeclaration(t){</span><span class="s1">return this</span><span class="s0">.match(</span><span class="s3">80</span><span class="s0">)?</span><span class="s1">this</span><span class="s0">.parseClass(</span><span class="s1">this</span><span class="s0">.startNode(),!</span><span class="s3">0</span><span class="s0">,!</span><span class="s3">1</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.parseStatementListItem()}isExportDefaultSpecifier(){let{type:t}=</span><span class="s1">this</span><span class="s0">.state;</span><span class="s1">if</span><span class="s0">(q(t)){</span><span class="s1">if</span><span class="s0">(t===</span><span class="s3">95</span><span class="s0">&amp;&amp;!</span><span class="s1">this</span><span class="s0">.state.containsEsc||t===</span><span class="s3">99</span><span class="s0">)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">((t===</span><span class="s3">128</span><span class="s0">||t===</span><span class="s3">127</span><span class="s0">)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.state.containsEsc){let{type:s}=</span><span class="s1">this</span><span class="s0">.lookahead();</span><span class="s1">if</span><span class="s0">(q(s)&amp;&amp;s!==</span><span class="s3">97</span><span class="s0">||s===</span><span class="s3">5</span><span class="s0">)</span><span class="s1">return this</span><span class="s0">.expectOnePlugin([</span><span class="s2">&quot;flow&quot;</span><span class="s0">,</span><span class="s2">&quot;typescript&quot;</span><span class="s0">]),!</span><span class="s3">1</span><span class="s0">}}</span><span class="s1">else if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">65</span><span class="s0">))</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;let r=</span><span class="s1">this</span><span class="s0">.nextTokenStart(),e=</span><span class="s1">this</span><span class="s0">.isUnparsedContextual(r,</span><span class="s2">&quot;from&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.input.charCodeAt(r)===</span><span class="s3">44</span><span class="s0">||q(</span><span class="s1">this</span><span class="s0">.state.type)&amp;&amp;e)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">65</span><span class="s0">)&amp;&amp;e){let s=</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.nextTokenStartSince(r+</span><span class="s3">4</span><span class="s0">));</span><span class="s1">return </span><span class="s0">s===</span><span class="s3">34</span><span class="s0">||s===</span><span class="s3">39</span><span class="s0">}</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">}parseExportFrom(t,r){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eatContextual(</span><span class="s3">97</span><span class="s0">)){t.source=</span><span class="s1">this</span><span class="s0">.parseImportSource(),</span><span class="s1">this</span><span class="s0">.checkExport(t);let e=</span><span class="s1">this</span><span class="s0">.maybeParseImportAssertions();e&amp;&amp;(t.assertions=e,</span><span class="s1">this</span><span class="s0">.checkJSONModuleImport(t))}</span><span class="s1">else </span><span class="s0">r&amp;&amp;</span><span class="s1">this</span><span class="s0">.unexpected();</span><span class="s1">this</span><span class="s0">.semicolon()}shouldParseExportDeclaration(){let{type:t}=</span><span class="s1">this</span><span class="s0">.state;</span><span class="s1">return </span><span class="s0">t===</span><span class="s3">26</span><span class="s0">&amp;&amp;(</span><span class="s1">this</span><span class="s0">.expectOnePlugin([</span><span class="s2">&quot;decorators&quot;</span><span class="s0">,</span><span class="s2">&quot;decorators-legacy&quot;</span><span class="s0">]),</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s2">&quot;decorators&quot;</span><span class="s0">))?(</span><span class="s1">this</span><span class="s0">.getPluginOption(</span><span class="s2">&quot;decorators&quot;</span><span class="s0">,</span><span class="s2">&quot;decoratorsBeforeExport&quot;</span><span class="s0">)===!</span><span class="s3">0</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.DecoratorBeforeExport,{at:</span><span class="s1">this</span><span class="s0">.state.startLoc}),!</span><span class="s3">0</span><span class="s0">):t===</span><span class="s3">74</span><span class="s0">||t===</span><span class="s3">75</span><span class="s0">||t===</span><span class="s3">68</span><span class="s0">||t===</span><span class="s3">80</span><span class="s0">||</span><span class="s1">this</span><span class="s0">.isLet()||</span><span class="s1">this</span><span class="s0">.isAsyncFunction()}checkExport(t,r,e,s){</span><span class="s1">if</span><span class="s0">(r){</span><span class="s1">if</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.checkDuplicateExports(t,</span><span class="s2">&quot;default&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s2">&quot;exportDefaultFrom&quot;</span><span class="s0">)){</span><span class="s1">var </span><span class="s0">i;let a=t.declaration;a.type===</span><span class="s2">&quot;Identifier&quot;</span><span class="s0">&amp;&amp;a.name===</span><span class="s2">&quot;from&quot;</span><span class="s0">&amp;&amp;a.end-a.start===</span><span class="s3">4</span><span class="s0">&amp;&amp;!((i=a.extra)!=</span><span class="s1">null</span><span class="s0">&amp;&amp;i.parenthesized)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.ExportDefaultFromAsIdentifier,{at:a})}}</span><span class="s1">else if</span><span class="s0">(t.specifiers&amp;&amp;t.specifiers.length)</span><span class="s1">for</span><span class="s0">(let a of t.specifiers){let{exported:n}=a,o=n.type===</span><span class="s2">&quot;Identifier&quot;</span><span class="s0">?n.name:n.value;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.checkDuplicateExports(a,o),!s&amp;&amp;a.local){let{local:u}=a;u.type!==</span><span class="s2">&quot;Identifier&quot;</span><span class="s0">?</span><span class="s1">this</span><span class="s0">.raise(f.ExportBindingIsString,{at:a,localName:u.value,exportName:o}):(</span><span class="s1">this</span><span class="s0">.checkReservedWord(u.name,u.loc.start,!</span><span class="s3">0</span><span class="s0">,!</span><span class="s3">1</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.scope.checkLocalExport(u))}}</span><span class="s1">else if</span><span class="s0">(t.declaration){</span><span class="s1">if</span><span class="s0">(t.declaration.type===</span><span class="s2">&quot;FunctionDeclaration&quot;</span><span class="s0">||t.declaration.type===</span><span class="s2">&quot;ClassDeclaration&quot;</span><span class="s0">){let a=t.declaration.id;</span><span class="s1">if</span><span class="s0">(!a)</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;Assertion failure&quot;</span><span class="s0">);</span><span class="s1">this</span><span class="s0">.checkDuplicateExports(t,a.name)}</span><span class="s1">else if</span><span class="s0">(t.declaration.type===</span><span class="s2">&quot;VariableDeclaration&quot;</span><span class="s0">)</span><span class="s1">for</span><span class="s0">(let a of t.declaration.declarations)</span><span class="s1">this</span><span class="s0">.checkDeclaration(a.id)}}}checkDeclaration(t){</span><span class="s1">if</span><span class="s0">(t.type===</span><span class="s2">&quot;Identifier&quot;</span><span class="s0">)</span><span class="s1">this</span><span class="s0">.checkDuplicateExports(t,t.name);</span><span class="s1">else if</span><span class="s0">(t.type===</span><span class="s2">&quot;ObjectPattern&quot;</span><span class="s0">)</span><span class="s1">for</span><span class="s0">(let r of t.properties)</span><span class="s1">this</span><span class="s0">.checkDeclaration(r);</span><span class="s1">else if</span><span class="s0">(t.type===</span><span class="s2">&quot;ArrayPattern&quot;</span><span class="s0">)</span><span class="s1">for</span><span class="s0">(let r of t.elements)r&amp;&amp;</span><span class="s1">this</span><span class="s0">.checkDeclaration(r);</span><span class="s1">else </span><span class="s0">t.type===</span><span class="s2">&quot;ObjectProperty&quot;</span><span class="s0">?</span><span class="s1">this</span><span class="s0">.checkDeclaration(t.value):t.type===</span><span class="s2">&quot;RestElement&quot;</span><span class="s0">?</span><span class="s1">this</span><span class="s0">.checkDeclaration(t.argument):t.type===</span><span class="s2">&quot;AssignmentPattern&quot;</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.checkDeclaration(t.left)}checkDuplicateExports(t,r){</span><span class="s1">this</span><span class="s0">.exportedIdentifiers.has(r)&amp;&amp;(r===</span><span class="s2">&quot;default&quot;</span><span class="s0">?</span><span class="s1">this</span><span class="s0">.raise(f.DuplicateDefaultExport,{at:t}):</span><span class="s1">this</span><span class="s0">.raise(f.DuplicateExport,{at:t,exportName:r})),</span><span class="s1">this</span><span class="s0">.exportedIdentifiers.add(r)}parseExportSpecifiers(t){let r=[],e=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">5</span><span class="s0">);!</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">8</span><span class="s0">);){</span><span class="s1">if</span><span class="s0">(e)e=!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">else if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">12</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">8</span><span class="s0">))</span><span class="s1">break</span><span class="s0">;let s=</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">128</span><span class="s0">),i=</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">131</span><span class="s0">),a=</span><span class="s1">this</span><span class="s0">.startNode();a.local=</span><span class="s1">this</span><span class="s0">.parseModuleExportName(),r.push(</span><span class="s1">this</span><span class="s0">.parseExportSpecifier(a,i,t,s))}</span><span class="s1">return </span><span class="s0">r}parseExportSpecifier(t,r,e,s){</span><span class="s1">return this</span><span class="s0">.eatContextual(</span><span class="s3">93</span><span class="s0">)?t.exported=</span><span class="s1">this</span><span class="s0">.parseModuleExportName():r?t.exported=Kl(t.local):t.exported||(t.exported=me(t.local)),</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s2">&quot;ExportSpecifier&quot;</span><span class="s0">)}parseModuleExportName(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">131</span><span class="s0">)){let t=</span><span class="s1">this</span><span class="s0">.parseStringLiteral(</span><span class="s1">this</span><span class="s0">.state.value),r=t.value.match(Ah);</span><span class="s1">return </span><span class="s0">r&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.ModuleExportNameHasLoneSurrogate,{at:t,surrogateCharCode:r[</span><span class="s3">0</span><span class="s0">].charCodeAt(</span><span class="s3">0</span><span class="s0">)}),t}</span><span class="s1">return this</span><span class="s0">.parseIdentifier(!</span><span class="s3">0</span><span class="s0">)}isJSONModuleImport(t){</span><span class="s1">return </span><span class="s0">t.assertions!=</span><span class="s1">null</span><span class="s0">?t.assertions.some(r=&gt;{let{key:e,value:s}=r;</span><span class="s1">return </span><span class="s0">s.value===</span><span class="s2">&quot;json&quot;</span><span class="s0">&amp;&amp;(e.type===</span><span class="s2">&quot;Identifier&quot;</span><span class="s0">?e.name===</span><span class="s2">&quot;type&quot;</span><span class="s0">:e.value===</span><span class="s2">&quot;type&quot;</span><span class="s0">)}):!</span><span class="s3">1</span><span class="s0">}checkImportReflection(t){</span><span class="s1">if</span><span class="s0">(t.module){</span><span class="s1">var </span><span class="s0">r;(t.specifiers.length!==</span><span class="s3">1</span><span class="s0">||t.specifiers[</span><span class="s3">0</span><span class="s0">].type!==</span><span class="s2">&quot;ImportDefaultSpecifier&quot;</span><span class="s0">)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.ImportReflectionNotBinding,{at:t.specifiers[</span><span class="s3">0</span><span class="s0">].loc.start}),((r=t.assertions)==</span><span class="s1">null</span><span class="s0">?</span><span class="s1">void </span><span class="s3">0</span><span class="s0">:r.length)&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.ImportReflectionHasAssertion,{at:t.specifiers[</span><span class="s3">0</span><span class="s0">].loc.start})}}checkJSONModuleImport(t){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isJSONModuleImport(t)&amp;&amp;t.type!==</span><span class="s2">&quot;ExportAllDeclaration&quot;</span><span class="s0">){let{specifiers:r}=t;</span><span class="s1">if</span><span class="s0">(r!=</span><span class="s1">null</span><span class="s0">){let e=r.find(s=&gt;{let i;</span><span class="s1">if</span><span class="s0">(s.type===</span><span class="s2">&quot;ExportSpecifier&quot;</span><span class="s0">?i=s.local:s.type===</span><span class="s2">&quot;ImportSpecifier&quot;</span><span class="s0">&amp;&amp;(i=s.imported),i!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">)</span><span class="s1">return </span><span class="s0">i.type===</span><span class="s2">&quot;Identifier&quot;</span><span class="s0">?i.name!==</span><span class="s2">&quot;default&quot;</span><span class="s0">:i.value!==</span><span class="s2">&quot;default&quot;</span><span class="s0">});e!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.ImportJSONBindingNotDefault,{at:e.loc.start})}}}parseMaybeImportReflection(t){let r=!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">125</span><span class="s0">)){let e=</span><span class="s1">this</span><span class="s0">.lookahead(),s=e.type;q(s)?(s!==</span><span class="s3">97</span><span class="s0">||</span><span class="s1">this</span><span class="s0">.input.charCodeAt(</span><span class="s1">this</span><span class="s0">.nextTokenStartSince(e.end))===</span><span class="s3">102</span><span class="s0">)&amp;&amp;(r=!</span><span class="s3">0</span><span class="s0">):s!==</span><span class="s3">12</span><span class="s0">&amp;&amp;(r=!</span><span class="s3">0</span><span class="s0">)}r?(</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s2">&quot;importReflection&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.next(),t.module=!</span><span class="s3">0</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.hasPlugin(</span><span class="s2">&quot;importReflection&quot;</span><span class="s0">)&amp;&amp;(t.module=!</span><span class="s3">1</span><span class="s0">)}parseImport(t){</span><span class="s1">if</span><span class="s0">(t.specifiers=[],!</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">131</span><span class="s0">)){</span><span class="s1">this</span><span class="s0">.parseMaybeImportReflection(t);let s=!</span><span class="s1">this</span><span class="s0">.maybeParseDefaultImportSpecifier(t)||</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">12</span><span class="s0">),i=s&amp;&amp;</span><span class="s1">this</span><span class="s0">.maybeParseStarImportSpecifier(t);s&amp;&amp;!i&amp;&amp;</span><span class="s1">this</span><span class="s0">.parseNamedImportSpecifiers(t),</span><span class="s1">this</span><span class="s0">.expectContextual(</span><span class="s3">97</span><span class="s0">)}t.source=</span><span class="s1">this</span><span class="s0">.parseImportSource();let r=</span><span class="s1">this</span><span class="s0">.maybeParseImportAssertions();</span><span class="s1">if</span><span class="s0">(r)t.assertions=r;</span><span class="s1">else</span><span class="s0">{let e=</span><span class="s1">this</span><span class="s0">.maybeParseModuleAttributes();e&amp;&amp;(t.attributes=e)}</span><span class="s1">return this</span><span class="s0">.checkImportReflection(t),</span><span class="s1">this</span><span class="s0">.checkJSONModuleImport(t),</span><span class="s1">this</span><span class="s0">.semicolon(),</span><span class="s1">this</span><span class="s0">.finishNode(t,</span><span class="s2">&quot;ImportDeclaration&quot;</span><span class="s0">)}parseImportSource(){</span><span class="s1">return this</span><span class="s0">.match(</span><span class="s3">131</span><span class="s0">)||</span><span class="s1">this</span><span class="s0">.unexpected(),</span><span class="s1">this</span><span class="s0">.parseExprAtom()}shouldParseDefaultImport(t){</span><span class="s1">return </span><span class="s0">q(</span><span class="s1">this</span><span class="s0">.state.type)}parseImportSpecifierLocal(t,r,e){r.local=</span><span class="s1">this</span><span class="s0">.parseIdentifier(),t.specifiers.push(</span><span class="s1">this</span><span class="s0">.finishImportSpecifier(r,e))}finishImportSpecifier(t,r){let e=arguments.length&gt;</span><span class="s3">2</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">2</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">2</span><span class="s0">]:Be;</span><span class="s1">return this</span><span class="s0">.checkLVal(t.local,{</span><span class="s1">in</span><span class="s0">:{type:r},binding:e}),</span><span class="s1">this</span><span class="s0">.finishNode(t,r)}parseAssertEntries(){let t=[],r=</span><span class="s1">new </span><span class="s0">Set;</span><span class="s1">do</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">8</span><span class="s0">))</span><span class="s1">break</span><span class="s0">;let e=</span><span class="s1">this</span><span class="s0">.startNode(),s=</span><span class="s1">this</span><span class="s0">.state.value;</span><span class="s1">if</span><span class="s0">(r.has(s)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.ModuleAttributesWithDuplicateKeys,{at:</span><span class="s1">this</span><span class="s0">.state.startLoc,key:s}),r.add(s),</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">131</span><span class="s0">)?e.key=</span><span class="s1">this</span><span class="s0">.parseStringLiteral(s):e.key=</span><span class="s1">this</span><span class="s0">.parseIdentifier(!</span><span class="s3">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">14</span><span class="s0">),!</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">131</span><span class="s0">))</span><span class="s1">throw this</span><span class="s0">.raise(f.ModuleAttributeInvalidValue,{at:</span><span class="s1">this</span><span class="s0">.state.startLoc});e.value=</span><span class="s1">this</span><span class="s0">.parseStringLiteral(</span><span class="s1">this</span><span class="s0">.state.value),t.push(</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;ImportAttribute&quot;</span><span class="s0">))}</span><span class="s1">while</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">12</span><span class="s0">));</span><span class="s1">return </span><span class="s0">t}maybeParseModuleAttributes(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">76</span><span class="s0">)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.hasPrecedingLineBreak())</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s2">&quot;moduleAttributes&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.next();</span><span class="s1">else return this</span><span class="s0">.hasPlugin(</span><span class="s2">&quot;moduleAttributes&quot;</span><span class="s0">)?[]:</span><span class="s1">null</span><span class="s0">;let t=[],r=</span><span class="s1">new </span><span class="s0">Set;</span><span class="s1">do</span><span class="s0">{let e=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">if</span><span class="s0">(e.key=</span><span class="s1">this</span><span class="s0">.parseIdentifier(!</span><span class="s3">0</span><span class="s0">),e.key.name!==</span><span class="s2">&quot;type&quot;</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.ModuleAttributeDifferentFromType,{at:e.key}),r.has(e.key.name)&amp;&amp;</span><span class="s1">this</span><span class="s0">.raise(f.ModuleAttributesWithDuplicateKeys,{at:e.key,key:e.key.name}),r.add(e.key.name),</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">14</span><span class="s0">),!</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">131</span><span class="s0">))</span><span class="s1">throw this</span><span class="s0">.raise(f.ModuleAttributeInvalidValue,{at:</span><span class="s1">this</span><span class="s0">.state.startLoc});e.value=</span><span class="s1">this</span><span class="s0">.parseStringLiteral(</span><span class="s1">this</span><span class="s0">.state.value),</span><span class="s1">this</span><span class="s0">.finishNode(e,</span><span class="s2">&quot;ImportAttribute&quot;</span><span class="s0">),t.push(e)}</span><span class="s1">while</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">12</span><span class="s0">));</span><span class="s1">return </span><span class="s0">t}maybeParseImportAssertions(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">94</span><span class="s0">)&amp;&amp;!</span><span class="s1">this</span><span class="s0">.hasPrecedingLineBreak())</span><span class="s1">this</span><span class="s0">.expectPlugin(</span><span class="s2">&quot;importAssertions&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.next();</span><span class="s1">else return this</span><span class="s0">.hasPlugin(</span><span class="s2">&quot;importAssertions&quot;</span><span class="s0">)?[]:</span><span class="s1">null</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">5</span><span class="s0">);let t=</span><span class="s1">this</span><span class="s0">.parseAssertEntries();</span><span class="s1">return this</span><span class="s0">.eat(</span><span class="s3">8</span><span class="s0">),t}maybeParseDefaultImportSpecifier(t){</span><span class="s1">return this</span><span class="s0">.shouldParseDefaultImport(t)?(</span><span class="s1">this</span><span class="s0">.parseImportSpecifierLocal(t,</span><span class="s1">this</span><span class="s0">.startNode(),</span><span class="s2">&quot;ImportDefaultSpecifier&quot;</span><span class="s0">),!</span><span class="s3">0</span><span class="s0">):!</span><span class="s3">1</span><span class="s0">}maybeParseStarImportSpecifier(t){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">55</span><span class="s0">)){let r=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.next(),</span><span class="s1">this</span><span class="s0">.expectContextual(</span><span class="s3">93</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.parseImportSpecifierLocal(t,r,</span><span class="s2">&quot;ImportNamespaceSpecifier&quot;</span><span class="s0">),!</span><span class="s3">0</span><span class="s0">}</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">}parseNamedImportSpecifiers(t){let r=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">5</span><span class="s0">);!</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">8</span><span class="s0">);){</span><span class="s1">if</span><span class="s0">(r)r=!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">14</span><span class="s0">))</span><span class="s1">throw this</span><span class="s0">.raise(f.DestructureNamedImport,{at:</span><span class="s1">this</span><span class="s0">.state.startLoc});</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.expect(</span><span class="s3">12</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.eat(</span><span class="s3">8</span><span class="s0">))</span><span class="s1">break</span><span class="s0">}let e=</span><span class="s1">this</span><span class="s0">.startNode(),s=</span><span class="s1">this</span><span class="s0">.match(</span><span class="s3">131</span><span class="s0">),i=</span><span class="s1">this</span><span class="s0">.isContextual(</span><span class="s3">128</span><span class="s0">);e.imported=</span><span class="s1">this</span><span class="s0">.parseModuleExportName();let a=</span><span class="s1">this</span><span class="s0">.parseImportSpecifier(e,s,t.importKind===</span><span class="s2">&quot;type&quot;</span><span class="s0">||t.importKind===</span><span class="s2">&quot;typeof&quot;</span><span class="s0">,i,</span><span class="s1">void </span><span class="s3">0</span><span class="s0">);t.specifiers.push(a)}}parseImportSpecifier(t,r,e,s,i){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.eatContextual(</span><span class="s3">93</span><span class="s0">))t.local=</span><span class="s1">this</span><span class="s0">.parseIdentifier();</span><span class="s1">else</span><span class="s0">{let{imported:a}=t;</span><span class="s1">if</span><span class="s0">(r)</span><span class="s1">throw this</span><span class="s0">.raise(f.ImportBindingIsString,{at:t,importName:a.value});</span><span class="s1">this</span><span class="s0">.checkReservedWord(a.name,t.loc.start,!</span><span class="s3">0</span><span class="s0">,!</span><span class="s3">0</span><span class="s0">),t.local||(t.local=me(a))}</span><span class="s1">return this</span><span class="s0">.finishImportSpecifier(t,</span><span class="s2">&quot;ImportSpecifier&quot;</span><span class="s0">,i)}isThisParam(t){</span><span class="s1">return </span><span class="s0">t.type===</span><span class="s2">&quot;Identifier&quot;</span><span class="s0">&amp;&amp;t.name===</span><span class="s2">&quot;this&quot;</span><span class="s0">}},Yr=class extends vh{constructor(t,r){t=p(t),super(t,r),</span><span class="s1">this</span><span class="s0">.options=t,</span><span class="s1">this</span><span class="s0">.initializeScopes(),</span><span class="s1">this</span><span class="s0">.plugins=Eh(</span><span class="s1">this</span><span class="s0">.options.plugins),</span><span class="s1">this</span><span class="s0">.filename=t.sourceFilename}getScopeHandler(){</span><span class="s1">return </span><span class="s0">is}parse(){</span><span class="s1">this</span><span class="s0">.enterInitialScopes();let t=</span><span class="s1">this</span><span class="s0">.startNode(),r=</span><span class="s1">this</span><span class="s0">.startNode();</span><span class="s1">return this</span><span class="s0">.nextToken(),t.errors=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.parseTopLevel(t,r),t.errors=</span><span class="s1">this</span><span class="s0">.state.errors,t}};</span><span class="s1">function </span><span class="s0">Eh(t){let r=</span><span class="s1">new </span><span class="s0">Map;</span><span class="s1">for</span><span class="s0">(let e of t){let[s,i]=Array.isArray(e)?e:[e,{}];r.has(s)||r.set(s,i||{})}</span><span class="s1">return </span><span class="s0">r}</span><span class="s1">function </span><span class="s0">Ch(t,r){</span><span class="s1">var </span><span class="s0">e;</span><span class="s1">if</span><span class="s0">(((e=r)==</span><span class="s1">null</span><span class="s0">?</span><span class="s1">void </span><span class="s3">0</span><span class="s0">:e.sourceType)===</span><span class="s2">&quot;unambiguous&quot;</span><span class="s0">){r=Object.assign({},r);</span><span class="s1">try</span><span class="s0">{r.sourceType=</span><span class="s2">&quot;module&quot;</span><span class="s0">;let s=Xe(r,t),i=s.parse();</span><span class="s1">if</span><span class="s0">(s.sawUnambiguousESM)</span><span class="s1">return </span><span class="s0">i;</span><span class="s1">if</span><span class="s0">(s.ambiguousScriptDifferentAst)</span><span class="s1">try</span><span class="s0">{</span><span class="s1">return </span><span class="s0">r.sourceType=</span><span class="s2">&quot;script&quot;</span><span class="s0">,Xe(r,t).parse()}</span><span class="s1">catch</span><span class="s0">{}</span><span class="s1">else </span><span class="s0">i.program.sourceType=</span><span class="s2">&quot;script&quot;</span><span class="s0">;</span><span class="s1">return </span><span class="s0">i}</span><span class="s1">catch</span><span class="s0">(s){</span><span class="s1">try</span><span class="s0">{</span><span class="s1">return </span><span class="s0">r.sourceType=</span><span class="s2">&quot;script&quot;</span><span class="s0">,Xe(r,t).parse()}</span><span class="s1">catch</span><span class="s0">{}</span><span class="s1">throw </span><span class="s0">s}}</span><span class="s1">else return </span><span class="s0">Xe(r,t).parse()}</span><span class="s1">function </span><span class="s0">bh(t,r){let e=Xe(r,t);</span><span class="s1">return </span><span class="s0">e.options.strictMode&amp;&amp;(e.state.strict=!</span><span class="s3">0</span><span class="s0">),e.getExpression()}</span><span class="s1">function </span><span class="s0">Sh(t){let r={};</span><span class="s1">for</span><span class="s0">(let e of Object.keys(t))r[e]=ce(t[e]);</span><span class="s1">return </span><span class="s0">r}</span><span class="s1">var </span><span class="s0">wh=Sh(Z);</span><span class="s1">function </span><span class="s0">Xe(t,r){let e=Yr;</span><span class="s1">return </span><span class="s0">t!=</span><span class="s1">null</span><span class="s0">&amp;&amp;t.plugins&amp;&amp;(yh(t.plugins),e=Ih(t.plugins)),</span><span class="s1">new </span><span class="s0">e(t,r)}</span><span class="s1">var </span><span class="s0">Qr={};</span><span class="s1">function </span><span class="s0">Ih(t){let r=xh.filter(i=&gt;J(t,i)),e=r.join(</span><span class="s2">&quot;/&quot;</span><span class="s0">),s=Qr[e];</span><span class="s1">if</span><span class="s0">(!s){s=Yr;</span><span class="s1">for</span><span class="s0">(let i of r)s=Xr[i](s);Qr[e]=s}</span><span class="s1">return </span><span class="s0">s}l.parse=Ch,l.parseExpression=bh,l.tokTypes=wh}}),Xf=$({</span><span class="s2">&quot;src/language-js/parse/json.js&quot;</span><span class="s0">(l,h){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;U();</span><span class="s1">var </span><span class="s0">p=Io(),d=lr(),x=ko(),P=Do();</span><span class="s1">function </span><span class="s0">m(){let w=arguments.length&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">0</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">0</span><span class="s0">]:{},{allowComments:L=!</span><span class="s3">0</span><span class="s0">}=w;</span><span class="s1">return function</span><span class="s0">(_){let{parseExpression:G}=Fo(),N;</span><span class="s1">try</span><span class="s0">{N=G(_,{tokens:!</span><span class="s3">0</span><span class="s0">,ranges:!</span><span class="s3">0</span><span class="s0">})}</span><span class="s1">catch</span><span class="s0">(O){</span><span class="s1">throw </span><span class="s0">P(O)}</span><span class="s1">if</span><span class="s0">(!L&amp;&amp;p(N.comments))</span><span class="s1">throw </span><span class="s0">v(N.comments[</span><span class="s3">0</span><span class="s0">],</span><span class="s2">&quot;Comment&quot;</span><span class="s0">);</span><span class="s1">return </span><span class="s0">S(N),N}}</span><span class="s1">function </span><span class="s0">v(w,L){let[A,_]=[w.loc.start,w.loc.end].map(G=&gt;{let{line:N,column:O}=G;</span><span class="s1">return</span><span class="s0">{line:N,column:O+</span><span class="s3">1</span><span class="s0">}});</span><span class="s1">return </span><span class="s0">d(`${L} is not allowed </span><span class="s1">in </span><span class="s0">JSON.`,{start:A,end:_})}</span><span class="s1">function </span><span class="s0">S(w){</span><span class="s1">switch</span><span class="s0">(w.type){</span><span class="s1">case</span><span class="s2">&quot;ArrayExpression&quot;</span><span class="s0">:</span><span class="s1">for</span><span class="s0">(let L of w.elements)L!==</span><span class="s1">null</span><span class="s0">&amp;&amp;S(L);</span><span class="s1">return</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;ObjectExpression&quot;</span><span class="s0">:</span><span class="s1">for</span><span class="s0">(let L of w.properties)S(L);</span><span class="s1">return</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;ObjectProperty&quot;</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(w.computed)</span><span class="s1">throw </span><span class="s0">v(w.key,</span><span class="s2">&quot;Computed key&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(w.shorthand)</span><span class="s1">throw </span><span class="s0">v(w.key,</span><span class="s2">&quot;Shorthand property&quot;</span><span class="s0">);w.key.type!==</span><span class="s2">&quot;Identifier&quot;</span><span class="s0">&amp;&amp;S(w.key),S(w.value);</span><span class="s1">return</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;UnaryExpression&quot;</span><span class="s0">:{let{operator:L,argument:A}=w;</span><span class="s1">if</span><span class="s0">(L!==</span><span class="s2">&quot;+&quot;</span><span class="s0">&amp;&amp;L!==</span><span class="s2">&quot;-&quot;</span><span class="s0">)</span><span class="s1">throw </span><span class="s0">v(w,`Operator </span><span class="s2">'${w.operator}'</span><span class="s0">`);</span><span class="s1">if</span><span class="s0">(A.type===</span><span class="s2">&quot;NumericLiteral&quot;</span><span class="s0">||A.type===</span><span class="s2">&quot;Identifier&quot;</span><span class="s0">&amp;&amp;(A.name===</span><span class="s2">&quot;Infinity&quot;</span><span class="s0">||A.name===</span><span class="s2">&quot;NaN&quot;</span><span class="s0">))</span><span class="s1">return</span><span class="s0">;</span><span class="s1">throw </span><span class="s0">v(A,`Operator </span><span class="s2">'${L}' </span><span class="s0">before </span><span class="s2">'${A.type}'</span><span class="s0">`)}</span><span class="s1">case</span><span class="s2">&quot;Identifier&quot;</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(w.name!==</span><span class="s2">&quot;Infinity&quot;</span><span class="s0">&amp;&amp;w.name!==</span><span class="s2">&quot;NaN&quot;</span><span class="s0">&amp;&amp;w.name!==</span><span class="s2">&quot;undefined&quot;</span><span class="s0">)</span><span class="s1">throw </span><span class="s0">v(w,`Identifier </span><span class="s2">'${w.name}'</span><span class="s0">`);</span><span class="s1">return</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;TemplateLiteral&quot;</span><span class="s0">:</span><span class="s1">if</span><span class="s0">(p(w.expressions))</span><span class="s1">throw </span><span class="s0">v(w.expressions[</span><span class="s3">0</span><span class="s0">],</span><span class="s2">&quot;'TemplateLiteral' with expression&quot;</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(let L of w.quasis)S(L);</span><span class="s1">return</span><span class="s0">;</span><span class="s1">case</span><span class="s2">&quot;NullLiteral&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;BooleanLiteral&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;NumericLiteral&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;StringLiteral&quot;</span><span class="s0">:</span><span class="s1">case</span><span class="s2">&quot;TemplateElement&quot;</span><span class="s0">:</span><span class="s1">return</span><span class="s0">;</span><span class="s1">default</span><span class="s0">:</span><span class="s1">throw </span><span class="s0">v(w,`</span><span class="s2">'${w.type}'</span><span class="s0">`)}}</span><span class="s1">var </span><span class="s0">k=m(),F={json:x({parse:k,hasPragma(){</span><span class="s1">return</span><span class="s0">!</span><span class="s3">0</span><span class="s0">}}),json5:x(k),</span><span class="s2">&quot;json-stringify&quot;</span><span class="s0">:x({parse:m({allowComments:!</span><span class="s3">1</span><span class="s0">}),astFormat:</span><span class="s2">&quot;estree-json&quot;</span><span class="s0">})};h.exports=F}});U();</span><span class="s1">var </span><span class="s0">Yf=kf(),Qf=po(),Zf=Of(),Ue=ko(),ed=Do(),td=Jf(),sd=Xf(),rd={sourceType:</span><span class="s2">&quot;module&quot;</span><span class="s0">,allowImportExportEverywhere:!</span><span class="s3">0</span><span class="s0">,allowReturnOutsideFunction:!</span><span class="s3">0</span><span class="s0">,allowSuperOutsideMethod:!</span><span class="s3">0</span><span class="s0">,allowUndeclaredExports:!</span><span class="s3">0</span><span class="s0">,errorRecovery:!</span><span class="s3">0</span><span class="s0">,createParenthesizedExpressions:!</span><span class="s3">0</span><span class="s0">,plugins:[</span><span class="s2">&quot;doExpressions&quot;</span><span class="s0">,</span><span class="s2">&quot;exportDefaultFrom&quot;</span><span class="s0">,</span><span class="s2">&quot;functionBind&quot;</span><span class="s0">,</span><span class="s2">&quot;functionSent&quot;</span><span class="s0">,</span><span class="s2">&quot;throwExpressions&quot;</span><span class="s0">,</span><span class="s2">&quot;partialApplication&quot;</span><span class="s0">,[</span><span class="s2">&quot;decorators&quot;</span><span class="s0">,{decoratorsBeforeExport:!</span><span class="s3">1</span><span class="s0">}],</span><span class="s2">&quot;importAssertions&quot;</span><span class="s0">,</span><span class="s2">&quot;decimal&quot;</span><span class="s0">,</span><span class="s2">&quot;moduleBlocks&quot;</span><span class="s0">,</span><span class="s2">&quot;asyncDoExpressions&quot;</span><span class="s0">,</span><span class="s2">&quot;regexpUnicodeSets&quot;</span><span class="s0">,</span><span class="s2">&quot;destructuringPrivate&quot;</span><span class="s0">,</span><span class="s2">&quot;decoratorAutoAccessors&quot;</span><span class="s0">],tokens:!</span><span class="s3">0</span><span class="s0">,ranges:!</span><span class="s3">0</span><span class="s0">},id=[</span><span class="s2">&quot;recordAndTuple&quot;</span><span class="s0">,{syntaxType:</span><span class="s2">&quot;hash&quot;</span><span class="s0">}],no=</span><span class="s2">&quot;v8intrinsic&quot;</span><span class="s0">,oo=[[</span><span class="s2">&quot;pipelineOperator&quot;</span><span class="s0">,{proposal:</span><span class="s2">&quot;hack&quot;</span><span class="s0">,topicToken:</span><span class="s2">&quot;%&quot;</span><span class="s0">}],[</span><span class="s2">&quot;pipelineOperator&quot;</span><span class="s0">,{proposal:</span><span class="s2">&quot;minimal&quot;</span><span class="s0">}],[</span><span class="s2">&quot;pipelineOperator&quot;</span><span class="s0">,{proposal:</span><span class="s2">&quot;fsharp&quot;</span><span class="s0">}]],he=</span><span class="s1">function</span><span class="s0">(l){let h=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">1</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">1</span><span class="s0">]:rd;</span><span class="s1">return </span><span class="s0">Object.assign(Object.assign({},h),{},{plugins:[...h.plugins,...l]})},ad=/@(?:no)?flow\b/;</span><span class="s1">function </span><span class="s0">nd(l,h){</span><span class="s1">if</span><span class="s0">(h.filepath&amp;&amp;h.filepath.endsWith(</span><span class="s2">&quot;.js.flow&quot;</span><span class="s0">))</span><span class="s1">return</span><span class="s0">!</span><span class="s3">0</span><span class="s0">;let p=Qf(l);p&amp;&amp;(l=l.slice(p.length));let d=Zf(l,</span><span class="s3">0</span><span class="s0">);</span><span class="s1">return </span><span class="s0">d!==!</span><span class="s3">1</span><span class="s0">&amp;&amp;(l=l.slice(</span><span class="s3">0</span><span class="s0">,d)),ad.test(l)}</span><span class="s1">function </span><span class="s0">od(l,h,p){let d=Fo()[l],x=d(h,p),P=x.errors.find(m=&gt;!fd.has(m.reasonCode));</span><span class="s1">if</span><span class="s0">(P)</span><span class="s1">throw </span><span class="s0">P;</span><span class="s1">return </span><span class="s0">x}</span><span class="s1">function </span><span class="s0">$e(l){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">h=arguments.length,p=</span><span class="s1">new </span><span class="s0">Array(h&gt;</span><span class="s3">1</span><span class="s0">?h-1:</span><span class="s3">0</span><span class="s0">),d=</span><span class="s3">1</span><span class="s0">;d&lt;h;d++)p[d-1]=arguments[d];</span><span class="s1">return function</span><span class="s0">(x,P){let m=arguments.length&gt;</span><span class="s3">2</span><span class="s0">&amp;&amp;arguments[</span><span class="s3">2</span><span class="s0">]!==</span><span class="s1">void </span><span class="s3">0</span><span class="s0">?arguments[</span><span class="s3">2</span><span class="s0">]:{};</span><span class="s1">if</span><span class="s0">((m.parser===</span><span class="s2">&quot;babel&quot;</span><span class="s0">||m.parser===</span><span class="s2">&quot;__babel_estree&quot;</span><span class="s0">)&amp;&amp;nd(x,m))</span><span class="s1">return </span><span class="s0">m.parser=</span><span class="s2">&quot;babel-flow&quot;</span><span class="s0">,Lo(x,P,m);let v=p;m.__babelSourceType===</span><span class="s2">&quot;script&quot;</span><span class="s0">&amp;&amp;(v=v.map(w=&gt;Object.assign(Object.assign({},w),{},{sourceType:</span><span class="s2">&quot;script&quot;</span><span class="s0">}))),/#[[{]/.test(x)&amp;&amp;(v=v.map(w=&gt;he([id],w)));let S=/%[A-Z]/.test(x);x.includes(</span><span class="s2">&quot;|&gt;&quot;</span><span class="s0">)?v=(S?[...oo,no]:oo).flatMap(L=&gt;v.map(A=&gt;he([L],A))):S&amp;&amp;(v=v.map(w=&gt;he([no],w)));let{result:k,error:F}=Yf(...v.map(w=&gt;()=&gt;od(l,x,w)));</span><span class="s1">if</span><span class="s0">(!k)</span><span class="s1">throw </span><span class="s0">ed(F);</span><span class="s1">return </span><span class="s0">m.originalText=x,td(k,m)}}</span><span class="s1">var </span><span class="s0">ld=$e(</span><span class="s2">&quot;parse&quot;</span><span class="s0">,he([</span><span class="s2">&quot;jsx&quot;</span><span class="s0">,</span><span class="s2">&quot;flow&quot;</span><span class="s0">])),Lo=$e(</span><span class="s2">&quot;parse&quot;</span><span class="s0">,he([</span><span class="s2">&quot;jsx&quot;</span><span class="s0">,[</span><span class="s2">&quot;flow&quot;</span><span class="s0">,{all:!</span><span class="s3">0</span><span class="s0">,enums:!</span><span class="s3">0</span><span class="s0">}]])),hd=$e(</span><span class="s2">&quot;parse&quot;</span><span class="s0">,he([</span><span class="s2">&quot;jsx&quot;</span><span class="s0">,</span><span class="s2">&quot;typescript&quot;</span><span class="s0">]),he([</span><span class="s2">&quot;typescript&quot;</span><span class="s0">])),ud=$e(</span><span class="s2">&quot;parse&quot;</span><span class="s0">,he([</span><span class="s2">&quot;jsx&quot;</span><span class="s0">,</span><span class="s2">&quot;flow&quot;</span><span class="s0">,</span><span class="s2">&quot;estree&quot;</span><span class="s0">])),cd=$e(</span><span class="s2">&quot;parseExpression&quot;</span><span class="s0">,he([</span><span class="s2">&quot;jsx&quot;</span><span class="s0">])),pd=$e(</span><span class="s2">&quot;parseExpression&quot;</span><span class="s0">,he([</span><span class="s2">&quot;typescript&quot;</span><span class="s0">])),fd=</span><span class="s1">new </span><span class="s0">Set([</span><span class="s2">&quot;StrictNumericEscape&quot;</span><span class="s0">,</span><span class="s2">&quot;StrictWith&quot;</span><span class="s0">,</span><span class="s2">&quot;StrictOctalLiteral&quot;</span><span class="s0">,</span><span class="s2">&quot;StrictDelete&quot;</span><span class="s0">,</span><span class="s2">&quot;StrictEvalArguments&quot;</span><span class="s0">,</span><span class="s2">&quot;StrictEvalArgumentsBinding&quot;</span><span class="s0">,</span><span class="s2">&quot;StrictFunction&quot;</span><span class="s0">,</span><span class="s2">&quot;EmptyTypeArguments&quot;</span><span class="s0">,</span><span class="s2">&quot;EmptyTypeParameters&quot;</span><span class="s0">,</span><span class="s2">&quot;ConstructorHasTypeParameters&quot;</span><span class="s0">,</span><span class="s2">&quot;UnsupportedParameterPropertyKind&quot;</span><span class="s0">,</span><span class="s2">&quot;UnexpectedParameterModifier&quot;</span><span class="s0">,</span><span class="s2">&quot;MixedLabeledAndUnlabeledElements&quot;</span><span class="s0">,</span><span class="s2">&quot;InvalidTupleMemberLabel&quot;</span><span class="s0">,</span><span class="s2">&quot;NonClassMethodPropertyHasAbstractModifer&quot;</span><span class="s0">,</span><span class="s2">&quot;ReadonlyForMethodSignature&quot;</span><span class="s0">,</span><span class="s2">&quot;ClassMethodHasDeclare&quot;</span><span class="s0">,</span><span class="s2">&quot;ClassMethodHasReadonly&quot;</span><span class="s0">,</span><span class="s2">&quot;InvalidModifierOnTypeMember&quot;</span><span class="s0">,</span><span class="s2">&quot;DuplicateAccessibilityModifier&quot;</span><span class="s0">,</span><span class="s2">&quot;IndexSignatureHasDeclare&quot;</span><span class="s0">,</span><span class="s2">&quot;DecoratorExportClass&quot;</span><span class="s0">,</span><span class="s2">&quot;ParamDupe&quot;</span><span class="s0">,</span><span class="s2">&quot;InvalidDecimal&quot;</span><span class="s0">,</span><span class="s2">&quot;RestTrailingComma&quot;</span><span class="s0">,</span><span class="s2">&quot;UnsupportedParameterDecorator&quot;</span><span class="s0">,</span><span class="s2">&quot;UnterminatedJsxContent&quot;</span><span class="s0">,</span><span class="s2">&quot;UnexpectedReservedWord&quot;</span><span class="s0">,</span><span class="s2">&quot;ModuleAttributesWithDuplicateKeys&quot;</span><span class="s0">,</span><span class="s2">&quot;LineTerminatorBeforeArrow&quot;</span><span class="s0">,</span><span class="s2">&quot;InvalidEscapeSequenceTemplate&quot;</span><span class="s0">,</span><span class="s2">&quot;NonAbstractClassHasAbstractMethod&quot;</span><span class="s0">,</span><span class="s2">&quot;UnsupportedPropertyDecorator&quot;</span><span class="s0">,</span><span class="s2">&quot;OptionalTypeBeforeRequired&quot;</span><span class="s0">,</span><span class="s2">&quot;PatternIsOptional&quot;</span><span class="s0">,</span><span class="s2">&quot;OptionalBindingPattern&quot;</span><span class="s0">,</span><span class="s2">&quot;DeclareClassFieldHasInitializer&quot;</span><span class="s0">,</span><span class="s2">&quot;TypeImportCannotSpecifyDefaultAndNamed&quot;</span><span class="s0">,</span><span class="s2">&quot;DeclareFunctionHasImplementation&quot;</span><span class="s0">,</span><span class="s2">&quot;ConstructorClassField&quot;</span><span class="s0">,</span><span class="s2">&quot;VarRedeclaration&quot;</span><span class="s0">,</span><span class="s2">&quot;InvalidPrivateFieldResolution&quot;</span><span class="s0">,</span><span class="s2">&quot;DuplicateExport&quot;</span><span class="s0">]),lo=Ue(ld),ho=Ue(hd),uo=Ue(cd),dd=Ue(pd);Oo.exports={parsers:Object.assign(Object.assign({babel:lo,</span><span class="s2">&quot;babel-flow&quot;</span><span class="s0">:Ue(Lo),</span><span class="s2">&quot;babel-ts&quot;</span><span class="s0">:ho},sd),{},{__js_expression:uo,__vue_expression:uo,__vue_ts_expression:dd,__vue_event_binding:lo,__vue_ts_event_binding:ho,__babel_estree:Ue(ud)})}});</span><span class="s1">return </span><span class="s0">md();});</span></pre>
</body>
</html>
<html>
<head>
<title>NetworkingModule.java</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #629755; font-weight: bold; font-style: italic;}
.s5 { color: #6a8759;}
.s6 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
NetworkingModule.java</font>
</center></td></tr></table>
<pre><span class="s0">/* 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>

<span class="s2">package </span><span class="s1">com.facebook.react.modules.network</span><span class="s2">;</span>

<span class="s2">import </span><span class="s1">android.net.Uri</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.os.Bundle</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.util.Base64</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">androidx.annotation.Nullable</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.common.logging.FLog</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.fbreact.specs.NativeNetworkingAndroidSpec</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.Arguments</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.GuardedAsyncTask</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.ReactApplicationContext</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.ReactMethod</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.ReadableArray</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.ReadableMap</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.WritableMap</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.common.StandardCharsets</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.common.network.OkHttpCallUtil</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.module.annotations.ReactModule</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.io.IOException</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.io.InputStream</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.nio.charset.Charset</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.ArrayList</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.HashSet</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.List</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.Locale</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.Set</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.concurrent.TimeUnit</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">okhttp3.Call</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">okhttp3.Callback</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">okhttp3.CookieJar</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">okhttp3.Headers</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">okhttp3.Interceptor</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">okhttp3.JavaNetCookieJar</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">okhttp3.MediaType</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">okhttp3.MultipartBody</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">okhttp3.OkHttpClient</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">okhttp3.Request</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">okhttp3.RequestBody</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">okhttp3.Response</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">okhttp3.ResponseBody</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">okio.ByteString</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">okio.GzipSource</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">okio.Okio</span><span class="s2">;</span>

<span class="s3">/** Implements the XMLHttpRequest JavaScript interface. */</span>
<span class="s1">@ReactModule(name = NativeNetworkingAndroidSpec.NAME)</span>
<span class="s2">public final class </span><span class="s1">NetworkingModule </span><span class="s2">extends </span><span class="s1">NativeNetworkingAndroidSpec {</span>

  <span class="s3">/**</span>
   <span class="s3">* Allows to implement a custom fetching process for specific URIs. It is the handler's job to</span>
   <span class="s3">* fetch the URI and return the JS body payload.</span>
   <span class="s3">*/</span>
  <span class="s2">public interface </span><span class="s1">UriHandler {</span>
    <span class="s3">/** Returns if the handler should be used for an URI. */</span>
    <span class="s2">boolean </span><span class="s1">supports(Uri uri</span><span class="s2">, </span><span class="s1">String responseType)</span><span class="s2">;</span>

    <span class="s3">/** Fetch the URI and return the JS body payload. */</span>
    <span class="s1">WritableMap fetch(Uri uri) </span><span class="s2">throws </span><span class="s1">IOException</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/** Allows adding custom handling to build the {</span><span class="s4">@link </span><span class="s3">RequestBody} from the JS body payload. */</span>
  <span class="s2">public interface </span><span class="s1">RequestBodyHandler {</span>
    <span class="s3">/** Returns if the handler should be used for a JS body payload. */</span>
    <span class="s2">boolean </span><span class="s1">supports(ReadableMap map)</span><span class="s2">;</span>

    <span class="s3">/** Returns the {</span><span class="s4">@link </span><span class="s3">RequestBody} for the JS body payload. */</span>
    <span class="s1">RequestBody toRequestBody(ReadableMap map</span><span class="s2">, </span><span class="s1">String contentType)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/** Allows adding custom handling to build the JS body payload from the {</span><span class="s4">@link </span><span class="s3">ResponseBody}. */</span>
  <span class="s2">public interface </span><span class="s1">ResponseHandler {</span>
    <span class="s3">/** Returns if the handler should be used for a response type. */</span>
    <span class="s2">boolean </span><span class="s1">supports(String responseType)</span><span class="s2">;</span>

    <span class="s3">/** Returns the JS body payload for the {</span><span class="s4">@link </span><span class="s3">ResponseBody}. */</span>
    <span class="s1">WritableMap toResponseData(ResponseBody body) </span><span class="s2">throws </span><span class="s1">IOException</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private static final </span><span class="s1">String TAG = NativeNetworkingAndroidSpec.NAME</span><span class="s2">;</span>
  <span class="s2">private static final </span><span class="s1">String CONTENT_ENCODING_HEADER_NAME = </span><span class="s5">&quot;content-encoding&quot;</span><span class="s2">;</span>
  <span class="s2">private static final </span><span class="s1">String CONTENT_TYPE_HEADER_NAME = </span><span class="s5">&quot;content-type&quot;</span><span class="s2">;</span>
  <span class="s2">private static final </span><span class="s1">String REQUEST_BODY_KEY_STRING = </span><span class="s5">&quot;string&quot;</span><span class="s2">;</span>
  <span class="s2">private static final </span><span class="s1">String REQUEST_BODY_KEY_URI = </span><span class="s5">&quot;uri&quot;</span><span class="s2">;</span>
  <span class="s2">private static final </span><span class="s1">String REQUEST_BODY_KEY_FORMDATA = </span><span class="s5">&quot;formData&quot;</span><span class="s2">;</span>
  <span class="s2">private static final </span><span class="s1">String REQUEST_BODY_KEY_BASE64 = </span><span class="s5">&quot;base64&quot;</span><span class="s2">;</span>
  <span class="s2">private static final </span><span class="s1">String USER_AGENT_HEADER_NAME = </span><span class="s5">&quot;user-agent&quot;</span><span class="s2">;</span>
  <span class="s2">private static final int </span><span class="s1">CHUNK_TIMEOUT_NS = </span><span class="s6">100 </span><span class="s1">* </span><span class="s6">1000000</span><span class="s2">; </span><span class="s0">// 100ms</span>
  <span class="s2">private static final int </span><span class="s1">MAX_CHUNK_SIZE_BETWEEN_FLUSHES = </span><span class="s6">8 </span><span class="s1">* </span><span class="s6">1024</span><span class="s2">; </span><span class="s0">// 8K</span>

  <span class="s2">private static </span><span class="s1">@Nullable CustomClientBuilder customClientBuilder = </span><span class="s2">null;</span>

  <span class="s2">private final </span><span class="s1">OkHttpClient mClient</span><span class="s2">;</span>
  <span class="s2">private final </span><span class="s1">ForwardingCookieHandler mCookieHandler</span><span class="s2">;</span>
  <span class="s2">private final </span><span class="s1">@Nullable String mDefaultUserAgent</span><span class="s2">;</span>
  <span class="s2">private final </span><span class="s1">CookieJarContainer mCookieJarContainer</span><span class="s2">;</span>
  <span class="s2">private final </span><span class="s1">Set&lt;Integer&gt; mRequestIds</span><span class="s2">;</span>
  <span class="s2">private final </span><span class="s1">List&lt;RequestBodyHandler&gt; mRequestBodyHandlers = </span><span class="s2">new </span><span class="s1">ArrayList&lt;&gt;()</span><span class="s2">;</span>
  <span class="s2">private final </span><span class="s1">List&lt;UriHandler&gt; mUriHandlers = </span><span class="s2">new </span><span class="s1">ArrayList&lt;&gt;()</span><span class="s2">;</span>
  <span class="s2">private final </span><span class="s1">List&lt;ResponseHandler&gt; mResponseHandlers = </span><span class="s2">new </span><span class="s1">ArrayList&lt;&gt;()</span><span class="s2">;</span>
  <span class="s2">private boolean </span><span class="s1">mShuttingDown</span><span class="s2">;</span>

  <span class="s2">public </span><span class="s1">NetworkingModule(</span>
      <span class="s1">ReactApplicationContext reactContext</span><span class="s2">,</span>
      <span class="s1">@Nullable String defaultUserAgent</span><span class="s2">,</span>
      <span class="s1">OkHttpClient client</span><span class="s2">,</span>
      <span class="s1">@Nullable List&lt;NetworkInterceptorCreator&gt; networkInterceptorCreators) {</span>
    <span class="s2">super</span><span class="s1">(reactContext)</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(networkInterceptorCreators != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">OkHttpClient.Builder clientBuilder = client.newBuilder()</span><span class="s2">;</span>
      <span class="s2">for </span><span class="s1">(NetworkInterceptorCreator networkInterceptorCreator : networkInterceptorCreators) {</span>
        <span class="s1">clientBuilder.addNetworkInterceptor(networkInterceptorCreator.create())</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s1">client = clientBuilder.build()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">mClient = client</span><span class="s2">;</span>
    <span class="s1">mCookieHandler = </span><span class="s2">new </span><span class="s1">ForwardingCookieHandler(reactContext)</span><span class="s2">;</span>
    <span class="s1">mCookieJarContainer = (CookieJarContainer) mClient.cookieJar()</span><span class="s2">;</span>
    <span class="s1">mShuttingDown = </span><span class="s2">false;</span>
    <span class="s1">mDefaultUserAgent = defaultUserAgent</span><span class="s2">;</span>
    <span class="s1">mRequestIds = </span><span class="s2">new </span><span class="s1">HashSet&lt;&gt;()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">context the ReactContext of the application</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">defaultUserAgent the User-Agent header that will be set for all requests where the</span>
   <span class="s3">*     caller does not provide one explicitly</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">client the {</span><span class="s4">@link </span><span class="s3">OkHttpClient} to be used for networking</span>
   <span class="s3">*/</span>
  <span class="s0">/* package */ </span><span class="s1">NetworkingModule(</span>
      <span class="s1">ReactApplicationContext context</span><span class="s2">, </span><span class="s1">@Nullable String defaultUserAgent</span><span class="s2">, </span><span class="s1">OkHttpClient client) {</span>
    <span class="s2">this</span><span class="s1">(context</span><span class="s2">, </span><span class="s1">defaultUserAgent</span><span class="s2">, </span><span class="s1">client</span><span class="s2">, null</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/** </span><span class="s4">@param </span><span class="s3">context the ReactContext of the application */</span>
  <span class="s2">public </span><span class="s1">NetworkingModule(</span><span class="s2">final </span><span class="s1">ReactApplicationContext context) {</span>
    <span class="s2">this</span><span class="s1">(context</span><span class="s2">, null, </span><span class="s1">OkHttpClientProvider.createClient(context)</span><span class="s2">, null</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">context the ReactContext of the application</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">networkInterceptorCreators list of {</span><span class="s4">@link </span><span class="s3">NetworkInterceptorCreator}'s whose create()</span>
   <span class="s3">*     methods would be called to attach the interceptors to the client.</span>
   <span class="s3">*/</span>
  <span class="s2">public </span><span class="s1">NetworkingModule(</span>
      <span class="s1">ReactApplicationContext context</span><span class="s2">, </span><span class="s1">List&lt;NetworkInterceptorCreator&gt; networkInterceptorCreators) {</span>
    <span class="s2">this</span><span class="s1">(context</span><span class="s2">, null, </span><span class="s1">OkHttpClientProvider.createClient(context)</span><span class="s2">, </span><span class="s1">networkInterceptorCreators)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">context the ReactContext of the application</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">defaultUserAgent the User-Agent header that will be set for all requests where the</span>
   <span class="s3">*     caller does not provide one explicitly</span>
   <span class="s3">*/</span>
  <span class="s2">public </span><span class="s1">NetworkingModule(ReactApplicationContext context</span><span class="s2">, </span><span class="s1">String defaultUserAgent) {</span>
    <span class="s2">this</span><span class="s1">(context</span><span class="s2">, </span><span class="s1">defaultUserAgent</span><span class="s2">, </span><span class="s1">OkHttpClientProvider.createClient(context)</span><span class="s2">, null</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public static void </span><span class="s1">setCustomClientBuilder(CustomClientBuilder ccb) {</span>
    <span class="s1">customClientBuilder = ccb</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public static interface </span><span class="s1">CustomClientBuilder {</span>
    <span class="s2">public void </span><span class="s1">apply(OkHttpClient.Builder builder)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private static void </span><span class="s1">applyCustomBuilder(OkHttpClient.Builder builder) {</span>
    <span class="s2">if </span><span class="s1">(customClientBuilder != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">customClientBuilder.apply(builder)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">initialize() {</span>
    <span class="s1">mCookieJarContainer.setCookieJar(</span><span class="s2">new </span><span class="s1">JavaNetCookieJar(mCookieHandler))</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">invalidate() {</span>
    <span class="s1">mShuttingDown = </span><span class="s2">true;</span>
    <span class="s1">cancelAllRequests()</span><span class="s2">;</span>

    <span class="s1">mCookieHandler.destroy()</span><span class="s2">;</span>
    <span class="s1">mCookieJarContainer.removeCookieJar()</span><span class="s2">;</span>

    <span class="s1">mRequestBodyHandlers.clear()</span><span class="s2">;</span>
    <span class="s1">mResponseHandlers.clear()</span><span class="s2">;</span>
    <span class="s1">mUriHandlers.clear()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">addUriHandler(UriHandler handler) {</span>
    <span class="s1">mUriHandlers.add(handler)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">addRequestBodyHandler(RequestBodyHandler handler) {</span>
    <span class="s1">mRequestBodyHandlers.add(handler)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">addResponseHandler(ResponseHandler handler) {</span>
    <span class="s1">mResponseHandlers.add(handler)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">removeUriHandler(UriHandler handler) {</span>
    <span class="s1">mUriHandlers.remove(handler)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">removeRequestBodyHandler(RequestBodyHandler handler) {</span>
    <span class="s1">mRequestBodyHandlers.remove(handler)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">removeResponseHandler(ResponseHandler handler) {</span>
    <span class="s1">mResponseHandlers.remove(handler)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">sendRequest(</span>
      <span class="s1">String method</span><span class="s2">,</span>
      <span class="s1">String url</span><span class="s2">,</span>
      <span class="s2">double </span><span class="s1">requestIdAsDouble</span><span class="s2">,</span>
      <span class="s1">ReadableArray headers</span><span class="s2">,</span>
      <span class="s1">ReadableMap data</span><span class="s2">,</span>
      <span class="s1">String responseType</span><span class="s2">,</span>
      <span class="s2">boolean </span><span class="s1">useIncrementalUpdates</span><span class="s2">,</span>
      <span class="s2">double </span><span class="s1">timeoutAsDouble</span><span class="s2">,</span>
      <span class="s2">boolean </span><span class="s1">withCredentials) {</span>
    <span class="s2">int </span><span class="s1">requestId = (</span><span class="s2">int</span><span class="s1">) requestIdAsDouble</span><span class="s2">;</span>
    <span class="s2">int </span><span class="s1">timeout = (</span><span class="s2">int</span><span class="s1">) timeoutAsDouble</span><span class="s2">;</span>
    <span class="s2">try </span><span class="s1">{</span>
      <span class="s1">sendRequestInternal(</span>
          <span class="s1">method</span><span class="s2">,</span>
          <span class="s1">url</span><span class="s2">,</span>
          <span class="s1">requestId</span><span class="s2">,</span>
          <span class="s1">headers</span><span class="s2">,</span>
          <span class="s1">data</span><span class="s2">,</span>
          <span class="s1">responseType</span><span class="s2">,</span>
          <span class="s1">useIncrementalUpdates</span><span class="s2">,</span>
          <span class="s1">timeout</span><span class="s2">,</span>
          <span class="s1">withCredentials)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(Throwable th) {</span>
      <span class="s1">FLog.e(TAG</span><span class="s2">, </span><span class="s5">&quot;Failed to send url request: &quot; </span><span class="s1">+ url</span><span class="s2">, </span><span class="s1">th)</span><span class="s2">;</span>

      <span class="s1">ResponseUtil.onRequestError(</span>
          <span class="s1">getReactApplicationContextIfActiveOrWarn()</span><span class="s2">, </span><span class="s1">requestId</span><span class="s2">, </span><span class="s1">th.getMessage()</span><span class="s2">, </span><span class="s1">th)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">/** </span><span class="s4">@param </span><span class="s3">timeout value of 0 results in no timeout */</span>
  <span class="s2">public void </span><span class="s1">sendRequestInternal(</span>
      <span class="s1">String method</span><span class="s2">,</span>
      <span class="s1">String url</span><span class="s2">,</span>
      <span class="s2">final int </span><span class="s1">requestId</span><span class="s2">,</span>
      <span class="s1">ReadableArray headers</span><span class="s2">,</span>
      <span class="s1">ReadableMap data</span><span class="s2">,</span>
      <span class="s2">final </span><span class="s1">String responseType</span><span class="s2">,</span>
      <span class="s2">final boolean </span><span class="s1">useIncrementalUpdates</span><span class="s2">,</span>
      <span class="s2">int </span><span class="s1">timeout</span><span class="s2">,</span>
      <span class="s2">boolean </span><span class="s1">withCredentials) {</span>
    <span class="s2">final </span><span class="s1">ReactApplicationContext reactApplicationContext =</span>
        <span class="s1">getReactApplicationContextIfActiveOrWarn()</span><span class="s2">;</span>
    <span class="s2">try </span><span class="s1">{</span>
      <span class="s1">Uri uri = Uri.parse(url)</span><span class="s2">;</span>

      <span class="s0">// Check if a handler is registered</span>
      <span class="s2">for </span><span class="s1">(UriHandler handler : mUriHandlers) {</span>
        <span class="s2">if </span><span class="s1">(handler.supports(uri</span><span class="s2">, </span><span class="s1">responseType)) {</span>
          <span class="s1">WritableMap res = handler.fetch(uri)</span><span class="s2">;</span>
          <span class="s1">ResponseUtil.onDataReceived(reactApplicationContext</span><span class="s2">, </span><span class="s1">requestId</span><span class="s2">, </span><span class="s1">res)</span><span class="s2">;</span>
          <span class="s1">ResponseUtil.onRequestSuccess(reactApplicationContext</span><span class="s2">, </span><span class="s1">requestId)</span><span class="s2">;</span>
          <span class="s2">return;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(IOException e) {</span>
      <span class="s1">ResponseUtil.onRequestError(reactApplicationContext</span><span class="s2">, </span><span class="s1">requestId</span><span class="s2">, </span><span class="s1">e.getMessage()</span><span class="s2">, </span><span class="s1">e)</span><span class="s2">;</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s1">Request.Builder requestBuilder</span><span class="s2">;</span>
    <span class="s2">try </span><span class="s1">{</span>
      <span class="s1">requestBuilder = </span><span class="s2">new </span><span class="s1">Request.Builder().url(url)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(Exception e) {</span>
      <span class="s1">ResponseUtil.onRequestError(reactApplicationContext</span><span class="s2">, </span><span class="s1">requestId</span><span class="s2">, </span><span class="s1">e.getMessage()</span><span class="s2">, null</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(requestId != </span><span class="s6">0</span><span class="s1">) {</span>
      <span class="s1">requestBuilder.tag(requestId)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">OkHttpClient.Builder clientBuilder = mClient.newBuilder()</span><span class="s2">;</span>

    <span class="s1">applyCustomBuilder(clientBuilder)</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(!withCredentials) {</span>
      <span class="s1">clientBuilder.cookieJar(CookieJar.NO_COOKIES)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s0">// If JS is listening for progress updates, install a ProgressResponseBody that intercepts the</span>
    <span class="s0">// response and counts bytes received.</span>
    <span class="s2">if </span><span class="s1">(useIncrementalUpdates) {</span>
      <span class="s1">clientBuilder.addNetworkInterceptor(</span>
          <span class="s2">new </span><span class="s1">Interceptor() {</span>
            <span class="s1">@Override</span>
            <span class="s2">public </span><span class="s1">Response intercept(Interceptor.Chain chain) </span><span class="s2">throws </span><span class="s1">IOException {</span>
              <span class="s1">Response originalResponse = chain.proceed(chain.request())</span><span class="s2">;</span>
              <span class="s1">ProgressResponseBody responseBody =</span>
                  <span class="s2">new </span><span class="s1">ProgressResponseBody(</span>
                      <span class="s1">originalResponse.body()</span><span class="s2">,</span>
                      <span class="s2">new </span><span class="s1">ProgressListener() {</span>
                        <span class="s2">long </span><span class="s1">last = System.nanoTime()</span><span class="s2">;</span>

                        <span class="s1">@Override</span>
                        <span class="s2">public void </span><span class="s1">onProgress(</span>
                            <span class="s2">long </span><span class="s1">bytesWritten</span><span class="s2">, long </span><span class="s1">contentLength</span><span class="s2">, boolean </span><span class="s1">done) {</span>
                          <span class="s2">long </span><span class="s1">now = System.nanoTime()</span><span class="s2">;</span>
                          <span class="s2">if </span><span class="s1">(!done &amp;&amp; !shouldDispatch(now</span><span class="s2">, </span><span class="s1">last)) {</span>
                            <span class="s2">return;</span>
                          <span class="s1">}</span>
                          <span class="s2">if </span><span class="s1">(responseType.equals(</span><span class="s5">&quot;text&quot;</span><span class="s1">)) {</span>
                            <span class="s0">// For 'text' responses we continuously send response data with progress</span>
                            <span class="s0">// info to</span>
                            <span class="s0">// JS below, so no need to do anything here.</span>
                            <span class="s2">return;</span>
                          <span class="s1">}</span>
                          <span class="s1">ResponseUtil.onDataReceivedProgress(</span>
                              <span class="s1">reactApplicationContext</span><span class="s2">, </span><span class="s1">requestId</span><span class="s2">, </span><span class="s1">bytesWritten</span><span class="s2">, </span><span class="s1">contentLength)</span><span class="s2">;</span>
                          <span class="s1">last = now</span><span class="s2">;</span>
                        <span class="s1">}</span>
                      <span class="s1">})</span><span class="s2">;</span>
              <span class="s2">return </span><span class="s1">originalResponse.newBuilder().body(responseBody).build()</span><span class="s2">;</span>
            <span class="s1">}</span>
          <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s0">// If the current timeout does not equal the passed in timeout, we need to clone the existing</span>
    <span class="s0">// client and set the timeout explicitly on the clone.  This is cheap as everything else is</span>
    <span class="s0">// shared under the hood.</span>
    <span class="s0">// See https://github.com/square/okhttp/wiki/Recipes#per-call-configuration for more information</span>
    <span class="s2">if </span><span class="s1">(timeout != mClient.connectTimeoutMillis()) {</span>
      <span class="s1">clientBuilder.connectTimeout(timeout</span><span class="s2">, </span><span class="s1">TimeUnit.MILLISECONDS)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">OkHttpClient client = clientBuilder.build()</span><span class="s2">;</span>

    <span class="s1">Headers requestHeaders = extractHeaders(headers</span><span class="s2">, </span><span class="s1">data)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(requestHeaders == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">ResponseUtil.onRequestError(</span>
          <span class="s1">reactApplicationContext</span><span class="s2">, </span><span class="s1">requestId</span><span class="s2">, </span><span class="s5">&quot;Unrecognized headers format&quot;</span><span class="s2">, null</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s1">String contentType = requestHeaders.get(CONTENT_TYPE_HEADER_NAME)</span><span class="s2">;</span>
    <span class="s1">String contentEncoding = requestHeaders.get(CONTENT_ENCODING_HEADER_NAME)</span><span class="s2">;</span>
    <span class="s1">requestBuilder.headers(requestHeaders)</span><span class="s2">;</span>

    <span class="s0">// Check if a handler is registered</span>
    <span class="s1">RequestBodyHandler handler = </span><span class="s2">null;</span>
    <span class="s2">if </span><span class="s1">(data != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">for </span><span class="s1">(RequestBodyHandler curHandler : mRequestBodyHandlers) {</span>
        <span class="s2">if </span><span class="s1">(curHandler.supports(data)) {</span>
          <span class="s1">handler = curHandler</span><span class="s2">;</span>
          <span class="s2">break;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">RequestBody requestBody</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(data == </span><span class="s2">null</span>
        <span class="s1">|| method.toLowerCase(Locale.ROOT).equals(</span><span class="s5">&quot;get&quot;</span><span class="s1">)</span>
        <span class="s1">|| method.toLowerCase(Locale.ROOT).equals(</span><span class="s5">&quot;head&quot;</span><span class="s1">)) {</span>
      <span class="s1">requestBody = RequestBodyUtil.getEmptyBody(method)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(handler != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">requestBody = handler.toRequestBody(data</span><span class="s2">, </span><span class="s1">contentType)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(data.hasKey(REQUEST_BODY_KEY_STRING)) {</span>
      <span class="s2">if </span><span class="s1">(contentType == </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">ResponseUtil.onRequestError(</span>
            <span class="s1">reactApplicationContext</span><span class="s2">,</span>
            <span class="s1">requestId</span><span class="s2">,</span>
            <span class="s5">&quot;Payload is set but no content-type header specified&quot;</span><span class="s2">,</span>
            <span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">return;</span>
      <span class="s1">}</span>
      <span class="s1">String body = data.getString(REQUEST_BODY_KEY_STRING)</span><span class="s2">;</span>
      <span class="s1">MediaType contentMediaType = MediaType.parse(contentType)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(RequestBodyUtil.isGzipEncoding(contentEncoding)) {</span>
        <span class="s1">requestBody = RequestBodyUtil.createGzip(contentMediaType</span><span class="s2">, </span><span class="s1">body)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(requestBody == </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">ResponseUtil.onRequestError(</span>
              <span class="s1">reactApplicationContext</span><span class="s2">, </span><span class="s1">requestId</span><span class="s2">, </span><span class="s5">&quot;Failed to gzip request body&quot;</span><span class="s2">, null</span><span class="s1">)</span><span class="s2">;</span>
          <span class="s2">return;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s0">// Use getBytes() to convert the body into a byte[], preventing okhttp from</span>
        <span class="s0">// appending the character set to the Content-Type header when otherwise unspecified</span>
        <span class="s0">// https://github.com/facebook/react-native/issues/8237</span>
        <span class="s1">Charset charset =</span>
            <span class="s1">contentMediaType == </span><span class="s2">null</span>
                <span class="s1">? StandardCharsets.UTF_8</span>
                <span class="s1">: contentMediaType.charset(StandardCharsets.UTF_8)</span><span class="s2">;</span>
        <span class="s1">requestBody = RequestBody.create(contentMediaType</span><span class="s2">, </span><span class="s1">body.getBytes(charset))</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(data.hasKey(REQUEST_BODY_KEY_BASE64)) {</span>
      <span class="s2">if </span><span class="s1">(contentType == </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">ResponseUtil.onRequestError(</span>
            <span class="s1">reactApplicationContext</span><span class="s2">,</span>
            <span class="s1">requestId</span><span class="s2">,</span>
            <span class="s5">&quot;Payload is set but no content-type header specified&quot;</span><span class="s2">,</span>
            <span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">return;</span>
      <span class="s1">}</span>
      <span class="s1">String base64String = data.getString(REQUEST_BODY_KEY_BASE64)</span><span class="s2">;</span>
      <span class="s1">MediaType contentMediaType = MediaType.parse(contentType)</span><span class="s2">;</span>
      <span class="s1">requestBody = RequestBody.create(contentMediaType</span><span class="s2">, </span><span class="s1">ByteString.decodeBase64(base64String))</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(data.hasKey(REQUEST_BODY_KEY_URI)) {</span>
      <span class="s2">if </span><span class="s1">(contentType == </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">ResponseUtil.onRequestError(</span>
            <span class="s1">reactApplicationContext</span><span class="s2">,</span>
            <span class="s1">requestId</span><span class="s2">,</span>
            <span class="s5">&quot;Payload is set but no content-type header specified&quot;</span><span class="s2">,</span>
            <span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">return;</span>
      <span class="s1">}</span>
      <span class="s1">String uri = data.getString(REQUEST_BODY_KEY_URI)</span><span class="s2">;</span>
      <span class="s1">InputStream fileInputStream =</span>
          <span class="s1">RequestBodyUtil.getFileInputStream(getReactApplicationContext()</span><span class="s2">, </span><span class="s1">uri)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(fileInputStream == </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">ResponseUtil.onRequestError(</span>
            <span class="s1">reactApplicationContext</span><span class="s2">, </span><span class="s1">requestId</span><span class="s2">, </span><span class="s5">&quot;Could not retrieve file for uri &quot; </span><span class="s1">+ uri</span><span class="s2">, null</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">return;</span>
      <span class="s1">}</span>
      <span class="s1">requestBody = RequestBodyUtil.create(MediaType.parse(contentType)</span><span class="s2">, </span><span class="s1">fileInputStream)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(data.hasKey(REQUEST_BODY_KEY_FORMDATA)) {</span>
      <span class="s2">if </span><span class="s1">(contentType == </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">contentType = </span><span class="s5">&quot;multipart/form-data&quot;</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s1">ReadableArray parts = data.getArray(REQUEST_BODY_KEY_FORMDATA)</span><span class="s2">;</span>
      <span class="s1">MultipartBody.Builder multipartBuilder =</span>
          <span class="s1">constructMultipartBody(parts</span><span class="s2">, </span><span class="s1">contentType</span><span class="s2">, </span><span class="s1">requestId)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(multipartBuilder == </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">return;</span>
      <span class="s1">}</span>
      <span class="s1">requestBody = multipartBuilder.build()</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s0">// Nothing in data payload, at least nothing we could understand anyway.</span>
      <span class="s1">requestBody = RequestBodyUtil.getEmptyBody(method)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">requestBuilder.method(method</span><span class="s2">, </span><span class="s1">wrapRequestBodyWithProgressEmitter(requestBody</span><span class="s2">, </span><span class="s1">requestId))</span><span class="s2">;</span>

    <span class="s1">addRequest(requestId)</span><span class="s2">;</span>
    <span class="s1">client</span>
        <span class="s1">.newCall(requestBuilder.build())</span>
        <span class="s1">.enqueue(</span>
            <span class="s2">new </span><span class="s1">Callback() {</span>
              <span class="s1">@Override</span>
              <span class="s2">public void </span><span class="s1">onFailure(Call call</span><span class="s2">, </span><span class="s1">IOException e) {</span>
                <span class="s2">if </span><span class="s1">(mShuttingDown) {</span>
                  <span class="s2">return;</span>
                <span class="s1">}</span>
                <span class="s1">removeRequest(requestId)</span><span class="s2">;</span>
                <span class="s1">String errorMessage =</span>
                    <span class="s1">e.getMessage() != </span><span class="s2">null</span>
                        <span class="s1">? e.getMessage()</span>
                        <span class="s1">: </span><span class="s5">&quot;Error while executing request: &quot; </span><span class="s1">+ e.getClass().getSimpleName()</span><span class="s2">;</span>
                <span class="s1">ResponseUtil.onRequestError(reactApplicationContext</span><span class="s2">, </span><span class="s1">requestId</span><span class="s2">, </span><span class="s1">errorMessage</span><span class="s2">, </span><span class="s1">e)</span><span class="s2">;</span>
              <span class="s1">}</span>

              <span class="s1">@Override</span>
              <span class="s2">public void </span><span class="s1">onResponse(Call call</span><span class="s2">, </span><span class="s1">Response response) </span><span class="s2">throws </span><span class="s1">IOException {</span>
                <span class="s2">if </span><span class="s1">(mShuttingDown) {</span>
                  <span class="s2">return;</span>
                <span class="s1">}</span>
                <span class="s1">removeRequest(requestId)</span><span class="s2">;</span>
                <span class="s0">// Before we touch the body send headers to JS</span>
                <span class="s1">ResponseUtil.onResponseReceived(</span>
                    <span class="s1">reactApplicationContext</span><span class="s2">,</span>
                    <span class="s1">requestId</span><span class="s2">,</span>
                    <span class="s1">response.code()</span><span class="s2">,</span>
                    <span class="s1">translateHeaders(response.headers())</span><span class="s2">,</span>
                    <span class="s1">response.request().url().toString())</span><span class="s2">;</span>

                <span class="s2">try </span><span class="s1">{</span>
                  <span class="s0">// OkHttp implements something called transparent gzip, which mean that it will</span>
                  <span class="s0">// automatically add the Accept-Encoding gzip header and handle decoding</span>
                  <span class="s0">// internally.</span>
                  <span class="s0">// The issue is that it won't handle decoding if the user provides a</span>
                  <span class="s0">// Accept-Encoding</span>
                  <span class="s0">// header. This is also undesirable considering that iOS does handle the decoding</span>
                  <span class="s0">// even</span>
                  <span class="s0">// when the header is provided. To make sure this works in all cases, handle gzip</span>
                  <span class="s0">// body</span>
                  <span class="s0">// here also. This works fine since OKHttp will remove the Content-Encoding header</span>
                  <span class="s0">// if</span>
                  <span class="s0">// it used transparent gzip.</span>
                  <span class="s0">// See</span>
                  <span class="s0">// https://github.com/square/okhttp/blob/5b37cda9e00626f43acf354df145fd452c3031f1/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java#L76-L111</span>
                  <span class="s1">ResponseBody responseBody = response.body()</span><span class="s2">;</span>
                  <span class="s2">if </span><span class="s1">(</span><span class="s5">&quot;gzip&quot;</span><span class="s1">.equalsIgnoreCase(response.header(</span><span class="s5">&quot;Content-Encoding&quot;</span><span class="s1">))</span>
                      <span class="s1">&amp;&amp; responseBody != </span><span class="s2">null</span><span class="s1">) {</span>
                    <span class="s1">GzipSource gzipSource = </span><span class="s2">new </span><span class="s1">GzipSource(responseBody.source())</span><span class="s2">;</span>
                    <span class="s1">String contentType = response.header(</span><span class="s5">&quot;Content-Type&quot;</span><span class="s1">)</span><span class="s2">;</span>
                    <span class="s1">responseBody =</span>
                        <span class="s1">ResponseBody.create(</span>
                            <span class="s1">contentType != </span><span class="s2">null </span><span class="s1">? MediaType.parse(contentType) : </span><span class="s2">null,</span>
                            <span class="s1">-</span><span class="s6">1L</span><span class="s2">,</span>
                            <span class="s1">Okio.buffer(gzipSource))</span><span class="s2">;</span>
                  <span class="s1">}</span>

                  <span class="s0">// Check if a handler is registered</span>
                  <span class="s2">for </span><span class="s1">(ResponseHandler handler : mResponseHandlers) {</span>
                    <span class="s2">if </span><span class="s1">(handler.supports(responseType)) {</span>
                      <span class="s1">WritableMap res = handler.toResponseData(responseBody)</span><span class="s2">;</span>
                      <span class="s1">ResponseUtil.onDataReceived(reactApplicationContext</span><span class="s2">, </span><span class="s1">requestId</span><span class="s2">, </span><span class="s1">res)</span><span class="s2">;</span>
                      <span class="s1">ResponseUtil.onRequestSuccess(reactApplicationContext</span><span class="s2">, </span><span class="s1">requestId)</span><span class="s2">;</span>
                      <span class="s2">return;</span>
                    <span class="s1">}</span>
                  <span class="s1">}</span>

                  <span class="s0">// If JS wants progress updates during the download, and it requested a text</span>
                  <span class="s0">// response,</span>
                  <span class="s0">// periodically send response data updates to JS.</span>
                  <span class="s2">if </span><span class="s1">(useIncrementalUpdates &amp;&amp; responseType.equals(</span><span class="s5">&quot;text&quot;</span><span class="s1">)) {</span>
                    <span class="s1">readWithProgress(requestId</span><span class="s2">, </span><span class="s1">responseBody)</span><span class="s2">;</span>
                    <span class="s1">ResponseUtil.onRequestSuccess(reactApplicationContext</span><span class="s2">, </span><span class="s1">requestId)</span><span class="s2">;</span>
                    <span class="s2">return;</span>
                  <span class="s1">}</span>

                  <span class="s0">// Otherwise send the data in one big chunk, in the format that JS requested.</span>
                  <span class="s1">String responseString = </span><span class="s5">&quot;&quot;</span><span class="s2">;</span>
                  <span class="s2">if </span><span class="s1">(responseType.equals(</span><span class="s5">&quot;text&quot;</span><span class="s1">)) {</span>
                    <span class="s2">try </span><span class="s1">{</span>
                      <span class="s1">responseString = responseBody.string()</span><span class="s2">;</span>
                    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(IOException e) {</span>
                      <span class="s2">if </span><span class="s1">(response.request().method().equalsIgnoreCase(</span><span class="s5">&quot;HEAD&quot;</span><span class="s1">)) {</span>
                        <span class="s0">// The request is an `HEAD` and the body is empty,</span>
                        <span class="s0">// the OkHttp will produce an exception.</span>
                        <span class="s0">// Ignore the exception to not invalidate the request in the</span>
                        <span class="s0">// Javascript layer.</span>
                        <span class="s0">// Introduced to fix issue #7463.</span>
                      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">ResponseUtil.onRequestError(</span>
                            <span class="s1">reactApplicationContext</span><span class="s2">, </span><span class="s1">requestId</span><span class="s2">, </span><span class="s1">e.getMessage()</span><span class="s2">, </span><span class="s1">e)</span><span class="s2">;</span>
                      <span class="s1">}</span>
                    <span class="s1">}</span>
                  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(responseType.equals(</span><span class="s5">&quot;base64&quot;</span><span class="s1">)) {</span>
                    <span class="s1">responseString = Base64.encodeToString(responseBody.bytes()</span><span class="s2">, </span><span class="s1">Base64.NO_WRAP)</span><span class="s2">;</span>
                  <span class="s1">}</span>
                  <span class="s1">ResponseUtil.onDataReceived(reactApplicationContext</span><span class="s2">, </span><span class="s1">requestId</span><span class="s2">, </span><span class="s1">responseString)</span><span class="s2">;</span>
                  <span class="s1">ResponseUtil.onRequestSuccess(reactApplicationContext</span><span class="s2">, </span><span class="s1">requestId)</span><span class="s2">;</span>
                <span class="s1">} </span><span class="s2">catch </span><span class="s1">(IOException e) {</span>
                  <span class="s1">ResponseUtil.onRequestError(</span>
                      <span class="s1">reactApplicationContext</span><span class="s2">, </span><span class="s1">requestId</span><span class="s2">, </span><span class="s1">e.getMessage()</span><span class="s2">, </span><span class="s1">e)</span><span class="s2">;</span>
                <span class="s1">}</span>
              <span class="s1">}</span>
            <span class="s1">})</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private </span><span class="s1">RequestBody wrapRequestBodyWithProgressEmitter(</span>
      <span class="s2">final </span><span class="s1">RequestBody requestBody</span><span class="s2">, final int </span><span class="s1">requestId) {</span>
    <span class="s2">if </span><span class="s1">(requestBody == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">return null;</span>
    <span class="s1">}</span>
    <span class="s2">final </span><span class="s1">ReactApplicationContext reactApplicationContext =</span>
        <span class="s1">getReactApplicationContextIfActiveOrWarn()</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">RequestBodyUtil.createProgressRequest(</span>
        <span class="s1">requestBody</span><span class="s2">,</span>
        <span class="s2">new </span><span class="s1">ProgressListener() {</span>
          <span class="s2">long </span><span class="s1">last = System.nanoTime()</span><span class="s2">;</span>

          <span class="s1">@Override</span>
          <span class="s2">public void </span><span class="s1">onProgress(</span><span class="s2">long </span><span class="s1">bytesWritten</span><span class="s2">, long </span><span class="s1">contentLength</span><span class="s2">, boolean </span><span class="s1">done) {</span>
            <span class="s2">long </span><span class="s1">now = System.nanoTime()</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(done || shouldDispatch(now</span><span class="s2">, </span><span class="s1">last)) {</span>
              <span class="s1">ResponseUtil.onDataSend(</span>
                  <span class="s1">reactApplicationContext</span><span class="s2">, </span><span class="s1">requestId</span><span class="s2">, </span><span class="s1">bytesWritten</span><span class="s2">, </span><span class="s1">contentLength)</span><span class="s2">;</span>
              <span class="s1">last = now</span><span class="s2">;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">})</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private void </span><span class="s1">readWithProgress(</span><span class="s2">int </span><span class="s1">requestId</span><span class="s2">, </span><span class="s1">ResponseBody responseBody) </span><span class="s2">throws </span><span class="s1">IOException {</span>
    <span class="s2">long </span><span class="s1">totalBytesRead = -</span><span class="s6">1</span><span class="s2">;</span>
    <span class="s2">long </span><span class="s1">contentLength = -</span><span class="s6">1</span><span class="s2">;</span>
    <span class="s2">try </span><span class="s1">{</span>
      <span class="s1">ProgressResponseBody progressResponseBody = (ProgressResponseBody) responseBody</span><span class="s2">;</span>
      <span class="s1">totalBytesRead = progressResponseBody.totalBytesRead()</span><span class="s2">;</span>
      <span class="s1">contentLength = progressResponseBody.contentLength()</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(ClassCastException e) {</span>
      <span class="s0">// Ignore</span>
    <span class="s1">}</span>

    <span class="s1">Charset charset =</span>
        <span class="s1">responseBody.contentType() == </span><span class="s2">null</span>
            <span class="s1">? StandardCharsets.UTF_8</span>
            <span class="s1">: responseBody.contentType().charset(StandardCharsets.UTF_8)</span><span class="s2">;</span>

    <span class="s1">ProgressiveStringDecoder streamDecoder = </span><span class="s2">new </span><span class="s1">ProgressiveStringDecoder(charset)</span><span class="s2">;</span>
    <span class="s1">InputStream inputStream = responseBody.byteStream()</span><span class="s2">;</span>
    <span class="s2">try </span><span class="s1">{</span>
      <span class="s2">byte</span><span class="s1">[] buffer = </span><span class="s2">new byte</span><span class="s1">[MAX_CHUNK_SIZE_BETWEEN_FLUSHES]</span><span class="s2">;</span>
      <span class="s2">int </span><span class="s1">read</span><span class="s2">;</span>
      <span class="s2">final </span><span class="s1">ReactApplicationContext reactApplicationContext =</span>
          <span class="s1">getReactApplicationContextIfActiveOrWarn()</span><span class="s2">;</span>
      <span class="s2">while </span><span class="s1">((read = inputStream.read(buffer)) != -</span><span class="s6">1</span><span class="s1">) {</span>
        <span class="s1">ResponseUtil.onIncrementalDataReceived(</span>
            <span class="s1">reactApplicationContext</span><span class="s2">,</span>
            <span class="s1">requestId</span><span class="s2">,</span>
            <span class="s1">streamDecoder.decodeNext(buffer</span><span class="s2">, </span><span class="s1">read)</span><span class="s2">,</span>
            <span class="s1">totalBytesRead</span><span class="s2">,</span>
            <span class="s1">contentLength)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
      <span class="s1">inputStream.close()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">private static boolean </span><span class="s1">shouldDispatch(</span><span class="s2">long </span><span class="s1">now</span><span class="s2">, long </span><span class="s1">last) {</span>
    <span class="s2">return </span><span class="s1">last + CHUNK_TIMEOUT_NS &lt; now</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private synchronized void </span><span class="s1">addRequest(</span><span class="s2">int </span><span class="s1">requestId) {</span>
    <span class="s1">mRequestIds.add(requestId)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private synchronized void </span><span class="s1">removeRequest(</span><span class="s2">int </span><span class="s1">requestId) {</span>
    <span class="s1">mRequestIds.remove(requestId)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private synchronized void </span><span class="s1">cancelAllRequests() {</span>
    <span class="s2">for </span><span class="s1">(Integer requestId : mRequestIds) {</span>
      <span class="s1">cancelRequest(requestId)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">mRequestIds.clear()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private static </span><span class="s1">WritableMap translateHeaders(Headers headers) {</span>
    <span class="s1">Bundle responseHeaders = </span><span class="s2">new </span><span class="s1">Bundle()</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s6">0</span><span class="s2">; </span><span class="s1">i &lt; headers.size()</span><span class="s2">; </span><span class="s1">i++) {</span>
      <span class="s1">String headerName = headers.name(i)</span><span class="s2">;</span>
      <span class="s0">// multiple values for the same header</span>
      <span class="s2">if </span><span class="s1">(responseHeaders.containsKey(headerName)) {</span>
        <span class="s1">responseHeaders.putString(</span>
            <span class="s1">headerName</span><span class="s2">, </span><span class="s1">responseHeaders.getString(headerName) + </span><span class="s5">&quot;, &quot; </span><span class="s1">+ headers.value(i))</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">responseHeaders.putString(headerName</span><span class="s2">, </span><span class="s1">headers.value(i))</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">Arguments.fromBundle(responseHeaders)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">abortRequest(</span><span class="s2">double </span><span class="s1">requestIdAsDouble) {</span>
    <span class="s2">int </span><span class="s1">requestId = (</span><span class="s2">int</span><span class="s1">) requestIdAsDouble</span><span class="s2">;</span>
    <span class="s1">cancelRequest(requestId)</span><span class="s2">;</span>
    <span class="s1">removeRequest(requestId)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private void </span><span class="s1">cancelRequest(</span><span class="s2">final int </span><span class="s1">requestId) {</span>
    <span class="s0">// We have to use AsyncTask since this might trigger a NetworkOnMainThreadException, this is an</span>
    <span class="s0">// open issue on OkHttp: https://github.com/square/okhttp/issues/869</span>
    <span class="s2">new </span><span class="s1">GuardedAsyncTask&lt;Void</span><span class="s2">, </span><span class="s1">Void&gt;(getReactApplicationContext()) {</span>
      <span class="s1">@Override</span>
      <span class="s2">protected void </span><span class="s1">doInBackgroundGuarded(Void... params) {</span>
        <span class="s1">OkHttpCallUtil.cancelTag(mClient</span><span class="s2">, </span><span class="s1">Integer.valueOf(requestId))</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}.execute()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@ReactMethod</span>
  <span class="s2">public void </span><span class="s1">clearCookies(com.facebook.react.bridge.Callback callback) {</span>
    <span class="s1">mCookieHandler.clearCookies(callback)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">addListener(String eventName) {}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">removeListeners(</span><span class="s2">double </span><span class="s1">count) {}</span>

  <span class="s2">private </span><span class="s1">@Nullable MultipartBody.Builder constructMultipartBody(</span>
      <span class="s1">ReadableArray body</span><span class="s2">, </span><span class="s1">String contentType</span><span class="s2">, int </span><span class="s1">requestId) {</span>
    <span class="s1">MultipartBody.Builder multipartBuilder = </span><span class="s2">new </span><span class="s1">MultipartBody.Builder()</span><span class="s2">;</span>
    <span class="s1">multipartBuilder.setType(MediaType.parse(contentType))</span><span class="s2">;</span>

    <span class="s2">final </span><span class="s1">ReactApplicationContext reactApplicationContext =</span>
        <span class="s1">getReactApplicationContextIfActiveOrWarn()</span><span class="s2">;</span>

    <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s6">0</span><span class="s2">, </span><span class="s1">size = body.size()</span><span class="s2">; </span><span class="s1">i &lt; size</span><span class="s2">; </span><span class="s1">i++) {</span>
      <span class="s1">ReadableMap bodyPart = body.getMap(i)</span><span class="s2">;</span>

      <span class="s0">// Determine part's content type.</span>
      <span class="s1">ReadableArray headersArray = bodyPart.getArray(</span><span class="s5">&quot;headers&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">Headers headers = extractHeaders(headersArray</span><span class="s2">, null</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(headers == </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">ResponseUtil.onRequestError(</span>
            <span class="s1">reactApplicationContext</span><span class="s2">,</span>
            <span class="s1">requestId</span><span class="s2">,</span>
            <span class="s5">&quot;Missing or invalid header format for FormData part.&quot;</span><span class="s2">,</span>
            <span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">return null;</span>
      <span class="s1">}</span>
      <span class="s1">MediaType partContentType = </span><span class="s2">null;</span>
      <span class="s1">String partContentTypeStr = headers.get(CONTENT_TYPE_HEADER_NAME)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(partContentTypeStr != </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">partContentType = MediaType.parse(partContentTypeStr)</span><span class="s2">;</span>
        <span class="s0">// Remove the content-type header because MultipartBuilder gets it explicitly as an</span>
        <span class="s0">// argument and doesn't expect it in the headers array.</span>
        <span class="s1">headers = headers.newBuilder().removeAll(CONTENT_TYPE_HEADER_NAME).build()</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(bodyPart.hasKey(REQUEST_BODY_KEY_STRING)) {</span>
        <span class="s1">String bodyValue = bodyPart.getString(REQUEST_BODY_KEY_STRING)</span><span class="s2">;</span>
        <span class="s1">multipartBuilder.addPart(headers</span><span class="s2">, </span><span class="s1">RequestBody.create(partContentType</span><span class="s2">, </span><span class="s1">bodyValue))</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(bodyPart.hasKey(REQUEST_BODY_KEY_URI)) {</span>
        <span class="s2">if </span><span class="s1">(partContentType == </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">ResponseUtil.onRequestError(</span>
              <span class="s1">reactApplicationContext</span><span class="s2">,</span>
              <span class="s1">requestId</span><span class="s2">,</span>
              <span class="s5">&quot;Binary FormData part needs a content-type header.&quot;</span><span class="s2">,</span>
              <span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
          <span class="s2">return null;</span>
        <span class="s1">}</span>
        <span class="s1">String fileContentUriStr = bodyPart.getString(REQUEST_BODY_KEY_URI)</span><span class="s2">;</span>
        <span class="s1">InputStream fileInputStream =</span>
            <span class="s1">RequestBodyUtil.getFileInputStream(getReactApplicationContext()</span><span class="s2">, </span><span class="s1">fileContentUriStr)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(fileInputStream == </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">ResponseUtil.onRequestError(</span>
              <span class="s1">reactApplicationContext</span><span class="s2">,</span>
              <span class="s1">requestId</span><span class="s2">,</span>
              <span class="s5">&quot;Could not retrieve file for uri &quot; </span><span class="s1">+ fileContentUriStr</span><span class="s2">,</span>
              <span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
          <span class="s2">return null;</span>
        <span class="s1">}</span>
        <span class="s1">multipartBuilder.addPart(headers</span><span class="s2">, </span><span class="s1">RequestBodyUtil.create(partContentType</span><span class="s2">, </span><span class="s1">fileInputStream))</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">ResponseUtil.onRequestError(</span>
            <span class="s1">reactApplicationContext</span><span class="s2">, </span><span class="s1">requestId</span><span class="s2">, </span><span class="s5">&quot;Unrecognized FormData part.&quot;</span><span class="s2">, null</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">multipartBuilder</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Extracts the headers from the Array. If the format is invalid, this method will return null.</span>
   <span class="s3">*/</span>
  <span class="s2">private </span><span class="s1">@Nullable Headers extractHeaders(</span>
      <span class="s1">@Nullable ReadableArray headersArray</span><span class="s2">, </span><span class="s1">@Nullable ReadableMap requestData) {</span>
    <span class="s2">if </span><span class="s1">(headersArray == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">return null;</span>
    <span class="s1">}</span>
    <span class="s1">Headers.Builder headersBuilder = </span><span class="s2">new </span><span class="s1">Headers.Builder()</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">headersIdx = </span><span class="s6">0</span><span class="s2">, </span><span class="s1">size = headersArray.size()</span><span class="s2">; </span><span class="s1">headersIdx &lt; size</span><span class="s2">; </span><span class="s1">headersIdx++) {</span>
      <span class="s1">ReadableArray header = headersArray.getArray(headersIdx)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(header == </span><span class="s2">null </span><span class="s1">|| header.size() != </span><span class="s6">2</span><span class="s1">) {</span>
        <span class="s2">return null;</span>
      <span class="s1">}</span>
      <span class="s1">String headerName = HeaderUtil.stripHeaderName(header.getString(</span><span class="s6">0</span><span class="s1">))</span><span class="s2">;</span>
      <span class="s1">String headerValue = HeaderUtil.stripHeaderValue(header.getString(</span><span class="s6">1</span><span class="s1">))</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(headerName == </span><span class="s2">null </span><span class="s1">|| headerValue == </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">return null;</span>
      <span class="s1">}</span>
      <span class="s1">headersBuilder.add(headerName</span><span class="s2">, </span><span class="s1">headerValue)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(headersBuilder.get(USER_AGENT_HEADER_NAME) == </span><span class="s2">null </span><span class="s1">&amp;&amp; mDefaultUserAgent != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">headersBuilder.add(USER_AGENT_HEADER_NAME</span><span class="s2">, </span><span class="s1">mDefaultUserAgent)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s0">// Sanitize content encoding header, supported only when request specify payload as string</span>
    <span class="s2">boolean </span><span class="s1">isGzipSupported = requestData != </span><span class="s2">null </span><span class="s1">&amp;&amp; requestData.hasKey(REQUEST_BODY_KEY_STRING)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!isGzipSupported) {</span>
      <span class="s1">headersBuilder.removeAll(CONTENT_ENCODING_HEADER_NAME)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">headersBuilder.build()</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
</pre>
</body>
</html>
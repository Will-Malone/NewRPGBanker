<html>
<head>
<title>GenerateViewConfigJs.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
.s5 { color: #4646f1;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
GenerateViewConfigJs.js</font>
</center></td></tr></table>
<pre><span class="s0">/** 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 * 
 * 
 * @format 
 */</span>

<span class="s2">'use strict'</span><span class="s1">;</span>

<span class="s1">const j = require(</span><span class="s2">'jscodeshift'</span><span class="s1">);</span>

<span class="s0">// File path -&gt; contents</span>

<span class="s1">const FileTemplate = ({imports, componentConfig}) =&gt; `</span>
<span class="s0">/** 
 * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen). 
 * 
 * Do not edit this file as changes may cause incorrect behavior and will be lost 
 * once the code is regenerated. 
 * 
 * @flow 
 * 
 * ${'@'}generated by codegen project: GenerateViewConfigJs.js 
 */</span>

<span class="s2">'use strict'</span><span class="s1">;</span>

<span class="s1">${imports}</span>

<span class="s1">${componentConfig}</span>
<span class="s1">`;</span>

<span class="s0">// We use this to add to a set. Need to make sure we aren't importing</span>
<span class="s0">// this multiple times.</span>
<span class="s1">const UIMANAGER_IMPORT = </span><span class="s2">'const {UIManager} = require(&quot;react-native&quot;)'</span><span class="s1">;</span>
<span class="s3">function </span><span class="s1">getReactDiffProcessValue(typeAnnotation) {</span>
  <span class="s3">switch </span><span class="s1">(typeAnnotation.type) {</span>
    <span class="s3">case </span><span class="s2">'BooleanTypeAnnotation'</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s2">'StringTypeAnnotation'</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s2">'Int32TypeAnnotation'</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s2">'DoubleTypeAnnotation'</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s2">'FloatTypeAnnotation'</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s2">'ObjectTypeAnnotation'</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s2">'StringEnumTypeAnnotation'</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s2">'Int32EnumTypeAnnotation'</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s2">'MixedTypeAnnotation'</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">j.literal(</span><span class="s3">true</span><span class="s1">);</span>
    <span class="s3">case </span><span class="s2">'ReservedPropTypeAnnotation'</span><span class="s1">:</span>
      <span class="s3">switch </span><span class="s1">(typeAnnotation.name) {</span>
        <span class="s3">case </span><span class="s2">'ColorPrimitive'</span><span class="s1">:</span>
          <span class="s3">return </span><span class="s1">j.template</span>
            <span class="s1">.expression`{ process: require(</span><span class="s2">'react-native/Libraries/StyleSheet/processColor'</span><span class="s1">).</span><span class="s3">default </span><span class="s1">}`;</span>
        <span class="s3">case </span><span class="s2">'ImageSourcePrimitive'</span><span class="s1">:</span>
          <span class="s3">return </span><span class="s1">j.template</span>
            <span class="s1">.expression`{ process: require(</span><span class="s2">'react-native/Libraries/Image/resolveAssetSource'</span><span class="s1">) }`;</span>
        <span class="s3">case </span><span class="s2">'ImageRequestPrimitive'</span><span class="s1">:</span>
          <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">'ImageRequest should not be used in props'</span><span class="s1">);</span>
        <span class="s3">case </span><span class="s2">'PointPrimitive'</span><span class="s1">:</span>
          <span class="s3">return </span><span class="s1">j.template</span>
            <span class="s1">.expression`{ diff: require(</span><span class="s2">'react-native/Libraries/Utilities/differ/pointsDiffer'</span><span class="s1">) }`;</span>
        <span class="s3">case </span><span class="s2">'EdgeInsetsPrimitive'</span><span class="s1">:</span>
          <span class="s3">return </span><span class="s1">j.template</span>
            <span class="s1">.expression`{ diff: require(</span><span class="s2">'react-native/Libraries/Utilities/differ/insetsDiffer'</span><span class="s1">) }`;</span>
        <span class="s3">case </span><span class="s2">'DimensionPrimitive'</span><span class="s1">:</span>
          <span class="s3">return </span><span class="s1">j.literal(</span><span class="s3">true</span><span class="s1">);</span>
        <span class="s3">default</span><span class="s1">:</span>
          <span class="s1">typeAnnotation.name;</span>
          <span class="s3">throw new </span><span class="s1">Error(</span>
            <span class="s1">`Received unknown native typeAnnotation: </span><span class="s2">&quot;${typeAnnotation.name}&quot;</span><span class="s1">`,</span>
          <span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s3">case </span><span class="s2">'ArrayTypeAnnotation'</span><span class="s1">:</span>
      <span class="s3">if </span><span class="s1">(typeAnnotation.elementType.type === </span><span class="s2">'ReservedPropTypeAnnotation'</span><span class="s1">) {</span>
        <span class="s3">switch </span><span class="s1">(typeAnnotation.elementType.name) {</span>
          <span class="s3">case </span><span class="s2">'ColorPrimitive'</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">j.template</span>
              <span class="s1">.expression`{ process: require(</span><span class="s2">'react-native/Libraries/StyleSheet/processColorArray'</span><span class="s1">) }`;</span>
          <span class="s3">case </span><span class="s2">'ImageSourcePrimitive'</span><span class="s1">:</span>
          <span class="s3">case </span><span class="s2">'PointPrimitive'</span><span class="s1">:</span>
          <span class="s3">case </span><span class="s2">'EdgeInsetsPrimitive'</span><span class="s1">:</span>
          <span class="s3">case </span><span class="s2">'DimensionPrimitive'</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">j.literal(</span><span class="s3">true</span><span class="s1">);</span>
          <span class="s3">default</span><span class="s1">:</span>
            <span class="s3">throw new </span><span class="s1">Error(</span>
              <span class="s1">`Received unknown array native typeAnnotation: </span><span class="s2">&quot;${typeAnnotation.elementType.name}&quot;</span><span class="s1">`,</span>
            <span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s3">return </span><span class="s1">j.literal(</span><span class="s3">true</span><span class="s1">);</span>
    <span class="s3">default</span><span class="s1">:</span>
      <span class="s1">typeAnnotation;</span>
      <span class="s3">throw new </span><span class="s1">Error(</span>
        <span class="s1">`Received unknown typeAnnotation: </span><span class="s2">&quot;${typeAnnotation.type}&quot;</span><span class="s1">`,</span>
      <span class="s1">);</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">const ComponentTemplate = ({</span>
  <span class="s1">componentName,</span>
  <span class="s1">paperComponentName,</span>
  <span class="s1">paperComponentNameDeprecated,</span>
<span class="s1">}) =&gt; {</span>
  <span class="s1">const nativeComponentName =</span>
    <span class="s1">paperComponentName !== </span><span class="s3">null </span><span class="s1">&amp;&amp; paperComponentName !== </span><span class="s3">void </span><span class="s4">0</span>
      <span class="s1">? paperComponentName</span>
      <span class="s1">: componentName;</span>
  <span class="s3">return </span><span class="s1">`</span>
<span class="s1">let nativeComponentName = </span><span class="s2">'${nativeComponentName}'</span><span class="s1">;</span>
<span class="s1">${</span>
  <span class="s1">paperComponentNameDeprecated != </span><span class="s3">null</span>
    <span class="s1">? DeprecatedComponentNameCheckTemplate({</span>
        <span class="s1">componentName,</span>
        <span class="s1">paperComponentNameDeprecated,</span>
      <span class="s1">})</span>
    <span class="s1">: </span><span class="s2">''</span>
<span class="s1">}</span>

<span class="s1">export const __INTERNAL_VIEW_CONFIG = VIEW_CONFIG;</span>

<span class="s1">export </span><span class="s3">default </span><span class="s1">NativeComponentRegistry.get(nativeComponentName, () =&gt; __INTERNAL_VIEW_CONFIG);</span>
<span class="s1">`.trim();</span>
<span class="s1">};</span>

<span class="s0">// Check whether the native component exists in the app binary.</span>
<span class="s0">// Old getViewManagerConfig() checks for the existance of the native Paper view manager. Not available in Bridgeless.</span>
<span class="s0">// New hasViewManagerConfig() queries Fabricâ€™s native component registry directly.</span>
<span class="s1">const DeprecatedComponentNameCheckTemplate = ({</span>
  <span class="s1">componentName,</span>
  <span class="s1">paperComponentNameDeprecated,</span>
<span class="s1">}) =&gt;</span>
  <span class="s1">`</span>
<span class="s3">if </span><span class="s1">(UIManager.hasViewManagerConfig(</span><span class="s2">'${componentName}'</span><span class="s1">)) {</span>
  <span class="s1">nativeComponentName = </span><span class="s2">'${componentName}'</span><span class="s1">;</span>
<span class="s1">} </span><span class="s3">else if </span><span class="s1">(UIManager.hasViewManagerConfig(</span><span class="s2">'${paperComponentNameDeprecated}'</span><span class="s1">)) {</span>
  <span class="s1">nativeComponentName = </span><span class="s2">'${paperComponentNameDeprecated}'</span><span class="s1">;</span>
<span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
  <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">'Failed to find native component for either &quot;${componentName}&quot; or &quot;${paperComponentNameDeprecated}&quot;'</span><span class="s1">);</span>
<span class="s1">}</span>
<span class="s1">`.trim();</span>

<span class="s0">// Replicates the behavior of RCTNormalizeInputEventName in RCTEventDispatcher.m</span>
<span class="s3">function </span><span class="s1">normalizeInputEventName(name) {</span>
  <span class="s3">if </span><span class="s1">(name.startsWith(</span><span class="s2">'on'</span><span class="s1">)) {</span>
    <span class="s3">return </span><span class="s1">name.replace(/^on/, </span><span class="s2">'top'</span><span class="s1">);</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(!name.startsWith(</span><span class="s2">'top'</span><span class="s1">)) {</span>
    <span class="s3">return </span><span class="s1">`top${name[</span><span class="s4">0</span><span class="s1">].toUpperCase()}${name.slice(</span><span class="s4">1</span><span class="s1">)}`;</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">name;</span>
<span class="s1">}</span>

<span class="s0">// Replicates the behavior of viewConfig in RCTComponentData.m</span>
<span class="s3">function </span><span class="s1">getValidAttributesForEvents(events, imports) {</span>
  <span class="s1">imports.add(</span>
    <span class="s2">&quot;const {ConditionallyIgnoredEventHandlers} = require('react-native/Libraries/NativeComponent/ViewConfigIgnore');&quot;</span><span class="s1">,</span>
  <span class="s1">);</span>
  <span class="s1">const validAttributes = j.objectExpression(</span>
    <span class="s1">events.map(eventType =&gt; {</span>
      <span class="s3">return </span><span class="s1">j.property(</span><span class="s2">'init'</span><span class="s1">, j.identifier(eventType.name), j.literal(</span><span class="s3">true</span><span class="s1">));</span>
    <span class="s1">}),</span>
  <span class="s1">);</span>
  <span class="s3">return </span><span class="s1">j.callExpression(j.identifier(</span><span class="s2">'ConditionallyIgnoredEventHandlers'</span><span class="s1">), [</span>
    <span class="s1">validAttributes,</span>
  <span class="s1">]);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">generateBubblingEventInfo(event, nameOveride) {</span>
  <span class="s3">return </span><span class="s1">j.property(</span>
    <span class="s2">'init'</span><span class="s1">,</span>
    <span class="s1">j.identifier(nameOveride || normalizeInputEventName(event.name)),</span>
    <span class="s1">j.objectExpression([</span>
      <span class="s1">j.property(</span>
        <span class="s2">'init'</span><span class="s1">,</span>
        <span class="s1">j.identifier(</span><span class="s2">'phasedRegistrationNames'</span><span class="s1">),</span>
        <span class="s1">j.objectExpression([</span>
          <span class="s1">j.property(</span>
            <span class="s2">'init'</span><span class="s1">,</span>
            <span class="s1">j.identifier(</span><span class="s2">'captured'</span><span class="s1">),</span>
            <span class="s1">j.literal(`${event.name}Capture`),</span>
          <span class="s1">),</span>
          <span class="s1">j.property(</span><span class="s2">'init'</span><span class="s1">, j.identifier(</span><span class="s2">'bubbled'</span><span class="s1">), j.literal(event.name)),</span>
        <span class="s1">]),</span>
      <span class="s1">),</span>
    <span class="s1">]),</span>
  <span class="s1">);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">generateDirectEventInfo(event, nameOveride) {</span>
  <span class="s3">return </span><span class="s1">j.property(</span>
    <span class="s2">'init'</span><span class="s1">,</span>
    <span class="s1">j.identifier(nameOveride || normalizeInputEventName(event.name)),</span>
    <span class="s1">j.objectExpression([</span>
      <span class="s1">j.property(</span>
        <span class="s2">'init'</span><span class="s1">,</span>
        <span class="s1">j.identifier(</span><span class="s2">'registrationName'</span><span class="s1">),</span>
        <span class="s1">j.literal(event.name),</span>
      <span class="s1">),</span>
    <span class="s1">]),</span>
  <span class="s1">);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">buildViewConfig(schema, componentName, component, imports) {</span>
  <span class="s1">const componentProps = component.props;</span>
  <span class="s1">const componentEvents = component.events;</span>
  <span class="s1">component.extendsProps.forEach(extendProps =&gt; {</span>
    <span class="s3">switch </span><span class="s1">(extendProps.type) {</span>
      <span class="s3">case </span><span class="s2">'ReactNativeBuiltInType'</span><span class="s1">:</span>
        <span class="s3">switch </span><span class="s1">(extendProps.knownTypeName) {</span>
          <span class="s3">case </span><span class="s2">'ReactNativeCoreViewProps'</span><span class="s1">:</span>
            <span class="s1">imports.add(</span>
              <span class="s2">&quot;const NativeComponentRegistry = require('react-native/Libraries/NativeComponent/NativeComponentRegistry');&quot;</span><span class="s1">,</span>
            <span class="s1">);</span>
            <span class="s3">return</span><span class="s1">;</span>
          <span class="s3">default</span><span class="s1">:</span>
            <span class="s1">extendProps.knownTypeName;</span>
            <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">'Invalid knownTypeName'</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s3">default</span><span class="s1">:</span>
        <span class="s1">extendProps.type;</span>
        <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">'Invalid extended type'</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">});</span>
  <span class="s1">const validAttributes = j.objectExpression([</span>
    <span class="s1">...componentProps.map(schemaProp =&gt; {</span>
      <span class="s3">return </span><span class="s1">j.property(</span>
        <span class="s2">'init'</span><span class="s1">,</span>
        <span class="s1">j.identifier(schemaProp.name),</span>
        <span class="s1">getReactDiffProcessValue(schemaProp.typeAnnotation),</span>
      <span class="s1">);</span>
    <span class="s1">}),</span>
    <span class="s1">...(componentEvents.length &gt; </span><span class="s4">0</span>
      <span class="s1">? [</span>
          <span class="s1">j.spreadProperty(</span>
            <span class="s1">getValidAttributesForEvents(componentEvents, imports),</span>
          <span class="s1">),</span>
        <span class="s1">]</span>
      <span class="s1">: []),</span>
  <span class="s1">]);</span>
  <span class="s1">const bubblingEventNames = component.events</span>
    <span class="s1">.filter(event =&gt; event.bubblingType === </span><span class="s2">'bubble'</span><span class="s1">)</span>
    <span class="s1">.reduce((bubblingEvents, event) =&gt; {</span>
      <span class="s0">// We add in the deprecated paper name so that it is in the view config.</span>
      <span class="s0">// This means either the old event name or the new event name can fire</span>
      <span class="s0">// and be sent to the listener until the old top level name is removed.</span>
      <span class="s3">if </span><span class="s1">(event.paperTopLevelNameDeprecated) {</span>
        <span class="s1">bubblingEvents.push(</span>
          <span class="s1">generateBubblingEventInfo(event, event.paperTopLevelNameDeprecated),</span>
        <span class="s1">);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">bubblingEvents.push(generateBubblingEventInfo(event));</span>
      <span class="s1">}</span>
      <span class="s3">return </span><span class="s1">bubblingEvents;</span>
    <span class="s1">}, []);</span>
  <span class="s1">const bubblingEvents =</span>
    <span class="s1">bubblingEventNames.length &gt; </span><span class="s4">0</span>
      <span class="s1">? j.property(</span>
          <span class="s2">'init'</span><span class="s1">,</span>
          <span class="s1">j.identifier(</span><span class="s2">'bubblingEventTypes'</span><span class="s1">),</span>
          <span class="s1">j.objectExpression(bubblingEventNames),</span>
        <span class="s1">)</span>
      <span class="s1">: </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">const directEventNames = component.events</span>
    <span class="s1">.filter(event =&gt; event.bubblingType === </span><span class="s2">'direct'</span><span class="s1">)</span>
    <span class="s1">.reduce((directEvents, event) =&gt; {</span>
      <span class="s0">// We add in the deprecated paper name so that it is in the view config.</span>
      <span class="s0">// This means either the old event name or the new event name can fire</span>
      <span class="s0">// and be sent to the listener until the old top level name is removed.</span>
      <span class="s3">if </span><span class="s1">(event.paperTopLevelNameDeprecated) {</span>
        <span class="s1">directEvents.push(</span>
          <span class="s1">generateDirectEventInfo(event, event.paperTopLevelNameDeprecated),</span>
        <span class="s1">);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">directEvents.push(generateDirectEventInfo(event));</span>
      <span class="s1">}</span>
      <span class="s3">return </span><span class="s1">directEvents;</span>
    <span class="s1">}, []);</span>
  <span class="s1">const directEvents =</span>
    <span class="s1">directEventNames.length &gt; </span><span class="s4">0</span>
      <span class="s1">? j.property(</span>
          <span class="s2">'init'</span><span class="s1">,</span>
          <span class="s1">j.identifier(</span><span class="s2">'directEventTypes'</span><span class="s1">),</span>
          <span class="s1">j.objectExpression(directEventNames),</span>
        <span class="s1">)</span>
      <span class="s1">: </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">const properties = [</span>
    <span class="s1">j.property(</span>
      <span class="s2">'init'</span><span class="s1">,</span>
      <span class="s1">j.identifier(</span><span class="s2">'uiViewClassName'</span><span class="s1">),</span>
      <span class="s1">j.literal(componentName),</span>
    <span class="s1">),</span>
    <span class="s1">bubblingEvents,</span>
    <span class="s1">directEvents,</span>
    <span class="s1">j.property(</span><span class="s2">'init'</span><span class="s1">, j.identifier(</span><span class="s2">'validAttributes'</span><span class="s1">), validAttributes),</span>
  <span class="s1">].filter(Boolean);</span>
  <span class="s3">return </span><span class="s1">j.objectExpression(properties);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">buildCommands(schema, componentName, component, imports) {</span>
  <span class="s1">const commands = component.commands;</span>
  <span class="s3">if </span><span class="s1">(commands.length === </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s1">imports.add(</span>
    <span class="s2">'const {dispatchCommand} = require(&quot;react-native/Libraries/ReactNative/RendererProxy&quot;);'</span><span class="s1">,</span>
  <span class="s1">);</span>
  <span class="s1">const properties = commands.map(command =&gt; {</span>
    <span class="s1">const commandName = command.name;</span>
    <span class="s1">const params = command.typeAnnotation.params;</span>
    <span class="s1">const commandNameLiteral = j.literal(commandName);</span>
    <span class="s1">const commandNameIdentifier = j.identifier(commandName);</span>
    <span class="s1">const arrayParams = j.arrayExpression(</span>
      <span class="s1">params.map(param =&gt; {</span>
        <span class="s3">return </span><span class="s1">j.identifier(param.name);</span>
      <span class="s1">}),</span>
    <span class="s1">);</span>
    <span class="s1">const expression = j.template</span>
      <span class="s1">.expression`dispatchCommand(ref, ${commandNameLiteral}, ${arrayParams})`;</span>
    <span class="s1">const functionParams = params.map(param =&gt; {</span>
      <span class="s3">return </span><span class="s1">j.identifier(param.name);</span>
    <span class="s1">});</span>
    <span class="s1">const property = j.property(</span>
      <span class="s2">'init'</span><span class="s1">,</span>
      <span class="s1">commandNameIdentifier,</span>
      <span class="s1">j.functionExpression(</span>
        <span class="s3">null</span><span class="s1">,</span>
        <span class="s1">[j.identifier(</span><span class="s2">'ref'</span><span class="s1">), ...functionParams],</span>
        <span class="s1">j.blockStatement([j.expressionStatement(expression)]),</span>
      <span class="s1">),</span>
    <span class="s1">);</span>
    <span class="s1">property.method = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s1">property;</span>
  <span class="s1">});</span>
  <span class="s3">return </span><span class="s1">j.exportNamedDeclaration(</span>
    <span class="s1">j.variableDeclaration(</span><span class="s2">'const'</span><span class="s1">, [</span>
      <span class="s1">j.variableDeclarator(</span>
        <span class="s1">j.identifier(</span><span class="s2">'Commands'</span><span class="s1">),</span>
        <span class="s1">j.objectExpression(properties),</span>
      <span class="s1">),</span>
    <span class="s1">]),</span>
  <span class="s1">);</span>
<span class="s1">}</span>
<span class="s1">module.exports = {</span>
  <span class="s1">generate(libraryName, schema) {</span>
    <span class="s3">try </span><span class="s1">{</span>
      <span class="s1">const fileName = `${libraryName}NativeViewConfig.js`;</span>
      <span class="s1">const imports = </span><span class="s3">new </span><span class="s1">Set();</span>
      <span class="s1">const moduleResults = Object.keys(schema.modules)</span>
        <span class="s1">.map(moduleName =&gt; {</span>
          <span class="s1">const module = schema.modules[moduleName];</span>
          <span class="s3">if </span><span class="s1">(module.type !== </span><span class="s2">'Component'</span><span class="s1">) {</span>
            <span class="s3">return</span><span class="s1">;</span>
          <span class="s1">}</span>
          <span class="s1">const components = module.components;</span>
          <span class="s3">return </span><span class="s1">Object.keys(components)</span>
            <span class="s1">.map(componentName =&gt; {</span>
              <span class="s3">var </span><span class="s1">_component$paperCompo;</span>
              <span class="s1">const component = components[componentName];</span>
              <span class="s3">if </span><span class="s1">(component.paperComponentNameDeprecated) {</span>
                <span class="s1">imports.add(UIMANAGER_IMPORT);</span>
              <span class="s1">}</span>
              <span class="s1">const replacedTemplate = ComponentTemplate({</span>
                <span class="s1">componentName,</span>
                <span class="s1">paperComponentName: component.paperComponentName,</span>
                <span class="s1">paperComponentNameDeprecated:</span>
                  <span class="s1">component.paperComponentNameDeprecated,</span>
              <span class="s1">});</span>
              <span class="s1">const replacedSourceRoot = j.withParser(</span><span class="s2">'flow'</span><span class="s1">)(replacedTemplate);</span>
              <span class="s1">const paperComponentName =</span>
                <span class="s1">(_component$paperCompo = component.paperComponentName) !==</span>
                  <span class="s3">null </span><span class="s1">&amp;&amp; _component$paperCompo !== </span><span class="s3">void </span><span class="s4">0</span>
                  <span class="s1">? _component$paperCompo</span>
                  <span class="s1">: componentName;</span>
              <span class="s1">replacedSourceRoot</span>
                <span class="s1">.find(j.Identifier, {</span>
                  <span class="s1">name: </span><span class="s2">'VIEW_CONFIG'</span><span class="s1">,</span>
                <span class="s1">})</span>
                <span class="s1">.replaceWith(</span>
                  <span class="s1">buildViewConfig(</span>
                    <span class="s1">schema,</span>
                    <span class="s1">paperComponentName,</span>
                    <span class="s1">component,</span>
                    <span class="s1">imports,</span>
                  <span class="s1">),</span>
                <span class="s1">);</span>
              <span class="s1">const commands = buildCommands(</span>
                <span class="s1">schema,</span>
                <span class="s1">paperComponentName,</span>
                <span class="s1">component,</span>
                <span class="s1">imports,</span>
              <span class="s1">);</span>
              <span class="s3">if </span><span class="s1">(commands) {</span>
                <span class="s1">replacedSourceRoot</span>
                  <span class="s1">.find(j.ExportDefaultDeclaration)</span>
                  <span class="s1">.insertAfter(j(commands).toSource());</span>
              <span class="s1">}</span>
              <span class="s1">const replacedSource = replacedSourceRoot.toSource({</span>
                <span class="s1">quote: </span><span class="s2">'single'</span><span class="s1">,</span>
                <span class="s1">trailingComma: </span><span class="s3">true</span><span class="s1">,</span>
              <span class="s1">});</span>
              <span class="s3">return </span><span class="s1">replacedSource;</span>
            <span class="s1">})</span>
            <span class="s1">.join(</span><span class="s2">'</span><span class="s5">\n\n</span><span class="s2">'</span><span class="s1">);</span>
        <span class="s1">})</span>
        <span class="s1">.filter(Boolean)</span>
        <span class="s1">.join(</span><span class="s2">'</span><span class="s5">\n\n</span><span class="s2">'</span><span class="s1">);</span>
      <span class="s1">const replacedTemplate = FileTemplate({</span>
        <span class="s1">componentConfig: moduleResults,</span>
        <span class="s1">imports: Array.from(imports).sort().join(</span><span class="s2">'</span><span class="s5">\n</span><span class="s2">'</span><span class="s1">),</span>
      <span class="s1">});</span>
      <span class="s3">return new </span><span class="s1">Map([[fileName, replacedTemplate]]);</span>
    <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
      <span class="s1">console.error(`\nError parsing schema </span><span class="s3">for </span><span class="s1">${libraryName}\n`);</span>
      <span class="s1">console.error(JSON.stringify(schema));</span>
      <span class="s3">throw </span><span class="s1">error;</span>
    <span class="s1">}</span>
  <span class="s1">},</span>
<span class="s1">};</span>
</pre>
</body>
</html>
<html>
<head>
<title>ReactFabric-dev.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
.s5 { color: #4646f1;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
ReactFabric-dev.js</font>
</center></td></tr></table>
<pre><span class="s0">/** 
 * Copyright (c) Facebook, Inc. and its affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 * 
 * @noflow 
 * @nolint 
 * @providesModule ReactFabric-dev 
 * @preventMunge 
 * @generated SignedSource&lt;&lt;343bc15819bccf8610b6ff32fcb59b21&gt;&gt; 
 */</span>

<span class="s2">'use strict'</span><span class="s1">;</span>

<span class="s3">if </span><span class="s1">(__DEV__) {</span>
  <span class="s1">(</span><span class="s3">function</span><span class="s1">() {</span>

          <span class="s2">'use strict'</span><span class="s1">;</span>

<span class="s0">/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */</span>
<span class="s3">if </span><span class="s1">(</span>
  <span class="s3">typeof </span><span class="s1">__REACT_DEVTOOLS_GLOBAL_HOOK__ !== </span><span class="s2">'undefined' </span><span class="s1">&amp;&amp;</span>
  <span class="s3">typeof </span><span class="s1">__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart ===</span>
    <span class="s2">'function'</span>
<span class="s1">) {</span>
  <span class="s1">__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(</span><span class="s3">new </span><span class="s1">Error());</span>
<span class="s1">}</span>
          <span class="s2">&quot;use strict&quot;</span><span class="s1">;</span>

<span class="s3">var </span><span class="s1">React = require(</span><span class="s2">&quot;react&quot;</span><span class="s1">);</span>
<span class="s1">require(</span><span class="s2">&quot;react-native/Libraries/ReactPrivate/ReactNativePrivateInitializeCore&quot;</span><span class="s1">);</span>
<span class="s3">var </span><span class="s1">ReactNativePrivateInterface = require(</span><span class="s2">&quot;react-native/Libraries/ReactPrivate/ReactNativePrivateInterface&quot;</span><span class="s1">);</span>
<span class="s3">var </span><span class="s1">Scheduler = require(</span><span class="s2">&quot;scheduler&quot;</span><span class="s1">);</span>

<span class="s3">var </span><span class="s1">ReactSharedInternals =</span>
  <span class="s1">React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;</span>

<span class="s0">// by calls to these methods by a Babel plugin.</span>
<span class="s0">//</span>
<span class="s0">// In PROD (or in packages without access to React internals),</span>
<span class="s0">// they are left as they are instead.</span>

<span class="s3">function </span><span class="s1">warn(format) {</span>
  <span class="s1">{</span>
    <span class="s1">{</span>
      <span class="s3">for </span><span class="s1">(</span>
        <span class="s3">var </span><span class="s1">_len = arguments.length,</span>
          <span class="s1">args = </span><span class="s3">new </span><span class="s1">Array(_len &gt; </span><span class="s4">1 </span><span class="s1">? _len - </span><span class="s4">1 </span><span class="s1">: </span><span class="s4">0</span><span class="s1">),</span>
          <span class="s1">_key = </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s1">_key &lt; _len;</span>
        <span class="s1">_key++</span>
      <span class="s1">) {</span>
        <span class="s1">args[_key - </span><span class="s4">1</span><span class="s1">] = arguments[_key];</span>
      <span class="s1">}</span>

      <span class="s1">printWarning(</span><span class="s2">&quot;warn&quot;</span><span class="s1">, format, args);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">error(format) {</span>
  <span class="s1">{</span>
    <span class="s1">{</span>
      <span class="s3">for </span><span class="s1">(</span>
        <span class="s3">var </span><span class="s1">_len2 = arguments.length,</span>
          <span class="s1">args = </span><span class="s3">new </span><span class="s1">Array(_len2 &gt; </span><span class="s4">1 </span><span class="s1">? _len2 - </span><span class="s4">1 </span><span class="s1">: </span><span class="s4">0</span><span class="s1">),</span>
          <span class="s1">_key2 = </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s1">_key2 &lt; _len2;</span>
        <span class="s1">_key2++</span>
      <span class="s1">) {</span>
        <span class="s1">args[_key2 - </span><span class="s4">1</span><span class="s1">] = arguments[_key2];</span>
      <span class="s1">}</span>

      <span class="s1">printWarning(</span><span class="s2">&quot;error&quot;</span><span class="s1">, format, args);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">printWarning(level, format, args) {</span>
  <span class="s0">// When changing this logic, you might want to also</span>
  <span class="s0">// update consoleWithStackDev.www.js as well.</span>
  <span class="s1">{</span>
    <span class="s3">var </span><span class="s1">ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;</span>
    <span class="s3">var </span><span class="s1">stack = ReactDebugCurrentFrame.getStackAddendum();</span>

    <span class="s3">if </span><span class="s1">(stack !== </span><span class="s2">&quot;&quot;</span><span class="s1">) {</span>
      <span class="s1">format += </span><span class="s2">&quot;%s&quot;</span><span class="s1">;</span>
      <span class="s1">args = args.concat([stack]);</span>
    <span class="s1">} </span><span class="s0">// eslint-disable-next-line react-internal/safe-string-coercion</span>

    <span class="s3">var </span><span class="s1">argsWithFormat = args.map(</span><span class="s3">function</span><span class="s1">(item) {</span>
      <span class="s3">return </span><span class="s1">String(item);</span>
    <span class="s1">}); </span><span class="s0">// Careful: RN currently depends on this prefix</span>

    <span class="s1">argsWithFormat.unshift(</span><span class="s2">&quot;Warning: &quot; </span><span class="s1">+ format); </span><span class="s0">// We intentionally don't use spread (or .apply) directly because it</span>
    <span class="s0">// breaks IE9: https://github.com/facebook/react/issues/13610</span>
    <span class="s0">// eslint-disable-next-line react-internal/no-production-logging</span>

    <span class="s1">Function.prototype.apply.call(console[level], console, argsWithFormat);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">invokeGuardedCallbackProd(name, func, context, a, b, c, d, e, f) {</span>
  <span class="s3">var </span><span class="s1">funcArgs = Array.prototype.slice.call(arguments, </span><span class="s4">3</span><span class="s1">);</span>

  <span class="s3">try </span><span class="s1">{</span>
    <span class="s1">func.apply(context, funcArgs);</span>
  <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
    <span class="s3">this</span><span class="s1">.onError(error);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">invokeGuardedCallbackImpl = invokeGuardedCallbackProd;</span>

<span class="s1">{</span>
  <span class="s0">// In DEV mode, we swap out invokeGuardedCallback for a special version</span>
  <span class="s0">// that plays more nicely with the browser's DevTools. The idea is to preserve</span>
  <span class="s0">// &quot;Pause on exceptions&quot; behavior. Because React wraps all user-provided</span>
  <span class="s0">// functions in invokeGuardedCallback, and the production version of</span>
  <span class="s0">// invokeGuardedCallback uses a try-catch, all user exceptions are treated</span>
  <span class="s0">// like caught exceptions, and the DevTools won't pause unless the developer</span>
  <span class="s0">// takes the extra step of enabling pause on caught exceptions. This is</span>
  <span class="s0">// unintuitive, though, because even though React has caught the error, from</span>
  <span class="s0">// the developer's perspective, the error is uncaught.</span>
  <span class="s0">//</span>
  <span class="s0">// To preserve the expected &quot;Pause on exceptions&quot; behavior, we don't use a</span>
  <span class="s0">// try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake</span>
  <span class="s0">// DOM node, and call the user-provided callback from inside an event handler</span>
  <span class="s0">// for that fake event. If the callback throws, the error is &quot;captured&quot; using</span>
  <span class="s0">// a global event handler. But because the error happens in a different</span>
  <span class="s0">// event loop context, it does not interrupt the normal program flow.</span>
  <span class="s0">// Effectively, this gives us try-catch behavior without actually using</span>
  <span class="s0">// try-catch. Neat!</span>
  <span class="s0">// Check that the browser supports the APIs we need to implement our special</span>
  <span class="s0">// DEV version of invokeGuardedCallback</span>
  <span class="s3">if </span><span class="s1">(</span>
    <span class="s3">typeof </span><span class="s1">window !== </span><span class="s2">&quot;undefined&quot; </span><span class="s1">&amp;&amp;</span>
    <span class="s3">typeof </span><span class="s1">window.dispatchEvent === </span><span class="s2">&quot;function&quot; </span><span class="s1">&amp;&amp;</span>
    <span class="s3">typeof </span><span class="s1">document !== </span><span class="s2">&quot;undefined&quot; </span><span class="s1">&amp;&amp;</span>
    <span class="s3">typeof </span><span class="s1">document.createEvent === </span><span class="s2">&quot;function&quot;</span>
  <span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">fakeNode = document.createElement(</span><span class="s2">&quot;react&quot;</span><span class="s1">);</span>

    <span class="s1">invokeGuardedCallbackImpl = </span><span class="s3">function </span><span class="s1">invokeGuardedCallbackDev(</span>
      <span class="s1">name,</span>
      <span class="s1">func,</span>
      <span class="s1">context,</span>
      <span class="s1">a,</span>
      <span class="s1">b,</span>
      <span class="s1">c,</span>
      <span class="s1">d,</span>
      <span class="s1">e,</span>
      <span class="s1">f</span>
    <span class="s1">) {</span>
      <span class="s0">// If document doesn't exist we know for sure we will crash in this method</span>
      <span class="s0">// when we call document.createEvent(). However this can cause confusing</span>
      <span class="s0">// errors: https://github.com/facebook/create-react-app/issues/3482</span>
      <span class="s0">// So we preemptively throw with a better message instead.</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">document === </span><span class="s2">&quot;undefined&quot; </span><span class="s1">|| document === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">throw new </span><span class="s1">Error(</span>
          <span class="s2">&quot;The `document` global was defined when React was initialized, but is not &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;defined anymore. This can happen in a test environment if a component &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;schedules an update from an asynchronous callback, but the test has already &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;finished running. To solve this, you can either unmount the component at &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;the end of your test (and ensure that any asynchronous operations get &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;canceled in `componentWillUnmount`), or you can change the test itself &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;to be asynchronous.&quot;</span>
        <span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">evt = document.createEvent(</span><span class="s2">&quot;Event&quot;</span><span class="s1">);</span>
      <span class="s3">var </span><span class="s1">didCall = </span><span class="s3">false</span><span class="s1">; </span><span class="s0">// Keeps track of whether the user-provided callback threw an error. We</span>
      <span class="s0">// set this to true at the beginning, then set it to false right after</span>
      <span class="s0">// calling the function. If the function errors, `didError` will never be</span>
      <span class="s0">// set to false. This strategy works even if the browser is flaky and</span>
      <span class="s0">// fails to call our global error handler, because it doesn't rely on</span>
      <span class="s0">// the error event at all.</span>

      <span class="s3">var </span><span class="s1">didError = </span><span class="s3">true</span><span class="s1">; </span><span class="s0">// Keeps track of the value of window.event so that we can reset it</span>
      <span class="s0">// during the callback to let user code access window.event in the</span>
      <span class="s0">// browsers that support it.</span>

      <span class="s3">var </span><span class="s1">windowEvent = window.event; </span><span class="s0">// Keeps track of the descriptor of window.event to restore it after event</span>
      <span class="s0">// dispatching: https://github.com/facebook/react/issues/13688</span>

      <span class="s3">var </span><span class="s1">windowEventDescriptor = Object.getOwnPropertyDescriptor(</span>
        <span class="s1">window,</span>
        <span class="s2">&quot;event&quot;</span>
      <span class="s1">);</span>

      <span class="s3">function </span><span class="s1">restoreAfterDispatch() {</span>
        <span class="s0">// We immediately remove the callback from event listeners so that</span>
        <span class="s0">// nested `invokeGuardedCallback` calls do not clash. Otherwise, a</span>
        <span class="s0">// nested call would trigger the fake event handlers of any call higher</span>
        <span class="s0">// in the stack.</span>
        <span class="s1">fakeNode.removeEventListener(evtType, callCallback, </span><span class="s3">false</span><span class="s1">); </span><span class="s0">// We check for window.hasOwnProperty('event') to prevent the</span>
        <span class="s0">// window.event assignment in both IE &lt;= 10 as they throw an error</span>
        <span class="s0">// &quot;Member not found&quot; in strict mode, and in Firefox which does not</span>
        <span class="s0">// support window.event.</span>

        <span class="s3">if </span><span class="s1">(</span>
          <span class="s3">typeof </span><span class="s1">window.event !== </span><span class="s2">&quot;undefined&quot; </span><span class="s1">&amp;&amp;</span>
          <span class="s1">window.hasOwnProperty(</span><span class="s2">&quot;event&quot;</span><span class="s1">)</span>
        <span class="s1">) {</span>
          <span class="s1">window.event = windowEvent;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s0">// Create an event handler for our fake event. We will synchronously</span>
      <span class="s0">// dispatch our fake event using `dispatchEvent`. Inside the handler, we</span>
      <span class="s0">// call the user-provided callback.</span>

      <span class="s3">var </span><span class="s1">funcArgs = Array.prototype.slice.call(arguments, </span><span class="s4">3</span><span class="s1">);</span>

      <span class="s3">function </span><span class="s1">callCallback() {</span>
        <span class="s1">didCall = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s1">restoreAfterDispatch();</span>
        <span class="s1">func.apply(context, funcArgs);</span>
        <span class="s1">didError = </span><span class="s3">false</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// Create a global error event handler. We use this to capture the value</span>
      <span class="s0">// that was thrown. It's possible that this error handler will fire more</span>
      <span class="s0">// than once; for example, if non-React code also calls `dispatchEvent`</span>
      <span class="s0">// and a handler for that event throws. We should be resilient to most of</span>
      <span class="s0">// those cases. Even if our error event handler fires more than once, the</span>
      <span class="s0">// last error event is always used. If the callback actually does error,</span>
      <span class="s0">// we know that the last error event is the correct one, because it's not</span>
      <span class="s0">// possible for anything else to have happened in between our callback</span>
      <span class="s0">// erroring and the code that follows the `dispatchEvent` call below. If</span>
      <span class="s0">// the callback doesn't error, but the error event was fired, we know to</span>
      <span class="s0">// ignore it because `didError` will be false, as described above.</span>

      <span class="s3">var </span><span class="s1">error; </span><span class="s0">// Use this to track whether the error event is ever called.</span>

      <span class="s3">var </span><span class="s1">didSetError = </span><span class="s3">false</span><span class="s1">;</span>
      <span class="s3">var </span><span class="s1">isCrossOriginError = </span><span class="s3">false</span><span class="s1">;</span>

      <span class="s3">function </span><span class="s1">handleWindowError(event) {</span>
        <span class="s1">error = event.error;</span>
        <span class="s1">didSetError = </span><span class="s3">true</span><span class="s1">;</span>

        <span class="s3">if </span><span class="s1">(error === </span><span class="s3">null </span><span class="s1">&amp;&amp; event.colno === </span><span class="s4">0 </span><span class="s1">&amp;&amp; event.lineno === </span><span class="s4">0</span><span class="s1">) {</span>
          <span class="s1">isCrossOriginError = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(event.defaultPrevented) {</span>
          <span class="s0">// Some other error handler has prevented default.</span>
          <span class="s0">// Browsers silence the error report if this happens.</span>
          <span class="s0">// We'll remember this to later decide whether to log it or not.</span>
          <span class="s3">if </span><span class="s1">(error != </span><span class="s3">null </span><span class="s1">&amp;&amp; </span><span class="s3">typeof </span><span class="s1">error === </span><span class="s2">&quot;object&quot;</span><span class="s1">) {</span>
            <span class="s3">try </span><span class="s1">{</span>
              <span class="s1">error._suppressLogging = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s3">catch </span><span class="s1">(inner) {</span>
              <span class="s0">// Ignore.</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s0">// Create a fake event type.</span>

      <span class="s3">var </span><span class="s1">evtType = </span><span class="s2">&quot;react-&quot; </span><span class="s1">+ (name ? name : </span><span class="s2">&quot;invokeguardedcallback&quot;</span><span class="s1">); </span><span class="s0">// Attach our event handlers</span>

      <span class="s1">window.addEventListener(</span><span class="s2">&quot;error&quot;</span><span class="s1">, handleWindowError);</span>
      <span class="s1">fakeNode.addEventListener(evtType, callCallback, </span><span class="s3">false</span><span class="s1">); </span><span class="s0">// Synchronously dispatch our fake event. If the user-provided function</span>
      <span class="s0">// errors, it will trigger our global error handler.</span>

      <span class="s1">evt.initEvent(evtType, </span><span class="s3">false</span><span class="s1">, </span><span class="s3">false</span><span class="s1">);</span>
      <span class="s1">fakeNode.dispatchEvent(evt);</span>

      <span class="s3">if </span><span class="s1">(windowEventDescriptor) {</span>
        <span class="s1">Object.defineProperty(window, </span><span class="s2">&quot;event&quot;</span><span class="s1">, windowEventDescriptor);</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(didCall &amp;&amp; didError) {</span>
        <span class="s3">if </span><span class="s1">(!didSetError) {</span>
          <span class="s0">// The callback errored, but the error event never fired.</span>
          <span class="s0">// eslint-disable-next-line react-internal/prod-error-codes</span>
          <span class="s1">error = </span><span class="s3">new </span><span class="s1">Error(</span>
            <span class="s2">&quot;An error was thrown inside one of your components, but React &quot; </span><span class="s1">+</span>
              <span class="s2">&quot;doesn't know what it was. This is likely due to browser &quot; </span><span class="s1">+</span>
              <span class="s2">'flakiness. React does its best to preserve the &quot;Pause on ' </span><span class="s1">+</span>
              <span class="s2">'exceptions&quot; behavior of the DevTools, which requires some ' </span><span class="s1">+</span>
              <span class="s2">&quot;DEV-mode only tricks. It's possible that these don't work in &quot; </span><span class="s1">+</span>
              <span class="s2">&quot;your browser. Try triggering the error in production mode, &quot; </span><span class="s1">+</span>
              <span class="s2">&quot;or switching to a modern browser. If you suspect that this is &quot; </span><span class="s1">+</span>
              <span class="s2">&quot;actually an issue with React, please file an issue.&quot;</span>
          <span class="s1">);</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(isCrossOriginError) {</span>
          <span class="s0">// eslint-disable-next-line react-internal/prod-error-codes</span>
          <span class="s1">error = </span><span class="s3">new </span><span class="s1">Error(</span>
            <span class="s2">&quot;A cross-origin error was thrown. React doesn't have access to &quot; </span><span class="s1">+</span>
              <span class="s2">&quot;the actual error object in development. &quot; </span><span class="s1">+</span>
              <span class="s2">&quot;See https://reactjs.org/link/crossorigin-error for more information.&quot;</span>
          <span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s3">this</span><span class="s1">.onError(error);</span>
      <span class="s1">} </span><span class="s0">// Remove our event listeners</span>

      <span class="s1">window.removeEventListener(</span><span class="s2">&quot;error&quot;</span><span class="s1">, handleWindowError);</span>

      <span class="s3">if </span><span class="s1">(!didCall) {</span>
        <span class="s0">// Something went really wrong, and our event was not dispatched.</span>
        <span class="s0">// https://github.com/facebook/react/issues/16734</span>
        <span class="s0">// https://github.com/facebook/react/issues/16585</span>
        <span class="s0">// Fall back to the production implementation.</span>
        <span class="s1">restoreAfterDispatch();</span>
        <span class="s3">return </span><span class="s1">invokeGuardedCallbackProd.apply(</span><span class="s3">this</span><span class="s1">, arguments);</span>
      <span class="s1">}</span>
    <span class="s1">};</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;</span>

<span class="s3">var </span><span class="s1">hasError = </span><span class="s3">false</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">caughtError = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// Used by event system to capture/rethrow the first error.</span>

<span class="s3">var </span><span class="s1">hasRethrowError = </span><span class="s3">false</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">rethrowError = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">reporter = {</span>
  <span class="s1">onError: </span><span class="s3">function</span><span class="s1">(error) {</span>
    <span class="s1">hasError = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">caughtError = error;</span>
  <span class="s1">}</span>
<span class="s1">};</span>
<span class="s0">/** 
 * Call a function while guarding against errors that happens within it. 
 * Returns an error if it throws, otherwise null. 
 * 
 * In production, this is implemented using a try-catch. The reason we don't 
 * use a try-catch directly is so that we can swap out a different 
 * implementation in DEV mode. 
 * 
 * @param {String} name of the guard to use for logging or debugging 
 * @param {Function} func The function to invoke 
 * @param {*} context The context to use when calling the function 
 * @param {...*} args Arguments for function 
 */</span>

<span class="s3">function </span><span class="s1">invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {</span>
  <span class="s1">hasError = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s1">caughtError = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">invokeGuardedCallbackImpl$1.apply(reporter, arguments);</span>
<span class="s1">}</span>
<span class="s0">/** 
 * Same as invokeGuardedCallback, but instead of returning an error, it stores 
 * it in a global so it can be rethrown by `rethrowCaughtError` later. 
 * TODO: See if caughtError and rethrowError can be unified. 
 * 
 * @param {String} name of the guard to use for logging or debugging 
 * @param {Function} func The function to invoke 
 * @param {*} context The context to use when calling the function 
 * @param {...*} args Arguments for function 
 */</span>

<span class="s3">function </span><span class="s1">invokeGuardedCallbackAndCatchFirstError(</span>
  <span class="s1">name,</span>
  <span class="s1">func,</span>
  <span class="s1">context,</span>
  <span class="s1">a,</span>
  <span class="s1">b,</span>
  <span class="s1">c,</span>
  <span class="s1">d,</span>
  <span class="s1">e,</span>
  <span class="s1">f</span>
<span class="s1">) {</span>
  <span class="s1">invokeGuardedCallback.apply(</span><span class="s3">this</span><span class="s1">, arguments);</span>

  <span class="s3">if </span><span class="s1">(hasError) {</span>
    <span class="s3">var </span><span class="s1">error = clearCaughtError();</span>

    <span class="s3">if </span><span class="s1">(!hasRethrowError) {</span>
      <span class="s1">hasRethrowError = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">rethrowError = error;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">/** 
 * During execution of guarded functions we will capture the first error which 
 * we will rethrow to be handled by the top level error handler. 
 */</span>

<span class="s3">function </span><span class="s1">rethrowCaughtError() {</span>
  <span class="s3">if </span><span class="s1">(hasRethrowError) {</span>
    <span class="s3">var </span><span class="s1">error = rethrowError;</span>
    <span class="s1">hasRethrowError = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">rethrowError = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">throw </span><span class="s1">error;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">hasCaughtError() {</span>
  <span class="s3">return </span><span class="s1">hasError;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">clearCaughtError() {</span>
  <span class="s3">if </span><span class="s1">(hasError) {</span>
    <span class="s3">var </span><span class="s1">error = caughtError;</span>
    <span class="s1">hasError = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">caughtError = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s1">error;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s3">throw new </span><span class="s1">Error(</span>
      <span class="s2">&quot;clearCaughtError was called but no error was captured. This error &quot; </span><span class="s1">+</span>
        <span class="s2">&quot;is likely caused by a bug in React. Please file an issue.&quot;</span>
    <span class="s1">);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">isArrayImpl = Array.isArray; </span><span class="s0">// eslint-disable-next-line no-redeclare</span>

<span class="s3">function </span><span class="s1">isArray(a) {</span>
  <span class="s3">return </span><span class="s1">isArrayImpl(a);</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">getFiberCurrentPropsFromNode = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">getInstanceFromNode = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">getNodeFromInstance = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s3">function </span><span class="s1">setComponentTree(</span>
  <span class="s1">getFiberCurrentPropsFromNodeImpl,</span>
  <span class="s1">getInstanceFromNodeImpl,</span>
  <span class="s1">getNodeFromInstanceImpl</span>
<span class="s1">) {</span>
  <span class="s1">getFiberCurrentPropsFromNode = getFiberCurrentPropsFromNodeImpl;</span>
  <span class="s1">getInstanceFromNode = getInstanceFromNodeImpl;</span>
  <span class="s1">getNodeFromInstance = getNodeFromInstanceImpl;</span>

  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(!getNodeFromInstance || !getInstanceFromNode) {</span>
      <span class="s1">error(</span>
        <span class="s2">&quot;EventPluginUtils.setComponentTree(...): Injected &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;module is missing getNodeFromInstance or getInstanceFromNode.&quot;</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">var </span><span class="s1">validateEventDispatches;</span>

<span class="s1">{</span>
  <span class="s1">validateEventDispatches = </span><span class="s3">function</span><span class="s1">(event) {</span>
    <span class="s3">var </span><span class="s1">dispatchListeners = event._dispatchListeners;</span>
    <span class="s3">var </span><span class="s1">dispatchInstances = event._dispatchInstances;</span>
    <span class="s3">var </span><span class="s1">listenersIsArr = isArray(dispatchListeners);</span>
    <span class="s3">var </span><span class="s1">listenersLen = listenersIsArr</span>
      <span class="s1">? dispatchListeners.length</span>
      <span class="s1">: dispatchListeners</span>
      <span class="s1">? </span><span class="s4">1</span>
      <span class="s1">: </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">instancesIsArr = isArray(dispatchInstances);</span>
    <span class="s3">var </span><span class="s1">instancesLen = instancesIsArr</span>
      <span class="s1">? dispatchInstances.length</span>
      <span class="s1">: dispatchInstances</span>
      <span class="s1">? </span><span class="s4">1</span>
      <span class="s1">: </span><span class="s4">0</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s1">(instancesIsArr !== listenersIsArr || instancesLen !== listenersLen) {</span>
      <span class="s1">error(</span><span class="s2">&quot;EventPluginUtils: Invalid `event`.&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">};</span>
<span class="s1">}</span>
<span class="s0">/** 
 * Dispatch the event to the listener. 
 * @param {SyntheticEvent} event SyntheticEvent to handle 
 * @param {function} listener Application-level callback 
 * @param {*} inst Internal component instance 
 */</span>

<span class="s3">function </span><span class="s1">executeDispatch(event, listener, inst) {</span>
  <span class="s3">var </span><span class="s1">type = event.type || </span><span class="s2">&quot;unknown-event&quot;</span><span class="s1">;</span>
  <span class="s1">event.currentTarget = getNodeFromInstance(inst);</span>
  <span class="s1">invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);</span>
  <span class="s1">event.currentTarget = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s0">/** 
 * Standard/simple iteration through an event's collected dispatches. 
 */</span>

<span class="s3">function </span><span class="s1">executeDispatchesInOrder(event) {</span>
  <span class="s3">var </span><span class="s1">dispatchListeners = event._dispatchListeners;</span>
  <span class="s3">var </span><span class="s1">dispatchInstances = event._dispatchInstances;</span>

  <span class="s1">{</span>
    <span class="s1">validateEventDispatches(event);</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(isArray(dispatchListeners)) {</span>
    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; dispatchListeners.length; i++) {</span>
      <span class="s3">if </span><span class="s1">(event.isPropagationStopped()) {</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// Listeners and Instances are two parallel arrays that are always in sync.</span>

      <span class="s1">executeDispatch(event, dispatchListeners[i], dispatchInstances[i]);</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(dispatchListeners) {</span>
    <span class="s1">executeDispatch(event, dispatchListeners, dispatchInstances);</span>
  <span class="s1">}</span>

  <span class="s1">event._dispatchListeners = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">event._dispatchInstances = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s0">/** 
 * Standard/simple iteration through an event's collected dispatches, but stops 
 * at the first dispatch execution returning true, and returns that id. 
 * 
 * @return {?string} id of the first dispatch execution who's listener returns 
 * true, or null if no listener returned true. 
 */</span>

<span class="s3">function </span><span class="s1">executeDispatchesInOrderStopAtTrueImpl(event) {</span>
  <span class="s3">var </span><span class="s1">dispatchListeners = event._dispatchListeners;</span>
  <span class="s3">var </span><span class="s1">dispatchInstances = event._dispatchInstances;</span>

  <span class="s1">{</span>
    <span class="s1">validateEventDispatches(event);</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(isArray(dispatchListeners)) {</span>
    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; dispatchListeners.length; i++) {</span>
      <span class="s3">if </span><span class="s1">(event.isPropagationStopped()) {</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// Listeners and Instances are two parallel arrays that are always in sync.</span>

      <span class="s3">if </span><span class="s1">(dispatchListeners[i](event, dispatchInstances[i])) {</span>
        <span class="s3">return </span><span class="s1">dispatchInstances[i];</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(dispatchListeners) {</span>
    <span class="s3">if </span><span class="s1">(dispatchListeners(event, dispatchInstances)) {</span>
      <span class="s3">return </span><span class="s1">dispatchInstances;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">return null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s0">/** 
 * @see executeDispatchesInOrderStopAtTrueImpl 
 */</span>

<span class="s3">function </span><span class="s1">executeDispatchesInOrderStopAtTrue(event) {</span>
  <span class="s3">var </span><span class="s1">ret = executeDispatchesInOrderStopAtTrueImpl(event);</span>
  <span class="s1">event._dispatchInstances = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">event._dispatchListeners = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">return </span><span class="s1">ret;</span>
<span class="s1">}</span>
<span class="s0">/** 
 * Execution of a &quot;direct&quot; dispatch - there must be at most one dispatch 
 * accumulated on the event or it is considered an error. It doesn't really make 
 * sense for an event with multiple dispatches (bubbled) to keep track of the 
 * return values at each dispatch execution, but it does tend to make sense when 
 * dealing with &quot;direct&quot; dispatches. 
 * 
 * @return {*} The return value of executing the single dispatch. 
 */</span>

<span class="s3">function </span><span class="s1">executeDirectDispatch(event) {</span>
  <span class="s1">{</span>
    <span class="s1">validateEventDispatches(event);</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">dispatchListener = event._dispatchListeners;</span>
  <span class="s3">var </span><span class="s1">dispatchInstance = event._dispatchInstances;</span>

  <span class="s3">if </span><span class="s1">(isArray(dispatchListener)) {</span>
    <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;executeDirectDispatch(...): Invalid `event`.&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s1">event.currentTarget = dispatchListener</span>
    <span class="s1">? getNodeFromInstance(dispatchInstance)</span>
    <span class="s1">: </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">res = dispatchListener ? dispatchListener(event) : </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">event.currentTarget = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">event._dispatchListeners = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">event._dispatchInstances = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">return </span><span class="s1">res;</span>
<span class="s1">}</span>
<span class="s0">/** 
 * @param {SyntheticEvent} event 
 * @return {boolean} True iff number of dispatches accumulated is greater than 0. 
 */</span>

<span class="s3">function </span><span class="s1">hasDispatches(event) {</span>
  <span class="s3">return </span><span class="s1">!!event._dispatchListeners;</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">assign = Object.assign;</span>

<span class="s3">var </span><span class="s1">EVENT_POOL_SIZE = </span><span class="s4">10</span><span class="s1">;</span>
<span class="s0">/** 
 * @interface Event 
 * @see http://www.w3.org/TR/DOM-Level-3-Events/ 
 */</span>

<span class="s3">var </span><span class="s1">EventInterface = {</span>
  <span class="s1">type: </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">target: </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s0">// currentTarget is set when dispatching; no use in copying it here</span>
  <span class="s1">currentTarget: </span><span class="s3">function</span><span class="s1">() {</span>
    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">},</span>
  <span class="s1">eventPhase: </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">bubbles: </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">cancelable: </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">timeStamp: </span><span class="s3">function</span><span class="s1">(event) {</span>
    <span class="s3">return </span><span class="s1">event.timeStamp || Date.now();</span>
  <span class="s1">},</span>
  <span class="s1">defaultPrevented: </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">isTrusted: </span><span class="s3">null</span>
<span class="s1">};</span>

<span class="s3">function </span><span class="s1">functionThatReturnsTrue() {</span>
  <span class="s3">return true</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">functionThatReturnsFalse() {</span>
  <span class="s3">return false</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s0">/** 
 * Synthetic events are dispatched by event plugins, typically in response to a 
 * top-level event delegation handler. 
 * 
 * These systems should generally use pooling to reduce the frequency of garbage 
 * collection. The system should check `isPersistent` to determine whether the 
 * event should be released into the pool after being dispatched. Users that 
 * need a persisted event should invoke `persist`. 
 * 
 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by 
 * normalizing browser quirks. Subclasses do not necessarily have to implement a 
 * DOM interface; custom application-specific events can also subclass this. 
 * 
 * @param {object} dispatchConfig Configuration used to dispatch this event. 
 * @param {*} targetInst Marker identifying the event target. 
 * @param {object} nativeEvent Native browser event. 
 * @param {DOMEventTarget} nativeEventTarget Target node. 
 */</span>

<span class="s3">function </span><span class="s1">SyntheticEvent(</span>
  <span class="s1">dispatchConfig,</span>
  <span class="s1">targetInst,</span>
  <span class="s1">nativeEvent,</span>
  <span class="s1">nativeEventTarget</span>
<span class="s1">) {</span>
  <span class="s1">{</span>
    <span class="s0">// these have a getter/setter for warnings</span>
    <span class="s3">delete this</span><span class="s1">.nativeEvent;</span>
    <span class="s3">delete this</span><span class="s1">.preventDefault;</span>
    <span class="s3">delete this</span><span class="s1">.stopPropagation;</span>
    <span class="s3">delete this</span><span class="s1">.isDefaultPrevented;</span>
    <span class="s3">delete this</span><span class="s1">.isPropagationStopped;</span>
  <span class="s1">}</span>

  <span class="s3">this</span><span class="s1">.dispatchConfig = dispatchConfig;</span>
  <span class="s3">this</span><span class="s1">._targetInst = targetInst;</span>
  <span class="s3">this</span><span class="s1">.nativeEvent = nativeEvent;</span>
  <span class="s3">this</span><span class="s1">._dispatchListeners = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">._dispatchInstances = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">Interface = </span><span class="s3">this</span><span class="s1">.constructor.Interface;</span>

  <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">propName </span><span class="s3">in </span><span class="s1">Interface) {</span>
    <span class="s3">if </span><span class="s1">(!Interface.hasOwnProperty(propName)) {</span>
      <span class="s3">continue</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s3">delete this</span><span class="s1">[propName]; </span><span class="s0">// this has a getter/setter for warnings</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">normalize = Interface[propName];</span>

    <span class="s3">if </span><span class="s1">(normalize) {</span>
      <span class="s3">this</span><span class="s1">[propName] = normalize(nativeEvent);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(propName === </span><span class="s2">&quot;target&quot;</span><span class="s1">) {</span>
        <span class="s3">this</span><span class="s1">.target = nativeEventTarget;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s3">this</span><span class="s1">[propName] = nativeEvent[propName];</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">defaultPrevented =</span>
    <span class="s1">nativeEvent.defaultPrevented != </span><span class="s3">null</span>
      <span class="s1">? nativeEvent.defaultPrevented</span>
      <span class="s1">: nativeEvent.returnValue === </span><span class="s3">false</span><span class="s1">;</span>

  <span class="s3">if </span><span class="s1">(defaultPrevented) {</span>
    <span class="s3">this</span><span class="s1">.isDefaultPrevented = functionThatReturnsTrue;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s3">this</span><span class="s1">.isDefaultPrevented = functionThatReturnsFalse;</span>
  <span class="s1">}</span>

  <span class="s3">this</span><span class="s1">.isPropagationStopped = functionThatReturnsFalse;</span>
  <span class="s3">return this</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s1">assign(SyntheticEvent.prototype, {</span>
  <span class="s1">preventDefault: </span><span class="s3">function</span><span class="s1">() {</span>
    <span class="s3">this</span><span class="s1">.defaultPrevented = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">event = </span><span class="s3">this</span><span class="s1">.nativeEvent;</span>

    <span class="s3">if </span><span class="s1">(!event) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(event.preventDefault) {</span>
      <span class="s1">event.preventDefault();</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">event.returnValue !== </span><span class="s2">&quot;unknown&quot;</span><span class="s1">) {</span>
      <span class="s1">event.returnValue = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">this</span><span class="s1">.isDefaultPrevented = functionThatReturnsTrue;</span>
  <span class="s1">},</span>
  <span class="s1">stopPropagation: </span><span class="s3">function</span><span class="s1">() {</span>
    <span class="s3">var </span><span class="s1">event = </span><span class="s3">this</span><span class="s1">.nativeEvent;</span>

    <span class="s3">if </span><span class="s1">(!event) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(event.stopPropagation) {</span>
      <span class="s1">event.stopPropagation();</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">event.cancelBubble !== </span><span class="s2">&quot;unknown&quot;</span><span class="s1">) {</span>
      <span class="s0">// The ChangeEventPlugin registers a &quot;propertychange&quot; event for</span>
      <span class="s0">// IE. This event does not support bubbling or cancelling, and</span>
      <span class="s0">// any references to cancelBubble throw &quot;Member not found&quot;.  A</span>
      <span class="s0">// typeof check of &quot;unknown&quot; circumvents this issue (and is also</span>
      <span class="s0">// IE specific).</span>
      <span class="s1">event.cancelBubble = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">this</span><span class="s1">.isPropagationStopped = functionThatReturnsTrue;</span>
  <span class="s1">},</span>

  <span class="s0">/** 
   * We release all dispatched `SyntheticEvent`s after each event loop, adding 
   * them back into the pool. This allows a way to hold onto a reference that 
   * won't be added back into the pool. 
   */</span>
  <span class="s1">persist: </span><span class="s3">function</span><span class="s1">() {</span>
    <span class="s3">this</span><span class="s1">.isPersistent = functionThatReturnsTrue;</span>
  <span class="s1">},</span>

  <span class="s0">/** 
   * Checks if this event should be released back into the pool. 
   * 
   * @return {boolean} True if this should not be released, false otherwise. 
   */</span>
  <span class="s1">isPersistent: functionThatReturnsFalse,</span>

  <span class="s0">/** 
   * `PooledClass` looks for `destructor` on each instance it releases. 
   */</span>
  <span class="s1">destructor: </span><span class="s3">function</span><span class="s1">() {</span>
    <span class="s3">var </span><span class="s1">Interface = </span><span class="s3">this</span><span class="s1">.constructor.Interface;</span>

    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">propName </span><span class="s3">in </span><span class="s1">Interface) {</span>
      <span class="s1">{</span>
        <span class="s1">Object.defineProperty(</span>
          <span class="s3">this</span><span class="s1">,</span>
          <span class="s1">propName,</span>
          <span class="s1">getPooledWarningPropertyDefinition(propName, Interface[propName])</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">this</span><span class="s1">.dispatchConfig = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s1">._targetInst = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s1">.nativeEvent = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s1">.isDefaultPrevented = functionThatReturnsFalse;</span>
    <span class="s3">this</span><span class="s1">.isPropagationStopped = functionThatReturnsFalse;</span>
    <span class="s3">this</span><span class="s1">._dispatchListeners = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s1">._dispatchInstances = </span><span class="s3">null</span><span class="s1">;</span>

    <span class="s1">{</span>
      <span class="s1">Object.defineProperty(</span>
        <span class="s3">this</span><span class="s1">,</span>
        <span class="s2">&quot;nativeEvent&quot;</span><span class="s1">,</span>
        <span class="s1">getPooledWarningPropertyDefinition(</span><span class="s2">&quot;nativeEvent&quot;</span><span class="s1">, </span><span class="s3">null</span><span class="s1">)</span>
      <span class="s1">);</span>
      <span class="s1">Object.defineProperty(</span>
        <span class="s3">this</span><span class="s1">,</span>
        <span class="s2">&quot;isDefaultPrevented&quot;</span><span class="s1">,</span>
        <span class="s1">getPooledWarningPropertyDefinition(</span>
          <span class="s2">&quot;isDefaultPrevented&quot;</span><span class="s1">,</span>
          <span class="s1">functionThatReturnsFalse</span>
        <span class="s1">)</span>
      <span class="s1">);</span>
      <span class="s1">Object.defineProperty(</span>
        <span class="s3">this</span><span class="s1">,</span>
        <span class="s2">&quot;isPropagationStopped&quot;</span><span class="s1">,</span>
        <span class="s1">getPooledWarningPropertyDefinition(</span>
          <span class="s2">&quot;isPropagationStopped&quot;</span><span class="s1">,</span>
          <span class="s1">functionThatReturnsFalse</span>
        <span class="s1">)</span>
      <span class="s1">);</span>
      <span class="s1">Object.defineProperty(</span>
        <span class="s3">this</span><span class="s1">,</span>
        <span class="s2">&quot;preventDefault&quot;</span><span class="s1">,</span>
        <span class="s1">getPooledWarningPropertyDefinition(</span><span class="s2">&quot;preventDefault&quot;</span><span class="s1">, </span><span class="s3">function</span><span class="s1">() {})</span>
      <span class="s1">);</span>
      <span class="s1">Object.defineProperty(</span>
        <span class="s3">this</span><span class="s1">,</span>
        <span class="s2">&quot;stopPropagation&quot;</span><span class="s1">,</span>
        <span class="s1">getPooledWarningPropertyDefinition(</span><span class="s2">&quot;stopPropagation&quot;</span><span class="s1">, </span><span class="s3">function</span><span class="s1">() {})</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">});</span>
<span class="s1">SyntheticEvent.Interface = EventInterface;</span>
<span class="s0">/** 
 * Helper to reduce boilerplate when creating subclasses. 
 */</span>

<span class="s1">SyntheticEvent.extend = </span><span class="s3">function</span><span class="s1">(Interface) {</span>
  <span class="s3">var </span><span class="s1">Super = </span><span class="s3">this</span><span class="s1">;</span>

  <span class="s3">var </span><span class="s1">E = </span><span class="s3">function</span><span class="s1">() {};</span>

  <span class="s1">E.prototype = Super.prototype;</span>
  <span class="s3">var </span><span class="s1">prototype = </span><span class="s3">new </span><span class="s1">E();</span>

  <span class="s3">function </span><span class="s1">Class() {</span>
    <span class="s3">return </span><span class="s1">Super.apply(</span><span class="s3">this</span><span class="s1">, arguments);</span>
  <span class="s1">}</span>

  <span class="s1">assign(prototype, Class.prototype);</span>
  <span class="s1">Class.prototype = prototype;</span>
  <span class="s1">Class.prototype.constructor = Class;</span>
  <span class="s1">Class.Interface = assign({}, Super.Interface, Interface);</span>
  <span class="s1">Class.extend = Super.extend;</span>
  <span class="s1">addEventPoolingTo(Class);</span>
  <span class="s3">return </span><span class="s1">Class;</span>
<span class="s1">};</span>

<span class="s1">addEventPoolingTo(SyntheticEvent);</span>
<span class="s0">/** 
 * Helper to nullify syntheticEvent instance properties when destructing 
 * 
 * @param {String} propName 
 * @param {?object} getVal 
 * @return {object} defineProperty object 
 */</span>

<span class="s3">function </span><span class="s1">getPooledWarningPropertyDefinition(propName, getVal) {</span>
  <span class="s3">function </span><span class="s1">set(val) {</span>
    <span class="s3">var </span><span class="s1">action = isFunction ? </span><span class="s2">&quot;setting the method&quot; </span><span class="s1">: </span><span class="s2">&quot;setting the property&quot;</span><span class="s1">;</span>
    <span class="s1">warn(action, </span><span class="s2">&quot;This is effectively a no-op&quot;</span><span class="s1">);</span>
    <span class="s3">return </span><span class="s1">val;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">get() {</span>
    <span class="s3">var </span><span class="s1">action = isFunction ? </span><span class="s2">&quot;accessing the method&quot; </span><span class="s1">: </span><span class="s2">&quot;accessing the property&quot;</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">result = isFunction</span>
      <span class="s1">? </span><span class="s2">&quot;This is a no-op function&quot;</span>
      <span class="s1">: </span><span class="s2">&quot;This is set to null&quot;</span><span class="s1">;</span>
    <span class="s1">warn(action, result);</span>
    <span class="s3">return </span><span class="s1">getVal;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">warn(action, result) {</span>
    <span class="s1">{</span>
      <span class="s1">error(</span>
        <span class="s2">&quot;This synthetic event is reused for performance reasons. If you're seeing this, &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;you're %s `%s` on a released/nullified synthetic event. %s. &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;If you must keep the original synthetic event around, use event.persist(). &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;See https://reactjs.org/link/event-pooling for more information.&quot;</span><span class="s1">,</span>
        <span class="s1">action,</span>
        <span class="s1">propName,</span>
        <span class="s1">result</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">isFunction = </span><span class="s3">typeof </span><span class="s1">getVal === </span><span class="s2">&quot;function&quot;</span><span class="s1">;</span>
  <span class="s3">return </span><span class="s1">{</span>
    <span class="s1">configurable: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">set: set,</span>
    <span class="s1">get: get</span>
  <span class="s1">};</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">createOrGetPooledEvent(</span>
  <span class="s1">dispatchConfig,</span>
  <span class="s1">targetInst,</span>
  <span class="s1">nativeEvent,</span>
  <span class="s1">nativeInst</span>
<span class="s1">) {</span>
  <span class="s3">var </span><span class="s1">EventConstructor = </span><span class="s3">this</span><span class="s1">;</span>

  <span class="s3">if </span><span class="s1">(EventConstructor.eventPool.length) {</span>
    <span class="s3">var </span><span class="s1">instance = EventConstructor.eventPool.pop();</span>
    <span class="s1">EventConstructor.call(</span>
      <span class="s1">instance,</span>
      <span class="s1">dispatchConfig,</span>
      <span class="s1">targetInst,</span>
      <span class="s1">nativeEvent,</span>
      <span class="s1">nativeInst</span>
    <span class="s1">);</span>
    <span class="s3">return </span><span class="s1">instance;</span>
  <span class="s1">}</span>

  <span class="s3">return new </span><span class="s1">EventConstructor(</span>
    <span class="s1">dispatchConfig,</span>
    <span class="s1">targetInst,</span>
    <span class="s1">nativeEvent,</span>
    <span class="s1">nativeInst</span>
  <span class="s1">);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">releasePooledEvent(event) {</span>
  <span class="s3">var </span><span class="s1">EventConstructor = </span><span class="s3">this</span><span class="s1">;</span>

  <span class="s3">if </span><span class="s1">(!(event </span><span class="s3">instanceof </span><span class="s1">EventConstructor)) {</span>
    <span class="s3">throw new </span><span class="s1">Error(</span>
      <span class="s2">&quot;Trying to release an event instance into a pool of a different type.&quot;</span>
    <span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s1">event.destructor();</span>

  <span class="s3">if </span><span class="s1">(EventConstructor.eventPool.length &lt; EVENT_POOL_SIZE) {</span>
    <span class="s1">EventConstructor.eventPool.push(event);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">addEventPoolingTo(EventConstructor) {</span>
  <span class="s1">EventConstructor.getPooled = createOrGetPooledEvent;</span>
  <span class="s1">EventConstructor.eventPool = [];</span>
  <span class="s1">EventConstructor.release = releasePooledEvent;</span>
<span class="s1">}</span>

<span class="s0">/** 
 * `touchHistory` isn't actually on the native event, but putting it in the 
 * interface will ensure that it is cleaned up when pooled/destroyed. The 
 * `ResponderEventPlugin` will populate it appropriately. 
 */</span>

<span class="s3">var </span><span class="s1">ResponderSyntheticEvent = SyntheticEvent.extend({</span>
  <span class="s1">touchHistory: </span><span class="s3">function</span><span class="s1">(nativeEvent) {</span>
    <span class="s3">return null</span><span class="s1">; </span><span class="s0">// Actually doesn't even look at the native event.</span>
  <span class="s1">}</span>
<span class="s1">});</span>

<span class="s3">var </span><span class="s1">TOP_TOUCH_START = </span><span class="s2">&quot;topTouchStart&quot;</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">TOP_TOUCH_MOVE = </span><span class="s2">&quot;topTouchMove&quot;</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">TOP_TOUCH_END = </span><span class="s2">&quot;topTouchEnd&quot;</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">TOP_TOUCH_CANCEL = </span><span class="s2">&quot;topTouchCancel&quot;</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">TOP_SCROLL = </span><span class="s2">&quot;topScroll&quot;</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">TOP_SELECTION_CHANGE = </span><span class="s2">&quot;topSelectionChange&quot;</span><span class="s1">;</span>
<span class="s3">function </span><span class="s1">isStartish(topLevelType) {</span>
  <span class="s3">return </span><span class="s1">topLevelType === TOP_TOUCH_START;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">isMoveish(topLevelType) {</span>
  <span class="s3">return </span><span class="s1">topLevelType === TOP_TOUCH_MOVE;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">isEndish(topLevelType) {</span>
  <span class="s3">return </span><span class="s1">topLevelType === TOP_TOUCH_END || topLevelType === TOP_TOUCH_CANCEL;</span>
<span class="s1">}</span>
<span class="s3">var </span><span class="s1">startDependencies = [TOP_TOUCH_START];</span>
<span class="s3">var </span><span class="s1">moveDependencies = [TOP_TOUCH_MOVE];</span>
<span class="s3">var </span><span class="s1">endDependencies = [TOP_TOUCH_CANCEL, TOP_TOUCH_END];</span>

<span class="s0">/** 
 * Tracks the position and time of each active touch by `touch.identifier`. We 
 * should typically only see IDs in the range of 1-20 because IDs get recycled 
 * when touches end and start again. 
 */</span>

<span class="s3">var </span><span class="s1">MAX_TOUCH_BANK = </span><span class="s4">20</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">touchBank = [];</span>
<span class="s3">var </span><span class="s1">touchHistory = {</span>
  <span class="s1">touchBank: touchBank,</span>
  <span class="s1">numberActiveTouches: </span><span class="s4">0</span><span class="s1">,</span>
  <span class="s0">// If there is only one active touch, we remember its location. This prevents</span>
  <span class="s0">// us having to loop through all of the touches all the time in the most</span>
  <span class="s0">// common case.</span>
  <span class="s1">indexOfSingleActiveTouch: -</span><span class="s4">1</span><span class="s1">,</span>
  <span class="s1">mostRecentTimeStamp: </span><span class="s4">0</span>
<span class="s1">};</span>

<span class="s3">function </span><span class="s1">timestampForTouch(touch) {</span>
  <span class="s0">// The legacy internal implementation provides &quot;timeStamp&quot;, which has been</span>
  <span class="s0">// renamed to &quot;timestamp&quot;. Let both work for now while we iron it out</span>
  <span class="s0">// TODO (evv): rename timeStamp to timestamp in internal code</span>
  <span class="s3">return </span><span class="s1">touch.timeStamp || touch.timestamp;</span>
<span class="s1">}</span>
<span class="s0">/** 
 * TODO: Instead of making gestures recompute filtered velocity, we could 
 * include a built in velocity computation that can be reused globally. 
 */</span>

<span class="s3">function </span><span class="s1">createTouchRecord(touch) {</span>
  <span class="s3">return </span><span class="s1">{</span>
    <span class="s1">touchActive: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">startPageX: touch.pageX,</span>
    <span class="s1">startPageY: touch.pageY,</span>
    <span class="s1">startTimeStamp: timestampForTouch(touch),</span>
    <span class="s1">currentPageX: touch.pageX,</span>
    <span class="s1">currentPageY: touch.pageY,</span>
    <span class="s1">currentTimeStamp: timestampForTouch(touch),</span>
    <span class="s1">previousPageX: touch.pageX,</span>
    <span class="s1">previousPageY: touch.pageY,</span>
    <span class="s1">previousTimeStamp: timestampForTouch(touch)</span>
  <span class="s1">};</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">resetTouchRecord(touchRecord, touch) {</span>
  <span class="s1">touchRecord.touchActive = </span><span class="s3">true</span><span class="s1">;</span>
  <span class="s1">touchRecord.startPageX = touch.pageX;</span>
  <span class="s1">touchRecord.startPageY = touch.pageY;</span>
  <span class="s1">touchRecord.startTimeStamp = timestampForTouch(touch);</span>
  <span class="s1">touchRecord.currentPageX = touch.pageX;</span>
  <span class="s1">touchRecord.currentPageY = touch.pageY;</span>
  <span class="s1">touchRecord.currentTimeStamp = timestampForTouch(touch);</span>
  <span class="s1">touchRecord.previousPageX = touch.pageX;</span>
  <span class="s1">touchRecord.previousPageY = touch.pageY;</span>
  <span class="s1">touchRecord.previousTimeStamp = timestampForTouch(touch);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">getTouchIdentifier(_ref) {</span>
  <span class="s3">var </span><span class="s1">identifier = _ref.identifier;</span>

  <span class="s3">if </span><span class="s1">(identifier == </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Touch object is missing identifier.&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(identifier &gt; MAX_TOUCH_BANK) {</span>
      <span class="s1">error(</span>
        <span class="s2">&quot;Touch identifier %s is greater than maximum supported %s which causes &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;performance issues backfilling array locations for all of the indices.&quot;</span><span class="s1">,</span>
        <span class="s1">identifier,</span>
        <span class="s1">MAX_TOUCH_BANK</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">identifier;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">recordTouchStart(touch) {</span>
  <span class="s3">var </span><span class="s1">identifier = getTouchIdentifier(touch);</span>
  <span class="s3">var </span><span class="s1">touchRecord = touchBank[identifier];</span>

  <span class="s3">if </span><span class="s1">(touchRecord) {</span>
    <span class="s1">resetTouchRecord(touchRecord, touch);</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">touchBank[identifier] = createTouchRecord(touch);</span>
  <span class="s1">}</span>

  <span class="s1">touchHistory.mostRecentTimeStamp = timestampForTouch(touch);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">recordTouchMove(touch) {</span>
  <span class="s3">var </span><span class="s1">touchRecord = touchBank[getTouchIdentifier(touch)];</span>

  <span class="s3">if </span><span class="s1">(touchRecord) {</span>
    <span class="s1">touchRecord.touchActive = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">touchRecord.previousPageX = touchRecord.currentPageX;</span>
    <span class="s1">touchRecord.previousPageY = touchRecord.currentPageY;</span>
    <span class="s1">touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;</span>
    <span class="s1">touchRecord.currentPageX = touch.pageX;</span>
    <span class="s1">touchRecord.currentPageY = touch.pageY;</span>
    <span class="s1">touchRecord.currentTimeStamp = timestampForTouch(touch);</span>
    <span class="s1">touchHistory.mostRecentTimeStamp = timestampForTouch(touch);</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">{</span>
      <span class="s1">warn(</span>
        <span class="s2">&quot;Cannot record touch move without a touch start.</span><span class="s5">\n</span><span class="s2">&quot; </span><span class="s1">+</span>
          <span class="s2">&quot;Touch Move: %s</span><span class="s5">\n</span><span class="s2">&quot; </span><span class="s1">+</span>
          <span class="s2">&quot;Touch Bank: %s&quot;</span><span class="s1">,</span>
        <span class="s1">printTouch(touch),</span>
        <span class="s1">printTouchBank()</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">recordTouchEnd(touch) {</span>
  <span class="s3">var </span><span class="s1">touchRecord = touchBank[getTouchIdentifier(touch)];</span>

  <span class="s3">if </span><span class="s1">(touchRecord) {</span>
    <span class="s1">touchRecord.touchActive = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">touchRecord.previousPageX = touchRecord.currentPageX;</span>
    <span class="s1">touchRecord.previousPageY = touchRecord.currentPageY;</span>
    <span class="s1">touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;</span>
    <span class="s1">touchRecord.currentPageX = touch.pageX;</span>
    <span class="s1">touchRecord.currentPageY = touch.pageY;</span>
    <span class="s1">touchRecord.currentTimeStamp = timestampForTouch(touch);</span>
    <span class="s1">touchHistory.mostRecentTimeStamp = timestampForTouch(touch);</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">{</span>
      <span class="s1">warn(</span>
        <span class="s2">&quot;Cannot record touch end without a touch start.</span><span class="s5">\n</span><span class="s2">&quot; </span><span class="s1">+</span>
          <span class="s2">&quot;Touch End: %s</span><span class="s5">\n</span><span class="s2">&quot; </span><span class="s1">+</span>
          <span class="s2">&quot;Touch Bank: %s&quot;</span><span class="s1">,</span>
        <span class="s1">printTouch(touch),</span>
        <span class="s1">printTouchBank()</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">printTouch(touch) {</span>
  <span class="s3">return </span><span class="s1">JSON.stringify({</span>
    <span class="s1">identifier: touch.identifier,</span>
    <span class="s1">pageX: touch.pageX,</span>
    <span class="s1">pageY: touch.pageY,</span>
    <span class="s1">timestamp: timestampForTouch(touch)</span>
  <span class="s1">});</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">printTouchBank() {</span>
  <span class="s3">var </span><span class="s1">printed = JSON.stringify(touchBank.slice(</span><span class="s4">0</span><span class="s1">, MAX_TOUCH_BANK));</span>

  <span class="s3">if </span><span class="s1">(touchBank.length &gt; MAX_TOUCH_BANK) {</span>
    <span class="s1">printed += </span><span class="s2">&quot; (original size: &quot; </span><span class="s1">+ touchBank.length + </span><span class="s2">&quot;)&quot;</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">printed;</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">instrumentationCallback;</span>
<span class="s3">var </span><span class="s1">ResponderTouchHistoryStore = {</span>
  <span class="s0">/** 
   * Registers a listener which can be used to instrument every touch event. 
   */</span>
  <span class="s1">instrument: </span><span class="s3">function</span><span class="s1">(callback) {</span>
    <span class="s1">instrumentationCallback = callback;</span>
  <span class="s1">},</span>
  <span class="s1">recordTouchTrack: </span><span class="s3">function</span><span class="s1">(topLevelType, nativeEvent) {</span>
    <span class="s3">if </span><span class="s1">(instrumentationCallback != </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">instrumentationCallback(topLevelType, nativeEvent);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(isMoveish(topLevelType)) {</span>
      <span class="s1">nativeEvent.changedTouches.forEach(recordTouchMove);</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(isStartish(topLevelType)) {</span>
      <span class="s1">nativeEvent.changedTouches.forEach(recordTouchStart);</span>
      <span class="s1">touchHistory.numberActiveTouches = nativeEvent.touches.length;</span>

      <span class="s3">if </span><span class="s1">(touchHistory.numberActiveTouches === </span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s1">touchHistory.indexOfSingleActiveTouch =</span>
          <span class="s1">nativeEvent.touches[</span><span class="s4">0</span><span class="s1">].identifier;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(isEndish(topLevelType)) {</span>
      <span class="s1">nativeEvent.changedTouches.forEach(recordTouchEnd);</span>
      <span class="s1">touchHistory.numberActiveTouches = nativeEvent.touches.length;</span>

      <span class="s3">if </span><span class="s1">(touchHistory.numberActiveTouches === </span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; touchBank.length; i++) {</span>
          <span class="s3">var </span><span class="s1">touchTrackToCheck = touchBank[i];</span>

          <span class="s3">if </span><span class="s1">(touchTrackToCheck != </span><span class="s3">null </span><span class="s1">&amp;&amp; touchTrackToCheck.touchActive) {</span>
            <span class="s1">touchHistory.indexOfSingleActiveTouch = i;</span>
            <span class="s3">break</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s1">{</span>
          <span class="s3">var </span><span class="s1">activeRecord = touchBank[touchHistory.indexOfSingleActiveTouch];</span>

          <span class="s3">if </span><span class="s1">(activeRecord == </span><span class="s3">null </span><span class="s1">|| !activeRecord.touchActive) {</span>
            <span class="s1">error(</span><span class="s2">&quot;Cannot find single active touch.&quot;</span><span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">},</span>
  <span class="s1">touchHistory: touchHistory</span>
<span class="s1">};</span>

<span class="s0">/** 
 * Accumulates items that must not be null or undefined. 
 * 
 * This is used to conserve memory by avoiding array allocations. 
 * 
 * @return {*|array&lt;*&gt;} An accumulation of items. 
 */</span>

<span class="s3">function </span><span class="s1">accumulate(current, next) {</span>
  <span class="s3">if </span><span class="s1">(next == </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">throw new </span><span class="s1">Error(</span>
      <span class="s2">&quot;accumulate(...): Accumulated items must not be null or undefined.&quot;</span>
    <span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(current == </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">return </span><span class="s1">next;</span>
  <span class="s1">} </span><span class="s0">// Both are not empty. Warning: Never call x.concat(y) when you are not</span>
  <span class="s0">// certain that x is an Array (x could be a string with concat method).</span>

  <span class="s3">if </span><span class="s1">(isArray(current)) {</span>
    <span class="s3">return </span><span class="s1">current.concat(next);</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(isArray(next)) {</span>
    <span class="s3">return </span><span class="s1">[current].concat(next);</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">[current, next];</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Accumulates items that must not be null or undefined into the first one. This 
 * is used to conserve memory by avoiding array allocations, and thus sacrifices 
 * API cleanness. Since `current` can be null before being passed in and not 
 * null after this function, make sure to assign it back to `current`: 
 * 
 * `a = accumulateInto(a, b);` 
 * 
 * This API should be sparingly used. Try `accumulate` for something cleaner. 
 * 
 * @return {*|array&lt;*&gt;} An accumulation of items. 
 */</span>

<span class="s3">function </span><span class="s1">accumulateInto(current, next) {</span>
  <span class="s3">if </span><span class="s1">(next == </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">throw new </span><span class="s1">Error(</span>
      <span class="s2">&quot;accumulateInto(...): Accumulated items must not be null or undefined.&quot;</span>
    <span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(current == </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">return </span><span class="s1">next;</span>
  <span class="s1">} </span><span class="s0">// Both are not empty. Warning: Never call x.concat(y) when you are not</span>
  <span class="s0">// certain that x is an Array (x could be a string with concat method).</span>

  <span class="s3">if </span><span class="s1">(isArray(current)) {</span>
    <span class="s3">if </span><span class="s1">(isArray(next)) {</span>
      <span class="s1">current.push.apply(current, next);</span>
      <span class="s3">return </span><span class="s1">current;</span>
    <span class="s1">}</span>

    <span class="s1">current.push(next);</span>
    <span class="s3">return </span><span class="s1">current;</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(isArray(next)) {</span>
    <span class="s0">// A bit too dangerous to mutate `next`.</span>
    <span class="s3">return </span><span class="s1">[current].concat(next);</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">[current, next];</span>
<span class="s1">}</span>

<span class="s0">/** 
 * @param {array} arr an &quot;accumulation&quot; of items which is either an Array or 
 * a single item. Useful when paired with the `accumulate` module. This is a 
 * simple utility that allows us to reason about a collection of items, but 
 * handling the case when there is exactly one item (and we do not need to 
 * allocate an array). 
 * @param {function} cb Callback invoked with each element or a collection. 
 * @param {?} [scope] Scope used as `this` in a callback. 
 */</span>
<span class="s3">function </span><span class="s1">forEachAccumulated(arr, cb, scope) {</span>
  <span class="s3">if </span><span class="s1">(Array.isArray(arr)) {</span>
    <span class="s1">arr.forEach(cb, scope);</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(arr) {</span>
    <span class="s1">cb.call(scope, arr);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">FunctionComponent = </span><span class="s4">0</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">ClassComponent = </span><span class="s4">1</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">IndeterminateComponent = </span><span class="s4">2</span><span class="s1">; </span><span class="s0">// Before we know whether it is function or class</span>

<span class="s3">var </span><span class="s1">HostRoot = </span><span class="s4">3</span><span class="s1">; </span><span class="s0">// Root of a host tree. Could be nested inside another node.</span>

<span class="s3">var </span><span class="s1">HostPortal = </span><span class="s4">4</span><span class="s1">; </span><span class="s0">// A subtree. Could be an entry point to a different renderer.</span>

<span class="s3">var </span><span class="s1">HostComponent = </span><span class="s4">5</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">HostText = </span><span class="s4">6</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">Fragment = </span><span class="s4">7</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">Mode = </span><span class="s4">8</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">ContextConsumer = </span><span class="s4">9</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">ContextProvider = </span><span class="s4">10</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">ForwardRef = </span><span class="s4">11</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">Profiler = </span><span class="s4">12</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">SuspenseComponent = </span><span class="s4">13</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">MemoComponent = </span><span class="s4">14</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">SimpleMemoComponent = </span><span class="s4">15</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">LazyComponent = </span><span class="s4">16</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">IncompleteClassComponent = </span><span class="s4">17</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">DehydratedFragment = </span><span class="s4">18</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">SuspenseListComponent = </span><span class="s4">19</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">ScopeComponent = </span><span class="s4">21</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">OffscreenComponent = </span><span class="s4">22</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">LegacyHiddenComponent = </span><span class="s4">23</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">CacheComponent = </span><span class="s4">24</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">TracingMarkerComponent = </span><span class="s4">25</span><span class="s1">;</span>

<span class="s0">/** 
 * Instance of element that should respond to touch/move types of interactions, 
 * as indicated explicitly by relevant callbacks. 
 */</span>

<span class="s3">var </span><span class="s1">responderInst = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s0">/** 
 * Count of current touches. A textInput should become responder iff the 
 * selection changes while there is a touch on the screen. 
 */</span>

<span class="s3">var </span><span class="s1">trackedTouchCount = </span><span class="s4">0</span><span class="s1">;</span>

<span class="s3">var </span><span class="s1">changeResponder = </span><span class="s3">function</span><span class="s1">(nextResponderInst, blockHostResponder) {</span>
  <span class="s3">var </span><span class="s1">oldResponderInst = responderInst;</span>
  <span class="s1">responderInst = nextResponderInst;</span>

  <span class="s3">if </span><span class="s1">(ResponderEventPlugin.GlobalResponderHandler !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s1">ResponderEventPlugin.GlobalResponderHandler.onChange(</span>
      <span class="s1">oldResponderInst,</span>
      <span class="s1">nextResponderInst,</span>
      <span class="s1">blockHostResponder</span>
    <span class="s1">);</span>
  <span class="s1">}</span>
<span class="s1">};</span>

<span class="s3">var </span><span class="s1">eventTypes = {</span>
  <span class="s0">/** 
   * On a `touchStart`/`mouseDown`, is it desired that this element become the 
   * responder? 
   */</span>
  <span class="s1">startShouldSetResponder: {</span>
    <span class="s1">phasedRegistrationNames: {</span>
      <span class="s1">bubbled: </span><span class="s2">&quot;onStartShouldSetResponder&quot;</span><span class="s1">,</span>
      <span class="s1">captured: </span><span class="s2">&quot;onStartShouldSetResponderCapture&quot;</span>
    <span class="s1">},</span>
    <span class="s1">dependencies: startDependencies</span>
  <span class="s1">},</span>

  <span class="s0">/** 
   * On a `scroll`, is it desired that this element become the responder? This 
   * is usually not needed, but should be used to retroactively infer that a 
   * `touchStart` had occurred during momentum scroll. During a momentum scroll, 
   * a touch start will be immediately followed by a scroll event if the view is 
   * currently scrolling. 
   * 
   * TODO: This shouldn't bubble. 
   */</span>
  <span class="s1">scrollShouldSetResponder: {</span>
    <span class="s1">phasedRegistrationNames: {</span>
      <span class="s1">bubbled: </span><span class="s2">&quot;onScrollShouldSetResponder&quot;</span><span class="s1">,</span>
      <span class="s1">captured: </span><span class="s2">&quot;onScrollShouldSetResponderCapture&quot;</span>
    <span class="s1">},</span>
    <span class="s1">dependencies: [TOP_SCROLL]</span>
  <span class="s1">},</span>

  <span class="s0">/** 
   * On text selection change, should this element become the responder? This 
   * is needed for text inputs or other views with native selection, so the 
   * JS view can claim the responder. 
   * 
   * TODO: This shouldn't bubble. 
   */</span>
  <span class="s1">selectionChangeShouldSetResponder: {</span>
    <span class="s1">phasedRegistrationNames: {</span>
      <span class="s1">bubbled: </span><span class="s2">&quot;onSelectionChangeShouldSetResponder&quot;</span><span class="s1">,</span>
      <span class="s1">captured: </span><span class="s2">&quot;onSelectionChangeShouldSetResponderCapture&quot;</span>
    <span class="s1">},</span>
    <span class="s1">dependencies: [TOP_SELECTION_CHANGE]</span>
  <span class="s1">},</span>

  <span class="s0">/** 
   * On a `touchMove`/`mouseMove`, is it desired that this element become the 
   * responder? 
   */</span>
  <span class="s1">moveShouldSetResponder: {</span>
    <span class="s1">phasedRegistrationNames: {</span>
      <span class="s1">bubbled: </span><span class="s2">&quot;onMoveShouldSetResponder&quot;</span><span class="s1">,</span>
      <span class="s1">captured: </span><span class="s2">&quot;onMoveShouldSetResponderCapture&quot;</span>
    <span class="s1">},</span>
    <span class="s1">dependencies: moveDependencies</span>
  <span class="s1">},</span>

  <span class="s0">/** 
   * Direct responder events dispatched directly to responder. Do not bubble. 
   */</span>
  <span class="s1">responderStart: {</span>
    <span class="s1">registrationName: </span><span class="s2">&quot;onResponderStart&quot;</span><span class="s1">,</span>
    <span class="s1">dependencies: startDependencies</span>
  <span class="s1">},</span>
  <span class="s1">responderMove: {</span>
    <span class="s1">registrationName: </span><span class="s2">&quot;onResponderMove&quot;</span><span class="s1">,</span>
    <span class="s1">dependencies: moveDependencies</span>
  <span class="s1">},</span>
  <span class="s1">responderEnd: {</span>
    <span class="s1">registrationName: </span><span class="s2">&quot;onResponderEnd&quot;</span><span class="s1">,</span>
    <span class="s1">dependencies: endDependencies</span>
  <span class="s1">},</span>
  <span class="s1">responderRelease: {</span>
    <span class="s1">registrationName: </span><span class="s2">&quot;onResponderRelease&quot;</span><span class="s1">,</span>
    <span class="s1">dependencies: endDependencies</span>
  <span class="s1">},</span>
  <span class="s1">responderTerminationRequest: {</span>
    <span class="s1">registrationName: </span><span class="s2">&quot;onResponderTerminationRequest&quot;</span><span class="s1">,</span>
    <span class="s1">dependencies: []</span>
  <span class="s1">},</span>
  <span class="s1">responderGrant: {</span>
    <span class="s1">registrationName: </span><span class="s2">&quot;onResponderGrant&quot;</span><span class="s1">,</span>
    <span class="s1">dependencies: []</span>
  <span class="s1">},</span>
  <span class="s1">responderReject: {</span>
    <span class="s1">registrationName: </span><span class="s2">&quot;onResponderReject&quot;</span><span class="s1">,</span>
    <span class="s1">dependencies: []</span>
  <span class="s1">},</span>
  <span class="s1">responderTerminate: {</span>
    <span class="s1">registrationName: </span><span class="s2">&quot;onResponderTerminate&quot;</span><span class="s1">,</span>
    <span class="s1">dependencies: []</span>
  <span class="s1">}</span>
<span class="s1">}; </span><span class="s0">// Start of inline: the below functions were inlined from</span>
<span class="s0">// EventPropagator.js, as they deviated from ReactDOM's newer</span>
<span class="s0">// implementations.</span>

<span class="s3">function </span><span class="s1">getParent(inst) {</span>
  <span class="s3">do </span><span class="s1">{</span>
    <span class="s1">inst = inst.</span><span class="s3">return</span><span class="s1">; </span><span class="s0">// TODO: If this is a HostRoot we might want to bail out.</span>
    <span class="s0">// That is depending on if we want nested subtrees (layers) to bubble</span>
    <span class="s0">// events to their parent. We could also go through parentNode on the</span>
    <span class="s0">// host node but that wouldn't work for React Native and doesn't let us</span>
    <span class="s0">// do the portal feature.</span>
  <span class="s1">} </span><span class="s3">while </span><span class="s1">(inst &amp;&amp; inst.tag !== HostComponent);</span>

  <span class="s3">if </span><span class="s1">(inst) {</span>
    <span class="s3">return </span><span class="s1">inst;</span>
  <span class="s1">}</span>

  <span class="s3">return null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s0">/** 
 * Return the lowest common ancestor of A and B, or null if they are in 
 * different trees. 
 */</span>

<span class="s3">function </span><span class="s1">getLowestCommonAncestor(instA, instB) {</span>
  <span class="s3">var </span><span class="s1">depthA = </span><span class="s4">0</span><span class="s1">;</span>

  <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">tempA = instA; tempA; tempA = getParent(tempA)) {</span>
    <span class="s1">depthA++;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">depthB = </span><span class="s4">0</span><span class="s1">;</span>

  <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">tempB = instB; tempB; tempB = getParent(tempB)) {</span>
    <span class="s1">depthB++;</span>
  <span class="s1">} </span><span class="s0">// If A is deeper, crawl up.</span>

  <span class="s3">while </span><span class="s1">(depthA - depthB &gt; </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s1">instA = getParent(instA);</span>
    <span class="s1">depthA--;</span>
  <span class="s1">} </span><span class="s0">// If B is deeper, crawl up.</span>

  <span class="s3">while </span><span class="s1">(depthB - depthA &gt; </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s1">instB = getParent(instB);</span>
    <span class="s1">depthB--;</span>
  <span class="s1">} </span><span class="s0">// Walk in lockstep until we find a match.</span>

  <span class="s3">var </span><span class="s1">depth = depthA;</span>

  <span class="s3">while </span><span class="s1">(depth--) {</span>
    <span class="s3">if </span><span class="s1">(instA === instB || instA === instB.alternate) {</span>
      <span class="s3">return </span><span class="s1">instA;</span>
    <span class="s1">}</span>

    <span class="s1">instA = getParent(instA);</span>
    <span class="s1">instB = getParent(instB);</span>
  <span class="s1">}</span>

  <span class="s3">return null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s0">/** 
 * Return if A is an ancestor of B. 
 */</span>

<span class="s3">function </span><span class="s1">isAncestor(instA, instB) {</span>
  <span class="s3">while </span><span class="s1">(instB) {</span>
    <span class="s3">if </span><span class="s1">(instA === instB || instA === instB.alternate) {</span>
      <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">instB = getParent(instB);</span>
  <span class="s1">}</span>

  <span class="s3">return false</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s0">/** 
 * Simulates the traversal of a two-phase, capture/bubble event dispatch. 
 */</span>

<span class="s3">function </span><span class="s1">traverseTwoPhase(inst, fn, arg) {</span>
  <span class="s3">var </span><span class="s1">path = [];</span>

  <span class="s3">while </span><span class="s1">(inst) {</span>
    <span class="s1">path.push(inst);</span>
    <span class="s1">inst = getParent(inst);</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">i;</span>

  <span class="s3">for </span><span class="s1">(i = path.length; i-- &gt; </span><span class="s4">0</span><span class="s1">; ) {</span>
    <span class="s1">fn(path[i], </span><span class="s2">&quot;captured&quot;</span><span class="s1">, arg);</span>
  <span class="s1">}</span>

  <span class="s3">for </span><span class="s1">(i = </span><span class="s4">0</span><span class="s1">; i &lt; path.length; i++) {</span>
    <span class="s1">fn(path[i], </span><span class="s2">&quot;bubbled&quot;</span><span class="s1">, arg);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">getListener(inst, registrationName) {</span>
  <span class="s3">var </span><span class="s1">stateNode = inst.stateNode;</span>

  <span class="s3">if </span><span class="s1">(stateNode === </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s0">// Work in progress (ex: onload events in incremental mode).</span>
    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">props = getFiberCurrentPropsFromNode(stateNode);</span>

  <span class="s3">if </span><span class="s1">(props === </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s0">// Work in progress.</span>
    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">listener = props[registrationName];</span>

  <span class="s3">if </span><span class="s1">(listener &amp;&amp; </span><span class="s3">typeof </span><span class="s1">listener !== </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
    <span class="s3">throw new </span><span class="s1">Error(</span>
      <span class="s2">&quot;Expected `&quot; </span><span class="s1">+</span>
        <span class="s1">registrationName +</span>
        <span class="s2">&quot;` listener to be a function, instead got a value of `&quot; </span><span class="s1">+</span>
        <span class="s3">typeof </span><span class="s1">listener +</span>
        <span class="s2">&quot;` type.&quot;</span>
    <span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">listener;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">listenerAtPhase(inst, event, propagationPhase) {</span>
  <span class="s3">var </span><span class="s1">registrationName =</span>
    <span class="s1">event.dispatchConfig.phasedRegistrationNames[propagationPhase];</span>
  <span class="s3">return </span><span class="s1">getListener(inst, registrationName);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">accumulateDirectionalDispatches(inst, phase, event) {</span>
  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(!inst) {</span>
      <span class="s1">error(</span><span class="s2">&quot;Dispatching inst must not be null&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">listener = listenerAtPhase(inst, event, phase);</span>

  <span class="s3">if </span><span class="s1">(listener) {</span>
    <span class="s1">event._dispatchListeners = accumulateInto(</span>
      <span class="s1">event._dispatchListeners,</span>
      <span class="s1">listener</span>
    <span class="s1">);</span>
    <span class="s1">event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">/** 
 * Accumulates without regard to direction, does not look for phased 
 * registration names. Same as `accumulateDirectDispatchesSingle` but without 
 * requiring that the `dispatchMarker` be the same as the dispatched ID. 
 */</span>

<span class="s3">function </span><span class="s1">accumulateDispatches(inst, ignoredDirection, event) {</span>
  <span class="s3">if </span><span class="s1">(inst &amp;&amp; event &amp;&amp; event.dispatchConfig.registrationName) {</span>
    <span class="s3">var </span><span class="s1">registrationName = event.dispatchConfig.registrationName;</span>
    <span class="s3">var </span><span class="s1">listener = getListener(inst, registrationName);</span>

    <span class="s3">if </span><span class="s1">(listener) {</span>
      <span class="s1">event._dispatchListeners = accumulateInto(</span>
        <span class="s1">event._dispatchListeners,</span>
        <span class="s1">listener</span>
      <span class="s1">);</span>
      <span class="s1">event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">/** 
 * Accumulates dispatches on an `SyntheticEvent`, but only for the 
 * `dispatchMarker`. 
 * @param {SyntheticEvent} event 
 */</span>

<span class="s3">function </span><span class="s1">accumulateDirectDispatchesSingle(event) {</span>
  <span class="s3">if </span><span class="s1">(event &amp;&amp; event.dispatchConfig.registrationName) {</span>
    <span class="s1">accumulateDispatches(event._targetInst, </span><span class="s3">null</span><span class="s1">, event);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">accumulateDirectDispatches(events) {</span>
  <span class="s1">forEachAccumulated(events, accumulateDirectDispatchesSingle);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">accumulateTwoPhaseDispatchesSingleSkipTarget(event) {</span>
  <span class="s3">if </span><span class="s1">(event &amp;&amp; event.dispatchConfig.phasedRegistrationNames) {</span>
    <span class="s3">var </span><span class="s1">targetInst = event._targetInst;</span>
    <span class="s3">var </span><span class="s1">parentInst = targetInst ? getParent(targetInst) : </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">accumulateTwoPhaseDispatchesSkipTarget(events) {</span>
  <span class="s1">forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">accumulateTwoPhaseDispatchesSingle(event) {</span>
  <span class="s3">if </span><span class="s1">(event &amp;&amp; event.dispatchConfig.phasedRegistrationNames) {</span>
    <span class="s1">traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">accumulateTwoPhaseDispatches(events) {</span>
  <span class="s1">forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);</span>
<span class="s1">} </span><span class="s0">// End of inline</span>

<span class="s0">/** 
 * 
 * Responder System: 
 * ---------------- 
 * 
 * - A global, solitary &quot;interaction lock&quot; on a view. 
 * - If a node becomes the responder, it should convey visual feedback 
 *   immediately to indicate so, either by highlighting or moving accordingly. 
 * - To be the responder means, that touches are exclusively important to that 
 *   responder view, and no other view. 
 * - While touches are still occurring, the responder lock can be transferred to 
 *   a new view, but only to increasingly &quot;higher&quot; views (meaning ancestors of 
 *   the current responder). 
 * 
 * Responder being granted: 
 * ------------------------ 
 * 
 * - Touch starts, moves, and scrolls can cause an ID to become the responder. 
 * - We capture/bubble `startShouldSetResponder`/`moveShouldSetResponder` to 
 *   the &quot;appropriate place&quot;. 
 * - If nothing is currently the responder, the &quot;appropriate place&quot; is the 
 *   initiating event's `targetID`. 
 * - If something *is* already the responder, the &quot;appropriate place&quot; is the 
 *   first common ancestor of the event target and the current `responderInst`. 
 * - Some negotiation happens: See the timing diagram below. 
 * - Scrolled views automatically become responder. The reasoning is that a 
 *   platform scroll view that isn't built on top of the responder system has 
 *   began scrolling, and the active responder must now be notified that the 
 *   interaction is no longer locked to it - the system has taken over. 
 * 
 * - Responder being released: 
 *   As soon as no more touches that *started* inside of descendants of the 
 *   *current* responderInst, an `onResponderRelease` event is dispatched to the 
 *   current responder, and the responder lock is released. 
 * 
 * TODO: 
 * - on &quot;end&quot;, a callback hook for `onResponderEndShouldRemainResponder` that 
 *   determines if the responder lock should remain. 
 * - If a view shouldn't &quot;remain&quot; the responder, any active touches should by 
 *   default be considered &quot;dead&quot; and do not influence future negotiations or 
 *   bubble paths. It should be as if those touches do not exist. 
 * -- For multitouch: Usually a translate-z will choose to &quot;remain&quot; responder 
 *  after one out of many touches ended. For translate-y, usually the view 
 *  doesn't wish to &quot;remain&quot; responder after one of many touches end. 
 * - Consider building this on top of a `stopPropagation` model similar to 
 *   `W3C` events. 
 * - Ensure that `onResponderTerminate` is called on touch cancels, whether or 
 *   not `onResponderTerminationRequest` returns `true` or `false`. 
 * 
 */</span>

<span class="s0">/*                                             Negotiation Performed 
                                             +-----------------------+ 
                                            /                         \ 
Process low level events to    +     Current Responder      +   wantsResponderID 
determine who to perform negot-|   (if any exists at all)   | 
iation/transition              | Otherwise just pass through| 
-------------------------------+----------------------------+------------------+ 
Bubble to find first ID        |                            | 
to return true:wantsResponderID|                            | 
                               |                            | 
     +-------------+           |                            | 
     | onTouchStart|           |                            | 
     +------+------+     none  |                            | 
            |            return|                            | 
+-----------v-------------+true| +------------------------+ | 
|onStartShouldSetResponder|-----&gt;|onResponderStart (cur)  |&lt;-----------+ 
+-----------+-------------+    | +------------------------+ |          | 
            |                  |                            | +--------+-------+ 
            | returned true for|       false:REJECT +--------&gt;|onResponderReject 
            | wantsResponderID |                    |       | +----------------+ 
            | (now attempt     | +------------------+-----+ | 
            |  handoff)        | |   onResponder          | | 
            +-------------------&gt;|      TerminationRequest| | 
                               | +------------------+-----+ | 
                               |                    |       | +----------------+ 
                               |         true:GRANT +--------&gt;|onResponderGrant| 
                               |                            | +--------+-------+ 
                               | +------------------------+ |          | 
                               | |   onResponderTerminate |&lt;-----------+ 
                               | +------------------+-----+ | 
                               |                    |       | +----------------+ 
                               |                    +--------&gt;|onResponderStart| 
                               |                            | +----------------+ 
Bubble to find first ID        |                            | 
to return true:wantsResponderID|                            | 
                               |                            | 
     +-------------+           |                            | 
     | onTouchMove |           |                            | 
     +------+------+     none  |                            | 
            |            return|                            | 
+-----------v-------------+true| +------------------------+ | 
|onMoveShouldSetResponder |-----&gt;|onResponderMove (cur)   |&lt;-----------+ 
+-----------+-------------+    | +------------------------+ |          | 
            |                  |                            | +--------+-------+ 
            | returned true for|       false:REJECT +--------&gt;|onResponderRejec| 
            | wantsResponderID |                    |       | +----------------+ 
            | (now attempt     | +------------------+-----+ | 
            |  handoff)        | |   onResponder          | | 
            +-------------------&gt;|      TerminationRequest| | 
                               | +------------------+-----+ | 
                               |                    |       | +----------------+ 
                               |         true:GRANT +--------&gt;|onResponderGrant| 
                               |                            | +--------+-------+ 
                               | +------------------------+ |          | 
                               | |   onResponderTerminate |&lt;-----------+ 
                               | +------------------+-----+ | 
                               |                    |       | +----------------+ 
                               |                    +--------&gt;|onResponderMove | 
                               |                            | +----------------+ 
                               |                            | 
                               |                            | 
      Some active touch started|                            | 
      inside current responder | +------------------------+ | 
      +-------------------------&gt;|      onResponderEnd    | | 
      |                        | +------------------------+ | 
  +---+---------+              |                            | 
  | onTouchEnd  |              |                            | 
  +---+---------+              |                            | 
      |                        | +------------------------+ | 
      +-------------------------&gt;|     onResponderEnd     | | 
      No active touches started| +-----------+------------+ | 
      inside current responder |             |              | 
                               |             v              | 
                               | +------------------------+ | 
                               | |    onResponderRelease  | | 
                               | +------------------------+ | 
                               |                            | 
                               +                            + */</span>

<span class="s0">/** 
 * A note about event ordering in the `EventPluginRegistry`. 
 * 
 * Suppose plugins are injected in the following order: 
 * 
 * `[R, S, C]` 
 * 
 * To help illustrate the example, assume `S` is `SimpleEventPlugin` (for 
 * `onClick` etc) and `R` is `ResponderEventPlugin`. 
 * 
 * &quot;Deferred-Dispatched Events&quot;: 
 * 
 * - The current event plugin system will traverse the list of injected plugins, 
 *   in order, and extract events by collecting the plugin's return value of 
 *   `extractEvents()`. 
 * - These events that are returned from `extractEvents` are &quot;deferred 
 *   dispatched events&quot;. 
 * - When returned from `extractEvents`, deferred-dispatched events contain an 
 *   &quot;accumulation&quot; of deferred dispatches. 
 * - These deferred dispatches are accumulated/collected before they are 
 *   returned, but processed at a later time by the `EventPluginRegistry` (hence the 
 *   name deferred). 
 * 
 * In the process of returning their deferred-dispatched events, event plugins 
 * themselves can dispatch events on-demand without returning them from 
 * `extractEvents`. Plugins might want to do this, so that they can use event 
 * dispatching as a tool that helps them decide which events should be extracted 
 * in the first place. 
 * 
 * &quot;On-Demand-Dispatched Events&quot;: 
 * 
 * - On-demand-dispatched events are not returned from `extractEvents`. 
 * - On-demand-dispatched events are dispatched during the process of returning 
 *   the deferred-dispatched events. 
 * - They should not have side effects. 
 * - They should be avoided, and/or eventually be replaced with another 
 *   abstraction that allows event plugins to perform multiple &quot;rounds&quot; of event 
 *   extraction. 
 * 
 * Therefore, the sequence of event dispatches becomes: 
 * 
 * - `R`s on-demand events (if any)   (dispatched by `R` on-demand) 
 * - `S`s on-demand events (if any)   (dispatched by `S` on-demand) 
 * - `C`s on-demand events (if any)   (dispatched by `C` on-demand) 
 * - `R`s extracted events (if any)   (dispatched by `EventPluginRegistry`) 
 * - `S`s extracted events (if any)   (dispatched by `EventPluginRegistry`) 
 * - `C`s extracted events (if any)   (dispatched by `EventPluginRegistry`) 
 * 
 * In the case of `ResponderEventPlugin`: If the `startShouldSetResponder` 
 * on-demand dispatch returns `true` (and some other details are satisfied) the 
 * `onResponderGrant` deferred dispatched event is returned from 
 * `extractEvents`. The sequence of dispatch executions in this case 
 * will appear as follows: 
 * 
 * - `startShouldSetResponder` (`ResponderEventPlugin` dispatches on-demand) 
 * - `touchStartCapture`       (`EventPluginRegistry` dispatches as usual) 
 * - `touchStart`              (`EventPluginRegistry` dispatches as usual) 
 * - `responderGrant/Reject`   (`EventPluginRegistry` dispatches as usual) 
 */</span>

<span class="s3">function </span><span class="s1">setResponderAndExtractTransfer(</span>
  <span class="s1">topLevelType,</span>
  <span class="s1">targetInst,</span>
  <span class="s1">nativeEvent,</span>
  <span class="s1">nativeEventTarget</span>
<span class="s1">) {</span>
  <span class="s3">var </span><span class="s1">shouldSetEventType = isStartish(topLevelType)</span>
    <span class="s1">? eventTypes.startShouldSetResponder</span>
    <span class="s1">: isMoveish(topLevelType)</span>
    <span class="s1">? eventTypes.moveShouldSetResponder</span>
    <span class="s1">: topLevelType === TOP_SELECTION_CHANGE</span>
    <span class="s1">? eventTypes.selectionChangeShouldSetResponder</span>
    <span class="s1">: eventTypes.scrollShouldSetResponder; </span><span class="s0">// TODO: stop one short of the current responder.</span>

  <span class="s3">var </span><span class="s1">bubbleShouldSetFrom = !responderInst</span>
    <span class="s1">? targetInst</span>
    <span class="s1">: getLowestCommonAncestor(responderInst, targetInst); </span><span class="s0">// When capturing/bubbling the &quot;shouldSet&quot; event, we want to skip the target</span>
  <span class="s0">// (deepest ID) if it happens to be the current responder. The reasoning:</span>
  <span class="s0">// It's strange to get an `onMoveShouldSetResponder` when you're *already*</span>
  <span class="s0">// the responder.</span>

  <span class="s3">var </span><span class="s1">skipOverBubbleShouldSetFrom = bubbleShouldSetFrom === responderInst;</span>
  <span class="s3">var </span><span class="s1">shouldSetEvent = ResponderSyntheticEvent.getPooled(</span>
    <span class="s1">shouldSetEventType,</span>
    <span class="s1">bubbleShouldSetFrom,</span>
    <span class="s1">nativeEvent,</span>
    <span class="s1">nativeEventTarget</span>
  <span class="s1">);</span>
  <span class="s1">shouldSetEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;</span>

  <span class="s3">if </span><span class="s1">(skipOverBubbleShouldSetFrom) {</span>
    <span class="s1">accumulateTwoPhaseDispatchesSkipTarget(shouldSetEvent);</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">accumulateTwoPhaseDispatches(shouldSetEvent);</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">wantsResponderInst = executeDispatchesInOrderStopAtTrue(shouldSetEvent);</span>

  <span class="s3">if </span><span class="s1">(!shouldSetEvent.isPersistent()) {</span>
    <span class="s1">shouldSetEvent.constructor.release(shouldSetEvent);</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(!wantsResponderInst || wantsResponderInst === responderInst) {</span>
    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">extracted;</span>
  <span class="s3">var </span><span class="s1">grantEvent = ResponderSyntheticEvent.getPooled(</span>
    <span class="s1">eventTypes.responderGrant,</span>
    <span class="s1">wantsResponderInst,</span>
    <span class="s1">nativeEvent,</span>
    <span class="s1">nativeEventTarget</span>
  <span class="s1">);</span>
  <span class="s1">grantEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;</span>
  <span class="s1">accumulateDirectDispatches(grantEvent);</span>
  <span class="s3">var </span><span class="s1">blockHostResponder = executeDirectDispatch(grantEvent) === </span><span class="s3">true</span><span class="s1">;</span>

  <span class="s3">if </span><span class="s1">(responderInst) {</span>
    <span class="s3">var </span><span class="s1">terminationRequestEvent = ResponderSyntheticEvent.getPooled(</span>
      <span class="s1">eventTypes.responderTerminationRequest,</span>
      <span class="s1">responderInst,</span>
      <span class="s1">nativeEvent,</span>
      <span class="s1">nativeEventTarget</span>
    <span class="s1">);</span>
    <span class="s1">terminationRequestEvent.touchHistory =</span>
      <span class="s1">ResponderTouchHistoryStore.touchHistory;</span>
    <span class="s1">accumulateDirectDispatches(terminationRequestEvent);</span>
    <span class="s3">var </span><span class="s1">shouldSwitch =</span>
      <span class="s1">!hasDispatches(terminationRequestEvent) ||</span>
      <span class="s1">executeDirectDispatch(terminationRequestEvent);</span>

    <span class="s3">if </span><span class="s1">(!terminationRequestEvent.isPersistent()) {</span>
      <span class="s1">terminationRequestEvent.constructor.release(terminationRequestEvent);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(shouldSwitch) {</span>
      <span class="s3">var </span><span class="s1">terminateEvent = ResponderSyntheticEvent.getPooled(</span>
        <span class="s1">eventTypes.responderTerminate,</span>
        <span class="s1">responderInst,</span>
        <span class="s1">nativeEvent,</span>
        <span class="s1">nativeEventTarget</span>
      <span class="s1">);</span>
      <span class="s1">terminateEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;</span>
      <span class="s1">accumulateDirectDispatches(terminateEvent);</span>
      <span class="s1">extracted = accumulate(extracted, [grantEvent, terminateEvent]);</span>
      <span class="s1">changeResponder(wantsResponderInst, blockHostResponder);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">var </span><span class="s1">rejectEvent = ResponderSyntheticEvent.getPooled(</span>
        <span class="s1">eventTypes.responderReject,</span>
        <span class="s1">wantsResponderInst,</span>
        <span class="s1">nativeEvent,</span>
        <span class="s1">nativeEventTarget</span>
      <span class="s1">);</span>
      <span class="s1">rejectEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;</span>
      <span class="s1">accumulateDirectDispatches(rejectEvent);</span>
      <span class="s1">extracted = accumulate(extracted, rejectEvent);</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">extracted = accumulate(extracted, grantEvent);</span>
    <span class="s1">changeResponder(wantsResponderInst, blockHostResponder);</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">extracted;</span>
<span class="s1">}</span>
<span class="s0">/** 
 * A transfer is a negotiation between a currently set responder and the next 
 * element to claim responder status. Any start event could trigger a transfer 
 * of responderInst. Any move event could trigger a transfer. 
 * 
 * @param {string} topLevelType Record from `BrowserEventConstants`. 
 * @return {boolean} True if a transfer of responder could possibly occur. 
 */</span>

<span class="s3">function </span><span class="s1">canTriggerTransfer(topLevelType, topLevelInst, nativeEvent) {</span>
  <span class="s3">return </span><span class="s1">(</span>
    <span class="s1">topLevelInst &amp;&amp; </span><span class="s0">// responderIgnoreScroll: We are trying to migrate away from specifically</span>
    <span class="s0">// tracking native scroll events here and responderIgnoreScroll indicates we</span>
    <span class="s0">// will send topTouchCancel to handle canceling touch events instead</span>
    <span class="s1">((topLevelType === TOP_SCROLL &amp;&amp; !nativeEvent.responderIgnoreScroll) ||</span>
      <span class="s1">(trackedTouchCount &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; topLevelType === TOP_SELECTION_CHANGE) ||</span>
      <span class="s1">isStartish(topLevelType) ||</span>
      <span class="s1">isMoveish(topLevelType))</span>
  <span class="s1">);</span>
<span class="s1">}</span>
<span class="s0">/** 
 * Returns whether or not this touch end event makes it such that there are no 
 * longer any touches that started inside of the current `responderInst`. 
 * 
 * @param {NativeEvent} nativeEvent Native touch end event. 
 * @return {boolean} Whether or not this touch end event ends the responder. 
 */</span>

<span class="s3">function </span><span class="s1">noResponderTouches(nativeEvent) {</span>
  <span class="s3">var </span><span class="s1">touches = nativeEvent.touches;</span>

  <span class="s3">if </span><span class="s1">(!touches || touches.length === </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s3">return true</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; touches.length; i++) {</span>
    <span class="s3">var </span><span class="s1">activeTouch = touches[i];</span>
    <span class="s3">var </span><span class="s1">target = activeTouch.target;</span>

    <span class="s3">if </span><span class="s1">(target !== </span><span class="s3">null </span><span class="s1">&amp;&amp; target !== undefined &amp;&amp; target !== </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s0">// Is the original touch location inside of the current responder?</span>
      <span class="s3">var </span><span class="s1">targetInst = getInstanceFromNode(target);</span>

      <span class="s3">if </span><span class="s1">(isAncestor(responderInst, targetInst)) {</span>
        <span class="s3">return false</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">return true</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">ResponderEventPlugin = {</span>
  <span class="s0">/* For unit testing only */</span>
  <span class="s1">_getResponder: </span><span class="s3">function</span><span class="s1">() {</span>
    <span class="s3">return </span><span class="s1">responderInst;</span>
  <span class="s1">},</span>
  <span class="s1">eventTypes: eventTypes,</span>

  <span class="s0">/** 
   * We must be resilient to `targetInst` being `null` on `touchMove` or 
   * `touchEnd`. On certain platforms, this means that a native scroll has 
   * assumed control and the original touch targets are destroyed. 
   */</span>
  <span class="s1">extractEvents: </span><span class="s3">function</span><span class="s1">(</span>
    <span class="s1">topLevelType,</span>
    <span class="s1">targetInst,</span>
    <span class="s1">nativeEvent,</span>
    <span class="s1">nativeEventTarget,</span>
    <span class="s1">eventSystemFlags</span>
  <span class="s1">) {</span>
    <span class="s3">if </span><span class="s1">(isStartish(topLevelType)) {</span>
      <span class="s1">trackedTouchCount += </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(isEndish(topLevelType)) {</span>
      <span class="s3">if </span><span class="s1">(trackedTouchCount &gt;= </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">trackedTouchCount -= </span><span class="s4">1</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">{</span>
          <span class="s1">warn(</span>
            <span class="s2">&quot;Ended a touch event which was not counted in `trackedTouchCount`.&quot;</span>
          <span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s3">return null</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">ResponderTouchHistoryStore.recordTouchTrack(topLevelType, nativeEvent);</span>
    <span class="s3">var </span><span class="s1">extracted = canTriggerTransfer(topLevelType, targetInst, nativeEvent)</span>
      <span class="s1">? setResponderAndExtractTransfer(</span>
          <span class="s1">topLevelType,</span>
          <span class="s1">targetInst,</span>
          <span class="s1">nativeEvent,</span>
          <span class="s1">nativeEventTarget</span>
        <span class="s1">)</span>
      <span class="s1">: </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// Responder may or may not have transferred on a new touch start/move.</span>
    <span class="s0">// Regardless, whoever is the responder after any potential transfer, we</span>
    <span class="s0">// direct all touch start/move/ends to them in the form of</span>
    <span class="s0">// `onResponderMove/Start/End`. These will be called for *every* additional</span>
    <span class="s0">// finger that move/start/end, dispatched directly to whoever is the</span>
    <span class="s0">// current responder at that moment, until the responder is &quot;released&quot;.</span>
    <span class="s0">//</span>
    <span class="s0">// These multiple individual change touch events are are always bookended</span>
    <span class="s0">// by `onResponderGrant`, and one of</span>
    <span class="s0">// (`onResponderRelease/onResponderTerminate`).</span>

    <span class="s3">var </span><span class="s1">isResponderTouchStart = responderInst &amp;&amp; isStartish(topLevelType);</span>
    <span class="s3">var </span><span class="s1">isResponderTouchMove = responderInst &amp;&amp; isMoveish(topLevelType);</span>
    <span class="s3">var </span><span class="s1">isResponderTouchEnd = responderInst &amp;&amp; isEndish(topLevelType);</span>
    <span class="s3">var </span><span class="s1">incrementalTouch = isResponderTouchStart</span>
      <span class="s1">? eventTypes.responderStart</span>
      <span class="s1">: isResponderTouchMove</span>
      <span class="s1">? eventTypes.responderMove</span>
      <span class="s1">: isResponderTouchEnd</span>
      <span class="s1">? eventTypes.responderEnd</span>
      <span class="s1">: </span><span class="s3">null</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s1">(incrementalTouch) {</span>
      <span class="s3">var </span><span class="s1">gesture = ResponderSyntheticEvent.getPooled(</span>
        <span class="s1">incrementalTouch,</span>
        <span class="s1">responderInst,</span>
        <span class="s1">nativeEvent,</span>
        <span class="s1">nativeEventTarget</span>
      <span class="s1">);</span>
      <span class="s1">gesture.touchHistory = ResponderTouchHistoryStore.touchHistory;</span>
      <span class="s1">accumulateDirectDispatches(gesture);</span>
      <span class="s1">extracted = accumulate(extracted, gesture);</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">isResponderTerminate =</span>
      <span class="s1">responderInst &amp;&amp; topLevelType === TOP_TOUCH_CANCEL;</span>
    <span class="s3">var </span><span class="s1">isResponderRelease =</span>
      <span class="s1">responderInst &amp;&amp;</span>
      <span class="s1">!isResponderTerminate &amp;&amp;</span>
      <span class="s1">isEndish(topLevelType) &amp;&amp;</span>
      <span class="s1">noResponderTouches(nativeEvent);</span>
    <span class="s3">var </span><span class="s1">finalTouch = isResponderTerminate</span>
      <span class="s1">? eventTypes.responderTerminate</span>
      <span class="s1">: isResponderRelease</span>
      <span class="s1">? eventTypes.responderRelease</span>
      <span class="s1">: </span><span class="s3">null</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s1">(finalTouch) {</span>
      <span class="s3">var </span><span class="s1">finalEvent = ResponderSyntheticEvent.getPooled(</span>
        <span class="s1">finalTouch,</span>
        <span class="s1">responderInst,</span>
        <span class="s1">nativeEvent,</span>
        <span class="s1">nativeEventTarget</span>
      <span class="s1">);</span>
      <span class="s1">finalEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;</span>
      <span class="s1">accumulateDirectDispatches(finalEvent);</span>
      <span class="s1">extracted = accumulate(extracted, finalEvent);</span>
      <span class="s1">changeResponder(</span><span class="s3">null</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">extracted;</span>
  <span class="s1">},</span>
  <span class="s1">GlobalResponderHandler: </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">injection: {</span>
    <span class="s0">/** 
     * @param {{onChange: (ReactID, ReactID) =&gt; void} GlobalResponderHandler 
     * Object that handles any change in responder. Use this to inject 
     * integration with an existing touch handling system etc. 
     */</span>
    <span class="s1">injectGlobalResponderHandler: </span><span class="s3">function</span><span class="s1">(GlobalResponderHandler) {</span>
      <span class="s1">ResponderEventPlugin.GlobalResponderHandler = GlobalResponderHandler;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">};</span>

<span class="s0">/** 
 * Injectable ordering of event plugins. 
 */</span>
<span class="s3">var </span><span class="s1">eventPluginOrder = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s0">/** 
 * Injectable mapping from names to event plugin modules. 
 */</span>

<span class="s3">var </span><span class="s1">namesToPlugins = {};</span>
<span class="s0">/** 
 * Recomputes the plugin list using the injected plugins and plugin ordering. 
 * 
 * @private 
 */</span>

<span class="s3">function </span><span class="s1">recomputePluginOrdering() {</span>
  <span class="s3">if </span><span class="s1">(!eventPluginOrder) {</span>
    <span class="s0">// Wait until an `eventPluginOrder` is injected.</span>
    <span class="s3">return</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">pluginName </span><span class="s3">in </span><span class="s1">namesToPlugins) {</span>
    <span class="s3">var </span><span class="s1">pluginModule = namesToPlugins[pluginName];</span>
    <span class="s3">var </span><span class="s1">pluginIndex = eventPluginOrder.indexOf(pluginName);</span>

    <span class="s3">if </span><span class="s1">(pluginIndex &lt;= -</span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s3">throw new </span><span class="s1">Error(</span>
        <span class="s2">&quot;EventPluginRegistry: Cannot inject event plugins that do not exist in &quot; </span><span class="s1">+</span>
          <span class="s1">(</span><span class="s2">&quot;the plugin ordering, `&quot; </span><span class="s1">+ pluginName + </span><span class="s2">&quot;`.&quot;</span><span class="s1">)</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(plugins[pluginIndex]) {</span>
      <span class="s3">continue</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(!pluginModule.extractEvents) {</span>
      <span class="s3">throw new </span><span class="s1">Error(</span>
        <span class="s2">&quot;EventPluginRegistry: Event plugins must implement an `extractEvents` &quot; </span><span class="s1">+</span>
          <span class="s1">(</span><span class="s2">&quot;method, but `&quot; </span><span class="s1">+ pluginName + </span><span class="s2">&quot;` does not.&quot;</span><span class="s1">)</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s1">plugins[pluginIndex] = pluginModule;</span>
    <span class="s3">var </span><span class="s1">publishedEvents = pluginModule.eventTypes;</span>

    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">eventName </span><span class="s3">in </span><span class="s1">publishedEvents) {</span>
      <span class="s3">if </span><span class="s1">(</span>
        <span class="s1">!publishEventForPlugin(</span>
          <span class="s1">publishedEvents[eventName],</span>
          <span class="s1">pluginModule,</span>
          <span class="s1">eventName</span>
        <span class="s1">)</span>
      <span class="s1">) {</span>
        <span class="s3">throw new </span><span class="s1">Error(</span>
          <span class="s2">&quot;EventPluginRegistry: Failed to publish event `&quot; </span><span class="s1">+</span>
            <span class="s1">eventName +</span>
            <span class="s2">&quot;` for plugin `&quot; </span><span class="s1">+</span>
            <span class="s1">pluginName +</span>
            <span class="s2">&quot;`.&quot;</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">/** 
 * Publishes an event so that it can be dispatched by the supplied plugin. 
 * 
 * @param {object} dispatchConfig Dispatch configuration for the event. 
 * @param {object} PluginModule Plugin publishing the event. 
 * @return {boolean} True if the event was successfully published. 
 * @private 
 */</span>

<span class="s3">function </span><span class="s1">publishEventForPlugin(dispatchConfig, pluginModule, eventName) {</span>
  <span class="s3">if </span><span class="s1">(eventNameDispatchConfigs.hasOwnProperty(eventName)) {</span>
    <span class="s3">throw new </span><span class="s1">Error(</span>
      <span class="s2">&quot;EventPluginRegistry: More than one plugin attempted to publish the same &quot; </span><span class="s1">+</span>
        <span class="s1">(</span><span class="s2">&quot;event name, `&quot; </span><span class="s1">+ eventName + </span><span class="s2">&quot;`.&quot;</span><span class="s1">)</span>
    <span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s1">eventNameDispatchConfigs[eventName] = dispatchConfig;</span>
  <span class="s3">var </span><span class="s1">phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;</span>

  <span class="s3">if </span><span class="s1">(phasedRegistrationNames) {</span>
    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">phaseName </span><span class="s3">in </span><span class="s1">phasedRegistrationNames) {</span>
      <span class="s3">if </span><span class="s1">(phasedRegistrationNames.hasOwnProperty(phaseName)) {</span>
        <span class="s3">var </span><span class="s1">phasedRegistrationName = phasedRegistrationNames[phaseName];</span>
        <span class="s1">publishRegistrationName(</span>
          <span class="s1">phasedRegistrationName,</span>
          <span class="s1">pluginModule,</span>
          <span class="s1">eventName</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return true</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(dispatchConfig.registrationName) {</span>
    <span class="s1">publishRegistrationName(</span>
      <span class="s1">dispatchConfig.registrationName,</span>
      <span class="s1">pluginModule,</span>
      <span class="s1">eventName</span>
    <span class="s1">);</span>
    <span class="s3">return true</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">return false</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s0">/** 
 * Publishes a registration name that is used to identify dispatched events. 
 * 
 * @param {string} registrationName Registration name to add. 
 * @param {object} PluginModule Plugin publishing the event. 
 * @private 
 */</span>

<span class="s3">function </span><span class="s1">publishRegistrationName(registrationName, pluginModule, eventName) {</span>
  <span class="s3">if </span><span class="s1">(registrationNameModules[registrationName]) {</span>
    <span class="s3">throw new </span><span class="s1">Error(</span>
      <span class="s2">&quot;EventPluginRegistry: More than one plugin attempted to publish the same &quot; </span><span class="s1">+</span>
        <span class="s1">(</span><span class="s2">&quot;registration name, `&quot; </span><span class="s1">+ registrationName + </span><span class="s2">&quot;`.&quot;</span><span class="s1">)</span>
    <span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s1">registrationNameModules[registrationName] = pluginModule;</span>
  <span class="s1">registrationNameDependencies[registrationName] =</span>
    <span class="s1">pluginModule.eventTypes[eventName].dependencies;</span>

  <span class="s1">{</span>
    <span class="s3">var </span><span class="s1">lowerCasedName = registrationName.toLowerCase();</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">/** 
 * Registers plugins so that they can extract and dispatch events. 
 */</span>

<span class="s0">/** 
 * Ordered list of injected plugins. 
 */</span>

<span class="s3">var </span><span class="s1">plugins = [];</span>
<span class="s0">/** 
 * Mapping from event name to dispatch config 
 */</span>

<span class="s3">var </span><span class="s1">eventNameDispatchConfigs = {};</span>
<span class="s0">/** 
 * Mapping from registration name to plugin module 
 */</span>

<span class="s3">var </span><span class="s1">registrationNameModules = {};</span>
<span class="s0">/** 
 * Mapping from registration name to event name 
 */</span>

<span class="s3">var </span><span class="s1">registrationNameDependencies = {};</span>

<span class="s0">/** 
 * Injects an ordering of plugins (by plugin name). This allows the ordering 
 * to be decoupled from injection of the actual plugins so that ordering is 
 * always deterministic regardless of packaging, on-the-fly injection, etc. 
 * 
 * @param {array} InjectedEventPluginOrder 
 * @internal 
 */</span>

<span class="s3">function </span><span class="s1">injectEventPluginOrder(injectedEventPluginOrder) {</span>
  <span class="s3">if </span><span class="s1">(eventPluginOrder) {</span>
    <span class="s3">throw new </span><span class="s1">Error(</span>
      <span class="s2">&quot;EventPluginRegistry: Cannot inject event plugin ordering more than &quot; </span><span class="s1">+</span>
        <span class="s2">&quot;once. You are likely trying to load more than one copy of React.&quot;</span>
    <span class="s1">);</span>
  <span class="s1">} </span><span class="s0">// Clone the ordering so it cannot be dynamically mutated.</span>

  <span class="s1">eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);</span>
  <span class="s1">recomputePluginOrdering();</span>
<span class="s1">}</span>
<span class="s0">/** 
 * Injects plugins to be used by plugin event system. The plugin names must be 
 * in the ordering injected by `injectEventPluginOrder`. 
 * 
 * Plugins can be injected as part of page initialization or on-the-fly. 
 * 
 * @param {object} injectedNamesToPlugins Map from names to plugin modules. 
 * @internal 
 */</span>

<span class="s3">function </span><span class="s1">injectEventPluginsByName(injectedNamesToPlugins) {</span>
  <span class="s3">var </span><span class="s1">isOrderingDirty = </span><span class="s3">false</span><span class="s1">;</span>

  <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">pluginName </span><span class="s3">in </span><span class="s1">injectedNamesToPlugins) {</span>
    <span class="s3">if </span><span class="s1">(!injectedNamesToPlugins.hasOwnProperty(pluginName)) {</span>
      <span class="s3">continue</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">pluginModule = injectedNamesToPlugins[pluginName];</span>

    <span class="s3">if </span><span class="s1">(</span>
      <span class="s1">!namesToPlugins.hasOwnProperty(pluginName) ||</span>
      <span class="s1">namesToPlugins[pluginName] !== pluginModule</span>
    <span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(namesToPlugins[pluginName]) {</span>
        <span class="s3">throw new </span><span class="s1">Error(</span>
          <span class="s2">&quot;EventPluginRegistry: Cannot inject two different event plugins &quot; </span><span class="s1">+</span>
            <span class="s1">(</span><span class="s2">&quot;using the same name, `&quot; </span><span class="s1">+ pluginName + </span><span class="s2">&quot;`.&quot;</span><span class="s1">)</span>
        <span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s1">namesToPlugins[pluginName] = pluginModule;</span>
      <span class="s1">isOrderingDirty = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(isOrderingDirty) {</span>
    <span class="s1">recomputePluginOrdering();</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Get a list of listeners for a specific event, in-order. 
 * For React Native we treat the props-based function handlers 
 * as the first-class citizens, and they are always executed first 
 * for both capture and bubbling phase. 
 * 
 * We need &quot;phase&quot; propagated to this point to support the HostComponent 
 * EventEmitter API, which does not mutate the name of the handler based 
 * on phase (whereas prop handlers are registered as `onMyEvent` and `onMyEvent_Capture`). 
 * 
 * Native system events emitted into React Native 
 * will be emitted both to the prop handler function and to imperative event 
 * listeners. 
 * 
 * This will either return null, a single Function without an array, or 
 * an array of 2+ items. 
 */</span>

<span class="s3">function </span><span class="s1">getListeners(</span>
  <span class="s1">inst,</span>
  <span class="s1">registrationName,</span>
  <span class="s1">phase,</span>
  <span class="s1">dispatchToImperativeListeners</span>
<span class="s1">) {</span>
  <span class="s3">var </span><span class="s1">stateNode = inst.stateNode;</span>

  <span class="s3">if </span><span class="s1">(stateNode === </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s0">// If null: Work in progress (ex: onload events in incremental mode).</span>

  <span class="s3">var </span><span class="s1">props = getFiberCurrentPropsFromNode(stateNode);</span>

  <span class="s3">if </span><span class="s1">(props === </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s0">// Work in progress.</span>
    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">listener = props[registrationName];</span>

  <span class="s3">if </span><span class="s1">(listener &amp;&amp; </span><span class="s3">typeof </span><span class="s1">listener !== </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
    <span class="s3">throw new </span><span class="s1">Error(</span>
      <span class="s2">&quot;Expected `&quot; </span><span class="s1">+</span>
        <span class="s1">registrationName +</span>
        <span class="s2">&quot;` listener to be a function, instead got a value of `&quot; </span><span class="s1">+</span>
        <span class="s3">typeof </span><span class="s1">listener +</span>
        <span class="s2">&quot;` type.&quot;</span>
    <span class="s1">);</span>
  <span class="s1">} </span><span class="s0">// If there are no imperative listeners, early exit.</span>

  <span class="s3">if </span><span class="s1">(</span>
    <span class="s1">!(</span>
      <span class="s1">dispatchToImperativeListeners &amp;&amp;</span>
      <span class="s1">stateNode.canonical &amp;&amp;</span>
      <span class="s1">stateNode.canonical._eventListeners</span>
    <span class="s1">)</span>
  <span class="s1">) {</span>
    <span class="s3">return </span><span class="s1">listener;</span>
  <span class="s1">} </span><span class="s0">// Below this is the de-optimized path.</span>
  <span class="s0">// If you are using _eventListeners, we do not (yet)</span>
  <span class="s0">// expect this to be as performant as the props-only path.</span>
  <span class="s0">// If/when this becomes a bottleneck, it can be refactored</span>
  <span class="s0">// to avoid unnecessary closures and array allocations.</span>
  <span class="s0">//</span>
  <span class="s0">// Previously, there was only one possible listener for an event:</span>
  <span class="s0">// the onEventName property in props.</span>
  <span class="s0">// Now, it is also possible to have N listeners</span>
  <span class="s0">// for a specific event on a node. Thus, we accumulate all of the listeners,</span>
  <span class="s0">// including the props listener, and return a function that calls them all in</span>
  <span class="s0">// order, starting with the handler prop and then the listeners in order.</span>
  <span class="s0">// We return either a non-empty array or null.</span>

  <span class="s3">var </span><span class="s1">listeners = [];</span>

  <span class="s3">if </span><span class="s1">(listener) {</span>
    <span class="s1">listeners.push(listener);</span>
  <span class="s1">} </span><span class="s0">// TODO: for now, all of these events get an `rn:` prefix to enforce</span>
  <span class="s0">// that the user knows they're only getting non-W3C-compliant events</span>
  <span class="s0">// through this imperative event API.</span>
  <span class="s0">// Events might not necessarily be noncompliant, but we currently have</span>
  <span class="s0">// no verification that /any/ events are compliant.</span>
  <span class="s0">// Thus, we prefix to ensure no collision with W3C event names.</span>

  <span class="s3">var </span><span class="s1">requestedPhaseIsCapture = phase === </span><span class="s2">&quot;captured&quot;</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">mangledImperativeRegistrationName = requestedPhaseIsCapture</span>
    <span class="s1">? </span><span class="s2">&quot;rn:&quot; </span><span class="s1">+ registrationName.replace(/Capture$/, </span><span class="s2">&quot;&quot;</span><span class="s1">)</span>
    <span class="s1">: </span><span class="s2">&quot;rn:&quot; </span><span class="s1">+ registrationName; </span><span class="s0">// Get imperative event listeners for this event</span>

  <span class="s3">if </span><span class="s1">(</span>
    <span class="s1">stateNode.canonical._eventListeners[mangledImperativeRegistrationName] &amp;&amp;</span>
    <span class="s1">stateNode.canonical._eventListeners[mangledImperativeRegistrationName]</span>
      <span class="s1">.length &gt; </span><span class="s4">0</span>
  <span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">eventListeners =</span>
      <span class="s1">stateNode.canonical._eventListeners[mangledImperativeRegistrationName];</span>
    <span class="s1">eventListeners.forEach(</span><span class="s3">function</span><span class="s1">(listenerObj) {</span>
      <span class="s0">// Make sure phase of listener matches requested phase</span>
      <span class="s3">var </span><span class="s1">isCaptureEvent =</span>
        <span class="s1">listenerObj.options.capture != </span><span class="s3">null </span><span class="s1">&amp;&amp; listenerObj.options.capture;</span>

      <span class="s3">if </span><span class="s1">(isCaptureEvent !== requestedPhaseIsCapture) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// For now (this is an area of future optimization) we must wrap</span>
      <span class="s0">// all imperative event listeners in a function to unwrap the SyntheticEvent</span>
      <span class="s0">// and pass them an Event.</span>
      <span class="s0">// When this API is more stable and used more frequently, we can revisit.</span>

      <span class="s3">var </span><span class="s1">listenerFnWrapper = </span><span class="s3">function</span><span class="s1">(syntheticEvent) {</span>
        <span class="s3">var </span><span class="s1">eventInst = </span><span class="s3">new </span><span class="s1">ReactNativePrivateInterface.CustomEvent(</span>
          <span class="s1">mangledImperativeRegistrationName,</span>
          <span class="s1">{</span>
            <span class="s1">detail: syntheticEvent.nativeEvent</span>
          <span class="s1">}</span>
        <span class="s1">);</span>
        <span class="s1">eventInst.isTrusted = </span><span class="s3">true</span><span class="s1">; </span><span class="s0">// setSyntheticEvent is present on the React Native Event shim.</span>
        <span class="s0">// It is used to forward method calls on Event to the underlying SyntheticEvent.</span>
        <span class="s0">// $FlowFixMe</span>

        <span class="s1">eventInst.setSyntheticEvent(syntheticEvent);</span>

        <span class="s3">for </span><span class="s1">(</span>
          <span class="s3">var </span><span class="s1">_len = arguments.length,</span>
            <span class="s1">args = </span><span class="s3">new </span><span class="s1">Array(_len &gt; </span><span class="s4">1 </span><span class="s1">? _len - </span><span class="s4">1 </span><span class="s1">: </span><span class="s4">0</span><span class="s1">),</span>
            <span class="s1">_key = </span><span class="s4">1</span><span class="s1">;</span>
          <span class="s1">_key &lt; _len;</span>
          <span class="s1">_key++</span>
        <span class="s1">) {</span>
          <span class="s1">args[_key - </span><span class="s4">1</span><span class="s1">] = arguments[_key];</span>
        <span class="s1">}</span>

        <span class="s1">listenerObj.listener.apply(listenerObj, [eventInst].concat(args));</span>
      <span class="s1">}; </span><span class="s0">// Only call once?</span>
      <span class="s0">// If so, we ensure that it's only called once by setting a flag</span>
      <span class="s0">// and by removing it from eventListeners once it is called (but only</span>
      <span class="s0">// when it's actually been executed).</span>

      <span class="s3">if </span><span class="s1">(listenerObj.options.once) {</span>
        <span class="s1">listeners.push(</span><span class="s3">function</span><span class="s1">() {</span>
          <span class="s0">// Remove from the event listener once it's been called</span>
          <span class="s1">stateNode.canonical.removeEventListener_unstable(</span>
            <span class="s1">mangledImperativeRegistrationName,</span>
            <span class="s1">listenerObj.listener,</span>
            <span class="s1">listenerObj.capture</span>
          <span class="s1">); </span><span class="s0">// Guard against function being called more than once in</span>
          <span class="s0">// case there are somehow multiple in-flight references to</span>
          <span class="s0">// it being processed</span>

          <span class="s3">if </span><span class="s1">(!listenerObj.invalidated) {</span>
            <span class="s1">listenerObj.invalidated = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s1">listenerObj.listener.apply(listenerObj, arguments);</span>
          <span class="s1">}</span>
        <span class="s1">});</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">listeners.push(listenerFnWrapper);</span>
      <span class="s1">}</span>
    <span class="s1">});</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(listeners.length === </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(listeners.length === </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s3">return </span><span class="s1">listeners[</span><span class="s4">0</span><span class="s1">];</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">listeners;</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">customBubblingEventTypes =</span>
    <span class="s1">ReactNativePrivateInterface.ReactNativeViewConfigRegistry</span>
      <span class="s1">.customBubblingEventTypes,</span>
  <span class="s1">customDirectEventTypes =</span>
    <span class="s1">ReactNativePrivateInterface.ReactNativeViewConfigRegistry</span>
      <span class="s1">.customDirectEventTypes; </span><span class="s0">// Start of inline: the below functions were inlined from</span>
<span class="s0">// EventPropagator.js, as they deviated from ReactDOM's newer</span>
<span class="s0">// implementations.</span>

<span class="s3">function </span><span class="s1">listenersAtPhase(inst, event, propagationPhase) {</span>
  <span class="s3">var </span><span class="s1">registrationName =</span>
    <span class="s1">event.dispatchConfig.phasedRegistrationNames[propagationPhase];</span>
  <span class="s3">return </span><span class="s1">getListeners(inst, registrationName, propagationPhase, </span><span class="s3">true</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">accumulateListenersAndInstances(inst, event, listeners) {</span>
  <span class="s3">var </span><span class="s1">listenersLength = listeners</span>
    <span class="s1">? isArray(listeners)</span>
      <span class="s1">? listeners.length</span>
      <span class="s1">: </span><span class="s4">1</span>
    <span class="s1">: </span><span class="s4">0</span><span class="s1">;</span>

  <span class="s3">if </span><span class="s1">(listenersLength &gt; </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s1">event._dispatchListeners = accumulateInto(</span>
      <span class="s1">event._dispatchListeners,</span>
      <span class="s1">listeners</span>
    <span class="s1">); </span><span class="s0">// Avoid allocating additional arrays here</span>

    <span class="s3">if </span><span class="s1">(event._dispatchInstances == </span><span class="s3">null </span><span class="s1">&amp;&amp; listenersLength === </span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s1">event._dispatchInstances = inst;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">event._dispatchInstances = event._dispatchInstances || [];</span>

      <span class="s3">if </span><span class="s1">(!isArray(event._dispatchInstances)) {</span>
        <span class="s1">event._dispatchInstances = [event._dispatchInstances];</span>
      <span class="s1">}</span>

      <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; listenersLength; i++) {</span>
        <span class="s1">event._dispatchInstances.push(inst);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">accumulateDirectionalDispatches$1(inst, phase, event) {</span>
  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(!inst) {</span>
      <span class="s1">error(</span><span class="s2">&quot;Dispatching inst must not be null&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">listeners = listenersAtPhase(inst, event, phase);</span>
  <span class="s1">accumulateListenersAndInstances(inst, event, listeners);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">getParent$1(inst) {</span>
  <span class="s3">do </span><span class="s1">{</span>
    <span class="s1">inst = inst.</span><span class="s3">return</span><span class="s1">; </span><span class="s0">// TODO: If this is a HostRoot we might want to bail out.</span>
    <span class="s0">// That is depending on if we want nested subtrees (layers) to bubble</span>
    <span class="s0">// events to their parent. We could also go through parentNode on the</span>
    <span class="s0">// host node but that wouldn't work for React Native and doesn't let us</span>
    <span class="s0">// do the portal feature.</span>
  <span class="s1">} </span><span class="s3">while </span><span class="s1">(inst &amp;&amp; inst.tag !== HostComponent);</span>

  <span class="s3">if </span><span class="s1">(inst) {</span>
    <span class="s3">return </span><span class="s1">inst;</span>
  <span class="s1">}</span>

  <span class="s3">return null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s0">/** 
 * Simulates the traversal of a two-phase, capture/bubble event dispatch. 
 */</span>

<span class="s3">function </span><span class="s1">traverseTwoPhase$1(inst, fn, arg, skipBubbling) {</span>
  <span class="s3">var </span><span class="s1">path = [];</span>

  <span class="s3">while </span><span class="s1">(inst) {</span>
    <span class="s1">path.push(inst);</span>
    <span class="s1">inst = getParent$1(inst);</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">i;</span>

  <span class="s3">for </span><span class="s1">(i = path.length; i-- &gt; </span><span class="s4">0</span><span class="s1">; ) {</span>
    <span class="s1">fn(path[i], </span><span class="s2">&quot;captured&quot;</span><span class="s1">, arg);</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(skipBubbling) {</span>
    <span class="s0">// Dispatch on target only</span>
    <span class="s1">fn(path[</span><span class="s4">0</span><span class="s1">], </span><span class="s2">&quot;bubbled&quot;</span><span class="s1">, arg);</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s3">for </span><span class="s1">(i = </span><span class="s4">0</span><span class="s1">; i &lt; path.length; i++) {</span>
      <span class="s1">fn(path[i], </span><span class="s2">&quot;bubbled&quot;</span><span class="s1">, arg);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">accumulateTwoPhaseDispatchesSingle$1(event) {</span>
  <span class="s3">if </span><span class="s1">(event &amp;&amp; event.dispatchConfig.phasedRegistrationNames) {</span>
    <span class="s1">traverseTwoPhase$1(</span>
      <span class="s1">event._targetInst,</span>
      <span class="s1">accumulateDirectionalDispatches$1,</span>
      <span class="s1">event,</span>
      <span class="s3">false</span>
    <span class="s1">);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">accumulateTwoPhaseDispatches$1(events) {</span>
  <span class="s1">forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle$1);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">accumulateCapturePhaseDispatches(event) {</span>
  <span class="s3">if </span><span class="s1">(event &amp;&amp; event.dispatchConfig.phasedRegistrationNames) {</span>
    <span class="s1">traverseTwoPhase$1(</span>
      <span class="s1">event._targetInst,</span>
      <span class="s1">accumulateDirectionalDispatches$1,</span>
      <span class="s1">event,</span>
      <span class="s3">true</span>
    <span class="s1">);</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">/** 
 * Accumulates without regard to direction, does not look for phased 
 * registration names. Same as `accumulateDirectDispatchesSingle` but without 
 * requiring that the `dispatchMarker` be the same as the dispatched ID. 
 */</span>

<span class="s3">function </span><span class="s1">accumulateDispatches$1(inst, ignoredDirection, event) {</span>
  <span class="s3">if </span><span class="s1">(inst &amp;&amp; event &amp;&amp; event.dispatchConfig.registrationName) {</span>
    <span class="s3">var </span><span class="s1">registrationName = event.dispatchConfig.registrationName;</span>
    <span class="s3">var </span><span class="s1">listeners = getListeners(inst, registrationName, </span><span class="s2">&quot;bubbled&quot;</span><span class="s1">, </span><span class="s3">false</span><span class="s1">);</span>
    <span class="s1">accumulateListenersAndInstances(inst, event, listeners);</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">/** 
 * Accumulates dispatches on an `SyntheticEvent`, but only for the 
 * `dispatchMarker`. 
 * @param {SyntheticEvent} event 
 */</span>

<span class="s3">function </span><span class="s1">accumulateDirectDispatchesSingle$1(event) {</span>
  <span class="s3">if </span><span class="s1">(event &amp;&amp; event.dispatchConfig.registrationName) {</span>
    <span class="s1">accumulateDispatches$1(event._targetInst, </span><span class="s3">null</span><span class="s1">, event);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">accumulateDirectDispatches$1(events) {</span>
  <span class="s1">forEachAccumulated(events, accumulateDirectDispatchesSingle$1);</span>
<span class="s1">} </span><span class="s0">// End of inline</span>

<span class="s3">var </span><span class="s1">ReactNativeBridgeEventPlugin = {</span>
  <span class="s1">eventTypes: {},</span>
  <span class="s1">extractEvents: </span><span class="s3">function</span><span class="s1">(</span>
    <span class="s1">topLevelType,</span>
    <span class="s1">targetInst,</span>
    <span class="s1">nativeEvent,</span>
    <span class="s1">nativeEventTarget</span>
  <span class="s1">) {</span>
    <span class="s3">if </span><span class="s1">(targetInst == </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// Probably a node belonging to another renderer's tree.</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">bubbleDispatchConfig = customBubblingEventTypes[topLevelType];</span>
    <span class="s3">var </span><span class="s1">directDispatchConfig = customDirectEventTypes[topLevelType];</span>

    <span class="s3">if </span><span class="s1">(!bubbleDispatchConfig &amp;&amp; !directDispatchConfig) {</span>
      <span class="s3">throw new </span><span class="s1">Error( </span><span class="s0">// $FlowFixMe - Flow doesn't like this string coercion because DOMTopLevelEventType is opaque</span>
        <span class="s2">'Unsupported top level event type &quot;' </span><span class="s1">+ topLevelType + </span><span class="s2">'&quot; dispatched'</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">event = SyntheticEvent.getPooled(</span>
      <span class="s1">bubbleDispatchConfig || directDispatchConfig,</span>
      <span class="s1">targetInst,</span>
      <span class="s1">nativeEvent,</span>
      <span class="s1">nativeEventTarget</span>
    <span class="s1">);</span>

    <span class="s3">if </span><span class="s1">(bubbleDispatchConfig) {</span>
      <span class="s3">var </span><span class="s1">skipBubbling =</span>
        <span class="s1">event != </span><span class="s3">null </span><span class="s1">&amp;&amp;</span>
        <span class="s1">event.dispatchConfig.phasedRegistrationNames != </span><span class="s3">null </span><span class="s1">&amp;&amp;</span>
        <span class="s1">event.dispatchConfig.phasedRegistrationNames.skipBubbling;</span>

      <span class="s3">if </span><span class="s1">(skipBubbling) {</span>
        <span class="s1">accumulateCapturePhaseDispatches(event);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">accumulateTwoPhaseDispatches$1(event);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(directDispatchConfig) {</span>
      <span class="s1">accumulateDirectDispatches$1(event);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">event;</span>
  <span class="s1">}</span>
<span class="s1">};</span>

<span class="s3">var </span><span class="s1">ReactNativeEventPluginOrder = [</span>
  <span class="s2">&quot;ResponderEventPlugin&quot;</span><span class="s1">,</span>
  <span class="s2">&quot;ReactNativeBridgeEventPlugin&quot;</span>
<span class="s1">];</span>

<span class="s0">/** 
 * Make sure essential globals are available and are patched correctly. Please don't remove this 
 * line. Bundles created by react-packager `require` it before executing any application code. This 
 * ensures it exists in the dependency graph and can be `require`d. 
 * TODO: require this in packager, not in React #10932517 
 */</span>
<span class="s0">/** 
 * Inject module for resolving DOM hierarchy and plugin ordering. 
 */</span>

<span class="s1">injectEventPluginOrder(ReactNativeEventPluginOrder);</span>
<span class="s0">/** 
 * Some important event plugins included by default (without having to require 
 * them). 
 */</span>

<span class="s1">injectEventPluginsByName({</span>
  <span class="s1">ResponderEventPlugin: ResponderEventPlugin,</span>
  <span class="s1">ReactNativeBridgeEventPlugin: ReactNativeBridgeEventPlugin</span>
<span class="s1">});</span>

<span class="s3">function </span><span class="s1">getInstanceFromInstance(instanceHandle) {</span>
  <span class="s3">return </span><span class="s1">instanceHandle;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">getTagFromInstance(inst) {</span>
  <span class="s3">var </span><span class="s1">nativeInstance = inst.stateNode.canonical;</span>

  <span class="s3">if </span><span class="s1">(!nativeInstance._nativeTag) {</span>
    <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;All native instances should have a tag.&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">nativeInstance;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">getFiberCurrentPropsFromNode$1(inst) {</span>
  <span class="s3">return </span><span class="s1">inst.canonical.currentProps;</span>
<span class="s1">}</span>

<span class="s0">// Module provided by RN:</span>
<span class="s3">var </span><span class="s1">ReactFabricGlobalResponderHandler = {</span>
  <span class="s1">onChange: </span><span class="s3">function</span><span class="s1">(from, to, blockNativeResponder) {</span>
    <span class="s3">var </span><span class="s1">fromOrTo = from || to;</span>
    <span class="s3">var </span><span class="s1">fromOrToStateNode = fromOrTo &amp;&amp; fromOrTo.stateNode;</span>
    <span class="s3">var </span><span class="s1">isFabric = !!(</span>
      <span class="s1">fromOrToStateNode &amp;&amp; fromOrToStateNode.canonical._internalInstanceHandle</span>
    <span class="s1">);</span>

    <span class="s3">if </span><span class="s1">(isFabric) {</span>
      <span class="s3">if </span><span class="s1">(from) {</span>
        <span class="s0">// equivalent to clearJSResponder</span>
        <span class="s1">nativeFabricUIManager.setIsJSResponder(</span>
          <span class="s1">from.stateNode.node,</span>
          <span class="s3">false</span><span class="s1">,</span>
          <span class="s1">blockNativeResponder || </span><span class="s3">false</span>
        <span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(to) {</span>
        <span class="s0">// equivalent to setJSResponder</span>
        <span class="s1">nativeFabricUIManager.setIsJSResponder(</span>
          <span class="s1">to.stateNode.node,</span>
          <span class="s3">true</span><span class="s1">,</span>
          <span class="s1">blockNativeResponder || </span><span class="s3">false</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(to !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">tag = to.stateNode.canonical._nativeTag;</span>
        <span class="s1">ReactNativePrivateInterface.UIManager.setJSResponder(</span>
          <span class="s1">tag,</span>
          <span class="s1">blockNativeResponder</span>
        <span class="s1">);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">ReactNativePrivateInterface.UIManager.clearJSResponder();</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">};</span>

<span class="s1">setComponentTree(</span>
  <span class="s1">getFiberCurrentPropsFromNode$1,</span>
  <span class="s1">getInstanceFromInstance,</span>
  <span class="s1">getTagFromInstance</span>
<span class="s1">);</span>
<span class="s1">ResponderEventPlugin.injection.injectGlobalResponderHandler(</span>
  <span class="s1">ReactFabricGlobalResponderHandler</span>
<span class="s1">);</span>

<span class="s0">/** 
 * `ReactInstanceMap` maintains a mapping from a public facing stateful 
 * instance (key) and the internal representation (value). This allows public 
 * methods to accept the user facing instance as an argument and map them back 
 * to internal methods. 
 * 
 * Note that this module is currently shared and assumed to be stateless. 
 * If this becomes an actual Map, that will break. 
 */</span>
<span class="s3">function </span><span class="s1">get(key) {</span>
  <span class="s3">return </span><span class="s1">key._reactInternals;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">set(key, value) {</span>
  <span class="s1">key._reactInternals = value;</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">enableSchedulingProfiler = </span><span class="s3">false</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">enableProfilerTimer = </span><span class="s3">true</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">enableProfilerCommitHooks = </span><span class="s3">true</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">warnAboutStringRefs = </span><span class="s3">false</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">enableSuspenseAvoidThisFallback = </span><span class="s3">false</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">enableNewReconciler = </span><span class="s3">false</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">enableLazyContextPropagation = </span><span class="s3">false</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">enableLegacyHidden = </span><span class="s3">false</span><span class="s1">;</span>

<span class="s0">// ATTENTION</span>
<span class="s0">// When adding new symbols to this file,</span>
<span class="s0">// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'</span>
<span class="s0">// The Symbol used to tag the ReactElement-like types.</span>
<span class="s3">var </span><span class="s1">REACT_ELEMENT_TYPE = Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">&quot;react.element&quot;</span><span class="s1">);</span>
<span class="s3">var </span><span class="s1">REACT_PORTAL_TYPE = Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">&quot;react.portal&quot;</span><span class="s1">);</span>
<span class="s3">var </span><span class="s1">REACT_FRAGMENT_TYPE = Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">&quot;react.fragment&quot;</span><span class="s1">);</span>
<span class="s3">var </span><span class="s1">REACT_STRICT_MODE_TYPE = Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">&quot;react.strict_mode&quot;</span><span class="s1">);</span>
<span class="s3">var </span><span class="s1">REACT_PROFILER_TYPE = Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">&quot;react.profiler&quot;</span><span class="s1">);</span>
<span class="s3">var </span><span class="s1">REACT_PROVIDER_TYPE = Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">&quot;react.provider&quot;</span><span class="s1">);</span>
<span class="s3">var </span><span class="s1">REACT_CONTEXT_TYPE = Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">&quot;react.context&quot;</span><span class="s1">);</span>
<span class="s3">var </span><span class="s1">REACT_FORWARD_REF_TYPE = Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">&quot;react.forward_ref&quot;</span><span class="s1">);</span>
<span class="s3">var </span><span class="s1">REACT_SUSPENSE_TYPE = Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">&quot;react.suspense&quot;</span><span class="s1">);</span>
<span class="s3">var </span><span class="s1">REACT_SUSPENSE_LIST_TYPE = Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">&quot;react.suspense_list&quot;</span><span class="s1">);</span>
<span class="s3">var </span><span class="s1">REACT_MEMO_TYPE = Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">&quot;react.memo&quot;</span><span class="s1">);</span>
<span class="s3">var </span><span class="s1">REACT_LAZY_TYPE = Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">&quot;react.lazy&quot;</span><span class="s1">);</span>
<span class="s3">var </span><span class="s1">REACT_SCOPE_TYPE = Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">&quot;react.scope&quot;</span><span class="s1">);</span>
<span class="s3">var </span><span class="s1">REACT_DEBUG_TRACING_MODE_TYPE = Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">&quot;react.debug_trace_mode&quot;</span><span class="s1">);</span>
<span class="s3">var </span><span class="s1">REACT_OFFSCREEN_TYPE = Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">&quot;react.offscreen&quot;</span><span class="s1">);</span>
<span class="s3">var </span><span class="s1">REACT_LEGACY_HIDDEN_TYPE = Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">&quot;react.legacy_hidden&quot;</span><span class="s1">);</span>
<span class="s3">var </span><span class="s1">REACT_CACHE_TYPE = Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">&quot;react.cache&quot;</span><span class="s1">);</span>
<span class="s3">var </span><span class="s1">REACT_TRACING_MARKER_TYPE = Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">&quot;react.tracing_marker&quot;</span><span class="s1">);</span>
<span class="s3">var </span><span class="s1">MAYBE_ITERATOR_SYMBOL = Symbol.iterator;</span>
<span class="s3">var </span><span class="s1">FAUX_ITERATOR_SYMBOL = </span><span class="s2">&quot;@@iterator&quot;</span><span class="s1">;</span>
<span class="s3">function </span><span class="s1">getIteratorFn(maybeIterable) {</span>
  <span class="s3">if </span><span class="s1">(maybeIterable === </span><span class="s3">null </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">maybeIterable !== </span><span class="s2">&quot;object&quot;</span><span class="s1">) {</span>
    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">maybeIterator =</span>
    <span class="s1">(MAYBE_ITERATOR_SYMBOL &amp;&amp; maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||</span>
    <span class="s1">maybeIterable[FAUX_ITERATOR_SYMBOL];</span>

  <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">maybeIterator === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
    <span class="s3">return </span><span class="s1">maybeIterator;</span>
  <span class="s1">}</span>

  <span class="s3">return null</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">getWrappedName(outerType, innerType, wrapperName) {</span>
  <span class="s3">var </span><span class="s1">displayName = outerType.displayName;</span>

  <span class="s3">if </span><span class="s1">(displayName) {</span>
    <span class="s3">return </span><span class="s1">displayName;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">functionName = innerType.displayName || innerType.name || </span><span class="s2">&quot;&quot;</span><span class="s1">;</span>
  <span class="s3">return </span><span class="s1">functionName !== </span><span class="s2">&quot;&quot;</span>
    <span class="s1">? wrapperName + </span><span class="s2">&quot;(&quot; </span><span class="s1">+ functionName + </span><span class="s2">&quot;)&quot;</span>
    <span class="s1">: wrapperName;</span>
<span class="s1">} </span><span class="s0">// Keep in sync with react-reconciler/getComponentNameFromFiber</span>

<span class="s3">function </span><span class="s1">getContextName(type) {</span>
  <span class="s3">return </span><span class="s1">type.displayName || </span><span class="s2">&quot;Context&quot;</span><span class="s1">;</span>
<span class="s1">} </span><span class="s0">// Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.</span>

<span class="s3">function </span><span class="s1">getComponentNameFromType(type) {</span>
  <span class="s3">if </span><span class="s1">(type == </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s0">// Host root, text node or just invalid type.</span>
    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">type.tag === </span><span class="s2">&quot;number&quot;</span><span class="s1">) {</span>
      <span class="s1">error(</span>
        <span class="s2">&quot;Received an unexpected object in getComponentNameFromType(). &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;This is likely a bug in React. Please file an issue.&quot;</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">type === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
    <span class="s3">return </span><span class="s1">type.displayName || type.name || </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">type === </span><span class="s2">&quot;string&quot;</span><span class="s1">) {</span>
    <span class="s3">return </span><span class="s1">type;</span>
  <span class="s1">}</span>

  <span class="s3">switch </span><span class="s1">(type) {</span>
    <span class="s3">case </span><span class="s1">REACT_FRAGMENT_TYPE:</span>
      <span class="s3">return </span><span class="s2">&quot;Fragment&quot;</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s1">REACT_PORTAL_TYPE:</span>
      <span class="s3">return </span><span class="s2">&quot;Portal&quot;</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s1">REACT_PROFILER_TYPE:</span>
      <span class="s3">return </span><span class="s2">&quot;Profiler&quot;</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s1">REACT_STRICT_MODE_TYPE:</span>
      <span class="s3">return </span><span class="s2">&quot;StrictMode&quot;</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s1">REACT_SUSPENSE_TYPE:</span>
      <span class="s3">return </span><span class="s2">&quot;Suspense&quot;</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s1">REACT_SUSPENSE_LIST_TYPE:</span>
      <span class="s3">return </span><span class="s2">&quot;SuspenseList&quot;</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">type === </span><span class="s2">&quot;object&quot;</span><span class="s1">) {</span>
    <span class="s3">switch </span><span class="s1">(type.$$typeof) {</span>
      <span class="s3">case </span><span class="s1">REACT_CONTEXT_TYPE:</span>
        <span class="s3">var </span><span class="s1">context = type;</span>
        <span class="s3">return </span><span class="s1">getContextName(context) + </span><span class="s2">&quot;.Consumer&quot;</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s1">REACT_PROVIDER_TYPE:</span>
        <span class="s3">var </span><span class="s1">provider = type;</span>
        <span class="s3">return </span><span class="s1">getContextName(provider._context) + </span><span class="s2">&quot;.Provider&quot;</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s1">REACT_FORWARD_REF_TYPE:</span>
        <span class="s3">return </span><span class="s1">getWrappedName(type, type.render, </span><span class="s2">&quot;ForwardRef&quot;</span><span class="s1">);</span>

      <span class="s3">case </span><span class="s1">REACT_MEMO_TYPE:</span>
        <span class="s3">var </span><span class="s1">outerName = type.displayName || </span><span class="s3">null</span><span class="s1">;</span>

        <span class="s3">if </span><span class="s1">(outerName !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s3">return </span><span class="s1">outerName;</span>
        <span class="s1">}</span>

        <span class="s3">return </span><span class="s1">getComponentNameFromType(type.type) || </span><span class="s2">&quot;Memo&quot;</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s1">REACT_LAZY_TYPE: {</span>
        <span class="s3">var </span><span class="s1">lazyComponent = type;</span>
        <span class="s3">var </span><span class="s1">payload = lazyComponent._payload;</span>
        <span class="s3">var </span><span class="s1">init = lazyComponent._init;</span>

        <span class="s3">try </span><span class="s1">{</span>
          <span class="s3">return </span><span class="s1">getComponentNameFromType(init(payload));</span>
        <span class="s1">} </span><span class="s3">catch </span><span class="s1">(x) {</span>
          <span class="s3">return null</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s0">// eslint-disable-next-line no-fallthrough</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">return null</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">getWrappedName$1(outerType, innerType, wrapperName) {</span>
  <span class="s3">var </span><span class="s1">functionName = innerType.displayName || innerType.name || </span><span class="s2">&quot;&quot;</span><span class="s1">;</span>
  <span class="s3">return </span><span class="s1">(</span>
    <span class="s1">outerType.displayName ||</span>
    <span class="s1">(functionName !== </span><span class="s2">&quot;&quot; </span><span class="s1">? wrapperName + </span><span class="s2">&quot;(&quot; </span><span class="s1">+ functionName + </span><span class="s2">&quot;)&quot; </span><span class="s1">: wrapperName)</span>
  <span class="s1">);</span>
<span class="s1">} </span><span class="s0">// Keep in sync with shared/getComponentNameFromType</span>

<span class="s3">function </span><span class="s1">getContextName$1(type) {</span>
  <span class="s3">return </span><span class="s1">type.displayName || </span><span class="s2">&quot;Context&quot;</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">getComponentNameFromFiber(fiber) {</span>
  <span class="s3">var </span><span class="s1">tag = fiber.tag,</span>
    <span class="s1">type = fiber.type;</span>

  <span class="s3">switch </span><span class="s1">(tag) {</span>
    <span class="s3">case </span><span class="s1">CacheComponent:</span>
      <span class="s3">return </span><span class="s2">&quot;Cache&quot;</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s1">ContextConsumer:</span>
      <span class="s3">var </span><span class="s1">context = type;</span>
      <span class="s3">return </span><span class="s1">getContextName$1(context) + </span><span class="s2">&quot;.Consumer&quot;</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s1">ContextProvider:</span>
      <span class="s3">var </span><span class="s1">provider = type;</span>
      <span class="s3">return </span><span class="s1">getContextName$1(provider._context) + </span><span class="s2">&quot;.Provider&quot;</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s1">DehydratedFragment:</span>
      <span class="s3">return </span><span class="s2">&quot;DehydratedFragment&quot;</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s1">ForwardRef:</span>
      <span class="s3">return </span><span class="s1">getWrappedName$1(type, type.render, </span><span class="s2">&quot;ForwardRef&quot;</span><span class="s1">);</span>

    <span class="s3">case </span><span class="s1">Fragment:</span>
      <span class="s3">return </span><span class="s2">&quot;Fragment&quot;</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s1">HostComponent:</span>
      <span class="s0">// Host component type is the display name (e.g. &quot;div&quot;, &quot;View&quot;)</span>
      <span class="s3">return </span><span class="s1">type;</span>

    <span class="s3">case </span><span class="s1">HostPortal:</span>
      <span class="s3">return </span><span class="s2">&quot;Portal&quot;</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s1">HostRoot:</span>
      <span class="s3">return </span><span class="s2">&quot;Root&quot;</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s1">HostText:</span>
      <span class="s3">return </span><span class="s2">&quot;Text&quot;</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s1">LazyComponent:</span>
      <span class="s0">// Name comes from the type in this case; we don't have a tag.</span>
      <span class="s3">return </span><span class="s1">getComponentNameFromType(type);</span>

    <span class="s3">case </span><span class="s1">Mode:</span>
      <span class="s3">if </span><span class="s1">(type === REACT_STRICT_MODE_TYPE) {</span>
        <span class="s0">// Don't be less specific than shared/getComponentNameFromType</span>
        <span class="s3">return </span><span class="s2">&quot;StrictMode&quot;</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">return </span><span class="s2">&quot;Mode&quot;</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s1">OffscreenComponent:</span>
      <span class="s3">return </span><span class="s2">&quot;Offscreen&quot;</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s1">Profiler:</span>
      <span class="s3">return </span><span class="s2">&quot;Profiler&quot;</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s1">ScopeComponent:</span>
      <span class="s3">return </span><span class="s2">&quot;Scope&quot;</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s1">SuspenseComponent:</span>
      <span class="s3">return </span><span class="s2">&quot;Suspense&quot;</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s1">SuspenseListComponent:</span>
      <span class="s3">return </span><span class="s2">&quot;SuspenseList&quot;</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s1">TracingMarkerComponent:</span>
      <span class="s3">return </span><span class="s2">&quot;TracingMarker&quot;</span><span class="s1">;</span>
    <span class="s0">// The display name for this tags come from the user-provided type:</span>

    <span class="s3">case </span><span class="s1">ClassComponent:</span>
    <span class="s3">case </span><span class="s1">FunctionComponent:</span>
    <span class="s3">case </span><span class="s1">IncompleteClassComponent:</span>
    <span class="s3">case </span><span class="s1">IndeterminateComponent:</span>
    <span class="s3">case </span><span class="s1">MemoComponent:</span>
    <span class="s3">case </span><span class="s1">SimpleMemoComponent:</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">type === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
        <span class="s3">return </span><span class="s1">type.displayName || type.name || </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">type === </span><span class="s2">&quot;string&quot;</span><span class="s1">) {</span>
        <span class="s3">return </span><span class="s1">type;</span>
      <span class="s1">}</span>

      <span class="s3">break</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">return null</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">// Don't change these two values. They're used by React Dev Tools.</span>
<span class="s3">var </span><span class="s1">NoFlags =</span>
  <span class="s0">/*                      */</span>
  <span class="s4">0</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">PerformedWork =</span>
  <span class="s0">/*                */</span>
  <span class="s4">1</span><span class="s1">; </span><span class="s0">// You can change the rest (and add more).</span>

<span class="s3">var </span><span class="s1">Placement =</span>
  <span class="s0">/*                    */</span>
  <span class="s4">2</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">Update =</span>
  <span class="s0">/*                       */</span>
  <span class="s4">4</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">ChildDeletion =</span>
  <span class="s0">/*                */</span>
  <span class="s4">16</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">ContentReset =</span>
  <span class="s0">/*                 */</span>
  <span class="s4">32</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">Callback =</span>
  <span class="s0">/*                     */</span>
  <span class="s4">64</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">DidCapture =</span>
  <span class="s0">/*                   */</span>
  <span class="s4">128</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">ForceClientRender =</span>
  <span class="s0">/*            */</span>
  <span class="s4">256</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">Ref =</span>
  <span class="s0">/*                          */</span>
  <span class="s4">512</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">Snapshot =</span>
  <span class="s0">/*                     */</span>
  <span class="s4">1024</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">Passive =</span>
  <span class="s0">/*                      */</span>
  <span class="s4">2048</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">Hydrating =</span>
  <span class="s0">/*                    */</span>
  <span class="s4">4096</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">Visibility =</span>
  <span class="s0">/*                   */</span>
  <span class="s4">8192</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">StoreConsistency =</span>
  <span class="s0">/*             */</span>
  <span class="s4">16384</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">LifecycleEffectMask =</span>
  <span class="s1">Passive | Update | Callback | Ref | Snapshot | StoreConsistency; </span><span class="s0">// Union of all commit flags (flags with the lifetime of a particular commit)</span>

<span class="s3">var </span><span class="s1">HostEffectMask =</span>
  <span class="s0">/*               */</span>
  <span class="s4">32767</span><span class="s1">; </span><span class="s0">// These are not really side effects, but we still reuse this field.</span>

<span class="s3">var </span><span class="s1">Incomplete =</span>
  <span class="s0">/*                   */</span>
  <span class="s4">32768</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">ShouldCapture =</span>
  <span class="s0">/*                */</span>
  <span class="s4">65536</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">ForceUpdateForLegacySuspense =</span>
  <span class="s0">/* */</span>
  <span class="s4">131072</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">Forked =</span>
  <span class="s0">/*                       */</span>
  <span class="s4">1048576</span><span class="s1">; </span><span class="s0">// Static tags describe aspects of a fiber that are not specific to a render,</span>
<span class="s0">// e.g. a fiber uses a passive effect (even if there are no updates on this particular render).</span>
<span class="s0">// This enables us to defer more work in the unmount case,</span>
<span class="s0">// since we can defer traversing the tree during layout to look for Passive effects,</span>
<span class="s0">// and instead rely on the static flag as a signal that there may be cleanup work.</span>

<span class="s3">var </span><span class="s1">RefStatic =</span>
  <span class="s0">/*                    */</span>
  <span class="s4">2097152</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">LayoutStatic =</span>
  <span class="s0">/*                 */</span>
  <span class="s4">4194304</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">PassiveStatic =</span>
  <span class="s0">/*                */</span>
  <span class="s4">8388608</span><span class="s1">; </span><span class="s0">// These flags allow us to traverse to fibers that have effects on mount</span>
<span class="s0">// don't contain effects, by checking subtreeFlags.</span>

<span class="s3">var </span><span class="s1">BeforeMutationMask = </span><span class="s0">// TODO: Remove Update flag from before mutation phase by re-landing Visibility</span>
  <span class="s0">// flag logic (see #20043)</span>
  <span class="s1">Update | Snapshot | </span><span class="s4">0</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">MutationMask =</span>
  <span class="s1">Placement |</span>
  <span class="s1">Update |</span>
  <span class="s1">ChildDeletion |</span>
  <span class="s1">ContentReset |</span>
  <span class="s1">Ref |</span>
  <span class="s1">Hydrating |</span>
  <span class="s1">Visibility;</span>
<span class="s3">var </span><span class="s1">LayoutMask = Update | Callback | Ref | Visibility; </span><span class="s0">// TODO: Split into PassiveMountMask and PassiveUnmountMask</span>

<span class="s3">var </span><span class="s1">PassiveMask = Passive | ChildDeletion; </span><span class="s0">// Union of tags that don't get reset on clones.</span>
<span class="s0">// This allows certain concepts to persist without recalculating them,</span>
<span class="s0">// e.g. whether a subtree contains passive effects or portals.</span>

<span class="s3">var </span><span class="s1">StaticMask = LayoutStatic | PassiveStatic | RefStatic;</span>

<span class="s3">var </span><span class="s1">ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;</span>
<span class="s3">function </span><span class="s1">getNearestMountedFiber(fiber) {</span>
  <span class="s3">var </span><span class="s1">node = fiber;</span>
  <span class="s3">var </span><span class="s1">nearestMounted = fiber;</span>

  <span class="s3">if </span><span class="s1">(!fiber.alternate) {</span>
    <span class="s0">// If there is no alternate, this might be a new tree that isn't inserted</span>
    <span class="s0">// yet. If it is, then it will have a pending insertion effect on it.</span>
    <span class="s3">var </span><span class="s1">nextNode = node;</span>

    <span class="s3">do </span><span class="s1">{</span>
      <span class="s1">node = nextNode;</span>

      <span class="s3">if </span><span class="s1">((node.flags &amp; (Placement | Hydrating)) !== NoFlags) {</span>
        <span class="s0">// This is an insertion or in-progress hydration. The nearest possible</span>
        <span class="s0">// mounted fiber is the parent but we need to continue to figure out</span>
        <span class="s0">// if that one is still mounted.</span>
        <span class="s1">nearestMounted = node.</span><span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">nextNode = node.</span><span class="s3">return</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">while </span><span class="s1">(nextNode);</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s3">while </span><span class="s1">(node.</span><span class="s3">return</span><span class="s1">) {</span>
      <span class="s1">node = node.</span><span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(node.tag === HostRoot) {</span>
    <span class="s0">// TODO: Check if this was a nested HostRoot when used with</span>
    <span class="s0">// renderContainerIntoSubtree.</span>
    <span class="s3">return </span><span class="s1">nearestMounted;</span>
  <span class="s1">} </span><span class="s0">// If we didn't hit the root, that means that we're in an disconnected tree</span>
  <span class="s0">// that has been unmounted.</span>

  <span class="s3">return null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">isFiberMounted(fiber) {</span>
  <span class="s3">return </span><span class="s1">getNearestMountedFiber(fiber) === fiber;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">isMounted(component) {</span>
  <span class="s1">{</span>
    <span class="s3">var </span><span class="s1">owner = ReactCurrentOwner.current;</span>

    <span class="s3">if </span><span class="s1">(owner !== </span><span class="s3">null </span><span class="s1">&amp;&amp; owner.tag === ClassComponent) {</span>
      <span class="s3">var </span><span class="s1">ownerFiber = owner;</span>
      <span class="s3">var </span><span class="s1">instance = ownerFiber.stateNode;</span>

      <span class="s3">if </span><span class="s1">(!instance._warnedAboutRefsInRender) {</span>
        <span class="s1">error(</span>
          <span class="s2">&quot;%s is accessing isMounted inside its render() function. &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;render() should be a pure function of props and state. It should &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;never access something that requires stale data from the previous &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;render, such as refs. Move this logic to componentDidMount and &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;componentDidUpdate instead.&quot;</span><span class="s1">,</span>
          <span class="s1">getComponentNameFromFiber(ownerFiber) || </span><span class="s2">&quot;A component&quot;</span>
        <span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s1">instance._warnedAboutRefsInRender = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">fiber = get(component);</span>

  <span class="s3">if </span><span class="s1">(!fiber) {</span>
    <span class="s3">return false</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">getNearestMountedFiber(fiber) === fiber;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">assertIsMounted(fiber) {</span>
  <span class="s3">if </span><span class="s1">(getNearestMountedFiber(fiber) !== fiber) {</span>
    <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Unable to find node on an unmounted component.&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">findCurrentFiberUsingSlowPath(fiber) {</span>
  <span class="s3">var </span><span class="s1">alternate = fiber.alternate;</span>

  <span class="s3">if </span><span class="s1">(!alternate) {</span>
    <span class="s0">// If there is no alternate, then we only need to check if it is mounted.</span>
    <span class="s3">var </span><span class="s1">nearestMounted = getNearestMountedFiber(fiber);</span>

    <span class="s3">if </span><span class="s1">(nearestMounted === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Unable to find node on an unmounted component.&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(nearestMounted !== fiber) {</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">fiber;</span>
  <span class="s1">} </span><span class="s0">// If we have two possible branches, we'll walk backwards up to the root</span>
  <span class="s0">// to see what path the root points to. On the way we may hit one of the</span>
  <span class="s0">// special cases and we'll deal with them.</span>

  <span class="s3">var </span><span class="s1">a = fiber;</span>
  <span class="s3">var </span><span class="s1">b = alternate;</span>

  <span class="s3">while </span><span class="s1">(</span><span class="s3">true</span><span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">parentA = a.</span><span class="s3">return</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s1">(parentA === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// We're at the root.</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">parentB = parentA.alternate;</span>

    <span class="s3">if </span><span class="s1">(parentB === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// There is no alternate. This is an unusual case. Currently, it only</span>
      <span class="s0">// happens when a Suspense component is hidden. An extra fragment fiber</span>
      <span class="s0">// is inserted in between the Suspense fiber and its children. Skip</span>
      <span class="s0">// over this extra fragment fiber and proceed to the next parent.</span>
      <span class="s3">var </span><span class="s1">nextParent = parentA.</span><span class="s3">return</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s1">(nextParent !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">a = b = nextParent;</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// If there's no parent, we're at the root.</span>

      <span class="s3">break</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s0">// If both copies of the parent fiber point to the same child, we can</span>
    <span class="s0">// assume that the child is current. This happens when we bailout on low</span>
    <span class="s0">// priority: the bailed out fiber's child reuses the current child.</span>

    <span class="s3">if </span><span class="s1">(parentA.child === parentB.child) {</span>
      <span class="s3">var </span><span class="s1">child = parentA.child;</span>

      <span class="s3">while </span><span class="s1">(child) {</span>
        <span class="s3">if </span><span class="s1">(child === a) {</span>
          <span class="s0">// We've determined that A is the current branch.</span>
          <span class="s1">assertIsMounted(parentA);</span>
          <span class="s3">return </span><span class="s1">fiber;</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(child === b) {</span>
          <span class="s0">// We've determined that B is the current branch.</span>
          <span class="s1">assertIsMounted(parentA);</span>
          <span class="s3">return </span><span class="s1">alternate;</span>
        <span class="s1">}</span>

        <span class="s1">child = child.sibling;</span>
      <span class="s1">} </span><span class="s0">// We should never have an alternate for any mounting node. So the only</span>
      <span class="s0">// way this could possibly happen is if this was unmounted, if at all.</span>

      <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Unable to find node on an unmounted component.&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(a.</span><span class="s3">return </span><span class="s1">!== b.</span><span class="s3">return</span><span class="s1">) {</span>
      <span class="s0">// The return pointer of A and the return pointer of B point to different</span>
      <span class="s0">// fibers. We assume that return pointers never criss-cross, so A must</span>
      <span class="s0">// belong to the child set of A.return, and B must belong to the child</span>
      <span class="s0">// set of B.return.</span>
      <span class="s1">a = parentA;</span>
      <span class="s1">b = parentB;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s0">// The return pointers point to the same fiber. We'll have to use the</span>
      <span class="s0">// default, slow path: scan the child sets of each parent alternate to see</span>
      <span class="s0">// which child belongs to which set.</span>
      <span class="s0">//</span>
      <span class="s0">// Search parent A's child set</span>
      <span class="s3">var </span><span class="s1">didFindChild = </span><span class="s3">false</span><span class="s1">;</span>
      <span class="s3">var </span><span class="s1">_child = parentA.child;</span>

      <span class="s3">while </span><span class="s1">(_child) {</span>
        <span class="s3">if </span><span class="s1">(_child === a) {</span>
          <span class="s1">didFindChild = </span><span class="s3">true</span><span class="s1">;</span>
          <span class="s1">a = parentA;</span>
          <span class="s1">b = parentB;</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(_child === b) {</span>
          <span class="s1">didFindChild = </span><span class="s3">true</span><span class="s1">;</span>
          <span class="s1">b = parentA;</span>
          <span class="s1">a = parentB;</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">_child = _child.sibling;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(!didFindChild) {</span>
        <span class="s0">// Search parent B's child set</span>
        <span class="s1">_child = parentB.child;</span>

        <span class="s3">while </span><span class="s1">(_child) {</span>
          <span class="s3">if </span><span class="s1">(_child === a) {</span>
            <span class="s1">didFindChild = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s1">a = parentB;</span>
            <span class="s1">b = parentA;</span>
            <span class="s3">break</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s3">if </span><span class="s1">(_child === b) {</span>
            <span class="s1">didFindChild = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s1">b = parentB;</span>
            <span class="s1">a = parentA;</span>
            <span class="s3">break</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s1">_child = _child.sibling;</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(!didFindChild) {</span>
          <span class="s3">throw new </span><span class="s1">Error(</span>
            <span class="s2">&quot;Child was not found in either parent set. This indicates a bug &quot; </span><span class="s1">+</span>
              <span class="s2">&quot;in React related to the return pointer. Please file an issue.&quot;</span>
          <span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(a.alternate !== b) {</span>
      <span class="s3">throw new </span><span class="s1">Error(</span>
        <span class="s2">&quot;Return fibers should always be each others' alternates. &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;This error is likely caused by a bug in React. Please file an issue.&quot;</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s0">// If the root is not a host container, we're in a disconnected tree. I.e.</span>
  <span class="s0">// unmounted.</span>

  <span class="s3">if </span><span class="s1">(a.tag !== HostRoot) {</span>
    <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Unable to find node on an unmounted component.&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(a.stateNode.current === a) {</span>
    <span class="s0">// We've determined that A is the current branch.</span>
    <span class="s3">return </span><span class="s1">fiber;</span>
  <span class="s1">} </span><span class="s0">// Otherwise B has to be current branch.</span>

  <span class="s3">return </span><span class="s1">alternate;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">findCurrentHostFiber(parent) {</span>
  <span class="s3">var </span><span class="s1">currentParent = findCurrentFiberUsingSlowPath(parent);</span>
  <span class="s3">return </span><span class="s1">currentParent !== </span><span class="s3">null</span>
    <span class="s1">? findCurrentHostFiberImpl(currentParent)</span>
    <span class="s1">: </span><span class="s3">null</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">findCurrentHostFiberImpl(node) {</span>
  <span class="s0">// Next we'll drill down this component to find the first HostComponent/Text.</span>
  <span class="s3">if </span><span class="s1">(node.tag === HostComponent || node.tag === HostText) {</span>
    <span class="s3">return </span><span class="s1">node;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">child = node.child;</span>

  <span class="s3">while </span><span class="s1">(child !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">match = findCurrentHostFiberImpl(child);</span>

    <span class="s3">if </span><span class="s1">(match !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">return </span><span class="s1">match;</span>
    <span class="s1">}</span>

    <span class="s1">child = child.sibling;</span>
  <span class="s1">}</span>

  <span class="s3">return null</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">/** 
 * In the future, we should cleanup callbacks by cancelling them instead of 
 * using this. 
 */</span>
<span class="s3">function </span><span class="s1">mountSafeCallback_NOT_REALLY_SAFE(context, callback) {</span>
  <span class="s3">return function</span><span class="s1">() {</span>
    <span class="s3">if </span><span class="s1">(!callback) {</span>
      <span class="s3">return </span><span class="s1">undefined;</span>
    <span class="s1">} </span><span class="s0">// This protects against createClass() components.</span>
    <span class="s0">// We don't know if there is code depending on it.</span>
    <span class="s0">// We intentionally don't use isMounted() because even accessing</span>
    <span class="s0">// isMounted property on a React ES6 class will trigger a warning.</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">context.__isMounted === </span><span class="s2">&quot;boolean&quot;</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(!context.__isMounted) {</span>
        <span class="s3">return </span><span class="s1">undefined;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// FIXME: there used to be other branches that protected</span>
    <span class="s0">// against unmounted host components. But RN host components don't</span>
    <span class="s0">// define isMounted() anymore, so those checks didn't do anything.</span>
    <span class="s0">// They caused false positive warning noise so we removed them:</span>
    <span class="s0">// https://github.com/facebook/react-native/issues/18868#issuecomment-413579095</span>
    <span class="s0">// However, this means that the callback is NOT guaranteed to be safe</span>
    <span class="s0">// for host components. The solution we should implement is to make</span>
    <span class="s0">// UIManager.measure() and similar calls truly cancelable. Then we</span>
    <span class="s0">// can change our own code calling them to cancel when something unmounts.</span>

    <span class="s3">return </span><span class="s1">callback.apply(context, arguments);</span>
  <span class="s1">};</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">warnForStyleProps(props, validAttributes) {</span>
  <span class="s1">{</span>
    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">key </span><span class="s3">in </span><span class="s1">validAttributes.style) {</span>
      <span class="s3">if </span><span class="s1">(!(validAttributes[key] || props[key] === undefined)) {</span>
        <span class="s1">error(</span>
          <span class="s2">&quot;You are setting the style `{ %s&quot; </span><span class="s1">+</span>
            <span class="s2">&quot;: ... }` as a prop. You &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;should nest it in a style object. &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;E.g. `{ style: { %s&quot; </span><span class="s1">+</span>
            <span class="s2">&quot;: ... } }`&quot;</span><span class="s1">,</span>
          <span class="s1">key,</span>
          <span class="s1">key</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">// Modules provided by RN:</span>
<span class="s3">var </span><span class="s1">emptyObject = {};</span>
<span class="s0">/** 
 * Create a payload that contains all the updates between two sets of props. 
 * 
 * These helpers are all encapsulated into a single module, because they use 
 * mutation as a performance optimization which leads to subtle shared 
 * dependencies between the code paths. To avoid this mutable state leaking 
 * across modules, I've kept them isolated to this module. 
 */</span>

<span class="s0">// Tracks removed keys</span>
<span class="s3">var </span><span class="s1">removedKeys = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">removedKeyCount = </span><span class="s4">0</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">deepDifferOptions = {</span>
  <span class="s1">unsafelyIgnoreFunctions: </span><span class="s3">true</span>
<span class="s1">};</span>

<span class="s3">function </span><span class="s1">defaultDiffer(prevProp, nextProp) {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">nextProp !== </span><span class="s2">&quot;object&quot; </span><span class="s1">|| nextProp === </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s0">// Scalars have already been checked for equality</span>
    <span class="s3">return true</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s0">// For objects and arrays, the default diffing algorithm is a deep compare</span>
    <span class="s3">return </span><span class="s1">ReactNativePrivateInterface.deepDiffer(</span>
      <span class="s1">prevProp,</span>
      <span class="s1">nextProp,</span>
      <span class="s1">deepDifferOptions</span>
    <span class="s1">);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">restoreDeletedValuesInNestedArray(</span>
  <span class="s1">updatePayload,</span>
  <span class="s1">node,</span>
  <span class="s1">validAttributes</span>
<span class="s1">) {</span>
  <span class="s3">if </span><span class="s1">(isArray(node)) {</span>
    <span class="s3">var </span><span class="s1">i = node.length;</span>

    <span class="s3">while </span><span class="s1">(i-- &amp;&amp; removedKeyCount &gt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s1">restoreDeletedValuesInNestedArray(</span>
        <span class="s1">updatePayload,</span>
        <span class="s1">node[i],</span>
        <span class="s1">validAttributes</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(node &amp;&amp; removedKeyCount &gt; </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">obj = node;</span>

    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">propKey </span><span class="s3">in </span><span class="s1">removedKeys) {</span>
      <span class="s3">if </span><span class="s1">(!removedKeys[propKey]) {</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">nextProp = obj[propKey];</span>

      <span class="s3">if </span><span class="s1">(nextProp === undefined) {</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">attributeConfig = validAttributes[propKey];</span>

      <span class="s3">if </span><span class="s1">(!attributeConfig) {</span>
        <span class="s3">continue</span><span class="s1">; </span><span class="s0">// not a valid native prop</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">nextProp === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
        <span class="s1">nextProp = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">nextProp === </span><span class="s2">&quot;undefined&quot;</span><span class="s1">) {</span>
        <span class="s1">nextProp = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">attributeConfig !== </span><span class="s2">&quot;object&quot;</span><span class="s1">) {</span>
        <span class="s0">// case: !Object is the default case</span>
        <span class="s1">updatePayload[propKey] = nextProp;</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span>
        <span class="s3">typeof </span><span class="s1">attributeConfig.diff === </span><span class="s2">&quot;function&quot; </span><span class="s1">||</span>
        <span class="s3">typeof </span><span class="s1">attributeConfig.process === </span><span class="s2">&quot;function&quot;</span>
      <span class="s1">) {</span>
        <span class="s0">// case: CustomAttributeConfiguration</span>
        <span class="s3">var </span><span class="s1">nextValue =</span>
          <span class="s3">typeof </span><span class="s1">attributeConfig.process === </span><span class="s2">&quot;function&quot;</span>
            <span class="s1">? attributeConfig.process(nextProp)</span>
            <span class="s1">: nextProp;</span>
        <span class="s1">updatePayload[propKey] = nextValue;</span>
      <span class="s1">}</span>

      <span class="s1">removedKeys[propKey] = </span><span class="s3">false</span><span class="s1">;</span>
      <span class="s1">removedKeyCount--;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">diffNestedArrayProperty(</span>
  <span class="s1">updatePayload,</span>
  <span class="s1">prevArray,</span>
  <span class="s1">nextArray,</span>
  <span class="s1">validAttributes</span>
<span class="s1">) {</span>
  <span class="s3">var </span><span class="s1">minLength =</span>
    <span class="s1">prevArray.length &lt; nextArray.length ? prevArray.length : nextArray.length;</span>
  <span class="s3">var </span><span class="s1">i;</span>

  <span class="s3">for </span><span class="s1">(i = </span><span class="s4">0</span><span class="s1">; i &lt; minLength; i++) {</span>
    <span class="s0">// Diff any items in the array in the forward direction. Repeated keys</span>
    <span class="s0">// will be overwritten by later values.</span>
    <span class="s1">updatePayload = diffNestedProperty(</span>
      <span class="s1">updatePayload,</span>
      <span class="s1">prevArray[i],</span>
      <span class="s1">nextArray[i],</span>
      <span class="s1">validAttributes</span>
    <span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s3">for </span><span class="s1">(; i &lt; prevArray.length; i++) {</span>
    <span class="s0">// Clear out all remaining properties.</span>
    <span class="s1">updatePayload = clearNestedProperty(</span>
      <span class="s1">updatePayload,</span>
      <span class="s1">prevArray[i],</span>
      <span class="s1">validAttributes</span>
    <span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s3">for </span><span class="s1">(; i &lt; nextArray.length; i++) {</span>
    <span class="s0">// Add all remaining properties.</span>
    <span class="s1">updatePayload = addNestedProperty(</span>
      <span class="s1">updatePayload,</span>
      <span class="s1">nextArray[i],</span>
      <span class="s1">validAttributes</span>
    <span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">updatePayload;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">diffNestedProperty(</span>
  <span class="s1">updatePayload,</span>
  <span class="s1">prevProp,</span>
  <span class="s1">nextProp,</span>
  <span class="s1">validAttributes</span>
<span class="s1">) {</span>
  <span class="s3">if </span><span class="s1">(!updatePayload &amp;&amp; prevProp === nextProp) {</span>
    <span class="s0">// If no properties have been added, then we can bail out quickly on object</span>
    <span class="s0">// equality.</span>
    <span class="s3">return </span><span class="s1">updatePayload;</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(!prevProp || !nextProp) {</span>
    <span class="s3">if </span><span class="s1">(nextProp) {</span>
      <span class="s3">return </span><span class="s1">addNestedProperty(updatePayload, nextProp, validAttributes);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(prevProp) {</span>
      <span class="s3">return </span><span class="s1">clearNestedProperty(updatePayload, prevProp, validAttributes);</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">updatePayload;</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(!isArray(prevProp) &amp;&amp; !isArray(nextProp)) {</span>
    <span class="s0">// Both are leaves, we can diff the leaves.</span>
    <span class="s3">return </span><span class="s1">diffProperties(updatePayload, prevProp, nextProp, validAttributes);</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(isArray(prevProp) &amp;&amp; isArray(nextProp)) {</span>
    <span class="s0">// Both are arrays, we can diff the arrays.</span>
    <span class="s3">return </span><span class="s1">diffNestedArrayProperty(</span>
      <span class="s1">updatePayload,</span>
      <span class="s1">prevProp,</span>
      <span class="s1">nextProp,</span>
      <span class="s1">validAttributes</span>
    <span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(isArray(prevProp)) {</span>
    <span class="s3">return </span><span class="s1">diffProperties(</span>
      <span class="s1">updatePayload, </span><span class="s0">// $FlowFixMe - We know that this is always an object when the input is.</span>
      <span class="s1">ReactNativePrivateInterface.flattenStyle(prevProp), </span><span class="s0">// $FlowFixMe - We know that this isn't an array because of above flow.</span>
      <span class="s1">nextProp,</span>
      <span class="s1">validAttributes</span>
    <span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">diffProperties(</span>
    <span class="s1">updatePayload,</span>
    <span class="s1">prevProp, </span><span class="s0">// $FlowFixMe - We know that this is always an object when the input is.</span>
    <span class="s1">ReactNativePrivateInterface.flattenStyle(nextProp),</span>
    <span class="s1">validAttributes</span>
  <span class="s1">);</span>
<span class="s1">}</span>
<span class="s0">/** 
 * addNestedProperty takes a single set of props and valid attribute 
 * attribute configurations. It processes each prop and adds it to the 
 * updatePayload. 
 */</span>

<span class="s3">function </span><span class="s1">addNestedProperty(updatePayload, nextProp, validAttributes) {</span>
  <span class="s3">if </span><span class="s1">(!nextProp) {</span>
    <span class="s3">return </span><span class="s1">updatePayload;</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(!isArray(nextProp)) {</span>
    <span class="s0">// Add each property of the leaf.</span>
    <span class="s3">return </span><span class="s1">addProperties(updatePayload, nextProp, validAttributes);</span>
  <span class="s1">}</span>

  <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; nextProp.length; i++) {</span>
    <span class="s0">// Add all the properties of the array.</span>
    <span class="s1">updatePayload = addNestedProperty(</span>
      <span class="s1">updatePayload,</span>
      <span class="s1">nextProp[i],</span>
      <span class="s1">validAttributes</span>
    <span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">updatePayload;</span>
<span class="s1">}</span>
<span class="s0">/** 
 * clearNestedProperty takes a single set of props and valid attributes. It 
 * adds a null sentinel to the updatePayload, for each prop key. 
 */</span>

<span class="s3">function </span><span class="s1">clearNestedProperty(updatePayload, prevProp, validAttributes) {</span>
  <span class="s3">if </span><span class="s1">(!prevProp) {</span>
    <span class="s3">return </span><span class="s1">updatePayload;</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(!isArray(prevProp)) {</span>
    <span class="s0">// Add each property of the leaf.</span>
    <span class="s3">return </span><span class="s1">clearProperties(updatePayload, prevProp, validAttributes);</span>
  <span class="s1">}</span>

  <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; prevProp.length; i++) {</span>
    <span class="s0">// Add all the properties of the array.</span>
    <span class="s1">updatePayload = clearNestedProperty(</span>
      <span class="s1">updatePayload,</span>
      <span class="s1">prevProp[i],</span>
      <span class="s1">validAttributes</span>
    <span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">updatePayload;</span>
<span class="s1">}</span>
<span class="s0">/** 
 * diffProperties takes two sets of props and a set of valid attributes 
 * and write to updatePayload the values that changed or were deleted. 
 * If no updatePayload is provided, a new one is created and returned if 
 * anything changed. 
 */</span>

<span class="s3">function </span><span class="s1">diffProperties(updatePayload, prevProps, nextProps, validAttributes) {</span>
  <span class="s3">var </span><span class="s1">attributeConfig;</span>
  <span class="s3">var </span><span class="s1">nextProp;</span>
  <span class="s3">var </span><span class="s1">prevProp;</span>

  <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">propKey </span><span class="s3">in </span><span class="s1">nextProps) {</span>
    <span class="s1">attributeConfig = validAttributes[propKey];</span>

    <span class="s3">if </span><span class="s1">(!attributeConfig) {</span>
      <span class="s3">continue</span><span class="s1">; </span><span class="s0">// not a valid native prop</span>
    <span class="s1">}</span>

    <span class="s1">prevProp = prevProps[propKey];</span>
    <span class="s1">nextProp = nextProps[propKey]; </span><span class="s0">// functions are converted to booleans as markers that the associated</span>
    <span class="s0">// events should be sent from native.</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">nextProp === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
      <span class="s1">nextProp = </span><span class="s3">true</span><span class="s1">; </span><span class="s0">// If nextProp is not a function, then don't bother changing prevProp</span>
      <span class="s0">// since nextProp will win and go into the updatePayload regardless.</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">prevProp === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
        <span class="s1">prevProp = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// An explicit value of undefined is treated as a null because it overrides</span>
    <span class="s0">// any other preceding value.</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">nextProp === </span><span class="s2">&quot;undefined&quot;</span><span class="s1">) {</span>
      <span class="s1">nextProp = </span><span class="s3">null</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">prevProp === </span><span class="s2">&quot;undefined&quot;</span><span class="s1">) {</span>
        <span class="s1">prevProp = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(removedKeys) {</span>
      <span class="s1">removedKeys[propKey] = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(updatePayload &amp;&amp; updatePayload[propKey] !== undefined) {</span>
      <span class="s0">// Something else already triggered an update to this key because another</span>
      <span class="s0">// value diffed. Since we're now later in the nested arrays our value is</span>
      <span class="s0">// more important so we need to calculate it and override the existing</span>
      <span class="s0">// value. It doesn't matter if nothing changed, we'll set it anyway.</span>
      <span class="s0">// Pattern match on: attributeConfig</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">attributeConfig !== </span><span class="s2">&quot;object&quot;</span><span class="s1">) {</span>
        <span class="s0">// case: !Object is the default case</span>
        <span class="s1">updatePayload[propKey] = nextProp;</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span>
        <span class="s3">typeof </span><span class="s1">attributeConfig.diff === </span><span class="s2">&quot;function&quot; </span><span class="s1">||</span>
        <span class="s3">typeof </span><span class="s1">attributeConfig.process === </span><span class="s2">&quot;function&quot;</span>
      <span class="s1">) {</span>
        <span class="s0">// case: CustomAttributeConfiguration</span>
        <span class="s3">var </span><span class="s1">nextValue =</span>
          <span class="s3">typeof </span><span class="s1">attributeConfig.process === </span><span class="s2">&quot;function&quot;</span>
            <span class="s1">? attributeConfig.process(nextProp)</span>
            <span class="s1">: nextProp;</span>
        <span class="s1">updatePayload[propKey] = nextValue;</span>
      <span class="s1">}</span>

      <span class="s3">continue</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(prevProp === nextProp) {</span>
      <span class="s3">continue</span><span class="s1">; </span><span class="s0">// nothing changed</span>
    <span class="s1">} </span><span class="s0">// Pattern match on: attributeConfig</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">attributeConfig !== </span><span class="s2">&quot;object&quot;</span><span class="s1">) {</span>
      <span class="s0">// case: !Object is the default case</span>
      <span class="s3">if </span><span class="s1">(defaultDiffer(prevProp, nextProp)) {</span>
        <span class="s0">// a normal leaf has changed</span>
        <span class="s1">(updatePayload || (updatePayload = {}))[propKey] = nextProp;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span>
      <span class="s3">typeof </span><span class="s1">attributeConfig.diff === </span><span class="s2">&quot;function&quot; </span><span class="s1">||</span>
      <span class="s3">typeof </span><span class="s1">attributeConfig.process === </span><span class="s2">&quot;function&quot;</span>
    <span class="s1">) {</span>
      <span class="s0">// case: CustomAttributeConfiguration</span>
      <span class="s3">var </span><span class="s1">shouldUpdate =</span>
        <span class="s1">prevProp === undefined ||</span>
        <span class="s1">(</span><span class="s3">typeof </span><span class="s1">attributeConfig.diff === </span><span class="s2">&quot;function&quot;</span>
          <span class="s1">? attributeConfig.diff(prevProp, nextProp)</span>
          <span class="s1">: defaultDiffer(prevProp, nextProp));</span>

      <span class="s3">if </span><span class="s1">(shouldUpdate) {</span>
        <span class="s3">var </span><span class="s1">_nextValue =</span>
          <span class="s3">typeof </span><span class="s1">attributeConfig.process === </span><span class="s2">&quot;function&quot;</span>
            <span class="s1">? attributeConfig.process(nextProp)</span>
            <span class="s1">: nextProp;</span>

        <span class="s1">(updatePayload || (updatePayload = {}))[propKey] = _nextValue;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s0">// default: fallthrough case when nested properties are defined</span>
      <span class="s1">removedKeys = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">removedKeyCount = </span><span class="s4">0</span><span class="s1">; </span><span class="s0">// We think that attributeConfig is not CustomAttributeConfiguration at</span>
      <span class="s0">// this point so we assume it must be AttributeConfiguration.</span>

      <span class="s1">updatePayload = diffNestedProperty(</span>
        <span class="s1">updatePayload,</span>
        <span class="s1">prevProp,</span>
        <span class="s1">nextProp,</span>
        <span class="s1">attributeConfig</span>
      <span class="s1">);</span>

      <span class="s3">if </span><span class="s1">(removedKeyCount &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; updatePayload) {</span>
        <span class="s1">restoreDeletedValuesInNestedArray(</span>
          <span class="s1">updatePayload,</span>
          <span class="s1">nextProp,</span>
          <span class="s1">attributeConfig</span>
        <span class="s1">);</span>
        <span class="s1">removedKeys = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s0">// Also iterate through all the previous props to catch any that have been</span>
  <span class="s0">// removed and make sure native gets the signal so it can reset them to the</span>
  <span class="s0">// default.</span>

  <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">_propKey </span><span class="s3">in </span><span class="s1">prevProps) {</span>
    <span class="s3">if </span><span class="s1">(nextProps[_propKey] !== undefined) {</span>
      <span class="s3">continue</span><span class="s1">; </span><span class="s0">// we've already covered this key in the previous pass</span>
    <span class="s1">}</span>

    <span class="s1">attributeConfig = validAttributes[_propKey];</span>

    <span class="s3">if </span><span class="s1">(!attributeConfig) {</span>
      <span class="s3">continue</span><span class="s1">; </span><span class="s0">// not a valid native prop</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(updatePayload &amp;&amp; updatePayload[_propKey] !== undefined) {</span>
      <span class="s0">// This was already updated to a diff result earlier.</span>
      <span class="s3">continue</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">prevProp = prevProps[_propKey];</span>

    <span class="s3">if </span><span class="s1">(prevProp === undefined) {</span>
      <span class="s3">continue</span><span class="s1">; </span><span class="s0">// was already empty anyway</span>
    <span class="s1">} </span><span class="s0">// Pattern match on: attributeConfig</span>

    <span class="s3">if </span><span class="s1">(</span>
      <span class="s3">typeof </span><span class="s1">attributeConfig !== </span><span class="s2">&quot;object&quot; </span><span class="s1">||</span>
      <span class="s3">typeof </span><span class="s1">attributeConfig.diff === </span><span class="s2">&quot;function&quot; </span><span class="s1">||</span>
      <span class="s3">typeof </span><span class="s1">attributeConfig.process === </span><span class="s2">&quot;function&quot;</span>
    <span class="s1">) {</span>
      <span class="s0">// case: CustomAttributeConfiguration | !Object</span>
      <span class="s0">// Flag the leaf property for removal by sending a sentinel.</span>
      <span class="s1">(updatePayload || (updatePayload = {}))[_propKey] = </span><span class="s3">null</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s1">(!removedKeys) {</span>
        <span class="s1">removedKeys = {};</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(!removedKeys[_propKey]) {</span>
        <span class="s1">removedKeys[_propKey] = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s1">removedKeyCount++;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s0">// default:</span>
      <span class="s0">// This is a nested attribute configuration where all the properties</span>
      <span class="s0">// were removed so we need to go through and clear out all of them.</span>
      <span class="s1">updatePayload = clearNestedProperty(</span>
        <span class="s1">updatePayload,</span>
        <span class="s1">prevProp,</span>
        <span class="s1">attributeConfig</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">updatePayload;</span>
<span class="s1">}</span>
<span class="s0">/** 
 * addProperties adds all the valid props to the payload after being processed. 
 */</span>

<span class="s3">function </span><span class="s1">addProperties(updatePayload, props, validAttributes) {</span>
  <span class="s0">// TODO: Fast path</span>
  <span class="s3">return </span><span class="s1">diffProperties(updatePayload, emptyObject, props, validAttributes);</span>
<span class="s1">}</span>
<span class="s0">/** 
 * clearProperties clears all the previous props by adding a null sentinel 
 * to the payload for each valid key. 
 */</span>

<span class="s3">function </span><span class="s1">clearProperties(updatePayload, prevProps, validAttributes) {</span>
  <span class="s0">// TODO: Fast path</span>
  <span class="s3">return </span><span class="s1">diffProperties(updatePayload, prevProps, emptyObject, validAttributes);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">create(props, validAttributes) {</span>
  <span class="s3">return </span><span class="s1">addProperties(</span>
    <span class="s3">null</span><span class="s1">, </span><span class="s0">// updatePayload</span>
    <span class="s1">props,</span>
    <span class="s1">validAttributes</span>
  <span class="s1">);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">diff(prevProps, nextProps, validAttributes) {</span>
  <span class="s3">return </span><span class="s1">diffProperties(</span>
    <span class="s3">null</span><span class="s1">, </span><span class="s0">// updatePayload</span>
    <span class="s1">prevProps,</span>
    <span class="s1">nextProps,</span>
    <span class="s1">validAttributes</span>
  <span class="s1">);</span>
<span class="s1">}</span>

<span class="s0">// Used as a way to call batchedUpdates when we don't have a reference to</span>
<span class="s0">// the renderer. Such as when we're dispatching events or if third party</span>
<span class="s0">// libraries need to call batchedUpdates. Eventually, this API will go away when</span>
<span class="s0">// everything is batched by default. We'll then have a similar API to opt-out of</span>
<span class="s0">// scheduled work and instead do synchronous work.</span>
<span class="s0">// Defaults</span>
<span class="s3">var </span><span class="s1">batchedUpdatesImpl = </span><span class="s3">function</span><span class="s1">(fn, bookkeeping) {</span>
  <span class="s3">return </span><span class="s1">fn(bookkeeping);</span>
<span class="s1">};</span>

<span class="s3">var </span><span class="s1">isInsideEventHandler = </span><span class="s3">false</span><span class="s1">;</span>
<span class="s3">function </span><span class="s1">batchedUpdates(fn, bookkeeping) {</span>
  <span class="s3">if </span><span class="s1">(isInsideEventHandler) {</span>
    <span class="s0">// If we are currently inside another batch, we need to wait until it</span>
    <span class="s0">// fully completes before restoring state.</span>
    <span class="s3">return </span><span class="s1">fn(bookkeeping);</span>
  <span class="s1">}</span>

  <span class="s1">isInsideEventHandler = </span><span class="s3">true</span><span class="s1">;</span>

  <span class="s3">try </span><span class="s1">{</span>
    <span class="s3">return </span><span class="s1">batchedUpdatesImpl(fn, bookkeeping);</span>
  <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
    <span class="s1">isInsideEventHandler = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">setBatchingImplementation(_batchedUpdatesImpl, _discreteUpdatesImpl) {</span>
  <span class="s1">batchedUpdatesImpl = _batchedUpdatesImpl;</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Internal queue of events that have accumulated their dispatches and are 
 * waiting to have their dispatches executed. 
 */</span>

<span class="s3">var </span><span class="s1">eventQueue = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s0">/** 
 * Dispatches an event and releases it back into the pool, unless persistent. 
 * 
 * @param {?object} event Synthetic event to be dispatched. 
 * @private 
 */</span>

<span class="s3">var </span><span class="s1">executeDispatchesAndRelease = </span><span class="s3">function</span><span class="s1">(event) {</span>
  <span class="s3">if </span><span class="s1">(event) {</span>
    <span class="s1">executeDispatchesInOrder(event);</span>

    <span class="s3">if </span><span class="s1">(!event.isPersistent()) {</span>
      <span class="s1">event.constructor.release(event);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">};</span>

<span class="s3">var </span><span class="s1">executeDispatchesAndReleaseTopLevel = </span><span class="s3">function</span><span class="s1">(e) {</span>
  <span class="s3">return </span><span class="s1">executeDispatchesAndRelease(e);</span>
<span class="s1">};</span>

<span class="s3">function </span><span class="s1">runEventsInBatch(events) {</span>
  <span class="s3">if </span><span class="s1">(events !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s1">eventQueue = accumulateInto(eventQueue, events);</span>
  <span class="s1">} </span><span class="s0">// Set `eventQueue` to null before processing it so that we can tell if more</span>
  <span class="s0">// events get enqueued while processing.</span>

  <span class="s3">var </span><span class="s1">processingEventQueue = eventQueue;</span>
  <span class="s1">eventQueue = </span><span class="s3">null</span><span class="s1">;</span>

  <span class="s3">if </span><span class="s1">(!processingEventQueue) {</span>
    <span class="s3">return</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s1">forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);</span>

  <span class="s3">if </span><span class="s1">(eventQueue) {</span>
    <span class="s3">throw new </span><span class="s1">Error(</span>
      <span class="s2">&quot;processEventQueue(): Additional events were enqueued while processing &quot; </span><span class="s1">+</span>
        <span class="s2">&quot;an event queue. Support for this has not yet been implemented.&quot;</span>
    <span class="s1">);</span>
  <span class="s1">} </span><span class="s0">// This would be a good time to rethrow if any of the event handlers threw.</span>

  <span class="s1">rethrowCaughtError();</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Allows registered plugins an opportunity to extract events from top-level 
 * native browser events. 
 * 
 * @return {*} An accumulation of synthetic events. 
 * @internal 
 */</span>

<span class="s3">function </span><span class="s1">extractPluginEvents(</span>
  <span class="s1">topLevelType,</span>
  <span class="s1">targetInst,</span>
  <span class="s1">nativeEvent,</span>
  <span class="s1">nativeEventTarget</span>
<span class="s1">) {</span>
  <span class="s3">var </span><span class="s1">events = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">legacyPlugins = plugins;</span>

  <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; legacyPlugins.length; i++) {</span>
    <span class="s0">// Not every plugin in the ordering may be loaded at runtime.</span>
    <span class="s3">var </span><span class="s1">possiblePlugin = legacyPlugins[i];</span>

    <span class="s3">if </span><span class="s1">(possiblePlugin) {</span>
      <span class="s3">var </span><span class="s1">extractedEvents = possiblePlugin.extractEvents(</span>
        <span class="s1">topLevelType,</span>
        <span class="s1">targetInst,</span>
        <span class="s1">nativeEvent,</span>
        <span class="s1">nativeEventTarget</span>
      <span class="s1">);</span>

      <span class="s3">if </span><span class="s1">(extractedEvents) {</span>
        <span class="s1">events = accumulateInto(events, extractedEvents);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">events;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">runExtractedPluginEventsInBatch(</span>
  <span class="s1">topLevelType,</span>
  <span class="s1">targetInst,</span>
  <span class="s1">nativeEvent,</span>
  <span class="s1">nativeEventTarget</span>
<span class="s1">) {</span>
  <span class="s3">var </span><span class="s1">events = extractPluginEvents(</span>
    <span class="s1">topLevelType,</span>
    <span class="s1">targetInst,</span>
    <span class="s1">nativeEvent,</span>
    <span class="s1">nativeEventTarget</span>
  <span class="s1">);</span>
  <span class="s1">runEventsInBatch(events);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">dispatchEvent(target, topLevelType, nativeEvent) {</span>
  <span class="s3">var </span><span class="s1">targetFiber = target;</span>
  <span class="s3">var </span><span class="s1">eventTarget = </span><span class="s3">null</span><span class="s1">;</span>

  <span class="s3">if </span><span class="s1">(targetFiber != </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">stateNode = targetFiber.stateNode; </span><span class="s0">// Guard against Fiber being unmounted</span>

    <span class="s3">if </span><span class="s1">(stateNode != </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">eventTarget = stateNode.canonical;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">batchedUpdates(</span><span class="s3">function</span><span class="s1">() {</span>
    <span class="s0">// Emit event to the RawEventEmitter. This is an unused-by-default EventEmitter</span>
    <span class="s0">// that can be used to instrument event performance monitoring (primarily - could be useful</span>
    <span class="s0">// for other things too).</span>
    <span class="s0">//</span>
    <span class="s0">// NOTE: this merely emits events into the EventEmitter below.</span>
    <span class="s0">// If *you* do not add listeners to the `RawEventEmitter`,</span>
    <span class="s0">// then all of these emitted events will just blackhole and are no-ops.</span>
    <span class="s0">// It is available (although not officially supported... yet) if you want to collect</span>
    <span class="s0">// perf data on event latency in your application, and could also be useful for debugging</span>
    <span class="s0">// low-level events issues.</span>
    <span class="s0">//</span>
    <span class="s0">// If you do not have any event perf monitoring and are extremely concerned about event perf,</span>
    <span class="s0">// it is safe to disable these &quot;emit&quot; statements; it will prevent checking the size of</span>
    <span class="s0">// an empty array twice and prevent two no-ops. Practically the overhead is so low that</span>
    <span class="s0">// we don't think it's worth thinking about in prod; your perf issues probably lie elsewhere.</span>
    <span class="s0">//</span>
    <span class="s0">// We emit two events here: one for listeners to this specific event,</span>
    <span class="s0">// and one for the catchall listener '*', for any listeners that want</span>
    <span class="s0">// to be notified for all events.</span>
    <span class="s0">// Note that extracted events are *not* emitted,</span>
    <span class="s0">// only events that have a 1:1 mapping with a native event, at least for now.</span>
    <span class="s3">var </span><span class="s1">event = {</span>
      <span class="s1">eventName: topLevelType,</span>
      <span class="s1">nativeEvent: nativeEvent</span>
    <span class="s1">};</span>
    <span class="s1">ReactNativePrivateInterface.RawEventEmitter.emit(topLevelType, event);</span>
    <span class="s1">ReactNativePrivateInterface.RawEventEmitter.emit(</span><span class="s2">&quot;*&quot;</span><span class="s1">, event); </span><span class="s0">// Heritage plugin event system</span>

    <span class="s1">runExtractedPluginEventsInBatch(</span>
      <span class="s1">topLevelType,</span>
      <span class="s1">targetFiber,</span>
      <span class="s1">nativeEvent,</span>
      <span class="s1">eventTarget</span>
    <span class="s1">);</span>
  <span class="s1">}); </span><span class="s0">// React Native doesn't use ReactControlledComponent but if it did, here's</span>
  <span class="s0">// where it would do it.</span>
<span class="s1">}</span>

<span class="s0">// This module only exists as an ESM wrapper around the external CommonJS</span>
<span class="s3">var </span><span class="s1">scheduleCallback = Scheduler.unstable_scheduleCallback;</span>
<span class="s3">var </span><span class="s1">cancelCallback = Scheduler.unstable_cancelCallback;</span>
<span class="s3">var </span><span class="s1">shouldYield = Scheduler.unstable_shouldYield;</span>
<span class="s3">var </span><span class="s1">requestPaint = Scheduler.unstable_requestPaint;</span>
<span class="s3">var </span><span class="s1">now = Scheduler.unstable_now;</span>
<span class="s3">var </span><span class="s1">ImmediatePriority = Scheduler.unstable_ImmediatePriority;</span>
<span class="s3">var </span><span class="s1">UserBlockingPriority = Scheduler.unstable_UserBlockingPriority;</span>
<span class="s3">var </span><span class="s1">NormalPriority = Scheduler.unstable_NormalPriority;</span>
<span class="s3">var </span><span class="s1">IdlePriority = Scheduler.unstable_IdlePriority;</span>

<span class="s3">var </span><span class="s1">rendererID = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">injectedHook = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">hasLoggedError = </span><span class="s3">false</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">isDevToolsPresent = </span><span class="s3">typeof </span><span class="s1">__REACT_DEVTOOLS_GLOBAL_HOOK__ !== </span><span class="s2">&quot;undefined&quot;</span><span class="s1">;</span>
<span class="s3">function </span><span class="s1">injectInternals(internals) {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">__REACT_DEVTOOLS_GLOBAL_HOOK__ === </span><span class="s2">&quot;undefined&quot;</span><span class="s1">) {</span>
    <span class="s0">// No DevTools</span>
    <span class="s3">return false</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;</span>

  <span class="s3">if </span><span class="s1">(hook.isDisabled) {</span>
    <span class="s0">// This isn't a real property on the hook, but it can be set to opt out</span>
    <span class="s0">// of DevTools integration and associated warnings and logs.</span>
    <span class="s0">// https://github.com/facebook/react/issues/3877</span>
    <span class="s3">return true</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(!hook.supportsFiber) {</span>
    <span class="s1">{</span>
      <span class="s1">error(</span>
        <span class="s2">&quot;The installed version of React DevTools is too old and will not work &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;with the current version of React. Please update React DevTools. &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;https://reactjs.org/link/react-devtools&quot;</span>
      <span class="s1">);</span>
    <span class="s1">} </span><span class="s0">// DevTools exists, even though it doesn't support Fiber.</span>

    <span class="s3">return true</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">try </span><span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(enableSchedulingProfiler) {</span>
      <span class="s0">// Conditionally inject these hooks only if Timeline profiler is supported by this build.</span>
      <span class="s0">// This gives DevTools a way to feature detect that isn't tied to version number</span>
      <span class="s0">// (since profiling and timeline are controlled by different feature flags).</span>
      <span class="s1">internals = assign({}, internals, {</span>
        <span class="s1">getLaneLabelMap: getLaneLabelMap,</span>
        <span class="s1">injectProfilingHooks: injectProfilingHooks</span>
      <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s1">rendererID = hook.inject(internals); </span><span class="s0">// We have successfully injected, so now it is safe to set up hooks.</span>

    <span class="s1">injectedHook = hook;</span>
  <span class="s1">} </span><span class="s3">catch </span><span class="s1">(err) {</span>
    <span class="s0">// Catch all errors because it is unsafe to throw during initialization.</span>
    <span class="s1">{</span>
      <span class="s1">error(</span><span class="s2">&quot;React instrumentation encountered an error: %s.&quot;</span><span class="s1">, err);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(hook.checkDCE) {</span>
    <span class="s0">// This is the real DevTools.</span>
    <span class="s3">return true</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s0">// This is likely a hook installed by Fast Refresh runtime.</span>
    <span class="s3">return false</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">onScheduleRoot(root, children) {</span>
  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(</span>
      <span class="s1">injectedHook &amp;&amp;</span>
      <span class="s3">typeof </span><span class="s1">injectedHook.onScheduleFiberRoot === </span><span class="s2">&quot;function&quot;</span>
    <span class="s1">) {</span>
      <span class="s3">try </span><span class="s1">{</span>
        <span class="s1">injectedHook.onScheduleFiberRoot(rendererID, root, children);</span>
      <span class="s1">} </span><span class="s3">catch </span><span class="s1">(err) {</span>
        <span class="s3">if </span><span class="s1">(!hasLoggedError) {</span>
          <span class="s1">hasLoggedError = </span><span class="s3">true</span><span class="s1">;</span>

          <span class="s1">error(</span><span class="s2">&quot;React instrumentation encountered an error: %s&quot;</span><span class="s1">, err);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">onCommitRoot(root, eventPriority) {</span>
  <span class="s3">if </span><span class="s1">(injectedHook &amp;&amp; </span><span class="s3">typeof </span><span class="s1">injectedHook.onCommitFiberRoot === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
    <span class="s3">try </span><span class="s1">{</span>
      <span class="s3">var </span><span class="s1">didError = (root.current.flags &amp; DidCapture) === DidCapture;</span>

      <span class="s3">if </span><span class="s1">(enableProfilerTimer) {</span>
        <span class="s3">var </span><span class="s1">schedulerPriority;</span>

        <span class="s3">switch </span><span class="s1">(eventPriority) {</span>
          <span class="s3">case </span><span class="s1">DiscreteEventPriority:</span>
            <span class="s1">schedulerPriority = ImmediatePriority;</span>
            <span class="s3">break</span><span class="s1">;</span>

          <span class="s3">case </span><span class="s1">ContinuousEventPriority:</span>
            <span class="s1">schedulerPriority = UserBlockingPriority;</span>
            <span class="s3">break</span><span class="s1">;</span>

          <span class="s3">case </span><span class="s1">DefaultEventPriority:</span>
            <span class="s1">schedulerPriority = NormalPriority;</span>
            <span class="s3">break</span><span class="s1">;</span>

          <span class="s3">case </span><span class="s1">IdleEventPriority:</span>
            <span class="s1">schedulerPriority = IdlePriority;</span>
            <span class="s3">break</span><span class="s1">;</span>

          <span class="s3">default</span><span class="s1">:</span>
            <span class="s1">schedulerPriority = NormalPriority;</span>
            <span class="s3">break</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">injectedHook.onCommitFiberRoot(</span>
          <span class="s1">rendererID,</span>
          <span class="s1">root,</span>
          <span class="s1">schedulerPriority,</span>
          <span class="s1">didError</span>
        <span class="s1">);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">injectedHook.onCommitFiberRoot(rendererID, root, undefined, didError);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">catch </span><span class="s1">(err) {</span>
      <span class="s1">{</span>
        <span class="s3">if </span><span class="s1">(!hasLoggedError) {</span>
          <span class="s1">hasLoggedError = </span><span class="s3">true</span><span class="s1">;</span>

          <span class="s1">error(</span><span class="s2">&quot;React instrumentation encountered an error: %s&quot;</span><span class="s1">, err);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">onPostCommitRoot(root) {</span>
  <span class="s3">if </span><span class="s1">(</span>
    <span class="s1">injectedHook &amp;&amp;</span>
    <span class="s3">typeof </span><span class="s1">injectedHook.onPostCommitFiberRoot === </span><span class="s2">&quot;function&quot;</span>
  <span class="s1">) {</span>
    <span class="s3">try </span><span class="s1">{</span>
      <span class="s1">injectedHook.onPostCommitFiberRoot(rendererID, root);</span>
    <span class="s1">} </span><span class="s3">catch </span><span class="s1">(err) {</span>
      <span class="s1">{</span>
        <span class="s3">if </span><span class="s1">(!hasLoggedError) {</span>
          <span class="s1">hasLoggedError = </span><span class="s3">true</span><span class="s1">;</span>

          <span class="s1">error(</span><span class="s2">&quot;React instrumentation encountered an error: %s&quot;</span><span class="s1">, err);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">onCommitUnmount(fiber) {</span>
  <span class="s3">if </span><span class="s1">(injectedHook &amp;&amp; </span><span class="s3">typeof </span><span class="s1">injectedHook.onCommitFiberUnmount === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
    <span class="s3">try </span><span class="s1">{</span>
      <span class="s1">injectedHook.onCommitFiberUnmount(rendererID, fiber);</span>
    <span class="s1">} </span><span class="s3">catch </span><span class="s1">(err) {</span>
      <span class="s1">{</span>
        <span class="s3">if </span><span class="s1">(!hasLoggedError) {</span>
          <span class="s1">hasLoggedError = </span><span class="s3">true</span><span class="s1">;</span>

          <span class="s1">error(</span><span class="s2">&quot;React instrumentation encountered an error: %s&quot;</span><span class="s1">, err);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">injectProfilingHooks(profilingHooks) {}</span>

<span class="s3">function </span><span class="s1">getLaneLabelMap() {</span>
  <span class="s1">{</span>
    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">markComponentRenderStopped() {}</span>
<span class="s3">function </span><span class="s1">markComponentErrored(fiber, thrownValue, lanes) {}</span>
<span class="s3">function </span><span class="s1">markComponentSuspended(fiber, wakeable, lanes) {}</span>

<span class="s3">var </span><span class="s1">NoMode =</span>
  <span class="s0">/*                         */</span>
  <span class="s4">0</span><span class="s1">; </span><span class="s0">// TODO: Remove ConcurrentMode by reading from the root tag instead</span>

<span class="s3">var </span><span class="s1">ConcurrentMode =</span>
  <span class="s0">/*                 */</span>
  <span class="s4">1</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">ProfileMode =</span>
  <span class="s0">/*                    */</span>
  <span class="s4">2</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">StrictLegacyMode =</span>
  <span class="s0">/*               */</span>
  <span class="s4">8</span><span class="s1">;</span>

<span class="s0">// TODO: This is pretty well supported by browsers. Maybe we can drop it.</span>
<span class="s3">var </span><span class="s1">clz32 = Math.clz32 ? Math.clz32 : clz32Fallback; </span><span class="s0">// Count leading zeros.</span>
<span class="s0">// Based on:</span>
<span class="s0">// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32</span>

<span class="s3">var </span><span class="s1">log = Math.log;</span>
<span class="s3">var </span><span class="s1">LN2 = Math.LN2;</span>

<span class="s3">function </span><span class="s1">clz32Fallback(x) {</span>
  <span class="s3">var </span><span class="s1">asUint = x &gt;&gt;&gt; </span><span class="s4">0</span><span class="s1">;</span>

  <span class="s3">if </span><span class="s1">(asUint === </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s3">return </span><span class="s4">32</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">(</span><span class="s4">31 </span><span class="s1">- ((log(asUint) / LN2) | </span><span class="s4">0</span><span class="s1">)) | </span><span class="s4">0</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">// If those values are changed that package should be rebuilt and redeployed.</span>

<span class="s3">var </span><span class="s1">TotalLanes = </span><span class="s4">31</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">NoLanes =</span>
  <span class="s0">/*                        */</span>
  <span class="s4">0</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">NoLane =</span>
  <span class="s0">/*                          */</span>
  <span class="s4">0</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">SyncLane =</span>
  <span class="s0">/*                        */</span>
  <span class="s4">1</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">InputContinuousHydrationLane =</span>
  <span class="s0">/*    */</span>
  <span class="s4">2</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">InputContinuousLane =</span>
  <span class="s0">/*             */</span>
  <span class="s4">4</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">DefaultHydrationLane =</span>
  <span class="s0">/*            */</span>
  <span class="s4">8</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">DefaultLane =</span>
  <span class="s0">/*                     */</span>
  <span class="s4">16</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">TransitionHydrationLane =</span>
  <span class="s0">/*                */</span>
  <span class="s4">32</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">TransitionLanes =</span>
  <span class="s0">/*                       */</span>
  <span class="s4">4194240</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">TransitionLane1 =</span>
  <span class="s0">/*                        */</span>
  <span class="s4">64</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">TransitionLane2 =</span>
  <span class="s0">/*                        */</span>
  <span class="s4">128</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">TransitionLane3 =</span>
  <span class="s0">/*                        */</span>
  <span class="s4">256</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">TransitionLane4 =</span>
  <span class="s0">/*                        */</span>
  <span class="s4">512</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">TransitionLane5 =</span>
  <span class="s0">/*                        */</span>
  <span class="s4">1024</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">TransitionLane6 =</span>
  <span class="s0">/*                        */</span>
  <span class="s4">2048</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">TransitionLane7 =</span>
  <span class="s0">/*                        */</span>
  <span class="s4">4096</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">TransitionLane8 =</span>
  <span class="s0">/*                        */</span>
  <span class="s4">8192</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">TransitionLane9 =</span>
  <span class="s0">/*                        */</span>
  <span class="s4">16384</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">TransitionLane10 =</span>
  <span class="s0">/*                       */</span>
  <span class="s4">32768</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">TransitionLane11 =</span>
  <span class="s0">/*                       */</span>
  <span class="s4">65536</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">TransitionLane12 =</span>
  <span class="s0">/*                       */</span>
  <span class="s4">131072</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">TransitionLane13 =</span>
  <span class="s0">/*                       */</span>
  <span class="s4">262144</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">TransitionLane14 =</span>
  <span class="s0">/*                       */</span>
  <span class="s4">524288</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">TransitionLane15 =</span>
  <span class="s0">/*                       */</span>
  <span class="s4">1048576</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">TransitionLane16 =</span>
  <span class="s0">/*                       */</span>
  <span class="s4">2097152</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">RetryLanes =</span>
  <span class="s0">/*                            */</span>
  <span class="s4">130023424</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">RetryLane1 =</span>
  <span class="s0">/*                             */</span>
  <span class="s4">4194304</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">RetryLane2 =</span>
  <span class="s0">/*                             */</span>
  <span class="s4">8388608</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">RetryLane3 =</span>
  <span class="s0">/*                             */</span>
  <span class="s4">16777216</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">RetryLane4 =</span>
  <span class="s0">/*                             */</span>
  <span class="s4">33554432</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">RetryLane5 =</span>
  <span class="s0">/*                             */</span>
  <span class="s4">67108864</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">SomeRetryLane = RetryLane1;</span>
<span class="s3">var </span><span class="s1">SelectiveHydrationLane =</span>
  <span class="s0">/*          */</span>
  <span class="s4">134217728</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">NonIdleLanes =</span>
  <span class="s0">/*                          */</span>
  <span class="s4">268435455</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">IdleHydrationLane =</span>
  <span class="s0">/*               */</span>
  <span class="s4">268435456</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">IdleLane =</span>
  <span class="s0">/*                        */</span>
  <span class="s4">536870912</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">OffscreenLane =</span>
  <span class="s0">/*                   */</span>
  <span class="s4">1073741824</span><span class="s1">; </span><span class="s0">// This function is used for the experimental timeline (react-devtools-timeline)</span>
<span class="s3">var </span><span class="s1">NoTimestamp = -</span><span class="s4">1</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">nextTransitionLane = TransitionLane1;</span>
<span class="s3">var </span><span class="s1">nextRetryLane = RetryLane1;</span>

<span class="s3">function </span><span class="s1">getHighestPriorityLanes(lanes) {</span>
  <span class="s3">switch </span><span class="s1">(getHighestPriorityLane(lanes)) {</span>
    <span class="s3">case </span><span class="s1">SyncLane:</span>
      <span class="s3">return </span><span class="s1">SyncLane;</span>

    <span class="s3">case </span><span class="s1">InputContinuousHydrationLane:</span>
      <span class="s3">return </span><span class="s1">InputContinuousHydrationLane;</span>

    <span class="s3">case </span><span class="s1">InputContinuousLane:</span>
      <span class="s3">return </span><span class="s1">InputContinuousLane;</span>

    <span class="s3">case </span><span class="s1">DefaultHydrationLane:</span>
      <span class="s3">return </span><span class="s1">DefaultHydrationLane;</span>

    <span class="s3">case </span><span class="s1">DefaultLane:</span>
      <span class="s3">return </span><span class="s1">DefaultLane;</span>

    <span class="s3">case </span><span class="s1">TransitionHydrationLane:</span>
      <span class="s3">return </span><span class="s1">TransitionHydrationLane;</span>

    <span class="s3">case </span><span class="s1">TransitionLane1:</span>
    <span class="s3">case </span><span class="s1">TransitionLane2:</span>
    <span class="s3">case </span><span class="s1">TransitionLane3:</span>
    <span class="s3">case </span><span class="s1">TransitionLane4:</span>
    <span class="s3">case </span><span class="s1">TransitionLane5:</span>
    <span class="s3">case </span><span class="s1">TransitionLane6:</span>
    <span class="s3">case </span><span class="s1">TransitionLane7:</span>
    <span class="s3">case </span><span class="s1">TransitionLane8:</span>
    <span class="s3">case </span><span class="s1">TransitionLane9:</span>
    <span class="s3">case </span><span class="s1">TransitionLane10:</span>
    <span class="s3">case </span><span class="s1">TransitionLane11:</span>
    <span class="s3">case </span><span class="s1">TransitionLane12:</span>
    <span class="s3">case </span><span class="s1">TransitionLane13:</span>
    <span class="s3">case </span><span class="s1">TransitionLane14:</span>
    <span class="s3">case </span><span class="s1">TransitionLane15:</span>
    <span class="s3">case </span><span class="s1">TransitionLane16:</span>
      <span class="s3">return </span><span class="s1">lanes &amp; TransitionLanes;</span>

    <span class="s3">case </span><span class="s1">RetryLane1:</span>
    <span class="s3">case </span><span class="s1">RetryLane2:</span>
    <span class="s3">case </span><span class="s1">RetryLane3:</span>
    <span class="s3">case </span><span class="s1">RetryLane4:</span>
    <span class="s3">case </span><span class="s1">RetryLane5:</span>
      <span class="s3">return </span><span class="s1">lanes &amp; RetryLanes;</span>

    <span class="s3">case </span><span class="s1">SelectiveHydrationLane:</span>
      <span class="s3">return </span><span class="s1">SelectiveHydrationLane;</span>

    <span class="s3">case </span><span class="s1">IdleHydrationLane:</span>
      <span class="s3">return </span><span class="s1">IdleHydrationLane;</span>

    <span class="s3">case </span><span class="s1">IdleLane:</span>
      <span class="s3">return </span><span class="s1">IdleLane;</span>

    <span class="s3">case </span><span class="s1">OffscreenLane:</span>
      <span class="s3">return </span><span class="s1">OffscreenLane;</span>

    <span class="s3">default</span><span class="s1">:</span>
      <span class="s1">{</span>
        <span class="s1">error(</span><span class="s2">&quot;Should have found matching lanes. This is a bug in React.&quot;</span><span class="s1">);</span>
      <span class="s1">} </span><span class="s0">// This shouldn't be reachable, but as a fallback, return the entire bitmask.</span>

      <span class="s3">return </span><span class="s1">lanes;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">getNextLanes(root, wipLanes) {</span>
  <span class="s0">// Early bailout if there's no pending work left.</span>
  <span class="s3">var </span><span class="s1">pendingLanes = root.pendingLanes;</span>

  <span class="s3">if </span><span class="s1">(pendingLanes === NoLanes) {</span>
    <span class="s3">return </span><span class="s1">NoLanes;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">nextLanes = NoLanes;</span>
  <span class="s3">var </span><span class="s1">suspendedLanes = root.suspendedLanes;</span>
  <span class="s3">var </span><span class="s1">pingedLanes = root.pingedLanes; </span><span class="s0">// Do not work on any idle work until all the non-idle work has finished,</span>
  <span class="s0">// even if the work is suspended.</span>

  <span class="s3">var </span><span class="s1">nonIdlePendingLanes = pendingLanes &amp; NonIdleLanes;</span>

  <span class="s3">if </span><span class="s1">(nonIdlePendingLanes !== NoLanes) {</span>
    <span class="s3">var </span><span class="s1">nonIdleUnblockedLanes = nonIdlePendingLanes &amp; ~suspendedLanes;</span>

    <span class="s3">if </span><span class="s1">(nonIdleUnblockedLanes !== NoLanes) {</span>
      <span class="s1">nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">var </span><span class="s1">nonIdlePingedLanes = nonIdlePendingLanes &amp; pingedLanes;</span>

      <span class="s3">if </span><span class="s1">(nonIdlePingedLanes !== NoLanes) {</span>
        <span class="s1">nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s0">// The only remaining work is Idle.</span>
    <span class="s3">var </span><span class="s1">unblockedLanes = pendingLanes &amp; ~suspendedLanes;</span>

    <span class="s3">if </span><span class="s1">(unblockedLanes !== NoLanes) {</span>
      <span class="s1">nextLanes = getHighestPriorityLanes(unblockedLanes);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(pingedLanes !== NoLanes) {</span>
        <span class="s1">nextLanes = getHighestPriorityLanes(pingedLanes);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(nextLanes === NoLanes) {</span>
    <span class="s0">// This should only be reachable if we're suspended</span>
    <span class="s0">// TODO: Consider warning in this path if a fallback timer is not scheduled.</span>
    <span class="s3">return </span><span class="s1">NoLanes;</span>
  <span class="s1">} </span><span class="s0">// If we're already in the middle of a render, switching lanes will interrupt</span>
  <span class="s0">// it and we'll lose our progress. We should only do this if the new lanes are</span>
  <span class="s0">// higher priority.</span>

  <span class="s3">if </span><span class="s1">(</span>
    <span class="s1">wipLanes !== NoLanes &amp;&amp;</span>
    <span class="s1">wipLanes !== nextLanes &amp;&amp; </span><span class="s0">// If we already suspended with a delay, then interrupting is fine. Don't</span>
    <span class="s0">// bother waiting until the root is complete.</span>
    <span class="s1">(wipLanes &amp; suspendedLanes) === NoLanes</span>
  <span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">nextLane = getHighestPriorityLane(nextLanes);</span>
    <span class="s3">var </span><span class="s1">wipLane = getHighestPriorityLane(wipLanes);</span>

    <span class="s3">if </span><span class="s1">(</span>
      <span class="s0">// Tests whether the next lane is equal or lower priority than the wip</span>
      <span class="s0">// one. This works because the bits decrease in priority as you go left.</span>
      <span class="s1">nextLane &gt;= wipLane || </span><span class="s0">// Default priority updates should not interrupt transition updates. The</span>
      <span class="s0">// only difference between default updates and transition updates is that</span>
      <span class="s0">// default updates do not support refresh transitions.</span>
      <span class="s1">(nextLane === DefaultLane &amp;&amp; (wipLane &amp; TransitionLanes) !== NoLanes)</span>
    <span class="s1">) {</span>
      <span class="s0">// Keep working on the existing in-progress tree. Do not interrupt.</span>
      <span class="s3">return </span><span class="s1">wipLanes;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">((nextLanes &amp; InputContinuousLane) !== NoLanes) {</span>
    <span class="s0">// When updates are sync by default, we entangle continuous priority updates</span>
    <span class="s0">// and default updates, so they render in the same batch. The only reason</span>
    <span class="s0">// they use separate lanes is because continuous updates should interrupt</span>
    <span class="s0">// transitions, but default updates should not.</span>
    <span class="s1">nextLanes |= pendingLanes &amp; DefaultLane;</span>
  <span class="s1">} </span><span class="s0">// Check for entangled lanes and add them to the batch.</span>
  <span class="s0">//</span>
  <span class="s0">// A lane is said to be entangled with another when it's not allowed to render</span>
  <span class="s0">// in a batch that does not also include the other lane. Typically we do this</span>
  <span class="s0">// when multiple updates have the same source, and we only want to respond to</span>
  <span class="s0">// the most recent event from that source.</span>
  <span class="s0">//</span>
  <span class="s0">// Note that we apply entanglements *after* checking for partial work above.</span>
  <span class="s0">// This means that if a lane is entangled during an interleaved event while</span>
  <span class="s0">// it's already rendering, we won't interrupt it. This is intentional, since</span>
  <span class="s0">// entanglement is usually &quot;best effort&quot;: we'll try our best to render the</span>
  <span class="s0">// lanes in the same batch, but it's not worth throwing out partially</span>
  <span class="s0">// completed work in order to do it.</span>
  <span class="s0">// TODO: Reconsider this. The counter-argument is that the partial work</span>
  <span class="s0">// represents an intermediate state, which we don't want to show to the user.</span>
  <span class="s0">// And by spending extra time finishing it, we're increasing the amount of</span>
  <span class="s0">// time it takes to show the final state, which is what they are actually</span>
  <span class="s0">// waiting for.</span>
  <span class="s0">//</span>
  <span class="s0">// For those exceptions where entanglement is semantically important, like</span>
  <span class="s0">// useMutableSource, we should ensure that there is no partial work at the</span>
  <span class="s0">// time we apply the entanglement.</span>

  <span class="s3">var </span><span class="s1">entangledLanes = root.entangledLanes;</span>

  <span class="s3">if </span><span class="s1">(entangledLanes !== NoLanes) {</span>
    <span class="s3">var </span><span class="s1">entanglements = root.entanglements;</span>
    <span class="s3">var </span><span class="s1">lanes = nextLanes &amp; entangledLanes;</span>

    <span class="s3">while </span><span class="s1">(lanes &gt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">index = pickArbitraryLaneIndex(lanes);</span>
      <span class="s3">var </span><span class="s1">lane = </span><span class="s4">1 </span><span class="s1">&lt;&lt; index;</span>
      <span class="s1">nextLanes |= entanglements[index];</span>
      <span class="s1">lanes &amp;= ~lane;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">nextLanes;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">getMostRecentEventTime(root, lanes) {</span>
  <span class="s3">var </span><span class="s1">eventTimes = root.eventTimes;</span>
  <span class="s3">var </span><span class="s1">mostRecentEventTime = NoTimestamp;</span>

  <span class="s3">while </span><span class="s1">(lanes &gt; </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">index = pickArbitraryLaneIndex(lanes);</span>
    <span class="s3">var </span><span class="s1">lane = </span><span class="s4">1 </span><span class="s1">&lt;&lt; index;</span>
    <span class="s3">var </span><span class="s1">eventTime = eventTimes[index];</span>

    <span class="s3">if </span><span class="s1">(eventTime &gt; mostRecentEventTime) {</span>
      <span class="s1">mostRecentEventTime = eventTime;</span>
    <span class="s1">}</span>

    <span class="s1">lanes &amp;= ~lane;</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">mostRecentEventTime;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">computeExpirationTime(lane, currentTime) {</span>
  <span class="s3">switch </span><span class="s1">(lane) {</span>
    <span class="s3">case </span><span class="s1">SyncLane:</span>
    <span class="s3">case </span><span class="s1">InputContinuousHydrationLane:</span>
    <span class="s3">case </span><span class="s1">InputContinuousLane:</span>
      <span class="s0">// User interactions should expire slightly more quickly.</span>
      <span class="s0">//</span>
      <span class="s0">// NOTE: This is set to the corresponding constant as in Scheduler.js.</span>
      <span class="s0">// When we made it larger, a product metric in www regressed, suggesting</span>
      <span class="s0">// there's a user interaction that's being starved by a series of</span>
      <span class="s0">// synchronous updates. If that theory is correct, the proper solution is</span>
      <span class="s0">// to fix the starvation. However, this scenario supports the idea that</span>
      <span class="s0">// expiration times are an important safeguard when starvation</span>
      <span class="s0">// does happen.</span>
      <span class="s3">return </span><span class="s1">currentTime + </span><span class="s4">250</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s1">DefaultHydrationLane:</span>
    <span class="s3">case </span><span class="s1">DefaultLane:</span>
    <span class="s3">case </span><span class="s1">TransitionHydrationLane:</span>
    <span class="s3">case </span><span class="s1">TransitionLane1:</span>
    <span class="s3">case </span><span class="s1">TransitionLane2:</span>
    <span class="s3">case </span><span class="s1">TransitionLane3:</span>
    <span class="s3">case </span><span class="s1">TransitionLane4:</span>
    <span class="s3">case </span><span class="s1">TransitionLane5:</span>
    <span class="s3">case </span><span class="s1">TransitionLane6:</span>
    <span class="s3">case </span><span class="s1">TransitionLane7:</span>
    <span class="s3">case </span><span class="s1">TransitionLane8:</span>
    <span class="s3">case </span><span class="s1">TransitionLane9:</span>
    <span class="s3">case </span><span class="s1">TransitionLane10:</span>
    <span class="s3">case </span><span class="s1">TransitionLane11:</span>
    <span class="s3">case </span><span class="s1">TransitionLane12:</span>
    <span class="s3">case </span><span class="s1">TransitionLane13:</span>
    <span class="s3">case </span><span class="s1">TransitionLane14:</span>
    <span class="s3">case </span><span class="s1">TransitionLane15:</span>
    <span class="s3">case </span><span class="s1">TransitionLane16:</span>
      <span class="s3">return </span><span class="s1">currentTime + </span><span class="s4">5000</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s1">RetryLane1:</span>
    <span class="s3">case </span><span class="s1">RetryLane2:</span>
    <span class="s3">case </span><span class="s1">RetryLane3:</span>
    <span class="s3">case </span><span class="s1">RetryLane4:</span>
    <span class="s3">case </span><span class="s1">RetryLane5:</span>
      <span class="s0">// TODO: Retries should be allowed to expire if they are CPU bound for</span>
      <span class="s0">// too long, but when I made this change it caused a spike in browser</span>
      <span class="s0">// crashes. There must be some other underlying bug; not super urgent but</span>
      <span class="s0">// ideally should figure out why and fix it. Unfortunately we don't have</span>
      <span class="s0">// a repro for the crashes, only detected via production metrics.</span>
      <span class="s3">return </span><span class="s1">NoTimestamp;</span>

    <span class="s3">case </span><span class="s1">SelectiveHydrationLane:</span>
    <span class="s3">case </span><span class="s1">IdleHydrationLane:</span>
    <span class="s3">case </span><span class="s1">IdleLane:</span>
    <span class="s3">case </span><span class="s1">OffscreenLane:</span>
      <span class="s0">// Anything idle priority or lower should never expire.</span>
      <span class="s3">return </span><span class="s1">NoTimestamp;</span>

    <span class="s3">default</span><span class="s1">:</span>
      <span class="s1">{</span>
        <span class="s1">error(</span><span class="s2">&quot;Should have found matching lanes. This is a bug in React.&quot;</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s3">return </span><span class="s1">NoTimestamp;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">markStarvedLanesAsExpired(root, currentTime) {</span>
  <span class="s0">// TODO: This gets called every time we yield. We can optimize by storing</span>
  <span class="s0">// the earliest expiration time on the root. Then use that to quickly bail out</span>
  <span class="s0">// of this function.</span>
  <span class="s3">var </span><span class="s1">pendingLanes = root.pendingLanes;</span>
  <span class="s3">var </span><span class="s1">suspendedLanes = root.suspendedLanes;</span>
  <span class="s3">var </span><span class="s1">pingedLanes = root.pingedLanes;</span>
  <span class="s3">var </span><span class="s1">expirationTimes = root.expirationTimes; </span><span class="s0">// Iterate through the pending lanes and check if we've reached their</span>
  <span class="s0">// expiration time. If so, we'll assume the update is being starved and mark</span>
  <span class="s0">// it as expired to force it to finish.</span>

  <span class="s3">var </span><span class="s1">lanes = pendingLanes;</span>

  <span class="s3">while </span><span class="s1">(lanes &gt; </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">index = pickArbitraryLaneIndex(lanes);</span>
    <span class="s3">var </span><span class="s1">lane = </span><span class="s4">1 </span><span class="s1">&lt;&lt; index;</span>
    <span class="s3">var </span><span class="s1">expirationTime = expirationTimes[index];</span>

    <span class="s3">if </span><span class="s1">(expirationTime === NoTimestamp) {</span>
      <span class="s0">// Found a pending lane with no expiration time. If it's not suspended, or</span>
      <span class="s0">// if it's pinged, assume it's CPU-bound. Compute a new expiration time</span>
      <span class="s0">// using the current time.</span>
      <span class="s3">if </span><span class="s1">(</span>
        <span class="s1">(lane &amp; suspendedLanes) === NoLanes ||</span>
        <span class="s1">(lane &amp; pingedLanes) !== NoLanes</span>
      <span class="s1">) {</span>
        <span class="s0">// Assumes timestamps are monotonically increasing.</span>
        <span class="s1">expirationTimes[index] = computeExpirationTime(lane, currentTime);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(expirationTime &lt;= currentTime) {</span>
      <span class="s0">// This lane expired</span>
      <span class="s1">root.expiredLanes |= lane;</span>
    <span class="s1">}</span>

    <span class="s1">lanes &amp;= ~lane;</span>
  <span class="s1">}</span>
<span class="s1">} </span><span class="s0">// This returns the highest priority pending lanes regardless of whether they</span>
<span class="s3">function </span><span class="s1">getLanesToRetrySynchronouslyOnError(root) {</span>
  <span class="s3">var </span><span class="s1">everythingButOffscreen = root.pendingLanes &amp; ~OffscreenLane;</span>

  <span class="s3">if </span><span class="s1">(everythingButOffscreen !== NoLanes) {</span>
    <span class="s3">return </span><span class="s1">everythingButOffscreen;</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(everythingButOffscreen &amp; OffscreenLane) {</span>
    <span class="s3">return </span><span class="s1">OffscreenLane;</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">NoLanes;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">includesSyncLane(lanes) {</span>
  <span class="s3">return </span><span class="s1">(lanes &amp; SyncLane) !== NoLanes;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">includesNonIdleWork(lanes) {</span>
  <span class="s3">return </span><span class="s1">(lanes &amp; NonIdleLanes) !== NoLanes;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">includesOnlyRetries(lanes) {</span>
  <span class="s3">return </span><span class="s1">(lanes &amp; RetryLanes) === lanes;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">includesOnlyNonUrgentLanes(lanes) {</span>
  <span class="s3">var </span><span class="s1">UrgentLanes = SyncLane | InputContinuousLane | DefaultLane;</span>
  <span class="s3">return </span><span class="s1">(lanes &amp; UrgentLanes) === NoLanes;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">includesOnlyTransitions(lanes) {</span>
  <span class="s3">return </span><span class="s1">(lanes &amp; TransitionLanes) === lanes;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">includesBlockingLane(root, lanes) {</span>
  <span class="s3">var </span><span class="s1">SyncDefaultLanes =</span>
    <span class="s1">InputContinuousHydrationLane |</span>
    <span class="s1">InputContinuousLane |</span>
    <span class="s1">DefaultHydrationLane |</span>
    <span class="s1">DefaultLane;</span>
  <span class="s3">return </span><span class="s1">(lanes &amp; SyncDefaultLanes) !== NoLanes;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">includesExpiredLane(root, lanes) {</span>
  <span class="s0">// This is a separate check from includesBlockingLane because a lane can</span>
  <span class="s0">// expire after a render has already started.</span>
  <span class="s3">return </span><span class="s1">(lanes &amp; root.expiredLanes) !== NoLanes;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">isTransitionLane(lane) {</span>
  <span class="s3">return </span><span class="s1">(lane &amp; TransitionLanes) !== NoLanes;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">claimNextTransitionLane() {</span>
  <span class="s0">// Cycle through the lanes, assigning each new transition to the next lane.</span>
  <span class="s0">// In most cases, this means every transition gets its own lane, until we</span>
  <span class="s0">// run out of lanes and cycle back to the beginning.</span>
  <span class="s3">var </span><span class="s1">lane = nextTransitionLane;</span>
  <span class="s1">nextTransitionLane &lt;&lt;= </span><span class="s4">1</span><span class="s1">;</span>

  <span class="s3">if </span><span class="s1">((nextTransitionLane &amp; TransitionLanes) === NoLanes) {</span>
    <span class="s1">nextTransitionLane = TransitionLane1;</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">lane;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">claimNextRetryLane() {</span>
  <span class="s3">var </span><span class="s1">lane = nextRetryLane;</span>
  <span class="s1">nextRetryLane &lt;&lt;= </span><span class="s4">1</span><span class="s1">;</span>

  <span class="s3">if </span><span class="s1">((nextRetryLane &amp; RetryLanes) === NoLanes) {</span>
    <span class="s1">nextRetryLane = RetryLane1;</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">lane;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">getHighestPriorityLane(lanes) {</span>
  <span class="s3">return </span><span class="s1">lanes &amp; -lanes;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">pickArbitraryLane(lanes) {</span>
  <span class="s0">// This wrapper function gets inlined. Only exists so to communicate that it</span>
  <span class="s0">// doesn't matter which bit is selected; you can pick any bit without</span>
  <span class="s0">// affecting the algorithms where its used. Here I'm using</span>
  <span class="s0">// getHighestPriorityLane because it requires the fewest operations.</span>
  <span class="s3">return </span><span class="s1">getHighestPriorityLane(lanes);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">pickArbitraryLaneIndex(lanes) {</span>
  <span class="s3">return </span><span class="s4">31 </span><span class="s1">- clz32(lanes);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">laneToIndex(lane) {</span>
  <span class="s3">return </span><span class="s1">pickArbitraryLaneIndex(lane);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">includesSomeLane(a, b) {</span>
  <span class="s3">return </span><span class="s1">(a &amp; b) !== NoLanes;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">isSubsetOfLanes(set, subset) {</span>
  <span class="s3">return </span><span class="s1">(set &amp; subset) === subset;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">mergeLanes(a, b) {</span>
  <span class="s3">return </span><span class="s1">a | b;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">removeLanes(set, subset) {</span>
  <span class="s3">return </span><span class="s1">set &amp; ~subset;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">intersectLanes(a, b) {</span>
  <span class="s3">return </span><span class="s1">a &amp; b;</span>
<span class="s1">} </span><span class="s0">// Seems redundant, but it changes the type from a single lane (used for</span>
<span class="s0">// updates) to a group of lanes (used for flushing work).</span>

<span class="s3">function </span><span class="s1">laneToLanes(lane) {</span>
  <span class="s3">return </span><span class="s1">lane;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">createLaneMap(initial) {</span>
  <span class="s0">// Intentionally pushing one by one.</span>
  <span class="s0">// https://v8.dev/blog/elements-kinds#avoid-creating-holes</span>
  <span class="s3">var </span><span class="s1">laneMap = [];</span>

  <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; TotalLanes; i++) {</span>
    <span class="s1">laneMap.push(initial);</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">laneMap;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">markRootUpdated(root, updateLane, eventTime) {</span>
  <span class="s1">root.pendingLanes |= updateLane; </span><span class="s0">// If there are any suspended transitions, it's possible this new update</span>
  <span class="s0">// could unblock them. Clear the suspended lanes so that we can try rendering</span>
  <span class="s0">// them again.</span>
  <span class="s0">//</span>
  <span class="s0">// TODO: We really only need to unsuspend only lanes that are in the</span>
  <span class="s0">// `subtreeLanes` of the updated fiber, or the update lanes of the return</span>
  <span class="s0">// path. This would exclude suspended updates in an unrelated sibling tree,</span>
  <span class="s0">// since there's no way for this update to unblock it.</span>
  <span class="s0">//</span>
  <span class="s0">// We don't do this if the incoming update is idle, because we never process</span>
  <span class="s0">// idle updates until after all the regular updates have finished; there's no</span>
  <span class="s0">// way it could unblock a transition.</span>

  <span class="s3">if </span><span class="s1">(updateLane !== IdleLane) {</span>
    <span class="s1">root.suspendedLanes = NoLanes;</span>
    <span class="s1">root.pingedLanes = NoLanes;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">eventTimes = root.eventTimes;</span>
  <span class="s3">var </span><span class="s1">index = laneToIndex(updateLane); </span><span class="s0">// We can always overwrite an existing timestamp because we prefer the most</span>
  <span class="s0">// recent event, and we assume time is monotonically increasing.</span>

  <span class="s1">eventTimes[index] = eventTime;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">markRootSuspended(root, suspendedLanes) {</span>
  <span class="s1">root.suspendedLanes |= suspendedLanes;</span>
  <span class="s1">root.pingedLanes &amp;= ~suspendedLanes; </span><span class="s0">// The suspended lanes are no longer CPU-bound. Clear their expiration times.</span>

  <span class="s3">var </span><span class="s1">expirationTimes = root.expirationTimes;</span>
  <span class="s3">var </span><span class="s1">lanes = suspendedLanes;</span>

  <span class="s3">while </span><span class="s1">(lanes &gt; </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">index = pickArbitraryLaneIndex(lanes);</span>
    <span class="s3">var </span><span class="s1">lane = </span><span class="s4">1 </span><span class="s1">&lt;&lt; index;</span>
    <span class="s1">expirationTimes[index] = NoTimestamp;</span>
    <span class="s1">lanes &amp;= ~lane;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">markRootPinged(root, pingedLanes, eventTime) {</span>
  <span class="s1">root.pingedLanes |= root.suspendedLanes &amp; pingedLanes;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">markRootFinished(root, remainingLanes) {</span>
  <span class="s3">var </span><span class="s1">noLongerPendingLanes = root.pendingLanes &amp; ~remainingLanes;</span>
  <span class="s1">root.pendingLanes = remainingLanes; </span><span class="s0">// Let's try everything again</span>

  <span class="s1">root.suspendedLanes = NoLanes;</span>
  <span class="s1">root.pingedLanes = NoLanes;</span>
  <span class="s1">root.expiredLanes &amp;= remainingLanes;</span>
  <span class="s1">root.mutableReadLanes &amp;= remainingLanes;</span>
  <span class="s1">root.entangledLanes &amp;= remainingLanes;</span>
  <span class="s3">var </span><span class="s1">entanglements = root.entanglements;</span>
  <span class="s3">var </span><span class="s1">eventTimes = root.eventTimes;</span>
  <span class="s3">var </span><span class="s1">expirationTimes = root.expirationTimes; </span><span class="s0">// Clear the lanes that no longer have pending work</span>

  <span class="s3">var </span><span class="s1">lanes = noLongerPendingLanes;</span>

  <span class="s3">while </span><span class="s1">(lanes &gt; </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">index = pickArbitraryLaneIndex(lanes);</span>
    <span class="s3">var </span><span class="s1">lane = </span><span class="s4">1 </span><span class="s1">&lt;&lt; index;</span>
    <span class="s1">entanglements[index] = NoLanes;</span>
    <span class="s1">eventTimes[index] = NoTimestamp;</span>
    <span class="s1">expirationTimes[index] = NoTimestamp;</span>
    <span class="s1">lanes &amp;= ~lane;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">markRootEntangled(root, entangledLanes) {</span>
  <span class="s0">// In addition to entangling each of the given lanes with each other, we also</span>
  <span class="s0">// have to consider _transitive_ entanglements. For each lane that is already</span>
  <span class="s0">// entangled with *any* of the given lanes, that lane is now transitively</span>
  <span class="s0">// entangled with *all* the given lanes.</span>
  <span class="s0">//</span>
  <span class="s0">// Translated: If C is entangled with A, then entangling A with B also</span>
  <span class="s0">// entangles C with B.</span>
  <span class="s0">//</span>
  <span class="s0">// If this is hard to grasp, it might help to intentionally break this</span>
  <span class="s0">// function and look at the tests that fail in ReactTransition-test.js. Try</span>
  <span class="s0">// commenting out one of the conditions below.</span>
  <span class="s3">var </span><span class="s1">rootEntangledLanes = (root.entangledLanes |= entangledLanes);</span>
  <span class="s3">var </span><span class="s1">entanglements = root.entanglements;</span>
  <span class="s3">var </span><span class="s1">lanes = rootEntangledLanes;</span>

  <span class="s3">while </span><span class="s1">(lanes) {</span>
    <span class="s3">var </span><span class="s1">index = pickArbitraryLaneIndex(lanes);</span>
    <span class="s3">var </span><span class="s1">lane = </span><span class="s4">1 </span><span class="s1">&lt;&lt; index;</span>

    <span class="s3">if </span><span class="s1">(</span>
      <span class="s0">// Is this one of the newly entangled lanes?</span>
      <span class="s1">(lane &amp; entangledLanes) | </span><span class="s0">// Is this lane transitively entangled with the newly entangled lanes?</span>
      <span class="s1">(entanglements[index] &amp; entangledLanes)</span>
    <span class="s1">) {</span>
      <span class="s1">entanglements[index] |= entangledLanes;</span>
    <span class="s1">}</span>

    <span class="s1">lanes &amp;= ~lane;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">getBumpedLaneForHydration(root, renderLanes) {</span>
  <span class="s3">var </span><span class="s1">renderLane = getHighestPriorityLane(renderLanes);</span>
  <span class="s3">var </span><span class="s1">lane;</span>

  <span class="s3">switch </span><span class="s1">(renderLane) {</span>
    <span class="s3">case </span><span class="s1">InputContinuousLane:</span>
      <span class="s1">lane = InputContinuousHydrationLane;</span>
      <span class="s3">break</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s1">DefaultLane:</span>
      <span class="s1">lane = DefaultHydrationLane;</span>
      <span class="s3">break</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s1">TransitionLane1:</span>
    <span class="s3">case </span><span class="s1">TransitionLane2:</span>
    <span class="s3">case </span><span class="s1">TransitionLane3:</span>
    <span class="s3">case </span><span class="s1">TransitionLane4:</span>
    <span class="s3">case </span><span class="s1">TransitionLane5:</span>
    <span class="s3">case </span><span class="s1">TransitionLane6:</span>
    <span class="s3">case </span><span class="s1">TransitionLane7:</span>
    <span class="s3">case </span><span class="s1">TransitionLane8:</span>
    <span class="s3">case </span><span class="s1">TransitionLane9:</span>
    <span class="s3">case </span><span class="s1">TransitionLane10:</span>
    <span class="s3">case </span><span class="s1">TransitionLane11:</span>
    <span class="s3">case </span><span class="s1">TransitionLane12:</span>
    <span class="s3">case </span><span class="s1">TransitionLane13:</span>
    <span class="s3">case </span><span class="s1">TransitionLane14:</span>
    <span class="s3">case </span><span class="s1">TransitionLane15:</span>
    <span class="s3">case </span><span class="s1">TransitionLane16:</span>
    <span class="s3">case </span><span class="s1">RetryLane1:</span>
    <span class="s3">case </span><span class="s1">RetryLane2:</span>
    <span class="s3">case </span><span class="s1">RetryLane3:</span>
    <span class="s3">case </span><span class="s1">RetryLane4:</span>
    <span class="s3">case </span><span class="s1">RetryLane5:</span>
      <span class="s1">lane = TransitionHydrationLane;</span>
      <span class="s3">break</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s1">IdleLane:</span>
      <span class="s1">lane = IdleHydrationLane;</span>
      <span class="s3">break</span><span class="s1">;</span>

    <span class="s3">default</span><span class="s1">:</span>
      <span class="s0">// Everything else is already either a hydration lane, or shouldn't</span>
      <span class="s0">// be retried at a hydration lane.</span>
      <span class="s1">lane = NoLane;</span>
      <span class="s3">break</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s0">// Check if the lane we chose is suspended. If so, that indicates that we</span>
  <span class="s0">// already attempted and failed to hydrate at that level. Also check if we're</span>
  <span class="s0">// already rendering that lane, which is rare but could happen.</span>

  <span class="s3">if </span><span class="s1">((lane &amp; (root.suspendedLanes | renderLanes)) !== NoLane) {</span>
    <span class="s0">// Give up trying to hydrate and fall back to client render.</span>
    <span class="s3">return </span><span class="s1">NoLane;</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">lane;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">addFiberToLanesMap(root, fiber, lanes) {</span>
  <span class="s3">if </span><span class="s1">(!isDevToolsPresent) {</span>
    <span class="s3">return</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">pendingUpdatersLaneMap = root.pendingUpdatersLaneMap;</span>

  <span class="s3">while </span><span class="s1">(lanes &gt; </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">index = laneToIndex(lanes);</span>
    <span class="s3">var </span><span class="s1">lane = </span><span class="s4">1 </span><span class="s1">&lt;&lt; index;</span>
    <span class="s3">var </span><span class="s1">updaters = pendingUpdatersLaneMap[index];</span>
    <span class="s1">updaters.add(fiber);</span>
    <span class="s1">lanes &amp;= ~lane;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">movePendingFibersToMemoized(root, lanes) {</span>
  <span class="s3">if </span><span class="s1">(!isDevToolsPresent) {</span>
    <span class="s3">return</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">pendingUpdatersLaneMap = root.pendingUpdatersLaneMap;</span>
  <span class="s3">var </span><span class="s1">memoizedUpdaters = root.memoizedUpdaters;</span>

  <span class="s3">while </span><span class="s1">(lanes &gt; </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">index = laneToIndex(lanes);</span>
    <span class="s3">var </span><span class="s1">lane = </span><span class="s4">1 </span><span class="s1">&lt;&lt; index;</span>
    <span class="s3">var </span><span class="s1">updaters = pendingUpdatersLaneMap[index];</span>

    <span class="s3">if </span><span class="s1">(updaters.size &gt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s1">updaters.forEach(</span><span class="s3">function</span><span class="s1">(fiber) {</span>
        <span class="s3">var </span><span class="s1">alternate = fiber.alternate;</span>

        <span class="s3">if </span><span class="s1">(alternate === </span><span class="s3">null </span><span class="s1">|| !memoizedUpdaters.has(alternate)) {</span>
          <span class="s1">memoizedUpdaters.add(fiber);</span>
        <span class="s1">}</span>
      <span class="s1">});</span>
      <span class="s1">updaters.clear();</span>
    <span class="s1">}</span>

    <span class="s1">lanes &amp;= ~lane;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">getTransitionsForLanes(root, lanes) {</span>
  <span class="s1">{</span>
    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">DiscreteEventPriority = SyncLane;</span>
<span class="s3">var </span><span class="s1">ContinuousEventPriority = InputContinuousLane;</span>
<span class="s3">var </span><span class="s1">DefaultEventPriority = DefaultLane;</span>
<span class="s3">var </span><span class="s1">IdleEventPriority = IdleLane;</span>
<span class="s3">var </span><span class="s1">currentUpdatePriority = NoLane;</span>
<span class="s3">function </span><span class="s1">getCurrentUpdatePriority() {</span>
  <span class="s3">return </span><span class="s1">currentUpdatePriority;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">setCurrentUpdatePriority(newPriority) {</span>
  <span class="s1">currentUpdatePriority = newPriority;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">higherEventPriority(a, b) {</span>
  <span class="s3">return </span><span class="s1">a !== </span><span class="s4">0 </span><span class="s1">&amp;&amp; a &lt; b ? a : b;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">lowerEventPriority(a, b) {</span>
  <span class="s3">return </span><span class="s1">a === </span><span class="s4">0 </span><span class="s1">|| a &gt; b ? a : b;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">isHigherEventPriority(a, b) {</span>
  <span class="s3">return </span><span class="s1">a !== </span><span class="s4">0 </span><span class="s1">&amp;&amp; a &lt; b;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">lanesToEventPriority(lanes) {</span>
  <span class="s3">var </span><span class="s1">lane = getHighestPriorityLane(lanes);</span>

  <span class="s3">if </span><span class="s1">(!isHigherEventPriority(DiscreteEventPriority, lane)) {</span>
    <span class="s3">return </span><span class="s1">DiscreteEventPriority;</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(!isHigherEventPriority(ContinuousEventPriority, lane)) {</span>
    <span class="s3">return </span><span class="s1">ContinuousEventPriority;</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(includesNonIdleWork(lane)) {</span>
    <span class="s3">return </span><span class="s1">DefaultEventPriority;</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">IdleEventPriority;</span>
<span class="s1">}</span>

<span class="s0">// Renderers that don't support mutation</span>
<span class="s0">// can re-export everything from this module.</span>
<span class="s3">function </span><span class="s1">shim() {</span>
  <span class="s3">throw new </span><span class="s1">Error(</span>
    <span class="s2">&quot;The current renderer does not support mutation. &quot; </span><span class="s1">+</span>
      <span class="s2">&quot;This error is likely caused by a bug in React. &quot; </span><span class="s1">+</span>
      <span class="s2">&quot;Please file an issue.&quot;</span>
  <span class="s1">);</span>
<span class="s1">} </span><span class="s0">// Mutation (when unsupported)</span>
<span class="s3">var </span><span class="s1">commitMount = shim;</span>

<span class="s0">// Renderers that don't support hydration</span>
<span class="s0">// can re-export everything from this module.</span>
<span class="s3">function </span><span class="s1">shim$1() {</span>
  <span class="s3">throw new </span><span class="s1">Error(</span>
    <span class="s2">&quot;The current renderer does not support hydration. &quot; </span><span class="s1">+</span>
      <span class="s2">&quot;This error is likely caused by a bug in React. &quot; </span><span class="s1">+</span>
      <span class="s2">&quot;Please file an issue.&quot;</span>
  <span class="s1">);</span>
<span class="s1">} </span><span class="s0">// Hydration (when unsupported)</span>
<span class="s3">var </span><span class="s1">isSuspenseInstancePending = shim$1;</span>
<span class="s3">var </span><span class="s1">isSuspenseInstanceFallback = shim$1;</span>
<span class="s3">var </span><span class="s1">getSuspenseInstanceFallbackErrorDetails = shim$1;</span>
<span class="s3">var </span><span class="s1">registerSuspenseInstanceRetry = shim$1;</span>
<span class="s3">var </span><span class="s1">hydrateTextInstance = shim$1;</span>
<span class="s3">var </span><span class="s1">errorHydratingContainer = shim$1;</span>

<span class="s3">var </span><span class="s1">_nativeFabricUIManage = nativeFabricUIManager,</span>
  <span class="s1">createNode = _nativeFabricUIManage.createNode,</span>
  <span class="s1">cloneNode = _nativeFabricUIManage.cloneNode,</span>
  <span class="s1">cloneNodeWithNewChildren = _nativeFabricUIManage.cloneNodeWithNewChildren,</span>
  <span class="s1">cloneNodeWithNewChildrenAndProps =</span>
    <span class="s1">_nativeFabricUIManage.cloneNodeWithNewChildrenAndProps,</span>
  <span class="s1">cloneNodeWithNewProps = _nativeFabricUIManage.cloneNodeWithNewProps,</span>
  <span class="s1">createChildNodeSet = _nativeFabricUIManage.createChildSet,</span>
  <span class="s1">appendChildNode = _nativeFabricUIManage.appendChild,</span>
  <span class="s1">appendChildNodeToSet = _nativeFabricUIManage.appendChildToSet,</span>
  <span class="s1">completeRoot = _nativeFabricUIManage.completeRoot,</span>
  <span class="s1">registerEventHandler = _nativeFabricUIManage.registerEventHandler,</span>
  <span class="s1">fabricMeasure = _nativeFabricUIManage.measure,</span>
  <span class="s1">fabricMeasureInWindow = _nativeFabricUIManage.measureInWindow,</span>
  <span class="s1">fabricMeasureLayout = _nativeFabricUIManage.measureLayout,</span>
  <span class="s1">FabricDefaultPriority = _nativeFabricUIManage.unstable_DefaultEventPriority,</span>
  <span class="s1">FabricDiscretePriority = _nativeFabricUIManage.unstable_DiscreteEventPriority,</span>
  <span class="s1">fabricGetCurrentEventPriority =</span>
    <span class="s1">_nativeFabricUIManage.unstable_getCurrentEventPriority,</span>
  <span class="s1">_setNativeProps = _nativeFabricUIManage.setNativeProps;</span>
<span class="s3">var </span><span class="s1">getViewConfigForType =</span>
  <span class="s1">ReactNativePrivateInterface.ReactNativeViewConfigRegistry.get; </span><span class="s0">// Counter for uniquely identifying views.</span>
<span class="s0">// % 10 === 1 means it is a rootTag.</span>
<span class="s0">// % 2 === 0 means it is a Fabric tag.</span>
<span class="s0">// This means that they never overlap.</span>

<span class="s3">var </span><span class="s1">nextReactTag = </span><span class="s4">2</span><span class="s1">;</span>

<span class="s0">// TODO: Remove this conditional once all changes have propagated.</span>
<span class="s3">if </span><span class="s1">(registerEventHandler) {</span>
  <span class="s0">/** 
   * Register the event emitter with the native bridge 
   */</span>
  <span class="s1">registerEventHandler(dispatchEvent);</span>
<span class="s1">}</span>
<span class="s0">/** 
 * This is used for refs on host components. 
 */</span>

<span class="s3">var </span><span class="s1">ReactFabricHostComponent = </span><span class="s0">/*#__PURE__*/ </span><span class="s1">(</span><span class="s3">function</span><span class="s1">() {</span>
  <span class="s3">function </span><span class="s1">ReactFabricHostComponent(</span>
    <span class="s1">tag,</span>
    <span class="s1">viewConfig,</span>
    <span class="s1">props,</span>
    <span class="s1">internalInstanceHandle</span>
  <span class="s1">) {</span>
    <span class="s3">this</span><span class="s1">._nativeTag = tag;</span>
    <span class="s3">this</span><span class="s1">.viewConfig = viewConfig;</span>
    <span class="s3">this</span><span class="s1">.currentProps = props;</span>
    <span class="s3">this</span><span class="s1">._internalInstanceHandle = internalInstanceHandle;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">_proto = ReactFabricHostComponent.prototype;</span>

  <span class="s1">_proto.blur = </span><span class="s3">function </span><span class="s1">blur() {</span>
    <span class="s1">ReactNativePrivateInterface.TextInputState.blurTextInput(</span><span class="s3">this</span><span class="s1">);</span>
  <span class="s1">};</span>

  <span class="s1">_proto.focus = </span><span class="s3">function </span><span class="s1">focus() {</span>
    <span class="s1">ReactNativePrivateInterface.TextInputState.focusTextInput(</span><span class="s3">this</span><span class="s1">);</span>
  <span class="s1">};</span>

  <span class="s1">_proto.measure = </span><span class="s3">function </span><span class="s1">measure(callback) {</span>
    <span class="s3">var </span><span class="s1">stateNode = </span><span class="s3">this</span><span class="s1">._internalInstanceHandle.stateNode;</span>

    <span class="s3">if </span><span class="s1">(stateNode != </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">fabricMeasure(</span>
        <span class="s1">stateNode.node,</span>
        <span class="s1">mountSafeCallback_NOT_REALLY_SAFE(</span><span class="s3">this</span><span class="s1">, callback)</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s1">_proto.measureInWindow = </span><span class="s3">function </span><span class="s1">measureInWindow(callback) {</span>
    <span class="s3">var </span><span class="s1">stateNode = </span><span class="s3">this</span><span class="s1">._internalInstanceHandle.stateNode;</span>

    <span class="s3">if </span><span class="s1">(stateNode != </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">fabricMeasureInWindow(</span>
        <span class="s1">stateNode.node,</span>
        <span class="s1">mountSafeCallback_NOT_REALLY_SAFE(</span><span class="s3">this</span><span class="s1">, callback)</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s1">_proto.measureLayout = </span><span class="s3">function </span><span class="s1">measureLayout(</span>
    <span class="s1">relativeToNativeNode,</span>
    <span class="s1">onSuccess,</span>
    <span class="s1">onFail</span>
  <span class="s1">) </span><span class="s0">/* currently unused */</span>
  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(</span>
      <span class="s3">typeof </span><span class="s1">relativeToNativeNode === </span><span class="s2">&quot;number&quot; </span><span class="s1">||</span>
      <span class="s1">!(relativeToNativeNode </span><span class="s3">instanceof </span><span class="s1">ReactFabricHostComponent)</span>
    <span class="s1">) {</span>
      <span class="s1">{</span>
        <span class="s1">error(</span>
          <span class="s2">&quot;Warning: ref.measureLayout must be called with a ref to a native component.&quot;</span>
        <span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">toStateNode = </span><span class="s3">this</span><span class="s1">._internalInstanceHandle.stateNode;</span>
    <span class="s3">var </span><span class="s1">fromStateNode = relativeToNativeNode._internalInstanceHandle.stateNode;</span>

    <span class="s3">if </span><span class="s1">(toStateNode != </span><span class="s3">null </span><span class="s1">&amp;&amp; fromStateNode != </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">fabricMeasureLayout(</span>
        <span class="s1">toStateNode.node,</span>
        <span class="s1">fromStateNode.node,</span>
        <span class="s1">mountSafeCallback_NOT_REALLY_SAFE(</span><span class="s3">this</span><span class="s1">, onFail),</span>
        <span class="s1">mountSafeCallback_NOT_REALLY_SAFE(</span><span class="s3">this</span><span class="s1">, onSuccess)</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s1">_proto.setNativeProps = </span><span class="s3">function </span><span class="s1">setNativeProps(nativeProps) {</span>
    <span class="s1">{</span>
      <span class="s1">warnForStyleProps(nativeProps, </span><span class="s3">this</span><span class="s1">.viewConfig.validAttributes);</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">updatePayload = create(nativeProps, </span><span class="s3">this</span><span class="s1">.viewConfig.validAttributes);</span>
    <span class="s3">var </span><span class="s1">stateNode = </span><span class="s3">this</span><span class="s1">._internalInstanceHandle.stateNode;</span>

    <span class="s3">if </span><span class="s1">(stateNode != </span><span class="s3">null </span><span class="s1">&amp;&amp; updatePayload != </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">_setNativeProps(stateNode.node, updatePayload);</span>
    <span class="s1">}</span>
  <span class="s1">}; </span><span class="s0">// This API (addEventListener, removeEventListener) attempts to adhere to the</span>
  <span class="s0">// w3 Level2 Events spec as much as possible, treating HostComponent as a DOM node.</span>
  <span class="s0">//</span>
  <span class="s0">// Unless otherwise noted, these methods should &quot;just work&quot; and adhere to the W3 specs.</span>
  <span class="s0">// If they deviate in a way that is not explicitly noted here, you've found a bug!</span>
  <span class="s0">//</span>
  <span class="s0">// See:</span>
  <span class="s0">// * https://www.w3.org/TR/DOM-Level-2-Events/events.html</span>
  <span class="s0">// * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener</span>
  <span class="s0">// * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener</span>
  <span class="s0">//</span>
  <span class="s0">// And notably, not implemented (yet?):</span>
  <span class="s0">// * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/dispatchEvent</span>
  <span class="s0">//</span>
  <span class="s0">//</span>
  <span class="s0">// Deviations from spec/TODOs:</span>
  <span class="s0">// (1) listener must currently be a function, we do not support EventListener objects yet.</span>
  <span class="s0">// (2) we do not support the `signal` option / AbortSignal yet</span>

  <span class="s1">_proto.addEventListener_unstable = </span><span class="s3">function </span><span class="s1">addEventListener_unstable(</span>
    <span class="s1">eventType,</span>
    <span class="s1">listener,</span>
    <span class="s1">options</span>
  <span class="s1">) {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">eventType !== </span><span class="s2">&quot;string&quot;</span><span class="s1">) {</span>
      <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;addEventListener_unstable eventType must be a string&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">listener !== </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
      <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;addEventListener_unstable listener must be a function&quot;</span><span class="s1">);</span>
    <span class="s1">} </span><span class="s0">// The third argument is either boolean indicating &quot;captures&quot; or an object.</span>

    <span class="s3">var </span><span class="s1">optionsObj =</span>
      <span class="s3">typeof </span><span class="s1">options === </span><span class="s2">&quot;object&quot; </span><span class="s1">&amp;&amp; options !== </span><span class="s3">null </span><span class="s1">? options : {};</span>
    <span class="s3">var </span><span class="s1">capture =</span>
      <span class="s1">(</span><span class="s3">typeof </span><span class="s1">options === </span><span class="s2">&quot;boolean&quot; </span><span class="s1">? options : optionsObj.capture) || </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">once = optionsObj.once || </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">passive = optionsObj.passive || </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">signal = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// TODO: implement signal/AbortSignal</span>

    <span class="s3">var </span><span class="s1">eventListeners = </span><span class="s3">this</span><span class="s1">._eventListeners || {};</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._eventListeners == </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">this</span><span class="s1">._eventListeners = eventListeners;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">namedEventListeners = eventListeners[eventType] || [];</span>

    <span class="s3">if </span><span class="s1">(eventListeners[eventType] == </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">eventListeners[eventType] = namedEventListeners;</span>
    <span class="s1">}</span>

    <span class="s1">namedEventListeners.push({</span>
      <span class="s1">listener: listener,</span>
      <span class="s1">invalidated: </span><span class="s3">false</span><span class="s1">,</span>
      <span class="s1">options: {</span>
        <span class="s1">capture: capture,</span>
        <span class="s1">once: once,</span>
        <span class="s1">passive: passive,</span>
        <span class="s1">signal: signal</span>
      <span class="s1">}</span>
    <span class="s1">});</span>
  <span class="s1">}; </span><span class="s0">// See https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener</span>

  <span class="s1">_proto.removeEventListener_unstable = </span><span class="s3">function </span><span class="s1">removeEventListener_unstable(</span>
    <span class="s1">eventType,</span>
    <span class="s1">listener,</span>
    <span class="s1">options</span>
  <span class="s1">) {</span>
    <span class="s0">// eventType and listener must be referentially equal to be removed from the listeners</span>
    <span class="s0">// data structure, but in &quot;options&quot; we only check the `capture` flag, according to spec.</span>
    <span class="s0">// That means if you add the same function as a listener with capture set to true and false,</span>
    <span class="s0">// you must also call removeEventListener twice with capture set to true/false.</span>
    <span class="s3">var </span><span class="s1">optionsObj =</span>
      <span class="s3">typeof </span><span class="s1">options === </span><span class="s2">&quot;object&quot; </span><span class="s1">&amp;&amp; options !== </span><span class="s3">null </span><span class="s1">? options : {};</span>
    <span class="s3">var </span><span class="s1">capture =</span>
      <span class="s1">(</span><span class="s3">typeof </span><span class="s1">options === </span><span class="s2">&quot;boolean&quot; </span><span class="s1">? options : optionsObj.capture) || </span><span class="s3">false</span><span class="s1">; </span><span class="s0">// If there are no event listeners or named event listeners, we can bail early - our</span>
    <span class="s0">// job is already done.</span>

    <span class="s3">var </span><span class="s1">eventListeners = </span><span class="s3">this</span><span class="s1">._eventListeners;</span>

    <span class="s3">if </span><span class="s1">(!eventListeners) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">namedEventListeners = eventListeners[eventType];</span>

    <span class="s3">if </span><span class="s1">(!namedEventListeners) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s0">// TODO: optimize this path to make remove cheaper</span>

    <span class="s1">eventListeners[eventType] = namedEventListeners.filter(</span><span class="s3">function</span><span class="s1">(</span>
      <span class="s1">listenerObj</span>
    <span class="s1">) {</span>
      <span class="s3">return </span><span class="s1">!(</span>
        <span class="s1">listenerObj.listener === listener &amp;&amp;</span>
        <span class="s1">listenerObj.options.capture === capture</span>
      <span class="s1">);</span>
    <span class="s1">});</span>
  <span class="s1">};</span>

  <span class="s3">return </span><span class="s1">ReactFabricHostComponent;</span>
<span class="s1">})(); </span><span class="s0">// eslint-disable-next-line no-unused-expressions</span>
<span class="s3">function </span><span class="s1">appendInitialChild(parentInstance, child) {</span>
  <span class="s1">appendChildNode(parentInstance.node, child.node);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">createInstance(</span>
  <span class="s1">type,</span>
  <span class="s1">props,</span>
  <span class="s1">rootContainerInstance,</span>
  <span class="s1">hostContext,</span>
  <span class="s1">internalInstanceHandle</span>
<span class="s1">) {</span>
  <span class="s3">var </span><span class="s1">tag = nextReactTag;</span>
  <span class="s1">nextReactTag += </span><span class="s4">2</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">viewConfig = getViewConfigForType(type);</span>

  <span class="s1">{</span>
    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">key </span><span class="s3">in </span><span class="s1">viewConfig.validAttributes) {</span>
      <span class="s3">if </span><span class="s1">(props.hasOwnProperty(key)) {</span>
        <span class="s1">ReactNativePrivateInterface.deepFreezeAndThrowOnMutationInDev(</span>
          <span class="s1">props[key]</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">updatePayload = create(props, viewConfig.validAttributes);</span>
  <span class="s3">var </span><span class="s1">node = createNode(</span>
    <span class="s1">tag, </span><span class="s0">// reactTag</span>
    <span class="s1">viewConfig.uiViewClassName, </span><span class="s0">// viewName</span>
    <span class="s1">rootContainerInstance, </span><span class="s0">// rootTag</span>
    <span class="s1">updatePayload, </span><span class="s0">// props</span>
    <span class="s1">internalInstanceHandle </span><span class="s0">// internalInstanceHandle</span>
  <span class="s1">);</span>
  <span class="s3">var </span><span class="s1">component = </span><span class="s3">new </span><span class="s1">ReactFabricHostComponent(</span>
    <span class="s1">tag,</span>
    <span class="s1">viewConfig,</span>
    <span class="s1">props,</span>
    <span class="s1">internalInstanceHandle</span>
  <span class="s1">);</span>
  <span class="s3">return </span><span class="s1">{</span>
    <span class="s1">node: node,</span>
    <span class="s1">canonical: component</span>
  <span class="s1">};</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">createTextInstance(</span>
  <span class="s1">text,</span>
  <span class="s1">rootContainerInstance,</span>
  <span class="s1">hostContext,</span>
  <span class="s1">internalInstanceHandle</span>
<span class="s1">) {</span>
  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(!hostContext.isInAParentText) {</span>
      <span class="s1">error(</span><span class="s2">&quot;Text strings must be rendered within a &lt;Text&gt; component.&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">tag = nextReactTag;</span>
  <span class="s1">nextReactTag += </span><span class="s4">2</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">node = createNode(</span>
    <span class="s1">tag, </span><span class="s0">// reactTag</span>
    <span class="s2">&quot;RCTRawText&quot;</span><span class="s1">, </span><span class="s0">// viewName</span>
    <span class="s1">rootContainerInstance, </span><span class="s0">// rootTag</span>
    <span class="s1">{</span>
      <span class="s1">text: text</span>
    <span class="s1">}, </span><span class="s0">// props</span>
    <span class="s1">internalInstanceHandle </span><span class="s0">// instance handle</span>
  <span class="s1">);</span>
  <span class="s3">return </span><span class="s1">{</span>
    <span class="s1">node: node</span>
  <span class="s1">};</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">getRootHostContext(rootContainerInstance) {</span>
  <span class="s3">return </span><span class="s1">{</span>
    <span class="s1">isInAParentText: </span><span class="s3">false</span>
  <span class="s1">};</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">getChildHostContext(parentHostContext, type, rootContainerInstance) {</span>
  <span class="s3">var </span><span class="s1">prevIsInAParentText = parentHostContext.isInAParentText;</span>
  <span class="s3">var </span><span class="s1">isInAParentText =</span>
    <span class="s1">type === </span><span class="s2">&quot;AndroidTextInput&quot; </span><span class="s1">|| </span><span class="s0">// Android</span>
    <span class="s1">type === </span><span class="s2">&quot;RCTMultilineTextInputView&quot; </span><span class="s1">|| </span><span class="s0">// iOS</span>
    <span class="s1">type === </span><span class="s2">&quot;RCTSinglelineTextInputView&quot; </span><span class="s1">|| </span><span class="s0">// iOS</span>
    <span class="s1">type === </span><span class="s2">&quot;RCTText&quot; </span><span class="s1">||</span>
    <span class="s1">type === </span><span class="s2">&quot;RCTVirtualText&quot;</span><span class="s1">; </span><span class="s0">// TODO: If this is an offscreen host container, we should reuse the</span>
  <span class="s0">// parent context.</span>

  <span class="s3">if </span><span class="s1">(prevIsInAParentText !== isInAParentText) {</span>
    <span class="s3">return </span><span class="s1">{</span>
      <span class="s1">isInAParentText: isInAParentText</span>
    <span class="s1">};</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s3">return </span><span class="s1">parentHostContext;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">getPublicInstance(instance) {</span>
  <span class="s3">return </span><span class="s1">instance.canonical;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">prepareForCommit(containerInfo) {</span>
  <span class="s0">// Noop</span>
  <span class="s3">return null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">prepareUpdate(</span>
  <span class="s1">instance,</span>
  <span class="s1">type,</span>
  <span class="s1">oldProps,</span>
  <span class="s1">newProps,</span>
  <span class="s1">rootContainerInstance,</span>
  <span class="s1">hostContext</span>
<span class="s1">) {</span>
  <span class="s3">var </span><span class="s1">viewConfig = instance.canonical.viewConfig;</span>
  <span class="s3">var </span><span class="s1">updatePayload = diff(oldProps, newProps, viewConfig.validAttributes); </span><span class="s0">// TODO: If the event handlers have changed, we need to update the current props</span>
  <span class="s0">// in the commit phase but there is no host config hook to do it yet.</span>
  <span class="s0">// So instead we hack it by updating it in the render phase.</span>

  <span class="s1">instance.canonical.currentProps = newProps;</span>
  <span class="s3">return </span><span class="s1">updatePayload;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">resetAfterCommit(containerInfo) {</span>
  <span class="s0">// Noop</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">shouldSetTextContent(type, props) {</span>
  <span class="s0">// TODO (bvaughn) Revisit this decision.</span>
  <span class="s0">// Always returning false simplifies the createInstance() implementation,</span>
  <span class="s0">// But creates an additional child Fiber for raw text children.</span>
  <span class="s0">// No additional native views are created though.</span>
  <span class="s0">// It's not clear to me which is better so I'm deferring for now.</span>
  <span class="s0">// More context @ github.com/facebook/react/pull/8560#discussion_r92111303</span>
  <span class="s3">return false</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">getCurrentEventPriority() {</span>
  <span class="s3">var </span><span class="s1">currentEventPriority = fabricGetCurrentEventPriority</span>
    <span class="s1">? fabricGetCurrentEventPriority()</span>
    <span class="s1">: </span><span class="s3">null</span><span class="s1">;</span>

  <span class="s3">if </span><span class="s1">(currentEventPriority != </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">switch </span><span class="s1">(currentEventPriority) {</span>
      <span class="s3">case </span><span class="s1">FabricDiscretePriority:</span>
        <span class="s3">return </span><span class="s1">DiscreteEventPriority;</span>

      <span class="s3">case </span><span class="s1">FabricDefaultPriority:</span>
      <span class="s3">default</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">DefaultEventPriority;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">DefaultEventPriority;</span>
<span class="s1">} </span><span class="s0">// The Fabric renderer is secondary to the existing React Native renderer.</span>

<span class="s3">var </span><span class="s1">warnsIfNotActing = </span><span class="s3">false</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">scheduleTimeout = setTimeout;</span>
<span class="s3">var </span><span class="s1">cancelTimeout = clearTimeout;</span>
<span class="s3">var </span><span class="s1">noTimeout = -</span><span class="s4">1</span><span class="s1">; </span><span class="s0">// -------------------</span>
<span class="s3">function </span><span class="s1">cloneInstance(</span>
  <span class="s1">instance,</span>
  <span class="s1">updatePayload,</span>
  <span class="s1">type,</span>
  <span class="s1">oldProps,</span>
  <span class="s1">newProps,</span>
  <span class="s1">internalInstanceHandle,</span>
  <span class="s1">keepChildren,</span>
  <span class="s1">recyclableInstance</span>
<span class="s1">) {</span>
  <span class="s3">var </span><span class="s1">node = instance.node;</span>
  <span class="s3">var </span><span class="s1">clone;</span>

  <span class="s3">if </span><span class="s1">(keepChildren) {</span>
    <span class="s3">if </span><span class="s1">(updatePayload !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">clone = cloneNodeWithNewProps(node, updatePayload);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">clone = cloneNode(node);</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(updatePayload !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">clone = cloneNodeWithNewChildrenAndProps(node, updatePayload);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">clone = cloneNodeWithNewChildren(node);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">{</span>
    <span class="s1">node: clone,</span>
    <span class="s1">canonical: instance.canonical</span>
  <span class="s1">};</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">cloneHiddenInstance(instance, type, props, internalInstanceHandle) {</span>
  <span class="s3">var </span><span class="s1">viewConfig = instance.canonical.viewConfig;</span>
  <span class="s3">var </span><span class="s1">node = instance.node;</span>
  <span class="s3">var </span><span class="s1">updatePayload = create(</span>
    <span class="s1">{</span>
      <span class="s1">style: {</span>
        <span class="s1">display: </span><span class="s2">&quot;none&quot;</span>
      <span class="s1">}</span>
    <span class="s1">},</span>
    <span class="s1">viewConfig.validAttributes</span>
  <span class="s1">);</span>
  <span class="s3">return </span><span class="s1">{</span>
    <span class="s1">node: cloneNodeWithNewProps(node, updatePayload),</span>
    <span class="s1">canonical: instance.canonical</span>
  <span class="s1">};</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">cloneHiddenTextInstance(instance, text, internalInstanceHandle) {</span>
  <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Not yet implemented.&quot;</span><span class="s1">);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">createContainerChildSet(container) {</span>
  <span class="s3">return </span><span class="s1">createChildNodeSet(container);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">appendChildToContainerChildSet(childSet, child) {</span>
  <span class="s1">appendChildNodeToSet(childSet, child.node);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">finalizeContainerChildren(container, newChildren) {</span>
  <span class="s1">completeRoot(container, newChildren);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">replaceContainerChildren(container, newChildren) {}</span>
<span class="s3">function </span><span class="s1">preparePortalMount(portalInstance) {</span>
  <span class="s0">// noop</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;</span>
<span class="s3">function </span><span class="s1">describeBuiltInComponentFrame(name, source, ownerFn) {</span>
  <span class="s1">{</span>
    <span class="s3">var </span><span class="s1">ownerName = </span><span class="s3">null</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s1">(ownerFn) {</span>
      <span class="s1">ownerName = ownerFn.displayName || ownerFn.name || </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">describeComponentFrame(name, source, ownerName);</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">var </span><span class="s1">componentFrameCache;</span>

<span class="s1">{</span>
  <span class="s3">var </span><span class="s1">PossiblyWeakMap = </span><span class="s3">typeof </span><span class="s1">WeakMap === </span><span class="s2">&quot;function&quot; </span><span class="s1">? WeakMap : Map;</span>
  <span class="s1">componentFrameCache = </span><span class="s3">new </span><span class="s1">PossiblyWeakMap();</span>
<span class="s1">}</span>
<span class="s3">var </span><span class="s1">BEFORE_SLASH_RE = /^(.*)[\\\/]/;</span>

<span class="s3">function </span><span class="s1">describeComponentFrame(name, source, ownerName) {</span>
  <span class="s3">var </span><span class="s1">sourceInfo = </span><span class="s2">&quot;&quot;</span><span class="s1">;</span>

  <span class="s3">if </span><span class="s1">(source) {</span>
    <span class="s3">var </span><span class="s1">path = source.fileName;</span>
    <span class="s3">var </span><span class="s1">fileName = path.replace(BEFORE_SLASH_RE, </span><span class="s2">&quot;&quot;</span><span class="s1">); </span><span class="s0">// In DEV, include code for a common special case:</span>
    <span class="s0">// prefer &quot;folder/index.js&quot; instead of just &quot;index.js&quot;.</span>

    <span class="s3">if </span><span class="s1">(/^index\./.test(fileName)) {</span>
      <span class="s3">var </span><span class="s1">match = path.match(BEFORE_SLASH_RE);</span>

      <span class="s3">if </span><span class="s1">(match) {</span>
        <span class="s3">var </span><span class="s1">pathBeforeSlash = match[</span><span class="s4">1</span><span class="s1">];</span>

        <span class="s3">if </span><span class="s1">(pathBeforeSlash) {</span>
          <span class="s3">var </span><span class="s1">folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, </span><span class="s2">&quot;&quot;</span><span class="s1">);</span>
          <span class="s1">fileName = folderName + </span><span class="s2">&quot;/&quot; </span><span class="s1">+ fileName;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">sourceInfo = </span><span class="s2">&quot; (at &quot; </span><span class="s1">+ fileName + </span><span class="s2">&quot;:&quot; </span><span class="s1">+ source.lineNumber + </span><span class="s2">&quot;)&quot;</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(ownerName) {</span>
    <span class="s1">sourceInfo = </span><span class="s2">&quot; (created by &quot; </span><span class="s1">+ ownerName + </span><span class="s2">&quot;)&quot;</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s2">&quot;</span><span class="s5">\n    </span><span class="s2">in &quot; </span><span class="s1">+ (name || </span><span class="s2">&quot;Unknown&quot;</span><span class="s1">) + sourceInfo;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">describeClassComponentFrame(ctor, source, ownerFn) {</span>
  <span class="s1">{</span>
    <span class="s3">return </span><span class="s1">describeFunctionComponentFrame(ctor, source, ownerFn);</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">describeFunctionComponentFrame(fn, source, ownerFn) {</span>
  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(!fn) {</span>
      <span class="s3">return </span><span class="s2">&quot;&quot;</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">name = fn.displayName || fn.name || </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">ownerName = </span><span class="s3">null</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s1">(ownerFn) {</span>
      <span class="s1">ownerName = ownerFn.displayName || ownerFn.name || </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">describeComponentFrame(name, source, ownerName);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {</span>
  <span class="s3">if </span><span class="s1">(type == </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">return </span><span class="s2">&quot;&quot;</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">type === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
    <span class="s1">{</span>
      <span class="s3">return </span><span class="s1">describeFunctionComponentFrame(type, source, ownerFn);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">type === </span><span class="s2">&quot;string&quot;</span><span class="s1">) {</span>
    <span class="s3">return </span><span class="s1">describeBuiltInComponentFrame(type, source, ownerFn);</span>
  <span class="s1">}</span>

  <span class="s3">switch </span><span class="s1">(type) {</span>
    <span class="s3">case </span><span class="s1">REACT_SUSPENSE_TYPE:</span>
      <span class="s3">return </span><span class="s1">describeBuiltInComponentFrame(</span><span class="s2">&quot;Suspense&quot;</span><span class="s1">, source, ownerFn);</span>

    <span class="s3">case </span><span class="s1">REACT_SUSPENSE_LIST_TYPE:</span>
      <span class="s3">return </span><span class="s1">describeBuiltInComponentFrame(</span><span class="s2">&quot;SuspenseList&quot;</span><span class="s1">, source, ownerFn);</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">type === </span><span class="s2">&quot;object&quot;</span><span class="s1">) {</span>
    <span class="s3">switch </span><span class="s1">(type.$$typeof) {</span>
      <span class="s3">case </span><span class="s1">REACT_FORWARD_REF_TYPE:</span>
        <span class="s3">return </span><span class="s1">describeFunctionComponentFrame(type.render, source, ownerFn);</span>

      <span class="s3">case </span><span class="s1">REACT_MEMO_TYPE:</span>
        <span class="s0">// Memo may contain any component type so we recursively resolve it.</span>
        <span class="s3">return </span><span class="s1">describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);</span>

      <span class="s3">case </span><span class="s1">REACT_LAZY_TYPE: {</span>
        <span class="s3">var </span><span class="s1">lazyComponent = type;</span>
        <span class="s3">var </span><span class="s1">payload = lazyComponent._payload;</span>
        <span class="s3">var </span><span class="s1">init = lazyComponent._init;</span>

        <span class="s3">try </span><span class="s1">{</span>
          <span class="s0">// Lazy may contain any component type so we recursively resolve it.</span>
          <span class="s3">return </span><span class="s1">describeUnknownElementTypeFrameInDEV(</span>
            <span class="s1">init(payload),</span>
            <span class="s1">source,</span>
            <span class="s1">ownerFn</span>
          <span class="s1">);</span>
        <span class="s1">} </span><span class="s3">catch </span><span class="s1">(x) {}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s2">&quot;&quot;</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">hasOwnProperty = Object.prototype.hasOwnProperty;</span>

<span class="s3">var </span><span class="s1">loggedTypeFailures = {};</span>
<span class="s3">var </span><span class="s1">ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;</span>

<span class="s3">function </span><span class="s1">setCurrentlyValidatingElement(element) {</span>
  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(element) {</span>
      <span class="s3">var </span><span class="s1">owner = element._owner;</span>
      <span class="s3">var </span><span class="s1">stack = describeUnknownElementTypeFrameInDEV(</span>
        <span class="s1">element.type,</span>
        <span class="s1">element._source,</span>
        <span class="s1">owner ? owner.type : </span><span class="s3">null</span>
      <span class="s1">);</span>
      <span class="s1">ReactDebugCurrentFrame.setExtraStackFrame(stack);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">ReactDebugCurrentFrame.setExtraStackFrame(</span><span class="s3">null</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">checkPropTypes(typeSpecs, values, location, componentName, element) {</span>
  <span class="s1">{</span>
    <span class="s0">// $FlowFixMe This is okay but Flow doesn't know it.</span>
    <span class="s3">var </span><span class="s1">has = Function.call.bind(hasOwnProperty);</span>

    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">typeSpecName </span><span class="s3">in </span><span class="s1">typeSpecs) {</span>
      <span class="s3">if </span><span class="s1">(has(typeSpecs, typeSpecName)) {</span>
        <span class="s3">var </span><span class="s1">error$1 = </span><span class="s3">void </span><span class="s4">0</span><span class="s1">; </span><span class="s0">// Prop type validation may throw. In case they do, we don't want to</span>
        <span class="s0">// fail the render phase where it didn't fail before. So we log it.</span>
        <span class="s0">// After these have been cleaned up, we'll let them throw.</span>

        <span class="s3">try </span><span class="s1">{</span>
          <span class="s0">// This is intentionally an invariant that gets caught. It's the same</span>
          <span class="s0">// behavior as without this statement except with a better message.</span>
          <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">typeSpecs[typeSpecName] !== </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
            <span class="s0">// eslint-disable-next-line react-internal/prod-error-codes</span>
            <span class="s3">var </span><span class="s1">err = Error(</span>
              <span class="s1">(componentName || </span><span class="s2">&quot;React class&quot;</span><span class="s1">) +</span>
                <span class="s2">&quot;: &quot; </span><span class="s1">+</span>
                <span class="s1">location +</span>
                <span class="s2">&quot; type `&quot; </span><span class="s1">+</span>
                <span class="s1">typeSpecName +</span>
                <span class="s2">&quot;` is invalid; &quot; </span><span class="s1">+</span>
                <span class="s2">&quot;it must be a function, usually from the `prop-types` package, but received `&quot; </span><span class="s1">+</span>
                <span class="s3">typeof </span><span class="s1">typeSpecs[typeSpecName] +</span>
                <span class="s2">&quot;`.&quot; </span><span class="s1">+</span>
                <span class="s2">&quot;This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.&quot;</span>
            <span class="s1">);</span>
            <span class="s1">err.name = </span><span class="s2">&quot;Invariant Violation&quot;</span><span class="s1">;</span>
            <span class="s3">throw </span><span class="s1">err;</span>
          <span class="s1">}</span>

          <span class="s1">error$1 = typeSpecs[typeSpecName](</span>
            <span class="s1">values,</span>
            <span class="s1">typeSpecName,</span>
            <span class="s1">componentName,</span>
            <span class="s1">location,</span>
            <span class="s3">null</span><span class="s1">,</span>
            <span class="s2">&quot;SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED&quot;</span>
          <span class="s1">);</span>
        <span class="s1">} </span><span class="s3">catch </span><span class="s1">(ex) {</span>
          <span class="s1">error$1 = ex;</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(error$1 &amp;&amp; !(error$1 </span><span class="s3">instanceof </span><span class="s1">Error)) {</span>
          <span class="s1">setCurrentlyValidatingElement(element);</span>

          <span class="s1">error(</span>
            <span class="s2">&quot;%s: type specification of %s&quot; </span><span class="s1">+</span>
              <span class="s2">&quot; `%s` is invalid; the type checker &quot; </span><span class="s1">+</span>
              <span class="s2">&quot;function must return `null` or an `Error` but returned a %s. &quot; </span><span class="s1">+</span>
              <span class="s2">&quot;You may have forgotten to pass an argument to the type checker &quot; </span><span class="s1">+</span>
              <span class="s2">&quot;creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and &quot; </span><span class="s1">+</span>
              <span class="s2">&quot;shape all require an argument).&quot;</span><span class="s1">,</span>
            <span class="s1">componentName || </span><span class="s2">&quot;React class&quot;</span><span class="s1">,</span>
            <span class="s1">location,</span>
            <span class="s1">typeSpecName,</span>
            <span class="s3">typeof </span><span class="s1">error$1</span>
          <span class="s1">);</span>

          <span class="s1">setCurrentlyValidatingElement(</span><span class="s3">null</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(</span>
          <span class="s1">error$1 </span><span class="s3">instanceof </span><span class="s1">Error &amp;&amp;</span>
          <span class="s1">!(error$1.message </span><span class="s3">in </span><span class="s1">loggedTypeFailures)</span>
        <span class="s1">) {</span>
          <span class="s0">// Only monitor this failure once because there tends to be a lot of the</span>
          <span class="s0">// same error.</span>
          <span class="s1">loggedTypeFailures[error$1.message] = </span><span class="s3">true</span><span class="s1">;</span>
          <span class="s1">setCurrentlyValidatingElement(element);</span>

          <span class="s1">error(</span><span class="s2">&quot;Failed %s type: %s&quot;</span><span class="s1">, location, error$1.message);</span>

          <span class="s1">setCurrentlyValidatingElement(</span><span class="s3">null</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">valueStack = [];</span>
<span class="s3">var </span><span class="s1">fiberStack;</span>

<span class="s1">{</span>
  <span class="s1">fiberStack = [];</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">index = -</span><span class="s4">1</span><span class="s1">;</span>

<span class="s3">function </span><span class="s1">createCursor(defaultValue) {</span>
  <span class="s3">return </span><span class="s1">{</span>
    <span class="s1">current: defaultValue</span>
  <span class="s1">};</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">pop(cursor, fiber) {</span>
  <span class="s3">if </span><span class="s1">(index &lt; </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s1">{</span>
      <span class="s1">error(</span><span class="s2">&quot;Unexpected pop.&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">return</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(fiber !== fiberStack[index]) {</span>
      <span class="s1">error(</span><span class="s2">&quot;Unexpected Fiber popped.&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">cursor.current = valueStack[index];</span>
  <span class="s1">valueStack[index] = </span><span class="s3">null</span><span class="s1">;</span>

  <span class="s1">{</span>
    <span class="s1">fiberStack[index] = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s1">index--;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">push(cursor, value, fiber) {</span>
  <span class="s1">index++;</span>
  <span class="s1">valueStack[index] = cursor.current;</span>

  <span class="s1">{</span>
    <span class="s1">fiberStack[index] = fiber;</span>
  <span class="s1">}</span>

  <span class="s1">cursor.current = value;</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">warnedAboutMissingGetChildContext;</span>

<span class="s1">{</span>
  <span class="s1">warnedAboutMissingGetChildContext = {};</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">emptyContextObject = {};</span>

<span class="s1">{</span>
  <span class="s1">Object.freeze(emptyContextObject);</span>
<span class="s1">} </span><span class="s0">// A cursor to the current merged context object on the stack.</span>

<span class="s3">var </span><span class="s1">contextStackCursor = createCursor(emptyContextObject); </span><span class="s0">// A cursor to a boolean indicating whether the context has changed.</span>

<span class="s3">var </span><span class="s1">didPerformWorkStackCursor = createCursor(</span><span class="s3">false</span><span class="s1">); </span><span class="s0">// Keep track of the previous context object that was on the stack.</span>
<span class="s0">// We use this to get access to the parent context after we have already</span>
<span class="s0">// pushed the next context provider, and now need to merge their contexts.</span>

<span class="s3">var </span><span class="s1">previousContext = emptyContextObject;</span>

<span class="s3">function </span><span class="s1">getUnmaskedContext(</span>
  <span class="s1">workInProgress,</span>
  <span class="s1">Component,</span>
  <span class="s1">didPushOwnContextIfProvider</span>
<span class="s1">) {</span>
  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(didPushOwnContextIfProvider &amp;&amp; isContextProvider(Component)) {</span>
      <span class="s0">// If the fiber is a context provider itself, when we read its context</span>
      <span class="s0">// we may have already pushed its own child context on the stack. A context</span>
      <span class="s0">// provider should not &quot;see&quot; its own child context. Therefore we read the</span>
      <span class="s0">// previous (parent) context instead for a context provider.</span>
      <span class="s3">return </span><span class="s1">previousContext;</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">contextStackCursor.current;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">cacheContext(workInProgress, unmaskedContext, maskedContext) {</span>
  <span class="s1">{</span>
    <span class="s3">var </span><span class="s1">instance = workInProgress.stateNode;</span>
    <span class="s1">instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;</span>
    <span class="s1">instance.__reactInternalMemoizedMaskedChildContext = maskedContext;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">getMaskedContext(workInProgress, unmaskedContext) {</span>
  <span class="s1">{</span>
    <span class="s3">var </span><span class="s1">type = workInProgress.type;</span>
    <span class="s3">var </span><span class="s1">contextTypes = type.contextTypes;</span>

    <span class="s3">if </span><span class="s1">(!contextTypes) {</span>
      <span class="s3">return </span><span class="s1">emptyContextObject;</span>
    <span class="s1">} </span><span class="s0">// Avoid recreating masked context unless unmasked context has changed.</span>
    <span class="s0">// Failing to do this will result in unnecessary calls to componentWillReceiveProps.</span>
    <span class="s0">// This may trigger infinite loops if componentWillReceiveProps calls setState.</span>

    <span class="s3">var </span><span class="s1">instance = workInProgress.stateNode;</span>

    <span class="s3">if </span><span class="s1">(</span>
      <span class="s1">instance &amp;&amp;</span>
      <span class="s1">instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext</span>
    <span class="s1">) {</span>
      <span class="s3">return </span><span class="s1">instance.__reactInternalMemoizedMaskedChildContext;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">context = {};</span>

    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">key </span><span class="s3">in </span><span class="s1">contextTypes) {</span>
      <span class="s1">context[key] = unmaskedContext[key];</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s3">var </span><span class="s1">name = getComponentNameFromFiber(workInProgress) || </span><span class="s2">&quot;Unknown&quot;</span><span class="s1">;</span>
      <span class="s1">checkPropTypes(contextTypes, context, </span><span class="s2">&quot;context&quot;</span><span class="s1">, name);</span>
    <span class="s1">} </span><span class="s0">// Cache unmasked context so we can avoid recreating masked context unless necessary.</span>
    <span class="s0">// Context is created before the class component is instantiated so check for instance.</span>

    <span class="s3">if </span><span class="s1">(instance) {</span>
      <span class="s1">cacheContext(workInProgress, unmaskedContext, context);</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">context;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">hasContextChanged() {</span>
  <span class="s1">{</span>
    <span class="s3">return </span><span class="s1">didPerformWorkStackCursor.current;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">isContextProvider(type) {</span>
  <span class="s1">{</span>
    <span class="s3">var </span><span class="s1">childContextTypes = type.childContextTypes;</span>
    <span class="s3">return </span><span class="s1">childContextTypes !== </span><span class="s3">null </span><span class="s1">&amp;&amp; childContextTypes !== undefined;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">popContext(fiber) {</span>
  <span class="s1">{</span>
    <span class="s1">pop(didPerformWorkStackCursor, fiber);</span>
    <span class="s1">pop(contextStackCursor, fiber);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">popTopLevelContextObject(fiber) {</span>
  <span class="s1">{</span>
    <span class="s1">pop(didPerformWorkStackCursor, fiber);</span>
    <span class="s1">pop(contextStackCursor, fiber);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">pushTopLevelContextObject(fiber, context, didChange) {</span>
  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(contextStackCursor.current !== emptyContextObject) {</span>
      <span class="s3">throw new </span><span class="s1">Error(</span>
        <span class="s2">&quot;Unexpected context found on stack. &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;This error is likely caused by a bug in React. Please file an issue.&quot;</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s1">push(contextStackCursor, context, fiber);</span>
    <span class="s1">push(didPerformWorkStackCursor, didChange, fiber);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">processChildContext(fiber, type, parentContext) {</span>
  <span class="s1">{</span>
    <span class="s3">var </span><span class="s1">instance = fiber.stateNode;</span>
    <span class="s3">var </span><span class="s1">childContextTypes = type.childContextTypes; </span><span class="s0">// TODO (bvaughn) Replace this behavior with an invariant() in the future.</span>
    <span class="s0">// It has only been added in Fiber to match the (unintentional) behavior in Stack.</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.getChildContext !== </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
      <span class="s1">{</span>
        <span class="s3">var </span><span class="s1">componentName = getComponentNameFromFiber(fiber) || </span><span class="s2">&quot;Unknown&quot;</span><span class="s1">;</span>

        <span class="s3">if </span><span class="s1">(!warnedAboutMissingGetChildContext[componentName]) {</span>
          <span class="s1">warnedAboutMissingGetChildContext[componentName] = </span><span class="s3">true</span><span class="s1">;</span>

          <span class="s1">error(</span>
            <span class="s2">&quot;%s.childContextTypes is specified but there is no getChildContext() method &quot; </span><span class="s1">+</span>
              <span class="s2">&quot;on the instance. You can either define getChildContext() on %s or remove &quot; </span><span class="s1">+</span>
              <span class="s2">&quot;childContextTypes from it.&quot;</span><span class="s1">,</span>
            <span class="s1">componentName,</span>
            <span class="s1">componentName</span>
          <span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">return </span><span class="s1">parentContext;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">childContext = instance.getChildContext();</span>

    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">contextKey </span><span class="s3">in </span><span class="s1">childContext) {</span>
      <span class="s3">if </span><span class="s1">(!(contextKey </span><span class="s3">in </span><span class="s1">childContextTypes)) {</span>
        <span class="s3">throw new </span><span class="s1">Error(</span>
          <span class="s1">(getComponentNameFromFiber(fiber) || </span><span class="s2">&quot;Unknown&quot;</span><span class="s1">) +</span>
            <span class="s2">'.getChildContext(): key &quot;' </span><span class="s1">+</span>
            <span class="s1">contextKey +</span>
            <span class="s2">'&quot; is not defined in childContextTypes.'</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s3">var </span><span class="s1">name = getComponentNameFromFiber(fiber) || </span><span class="s2">&quot;Unknown&quot;</span><span class="s1">;</span>
      <span class="s1">checkPropTypes(childContextTypes, childContext, </span><span class="s2">&quot;child context&quot;</span><span class="s1">, name);</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">assign({}, parentContext, childContext);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">pushContextProvider(workInProgress) {</span>
  <span class="s1">{</span>
    <span class="s3">var </span><span class="s1">instance = workInProgress.stateNode; </span><span class="s0">// We push the context as early as possible to ensure stack integrity.</span>
    <span class="s0">// If the instance does not exist yet, we will push null at first,</span>
    <span class="s0">// and replace it on the stack later when invalidating the context.</span>

    <span class="s3">var </span><span class="s1">memoizedMergedChildContext =</span>
      <span class="s1">(instance &amp;&amp; instance.__reactInternalMemoizedMergedChildContext) ||</span>
      <span class="s1">emptyContextObject; </span><span class="s0">// Remember the parent context so we can merge with it later.</span>
    <span class="s0">// Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.</span>

    <span class="s1">previousContext = contextStackCursor.current;</span>
    <span class="s1">push(contextStackCursor, memoizedMergedChildContext, workInProgress);</span>
    <span class="s1">push(</span>
      <span class="s1">didPerformWorkStackCursor,</span>
      <span class="s1">didPerformWorkStackCursor.current,</span>
      <span class="s1">workInProgress</span>
    <span class="s1">);</span>
    <span class="s3">return true</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">invalidateContextProvider(workInProgress, type, didChange) {</span>
  <span class="s1">{</span>
    <span class="s3">var </span><span class="s1">instance = workInProgress.stateNode;</span>

    <span class="s3">if </span><span class="s1">(!instance) {</span>
      <span class="s3">throw new </span><span class="s1">Error(</span>
        <span class="s2">&quot;Expected to have an instance by this point. &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;This error is likely caused by a bug in React. Please file an issue.&quot;</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(didChange) {</span>
      <span class="s0">// Merge parent and own context.</span>
      <span class="s0">// Skip this if we're not updating due to sCU.</span>
      <span class="s0">// This avoids unnecessarily recomputing memoized values.</span>
      <span class="s3">var </span><span class="s1">mergedContext = processChildContext(</span>
        <span class="s1">workInProgress,</span>
        <span class="s1">type,</span>
        <span class="s1">previousContext</span>
      <span class="s1">);</span>
      <span class="s1">instance.__reactInternalMemoizedMergedChildContext = mergedContext; </span><span class="s0">// Replace the old (or empty) context with the new one.</span>
      <span class="s0">// It is important to unwind the context in the reverse order.</span>

      <span class="s1">pop(didPerformWorkStackCursor, workInProgress);</span>
      <span class="s1">pop(contextStackCursor, workInProgress); </span><span class="s0">// Now push the new context and mark that it has changed.</span>

      <span class="s1">push(contextStackCursor, mergedContext, workInProgress);</span>
      <span class="s1">push(didPerformWorkStackCursor, didChange, workInProgress);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">pop(didPerformWorkStackCursor, workInProgress);</span>
      <span class="s1">push(didPerformWorkStackCursor, didChange, workInProgress);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">findCurrentUnmaskedContext(fiber) {</span>
  <span class="s1">{</span>
    <span class="s0">// Currently this is only used with renderSubtreeIntoContainer; not sure if it</span>
    <span class="s0">// makes sense elsewhere</span>
    <span class="s3">if </span><span class="s1">(!isFiberMounted(fiber) || fiber.tag !== ClassComponent) {</span>
      <span class="s3">throw new </span><span class="s1">Error(</span>
        <span class="s2">&quot;Expected subtree parent to be a mounted class component. &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;This error is likely caused by a bug in React. Please file an issue.&quot;</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">node = fiber;</span>

    <span class="s3">do </span><span class="s1">{</span>
      <span class="s3">switch </span><span class="s1">(node.tag) {</span>
        <span class="s3">case </span><span class="s1">HostRoot:</span>
          <span class="s3">return </span><span class="s1">node.stateNode.context;</span>

        <span class="s3">case </span><span class="s1">ClassComponent: {</span>
          <span class="s3">var </span><span class="s1">Component = node.type;</span>

          <span class="s3">if </span><span class="s1">(isContextProvider(Component)) {</span>
            <span class="s3">return </span><span class="s1">node.stateNode.__reactInternalMemoizedMergedChildContext;</span>
          <span class="s1">}</span>

          <span class="s3">break</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">node = node.</span><span class="s3">return</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">while </span><span class="s1">(node !== </span><span class="s3">null</span><span class="s1">);</span>

    <span class="s3">throw new </span><span class="s1">Error(</span>
      <span class="s2">&quot;Found unexpected detached subtree parent. &quot; </span><span class="s1">+</span>
        <span class="s2">&quot;This error is likely caused by a bug in React. Please file an issue.&quot;</span>
    <span class="s1">);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">LegacyRoot = </span><span class="s4">0</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">ConcurrentRoot = </span><span class="s4">1</span><span class="s1">;</span>

<span class="s0">/** 
 * inlined Object.is polyfill to avoid requiring consumers ship their own 
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is 
 */</span>
<span class="s3">function </span><span class="s1">is(x, y) {</span>
  <span class="s3">return </span><span class="s1">(</span>
    <span class="s1">(x === y &amp;&amp; (x !== </span><span class="s4">0 </span><span class="s1">|| </span><span class="s4">1 </span><span class="s1">/ x === </span><span class="s4">1 </span><span class="s1">/ y)) || (x !== x &amp;&amp; y !== y) </span><span class="s0">// eslint-disable-line no-self-compare</span>
  <span class="s1">);</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">objectIs = </span><span class="s3">typeof </span><span class="s1">Object.is === </span><span class="s2">&quot;function&quot; </span><span class="s1">? Object.is : is;</span>

<span class="s3">var </span><span class="s1">syncQueue = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">includesLegacySyncCallbacks = </span><span class="s3">false</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">isFlushingSyncQueue = </span><span class="s3">false</span><span class="s1">;</span>
<span class="s3">function </span><span class="s1">scheduleSyncCallback(callback) {</span>
  <span class="s0">// Push this callback into an internal queue. We'll flush these either in</span>
  <span class="s0">// the next tick, or earlier if something calls `flushSyncCallbackQueue`.</span>
  <span class="s3">if </span><span class="s1">(syncQueue === </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s1">syncQueue = [callback];</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s0">// Push onto existing queue. Don't need to schedule a callback because</span>
    <span class="s0">// we already scheduled one when we created the queue.</span>
    <span class="s1">syncQueue.push(callback);</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">scheduleLegacySyncCallback(callback) {</span>
  <span class="s1">includesLegacySyncCallbacks = </span><span class="s3">true</span><span class="s1">;</span>
  <span class="s1">scheduleSyncCallback(callback);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">flushSyncCallbacksOnlyInLegacyMode() {</span>
  <span class="s0">// Only flushes the queue if there's a legacy sync callback scheduled.</span>
  <span class="s0">// TODO: There's only a single type of callback: performSyncOnWorkOnRoot. So</span>
  <span class="s0">// it might make more sense for the queue to be a list of roots instead of a</span>
  <span class="s0">// list of generic callbacks. Then we can have two: one for legacy roots, one</span>
  <span class="s0">// for concurrent roots. And this method would only flush the legacy ones.</span>
  <span class="s3">if </span><span class="s1">(includesLegacySyncCallbacks) {</span>
    <span class="s1">flushSyncCallbacks();</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">flushSyncCallbacks() {</span>
  <span class="s3">if </span><span class="s1">(!isFlushingSyncQueue &amp;&amp; syncQueue !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s0">// Prevent re-entrance.</span>
    <span class="s1">isFlushingSyncQueue = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">previousUpdatePriority = getCurrentUpdatePriority();</span>

    <span class="s3">try </span><span class="s1">{</span>
      <span class="s3">var </span><span class="s1">isSync = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s3">var </span><span class="s1">queue = syncQueue; </span><span class="s0">// TODO: Is this necessary anymore? The only user code that runs in this</span>
      <span class="s0">// queue is in the render or commit phases.</span>

      <span class="s1">setCurrentUpdatePriority(DiscreteEventPriority);</span>

      <span class="s3">for </span><span class="s1">(; i &lt; queue.length; i++) {</span>
        <span class="s3">var </span><span class="s1">callback = queue[i];</span>

        <span class="s3">do </span><span class="s1">{</span>
          <span class="s1">callback = callback(isSync);</span>
        <span class="s1">} </span><span class="s3">while </span><span class="s1">(callback !== </span><span class="s3">null</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s1">syncQueue = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">includesLegacySyncCallbacks = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
      <span class="s0">// If something throws, leave the remaining callbacks on the queue.</span>
      <span class="s3">if </span><span class="s1">(syncQueue !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">syncQueue = syncQueue.slice(i + </span><span class="s4">1</span><span class="s1">);</span>
      <span class="s1">} </span><span class="s0">// Resume flushing in the next tick</span>

      <span class="s1">scheduleCallback(ImmediatePriority, flushSyncCallbacks);</span>
      <span class="s3">throw </span><span class="s1">error;</span>
    <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
      <span class="s1">setCurrentUpdatePriority(previousUpdatePriority);</span>
      <span class="s1">isFlushingSyncQueue = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">return null</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">// This is imported by the event replaying implementation in React DOM. It's</span>
<span class="s0">// in a separate file to break a circular dependency between the renderer and</span>
<span class="s0">// the reconciler.</span>
<span class="s3">function </span><span class="s1">isRootDehydrated(root) {</span>
  <span class="s3">var </span><span class="s1">currentState = root.current.memoizedState;</span>
  <span class="s3">return </span><span class="s1">currentState.isDehydrated;</span>
<span class="s1">}</span>

<span class="s0">// TODO: Use the unified fiber stack module instead of this local one?</span>
<span class="s0">// Intentionally not using it yet to derisk the initial implementation, because</span>
<span class="s0">// the way we push/pop these values is a bit unusual. If there's a mistake, I'd</span>
<span class="s0">// rather the ids be wrong than crash the whole reconciler.</span>
<span class="s3">var </span><span class="s1">forkStack = [];</span>
<span class="s3">var </span><span class="s1">forkStackIndex = </span><span class="s4">0</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">treeForkProvider = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">treeForkCount = </span><span class="s4">0</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">idStack = [];</span>
<span class="s3">var </span><span class="s1">idStackIndex = </span><span class="s4">0</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">treeContextProvider = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">treeContextId = </span><span class="s4">1</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">treeContextOverflow = </span><span class="s2">&quot;&quot;</span><span class="s1">;</span>

<span class="s3">function </span><span class="s1">popTreeContext(workInProgress) {</span>
  <span class="s0">// Restore the previous values.</span>
  <span class="s0">// This is a bit more complicated than other context-like modules in Fiber</span>
  <span class="s0">// because the same Fiber may appear on the stack multiple times and for</span>
  <span class="s0">// different reasons. We have to keep popping until the work-in-progress is</span>
  <span class="s0">// no longer at the top of the stack.</span>
  <span class="s3">while </span><span class="s1">(workInProgress === treeForkProvider) {</span>
    <span class="s1">treeForkProvider = forkStack[--forkStackIndex];</span>
    <span class="s1">forkStack[forkStackIndex] = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">treeForkCount = forkStack[--forkStackIndex];</span>
    <span class="s1">forkStack[forkStackIndex] = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">while </span><span class="s1">(workInProgress === treeContextProvider) {</span>
    <span class="s1">treeContextProvider = idStack[--idStackIndex];</span>
    <span class="s1">idStack[idStackIndex] = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">treeContextOverflow = idStack[--idStackIndex];</span>
    <span class="s1">idStack[idStackIndex] = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">treeContextId = idStack[--idStackIndex];</span>
    <span class="s1">idStack[idStackIndex] = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">isHydrating = </span><span class="s3">false</span><span class="s1">; </span><span class="s0">// This flag allows for warning supression when we expect there to be mismatches</span>
<span class="s0">// due to earlier mismatches or a suspended fiber.</span>

<span class="s3">var </span><span class="s1">didSuspendOrErrorDEV = </span><span class="s3">false</span><span class="s1">; </span><span class="s0">// Hydration errors that were thrown inside this boundary</span>

<span class="s3">var </span><span class="s1">hydrationErrors = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s3">function </span><span class="s1">didSuspendOrErrorWhileHydratingDEV() {</span>
  <span class="s1">{</span>
    <span class="s3">return </span><span class="s1">didSuspendOrErrorDEV;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">reenterHydrationStateFromDehydratedSuspenseInstance(</span>
  <span class="s1">fiber,</span>
  <span class="s1">suspenseInstance,</span>
  <span class="s1">treeContext</span>
<span class="s1">) {</span>
  <span class="s1">{</span>
    <span class="s3">return false</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">prepareToHydrateHostInstance(</span>
  <span class="s1">fiber,</span>
  <span class="s1">rootContainerInstance,</span>
  <span class="s1">hostContext</span>
<span class="s1">) {</span>
  <span class="s1">{</span>
    <span class="s3">throw new </span><span class="s1">Error(</span>
      <span class="s2">&quot;Expected prepareToHydrateHostInstance() to never be called. &quot; </span><span class="s1">+</span>
        <span class="s2">&quot;This error is likely caused by a bug in React. Please file an issue.&quot;</span>
    <span class="s1">);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">prepareToHydrateHostTextInstance(fiber) {</span>
  <span class="s1">{</span>
    <span class="s3">throw new </span><span class="s1">Error(</span>
      <span class="s2">&quot;Expected prepareToHydrateHostTextInstance() to never be called. &quot; </span><span class="s1">+</span>
        <span class="s2">&quot;This error is likely caused by a bug in React. Please file an issue.&quot;</span>
    <span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s3">var </span><span class="s1">shouldUpdate = hydrateTextInstance();</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">prepareToHydrateHostSuspenseInstance(fiber) {</span>
  <span class="s1">{</span>
    <span class="s3">throw new </span><span class="s1">Error(</span>
      <span class="s2">&quot;Expected prepareToHydrateHostSuspenseInstance() to never be called. &quot; </span><span class="s1">+</span>
        <span class="s2">&quot;This error is likely caused by a bug in React. Please file an issue.&quot;</span>
    <span class="s1">);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">popHydrationState(fiber) {</span>
  <span class="s1">{</span>
    <span class="s3">return false</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">upgradeHydrationErrorsToRecoverable() {</span>
  <span class="s3">if </span><span class="s1">(hydrationErrors !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s0">// Successfully completed a forced client render. The errors that occurred</span>
    <span class="s0">// during the hydration attempt are now recovered. We will log them in</span>
    <span class="s0">// commit phase, once the entire tree has finished.</span>
    <span class="s1">queueRecoverableErrors(hydrationErrors);</span>
    <span class="s1">hydrationErrors = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">getIsHydrating() {</span>
  <span class="s3">return </span><span class="s1">isHydrating;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">queueHydrationError(error) {</span>
  <span class="s3">if </span><span class="s1">(hydrationErrors === </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s1">hydrationErrors = [error];</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">hydrationErrors.push(error);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig;</span>
<span class="s3">var </span><span class="s1">NoTransition = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s3">function </span><span class="s1">requestCurrentTransition() {</span>
  <span class="s3">return </span><span class="s1">ReactCurrentBatchConfig.transition;</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Performs equality by iterating through keys on an object and returning false 
 * when any key has values which are not strictly equal between the arguments. 
 * Returns true when the values of all keys are strictly equal. 
 */</span>

<span class="s3">function </span><span class="s1">shallowEqual(objA, objB) {</span>
  <span class="s3">if </span><span class="s1">(objectIs(objA, objB)) {</span>
    <span class="s3">return true</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(</span>
    <span class="s3">typeof </span><span class="s1">objA !== </span><span class="s2">&quot;object&quot; </span><span class="s1">||</span>
    <span class="s1">objA === </span><span class="s3">null </span><span class="s1">||</span>
    <span class="s3">typeof </span><span class="s1">objB !== </span><span class="s2">&quot;object&quot; </span><span class="s1">||</span>
    <span class="s1">objB === </span><span class="s3">null</span>
  <span class="s1">) {</span>
    <span class="s3">return false</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">keysA = Object.keys(objA);</span>
  <span class="s3">var </span><span class="s1">keysB = Object.keys(objB);</span>

  <span class="s3">if </span><span class="s1">(keysA.length !== keysB.length) {</span>
    <span class="s3">return false</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s0">// Test for A's keys different from B.</span>

  <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; keysA.length; i++) {</span>
    <span class="s3">var </span><span class="s1">currentKey = keysA[i];</span>

    <span class="s3">if </span><span class="s1">(</span>
      <span class="s1">!hasOwnProperty.call(objB, currentKey) ||</span>
      <span class="s1">!objectIs(objA[currentKey], objB[currentKey])</span>
    <span class="s1">) {</span>
      <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">return true</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">describeFiber(fiber) {</span>
  <span class="s3">var </span><span class="s1">owner = fiber._debugOwner ? fiber._debugOwner.type : </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">source = fiber._debugSource;</span>

  <span class="s3">switch </span><span class="s1">(fiber.tag) {</span>
    <span class="s3">case </span><span class="s1">HostComponent:</span>
      <span class="s3">return </span><span class="s1">describeBuiltInComponentFrame(fiber.type, source, owner);</span>

    <span class="s3">case </span><span class="s1">LazyComponent:</span>
      <span class="s3">return </span><span class="s1">describeBuiltInComponentFrame(</span><span class="s2">&quot;Lazy&quot;</span><span class="s1">, source, owner);</span>

    <span class="s3">case </span><span class="s1">SuspenseComponent:</span>
      <span class="s3">return </span><span class="s1">describeBuiltInComponentFrame(</span><span class="s2">&quot;Suspense&quot;</span><span class="s1">, source, owner);</span>

    <span class="s3">case </span><span class="s1">SuspenseListComponent:</span>
      <span class="s3">return </span><span class="s1">describeBuiltInComponentFrame(</span><span class="s2">&quot;SuspenseList&quot;</span><span class="s1">, source, owner);</span>

    <span class="s3">case </span><span class="s1">FunctionComponent:</span>
    <span class="s3">case </span><span class="s1">IndeterminateComponent:</span>
    <span class="s3">case </span><span class="s1">SimpleMemoComponent:</span>
      <span class="s3">return </span><span class="s1">describeFunctionComponentFrame(fiber.type, source, owner);</span>

    <span class="s3">case </span><span class="s1">ForwardRef:</span>
      <span class="s3">return </span><span class="s1">describeFunctionComponentFrame(fiber.type.render, source, owner);</span>

    <span class="s3">case </span><span class="s1">ClassComponent:</span>
      <span class="s3">return </span><span class="s1">describeClassComponentFrame(fiber.type, source, owner);</span>

    <span class="s3">default</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s2">&quot;&quot;</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">getStackByFiberInDevAndProd(workInProgress) {</span>
  <span class="s3">try </span><span class="s1">{</span>
    <span class="s3">var </span><span class="s1">info = </span><span class="s2">&quot;&quot;</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">node = workInProgress;</span>

    <span class="s3">do </span><span class="s1">{</span>
      <span class="s1">info += describeFiber(node);</span>
      <span class="s1">node = node.</span><span class="s3">return</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">while </span><span class="s1">(node);</span>

    <span class="s3">return </span><span class="s1">info;</span>
  <span class="s1">} </span><span class="s3">catch </span><span class="s1">(x) {</span>
    <span class="s3">return </span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">Error generating stack: &quot; </span><span class="s1">+ x.message + </span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot; </span><span class="s1">+ x.stack;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;</span>
<span class="s3">var </span><span class="s1">current = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">isRendering = </span><span class="s3">false</span><span class="s1">;</span>
<span class="s3">function </span><span class="s1">getCurrentFiberOwnerNameInDevOrNull() {</span>
  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(current === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">owner = current._debugOwner;</span>

    <span class="s3">if </span><span class="s1">(owner !== </span><span class="s3">null </span><span class="s1">&amp;&amp; </span><span class="s3">typeof </span><span class="s1">owner !== </span><span class="s2">&quot;undefined&quot;</span><span class="s1">) {</span>
      <span class="s3">return </span><span class="s1">getComponentNameFromFiber(owner);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">return null</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">getCurrentFiberStackInDev() {</span>
  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(current === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">return </span><span class="s2">&quot;&quot;</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s0">// Safe because if current fiber exists, we are reconciling,</span>
    <span class="s0">// and it is guaranteed to be the work-in-progress version.</span>

    <span class="s3">return </span><span class="s1">getStackByFiberInDevAndProd(current);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">resetCurrentFiber() {</span>
  <span class="s1">{</span>
    <span class="s1">ReactDebugCurrentFrame$1.getCurrentStack = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">current = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">isRendering = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">setCurrentFiber(fiber) {</span>
  <span class="s1">{</span>
    <span class="s1">ReactDebugCurrentFrame$1.getCurrentStack =</span>
      <span class="s1">fiber === </span><span class="s3">null </span><span class="s1">? </span><span class="s3">null </span><span class="s1">: getCurrentFiberStackInDev;</span>
    <span class="s1">current = fiber;</span>
    <span class="s1">isRendering = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">getCurrentFiber() {</span>
  <span class="s1">{</span>
    <span class="s3">return </span><span class="s1">current;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">setIsRendering(rendering) {</span>
  <span class="s1">{</span>
    <span class="s1">isRendering = rendering;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">ReactStrictModeWarnings = {</span>
  <span class="s1">recordUnsafeLifecycleWarnings: </span><span class="s3">function</span><span class="s1">(fiber, instance) {},</span>
  <span class="s1">flushPendingUnsafeLifecycleWarnings: </span><span class="s3">function</span><span class="s1">() {},</span>
  <span class="s1">recordLegacyContextWarning: </span><span class="s3">function</span><span class="s1">(fiber, instance) {},</span>
  <span class="s1">flushLegacyContextWarning: </span><span class="s3">function</span><span class="s1">() {},</span>
  <span class="s1">discardPendingWarnings: </span><span class="s3">function</span><span class="s1">() {}</span>
<span class="s1">};</span>

<span class="s1">{</span>
  <span class="s3">var </span><span class="s1">findStrictRoot = </span><span class="s3">function</span><span class="s1">(fiber) {</span>
    <span class="s3">var </span><span class="s1">maybeStrictRoot = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">node = fiber;</span>

    <span class="s3">while </span><span class="s1">(node !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(node.mode &amp; StrictLegacyMode) {</span>
        <span class="s1">maybeStrictRoot = node;</span>
      <span class="s1">}</span>

      <span class="s1">node = node.</span><span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">maybeStrictRoot;</span>
  <span class="s1">};</span>

  <span class="s3">var </span><span class="s1">setToSortedString = </span><span class="s3">function</span><span class="s1">(set) {</span>
    <span class="s3">var </span><span class="s1">array = [];</span>
    <span class="s1">set.forEach(</span><span class="s3">function</span><span class="s1">(value) {</span>
      <span class="s1">array.push(value);</span>
    <span class="s1">});</span>
    <span class="s3">return </span><span class="s1">array.sort().join(</span><span class="s2">&quot;, &quot;</span><span class="s1">);</span>
  <span class="s1">};</span>

  <span class="s3">var </span><span class="s1">pendingComponentWillMountWarnings = [];</span>
  <span class="s3">var </span><span class="s1">pendingUNSAFE_ComponentWillMountWarnings = [];</span>
  <span class="s3">var </span><span class="s1">pendingComponentWillReceivePropsWarnings = [];</span>
  <span class="s3">var </span><span class="s1">pendingUNSAFE_ComponentWillReceivePropsWarnings = [];</span>
  <span class="s3">var </span><span class="s1">pendingComponentWillUpdateWarnings = [];</span>
  <span class="s3">var </span><span class="s1">pendingUNSAFE_ComponentWillUpdateWarnings = []; </span><span class="s0">// Tracks components we have already warned about.</span>

  <span class="s3">var </span><span class="s1">didWarnAboutUnsafeLifecycles = </span><span class="s3">new </span><span class="s1">Set();</span>

  <span class="s1">ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = </span><span class="s3">function</span><span class="s1">(</span>
    <span class="s1">fiber,</span>
    <span class="s1">instance</span>
  <span class="s1">) {</span>
    <span class="s0">// Dedupe strategy: Warn once per component.</span>
    <span class="s3">if </span><span class="s1">(didWarnAboutUnsafeLifecycles.has(fiber.type)) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span>
      <span class="s3">typeof </span><span class="s1">instance.componentWillMount === </span><span class="s2">&quot;function&quot; </span><span class="s1">&amp;&amp; </span><span class="s0">// Don't warn about react-lifecycles-compat polyfilled components.</span>
      <span class="s1">instance.componentWillMount.__suppressDeprecationWarning !== </span><span class="s3">true</span>
    <span class="s1">) {</span>
      <span class="s1">pendingComponentWillMountWarnings.push(fiber);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span>
      <span class="s1">fiber.mode &amp; StrictLegacyMode &amp;&amp;</span>
      <span class="s3">typeof </span><span class="s1">instance.UNSAFE_componentWillMount === </span><span class="s2">&quot;function&quot;</span>
    <span class="s1">) {</span>
      <span class="s1">pendingUNSAFE_ComponentWillMountWarnings.push(fiber);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span>
      <span class="s3">typeof </span><span class="s1">instance.componentWillReceiveProps === </span><span class="s2">&quot;function&quot; </span><span class="s1">&amp;&amp;</span>
      <span class="s1">instance.componentWillReceiveProps.__suppressDeprecationWarning !== </span><span class="s3">true</span>
    <span class="s1">) {</span>
      <span class="s1">pendingComponentWillReceivePropsWarnings.push(fiber);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span>
      <span class="s1">fiber.mode &amp; StrictLegacyMode &amp;&amp;</span>
      <span class="s3">typeof </span><span class="s1">instance.UNSAFE_componentWillReceiveProps === </span><span class="s2">&quot;function&quot;</span>
    <span class="s1">) {</span>
      <span class="s1">pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span>
      <span class="s3">typeof </span><span class="s1">instance.componentWillUpdate === </span><span class="s2">&quot;function&quot; </span><span class="s1">&amp;&amp;</span>
      <span class="s1">instance.componentWillUpdate.__suppressDeprecationWarning !== </span><span class="s3">true</span>
    <span class="s1">) {</span>
      <span class="s1">pendingComponentWillUpdateWarnings.push(fiber);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span>
      <span class="s1">fiber.mode &amp; StrictLegacyMode &amp;&amp;</span>
      <span class="s3">typeof </span><span class="s1">instance.UNSAFE_componentWillUpdate === </span><span class="s2">&quot;function&quot;</span>
    <span class="s1">) {</span>
      <span class="s1">pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s1">ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = </span><span class="s3">function</span><span class="s1">() {</span>
    <span class="s0">// We do an initial pass to gather component names</span>
    <span class="s3">var </span><span class="s1">componentWillMountUniqueNames = </span><span class="s3">new </span><span class="s1">Set();</span>

    <span class="s3">if </span><span class="s1">(pendingComponentWillMountWarnings.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s1">pendingComponentWillMountWarnings.forEach(</span><span class="s3">function</span><span class="s1">(fiber) {</span>
        <span class="s1">componentWillMountUniqueNames.add(</span>
          <span class="s1">getComponentNameFromFiber(fiber) || </span><span class="s2">&quot;Component&quot;</span>
        <span class="s1">);</span>
        <span class="s1">didWarnAboutUnsafeLifecycles.add(fiber.type);</span>
      <span class="s1">});</span>
      <span class="s1">pendingComponentWillMountWarnings = [];</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">UNSAFE_componentWillMountUniqueNames = </span><span class="s3">new </span><span class="s1">Set();</span>

    <span class="s3">if </span><span class="s1">(pendingUNSAFE_ComponentWillMountWarnings.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s1">pendingUNSAFE_ComponentWillMountWarnings.forEach(</span><span class="s3">function</span><span class="s1">(fiber) {</span>
        <span class="s1">UNSAFE_componentWillMountUniqueNames.add(</span>
          <span class="s1">getComponentNameFromFiber(fiber) || </span><span class="s2">&quot;Component&quot;</span>
        <span class="s1">);</span>
        <span class="s1">didWarnAboutUnsafeLifecycles.add(fiber.type);</span>
      <span class="s1">});</span>
      <span class="s1">pendingUNSAFE_ComponentWillMountWarnings = [];</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">componentWillReceivePropsUniqueNames = </span><span class="s3">new </span><span class="s1">Set();</span>

    <span class="s3">if </span><span class="s1">(pendingComponentWillReceivePropsWarnings.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s1">pendingComponentWillReceivePropsWarnings.forEach(</span><span class="s3">function</span><span class="s1">(fiber) {</span>
        <span class="s1">componentWillReceivePropsUniqueNames.add(</span>
          <span class="s1">getComponentNameFromFiber(fiber) || </span><span class="s2">&quot;Component&quot;</span>
        <span class="s1">);</span>
        <span class="s1">didWarnAboutUnsafeLifecycles.add(fiber.type);</span>
      <span class="s1">});</span>
      <span class="s1">pendingComponentWillReceivePropsWarnings = [];</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">UNSAFE_componentWillReceivePropsUniqueNames = </span><span class="s3">new </span><span class="s1">Set();</span>

    <span class="s3">if </span><span class="s1">(pendingUNSAFE_ComponentWillReceivePropsWarnings.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s1">pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(</span><span class="s3">function</span><span class="s1">(fiber) {</span>
        <span class="s1">UNSAFE_componentWillReceivePropsUniqueNames.add(</span>
          <span class="s1">getComponentNameFromFiber(fiber) || </span><span class="s2">&quot;Component&quot;</span>
        <span class="s1">);</span>
        <span class="s1">didWarnAboutUnsafeLifecycles.add(fiber.type);</span>
      <span class="s1">});</span>
      <span class="s1">pendingUNSAFE_ComponentWillReceivePropsWarnings = [];</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">componentWillUpdateUniqueNames = </span><span class="s3">new </span><span class="s1">Set();</span>

    <span class="s3">if </span><span class="s1">(pendingComponentWillUpdateWarnings.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s1">pendingComponentWillUpdateWarnings.forEach(</span><span class="s3">function</span><span class="s1">(fiber) {</span>
        <span class="s1">componentWillUpdateUniqueNames.add(</span>
          <span class="s1">getComponentNameFromFiber(fiber) || </span><span class="s2">&quot;Component&quot;</span>
        <span class="s1">);</span>
        <span class="s1">didWarnAboutUnsafeLifecycles.add(fiber.type);</span>
      <span class="s1">});</span>
      <span class="s1">pendingComponentWillUpdateWarnings = [];</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">UNSAFE_componentWillUpdateUniqueNames = </span><span class="s3">new </span><span class="s1">Set();</span>

    <span class="s3">if </span><span class="s1">(pendingUNSAFE_ComponentWillUpdateWarnings.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s1">pendingUNSAFE_ComponentWillUpdateWarnings.forEach(</span><span class="s3">function</span><span class="s1">(fiber) {</span>
        <span class="s1">UNSAFE_componentWillUpdateUniqueNames.add(</span>
          <span class="s1">getComponentNameFromFiber(fiber) || </span><span class="s2">&quot;Component&quot;</span>
        <span class="s1">);</span>
        <span class="s1">didWarnAboutUnsafeLifecycles.add(fiber.type);</span>
      <span class="s1">});</span>
      <span class="s1">pendingUNSAFE_ComponentWillUpdateWarnings = [];</span>
    <span class="s1">} </span><span class="s0">// Finally, we flush all the warnings</span>
    <span class="s0">// UNSAFE_ ones before the deprecated ones, since they'll be 'louder'</span>

    <span class="s3">if </span><span class="s1">(UNSAFE_componentWillMountUniqueNames.size &gt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);</span>

      <span class="s1">error(</span>
        <span class="s2">&quot;Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;See https://reactjs.org/link/unsafe-component-lifecycles for details.</span><span class="s5">\n\n</span><span class="s2">&quot; </span><span class="s1">+</span>
          <span class="s2">&quot;* Move code with side effects to componentDidMount, and set initial state in the constructor.</span><span class="s5">\n</span><span class="s2">&quot; </span><span class="s1">+</span>
          <span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">Please update the following components: %s&quot;</span><span class="s1">,</span>
        <span class="s1">sortedNames</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(UNSAFE_componentWillReceivePropsUniqueNames.size &gt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">_sortedNames = setToSortedString(</span>
        <span class="s1">UNSAFE_componentWillReceivePropsUniqueNames</span>
      <span class="s1">);</span>

      <span class="s1">error(</span>
        <span class="s2">&quot;Using UNSAFE_componentWillReceiveProps in strict mode is not recommended &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;and may indicate bugs in your code. &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;See https://reactjs.org/link/unsafe-component-lifecycles for details.</span><span class="s5">\n\n</span><span class="s2">&quot; </span><span class="s1">+</span>
          <span class="s2">&quot;* Move data fetching code or side effects to componentDidUpdate.</span><span class="s5">\n</span><span class="s2">&quot; </span><span class="s1">+</span>
          <span class="s2">&quot;* If you're updating state whenever props change, &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;refactor your code to use memoization techniques or move it to &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state</span><span class="s5">\n</span><span class="s2">&quot; </span><span class="s1">+</span>
          <span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">Please update the following components: %s&quot;</span><span class="s1">,</span>
        <span class="s1">_sortedNames</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(UNSAFE_componentWillUpdateUniqueNames.size &gt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">_sortedNames2 = setToSortedString(</span>
        <span class="s1">UNSAFE_componentWillUpdateUniqueNames</span>
      <span class="s1">);</span>

      <span class="s1">error(</span>
        <span class="s2">&quot;Using UNSAFE_componentWillUpdate in strict mode is not recommended &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;and may indicate bugs in your code. &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;See https://reactjs.org/link/unsafe-component-lifecycles for details.</span><span class="s5">\n\n</span><span class="s2">&quot; </span><span class="s1">+</span>
          <span class="s2">&quot;* Move data fetching code or side effects to componentDidUpdate.</span><span class="s5">\n</span><span class="s2">&quot; </span><span class="s1">+</span>
          <span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">Please update the following components: %s&quot;</span><span class="s1">,</span>
        <span class="s1">_sortedNames2</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(componentWillMountUniqueNames.size &gt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">_sortedNames3 = setToSortedString(componentWillMountUniqueNames);</span>

      <span class="s1">warn(</span>
        <span class="s2">&quot;componentWillMount has been renamed, and is not recommended for use. &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;See https://reactjs.org/link/unsafe-component-lifecycles for details.</span><span class="s5">\n\n</span><span class="s2">&quot; </span><span class="s1">+</span>
          <span class="s2">&quot;* Move code with side effects to componentDidMount, and set initial state in the constructor.</span><span class="s5">\n</span><span class="s2">&quot; </span><span class="s1">+</span>
          <span class="s2">&quot;* Rename componentWillMount to UNSAFE_componentWillMount to suppress &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;To rename all deprecated lifecycles to their new names, you can run &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;`npx react-codemod rename-unsafe-lifecycles` in your project source folder.</span><span class="s5">\n</span><span class="s2">&quot; </span><span class="s1">+</span>
          <span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">Please update the following components: %s&quot;</span><span class="s1">,</span>
        <span class="s1">_sortedNames3</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(componentWillReceivePropsUniqueNames.size &gt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">_sortedNames4 = setToSortedString(</span>
        <span class="s1">componentWillReceivePropsUniqueNames</span>
      <span class="s1">);</span>

      <span class="s1">warn(</span>
        <span class="s2">&quot;componentWillReceiveProps has been renamed, and is not recommended for use. &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;See https://reactjs.org/link/unsafe-component-lifecycles for details.</span><span class="s5">\n\n</span><span class="s2">&quot; </span><span class="s1">+</span>
          <span class="s2">&quot;* Move data fetching code or side effects to componentDidUpdate.</span><span class="s5">\n</span><span class="s2">&quot; </span><span class="s1">+</span>
          <span class="s2">&quot;* If you're updating state whenever props change, refactor your &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;code to use memoization techniques or move it to &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state</span><span class="s5">\n</span><span class="s2">&quot; </span><span class="s1">+</span>
          <span class="s2">&quot;* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;To rename all deprecated lifecycles to their new names, you can run &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;`npx react-codemod rename-unsafe-lifecycles` in your project source folder.</span><span class="s5">\n</span><span class="s2">&quot; </span><span class="s1">+</span>
          <span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">Please update the following components: %s&quot;</span><span class="s1">,</span>
        <span class="s1">_sortedNames4</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(componentWillUpdateUniqueNames.size &gt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">_sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);</span>

      <span class="s1">warn(</span>
        <span class="s2">&quot;componentWillUpdate has been renamed, and is not recommended for use. &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;See https://reactjs.org/link/unsafe-component-lifecycles for details.</span><span class="s5">\n\n</span><span class="s2">&quot; </span><span class="s1">+</span>
          <span class="s2">&quot;* Move data fetching code or side effects to componentDidUpdate.</span><span class="s5">\n</span><span class="s2">&quot; </span><span class="s1">+</span>
          <span class="s2">&quot;* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;To rename all deprecated lifecycles to their new names, you can run &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;`npx react-codemod rename-unsafe-lifecycles` in your project source folder.</span><span class="s5">\n</span><span class="s2">&quot; </span><span class="s1">+</span>
          <span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">Please update the following components: %s&quot;</span><span class="s1">,</span>
        <span class="s1">_sortedNames5</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s3">var </span><span class="s1">pendingLegacyContextWarning = </span><span class="s3">new </span><span class="s1">Map(); </span><span class="s0">// Tracks components we have already warned about.</span>

  <span class="s3">var </span><span class="s1">didWarnAboutLegacyContext = </span><span class="s3">new </span><span class="s1">Set();</span>

  <span class="s1">ReactStrictModeWarnings.recordLegacyContextWarning = </span><span class="s3">function</span><span class="s1">(</span>
    <span class="s1">fiber,</span>
    <span class="s1">instance</span>
  <span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">strictRoot = findStrictRoot(fiber);</span>

    <span class="s3">if </span><span class="s1">(strictRoot === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">error(</span>
        <span class="s2">&quot;Expected to find a StrictMode component in a strict mode tree. &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;This error is likely caused by a bug in React. Please file an issue.&quot;</span>
      <span class="s1">);</span>

      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s0">// Dedup strategy: Warn once per component.</span>

    <span class="s3">if </span><span class="s1">(didWarnAboutLegacyContext.has(fiber.type)) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">warningsForRoot = pendingLegacyContextWarning.get(strictRoot);</span>

    <span class="s3">if </span><span class="s1">(</span>
      <span class="s1">fiber.type.contextTypes != </span><span class="s3">null </span><span class="s1">||</span>
      <span class="s1">fiber.type.childContextTypes != </span><span class="s3">null </span><span class="s1">||</span>
      <span class="s1">(instance !== </span><span class="s3">null </span><span class="s1">&amp;&amp; </span><span class="s3">typeof </span><span class="s1">instance.getChildContext === </span><span class="s2">&quot;function&quot;</span><span class="s1">)</span>
    <span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(warningsForRoot === undefined) {</span>
        <span class="s1">warningsForRoot = [];</span>
        <span class="s1">pendingLegacyContextWarning.set(strictRoot, warningsForRoot);</span>
      <span class="s1">}</span>

      <span class="s1">warningsForRoot.push(fiber);</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s1">ReactStrictModeWarnings.flushLegacyContextWarning = </span><span class="s3">function</span><span class="s1">() {</span>
    <span class="s1">pendingLegacyContextWarning.forEach(</span><span class="s3">function</span><span class="s1">(fiberArray, strictRoot) {</span>
      <span class="s3">if </span><span class="s1">(fiberArray.length === </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">firstFiber = fiberArray[</span><span class="s4">0</span><span class="s1">];</span>
      <span class="s3">var </span><span class="s1">uniqueNames = </span><span class="s3">new </span><span class="s1">Set();</span>
      <span class="s1">fiberArray.forEach(</span><span class="s3">function</span><span class="s1">(fiber) {</span>
        <span class="s1">uniqueNames.add(getComponentNameFromFiber(fiber) || </span><span class="s2">&quot;Component&quot;</span><span class="s1">);</span>
        <span class="s1">didWarnAboutLegacyContext.add(fiber.type);</span>
      <span class="s1">});</span>
      <span class="s3">var </span><span class="s1">sortedNames = setToSortedString(uniqueNames);</span>

      <span class="s3">try </span><span class="s1">{</span>
        <span class="s1">setCurrentFiber(firstFiber);</span>

        <span class="s1">error(</span>
          <span class="s2">&quot;Legacy context API has been detected within a strict-mode tree.&quot; </span><span class="s1">+</span>
            <span class="s2">&quot;</span><span class="s5">\n\n</span><span class="s2">The old API will be supported in all 16.x releases, but applications &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;using it should migrate to the new version.&quot; </span><span class="s1">+</span>
            <span class="s2">&quot;</span><span class="s5">\n\n</span><span class="s2">Please update the following components: %s&quot; </span><span class="s1">+</span>
            <span class="s2">&quot;</span><span class="s5">\n\n</span><span class="s2">Learn more about this warning here: https://reactjs.org/link/legacy-context&quot;</span><span class="s1">,</span>
          <span class="s1">sortedNames</span>
        <span class="s1">);</span>
      <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
        <span class="s1">resetCurrentFiber();</span>
      <span class="s1">}</span>
    <span class="s1">});</span>
  <span class="s1">};</span>

  <span class="s1">ReactStrictModeWarnings.discardPendingWarnings = </span><span class="s3">function</span><span class="s1">() {</span>
    <span class="s1">pendingComponentWillMountWarnings = [];</span>
    <span class="s1">pendingUNSAFE_ComponentWillMountWarnings = [];</span>
    <span class="s1">pendingComponentWillReceivePropsWarnings = [];</span>
    <span class="s1">pendingUNSAFE_ComponentWillReceivePropsWarnings = [];</span>
    <span class="s1">pendingComponentWillUpdateWarnings = [];</span>
    <span class="s1">pendingUNSAFE_ComponentWillUpdateWarnings = [];</span>
    <span class="s1">pendingLegacyContextWarning = </span><span class="s3">new </span><span class="s1">Map();</span>
  <span class="s1">};</span>
<span class="s1">}</span>

<span class="s0">/* 
 * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol 
 * and Temporal.* types. See https://github.com/facebook/react/pull/22064. 
 * 
 * The functions in this module will throw an easier-to-understand, 
 * easier-to-debug exception with a clear errors message message explaining the 
 * problem. (Instead of a confusing exception thrown inside the implementation 
 * of the `value` object). 
 */</span>
<span class="s0">// $FlowFixMe only called in DEV, so void return is not possible.</span>
<span class="s3">function </span><span class="s1">typeName(value) {</span>
  <span class="s1">{</span>
    <span class="s0">// toStringTag is needed for namespaced types like Temporal.Instant</span>
    <span class="s3">var </span><span class="s1">hasToStringTag = </span><span class="s3">typeof </span><span class="s1">Symbol === </span><span class="s2">&quot;function&quot; </span><span class="s1">&amp;&amp; Symbol.toStringTag;</span>
    <span class="s3">var </span><span class="s1">type =</span>
      <span class="s1">(hasToStringTag &amp;&amp; value[Symbol.toStringTag]) ||</span>
      <span class="s1">value.constructor.name ||</span>
      <span class="s2">&quot;Object&quot;</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s1">type;</span>
  <span class="s1">}</span>
<span class="s1">} </span><span class="s0">// $FlowFixMe only called in DEV, so void return is not possible.</span>

<span class="s3">function </span><span class="s1">willCoercionThrow(value) {</span>
  <span class="s1">{</span>
    <span class="s3">try </span><span class="s1">{</span>
      <span class="s1">testStringCoercion(value);</span>
      <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">catch </span><span class="s1">(e) {</span>
      <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">testStringCoercion(value) {</span>
  <span class="s0">// If you ended up here by following an exception call stack, here's what's</span>
  <span class="s0">// happened: you supplied an object or symbol value to React (as a prop, key,</span>
  <span class="s0">// DOM attribute, CSS property, string ref, etc.) and when React tried to</span>
  <span class="s0">// coerce it to a string using `'' + value`, an exception was thrown.</span>
  <span class="s0">//</span>
  <span class="s0">// The most common types that will cause this exception are `Symbol` instances</span>
  <span class="s0">// and Temporal objects like `Temporal.Instant`. But any object that has a</span>
  <span class="s0">// `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this</span>
  <span class="s0">// exception. (Library authors do this to prevent users from using built-in</span>
  <span class="s0">// numeric operators like `+` or comparison operators like `&gt;=` because custom</span>
  <span class="s0">// methods are needed to perform accurate arithmetic or comparison.)</span>
  <span class="s0">//</span>
  <span class="s0">// To fix the problem, coerce this object or symbol value to a string before</span>
  <span class="s0">// passing it to React. The most reliable way is usually `String(value)`.</span>
  <span class="s0">//</span>
  <span class="s0">// To find which value is throwing, check the browser or debugger console.</span>
  <span class="s0">// Before this exception was thrown, there should be `console.error` output</span>
  <span class="s0">// that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the</span>
  <span class="s0">// problem and how that type was used: key, atrribute, input value prop, etc.</span>
  <span class="s0">// In most cases, this console output also shows the component and its</span>
  <span class="s0">// ancestor components where the exception happened.</span>
  <span class="s0">//</span>
  <span class="s0">// eslint-disable-next-line react-internal/safe-string-coercion</span>
  <span class="s3">return </span><span class="s2">&quot;&quot; </span><span class="s1">+ value;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">checkKeyStringCoercion(value) {</span>
  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(willCoercionThrow(value)) {</span>
      <span class="s1">error(</span>
        <span class="s2">&quot;The provided key is an unsupported type %s.&quot; </span><span class="s1">+</span>
          <span class="s2">&quot; This value must be coerced to a string before before using it here.&quot;</span><span class="s1">,</span>
        <span class="s1">typeName(value)</span>
      <span class="s1">);</span>

      <span class="s3">return </span><span class="s1">testStringCoercion(value); </span><span class="s0">// throw (to help callers find troubleshooting comments)</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">checkPropStringCoercion(value, propName) {</span>
  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(willCoercionThrow(value)) {</span>
      <span class="s1">error(</span>
        <span class="s2">&quot;The provided `%s` prop is an unsupported type %s.&quot; </span><span class="s1">+</span>
          <span class="s2">&quot; This value must be coerced to a string before before using it here.&quot;</span><span class="s1">,</span>
        <span class="s1">propName,</span>
        <span class="s1">typeName(value)</span>
      <span class="s1">);</span>

      <span class="s3">return </span><span class="s1">testStringCoercion(value); </span><span class="s0">// throw (to help callers find troubleshooting comments)</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">resolveDefaultProps(Component, baseProps) {</span>
  <span class="s3">if </span><span class="s1">(Component &amp;&amp; Component.defaultProps) {</span>
    <span class="s0">// Resolve default props. Taken from ReactElement</span>
    <span class="s3">var </span><span class="s1">props = assign({}, baseProps);</span>
    <span class="s3">var </span><span class="s1">defaultProps = Component.defaultProps;</span>

    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">propName </span><span class="s3">in </span><span class="s1">defaultProps) {</span>
      <span class="s3">if </span><span class="s1">(props[propName] === undefined) {</span>
        <span class="s1">props[propName] = defaultProps[propName];</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">props;</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">baseProps;</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">valueCursor = createCursor(</span><span class="s3">null</span><span class="s1">);</span>
<span class="s3">var </span><span class="s1">rendererSigil;</span>

<span class="s1">{</span>
  <span class="s0">// Use this to detect multiple renderers using the same context</span>
  <span class="s1">rendererSigil = {};</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">currentlyRenderingFiber = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">lastContextDependency = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">lastFullyObservedContext = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">isDisallowedContextReadInDEV = </span><span class="s3">false</span><span class="s1">;</span>
<span class="s3">function </span><span class="s1">resetContextDependencies() {</span>
  <span class="s0">// This is called right before React yields execution, to ensure `readContext`</span>
  <span class="s0">// cannot be called outside the render phase.</span>
  <span class="s1">currentlyRenderingFiber = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">lastContextDependency = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">lastFullyObservedContext = </span><span class="s3">null</span><span class="s1">;</span>

  <span class="s1">{</span>
    <span class="s1">isDisallowedContextReadInDEV = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">enterDisallowedContextReadInDEV() {</span>
  <span class="s1">{</span>
    <span class="s1">isDisallowedContextReadInDEV = </span><span class="s3">true</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">exitDisallowedContextReadInDEV() {</span>
  <span class="s1">{</span>
    <span class="s1">isDisallowedContextReadInDEV = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">pushProvider(providerFiber, context, nextValue) {</span>
  <span class="s1">{</span>
    <span class="s1">push(valueCursor, context._currentValue2, providerFiber);</span>
    <span class="s1">context._currentValue2 = nextValue;</span>

    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(</span>
        <span class="s1">context._currentRenderer2 !== undefined &amp;&amp;</span>
        <span class="s1">context._currentRenderer2 !== </span><span class="s3">null </span><span class="s1">&amp;&amp;</span>
        <span class="s1">context._currentRenderer2 !== rendererSigil</span>
      <span class="s1">) {</span>
        <span class="s1">error(</span>
          <span class="s2">&quot;Detected multiple renderers concurrently rendering the &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;same context provider. This is currently unsupported.&quot;</span>
        <span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s1">context._currentRenderer2 = rendererSigil;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">popProvider(context, providerFiber) {</span>
  <span class="s3">var </span><span class="s1">currentValue = valueCursor.current;</span>
  <span class="s1">pop(valueCursor, providerFiber);</span>

  <span class="s1">{</span>
    <span class="s1">{</span>
      <span class="s1">context._currentValue2 = currentValue;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">scheduleContextWorkOnParentPath(parent, renderLanes, propagationRoot) {</span>
  <span class="s0">// Update the child lanes of all the ancestors, including the alternates.</span>
  <span class="s3">var </span><span class="s1">node = parent;</span>

  <span class="s3">while </span><span class="s1">(node !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">alternate = node.alternate;</span>

    <span class="s3">if </span><span class="s1">(!isSubsetOfLanes(node.childLanes, renderLanes)) {</span>
      <span class="s1">node.childLanes = mergeLanes(node.childLanes, renderLanes);</span>

      <span class="s3">if </span><span class="s1">(alternate !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span>
      <span class="s1">alternate !== </span><span class="s3">null </span><span class="s1">&amp;&amp;</span>
      <span class="s1">!isSubsetOfLanes(alternate.childLanes, renderLanes)</span>
    <span class="s1">) {</span>
      <span class="s1">alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(node === propagationRoot) {</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">node = node.</span><span class="s3">return</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(node !== propagationRoot) {</span>
      <span class="s1">error(</span>
        <span class="s2">&quot;Expected to find the propagation root when scheduling context work. &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;This error is likely caused by a bug in React. Please file an issue.&quot;</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">propagateContextChange(workInProgress, context, renderLanes) {</span>
  <span class="s1">{</span>
    <span class="s1">propagateContextChange_eager(workInProgress, context, renderLanes);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">propagateContextChange_eager(workInProgress, context, renderLanes) {</span>
  <span class="s3">var </span><span class="s1">fiber = workInProgress.child;</span>

  <span class="s3">if </span><span class="s1">(fiber !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s0">// Set the return pointer of the child to the work-in-progress fiber.</span>
    <span class="s1">fiber.</span><span class="s3">return </span><span class="s1">= workInProgress;</span>
  <span class="s1">}</span>

  <span class="s3">while </span><span class="s1">(fiber !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">nextFiber = </span><span class="s3">void </span><span class="s4">0</span><span class="s1">; </span><span class="s0">// Visit this fiber.</span>

    <span class="s3">var </span><span class="s1">list = fiber.dependencies;</span>

    <span class="s3">if </span><span class="s1">(list !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">nextFiber = fiber.child;</span>
      <span class="s3">var </span><span class="s1">dependency = list.firstContext;</span>

      <span class="s3">while </span><span class="s1">(dependency !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s0">// Check if the context matches.</span>
        <span class="s3">if </span><span class="s1">(dependency.context === context) {</span>
          <span class="s0">// Match! Schedule an update on this fiber.</span>
          <span class="s3">if </span><span class="s1">(fiber.tag === ClassComponent) {</span>
            <span class="s0">// Schedule a force update on the work-in-progress.</span>
            <span class="s3">var </span><span class="s1">lane = pickArbitraryLane(renderLanes);</span>
            <span class="s3">var </span><span class="s1">update = createUpdate(NoTimestamp, lane);</span>
            <span class="s1">update.tag = ForceUpdate; </span><span class="s0">// TODO: Because we don't have a work-in-progress, this will add the</span>
            <span class="s0">// update to the current fiber, too, which means it will persist even if</span>
            <span class="s0">// this render is thrown away. Since it's a race condition, not sure it's</span>
            <span class="s0">// worth fixing.</span>
            <span class="s0">// Inlined `enqueueUpdate` to remove interleaved update check</span>

            <span class="s3">var </span><span class="s1">updateQueue = fiber.updateQueue;</span>

            <span class="s3">if </span><span class="s1">(updateQueue === </span><span class="s3">null</span><span class="s1">);</span>
            <span class="s3">else </span><span class="s1">{</span>
              <span class="s3">var </span><span class="s1">sharedQueue = updateQueue.shared;</span>
              <span class="s3">var </span><span class="s1">pending = sharedQueue.pending;</span>

              <span class="s3">if </span><span class="s1">(pending === </span><span class="s3">null</span><span class="s1">) {</span>
                <span class="s0">// This is the first update. Create a circular list.</span>
                <span class="s1">update.next = update;</span>
              <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s1">update.next = pending.next;</span>
                <span class="s1">pending.next = update;</span>
              <span class="s1">}</span>

              <span class="s1">sharedQueue.pending = update;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s1">fiber.lanes = mergeLanes(fiber.lanes, renderLanes);</span>
          <span class="s3">var </span><span class="s1">alternate = fiber.alternate;</span>

          <span class="s3">if </span><span class="s1">(alternate !== </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s1">alternate.lanes = mergeLanes(alternate.lanes, renderLanes);</span>
          <span class="s1">}</span>

          <span class="s1">scheduleContextWorkOnParentPath(</span>
            <span class="s1">fiber.</span><span class="s3">return</span><span class="s1">,</span>
            <span class="s1">renderLanes,</span>
            <span class="s1">workInProgress</span>
          <span class="s1">); </span><span class="s0">// Mark the updated lanes on the list, too.</span>

          <span class="s1">list.lanes = mergeLanes(list.lanes, renderLanes); </span><span class="s0">// Since we already found a match, we can stop traversing the</span>
          <span class="s0">// dependency list.</span>

          <span class="s3">break</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">dependency = dependency.next;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(fiber.tag === ContextProvider) {</span>
      <span class="s0">// Don't scan deeper if this is a matching provider</span>
      <span class="s1">nextFiber = fiber.type === workInProgress.type ? </span><span class="s3">null </span><span class="s1">: fiber.child;</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(fiber.tag === DehydratedFragment) {</span>
      <span class="s0">// If a dehydrated suspense boundary is in this subtree, we don't know</span>
      <span class="s0">// if it will have any context consumers in it. The best we can do is</span>
      <span class="s0">// mark it as having updates.</span>
      <span class="s3">var </span><span class="s1">parentSuspense = fiber.</span><span class="s3">return</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s1">(parentSuspense === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">throw new </span><span class="s1">Error(</span>
          <span class="s2">&quot;We just came from a parent so we must have had a parent. This is a bug in React.&quot;</span>
        <span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s1">parentSuspense.lanes = mergeLanes(parentSuspense.lanes, renderLanes);</span>
      <span class="s3">var </span><span class="s1">_alternate = parentSuspense.alternate;</span>

      <span class="s3">if </span><span class="s1">(_alternate !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">_alternate.lanes = mergeLanes(_alternate.lanes, renderLanes);</span>
      <span class="s1">} </span><span class="s0">// This is intentionally passing this fiber as the parent</span>
      <span class="s0">// because we want to schedule this fiber as having work</span>
      <span class="s0">// on its children. We'll use the childLanes on</span>
      <span class="s0">// this fiber to indicate that a context has changed.</span>

      <span class="s1">scheduleContextWorkOnParentPath(</span>
        <span class="s1">parentSuspense,</span>
        <span class="s1">renderLanes,</span>
        <span class="s1">workInProgress</span>
      <span class="s1">);</span>
      <span class="s1">nextFiber = fiber.sibling;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s0">// Traverse down.</span>
      <span class="s1">nextFiber = fiber.child;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(nextFiber !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// Set the return pointer of the child to the work-in-progress fiber.</span>
      <span class="s1">nextFiber.</span><span class="s3">return </span><span class="s1">= fiber;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s0">// No child. Traverse to next sibling.</span>
      <span class="s1">nextFiber = fiber;</span>

      <span class="s3">while </span><span class="s1">(nextFiber !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(nextFiber === workInProgress) {</span>
          <span class="s0">// We're back to the root of this subtree. Exit.</span>
          <span class="s1">nextFiber = </span><span class="s3">null</span><span class="s1">;</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">var </span><span class="s1">sibling = nextFiber.sibling;</span>

        <span class="s3">if </span><span class="s1">(sibling !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s0">// Set the return pointer of the sibling to the work-in-progress fiber.</span>
          <span class="s1">sibling.</span><span class="s3">return </span><span class="s1">= nextFiber.</span><span class="s3">return</span><span class="s1">;</span>
          <span class="s1">nextFiber = sibling;</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s0">// No more siblings. Traverse up.</span>

        <span class="s1">nextFiber = nextFiber.</span><span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">fiber = nextFiber;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">prepareToReadContext(workInProgress, renderLanes) {</span>
  <span class="s1">currentlyRenderingFiber = workInProgress;</span>
  <span class="s1">lastContextDependency = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">lastFullyObservedContext = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">dependencies = workInProgress.dependencies;</span>

  <span class="s3">if </span><span class="s1">(dependencies !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s1">{</span>
      <span class="s3">var </span><span class="s1">firstContext = dependencies.firstContext;</span>

      <span class="s3">if </span><span class="s1">(firstContext !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(includesSomeLane(dependencies.lanes, renderLanes)) {</span>
          <span class="s0">// Context list has a pending update. Mark that this fiber performed work.</span>
          <span class="s1">markWorkInProgressReceivedUpdate();</span>
        <span class="s1">} </span><span class="s0">// Reset the work-in-progress list</span>

        <span class="s1">dependencies.firstContext = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">readContext(context) {</span>
  <span class="s1">{</span>
    <span class="s0">// This warning would fire if you read context inside a Hook like useMemo.</span>
    <span class="s0">// Unlike the class check below, it's not enforced in production for perf.</span>
    <span class="s3">if </span><span class="s1">(isDisallowedContextReadInDEV) {</span>
      <span class="s1">error(</span>
        <span class="s2">&quot;Context can only be read while React is rendering. &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;In classes, you can read it in the render method or getDerivedStateFromProps. &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;In function components, you can read it directly in the function body, but not &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;inside Hooks like useReducer() or useMemo().&quot;</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">value = context._currentValue2;</span>

  <span class="s3">if </span><span class="s1">(lastFullyObservedContext === context);</span>
  <span class="s3">else </span><span class="s1">{</span>
    <span class="s3">var </span><span class="s1">contextItem = {</span>
      <span class="s1">context: context,</span>
      <span class="s1">memoizedValue: value,</span>
      <span class="s1">next: </span><span class="s3">null</span>
    <span class="s1">};</span>

    <span class="s3">if </span><span class="s1">(lastContextDependency === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(currentlyRenderingFiber === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">throw new </span><span class="s1">Error(</span>
          <span class="s2">&quot;Context can only be read while React is rendering. &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;In classes, you can read it in the render method or getDerivedStateFromProps. &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;In function components, you can read it directly in the function body, but not &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;inside Hooks like useReducer() or useMemo().&quot;</span>
        <span class="s1">);</span>
      <span class="s1">} </span><span class="s0">// This is the first dependency for this component. Create a new list.</span>

      <span class="s1">lastContextDependency = contextItem;</span>
      <span class="s1">currentlyRenderingFiber.dependencies = {</span>
        <span class="s1">lanes: NoLanes,</span>
        <span class="s1">firstContext: contextItem</span>
      <span class="s1">};</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s0">// Append a new context item.</span>
      <span class="s1">lastContextDependency = lastContextDependency.next = contextItem;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">value;</span>
<span class="s1">}</span>

<span class="s0">// render. When this render exits, either because it finishes or because it is</span>
<span class="s0">// interrupted, the interleaved updates will be transferred onto the main part</span>
<span class="s0">// of the queue.</span>

<span class="s3">var </span><span class="s1">concurrentQueues = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s3">function </span><span class="s1">pushConcurrentUpdateQueue(queue) {</span>
  <span class="s3">if </span><span class="s1">(concurrentQueues === </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s1">concurrentQueues = [queue];</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">concurrentQueues.push(queue);</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">finishQueueingConcurrentUpdates() {</span>
  <span class="s0">// Transfer the interleaved updates onto the main queue. Each queue has a</span>
  <span class="s0">// `pending` field and an `interleaved` field. When they are not null, they</span>
  <span class="s0">// point to the last node in a circular linked list. We need to append the</span>
  <span class="s0">// interleaved list to the end of the pending list by joining them into a</span>
  <span class="s0">// single, circular list.</span>
  <span class="s3">if </span><span class="s1">(concurrentQueues !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; concurrentQueues.length; i++) {</span>
      <span class="s3">var </span><span class="s1">queue = concurrentQueues[i];</span>
      <span class="s3">var </span><span class="s1">lastInterleavedUpdate = queue.interleaved;</span>

      <span class="s3">if </span><span class="s1">(lastInterleavedUpdate !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">queue.interleaved = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s3">var </span><span class="s1">firstInterleavedUpdate = lastInterleavedUpdate.next;</span>
        <span class="s3">var </span><span class="s1">lastPendingUpdate = queue.pending;</span>

        <span class="s3">if </span><span class="s1">(lastPendingUpdate !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s3">var </span><span class="s1">firstPendingUpdate = lastPendingUpdate.next;</span>
          <span class="s1">lastPendingUpdate.next = firstInterleavedUpdate;</span>
          <span class="s1">lastInterleavedUpdate.next = firstPendingUpdate;</span>
        <span class="s1">}</span>

        <span class="s1">queue.pending = lastInterleavedUpdate;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">concurrentQueues = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">enqueueConcurrentHookUpdate(fiber, queue, update, lane) {</span>
  <span class="s3">var </span><span class="s1">interleaved = queue.interleaved;</span>

  <span class="s3">if </span><span class="s1">(interleaved === </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s0">// This is the first update. Create a circular list.</span>
    <span class="s1">update.next = update; </span><span class="s0">// At the end of the current render, this queue's interleaved updates will</span>
    <span class="s0">// be transferred to the pending queue.</span>

    <span class="s1">pushConcurrentUpdateQueue(queue);</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">update.next = interleaved.next;</span>
    <span class="s1">interleaved.next = update;</span>
  <span class="s1">}</span>

  <span class="s1">queue.interleaved = update;</span>
  <span class="s3">return </span><span class="s1">markUpdateLaneFromFiberToRoot(fiber, lane);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">enqueueConcurrentHookUpdateAndEagerlyBailout(</span>
  <span class="s1">fiber,</span>
  <span class="s1">queue,</span>
  <span class="s1">update,</span>
  <span class="s1">lane</span>
<span class="s1">) {</span>
  <span class="s3">var </span><span class="s1">interleaved = queue.interleaved;</span>

  <span class="s3">if </span><span class="s1">(interleaved === </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s0">// This is the first update. Create a circular list.</span>
    <span class="s1">update.next = update; </span><span class="s0">// At the end of the current render, this queue's interleaved updates will</span>
    <span class="s0">// be transferred to the pending queue.</span>

    <span class="s1">pushConcurrentUpdateQueue(queue);</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">update.next = interleaved.next;</span>
    <span class="s1">interleaved.next = update;</span>
  <span class="s1">}</span>

  <span class="s1">queue.interleaved = update;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">enqueueConcurrentClassUpdate(fiber, queue, update, lane) {</span>
  <span class="s3">var </span><span class="s1">interleaved = queue.interleaved;</span>

  <span class="s3">if </span><span class="s1">(interleaved === </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s0">// This is the first update. Create a circular list.</span>
    <span class="s1">update.next = update; </span><span class="s0">// At the end of the current render, this queue's interleaved updates will</span>
    <span class="s0">// be transferred to the pending queue.</span>

    <span class="s1">pushConcurrentUpdateQueue(queue);</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">update.next = interleaved.next;</span>
    <span class="s1">interleaved.next = update;</span>
  <span class="s1">}</span>

  <span class="s1">queue.interleaved = update;</span>
  <span class="s3">return </span><span class="s1">markUpdateLaneFromFiberToRoot(fiber, lane);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">enqueueConcurrentRenderForLane(fiber, lane) {</span>
  <span class="s3">return </span><span class="s1">markUpdateLaneFromFiberToRoot(fiber, lane);</span>
<span class="s1">} </span><span class="s0">// Calling this function outside this module should only be done for backwards</span>
<span class="s0">// compatibility and should always be accompanied by a warning.</span>

<span class="s3">var </span><span class="s1">unsafe_markUpdateLaneFromFiberToRoot = markUpdateLaneFromFiberToRoot;</span>

<span class="s3">function </span><span class="s1">markUpdateLaneFromFiberToRoot(sourceFiber, lane) {</span>
  <span class="s0">// Update the source fiber's lanes</span>
  <span class="s1">sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);</span>
  <span class="s3">var </span><span class="s1">alternate = sourceFiber.alternate;</span>

  <span class="s3">if </span><span class="s1">(alternate !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s1">alternate.lanes = mergeLanes(alternate.lanes, lane);</span>
  <span class="s1">}</span>

  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(</span>
      <span class="s1">alternate === </span><span class="s3">null </span><span class="s1">&amp;&amp;</span>
      <span class="s1">(sourceFiber.flags &amp; (Placement | Hydrating)) !== NoFlags</span>
    <span class="s1">) {</span>
      <span class="s1">warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s0">// Walk the parent path to the root and update the child lanes.</span>

  <span class="s3">var </span><span class="s1">node = sourceFiber;</span>
  <span class="s3">var </span><span class="s1">parent = sourceFiber.</span><span class="s3">return</span><span class="s1">;</span>

  <span class="s3">while </span><span class="s1">(parent !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s1">parent.childLanes = mergeLanes(parent.childLanes, lane);</span>
    <span class="s1">alternate = parent.alternate;</span>

    <span class="s3">if </span><span class="s1">(alternate !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">alternate.childLanes = mergeLanes(alternate.childLanes, lane);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">{</span>
        <span class="s3">if </span><span class="s1">((parent.flags &amp; (Placement | Hydrating)) !== NoFlags) {</span>
          <span class="s1">warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">node = parent;</span>
    <span class="s1">parent = parent.</span><span class="s3">return</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(node.tag === HostRoot) {</span>
    <span class="s3">var </span><span class="s1">root = node.stateNode;</span>
    <span class="s3">return </span><span class="s1">root;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">UpdateState = </span><span class="s4">0</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">ReplaceState = </span><span class="s4">1</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">ForceUpdate = </span><span class="s4">2</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">CaptureUpdate = </span><span class="s4">3</span><span class="s1">; </span><span class="s0">// Global state that is reset at the beginning of calling `processUpdateQueue`.</span>
<span class="s0">// It should only be read right after calling `processUpdateQueue`, via</span>
<span class="s0">// `checkHasForceUpdateAfterProcessing`.</span>

<span class="s3">var </span><span class="s1">hasForceUpdate = </span><span class="s3">false</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">didWarnUpdateInsideUpdate;</span>
<span class="s3">var </span><span class="s1">currentlyProcessingQueue;</span>

<span class="s1">{</span>
  <span class="s1">didWarnUpdateInsideUpdate = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s1">currentlyProcessingQueue = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">initializeUpdateQueue(fiber) {</span>
  <span class="s3">var </span><span class="s1">queue = {</span>
    <span class="s1">baseState: fiber.memoizedState,</span>
    <span class="s1">firstBaseUpdate: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">lastBaseUpdate: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">shared: {</span>
      <span class="s1">pending: </span><span class="s3">null</span><span class="s1">,</span>
      <span class="s1">interleaved: </span><span class="s3">null</span><span class="s1">,</span>
      <span class="s1">lanes: NoLanes</span>
    <span class="s1">},</span>
    <span class="s1">effects: </span><span class="s3">null</span>
  <span class="s1">};</span>
  <span class="s1">fiber.updateQueue = queue;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">cloneUpdateQueue(current, workInProgress) {</span>
  <span class="s0">// Clone the update queue from current. Unless it's already a clone.</span>
  <span class="s3">var </span><span class="s1">queue = workInProgress.updateQueue;</span>
  <span class="s3">var </span><span class="s1">currentQueue = current.updateQueue;</span>

  <span class="s3">if </span><span class="s1">(queue === currentQueue) {</span>
    <span class="s3">var </span><span class="s1">clone = {</span>
      <span class="s1">baseState: currentQueue.baseState,</span>
      <span class="s1">firstBaseUpdate: currentQueue.firstBaseUpdate,</span>
      <span class="s1">lastBaseUpdate: currentQueue.lastBaseUpdate,</span>
      <span class="s1">shared: currentQueue.shared,</span>
      <span class="s1">effects: currentQueue.effects</span>
    <span class="s1">};</span>
    <span class="s1">workInProgress.updateQueue = clone;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">createUpdate(eventTime, lane) {</span>
  <span class="s3">var </span><span class="s1">update = {</span>
    <span class="s1">eventTime: eventTime,</span>
    <span class="s1">lane: lane,</span>
    <span class="s1">tag: UpdateState,</span>
    <span class="s1">payload: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">callback: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">next: </span><span class="s3">null</span>
  <span class="s1">};</span>
  <span class="s3">return </span><span class="s1">update;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">enqueueUpdate(fiber, update, lane) {</span>
  <span class="s3">var </span><span class="s1">updateQueue = fiber.updateQueue;</span>

  <span class="s3">if </span><span class="s1">(updateQueue === </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s0">// Only occurs if the fiber has been unmounted.</span>
    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">sharedQueue = updateQueue.shared;</span>

  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(</span>
      <span class="s1">currentlyProcessingQueue === sharedQueue &amp;&amp;</span>
      <span class="s1">!didWarnUpdateInsideUpdate</span>
    <span class="s1">) {</span>
      <span class="s1">error(</span>
        <span class="s2">&quot;An update (setState, replaceState, or forceUpdate) was scheduled &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;from inside an update function. Update functions should be pure, &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;with zero side-effects. Consider using componentDidUpdate or a &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;callback.&quot;</span>
      <span class="s1">);</span>

      <span class="s1">didWarnUpdateInsideUpdate = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(isUnsafeClassRenderPhaseUpdate()) {</span>
    <span class="s0">// This is an unsafe render phase update. Add directly to the update</span>
    <span class="s0">// queue so we can process it immediately during the current render.</span>
    <span class="s3">var </span><span class="s1">pending = sharedQueue.pending;</span>

    <span class="s3">if </span><span class="s1">(pending === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// This is the first update. Create a circular list.</span>
      <span class="s1">update.next = update;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">update.next = pending.next;</span>
      <span class="s1">pending.next = update;</span>
    <span class="s1">}</span>

    <span class="s1">sharedQueue.pending = update; </span><span class="s0">// Update the childLanes even though we're most likely already rendering</span>
    <span class="s0">// this fiber. This is for backwards compatibility in the case where you</span>
    <span class="s0">// update a different component during render phase than the one that is</span>
    <span class="s0">// currently renderings (a pattern that is accompanied by a warning).</span>

    <span class="s3">return </span><span class="s1">unsafe_markUpdateLaneFromFiberToRoot(fiber, lane);</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s3">return </span><span class="s1">enqueueConcurrentClassUpdate(fiber, sharedQueue, update, lane);</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">entangleTransitions(root, fiber, lane) {</span>
  <span class="s3">var </span><span class="s1">updateQueue = fiber.updateQueue;</span>

  <span class="s3">if </span><span class="s1">(updateQueue === </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s0">// Only occurs if the fiber has been unmounted.</span>
    <span class="s3">return</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">sharedQueue = updateQueue.shared;</span>

  <span class="s3">if </span><span class="s1">(isTransitionLane(lane)) {</span>
    <span class="s3">var </span><span class="s1">queueLanes = sharedQueue.lanes; </span><span class="s0">// If any entangled lanes are no longer pending on the root, then they must</span>
    <span class="s0">// have finished. We can remove them from the shared queue, which represents</span>
    <span class="s0">// a superset of the actually pending lanes. In some cases we may entangle</span>
    <span class="s0">// more than we need to, but that's OK. In fact it's worse if we *don't*</span>
    <span class="s0">// entangle when we should.</span>

    <span class="s1">queueLanes = intersectLanes(queueLanes, root.pendingLanes); </span><span class="s0">// Entangle the new transition lane with the other transition lanes.</span>

    <span class="s3">var </span><span class="s1">newQueueLanes = mergeLanes(queueLanes, lane);</span>
    <span class="s1">sharedQueue.lanes = newQueueLanes; </span><span class="s0">// Even if queue.lanes already include lane, we don't know for certain if</span>
    <span class="s0">// the lane finished since the last time we entangled it. So we need to</span>
    <span class="s0">// entangle it again, just to be sure.</span>

    <span class="s1">markRootEntangled(root, newQueueLanes);</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">enqueueCapturedUpdate(workInProgress, capturedUpdate) {</span>
  <span class="s0">// Captured updates are updates that are thrown by a child during the render</span>
  <span class="s0">// phase. They should be discarded if the render is aborted. Therefore,</span>
  <span class="s0">// we should only put them on the work-in-progress queue, not the current one.</span>
  <span class="s3">var </span><span class="s1">queue = workInProgress.updateQueue; </span><span class="s0">// Check if the work-in-progress queue is a clone.</span>

  <span class="s3">var </span><span class="s1">current = workInProgress.alternate;</span>

  <span class="s3">if </span><span class="s1">(current !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">currentQueue = current.updateQueue;</span>

    <span class="s3">if </span><span class="s1">(queue === currentQueue) {</span>
      <span class="s0">// The work-in-progress queue is the same as current. This happens when</span>
      <span class="s0">// we bail out on a parent fiber that then captures an error thrown by</span>
      <span class="s0">// a child. Since we want to append the update only to the work-in</span>
      <span class="s0">// -progress queue, we need to clone the updates. We usually clone during</span>
      <span class="s0">// processUpdateQueue, but that didn't happen in this case because we</span>
      <span class="s0">// skipped over the parent when we bailed out.</span>
      <span class="s3">var </span><span class="s1">newFirst = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s3">var </span><span class="s1">newLast = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s3">var </span><span class="s1">firstBaseUpdate = queue.firstBaseUpdate;</span>

      <span class="s3">if </span><span class="s1">(firstBaseUpdate !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s0">// Loop through the updates and clone them.</span>
        <span class="s3">var </span><span class="s1">update = firstBaseUpdate;</span>

        <span class="s3">do </span><span class="s1">{</span>
          <span class="s3">var </span><span class="s1">clone = {</span>
            <span class="s1">eventTime: update.eventTime,</span>
            <span class="s1">lane: update.lane,</span>
            <span class="s1">tag: update.tag,</span>
            <span class="s1">payload: update.payload,</span>
            <span class="s1">callback: update.callback,</span>
            <span class="s1">next: </span><span class="s3">null</span>
          <span class="s1">};</span>

          <span class="s3">if </span><span class="s1">(newLast === </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s1">newFirst = newLast = clone;</span>
          <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">newLast.next = clone;</span>
            <span class="s1">newLast = clone;</span>
          <span class="s1">}</span>

          <span class="s1">update = update.next;</span>
        <span class="s1">} </span><span class="s3">while </span><span class="s1">(update !== </span><span class="s3">null</span><span class="s1">); </span><span class="s0">// Append the captured update the end of the cloned list.</span>

        <span class="s3">if </span><span class="s1">(newLast === </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">newFirst = newLast = capturedUpdate;</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s1">newLast.next = capturedUpdate;</span>
          <span class="s1">newLast = capturedUpdate;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s0">// There are no base updates.</span>
        <span class="s1">newFirst = newLast = capturedUpdate;</span>
      <span class="s1">}</span>

      <span class="s1">queue = {</span>
        <span class="s1">baseState: currentQueue.baseState,</span>
        <span class="s1">firstBaseUpdate: newFirst,</span>
        <span class="s1">lastBaseUpdate: newLast,</span>
        <span class="s1">shared: currentQueue.shared,</span>
        <span class="s1">effects: currentQueue.effects</span>
      <span class="s1">};</span>
      <span class="s1">workInProgress.updateQueue = queue;</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s0">// Append the update to the end of the list.</span>

  <span class="s3">var </span><span class="s1">lastBaseUpdate = queue.lastBaseUpdate;</span>

  <span class="s3">if </span><span class="s1">(lastBaseUpdate === </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s1">queue.firstBaseUpdate = capturedUpdate;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">lastBaseUpdate.next = capturedUpdate;</span>
  <span class="s1">}</span>

  <span class="s1">queue.lastBaseUpdate = capturedUpdate;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">getStateFromUpdate(</span>
  <span class="s1">workInProgress,</span>
  <span class="s1">queue,</span>
  <span class="s1">update,</span>
  <span class="s1">prevState,</span>
  <span class="s1">nextProps,</span>
  <span class="s1">instance</span>
<span class="s1">) {</span>
  <span class="s3">switch </span><span class="s1">(update.tag) {</span>
    <span class="s3">case </span><span class="s1">ReplaceState: {</span>
      <span class="s3">var </span><span class="s1">payload = update.payload;</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">payload === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
        <span class="s0">// Updater function</span>
        <span class="s1">{</span>
          <span class="s1">enterDisallowedContextReadInDEV();</span>
        <span class="s1">}</span>

        <span class="s3">var </span><span class="s1">nextState = payload.call(instance, prevState, nextProps);</span>

        <span class="s1">{</span>
          <span class="s1">exitDisallowedContextReadInDEV();</span>
        <span class="s1">}</span>

        <span class="s3">return </span><span class="s1">nextState;</span>
      <span class="s1">} </span><span class="s0">// State object</span>

      <span class="s3">return </span><span class="s1">payload;</span>
    <span class="s1">}</span>

    <span class="s3">case </span><span class="s1">CaptureUpdate: {</span>
      <span class="s1">workInProgress.flags =</span>
        <span class="s1">(workInProgress.flags &amp; ~ShouldCapture) | DidCapture;</span>
    <span class="s1">}</span>
    <span class="s0">// Intentional fallthrough</span>

    <span class="s3">case </span><span class="s1">UpdateState: {</span>
      <span class="s3">var </span><span class="s1">_payload = update.payload;</span>
      <span class="s3">var </span><span class="s1">partialState;</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">_payload === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
        <span class="s0">// Updater function</span>
        <span class="s1">{</span>
          <span class="s1">enterDisallowedContextReadInDEV();</span>
        <span class="s1">}</span>

        <span class="s1">partialState = _payload.call(instance, prevState, nextProps);</span>

        <span class="s1">{</span>
          <span class="s1">exitDisallowedContextReadInDEV();</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s0">// Partial state object</span>
        <span class="s1">partialState = _payload;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(partialState === </span><span class="s3">null </span><span class="s1">|| partialState === undefined) {</span>
        <span class="s0">// Null and undefined are treated as no-ops.</span>
        <span class="s3">return </span><span class="s1">prevState;</span>
      <span class="s1">} </span><span class="s0">// Merge the partial state and the previous state.</span>

      <span class="s3">return </span><span class="s1">assign({}, prevState, partialState);</span>
    <span class="s1">}</span>

    <span class="s3">case </span><span class="s1">ForceUpdate: {</span>
      <span class="s1">hasForceUpdate = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s3">return </span><span class="s1">prevState;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">prevState;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">processUpdateQueue(workInProgress, props, instance, renderLanes) {</span>
  <span class="s0">// This is always non-null on a ClassComponent or HostRoot</span>
  <span class="s3">var </span><span class="s1">queue = workInProgress.updateQueue;</span>
  <span class="s1">hasForceUpdate = </span><span class="s3">false</span><span class="s1">;</span>

  <span class="s1">{</span>
    <span class="s1">currentlyProcessingQueue = queue.shared;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">firstBaseUpdate = queue.firstBaseUpdate;</span>
  <span class="s3">var </span><span class="s1">lastBaseUpdate = queue.lastBaseUpdate; </span><span class="s0">// Check if there are pending updates. If so, transfer them to the base queue.</span>

  <span class="s3">var </span><span class="s1">pendingQueue = queue.shared.pending;</span>

  <span class="s3">if </span><span class="s1">(pendingQueue !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s1">queue.shared.pending = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// The pending queue is circular. Disconnect the pointer between first</span>
    <span class="s0">// and last so that it's non-circular.</span>

    <span class="s3">var </span><span class="s1">lastPendingUpdate = pendingQueue;</span>
    <span class="s3">var </span><span class="s1">firstPendingUpdate = lastPendingUpdate.next;</span>
    <span class="s1">lastPendingUpdate.next = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// Append pending updates to base queue</span>

    <span class="s3">if </span><span class="s1">(lastBaseUpdate === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">firstBaseUpdate = firstPendingUpdate;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">lastBaseUpdate.next = firstPendingUpdate;</span>
    <span class="s1">}</span>

    <span class="s1">lastBaseUpdate = lastPendingUpdate; </span><span class="s0">// If there's a current queue, and it's different from the base queue, then</span>
    <span class="s0">// we need to transfer the updates to that queue, too. Because the base</span>
    <span class="s0">// queue is a singly-linked list with no cycles, we can append to both</span>
    <span class="s0">// lists and take advantage of structural sharing.</span>
    <span class="s0">// TODO: Pass `current` as argument</span>

    <span class="s3">var </span><span class="s1">current = workInProgress.alternate;</span>

    <span class="s3">if </span><span class="s1">(current !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// This is always non-null on a ClassComponent or HostRoot</span>
      <span class="s3">var </span><span class="s1">currentQueue = current.updateQueue;</span>
      <span class="s3">var </span><span class="s1">currentLastBaseUpdate = currentQueue.lastBaseUpdate;</span>

      <span class="s3">if </span><span class="s1">(currentLastBaseUpdate !== lastBaseUpdate) {</span>
        <span class="s3">if </span><span class="s1">(currentLastBaseUpdate === </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">currentQueue.firstBaseUpdate = firstPendingUpdate;</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s1">currentLastBaseUpdate.next = firstPendingUpdate;</span>
        <span class="s1">}</span>

        <span class="s1">currentQueue.lastBaseUpdate = lastPendingUpdate;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s0">// These values may change as we process the queue.</span>

  <span class="s3">if </span><span class="s1">(firstBaseUpdate !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s0">// Iterate through the list of updates to compute the result.</span>
    <span class="s3">var </span><span class="s1">newState = queue.baseState; </span><span class="s0">// TODO: Don't need to accumulate this. Instead, we can remove renderLanes</span>
    <span class="s0">// from the original lanes.</span>

    <span class="s3">var </span><span class="s1">newLanes = NoLanes;</span>
    <span class="s3">var </span><span class="s1">newBaseState = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">newFirstBaseUpdate = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">newLastBaseUpdate = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">update = firstBaseUpdate;</span>

    <span class="s3">do </span><span class="s1">{</span>
      <span class="s3">var </span><span class="s1">updateLane = update.lane;</span>
      <span class="s3">var </span><span class="s1">updateEventTime = update.eventTime;</span>

      <span class="s3">if </span><span class="s1">(!isSubsetOfLanes(renderLanes, updateLane)) {</span>
        <span class="s0">// Priority is insufficient. Skip this update. If this is the first</span>
        <span class="s0">// skipped update, the previous update/state is the new base</span>
        <span class="s0">// update/state.</span>
        <span class="s3">var </span><span class="s1">clone = {</span>
          <span class="s1">eventTime: updateEventTime,</span>
          <span class="s1">lane: updateLane,</span>
          <span class="s1">tag: update.tag,</span>
          <span class="s1">payload: update.payload,</span>
          <span class="s1">callback: update.callback,</span>
          <span class="s1">next: </span><span class="s3">null</span>
        <span class="s1">};</span>

        <span class="s3">if </span><span class="s1">(newLastBaseUpdate === </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">newFirstBaseUpdate = newLastBaseUpdate = clone;</span>
          <span class="s1">newBaseState = newState;</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s1">newLastBaseUpdate = newLastBaseUpdate.next = clone;</span>
        <span class="s1">} </span><span class="s0">// Update the remaining priority in the queue.</span>

        <span class="s1">newLanes = mergeLanes(newLanes, updateLane);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s0">// This update does have sufficient priority.</span>
        <span class="s3">if </span><span class="s1">(newLastBaseUpdate !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s3">var </span><span class="s1">_clone = {</span>
            <span class="s1">eventTime: updateEventTime,</span>
            <span class="s0">// This update is going to be committed so we never want uncommit</span>
            <span class="s0">// it. Using NoLane works because 0 is a subset of all bitmasks, so</span>
            <span class="s0">// this will never be skipped by the check above.</span>
            <span class="s1">lane: NoLane,</span>
            <span class="s1">tag: update.tag,</span>
            <span class="s1">payload: update.payload,</span>
            <span class="s1">callback: update.callback,</span>
            <span class="s1">next: </span><span class="s3">null</span>
          <span class="s1">};</span>
          <span class="s1">newLastBaseUpdate = newLastBaseUpdate.next = _clone;</span>
        <span class="s1">} </span><span class="s0">// Process this update.</span>

        <span class="s1">newState = getStateFromUpdate(</span>
          <span class="s1">workInProgress,</span>
          <span class="s1">queue,</span>
          <span class="s1">update,</span>
          <span class="s1">newState,</span>
          <span class="s1">props,</span>
          <span class="s1">instance</span>
        <span class="s1">);</span>
        <span class="s3">var </span><span class="s1">callback = update.callback;</span>

        <span class="s3">if </span><span class="s1">(</span>
          <span class="s1">callback !== </span><span class="s3">null </span><span class="s1">&amp;&amp; </span><span class="s0">// If the update was already committed, we should not queue its</span>
          <span class="s0">// callback again.</span>
          <span class="s1">update.lane !== NoLane</span>
        <span class="s1">) {</span>
          <span class="s1">workInProgress.flags |= Callback;</span>
          <span class="s3">var </span><span class="s1">effects = queue.effects;</span>

          <span class="s3">if </span><span class="s1">(effects === </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s1">queue.effects = [update];</span>
          <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">effects.push(update);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">update = update.next;</span>

      <span class="s3">if </span><span class="s1">(update === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">pendingQueue = queue.shared.pending;</span>

        <span class="s3">if </span><span class="s1">(pendingQueue === </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s0">// An update was scheduled from inside a reducer. Add the new</span>
          <span class="s0">// pending updates to the end of the list and keep processing.</span>
          <span class="s3">var </span><span class="s1">_lastPendingUpdate = pendingQueue; </span><span class="s0">// Intentionally unsound. Pending updates form a circular list, but we</span>
          <span class="s0">// unravel them when transferring them to the base queue.</span>

          <span class="s3">var </span><span class="s1">_firstPendingUpdate = _lastPendingUpdate.next;</span>
          <span class="s1">_lastPendingUpdate.next = </span><span class="s3">null</span><span class="s1">;</span>
          <span class="s1">update = _firstPendingUpdate;</span>
          <span class="s1">queue.lastBaseUpdate = _lastPendingUpdate;</span>
          <span class="s1">queue.shared.pending = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">while </span><span class="s1">(</span><span class="s3">true</span><span class="s1">);</span>

    <span class="s3">if </span><span class="s1">(newLastBaseUpdate === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">newBaseState = newState;</span>
    <span class="s1">}</span>

    <span class="s1">queue.baseState = newBaseState;</span>
    <span class="s1">queue.firstBaseUpdate = newFirstBaseUpdate;</span>
    <span class="s1">queue.lastBaseUpdate = newLastBaseUpdate; </span><span class="s0">// Interleaved updates are stored on a separate queue. We aren't going to</span>
    <span class="s0">// process them during this render, but we do need to track which lanes</span>
    <span class="s0">// are remaining.</span>

    <span class="s3">var </span><span class="s1">lastInterleaved = queue.shared.interleaved;</span>

    <span class="s3">if </span><span class="s1">(lastInterleaved !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">interleaved = lastInterleaved;</span>

      <span class="s3">do </span><span class="s1">{</span>
        <span class="s1">newLanes = mergeLanes(newLanes, interleaved.lane);</span>
        <span class="s1">interleaved = interleaved.next;</span>
      <span class="s1">} </span><span class="s3">while </span><span class="s1">(interleaved !== lastInterleaved);</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(firstBaseUpdate === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// `queue.lanes` is used for entangling transitions. We can set it back to</span>
      <span class="s0">// zero once the queue is empty.</span>
      <span class="s1">queue.shared.lanes = NoLanes;</span>
    <span class="s1">} </span><span class="s0">// Set the remaining expiration time to be whatever is remaining in the queue.</span>
    <span class="s0">// This should be fine because the only two other things that contribute to</span>
    <span class="s0">// expiration time are props and context. We're already in the middle of the</span>
    <span class="s0">// begin phase by the time we start processing the queue, so we've already</span>
    <span class="s0">// dealt with the props. Context in components that specify</span>
    <span class="s0">// shouldComponentUpdate is tricky; but we'll have to account for</span>
    <span class="s0">// that regardless.</span>

    <span class="s1">markSkippedUpdateLanes(newLanes);</span>
    <span class="s1">workInProgress.lanes = newLanes;</span>
    <span class="s1">workInProgress.memoizedState = newState;</span>
  <span class="s1">}</span>

  <span class="s1">{</span>
    <span class="s1">currentlyProcessingQueue = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">callCallback(callback, context) {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">callback !== </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
    <span class="s3">throw new </span><span class="s1">Error(</span>
      <span class="s2">&quot;Invalid argument passed as callback. Expected a function. Instead &quot; </span><span class="s1">+</span>
        <span class="s1">(</span><span class="s2">&quot;received: &quot; </span><span class="s1">+ callback)</span>
    <span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s1">callback.call(context);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">resetHasForceUpdateBeforeProcessing() {</span>
  <span class="s1">hasForceUpdate = </span><span class="s3">false</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">checkHasForceUpdateAfterProcessing() {</span>
  <span class="s3">return </span><span class="s1">hasForceUpdate;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">commitUpdateQueue(finishedWork, finishedQueue, instance) {</span>
  <span class="s0">// Commit the effects</span>
  <span class="s3">var </span><span class="s1">effects = finishedQueue.effects;</span>
  <span class="s1">finishedQueue.effects = </span><span class="s3">null</span><span class="s1">;</span>

  <span class="s3">if </span><span class="s1">(effects !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; effects.length; i++) {</span>
      <span class="s3">var </span><span class="s1">effect = effects[i];</span>
      <span class="s3">var </span><span class="s1">callback = effect.callback;</span>

      <span class="s3">if </span><span class="s1">(callback !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">effect.callback = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">callCallback(callback, instance);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">fakeInternalInstance = {}; </span><span class="s0">// React.Component uses a shared frozen object by default.</span>
<span class="s0">// We'll use it to determine whether we need to initialize legacy refs.</span>

<span class="s3">var </span><span class="s1">emptyRefsObject = </span><span class="s3">new </span><span class="s1">React.Component().refs;</span>
<span class="s3">var </span><span class="s1">didWarnAboutStateAssignmentForComponent;</span>
<span class="s3">var </span><span class="s1">didWarnAboutUninitializedState;</span>
<span class="s3">var </span><span class="s1">didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;</span>
<span class="s3">var </span><span class="s1">didWarnAboutLegacyLifecyclesAndDerivedState;</span>
<span class="s3">var </span><span class="s1">didWarnAboutUndefinedDerivedState;</span>
<span class="s3">var </span><span class="s1">warnOnUndefinedDerivedState;</span>
<span class="s3">var </span><span class="s1">warnOnInvalidCallback;</span>
<span class="s3">var </span><span class="s1">didWarnAboutDirectlyAssigningPropsToState;</span>
<span class="s3">var </span><span class="s1">didWarnAboutContextTypeAndContextTypes;</span>
<span class="s3">var </span><span class="s1">didWarnAboutInvalidateContextType;</span>

<span class="s1">{</span>
  <span class="s1">didWarnAboutStateAssignmentForComponent = </span><span class="s3">new </span><span class="s1">Set();</span>
  <span class="s1">didWarnAboutUninitializedState = </span><span class="s3">new </span><span class="s1">Set();</span>
  <span class="s1">didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = </span><span class="s3">new </span><span class="s1">Set();</span>
  <span class="s1">didWarnAboutLegacyLifecyclesAndDerivedState = </span><span class="s3">new </span><span class="s1">Set();</span>
  <span class="s1">didWarnAboutDirectlyAssigningPropsToState = </span><span class="s3">new </span><span class="s1">Set();</span>
  <span class="s1">didWarnAboutUndefinedDerivedState = </span><span class="s3">new </span><span class="s1">Set();</span>
  <span class="s1">didWarnAboutContextTypeAndContextTypes = </span><span class="s3">new </span><span class="s1">Set();</span>
  <span class="s1">didWarnAboutInvalidateContextType = </span><span class="s3">new </span><span class="s1">Set();</span>
  <span class="s3">var </span><span class="s1">didWarnOnInvalidCallback = </span><span class="s3">new </span><span class="s1">Set();</span>

  <span class="s1">warnOnInvalidCallback = </span><span class="s3">function</span><span class="s1">(callback, callerName) {</span>
    <span class="s3">if </span><span class="s1">(callback === </span><span class="s3">null </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">callback === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">key = callerName + </span><span class="s2">&quot;_&quot; </span><span class="s1">+ callback;</span>

    <span class="s3">if </span><span class="s1">(!didWarnOnInvalidCallback.has(key)) {</span>
      <span class="s1">didWarnOnInvalidCallback.add(key);</span>

      <span class="s1">error(</span>
        <span class="s2">&quot;%s(...): Expected the last optional `callback` argument to be a &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;function. Instead received: %s.&quot;</span><span class="s1">,</span>
        <span class="s1">callerName,</span>
        <span class="s1">callback</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s1">warnOnUndefinedDerivedState = </span><span class="s3">function</span><span class="s1">(type, partialState) {</span>
    <span class="s3">if </span><span class="s1">(partialState === undefined) {</span>
      <span class="s3">var </span><span class="s1">componentName = getComponentNameFromType(type) || </span><span class="s2">&quot;Component&quot;</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s1">(!didWarnAboutUndefinedDerivedState.has(componentName)) {</span>
        <span class="s1">didWarnAboutUndefinedDerivedState.add(componentName);</span>

        <span class="s1">error(</span>
          <span class="s2">&quot;%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;You have returned undefined.&quot;</span><span class="s1">,</span>
          <span class="s1">componentName</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}; </span><span class="s0">// This is so gross but it's at least non-critical and can be removed if</span>
  <span class="s0">// it causes problems. This is meant to give a nicer error message for</span>
  <span class="s0">// ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,</span>
  <span class="s0">// ...)) which otherwise throws a &quot;_processChildContext is not a function&quot;</span>
  <span class="s0">// exception.</span>

  <span class="s1">Object.defineProperty(fakeInternalInstance, </span><span class="s2">&quot;_processChildContext&quot;</span><span class="s1">, {</span>
    <span class="s1">enumerable: </span><span class="s3">false</span><span class="s1">,</span>
    <span class="s1">value: </span><span class="s3">function</span><span class="s1">() {</span>
      <span class="s3">throw new </span><span class="s1">Error(</span>
        <span class="s2">&quot;_processChildContext is not available in React 16+. This likely &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;means you have multiple copies of React and are attempting to nest &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;a React 15 tree inside a React 16 tree using &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;unstable_renderSubtreeIntoContainer, which isn't supported. Try &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;to make sure you have only one copy of React (and ideally, switch &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;to ReactDOM.createPortal).&quot;</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">});</span>
  <span class="s1">Object.freeze(fakeInternalInstance);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">applyDerivedStateFromProps(</span>
  <span class="s1">workInProgress,</span>
  <span class="s1">ctor,</span>
  <span class="s1">getDerivedStateFromProps,</span>
  <span class="s1">nextProps</span>
<span class="s1">) {</span>
  <span class="s3">var </span><span class="s1">prevState = workInProgress.memoizedState;</span>
  <span class="s3">var </span><span class="s1">partialState = getDerivedStateFromProps(nextProps, prevState);</span>

  <span class="s1">{</span>
    <span class="s1">warnOnUndefinedDerivedState(ctor, partialState);</span>
  <span class="s1">} </span><span class="s0">// Merge the partial state and the previous state.</span>

  <span class="s3">var </span><span class="s1">memoizedState =</span>
    <span class="s1">partialState === </span><span class="s3">null </span><span class="s1">|| partialState === undefined</span>
      <span class="s1">? prevState</span>
      <span class="s1">: assign({}, prevState, partialState);</span>
  <span class="s1">workInProgress.memoizedState = memoizedState; </span><span class="s0">// Once the update queue is empty, persist the derived state onto the</span>
  <span class="s0">// base state.</span>

  <span class="s3">if </span><span class="s1">(workInProgress.lanes === NoLanes) {</span>
    <span class="s0">// Queue is always non-null for classes</span>
    <span class="s3">var </span><span class="s1">updateQueue = workInProgress.updateQueue;</span>
    <span class="s1">updateQueue.baseState = memoizedState;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">classComponentUpdater = {</span>
  <span class="s1">isMounted: isMounted,</span>
  <span class="s1">enqueueSetState: </span><span class="s3">function</span><span class="s1">(inst, payload, callback) {</span>
    <span class="s3">var </span><span class="s1">fiber = get(inst);</span>
    <span class="s3">var </span><span class="s1">eventTime = requestEventTime();</span>
    <span class="s3">var </span><span class="s1">lane = requestUpdateLane(fiber);</span>
    <span class="s3">var </span><span class="s1">update = createUpdate(eventTime, lane);</span>
    <span class="s1">update.payload = payload;</span>

    <span class="s3">if </span><span class="s1">(callback !== undefined &amp;&amp; callback !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">{</span>
        <span class="s1">warnOnInvalidCallback(callback, </span><span class="s2">&quot;setState&quot;</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s1">update.callback = callback;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">root = enqueueUpdate(fiber, update, lane);</span>

    <span class="s3">if </span><span class="s1">(root !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">scheduleUpdateOnFiber(root, fiber, lane, eventTime);</span>
      <span class="s1">entangleTransitions(root, fiber, lane);</span>
    <span class="s1">}</span>
  <span class="s1">},</span>
  <span class="s1">enqueueReplaceState: </span><span class="s3">function</span><span class="s1">(inst, payload, callback) {</span>
    <span class="s3">var </span><span class="s1">fiber = get(inst);</span>
    <span class="s3">var </span><span class="s1">eventTime = requestEventTime();</span>
    <span class="s3">var </span><span class="s1">lane = requestUpdateLane(fiber);</span>
    <span class="s3">var </span><span class="s1">update = createUpdate(eventTime, lane);</span>
    <span class="s1">update.tag = ReplaceState;</span>
    <span class="s1">update.payload = payload;</span>

    <span class="s3">if </span><span class="s1">(callback !== undefined &amp;&amp; callback !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">{</span>
        <span class="s1">warnOnInvalidCallback(callback, </span><span class="s2">&quot;replaceState&quot;</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s1">update.callback = callback;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">root = enqueueUpdate(fiber, update, lane);</span>

    <span class="s3">if </span><span class="s1">(root !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">scheduleUpdateOnFiber(root, fiber, lane, eventTime);</span>
      <span class="s1">entangleTransitions(root, fiber, lane);</span>
    <span class="s1">}</span>
  <span class="s1">},</span>
  <span class="s1">enqueueForceUpdate: </span><span class="s3">function</span><span class="s1">(inst, callback) {</span>
    <span class="s3">var </span><span class="s1">fiber = get(inst);</span>
    <span class="s3">var </span><span class="s1">eventTime = requestEventTime();</span>
    <span class="s3">var </span><span class="s1">lane = requestUpdateLane(fiber);</span>
    <span class="s3">var </span><span class="s1">update = createUpdate(eventTime, lane);</span>
    <span class="s1">update.tag = ForceUpdate;</span>

    <span class="s3">if </span><span class="s1">(callback !== undefined &amp;&amp; callback !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">{</span>
        <span class="s1">warnOnInvalidCallback(callback, </span><span class="s2">&quot;forceUpdate&quot;</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s1">update.callback = callback;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">root = enqueueUpdate(fiber, update, lane);</span>

    <span class="s3">if </span><span class="s1">(root !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">scheduleUpdateOnFiber(root, fiber, lane, eventTime);</span>
      <span class="s1">entangleTransitions(root, fiber, lane);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">};</span>

<span class="s3">function </span><span class="s1">checkShouldComponentUpdate(</span>
  <span class="s1">workInProgress,</span>
  <span class="s1">ctor,</span>
  <span class="s1">oldProps,</span>
  <span class="s1">newProps,</span>
  <span class="s1">oldState,</span>
  <span class="s1">newState,</span>
  <span class="s1">nextContext</span>
<span class="s1">) {</span>
  <span class="s3">var </span><span class="s1">instance = workInProgress.stateNode;</span>

  <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.shouldComponentUpdate === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">shouldUpdate = instance.shouldComponentUpdate(</span>
      <span class="s1">newProps,</span>
      <span class="s1">newState,</span>
      <span class="s1">nextContext</span>
    <span class="s1">);</span>

    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(shouldUpdate === undefined) {</span>
        <span class="s1">error(</span>
          <span class="s2">&quot;%s.shouldComponentUpdate(): Returned undefined instead of a &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;boolean value. Make sure to return true or false.&quot;</span><span class="s1">,</span>
          <span class="s1">getComponentNameFromType(ctor) || </span><span class="s2">&quot;Component&quot;</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">shouldUpdate;</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(ctor.prototype &amp;&amp; ctor.prototype.isPureReactComponent) {</span>
    <span class="s3">return </span><span class="s1">(</span>
      <span class="s1">!shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)</span>
    <span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s3">return true</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">checkClassInstance(workInProgress, ctor, newProps) {</span>
  <span class="s3">var </span><span class="s1">instance = workInProgress.stateNode;</span>

  <span class="s1">{</span>
    <span class="s3">var </span><span class="s1">name = getComponentNameFromType(ctor) || </span><span class="s2">&quot;Component&quot;</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">renderPresent = instance.render;</span>

    <span class="s3">if </span><span class="s1">(!renderPresent) {</span>
      <span class="s3">if </span><span class="s1">(ctor.prototype &amp;&amp; </span><span class="s3">typeof </span><span class="s1">ctor.prototype.render === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
        <span class="s1">error(</span>
          <span class="s2">&quot;%s(...): No `render` method found on the returned component &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;instance: did you accidentally return an object from the constructor?&quot;</span><span class="s1">,</span>
          <span class="s1">name</span>
        <span class="s1">);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">error(</span>
          <span class="s2">&quot;%s(...): No `render` method found on the returned component &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;instance: you may have forgotten to define `render`.&quot;</span><span class="s1">,</span>
          <span class="s1">name</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span>
      <span class="s1">instance.getInitialState &amp;&amp;</span>
      <span class="s1">!instance.getInitialState.isReactClassApproved &amp;&amp;</span>
      <span class="s1">!instance.state</span>
    <span class="s1">) {</span>
      <span class="s1">error(</span>
        <span class="s2">&quot;getInitialState was defined on %s, a plain JavaScript class. &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;This is only supported for classes created using React.createClass. &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;Did you mean to define a state property instead?&quot;</span><span class="s1">,</span>
        <span class="s1">name</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span>
      <span class="s1">instance.getDefaultProps &amp;&amp;</span>
      <span class="s1">!instance.getDefaultProps.isReactClassApproved</span>
    <span class="s1">) {</span>
      <span class="s1">error(</span>
        <span class="s2">&quot;getDefaultProps was defined on %s, a plain JavaScript class. &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;This is only supported for classes created using React.createClass. &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;Use a static property to define defaultProps instead.&quot;</span><span class="s1">,</span>
        <span class="s1">name</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(instance.propTypes) {</span>
      <span class="s1">error(</span>
        <span class="s2">&quot;propTypes was defined as an instance property on %s. Use a static &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;property to define propTypes instead.&quot;</span><span class="s1">,</span>
        <span class="s1">name</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(instance.contextType) {</span>
      <span class="s1">error(</span>
        <span class="s2">&quot;contextType was defined as an instance property on %s. Use a static &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;property to define contextType instead.&quot;</span><span class="s1">,</span>
        <span class="s1">name</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(instance.contextTypes) {</span>
        <span class="s1">error(</span>
          <span class="s2">&quot;contextTypes was defined as an instance property on %s. Use a static &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;property to define contextTypes instead.&quot;</span><span class="s1">,</span>
          <span class="s1">name</span>
        <span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(</span>
        <span class="s1">ctor.contextType &amp;&amp;</span>
        <span class="s1">ctor.contextTypes &amp;&amp;</span>
        <span class="s1">!didWarnAboutContextTypeAndContextTypes.has(ctor)</span>
      <span class="s1">) {</span>
        <span class="s1">didWarnAboutContextTypeAndContextTypes.add(ctor);</span>

        <span class="s1">error(</span>
          <span class="s2">&quot;%s declares both contextTypes and contextType static properties. &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;The legacy contextTypes property will be ignored.&quot;</span><span class="s1">,</span>
          <span class="s1">name</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.componentShouldUpdate === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
      <span class="s1">error(</span>
        <span class="s2">&quot;%s has a method called &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;componentShouldUpdate(). Did you mean shouldComponentUpdate()? &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;The name is phrased as a question because the function is &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;expected to return a value.&quot;</span><span class="s1">,</span>
        <span class="s1">name</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span>
      <span class="s1">ctor.prototype &amp;&amp;</span>
      <span class="s1">ctor.prototype.isPureReactComponent &amp;&amp;</span>
      <span class="s3">typeof </span><span class="s1">instance.shouldComponentUpdate !== </span><span class="s2">&quot;undefined&quot;</span>
    <span class="s1">) {</span>
      <span class="s1">error(</span>
        <span class="s2">&quot;%s has a method called shouldComponentUpdate(). &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;shouldComponentUpdate should not be used when extending React.PureComponent. &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;Please extend React.Component if shouldComponentUpdate is used.&quot;</span><span class="s1">,</span>
        <span class="s1">getComponentNameFromType(ctor) || </span><span class="s2">&quot;A pure component&quot;</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.componentDidUnmount === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
      <span class="s1">error(</span>
        <span class="s2">&quot;%s has a method called &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;componentDidUnmount(). But there is no such lifecycle method. &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;Did you mean componentWillUnmount()?&quot;</span><span class="s1">,</span>
        <span class="s1">name</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.componentDidReceiveProps === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
      <span class="s1">error(</span>
        <span class="s2">&quot;%s has a method called &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;componentDidReceiveProps(). But there is no such lifecycle method. &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;If you meant to update the state in response to changing props, &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;use componentWillReceiveProps(). If you meant to fetch data or &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;run side-effects or mutations after React has updated the UI, use componentDidUpdate().&quot;</span><span class="s1">,</span>
        <span class="s1">name</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.componentWillRecieveProps === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
      <span class="s1">error(</span>
        <span class="s2">&quot;%s has a method called &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;componentWillRecieveProps(). Did you mean componentWillReceiveProps()?&quot;</span><span class="s1">,</span>
        <span class="s1">name</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.UNSAFE_componentWillRecieveProps === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
      <span class="s1">error(</span>
        <span class="s2">&quot;%s has a method called &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?&quot;</span><span class="s1">,</span>
        <span class="s1">name</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">hasMutatedProps = instance.props !== newProps;</span>

    <span class="s3">if </span><span class="s1">(instance.props !== undefined &amp;&amp; hasMutatedProps) {</span>
      <span class="s1">error(</span>
        <span class="s2">&quot;%s(...): When calling super() in `%s`, make sure to pass &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;up the same props that your component's constructor was passed.&quot;</span><span class="s1">,</span>
        <span class="s1">name,</span>
        <span class="s1">name</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(instance.defaultProps) {</span>
      <span class="s1">error(</span>
        <span class="s2">&quot;Setting defaultProps as an instance property on %s is not supported and will be ignored.&quot; </span><span class="s1">+</span>
          <span class="s2">&quot; Instead, define defaultProps as a static property on %s.&quot;</span><span class="s1">,</span>
        <span class="s1">name,</span>
        <span class="s1">name</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span>
      <span class="s3">typeof </span><span class="s1">instance.getSnapshotBeforeUpdate === </span><span class="s2">&quot;function&quot; </span><span class="s1">&amp;&amp;</span>
      <span class="s3">typeof </span><span class="s1">instance.componentDidUpdate !== </span><span class="s2">&quot;function&quot; </span><span class="s1">&amp;&amp;</span>
      <span class="s1">!didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)</span>
    <span class="s1">) {</span>
      <span class="s1">didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);</span>

      <span class="s1">error(</span>
        <span class="s2">&quot;%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;This component defines getSnapshotBeforeUpdate() only.&quot;</span><span class="s1">,</span>
        <span class="s1">getComponentNameFromType(ctor)</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.getDerivedStateFromProps === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
      <span class="s1">error(</span>
        <span class="s2">&quot;%s: getDerivedStateFromProps() is defined as an instance method &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;and will be ignored. Instead, declare it as a static method.&quot;</span><span class="s1">,</span>
        <span class="s1">name</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.getDerivedStateFromError === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
      <span class="s1">error(</span>
        <span class="s2">&quot;%s: getDerivedStateFromError() is defined as an instance method &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;and will be ignored. Instead, declare it as a static method.&quot;</span><span class="s1">,</span>
        <span class="s1">name</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">ctor.getSnapshotBeforeUpdate === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
      <span class="s1">error(</span>
        <span class="s2">&quot;%s: getSnapshotBeforeUpdate() is defined as a static method &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;and will be ignored. Instead, declare it as an instance method.&quot;</span><span class="s1">,</span>
        <span class="s1">name</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">_state = instance.state;</span>

    <span class="s3">if </span><span class="s1">(_state &amp;&amp; (</span><span class="s3">typeof </span><span class="s1">_state !== </span><span class="s2">&quot;object&quot; </span><span class="s1">|| isArray(_state))) {</span>
      <span class="s1">error(</span><span class="s2">&quot;%s.state: must be set to an object or null&quot;</span><span class="s1">, name);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span>
      <span class="s3">typeof </span><span class="s1">instance.getChildContext === </span><span class="s2">&quot;function&quot; </span><span class="s1">&amp;&amp;</span>
      <span class="s3">typeof </span><span class="s1">ctor.childContextTypes !== </span><span class="s2">&quot;object&quot;</span>
    <span class="s1">) {</span>
      <span class="s1">error(</span>
        <span class="s2">&quot;%s.getChildContext(): childContextTypes must be defined in order to &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;use getChildContext().&quot;</span><span class="s1">,</span>
        <span class="s1">name</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">adoptClassInstance(workInProgress, instance) {</span>
  <span class="s1">instance.updater = classComponentUpdater;</span>
  <span class="s1">workInProgress.stateNode = instance; </span><span class="s0">// The instance needs access to the fiber so that it can schedule updates</span>

  <span class="s1">set(instance, workInProgress);</span>

  <span class="s1">{</span>
    <span class="s1">instance._reactInternalInstance = fakeInternalInstance;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">constructClassInstance(workInProgress, ctor, props) {</span>
  <span class="s3">var </span><span class="s1">isLegacyContextConsumer = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">unmaskedContext = emptyContextObject;</span>
  <span class="s3">var </span><span class="s1">context = emptyContextObject;</span>
  <span class="s3">var </span><span class="s1">contextType = ctor.contextType;</span>

  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s2">&quot;contextType&quot; </span><span class="s3">in </span><span class="s1">ctor) {</span>
      <span class="s3">var </span><span class="s1">isValid = </span><span class="s0">// Allow null for conditional declaration</span>
        <span class="s1">contextType === </span><span class="s3">null </span><span class="s1">||</span>
        <span class="s1">(contextType !== undefined &amp;&amp;</span>
          <span class="s1">contextType.$$typeof === REACT_CONTEXT_TYPE &amp;&amp;</span>
          <span class="s1">contextType._context === undefined); </span><span class="s0">// Not a &lt;Context.Consumer&gt;</span>

      <span class="s3">if </span><span class="s1">(!isValid &amp;&amp; !didWarnAboutInvalidateContextType.has(ctor)) {</span>
        <span class="s1">didWarnAboutInvalidateContextType.add(ctor);</span>
        <span class="s3">var </span><span class="s1">addendum = </span><span class="s2">&quot;&quot;</span><span class="s1">;</span>

        <span class="s3">if </span><span class="s1">(contextType === undefined) {</span>
          <span class="s1">addendum =</span>
            <span class="s2">&quot; However, it is set to undefined. &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;This can be caused by a typo or by mixing up named and default imports. &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;This can also happen due to a circular dependency, so &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;try moving the createContext() call to a separate file.&quot;</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">contextType !== </span><span class="s2">&quot;object&quot;</span><span class="s1">) {</span>
          <span class="s1">addendum = </span><span class="s2">&quot; However, it is set to a &quot; </span><span class="s1">+ </span><span class="s3">typeof </span><span class="s1">contextType + </span><span class="s2">&quot;.&quot;</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(contextType.$$typeof === REACT_PROVIDER_TYPE) {</span>
          <span class="s1">addendum = </span><span class="s2">&quot; Did you accidentally pass the Context.Provider instead?&quot;</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(contextType._context !== undefined) {</span>
          <span class="s0">// &lt;Context.Consumer&gt;</span>
          <span class="s1">addendum = </span><span class="s2">&quot; Did you accidentally pass the Context.Consumer instead?&quot;</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s1">addendum =</span>
            <span class="s2">&quot; However, it is set to an object with keys {&quot; </span><span class="s1">+</span>
            <span class="s1">Object.keys(contextType).join(</span><span class="s2">&quot;, &quot;</span><span class="s1">) +</span>
            <span class="s2">&quot;}.&quot;</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">error(</span>
          <span class="s2">&quot;%s defines an invalid contextType. &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;contextType should point to the Context object returned by React.createContext().%s&quot;</span><span class="s1">,</span>
          <span class="s1">getComponentNameFromType(ctor) || </span><span class="s2">&quot;Component&quot;</span><span class="s1">,</span>
          <span class="s1">addendum</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">contextType === </span><span class="s2">&quot;object&quot; </span><span class="s1">&amp;&amp; contextType !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s1">context = readContext(contextType);</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">unmaskedContext = getUnmaskedContext(workInProgress, ctor, </span><span class="s3">true</span><span class="s1">);</span>
    <span class="s3">var </span><span class="s1">contextTypes = ctor.contextTypes;</span>
    <span class="s1">isLegacyContextConsumer =</span>
      <span class="s1">contextTypes !== </span><span class="s3">null </span><span class="s1">&amp;&amp; contextTypes !== undefined;</span>
    <span class="s1">context = isLegacyContextConsumer</span>
      <span class="s1">? getMaskedContext(workInProgress, unmaskedContext)</span>
      <span class="s1">: emptyContextObject;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">instance = </span><span class="s3">new </span><span class="s1">ctor(props, context); </span><span class="s0">// Instantiate twice to help detect side-effects.</span>

  <span class="s3">var </span><span class="s1">state = (workInProgress.memoizedState =</span>
    <span class="s1">instance.state !== </span><span class="s3">null </span><span class="s1">&amp;&amp; instance.state !== undefined</span>
      <span class="s1">? instance.state</span>
      <span class="s1">: </span><span class="s3">null</span><span class="s1">);</span>
  <span class="s1">adoptClassInstance(workInProgress, instance);</span>

  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">ctor.getDerivedStateFromProps === </span><span class="s2">&quot;function&quot; </span><span class="s1">&amp;&amp; state === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">componentName = getComponentNameFromType(ctor) || </span><span class="s2">&quot;Component&quot;</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s1">(!didWarnAboutUninitializedState.has(componentName)) {</span>
        <span class="s1">didWarnAboutUninitializedState.add(componentName);</span>

        <span class="s1">error(</span>
          <span class="s2">&quot;`%s` uses `getDerivedStateFromProps` but its initial state is &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;%s. This is not recommended. Instead, define the initial state by &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;assigning an object to `this.state` in the constructor of `%s`. &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;This ensures that `getDerivedStateFromProps` arguments have a consistent shape.&quot;</span><span class="s1">,</span>
          <span class="s1">componentName,</span>
          <span class="s1">instance.state === </span><span class="s3">null </span><span class="s1">? </span><span class="s2">&quot;null&quot; </span><span class="s1">: </span><span class="s2">&quot;undefined&quot;</span><span class="s1">,</span>
          <span class="s1">componentName</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// If new component APIs are defined, &quot;unsafe&quot; lifecycles won't be called.</span>
    <span class="s0">// Warn about these lifecycles if they are present.</span>
    <span class="s0">// Don't warn about react-lifecycles-compat polyfilled methods though.</span>

    <span class="s3">if </span><span class="s1">(</span>
      <span class="s3">typeof </span><span class="s1">ctor.getDerivedStateFromProps === </span><span class="s2">&quot;function&quot; </span><span class="s1">||</span>
      <span class="s3">typeof </span><span class="s1">instance.getSnapshotBeforeUpdate === </span><span class="s2">&quot;function&quot;</span>
    <span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">foundWillMountName = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s3">var </span><span class="s1">foundWillReceivePropsName = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s3">var </span><span class="s1">foundWillUpdateName = </span><span class="s3">null</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s1">(</span>
        <span class="s3">typeof </span><span class="s1">instance.componentWillMount === </span><span class="s2">&quot;function&quot; </span><span class="s1">&amp;&amp;</span>
        <span class="s1">instance.componentWillMount.__suppressDeprecationWarning !== </span><span class="s3">true</span>
      <span class="s1">) {</span>
        <span class="s1">foundWillMountName = </span><span class="s2">&quot;componentWillMount&quot;</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.UNSAFE_componentWillMount === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
        <span class="s1">foundWillMountName = </span><span class="s2">&quot;UNSAFE_componentWillMount&quot;</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(</span>
        <span class="s3">typeof </span><span class="s1">instance.componentWillReceiveProps === </span><span class="s2">&quot;function&quot; </span><span class="s1">&amp;&amp;</span>
        <span class="s1">instance.componentWillReceiveProps.__suppressDeprecationWarning !== </span><span class="s3">true</span>
      <span class="s1">) {</span>
        <span class="s1">foundWillReceivePropsName = </span><span class="s2">&quot;componentWillReceiveProps&quot;</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span>
        <span class="s3">typeof </span><span class="s1">instance.UNSAFE_componentWillReceiveProps === </span><span class="s2">&quot;function&quot;</span>
      <span class="s1">) {</span>
        <span class="s1">foundWillReceivePropsName = </span><span class="s2">&quot;UNSAFE_componentWillReceiveProps&quot;</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(</span>
        <span class="s3">typeof </span><span class="s1">instance.componentWillUpdate === </span><span class="s2">&quot;function&quot; </span><span class="s1">&amp;&amp;</span>
        <span class="s1">instance.componentWillUpdate.__suppressDeprecationWarning !== </span><span class="s3">true</span>
      <span class="s1">) {</span>
        <span class="s1">foundWillUpdateName = </span><span class="s2">&quot;componentWillUpdate&quot;</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.UNSAFE_componentWillUpdate === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
        <span class="s1">foundWillUpdateName = </span><span class="s2">&quot;UNSAFE_componentWillUpdate&quot;</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(</span>
        <span class="s1">foundWillMountName !== </span><span class="s3">null </span><span class="s1">||</span>
        <span class="s1">foundWillReceivePropsName !== </span><span class="s3">null </span><span class="s1">||</span>
        <span class="s1">foundWillUpdateName !== </span><span class="s3">null</span>
      <span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">_componentName = getComponentNameFromType(ctor) || </span><span class="s2">&quot;Component&quot;</span><span class="s1">;</span>

        <span class="s3">var </span><span class="s1">newApiName =</span>
          <span class="s3">typeof </span><span class="s1">ctor.getDerivedStateFromProps === </span><span class="s2">&quot;function&quot;</span>
            <span class="s1">? </span><span class="s2">&quot;getDerivedStateFromProps()&quot;</span>
            <span class="s1">: </span><span class="s2">&quot;getSnapshotBeforeUpdate()&quot;</span><span class="s1">;</span>

        <span class="s3">if </span><span class="s1">(!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {</span>
          <span class="s1">didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);</span>

          <span class="s1">error(</span>
            <span class="s2">&quot;Unsafe legacy lifecycles will not be called for components using new component APIs.</span><span class="s5">\n\n</span><span class="s2">&quot; </span><span class="s1">+</span>
              <span class="s2">&quot;%s uses %s but also contains the following legacy lifecycles:%s%s%s</span><span class="s5">\n\n</span><span class="s2">&quot; </span><span class="s1">+</span>
              <span class="s2">&quot;The above lifecycles should be removed. Learn more about this warning here:</span><span class="s5">\n</span><span class="s2">&quot; </span><span class="s1">+</span>
              <span class="s2">&quot;https://reactjs.org/link/unsafe-component-lifecycles&quot;</span><span class="s1">,</span>
            <span class="s1">_componentName,</span>
            <span class="s1">newApiName,</span>
            <span class="s1">foundWillMountName !== </span><span class="s3">null </span><span class="s1">? </span><span class="s2">&quot;</span><span class="s5">\n  </span><span class="s2">&quot; </span><span class="s1">+ foundWillMountName : </span><span class="s2">&quot;&quot;</span><span class="s1">,</span>
            <span class="s1">foundWillReceivePropsName !== </span><span class="s3">null</span>
              <span class="s1">? </span><span class="s2">&quot;</span><span class="s5">\n  </span><span class="s2">&quot; </span><span class="s1">+ foundWillReceivePropsName</span>
              <span class="s1">: </span><span class="s2">&quot;&quot;</span><span class="s1">,</span>
            <span class="s1">foundWillUpdateName !== </span><span class="s3">null </span><span class="s1">? </span><span class="s2">&quot;</span><span class="s5">\n  </span><span class="s2">&quot; </span><span class="s1">+ foundWillUpdateName : </span><span class="s2">&quot;&quot;</span>
          <span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s0">// Cache unmasked context so we can avoid recreating masked context unless necessary.</span>
  <span class="s0">// ReactFiberContext usually updates this cache but can't for newly-created instances.</span>

  <span class="s3">if </span><span class="s1">(isLegacyContextConsumer) {</span>
    <span class="s1">cacheContext(workInProgress, unmaskedContext, context);</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">instance;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">callComponentWillMount(workInProgress, instance) {</span>
  <span class="s3">var </span><span class="s1">oldState = instance.state;</span>

  <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.componentWillMount === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
    <span class="s1">instance.componentWillMount();</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.UNSAFE_componentWillMount === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
    <span class="s1">instance.UNSAFE_componentWillMount();</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(oldState !== instance.state) {</span>
    <span class="s1">{</span>
      <span class="s1">error(</span>
        <span class="s2">&quot;%s.componentWillMount(): Assigning directly to this.state is &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;deprecated (except inside a component's &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;constructor). Use setState instead.&quot;</span><span class="s1">,</span>
        <span class="s1">getComponentNameFromFiber(workInProgress) || </span><span class="s2">&quot;Component&quot;</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s1">classComponentUpdater.enqueueReplaceState(instance, instance.state, </span><span class="s3">null</span><span class="s1">);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">callComponentWillReceiveProps(</span>
  <span class="s1">workInProgress,</span>
  <span class="s1">instance,</span>
  <span class="s1">newProps,</span>
  <span class="s1">nextContext</span>
<span class="s1">) {</span>
  <span class="s3">var </span><span class="s1">oldState = instance.state;</span>

  <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.componentWillReceiveProps === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
    <span class="s1">instance.componentWillReceiveProps(newProps, nextContext);</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.UNSAFE_componentWillReceiveProps === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
    <span class="s1">instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(instance.state !== oldState) {</span>
    <span class="s1">{</span>
      <span class="s3">var </span><span class="s1">componentName =</span>
        <span class="s1">getComponentNameFromFiber(workInProgress) || </span><span class="s2">&quot;Component&quot;</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s1">(!didWarnAboutStateAssignmentForComponent.has(componentName)) {</span>
        <span class="s1">didWarnAboutStateAssignmentForComponent.add(componentName);</span>

        <span class="s1">error(</span>
          <span class="s2">&quot;%s.componentWillReceiveProps(): Assigning directly to &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;this.state is deprecated (except inside a component's &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;constructor). Use setState instead.&quot;</span><span class="s1">,</span>
          <span class="s1">componentName</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">classComponentUpdater.enqueueReplaceState(instance, instance.state, </span><span class="s3">null</span><span class="s1">);</span>
  <span class="s1">}</span>
<span class="s1">} </span><span class="s0">// Invokes the mount life-cycles on a previously never rendered instance.</span>

<span class="s3">function </span><span class="s1">mountClassInstance(workInProgress, ctor, newProps, renderLanes) {</span>
  <span class="s1">{</span>
    <span class="s1">checkClassInstance(workInProgress, ctor, newProps);</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">instance = workInProgress.stateNode;</span>
  <span class="s1">instance.props = newProps;</span>
  <span class="s1">instance.state = workInProgress.memoizedState;</span>
  <span class="s1">instance.refs = emptyRefsObject;</span>
  <span class="s1">initializeUpdateQueue(workInProgress);</span>
  <span class="s3">var </span><span class="s1">contextType = ctor.contextType;</span>

  <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">contextType === </span><span class="s2">&quot;object&quot; </span><span class="s1">&amp;&amp; contextType !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s1">instance.context = readContext(contextType);</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s3">var </span><span class="s1">unmaskedContext = getUnmaskedContext(workInProgress, ctor, </span><span class="s3">true</span><span class="s1">);</span>
    <span class="s1">instance.context = getMaskedContext(workInProgress, unmaskedContext);</span>
  <span class="s1">}</span>

  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(instance.state === newProps) {</span>
      <span class="s3">var </span><span class="s1">componentName = getComponentNameFromType(ctor) || </span><span class="s2">&quot;Component&quot;</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s1">(!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {</span>
        <span class="s1">didWarnAboutDirectlyAssigningPropsToState.add(componentName);</span>

        <span class="s1">error(</span>
          <span class="s2">&quot;%s: It is not recommended to assign props directly to state &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;because updates to props won't be reflected in state. &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;In most cases, it is better to use props directly.&quot;</span><span class="s1">,</span>
          <span class="s1">componentName</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(workInProgress.mode &amp; StrictLegacyMode) {</span>
      <span class="s1">ReactStrictModeWarnings.recordLegacyContextWarning(</span>
        <span class="s1">workInProgress,</span>
        <span class="s1">instance</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s1">ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(</span>
        <span class="s1">workInProgress,</span>
        <span class="s1">instance</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">instance.state = workInProgress.memoizedState;</span>
  <span class="s3">var </span><span class="s1">getDerivedStateFromProps = ctor.getDerivedStateFromProps;</span>

  <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">getDerivedStateFromProps === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
    <span class="s1">applyDerivedStateFromProps(</span>
      <span class="s1">workInProgress,</span>
      <span class="s1">ctor,</span>
      <span class="s1">getDerivedStateFromProps,</span>
      <span class="s1">newProps</span>
    <span class="s1">);</span>
    <span class="s1">instance.state = workInProgress.memoizedState;</span>
  <span class="s1">} </span><span class="s0">// In order to support react-lifecycles-compat polyfilled components,</span>
  <span class="s0">// Unsafe lifecycles should not be invoked for components using the new APIs.</span>

  <span class="s3">if </span><span class="s1">(</span>
    <span class="s3">typeof </span><span class="s1">ctor.getDerivedStateFromProps !== </span><span class="s2">&quot;function&quot; </span><span class="s1">&amp;&amp;</span>
    <span class="s3">typeof </span><span class="s1">instance.getSnapshotBeforeUpdate !== </span><span class="s2">&quot;function&quot; </span><span class="s1">&amp;&amp;</span>
    <span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.UNSAFE_componentWillMount === </span><span class="s2">&quot;function&quot; </span><span class="s1">||</span>
      <span class="s3">typeof </span><span class="s1">instance.componentWillMount === </span><span class="s2">&quot;function&quot;</span><span class="s1">)</span>
  <span class="s1">) {</span>
    <span class="s1">callComponentWillMount(workInProgress, instance); </span><span class="s0">// If we had additional state updates during this life-cycle, let's</span>
    <span class="s0">// process them now.</span>

    <span class="s1">processUpdateQueue(workInProgress, newProps, instance, renderLanes);</span>
    <span class="s1">instance.state = workInProgress.memoizedState;</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.componentDidMount === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">fiberFlags = Update;</span>

    <span class="s1">workInProgress.flags |= fiberFlags;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">resumeMountClassInstance(workInProgress, ctor, newProps, renderLanes) {</span>
  <span class="s3">var </span><span class="s1">instance = workInProgress.stateNode;</span>
  <span class="s3">var </span><span class="s1">oldProps = workInProgress.memoizedProps;</span>
  <span class="s1">instance.props = oldProps;</span>
  <span class="s3">var </span><span class="s1">oldContext = instance.context;</span>
  <span class="s3">var </span><span class="s1">contextType = ctor.contextType;</span>
  <span class="s3">var </span><span class="s1">nextContext = emptyContextObject;</span>

  <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">contextType === </span><span class="s2">&quot;object&quot; </span><span class="s1">&amp;&amp; contextType !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s1">nextContext = readContext(contextType);</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s3">var </span><span class="s1">nextLegacyUnmaskedContext = getUnmaskedContext(</span>
      <span class="s1">workInProgress,</span>
      <span class="s1">ctor,</span>
      <span class="s3">true</span>
    <span class="s1">);</span>
    <span class="s1">nextContext = getMaskedContext(workInProgress, nextLegacyUnmaskedContext);</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">getDerivedStateFromProps = ctor.getDerivedStateFromProps;</span>
  <span class="s3">var </span><span class="s1">hasNewLifecycles =</span>
    <span class="s3">typeof </span><span class="s1">getDerivedStateFromProps === </span><span class="s2">&quot;function&quot; </span><span class="s1">||</span>
    <span class="s3">typeof </span><span class="s1">instance.getSnapshotBeforeUpdate === </span><span class="s2">&quot;function&quot;</span><span class="s1">; </span><span class="s0">// Note: During these life-cycles, instance.props/instance.state are what</span>
  <span class="s0">// ever the previously attempted to render - not the &quot;current&quot;. However,</span>
  <span class="s0">// during componentDidUpdate we pass the &quot;current&quot; props.</span>
  <span class="s0">// In order to support react-lifecycles-compat polyfilled components,</span>
  <span class="s0">// Unsafe lifecycles should not be invoked for components using the new APIs.</span>

  <span class="s3">if </span><span class="s1">(</span>
    <span class="s1">!hasNewLifecycles &amp;&amp;</span>
    <span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.UNSAFE_componentWillReceiveProps === </span><span class="s2">&quot;function&quot; </span><span class="s1">||</span>
      <span class="s3">typeof </span><span class="s1">instance.componentWillReceiveProps === </span><span class="s2">&quot;function&quot;</span><span class="s1">)</span>
  <span class="s1">) {</span>
    <span class="s3">if </span><span class="s1">(oldProps !== newProps || oldContext !== nextContext) {</span>
      <span class="s1">callComponentWillReceiveProps(</span>
        <span class="s1">workInProgress,</span>
        <span class="s1">instance,</span>
        <span class="s1">newProps,</span>
        <span class="s1">nextContext</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">resetHasForceUpdateBeforeProcessing();</span>
  <span class="s3">var </span><span class="s1">oldState = workInProgress.memoizedState;</span>
  <span class="s3">var </span><span class="s1">newState = (instance.state = oldState);</span>
  <span class="s1">processUpdateQueue(workInProgress, newProps, instance, renderLanes);</span>
  <span class="s1">newState = workInProgress.memoizedState;</span>

  <span class="s3">if </span><span class="s1">(</span>
    <span class="s1">oldProps === newProps &amp;&amp;</span>
    <span class="s1">oldState === newState &amp;&amp;</span>
    <span class="s1">!hasContextChanged() &amp;&amp;</span>
    <span class="s1">!checkHasForceUpdateAfterProcessing()</span>
  <span class="s1">) {</span>
    <span class="s0">// If an update was already in progress, we should schedule an Update</span>
    <span class="s0">// effect even though we're bailing out, so that cWU/cDU are called.</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.componentDidMount === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">fiberFlags = Update;</span>

      <span class="s1">workInProgress.flags |= fiberFlags;</span>
    <span class="s1">}</span>

    <span class="s3">return false</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">getDerivedStateFromProps === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
    <span class="s1">applyDerivedStateFromProps(</span>
      <span class="s1">workInProgress,</span>
      <span class="s1">ctor,</span>
      <span class="s1">getDerivedStateFromProps,</span>
      <span class="s1">newProps</span>
    <span class="s1">);</span>
    <span class="s1">newState = workInProgress.memoizedState;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">shouldUpdate =</span>
    <span class="s1">checkHasForceUpdateAfterProcessing() ||</span>
    <span class="s1">checkShouldComponentUpdate(</span>
      <span class="s1">workInProgress,</span>
      <span class="s1">ctor,</span>
      <span class="s1">oldProps,</span>
      <span class="s1">newProps,</span>
      <span class="s1">oldState,</span>
      <span class="s1">newState,</span>
      <span class="s1">nextContext</span>
    <span class="s1">);</span>

  <span class="s3">if </span><span class="s1">(shouldUpdate) {</span>
    <span class="s0">// In order to support react-lifecycles-compat polyfilled components,</span>
    <span class="s0">// Unsafe lifecycles should not be invoked for components using the new APIs.</span>
    <span class="s3">if </span><span class="s1">(</span>
      <span class="s1">!hasNewLifecycles &amp;&amp;</span>
      <span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.UNSAFE_componentWillMount === </span><span class="s2">&quot;function&quot; </span><span class="s1">||</span>
        <span class="s3">typeof </span><span class="s1">instance.componentWillMount === </span><span class="s2">&quot;function&quot;</span><span class="s1">)</span>
    <span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.componentWillMount === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
        <span class="s1">instance.componentWillMount();</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.UNSAFE_componentWillMount === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
        <span class="s1">instance.UNSAFE_componentWillMount();</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.componentDidMount === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">_fiberFlags = Update;</span>

      <span class="s1">workInProgress.flags |= _fiberFlags;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s0">// If an update was already in progress, we should schedule an Update</span>
    <span class="s0">// effect even though we're bailing out, so that cWU/cDU are called.</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.componentDidMount === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">_fiberFlags2 = Update;</span>

      <span class="s1">workInProgress.flags |= _fiberFlags2;</span>
    <span class="s1">} </span><span class="s0">// If shouldComponentUpdate returned false, we should still update the</span>
    <span class="s0">// memoized state to indicate that this work can be reused.</span>

    <span class="s1">workInProgress.memoizedProps = newProps;</span>
    <span class="s1">workInProgress.memoizedState = newState;</span>
  <span class="s1">} </span><span class="s0">// Update the existing instance's state, props, and context pointers even</span>
  <span class="s0">// if shouldComponentUpdate returns false.</span>

  <span class="s1">instance.props = newProps;</span>
  <span class="s1">instance.state = newState;</span>
  <span class="s1">instance.context = nextContext;</span>
  <span class="s3">return </span><span class="s1">shouldUpdate;</span>
<span class="s1">} </span><span class="s0">// Invokes the update life-cycles and returns false if it shouldn't rerender.</span>

<span class="s3">function </span><span class="s1">updateClassInstance(</span>
  <span class="s1">current,</span>
  <span class="s1">workInProgress,</span>
  <span class="s1">ctor,</span>
  <span class="s1">newProps,</span>
  <span class="s1">renderLanes</span>
<span class="s1">) {</span>
  <span class="s3">var </span><span class="s1">instance = workInProgress.stateNode;</span>
  <span class="s1">cloneUpdateQueue(current, workInProgress);</span>
  <span class="s3">var </span><span class="s1">unresolvedOldProps = workInProgress.memoizedProps;</span>
  <span class="s3">var </span><span class="s1">oldProps =</span>
    <span class="s1">workInProgress.type === workInProgress.elementType</span>
      <span class="s1">? unresolvedOldProps</span>
      <span class="s1">: resolveDefaultProps(workInProgress.type, unresolvedOldProps);</span>
  <span class="s1">instance.props = oldProps;</span>
  <span class="s3">var </span><span class="s1">unresolvedNewProps = workInProgress.pendingProps;</span>
  <span class="s3">var </span><span class="s1">oldContext = instance.context;</span>
  <span class="s3">var </span><span class="s1">contextType = ctor.contextType;</span>
  <span class="s3">var </span><span class="s1">nextContext = emptyContextObject;</span>

  <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">contextType === </span><span class="s2">&quot;object&quot; </span><span class="s1">&amp;&amp; contextType !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s1">nextContext = readContext(contextType);</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s3">var </span><span class="s1">nextUnmaskedContext = getUnmaskedContext(workInProgress, ctor, </span><span class="s3">true</span><span class="s1">);</span>
    <span class="s1">nextContext = getMaskedContext(workInProgress, nextUnmaskedContext);</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">getDerivedStateFromProps = ctor.getDerivedStateFromProps;</span>
  <span class="s3">var </span><span class="s1">hasNewLifecycles =</span>
    <span class="s3">typeof </span><span class="s1">getDerivedStateFromProps === </span><span class="s2">&quot;function&quot; </span><span class="s1">||</span>
    <span class="s3">typeof </span><span class="s1">instance.getSnapshotBeforeUpdate === </span><span class="s2">&quot;function&quot;</span><span class="s1">; </span><span class="s0">// Note: During these life-cycles, instance.props/instance.state are what</span>
  <span class="s0">// ever the previously attempted to render - not the &quot;current&quot;. However,</span>
  <span class="s0">// during componentDidUpdate we pass the &quot;current&quot; props.</span>
  <span class="s0">// In order to support react-lifecycles-compat polyfilled components,</span>
  <span class="s0">// Unsafe lifecycles should not be invoked for components using the new APIs.</span>

  <span class="s3">if </span><span class="s1">(</span>
    <span class="s1">!hasNewLifecycles &amp;&amp;</span>
    <span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.UNSAFE_componentWillReceiveProps === </span><span class="s2">&quot;function&quot; </span><span class="s1">||</span>
      <span class="s3">typeof </span><span class="s1">instance.componentWillReceiveProps === </span><span class="s2">&quot;function&quot;</span><span class="s1">)</span>
  <span class="s1">) {</span>
    <span class="s3">if </span><span class="s1">(</span>
      <span class="s1">unresolvedOldProps !== unresolvedNewProps ||</span>
      <span class="s1">oldContext !== nextContext</span>
    <span class="s1">) {</span>
      <span class="s1">callComponentWillReceiveProps(</span>
        <span class="s1">workInProgress,</span>
        <span class="s1">instance,</span>
        <span class="s1">newProps,</span>
        <span class="s1">nextContext</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">resetHasForceUpdateBeforeProcessing();</span>
  <span class="s3">var </span><span class="s1">oldState = workInProgress.memoizedState;</span>
  <span class="s3">var </span><span class="s1">newState = (instance.state = oldState);</span>
  <span class="s1">processUpdateQueue(workInProgress, newProps, instance, renderLanes);</span>
  <span class="s1">newState = workInProgress.memoizedState;</span>

  <span class="s3">if </span><span class="s1">(</span>
    <span class="s1">unresolvedOldProps === unresolvedNewProps &amp;&amp;</span>
    <span class="s1">oldState === newState &amp;&amp;</span>
    <span class="s1">!hasContextChanged() &amp;&amp;</span>
    <span class="s1">!checkHasForceUpdateAfterProcessing() &amp;&amp;</span>
    <span class="s1">!enableLazyContextPropagation</span>
  <span class="s1">) {</span>
    <span class="s0">// If an update was already in progress, we should schedule an Update</span>
    <span class="s0">// effect even though we're bailing out, so that cWU/cDU are called.</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.componentDidUpdate === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(</span>
        <span class="s1">unresolvedOldProps !== current.memoizedProps ||</span>
        <span class="s1">oldState !== current.memoizedState</span>
      <span class="s1">) {</span>
        <span class="s1">workInProgress.flags |= Update;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.getSnapshotBeforeUpdate === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(</span>
        <span class="s1">unresolvedOldProps !== current.memoizedProps ||</span>
        <span class="s1">oldState !== current.memoizedState</span>
      <span class="s1">) {</span>
        <span class="s1">workInProgress.flags |= Snapshot;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return false</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">getDerivedStateFromProps === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
    <span class="s1">applyDerivedStateFromProps(</span>
      <span class="s1">workInProgress,</span>
      <span class="s1">ctor,</span>
      <span class="s1">getDerivedStateFromProps,</span>
      <span class="s1">newProps</span>
    <span class="s1">);</span>
    <span class="s1">newState = workInProgress.memoizedState;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">shouldUpdate =</span>
    <span class="s1">checkHasForceUpdateAfterProcessing() ||</span>
    <span class="s1">checkShouldComponentUpdate(</span>
      <span class="s1">workInProgress,</span>
      <span class="s1">ctor,</span>
      <span class="s1">oldProps,</span>
      <span class="s1">newProps,</span>
      <span class="s1">oldState,</span>
      <span class="s1">newState,</span>
      <span class="s1">nextContext</span>
    <span class="s1">) || </span><span class="s0">// TODO: In some cases, we'll end up checking if context has changed twice,</span>
    <span class="s0">// both before and after `shouldComponentUpdate` has been called. Not ideal,</span>
    <span class="s0">// but I'm loath to refactor this function. This only happens for memoized</span>
    <span class="s0">// components so it's not that common.</span>
    <span class="s1">enableLazyContextPropagation;</span>

  <span class="s3">if </span><span class="s1">(shouldUpdate) {</span>
    <span class="s0">// In order to support react-lifecycles-compat polyfilled components,</span>
    <span class="s0">// Unsafe lifecycles should not be invoked for components using the new APIs.</span>
    <span class="s3">if </span><span class="s1">(</span>
      <span class="s1">!hasNewLifecycles &amp;&amp;</span>
      <span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.UNSAFE_componentWillUpdate === </span><span class="s2">&quot;function&quot; </span><span class="s1">||</span>
        <span class="s3">typeof </span><span class="s1">instance.componentWillUpdate === </span><span class="s2">&quot;function&quot;</span><span class="s1">)</span>
    <span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.componentWillUpdate === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
        <span class="s1">instance.componentWillUpdate(newProps, newState, nextContext);</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.UNSAFE_componentWillUpdate === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
        <span class="s1">instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.componentDidUpdate === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
      <span class="s1">workInProgress.flags |= Update;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.getSnapshotBeforeUpdate === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
      <span class="s1">workInProgress.flags |= Snapshot;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s0">// If an update was already in progress, we should schedule an Update</span>
    <span class="s0">// effect even though we're bailing out, so that cWU/cDU are called.</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.componentDidUpdate === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(</span>
        <span class="s1">unresolvedOldProps !== current.memoizedProps ||</span>
        <span class="s1">oldState !== current.memoizedState</span>
      <span class="s1">) {</span>
        <span class="s1">workInProgress.flags |= Update;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.getSnapshotBeforeUpdate === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(</span>
        <span class="s1">unresolvedOldProps !== current.memoizedProps ||</span>
        <span class="s1">oldState !== current.memoizedState</span>
      <span class="s1">) {</span>
        <span class="s1">workInProgress.flags |= Snapshot;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// If shouldComponentUpdate returned false, we should still update the</span>
    <span class="s0">// memoized props/state to indicate that this work can be reused.</span>

    <span class="s1">workInProgress.memoizedProps = newProps;</span>
    <span class="s1">workInProgress.memoizedState = newState;</span>
  <span class="s1">} </span><span class="s0">// Update the existing instance's state, props, and context pointers even</span>
  <span class="s0">// if shouldComponentUpdate returns false.</span>

  <span class="s1">instance.props = newProps;</span>
  <span class="s1">instance.state = newState;</span>
  <span class="s1">instance.context = nextContext;</span>
  <span class="s3">return </span><span class="s1">shouldUpdate;</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">didWarnAboutMaps;</span>
<span class="s3">var </span><span class="s1">didWarnAboutGenerators;</span>
<span class="s3">var </span><span class="s1">didWarnAboutStringRefs;</span>
<span class="s3">var </span><span class="s1">ownerHasKeyUseWarning;</span>
<span class="s3">var </span><span class="s1">ownerHasFunctionTypeWarning;</span>

<span class="s3">var </span><span class="s1">warnForMissingKey = </span><span class="s3">function</span><span class="s1">(child, returnFiber) {};</span>

<span class="s1">{</span>
  <span class="s1">didWarnAboutMaps = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s1">didWarnAboutGenerators = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s1">didWarnAboutStringRefs = {};</span>
  <span class="s0">/** 
   * Warn if there's no key explicitly set on dynamic arrays of children or 
   * object keys are not valid. This allows us to keep track of children between 
   * updates. 
   */</span>

  <span class="s1">ownerHasKeyUseWarning = {};</span>
  <span class="s1">ownerHasFunctionTypeWarning = {};</span>

  <span class="s1">warnForMissingKey = </span><span class="s3">function</span><span class="s1">(child, returnFiber) {</span>
    <span class="s3">if </span><span class="s1">(child === </span><span class="s3">null </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">child !== </span><span class="s2">&quot;object&quot;</span><span class="s1">) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(!child._store || child._store.validated || child.key != </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">child._store !== </span><span class="s2">&quot;object&quot;</span><span class="s1">) {</span>
      <span class="s3">throw new </span><span class="s1">Error(</span>
        <span class="s2">&quot;React Component in warnForMissingKey should have a _store. &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;This error is likely caused by a bug in React. Please file an issue.&quot;</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s1">child._store.validated = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">componentName = getComponentNameFromFiber(returnFiber) || </span><span class="s2">&quot;Component&quot;</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s1">(ownerHasKeyUseWarning[componentName]) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">ownerHasKeyUseWarning[componentName] = </span><span class="s3">true</span><span class="s1">;</span>

    <span class="s1">error(</span>
      <span class="s2">&quot;Each child in a list should have a unique &quot; </span><span class="s1">+</span>
        <span class="s2">'&quot;key&quot; prop. See https://reactjs.org/link/warning-keys for ' </span><span class="s1">+</span>
        <span class="s2">&quot;more information.&quot;</span>
    <span class="s1">);</span>
  <span class="s1">};</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">coerceRef(returnFiber, current, element) {</span>
  <span class="s3">var </span><span class="s1">mixedRef = element.ref;</span>

  <span class="s3">if </span><span class="s1">(</span>
    <span class="s1">mixedRef !== </span><span class="s3">null </span><span class="s1">&amp;&amp;</span>
    <span class="s3">typeof </span><span class="s1">mixedRef !== </span><span class="s2">&quot;function&quot; </span><span class="s1">&amp;&amp;</span>
    <span class="s3">typeof </span><span class="s1">mixedRef !== </span><span class="s2">&quot;object&quot;</span>
  <span class="s1">) {</span>
    <span class="s1">{</span>
      <span class="s0">// TODO: Clean this up once we turn on the string ref warning for</span>
      <span class="s0">// everyone, because the strict mode case will no longer be relevant</span>
      <span class="s3">if </span><span class="s1">(</span>
        <span class="s1">(returnFiber.mode &amp; StrictLegacyMode || warnAboutStringRefs) &amp;&amp; </span><span class="s0">// We warn in ReactElement.js if owner and self are equal for string refs</span>
        <span class="s0">// because these cannot be automatically converted to an arrow function</span>
        <span class="s0">// using a codemod. Therefore, we don't have to warn about string refs again.</span>
        <span class="s1">!(</span>
          <span class="s1">element._owner &amp;&amp;</span>
          <span class="s1">element._self &amp;&amp;</span>
          <span class="s1">element._owner.stateNode !== element._self</span>
        <span class="s1">)</span>
      <span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">componentName =</span>
          <span class="s1">getComponentNameFromFiber(returnFiber) || </span><span class="s2">&quot;Component&quot;</span><span class="s1">;</span>

        <span class="s3">if </span><span class="s1">(!didWarnAboutStringRefs[componentName]) {</span>
          <span class="s1">{</span>
            <span class="s1">error(</span>
              <span class="s2">'A string ref, &quot;%s&quot;, has been found within a strict mode tree. ' </span><span class="s1">+</span>
                <span class="s2">&quot;String refs are a source of potential bugs and should be avoided. &quot; </span><span class="s1">+</span>
                <span class="s2">&quot;We recommend using useRef() or createRef() instead. &quot; </span><span class="s1">+</span>
                <span class="s2">&quot;Learn more about using refs safely here: &quot; </span><span class="s1">+</span>
                <span class="s2">&quot;https://reactjs.org/link/strict-mode-string-ref&quot;</span><span class="s1">,</span>
              <span class="s1">mixedRef</span>
            <span class="s1">);</span>
          <span class="s1">}</span>

          <span class="s1">didWarnAboutStringRefs[componentName] = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(element._owner) {</span>
      <span class="s3">var </span><span class="s1">owner = element._owner;</span>
      <span class="s3">var </span><span class="s1">inst;</span>

      <span class="s3">if </span><span class="s1">(owner) {</span>
        <span class="s3">var </span><span class="s1">ownerFiber = owner;</span>

        <span class="s3">if </span><span class="s1">(ownerFiber.tag !== ClassComponent) {</span>
          <span class="s3">throw new </span><span class="s1">Error(</span>
            <span class="s2">&quot;Function components cannot have string refs. &quot; </span><span class="s1">+</span>
              <span class="s2">&quot;We recommend using useRef() instead. &quot; </span><span class="s1">+</span>
              <span class="s2">&quot;Learn more about using refs safely here: &quot; </span><span class="s1">+</span>
              <span class="s2">&quot;https://reactjs.org/link/strict-mode-string-ref&quot;</span>
          <span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s1">inst = ownerFiber.stateNode;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(!inst) {</span>
        <span class="s3">throw new </span><span class="s1">Error(</span>
          <span class="s2">&quot;Missing owner for string ref &quot; </span><span class="s1">+</span>
            <span class="s1">mixedRef +</span>
            <span class="s2">&quot;. This error is likely caused by a &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;bug in React. Please file an issue.&quot;</span>
        <span class="s1">);</span>
      <span class="s1">} </span><span class="s0">// Assigning this to a const so Flow knows it won't change in the closure</span>

      <span class="s3">var </span><span class="s1">resolvedInst = inst;</span>

      <span class="s1">{</span>
        <span class="s1">checkPropStringCoercion(mixedRef, </span><span class="s2">&quot;ref&quot;</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">stringRef = </span><span class="s2">&quot;&quot; </span><span class="s1">+ mixedRef; </span><span class="s0">// Check if previous string ref matches new string ref</span>

      <span class="s3">if </span><span class="s1">(</span>
        <span class="s1">current !== </span><span class="s3">null </span><span class="s1">&amp;&amp;</span>
        <span class="s1">current.ref !== </span><span class="s3">null </span><span class="s1">&amp;&amp;</span>
        <span class="s3">typeof </span><span class="s1">current.ref === </span><span class="s2">&quot;function&quot; </span><span class="s1">&amp;&amp;</span>
        <span class="s1">current.ref._stringRef === stringRef</span>
      <span class="s1">) {</span>
        <span class="s3">return </span><span class="s1">current.ref;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">ref = </span><span class="s3">function</span><span class="s1">(value) {</span>
        <span class="s3">var </span><span class="s1">refs = resolvedInst.refs;</span>

        <span class="s3">if </span><span class="s1">(refs === emptyRefsObject) {</span>
          <span class="s0">// This is a lazy pooled frozen object, so we need to initialize.</span>
          <span class="s1">refs = resolvedInst.refs = {};</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(value === </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s3">delete </span><span class="s1">refs[stringRef];</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s1">refs[stringRef] = value;</span>
        <span class="s1">}</span>
      <span class="s1">};</span>

      <span class="s1">ref._stringRef = stringRef;</span>
      <span class="s3">return </span><span class="s1">ref;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">mixedRef !== </span><span class="s2">&quot;string&quot;</span><span class="s1">) {</span>
        <span class="s3">throw new </span><span class="s1">Error(</span>
          <span class="s2">&quot;Expected ref to be a function, a string, an object returned by React.createRef(), or null.&quot;</span>
        <span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(!element._owner) {</span>
        <span class="s3">throw new </span><span class="s1">Error(</span>
          <span class="s2">&quot;Element ref was specified as a string (&quot; </span><span class="s1">+</span>
            <span class="s1">mixedRef +</span>
            <span class="s2">&quot;) but no owner was set. This could happen for one of&quot; </span><span class="s1">+</span>
            <span class="s2">&quot; the following reasons:</span><span class="s5">\n</span><span class="s2">&quot; </span><span class="s1">+</span>
            <span class="s2">&quot;1. You may be adding a ref to a function component</span><span class="s5">\n</span><span class="s2">&quot; </span><span class="s1">+</span>
            <span class="s2">&quot;2. You may be adding a ref to a component that was not created inside a component's render method</span><span class="s5">\n</span><span class="s2">&quot; </span><span class="s1">+</span>
            <span class="s2">&quot;3. You have multiple copies of React loaded</span><span class="s5">\n</span><span class="s2">&quot; </span><span class="s1">+</span>
            <span class="s2">&quot;See https://reactjs.org/link/refs-must-have-owner for more information.&quot;</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">mixedRef;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">throwOnInvalidObjectType(returnFiber, newChild) {</span>
  <span class="s3">var </span><span class="s1">childString = Object.prototype.toString.call(newChild);</span>
  <span class="s3">throw new </span><span class="s1">Error(</span>
    <span class="s2">&quot;Objects are not valid as a React child (found: &quot; </span><span class="s1">+</span>
      <span class="s1">(childString === </span><span class="s2">&quot;[object Object]&quot;</span>
        <span class="s1">? </span><span class="s2">&quot;object with keys {&quot; </span><span class="s1">+ Object.keys(newChild).join(</span><span class="s2">&quot;, &quot;</span><span class="s1">) + </span><span class="s2">&quot;}&quot;</span>
        <span class="s1">: childString) +</span>
      <span class="s2">&quot;). &quot; </span><span class="s1">+</span>
      <span class="s2">&quot;If you meant to render a collection of children, use an array &quot; </span><span class="s1">+</span>
      <span class="s2">&quot;instead.&quot;</span>
  <span class="s1">);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">warnOnFunctionType(returnFiber) {</span>
  <span class="s1">{</span>
    <span class="s3">var </span><span class="s1">componentName = getComponentNameFromFiber(returnFiber) || </span><span class="s2">&quot;Component&quot;</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s1">(ownerHasFunctionTypeWarning[componentName]) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">ownerHasFunctionTypeWarning[componentName] = </span><span class="s3">true</span><span class="s1">;</span>

    <span class="s1">error(</span>
      <span class="s2">&quot;Functions are not valid as a React child. This may happen if &quot; </span><span class="s1">+</span>
        <span class="s2">&quot;you return a Component instead of &lt;Component /&gt; from render. &quot; </span><span class="s1">+</span>
        <span class="s2">&quot;Or maybe you meant to call this function rather than return it.&quot;</span>
    <span class="s1">);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">resolveLazy(lazyType) {</span>
  <span class="s3">var </span><span class="s1">payload = lazyType._payload;</span>
  <span class="s3">var </span><span class="s1">init = lazyType._init;</span>
  <span class="s3">return </span><span class="s1">init(payload);</span>
<span class="s1">} </span><span class="s0">// This wrapper function exists because I expect to clone the code in each path</span>
<span class="s0">// to be able to optimize each path individually by branching early. This needs</span>
<span class="s0">// a compiler or we can do it manually. Helpers that don't need this branching</span>
<span class="s0">// live outside of this function.</span>

<span class="s3">function </span><span class="s1">ChildReconciler(shouldTrackSideEffects) {</span>
  <span class="s3">function </span><span class="s1">deleteChild(returnFiber, childToDelete) {</span>
    <span class="s3">if </span><span class="s1">(!shouldTrackSideEffects) {</span>
      <span class="s0">// Noop.</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">deletions = returnFiber.deletions;</span>

    <span class="s3">if </span><span class="s1">(deletions === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">returnFiber.deletions = [childToDelete];</span>
      <span class="s1">returnFiber.flags |= ChildDeletion;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">deletions.push(childToDelete);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">deleteRemainingChildren(returnFiber, currentFirstChild) {</span>
    <span class="s3">if </span><span class="s1">(!shouldTrackSideEffects) {</span>
      <span class="s0">// Noop.</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s0">// TODO: For the shouldClone case, this could be micro-optimized a bit by</span>
    <span class="s0">// assuming that after the first child we've already added everything.</span>

    <span class="s3">var </span><span class="s1">childToDelete = currentFirstChild;</span>

    <span class="s3">while </span><span class="s1">(childToDelete !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">deleteChild(returnFiber, childToDelete);</span>
      <span class="s1">childToDelete = childToDelete.sibling;</span>
    <span class="s1">}</span>

    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">mapRemainingChildren(returnFiber, currentFirstChild) {</span>
    <span class="s0">// Add the remaining children to a temporary map so that we can find them by</span>
    <span class="s0">// keys quickly. Implicit (null) keys get added to this set with their index</span>
    <span class="s0">// instead.</span>
    <span class="s3">var </span><span class="s1">existingChildren = </span><span class="s3">new </span><span class="s1">Map();</span>
    <span class="s3">var </span><span class="s1">existingChild = currentFirstChild;</span>

    <span class="s3">while </span><span class="s1">(existingChild !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(existingChild.key !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">existingChildren.set(existingChild.key, existingChild);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">existingChildren.set(existingChild.index, existingChild);</span>
      <span class="s1">}</span>

      <span class="s1">existingChild = existingChild.sibling;</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">existingChildren;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">useFiber(fiber, pendingProps) {</span>
    <span class="s0">// We currently set sibling to null and index to 0 here because it is easy</span>
    <span class="s0">// to forget to do before returning it. E.g. for the single child case.</span>
    <span class="s3">var </span><span class="s1">clone = createWorkInProgress(fiber, pendingProps);</span>
    <span class="s1">clone.index = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">clone.sibling = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s1">clone;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">placeChild(newFiber, lastPlacedIndex, newIndex) {</span>
    <span class="s1">newFiber.index = newIndex;</span>

    <span class="s3">if </span><span class="s1">(!shouldTrackSideEffects) {</span>
      <span class="s0">// During hydration, the useId algorithm needs to know which fibers are</span>
      <span class="s0">// part of a list of children (arrays, iterators).</span>
      <span class="s1">newFiber.flags |= Forked;</span>
      <span class="s3">return </span><span class="s1">lastPlacedIndex;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">current = newFiber.alternate;</span>

    <span class="s3">if </span><span class="s1">(current !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">oldIndex = current.index;</span>

      <span class="s3">if </span><span class="s1">(oldIndex &lt; lastPlacedIndex) {</span>
        <span class="s0">// This is a move.</span>
        <span class="s1">newFiber.flags |= Placement;</span>
        <span class="s3">return </span><span class="s1">lastPlacedIndex;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s0">// This item can stay in place.</span>
        <span class="s3">return </span><span class="s1">oldIndex;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s0">// This is an insertion.</span>
      <span class="s1">newFiber.flags |= Placement;</span>
      <span class="s3">return </span><span class="s1">lastPlacedIndex;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">placeSingleChild(newFiber) {</span>
    <span class="s0">// This is simpler for the single child case. We only need to do a</span>
    <span class="s0">// placement for inserting new children.</span>
    <span class="s3">if </span><span class="s1">(shouldTrackSideEffects &amp;&amp; newFiber.alternate === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">newFiber.flags |= Placement;</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">newFiber;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">updateTextNode(returnFiber, current, textContent, lanes) {</span>
    <span class="s3">if </span><span class="s1">(current === </span><span class="s3">null </span><span class="s1">|| current.tag !== HostText) {</span>
      <span class="s0">// Insert</span>
      <span class="s3">var </span><span class="s1">created = createFiberFromText(textContent, returnFiber.mode, lanes);</span>
      <span class="s1">created.</span><span class="s3">return </span><span class="s1">= returnFiber;</span>
      <span class="s3">return </span><span class="s1">created;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s0">// Update</span>
      <span class="s3">var </span><span class="s1">existing = useFiber(current, textContent);</span>
      <span class="s1">existing.</span><span class="s3">return </span><span class="s1">= returnFiber;</span>
      <span class="s3">return </span><span class="s1">existing;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">updateElement(returnFiber, current, element, lanes) {</span>
    <span class="s3">var </span><span class="s1">elementType = element.type;</span>

    <span class="s3">if </span><span class="s1">(elementType === REACT_FRAGMENT_TYPE) {</span>
      <span class="s3">return </span><span class="s1">updateFragment(</span>
        <span class="s1">returnFiber,</span>
        <span class="s1">current,</span>
        <span class="s1">element.props.children,</span>
        <span class="s1">lanes,</span>
        <span class="s1">element.key</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(current !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(</span>
        <span class="s1">current.elementType === elementType || </span><span class="s0">// Keep this check inline so it only runs on the false path:</span>
        <span class="s1">isCompatibleFamilyForHotReloading(current, element) || </span><span class="s0">// Lazy types should reconcile their resolved type.</span>
        <span class="s0">// We need to do this after the Hot Reloading check above,</span>
        <span class="s0">// because hot reloading has different semantics than prod because</span>
        <span class="s0">// it doesn't resuspend. So we can't let the call below suspend.</span>
        <span class="s1">(</span><span class="s3">typeof </span><span class="s1">elementType === </span><span class="s2">&quot;object&quot; </span><span class="s1">&amp;&amp;</span>
          <span class="s1">elementType !== </span><span class="s3">null </span><span class="s1">&amp;&amp;</span>
          <span class="s1">elementType.$$typeof === REACT_LAZY_TYPE &amp;&amp;</span>
          <span class="s1">resolveLazy(elementType) === current.type)</span>
      <span class="s1">) {</span>
        <span class="s0">// Move based on index</span>
        <span class="s3">var </span><span class="s1">existing = useFiber(current, element.props);</span>
        <span class="s1">existing.ref = coerceRef(returnFiber, current, element);</span>
        <span class="s1">existing.</span><span class="s3">return </span><span class="s1">= returnFiber;</span>

        <span class="s1">{</span>
          <span class="s1">existing._debugSource = element._source;</span>
          <span class="s1">existing._debugOwner = element._owner;</span>
        <span class="s1">}</span>

        <span class="s3">return </span><span class="s1">existing;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// Insert</span>

    <span class="s3">var </span><span class="s1">created = createFiberFromElement(element, returnFiber.mode, lanes);</span>
    <span class="s1">created.ref = coerceRef(returnFiber, current, element);</span>
    <span class="s1">created.</span><span class="s3">return </span><span class="s1">= returnFiber;</span>
    <span class="s3">return </span><span class="s1">created;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">updatePortal(returnFiber, current, portal, lanes) {</span>
    <span class="s3">if </span><span class="s1">(</span>
      <span class="s1">current === </span><span class="s3">null </span><span class="s1">||</span>
      <span class="s1">current.tag !== HostPortal ||</span>
      <span class="s1">current.stateNode.containerInfo !== portal.containerInfo ||</span>
      <span class="s1">current.stateNode.implementation !== portal.implementation</span>
    <span class="s1">) {</span>
      <span class="s0">// Insert</span>
      <span class="s3">var </span><span class="s1">created = createFiberFromPortal(portal, returnFiber.mode, lanes);</span>
      <span class="s1">created.</span><span class="s3">return </span><span class="s1">= returnFiber;</span>
      <span class="s3">return </span><span class="s1">created;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s0">// Update</span>
      <span class="s3">var </span><span class="s1">existing = useFiber(current, portal.children || []);</span>
      <span class="s1">existing.</span><span class="s3">return </span><span class="s1">= returnFiber;</span>
      <span class="s3">return </span><span class="s1">existing;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">updateFragment(returnFiber, current, fragment, lanes, key) {</span>
    <span class="s3">if </span><span class="s1">(current === </span><span class="s3">null </span><span class="s1">|| current.tag !== Fragment) {</span>
      <span class="s0">// Insert</span>
      <span class="s3">var </span><span class="s1">created = createFiberFromFragment(</span>
        <span class="s1">fragment,</span>
        <span class="s1">returnFiber.mode,</span>
        <span class="s1">lanes,</span>
        <span class="s1">key</span>
      <span class="s1">);</span>
      <span class="s1">created.</span><span class="s3">return </span><span class="s1">= returnFiber;</span>
      <span class="s3">return </span><span class="s1">created;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s0">// Update</span>
      <span class="s3">var </span><span class="s1">existing = useFiber(current, fragment);</span>
      <span class="s1">existing.</span><span class="s3">return </span><span class="s1">= returnFiber;</span>
      <span class="s3">return </span><span class="s1">existing;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">createChild(returnFiber, newChild, lanes) {</span>
    <span class="s3">if </span><span class="s1">(</span>
      <span class="s1">(</span><span class="s3">typeof </span><span class="s1">newChild === </span><span class="s2">&quot;string&quot; </span><span class="s1">&amp;&amp; newChild !== </span><span class="s2">&quot;&quot;</span><span class="s1">) ||</span>
      <span class="s3">typeof </span><span class="s1">newChild === </span><span class="s2">&quot;number&quot;</span>
    <span class="s1">) {</span>
      <span class="s0">// Text nodes don't have keys. If the previous node is implicitly keyed</span>
      <span class="s0">// we can continue to replace it without aborting even if it is not a text</span>
      <span class="s0">// node.</span>
      <span class="s3">var </span><span class="s1">created = createFiberFromText(</span><span class="s2">&quot;&quot; </span><span class="s1">+ newChild, returnFiber.mode, lanes);</span>
      <span class="s1">created.</span><span class="s3">return </span><span class="s1">= returnFiber;</span>
      <span class="s3">return </span><span class="s1">created;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">newChild === </span><span class="s2">&quot;object&quot; </span><span class="s1">&amp;&amp; newChild !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">switch </span><span class="s1">(newChild.$$typeof) {</span>
        <span class="s3">case </span><span class="s1">REACT_ELEMENT_TYPE: {</span>
          <span class="s3">var </span><span class="s1">_created = createFiberFromElement(</span>
            <span class="s1">newChild,</span>
            <span class="s1">returnFiber.mode,</span>
            <span class="s1">lanes</span>
          <span class="s1">);</span>

          <span class="s1">_created.ref = coerceRef(returnFiber, </span><span class="s3">null</span><span class="s1">, newChild);</span>
          <span class="s1">_created.</span><span class="s3">return </span><span class="s1">= returnFiber;</span>
          <span class="s3">return </span><span class="s1">_created;</span>
        <span class="s1">}</span>

        <span class="s3">case </span><span class="s1">REACT_PORTAL_TYPE: {</span>
          <span class="s3">var </span><span class="s1">_created2 = createFiberFromPortal(</span>
            <span class="s1">newChild,</span>
            <span class="s1">returnFiber.mode,</span>
            <span class="s1">lanes</span>
          <span class="s1">);</span>

          <span class="s1">_created2.</span><span class="s3">return </span><span class="s1">= returnFiber;</span>
          <span class="s3">return </span><span class="s1">_created2;</span>
        <span class="s1">}</span>

        <span class="s3">case </span><span class="s1">REACT_LAZY_TYPE: {</span>
          <span class="s3">var </span><span class="s1">payload = newChild._payload;</span>
          <span class="s3">var </span><span class="s1">init = newChild._init;</span>
          <span class="s3">return </span><span class="s1">createChild(returnFiber, init(payload), lanes);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(isArray(newChild) || getIteratorFn(newChild)) {</span>
        <span class="s3">var </span><span class="s1">_created3 = createFiberFromFragment(</span>
          <span class="s1">newChild,</span>
          <span class="s1">returnFiber.mode,</span>
          <span class="s1">lanes,</span>
          <span class="s3">null</span>
        <span class="s1">);</span>

        <span class="s1">_created3.</span><span class="s3">return </span><span class="s1">= returnFiber;</span>
        <span class="s3">return </span><span class="s1">_created3;</span>
      <span class="s1">}</span>

      <span class="s1">throwOnInvalidObjectType(returnFiber, newChild);</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">newChild === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
        <span class="s1">warnOnFunctionType(returnFiber);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">updateSlot(returnFiber, oldFiber, newChild, lanes) {</span>
    <span class="s0">// Update the fiber if the keys match, otherwise return null.</span>
    <span class="s3">var </span><span class="s1">key = oldFiber !== </span><span class="s3">null </span><span class="s1">? oldFiber.key : </span><span class="s3">null</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s1">(</span>
      <span class="s1">(</span><span class="s3">typeof </span><span class="s1">newChild === </span><span class="s2">&quot;string&quot; </span><span class="s1">&amp;&amp; newChild !== </span><span class="s2">&quot;&quot;</span><span class="s1">) ||</span>
      <span class="s3">typeof </span><span class="s1">newChild === </span><span class="s2">&quot;number&quot;</span>
    <span class="s1">) {</span>
      <span class="s0">// Text nodes don't have keys. If the previous node is implicitly keyed</span>
      <span class="s0">// we can continue to replace it without aborting even if it is not a text</span>
      <span class="s0">// node.</span>
      <span class="s3">if </span><span class="s1">(key !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">return null</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">return </span><span class="s1">updateTextNode(returnFiber, oldFiber, </span><span class="s2">&quot;&quot; </span><span class="s1">+ newChild, lanes);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">newChild === </span><span class="s2">&quot;object&quot; </span><span class="s1">&amp;&amp; newChild !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">switch </span><span class="s1">(newChild.$$typeof) {</span>
        <span class="s3">case </span><span class="s1">REACT_ELEMENT_TYPE: {</span>
          <span class="s3">if </span><span class="s1">(newChild.key === key) {</span>
            <span class="s3">return </span><span class="s1">updateElement(returnFiber, oldFiber, newChild, lanes);</span>
          <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s3">return null</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">case </span><span class="s1">REACT_PORTAL_TYPE: {</span>
          <span class="s3">if </span><span class="s1">(newChild.key === key) {</span>
            <span class="s3">return </span><span class="s1">updatePortal(returnFiber, oldFiber, newChild, lanes);</span>
          <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s3">return null</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">case </span><span class="s1">REACT_LAZY_TYPE: {</span>
          <span class="s3">var </span><span class="s1">payload = newChild._payload;</span>
          <span class="s3">var </span><span class="s1">init = newChild._init;</span>
          <span class="s3">return </span><span class="s1">updateSlot(returnFiber, oldFiber, init(payload), lanes);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(isArray(newChild) || getIteratorFn(newChild)) {</span>
        <span class="s3">if </span><span class="s1">(key !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s3">return null</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">return </span><span class="s1">updateFragment(returnFiber, oldFiber, newChild, lanes, </span><span class="s3">null</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s1">throwOnInvalidObjectType(returnFiber, newChild);</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">newChild === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
        <span class="s1">warnOnFunctionType(returnFiber);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">updateFromMap(</span>
    <span class="s1">existingChildren,</span>
    <span class="s1">returnFiber,</span>
    <span class="s1">newIdx,</span>
    <span class="s1">newChild,</span>
    <span class="s1">lanes</span>
  <span class="s1">) {</span>
    <span class="s3">if </span><span class="s1">(</span>
      <span class="s1">(</span><span class="s3">typeof </span><span class="s1">newChild === </span><span class="s2">&quot;string&quot; </span><span class="s1">&amp;&amp; newChild !== </span><span class="s2">&quot;&quot;</span><span class="s1">) ||</span>
      <span class="s3">typeof </span><span class="s1">newChild === </span><span class="s2">&quot;number&quot;</span>
    <span class="s1">) {</span>
      <span class="s0">// Text nodes don't have keys, so we neither have to check the old nor</span>
      <span class="s0">// new node for the key. If both are text nodes, they match.</span>
      <span class="s3">var </span><span class="s1">matchedFiber = existingChildren.get(newIdx) || </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s3">return </span><span class="s1">updateTextNode(returnFiber, matchedFiber, </span><span class="s2">&quot;&quot; </span><span class="s1">+ newChild, lanes);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">newChild === </span><span class="s2">&quot;object&quot; </span><span class="s1">&amp;&amp; newChild !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">switch </span><span class="s1">(newChild.$$typeof) {</span>
        <span class="s3">case </span><span class="s1">REACT_ELEMENT_TYPE: {</span>
          <span class="s3">var </span><span class="s1">_matchedFiber =</span>
            <span class="s1">existingChildren.get(</span>
              <span class="s1">newChild.key === </span><span class="s3">null </span><span class="s1">? newIdx : newChild.key</span>
            <span class="s1">) || </span><span class="s3">null</span><span class="s1">;</span>

          <span class="s3">return </span><span class="s1">updateElement(returnFiber, _matchedFiber, newChild, lanes);</span>
        <span class="s1">}</span>

        <span class="s3">case </span><span class="s1">REACT_PORTAL_TYPE: {</span>
          <span class="s3">var </span><span class="s1">_matchedFiber2 =</span>
            <span class="s1">existingChildren.get(</span>
              <span class="s1">newChild.key === </span><span class="s3">null </span><span class="s1">? newIdx : newChild.key</span>
            <span class="s1">) || </span><span class="s3">null</span><span class="s1">;</span>

          <span class="s3">return </span><span class="s1">updatePortal(returnFiber, _matchedFiber2, newChild, lanes);</span>
        <span class="s1">}</span>

        <span class="s3">case </span><span class="s1">REACT_LAZY_TYPE:</span>
          <span class="s3">var </span><span class="s1">payload = newChild._payload;</span>
          <span class="s3">var </span><span class="s1">init = newChild._init;</span>
          <span class="s3">return </span><span class="s1">updateFromMap(</span>
            <span class="s1">existingChildren,</span>
            <span class="s1">returnFiber,</span>
            <span class="s1">newIdx,</span>
            <span class="s1">init(payload),</span>
            <span class="s1">lanes</span>
          <span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(isArray(newChild) || getIteratorFn(newChild)) {</span>
        <span class="s3">var </span><span class="s1">_matchedFiber3 = existingChildren.get(newIdx) || </span><span class="s3">null</span><span class="s1">;</span>

        <span class="s3">return </span><span class="s1">updateFragment(</span>
          <span class="s1">returnFiber,</span>
          <span class="s1">_matchedFiber3,</span>
          <span class="s1">newChild,</span>
          <span class="s1">lanes,</span>
          <span class="s3">null</span>
        <span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s1">throwOnInvalidObjectType(returnFiber, newChild);</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">newChild === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
        <span class="s1">warnOnFunctionType(returnFiber);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Warns if there is a duplicate or missing key 
   */</span>

  <span class="s3">function </span><span class="s1">warnOnInvalidKey(child, knownKeys, returnFiber) {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">child !== </span><span class="s2">&quot;object&quot; </span><span class="s1">|| child === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">return </span><span class="s1">knownKeys;</span>
      <span class="s1">}</span>

      <span class="s3">switch </span><span class="s1">(child.$$typeof) {</span>
        <span class="s3">case </span><span class="s1">REACT_ELEMENT_TYPE:</span>
        <span class="s3">case </span><span class="s1">REACT_PORTAL_TYPE:</span>
          <span class="s1">warnForMissingKey(child, returnFiber);</span>
          <span class="s3">var </span><span class="s1">key = child.key;</span>

          <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">key !== </span><span class="s2">&quot;string&quot;</span><span class="s1">) {</span>
            <span class="s3">break</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s3">if </span><span class="s1">(knownKeys === </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s1">knownKeys = </span><span class="s3">new </span><span class="s1">Set();</span>
            <span class="s1">knownKeys.add(key);</span>
            <span class="s3">break</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s3">if </span><span class="s1">(!knownKeys.has(key)) {</span>
            <span class="s1">knownKeys.add(key);</span>
            <span class="s3">break</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s1">error(</span>
            <span class="s2">&quot;Encountered two children with the same key, `%s`. &quot; </span><span class="s1">+</span>
              <span class="s2">&quot;Keys should be unique so that components maintain their identity &quot; </span><span class="s1">+</span>
              <span class="s2">&quot;across updates. Non-unique keys may cause children to be &quot; </span><span class="s1">+</span>
              <span class="s2">&quot;duplicated and/or omitted  the behavior is unsupported and &quot; </span><span class="s1">+</span>
              <span class="s2">&quot;could change in a future version.&quot;</span><span class="s1">,</span>
            <span class="s1">key</span>
          <span class="s1">);</span>

          <span class="s3">break</span><span class="s1">;</span>

        <span class="s3">case </span><span class="s1">REACT_LAZY_TYPE:</span>
          <span class="s3">var </span><span class="s1">payload = child._payload;</span>
          <span class="s3">var </span><span class="s1">init = child._init;</span>
          <span class="s1">warnOnInvalidKey(init(payload), knownKeys, returnFiber);</span>
          <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">knownKeys;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">reconcileChildrenArray(</span>
    <span class="s1">returnFiber,</span>
    <span class="s1">currentFirstChild,</span>
    <span class="s1">newChildren,</span>
    <span class="s1">lanes</span>
  <span class="s1">) {</span>
    <span class="s0">// This algorithm can't optimize by searching from both ends since we</span>
    <span class="s0">// don't have backpointers on fibers. I'm trying to see how far we can get</span>
    <span class="s0">// with that model. If it ends up not being worth the tradeoffs, we can</span>
    <span class="s0">// add it later.</span>
    <span class="s0">// Even with a two ended optimization, we'd want to optimize for the case</span>
    <span class="s0">// where there are few changes and brute force the comparison instead of</span>
    <span class="s0">// going for the Map. It'd like to explore hitting that path first in</span>
    <span class="s0">// forward-only mode and only go for the Map once we notice that we need</span>
    <span class="s0">// lots of look ahead. This doesn't handle reversal as well as two ended</span>
    <span class="s0">// search but that's unusual. Besides, for the two ended optimization to</span>
    <span class="s0">// work on Iterables, we'd need to copy the whole set.</span>
    <span class="s0">// In this first iteration, we'll just live with hitting the bad case</span>
    <span class="s0">// (adding everything to a Map) in for every insert/move.</span>
    <span class="s0">// If you change this code, also update reconcileChildrenIterator() which</span>
    <span class="s0">// uses the same algorithm.</span>
    <span class="s1">{</span>
      <span class="s0">// First, validate keys.</span>
      <span class="s3">var </span><span class="s1">knownKeys = </span><span class="s3">null</span><span class="s1">;</span>

      <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; newChildren.length; i++) {</span>
        <span class="s3">var </span><span class="s1">child = newChildren[i];</span>
        <span class="s1">knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">resultingFirstChild = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">previousNewFiber = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">oldFiber = currentFirstChild;</span>
    <span class="s3">var </span><span class="s1">lastPlacedIndex = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">newIdx = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">nextOldFiber = </span><span class="s3">null</span><span class="s1">;</span>

    <span class="s3">for </span><span class="s1">(; oldFiber !== </span><span class="s3">null </span><span class="s1">&amp;&amp; newIdx &lt; newChildren.length; newIdx++) {</span>
      <span class="s3">if </span><span class="s1">(oldFiber.index &gt; newIdx) {</span>
        <span class="s1">nextOldFiber = oldFiber;</span>
        <span class="s1">oldFiber = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">nextOldFiber = oldFiber.sibling;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">newFiber = updateSlot(</span>
        <span class="s1">returnFiber,</span>
        <span class="s1">oldFiber,</span>
        <span class="s1">newChildren[newIdx],</span>
        <span class="s1">lanes</span>
      <span class="s1">);</span>

      <span class="s3">if </span><span class="s1">(newFiber === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s0">// TODO: This breaks on empty slots like null children. That's</span>
        <span class="s0">// unfortunate because it triggers the slow path all the time. We need</span>
        <span class="s0">// a better way to communicate whether this was a miss or null,</span>
        <span class="s0">// boolean, undefined, etc.</span>
        <span class="s3">if </span><span class="s1">(oldFiber === </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">oldFiber = nextOldFiber;</span>
        <span class="s1">}</span>

        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(shouldTrackSideEffects) {</span>
        <span class="s3">if </span><span class="s1">(oldFiber &amp;&amp; newFiber.alternate === </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s0">// We matched the slot, but we didn't reuse the existing fiber, so we</span>
          <span class="s0">// need to delete the existing child.</span>
          <span class="s1">deleteChild(returnFiber, oldFiber);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);</span>

      <span class="s3">if </span><span class="s1">(previousNewFiber === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s0">// TODO: Move out of the loop. This only happens for the first run.</span>
        <span class="s1">resultingFirstChild = newFiber;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s0">// TODO: Defer siblings if we're not at the right index for this slot.</span>
        <span class="s0">// I.e. if we had null values before, then we want to defer this</span>
        <span class="s0">// for each null value. However, we also don't want to call updateSlot</span>
        <span class="s0">// with the previous one.</span>
        <span class="s1">previousNewFiber.sibling = newFiber;</span>
      <span class="s1">}</span>

      <span class="s1">previousNewFiber = newFiber;</span>
      <span class="s1">oldFiber = nextOldFiber;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(newIdx === newChildren.length) {</span>
      <span class="s0">// We've reached the end of the new children. We can delete the rest.</span>
      <span class="s1">deleteRemainingChildren(returnFiber, oldFiber);</span>

      <span class="s3">return </span><span class="s1">resultingFirstChild;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(oldFiber === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// If we don't have any more existing children we can choose a fast path</span>
      <span class="s0">// since the rest will all be insertions.</span>
      <span class="s3">for </span><span class="s1">(; newIdx &lt; newChildren.length; newIdx++) {</span>
        <span class="s3">var </span><span class="s1">_newFiber = createChild(returnFiber, newChildren[newIdx], lanes);</span>

        <span class="s3">if </span><span class="s1">(_newFiber === </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s3">continue</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);</span>

        <span class="s3">if </span><span class="s1">(previousNewFiber === </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s0">// TODO: Move out of the loop. This only happens for the first run.</span>
          <span class="s1">resultingFirstChild = _newFiber;</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s1">previousNewFiber.sibling = _newFiber;</span>
        <span class="s1">}</span>

        <span class="s1">previousNewFiber = _newFiber;</span>
      <span class="s1">}</span>

      <span class="s3">return </span><span class="s1">resultingFirstChild;</span>
    <span class="s1">} </span><span class="s0">// Add all children to a key map for quick lookups.</span>

    <span class="s3">var </span><span class="s1">existingChildren = mapRemainingChildren(returnFiber, oldFiber); </span><span class="s0">// Keep scanning and use the map to restore deleted items as moves.</span>

    <span class="s3">for </span><span class="s1">(; newIdx &lt; newChildren.length; newIdx++) {</span>
      <span class="s3">var </span><span class="s1">_newFiber2 = updateFromMap(</span>
        <span class="s1">existingChildren,</span>
        <span class="s1">returnFiber,</span>
        <span class="s1">newIdx,</span>
        <span class="s1">newChildren[newIdx],</span>
        <span class="s1">lanes</span>
      <span class="s1">);</span>

      <span class="s3">if </span><span class="s1">(_newFiber2 !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(shouldTrackSideEffects) {</span>
          <span class="s3">if </span><span class="s1">(_newFiber2.alternate !== </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s0">// The new fiber is a work in progress, but if there exists a</span>
            <span class="s0">// current, that means that we reused the fiber. We need to delete</span>
            <span class="s0">// it from the child list so that we don't add it to the deletion</span>
            <span class="s0">// list.</span>
            <span class="s1">existingChildren.</span><span class="s3">delete</span><span class="s1">(</span>
              <span class="s1">_newFiber2.key === </span><span class="s3">null </span><span class="s1">? newIdx : _newFiber2.key</span>
            <span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s1">lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);</span>

        <span class="s3">if </span><span class="s1">(previousNewFiber === </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">resultingFirstChild = _newFiber2;</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s1">previousNewFiber.sibling = _newFiber2;</span>
        <span class="s1">}</span>

        <span class="s1">previousNewFiber = _newFiber2;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(shouldTrackSideEffects) {</span>
      <span class="s0">// Any existing children that weren't consumed above were deleted. We need</span>
      <span class="s0">// to add them to the deletion list.</span>
      <span class="s1">existingChildren.forEach(</span><span class="s3">function</span><span class="s1">(child) {</span>
        <span class="s3">return </span><span class="s1">deleteChild(returnFiber, child);</span>
      <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">resultingFirstChild;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">reconcileChildrenIterator(</span>
    <span class="s1">returnFiber,</span>
    <span class="s1">currentFirstChild,</span>
    <span class="s1">newChildrenIterable,</span>
    <span class="s1">lanes</span>
  <span class="s1">) {</span>
    <span class="s0">// This is the same implementation as reconcileChildrenArray(),</span>
    <span class="s0">// but using the iterator instead.</span>
    <span class="s3">var </span><span class="s1">iteratorFn = getIteratorFn(newChildrenIterable);</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">iteratorFn !== </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
      <span class="s3">throw new </span><span class="s1">Error(</span>
        <span class="s2">&quot;An object is not an iterable. This error is likely caused by a bug in &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;React. Please file an issue.&quot;</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s0">// We don't support rendering Generators because it's a mutation.</span>
      <span class="s0">// See https://github.com/facebook/react/issues/12995</span>
      <span class="s3">if </span><span class="s1">(</span>
        <span class="s3">typeof </span><span class="s1">Symbol === </span><span class="s2">&quot;function&quot; </span><span class="s1">&amp;&amp; </span><span class="s0">// $FlowFixMe Flow doesn't know about toStringTag</span>
        <span class="s1">newChildrenIterable[Symbol.toStringTag] === </span><span class="s2">&quot;Generator&quot;</span>
      <span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(!didWarnAboutGenerators) {</span>
          <span class="s1">error(</span>
            <span class="s2">&quot;Using Generators as children is unsupported and will likely yield &quot; </span><span class="s1">+</span>
              <span class="s2">&quot;unexpected results because enumerating a generator mutates it. &quot; </span><span class="s1">+</span>
              <span class="s2">&quot;You may convert it to an array with `Array.from()` or the &quot; </span><span class="s1">+</span>
              <span class="s2">&quot;`[...spread]` operator before rendering. Keep in mind &quot; </span><span class="s1">+</span>
              <span class="s2">&quot;you might need to polyfill these features for older browsers.&quot;</span>
          <span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s1">didWarnAboutGenerators = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// Warn about using Maps as children</span>

      <span class="s3">if </span><span class="s1">(newChildrenIterable.entries === iteratorFn) {</span>
        <span class="s3">if </span><span class="s1">(!didWarnAboutMaps) {</span>
          <span class="s1">error(</span>
            <span class="s2">&quot;Using Maps as children is not supported. &quot; </span><span class="s1">+</span>
              <span class="s2">&quot;Use an array of keyed ReactElements instead.&quot;</span>
          <span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s1">didWarnAboutMaps = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// First, validate keys.</span>
      <span class="s0">// We'll get a different iterator later for the main pass.</span>

      <span class="s3">var </span><span class="s1">_newChildren = iteratorFn.call(newChildrenIterable);</span>

      <span class="s3">if </span><span class="s1">(_newChildren) {</span>
        <span class="s3">var </span><span class="s1">knownKeys = </span><span class="s3">null</span><span class="s1">;</span>

        <span class="s3">var </span><span class="s1">_step = _newChildren.next();</span>

        <span class="s3">for </span><span class="s1">(; !_step.done; _step = _newChildren.next()) {</span>
          <span class="s3">var </span><span class="s1">child = _step.value;</span>
          <span class="s1">knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">newChildren = iteratorFn.call(newChildrenIterable);</span>

    <span class="s3">if </span><span class="s1">(newChildren == </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;An iterable object provided no iterator.&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">resultingFirstChild = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">previousNewFiber = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">oldFiber = currentFirstChild;</span>
    <span class="s3">var </span><span class="s1">lastPlacedIndex = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">newIdx = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">nextOldFiber = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">step = newChildren.next();</span>

    <span class="s3">for </span><span class="s1">(</span>
      <span class="s1">;</span>
      <span class="s1">oldFiber !== </span><span class="s3">null </span><span class="s1">&amp;&amp; !step.done;</span>
      <span class="s1">newIdx++, step = newChildren.next()</span>
    <span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(oldFiber.index &gt; newIdx) {</span>
        <span class="s1">nextOldFiber = oldFiber;</span>
        <span class="s1">oldFiber = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">nextOldFiber = oldFiber.sibling;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);</span>

      <span class="s3">if </span><span class="s1">(newFiber === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s0">// TODO: This breaks on empty slots like null children. That's</span>
        <span class="s0">// unfortunate because it triggers the slow path all the time. We need</span>
        <span class="s0">// a better way to communicate whether this was a miss or null,</span>
        <span class="s0">// boolean, undefined, etc.</span>
        <span class="s3">if </span><span class="s1">(oldFiber === </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">oldFiber = nextOldFiber;</span>
        <span class="s1">}</span>

        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(shouldTrackSideEffects) {</span>
        <span class="s3">if </span><span class="s1">(oldFiber &amp;&amp; newFiber.alternate === </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s0">// We matched the slot, but we didn't reuse the existing fiber, so we</span>
          <span class="s0">// need to delete the existing child.</span>
          <span class="s1">deleteChild(returnFiber, oldFiber);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);</span>

      <span class="s3">if </span><span class="s1">(previousNewFiber === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s0">// TODO: Move out of the loop. This only happens for the first run.</span>
        <span class="s1">resultingFirstChild = newFiber;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s0">// TODO: Defer siblings if we're not at the right index for this slot.</span>
        <span class="s0">// I.e. if we had null values before, then we want to defer this</span>
        <span class="s0">// for each null value. However, we also don't want to call updateSlot</span>
        <span class="s0">// with the previous one.</span>
        <span class="s1">previousNewFiber.sibling = newFiber;</span>
      <span class="s1">}</span>

      <span class="s1">previousNewFiber = newFiber;</span>
      <span class="s1">oldFiber = nextOldFiber;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(step.done) {</span>
      <span class="s0">// We've reached the end of the new children. We can delete the rest.</span>
      <span class="s1">deleteRemainingChildren(returnFiber, oldFiber);</span>

      <span class="s3">return </span><span class="s1">resultingFirstChild;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(oldFiber === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// If we don't have any more existing children we can choose a fast path</span>
      <span class="s0">// since the rest will all be insertions.</span>
      <span class="s3">for </span><span class="s1">(; !step.done; newIdx++, step = newChildren.next()) {</span>
        <span class="s3">var </span><span class="s1">_newFiber3 = createChild(returnFiber, step.value, lanes);</span>

        <span class="s3">if </span><span class="s1">(_newFiber3 === </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s3">continue</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);</span>

        <span class="s3">if </span><span class="s1">(previousNewFiber === </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s0">// TODO: Move out of the loop. This only happens for the first run.</span>
          <span class="s1">resultingFirstChild = _newFiber3;</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s1">previousNewFiber.sibling = _newFiber3;</span>
        <span class="s1">}</span>

        <span class="s1">previousNewFiber = _newFiber3;</span>
      <span class="s1">}</span>

      <span class="s3">return </span><span class="s1">resultingFirstChild;</span>
    <span class="s1">} </span><span class="s0">// Add all children to a key map for quick lookups.</span>

    <span class="s3">var </span><span class="s1">existingChildren = mapRemainingChildren(returnFiber, oldFiber); </span><span class="s0">// Keep scanning and use the map to restore deleted items as moves.</span>

    <span class="s3">for </span><span class="s1">(; !step.done; newIdx++, step = newChildren.next()) {</span>
      <span class="s3">var </span><span class="s1">_newFiber4 = updateFromMap(</span>
        <span class="s1">existingChildren,</span>
        <span class="s1">returnFiber,</span>
        <span class="s1">newIdx,</span>
        <span class="s1">step.value,</span>
        <span class="s1">lanes</span>
      <span class="s1">);</span>

      <span class="s3">if </span><span class="s1">(_newFiber4 !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(shouldTrackSideEffects) {</span>
          <span class="s3">if </span><span class="s1">(_newFiber4.alternate !== </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s0">// The new fiber is a work in progress, but if there exists a</span>
            <span class="s0">// current, that means that we reused the fiber. We need to delete</span>
            <span class="s0">// it from the child list so that we don't add it to the deletion</span>
            <span class="s0">// list.</span>
            <span class="s1">existingChildren.</span><span class="s3">delete</span><span class="s1">(</span>
              <span class="s1">_newFiber4.key === </span><span class="s3">null </span><span class="s1">? newIdx : _newFiber4.key</span>
            <span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s1">lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);</span>

        <span class="s3">if </span><span class="s1">(previousNewFiber === </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">resultingFirstChild = _newFiber4;</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s1">previousNewFiber.sibling = _newFiber4;</span>
        <span class="s1">}</span>

        <span class="s1">previousNewFiber = _newFiber4;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(shouldTrackSideEffects) {</span>
      <span class="s0">// Any existing children that weren't consumed above were deleted. We need</span>
      <span class="s0">// to add them to the deletion list.</span>
      <span class="s1">existingChildren.forEach(</span><span class="s3">function</span><span class="s1">(child) {</span>
        <span class="s3">return </span><span class="s1">deleteChild(returnFiber, child);</span>
      <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">resultingFirstChild;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">reconcileSingleTextNode(</span>
    <span class="s1">returnFiber,</span>
    <span class="s1">currentFirstChild,</span>
    <span class="s1">textContent,</span>
    <span class="s1">lanes</span>
  <span class="s1">) {</span>
    <span class="s0">// There's no need to check for keys on text nodes since we don't have a</span>
    <span class="s0">// way to define them.</span>
    <span class="s3">if </span><span class="s1">(currentFirstChild !== </span><span class="s3">null </span><span class="s1">&amp;&amp; currentFirstChild.tag === HostText) {</span>
      <span class="s0">// We already have an existing node so let's just update it and delete</span>
      <span class="s0">// the rest.</span>
      <span class="s1">deleteRemainingChildren(returnFiber, currentFirstChild.sibling);</span>
      <span class="s3">var </span><span class="s1">existing = useFiber(currentFirstChild, textContent);</span>
      <span class="s1">existing.</span><span class="s3">return </span><span class="s1">= returnFiber;</span>
      <span class="s3">return </span><span class="s1">existing;</span>
    <span class="s1">} </span><span class="s0">// The existing first child is not a text node so we need to create one</span>
    <span class="s0">// and delete the existing ones.</span>

    <span class="s1">deleteRemainingChildren(returnFiber, currentFirstChild);</span>
    <span class="s3">var </span><span class="s1">created = createFiberFromText(textContent, returnFiber.mode, lanes);</span>
    <span class="s1">created.</span><span class="s3">return </span><span class="s1">= returnFiber;</span>
    <span class="s3">return </span><span class="s1">created;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">reconcileSingleElement(</span>
    <span class="s1">returnFiber,</span>
    <span class="s1">currentFirstChild,</span>
    <span class="s1">element,</span>
    <span class="s1">lanes</span>
  <span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">key = element.key;</span>
    <span class="s3">var </span><span class="s1">child = currentFirstChild;</span>

    <span class="s3">while </span><span class="s1">(child !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// TODO: If key === null and child.key === null, then this only applies to</span>
      <span class="s0">// the first item in the list.</span>
      <span class="s3">if </span><span class="s1">(child.key === key) {</span>
        <span class="s3">var </span><span class="s1">elementType = element.type;</span>

        <span class="s3">if </span><span class="s1">(elementType === REACT_FRAGMENT_TYPE) {</span>
          <span class="s3">if </span><span class="s1">(child.tag === Fragment) {</span>
            <span class="s1">deleteRemainingChildren(returnFiber, child.sibling);</span>
            <span class="s3">var </span><span class="s1">existing = useFiber(child, element.props.children);</span>
            <span class="s1">existing.</span><span class="s3">return </span><span class="s1">= returnFiber;</span>

            <span class="s1">{</span>
              <span class="s1">existing._debugSource = element._source;</span>
              <span class="s1">existing._debugOwner = element._owner;</span>
            <span class="s1">}</span>

            <span class="s3">return </span><span class="s1">existing;</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s3">if </span><span class="s1">(</span>
            <span class="s1">child.elementType === elementType || </span><span class="s0">// Keep this check inline so it only runs on the false path:</span>
            <span class="s1">isCompatibleFamilyForHotReloading(child, element) || </span><span class="s0">// Lazy types should reconcile their resolved type.</span>
            <span class="s0">// We need to do this after the Hot Reloading check above,</span>
            <span class="s0">// because hot reloading has different semantics than prod because</span>
            <span class="s0">// it doesn't resuspend. So we can't let the call below suspend.</span>
            <span class="s1">(</span><span class="s3">typeof </span><span class="s1">elementType === </span><span class="s2">&quot;object&quot; </span><span class="s1">&amp;&amp;</span>
              <span class="s1">elementType !== </span><span class="s3">null </span><span class="s1">&amp;&amp;</span>
              <span class="s1">elementType.$$typeof === REACT_LAZY_TYPE &amp;&amp;</span>
              <span class="s1">resolveLazy(elementType) === child.type)</span>
          <span class="s1">) {</span>
            <span class="s1">deleteRemainingChildren(returnFiber, child.sibling);</span>

            <span class="s3">var </span><span class="s1">_existing = useFiber(child, element.props);</span>

            <span class="s1">_existing.ref = coerceRef(returnFiber, child, element);</span>
            <span class="s1">_existing.</span><span class="s3">return </span><span class="s1">= returnFiber;</span>

            <span class="s1">{</span>
              <span class="s1">_existing._debugSource = element._source;</span>
              <span class="s1">_existing._debugOwner = element._owner;</span>
            <span class="s1">}</span>

            <span class="s3">return </span><span class="s1">_existing;</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s0">// Didn't match.</span>

        <span class="s1">deleteRemainingChildren(returnFiber, child);</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">deleteChild(returnFiber, child);</span>
      <span class="s1">}</span>

      <span class="s1">child = child.sibling;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(element.type === REACT_FRAGMENT_TYPE) {</span>
      <span class="s3">var </span><span class="s1">created = createFiberFromFragment(</span>
        <span class="s1">element.props.children,</span>
        <span class="s1">returnFiber.mode,</span>
        <span class="s1">lanes,</span>
        <span class="s1">element.key</span>
      <span class="s1">);</span>
      <span class="s1">created.</span><span class="s3">return </span><span class="s1">= returnFiber;</span>
      <span class="s3">return </span><span class="s1">created;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">var </span><span class="s1">_created4 = createFiberFromElement(element, returnFiber.mode, lanes);</span>

      <span class="s1">_created4.ref = coerceRef(returnFiber, currentFirstChild, element);</span>
      <span class="s1">_created4.</span><span class="s3">return </span><span class="s1">= returnFiber;</span>
      <span class="s3">return </span><span class="s1">_created4;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">reconcileSinglePortal(</span>
    <span class="s1">returnFiber,</span>
    <span class="s1">currentFirstChild,</span>
    <span class="s1">portal,</span>
    <span class="s1">lanes</span>
  <span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">key = portal.key;</span>
    <span class="s3">var </span><span class="s1">child = currentFirstChild;</span>

    <span class="s3">while </span><span class="s1">(child !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// TODO: If key === null and child.key === null, then this only applies to</span>
      <span class="s0">// the first item in the list.</span>
      <span class="s3">if </span><span class="s1">(child.key === key) {</span>
        <span class="s3">if </span><span class="s1">(</span>
          <span class="s1">child.tag === HostPortal &amp;&amp;</span>
          <span class="s1">child.stateNode.containerInfo === portal.containerInfo &amp;&amp;</span>
          <span class="s1">child.stateNode.implementation === portal.implementation</span>
        <span class="s1">) {</span>
          <span class="s1">deleteRemainingChildren(returnFiber, child.sibling);</span>
          <span class="s3">var </span><span class="s1">existing = useFiber(child, portal.children || []);</span>
          <span class="s1">existing.</span><span class="s3">return </span><span class="s1">= returnFiber;</span>
          <span class="s3">return </span><span class="s1">existing;</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s1">deleteRemainingChildren(returnFiber, child);</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">deleteChild(returnFiber, child);</span>
      <span class="s1">}</span>

      <span class="s1">child = child.sibling;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">created = createFiberFromPortal(portal, returnFiber.mode, lanes);</span>
    <span class="s1">created.</span><span class="s3">return </span><span class="s1">= returnFiber;</span>
    <span class="s3">return </span><span class="s1">created;</span>
  <span class="s1">} </span><span class="s0">// This API will tag the children with the side-effect of the reconciliation</span>
  <span class="s0">// itself. They will be added to the side-effect list as we pass through the</span>
  <span class="s0">// children and the parent.</span>

  <span class="s3">function </span><span class="s1">reconcileChildFibers(</span>
    <span class="s1">returnFiber,</span>
    <span class="s1">currentFirstChild,</span>
    <span class="s1">newChild,</span>
    <span class="s1">lanes</span>
  <span class="s1">) {</span>
    <span class="s0">// This function is not recursive.</span>
    <span class="s0">// If the top level item is an array, we treat it as a set of children,</span>
    <span class="s0">// not as a fragment. Nested arrays on the other hand will be treated as</span>
    <span class="s0">// fragment nodes. Recursion happens at the normal flow.</span>
    <span class="s0">// Handle top level unkeyed fragments as if they were arrays.</span>
    <span class="s0">// This leads to an ambiguity between &lt;&gt;{[...]}&lt;/&gt; and &lt;&gt;...&lt;/&gt;.</span>
    <span class="s0">// We treat the ambiguous cases above the same.</span>
    <span class="s3">var </span><span class="s1">isUnkeyedTopLevelFragment =</span>
      <span class="s3">typeof </span><span class="s1">newChild === </span><span class="s2">&quot;object&quot; </span><span class="s1">&amp;&amp;</span>
      <span class="s1">newChild !== </span><span class="s3">null </span><span class="s1">&amp;&amp;</span>
      <span class="s1">newChild.type === REACT_FRAGMENT_TYPE &amp;&amp;</span>
      <span class="s1">newChild.key === </span><span class="s3">null</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s1">(isUnkeyedTopLevelFragment) {</span>
      <span class="s1">newChild = newChild.props.children;</span>
    <span class="s1">} </span><span class="s0">// Handle object types</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">newChild === </span><span class="s2">&quot;object&quot; </span><span class="s1">&amp;&amp; newChild !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">switch </span><span class="s1">(newChild.$$typeof) {</span>
        <span class="s3">case </span><span class="s1">REACT_ELEMENT_TYPE:</span>
          <span class="s3">return </span><span class="s1">placeSingleChild(</span>
            <span class="s1">reconcileSingleElement(</span>
              <span class="s1">returnFiber,</span>
              <span class="s1">currentFirstChild,</span>
              <span class="s1">newChild,</span>
              <span class="s1">lanes</span>
            <span class="s1">)</span>
          <span class="s1">);</span>

        <span class="s3">case </span><span class="s1">REACT_PORTAL_TYPE:</span>
          <span class="s3">return </span><span class="s1">placeSingleChild(</span>
            <span class="s1">reconcileSinglePortal(</span>
              <span class="s1">returnFiber,</span>
              <span class="s1">currentFirstChild,</span>
              <span class="s1">newChild,</span>
              <span class="s1">lanes</span>
            <span class="s1">)</span>
          <span class="s1">);</span>

        <span class="s3">case </span><span class="s1">REACT_LAZY_TYPE:</span>
          <span class="s3">var </span><span class="s1">payload = newChild._payload;</span>
          <span class="s3">var </span><span class="s1">init = newChild._init; </span><span class="s0">// TODO: This function is supposed to be non-recursive.</span>

          <span class="s3">return </span><span class="s1">reconcileChildFibers(</span>
            <span class="s1">returnFiber,</span>
            <span class="s1">currentFirstChild,</span>
            <span class="s1">init(payload),</span>
            <span class="s1">lanes</span>
          <span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(isArray(newChild)) {</span>
        <span class="s3">return </span><span class="s1">reconcileChildrenArray(</span>
          <span class="s1">returnFiber,</span>
          <span class="s1">currentFirstChild,</span>
          <span class="s1">newChild,</span>
          <span class="s1">lanes</span>
        <span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(getIteratorFn(newChild)) {</span>
        <span class="s3">return </span><span class="s1">reconcileChildrenIterator(</span>
          <span class="s1">returnFiber,</span>
          <span class="s1">currentFirstChild,</span>
          <span class="s1">newChild,</span>
          <span class="s1">lanes</span>
        <span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s1">throwOnInvalidObjectType(returnFiber, newChild);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span>
      <span class="s1">(</span><span class="s3">typeof </span><span class="s1">newChild === </span><span class="s2">&quot;string&quot; </span><span class="s1">&amp;&amp; newChild !== </span><span class="s2">&quot;&quot;</span><span class="s1">) ||</span>
      <span class="s3">typeof </span><span class="s1">newChild === </span><span class="s2">&quot;number&quot;</span>
    <span class="s1">) {</span>
      <span class="s3">return </span><span class="s1">placeSingleChild(</span>
        <span class="s1">reconcileSingleTextNode(</span>
          <span class="s1">returnFiber,</span>
          <span class="s1">currentFirstChild,</span>
          <span class="s2">&quot;&quot; </span><span class="s1">+ newChild,</span>
          <span class="s1">lanes</span>
        <span class="s1">)</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">newChild === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
        <span class="s1">warnOnFunctionType(returnFiber);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// Remaining cases are all treated as empty.</span>

    <span class="s3">return </span><span class="s1">deleteRemainingChildren(returnFiber, currentFirstChild);</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">reconcileChildFibers;</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">reconcileChildFibers = ChildReconciler(</span><span class="s3">true</span><span class="s1">);</span>
<span class="s3">var </span><span class="s1">mountChildFibers = ChildReconciler(</span><span class="s3">false</span><span class="s1">);</span>
<span class="s3">function </span><span class="s1">cloneChildFibers(current, workInProgress) {</span>
  <span class="s3">if </span><span class="s1">(current !== </span><span class="s3">null </span><span class="s1">&amp;&amp; workInProgress.child !== current.child) {</span>
    <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Resuming work not yet implemented.&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(workInProgress.child === </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">return</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">currentChild = workInProgress.child;</span>
  <span class="s3">var </span><span class="s1">newChild = createWorkInProgress(currentChild, currentChild.pendingProps);</span>
  <span class="s1">workInProgress.child = newChild;</span>
  <span class="s1">newChild.</span><span class="s3">return </span><span class="s1">= workInProgress;</span>

  <span class="s3">while </span><span class="s1">(currentChild.sibling !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s1">currentChild = currentChild.sibling;</span>
    <span class="s1">newChild = newChild.sibling = createWorkInProgress(</span>
      <span class="s1">currentChild,</span>
      <span class="s1">currentChild.pendingProps</span>
    <span class="s1">);</span>
    <span class="s1">newChild.</span><span class="s3">return </span><span class="s1">= workInProgress;</span>
  <span class="s1">}</span>

  <span class="s1">newChild.sibling = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s1">} </span><span class="s0">// Reset a workInProgress child set to prepare it for a second pass.</span>

<span class="s3">function </span><span class="s1">resetChildFibers(workInProgress, lanes) {</span>
  <span class="s3">var </span><span class="s1">child = workInProgress.child;</span>

  <span class="s3">while </span><span class="s1">(child !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s1">resetWorkInProgress(child, lanes);</span>
    <span class="s1">child = child.sibling;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">NO_CONTEXT = {};</span>
<span class="s3">var </span><span class="s1">contextStackCursor$1 = createCursor(NO_CONTEXT);</span>
<span class="s3">var </span><span class="s1">contextFiberStackCursor = createCursor(NO_CONTEXT);</span>
<span class="s3">var </span><span class="s1">rootInstanceStackCursor = createCursor(NO_CONTEXT);</span>

<span class="s3">function </span><span class="s1">requiredContext(c) {</span>
  <span class="s3">if </span><span class="s1">(c === NO_CONTEXT) {</span>
    <span class="s3">throw new </span><span class="s1">Error(</span>
      <span class="s2">&quot;Expected host context to exist. This error is likely caused by a bug &quot; </span><span class="s1">+</span>
        <span class="s2">&quot;in React. Please file an issue.&quot;</span>
    <span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">c;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">getRootHostContainer() {</span>
  <span class="s3">var </span><span class="s1">rootInstance = requiredContext(rootInstanceStackCursor.current);</span>
  <span class="s3">return </span><span class="s1">rootInstance;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">pushHostContainer(fiber, nextRootInstance) {</span>
  <span class="s0">// Push current root instance onto the stack;</span>
  <span class="s0">// This allows us to reset root when portals are popped.</span>
  <span class="s1">push(rootInstanceStackCursor, nextRootInstance, fiber); </span><span class="s0">// Track the context and the Fiber that provided it.</span>
  <span class="s0">// This enables us to pop only Fibers that provide unique contexts.</span>

  <span class="s1">push(contextFiberStackCursor, fiber, fiber); </span><span class="s0">// Finally, we need to push the host context to the stack.</span>
  <span class="s0">// However, we can't just call getRootHostContext() and push it because</span>
  <span class="s0">// we'd have a different number of entries on the stack depending on</span>
  <span class="s0">// whether getRootHostContext() throws somewhere in renderer code or not.</span>
  <span class="s0">// So we push an empty value first. This lets us safely unwind on errors.</span>

  <span class="s1">push(contextStackCursor$1, NO_CONTEXT, fiber);</span>
  <span class="s3">var </span><span class="s1">nextRootContext = getRootHostContext(); </span><span class="s0">// Now that we know this function doesn't throw, replace it.</span>

  <span class="s1">pop(contextStackCursor$1, fiber);</span>
  <span class="s1">push(contextStackCursor$1, nextRootContext, fiber);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">popHostContainer(fiber) {</span>
  <span class="s1">pop(contextStackCursor$1, fiber);</span>
  <span class="s1">pop(contextFiberStackCursor, fiber);</span>
  <span class="s1">pop(rootInstanceStackCursor, fiber);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">getHostContext() {</span>
  <span class="s3">var </span><span class="s1">context = requiredContext(contextStackCursor$1.current);</span>
  <span class="s3">return </span><span class="s1">context;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">pushHostContext(fiber) {</span>
  <span class="s3">var </span><span class="s1">rootInstance = requiredContext(rootInstanceStackCursor.current);</span>
  <span class="s3">var </span><span class="s1">context = requiredContext(contextStackCursor$1.current);</span>
  <span class="s3">var </span><span class="s1">nextContext = getChildHostContext(context, fiber.type); </span><span class="s0">// Don't push this Fiber's context unless it's unique.</span>

  <span class="s3">if </span><span class="s1">(context === nextContext) {</span>
    <span class="s3">return</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s0">// Track the context and the Fiber that provided it.</span>
  <span class="s0">// This enables us to pop only Fibers that provide unique contexts.</span>

  <span class="s1">push(contextFiberStackCursor, fiber, fiber);</span>
  <span class="s1">push(contextStackCursor$1, nextContext, fiber);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">popHostContext(fiber) {</span>
  <span class="s0">// Do not pop unless this Fiber provided the current context.</span>
  <span class="s0">// pushHostContext() only pushes Fibers that provide unique contexts.</span>
  <span class="s3">if </span><span class="s1">(contextFiberStackCursor.current !== fiber) {</span>
    <span class="s3">return</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s1">pop(contextStackCursor$1, fiber);</span>
  <span class="s1">pop(contextFiberStackCursor, fiber);</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">DefaultSuspenseContext = </span><span class="s4">0</span><span class="s1">; </span><span class="s0">// The Suspense Context is split into two parts. The lower bits is</span>
<span class="s0">// inherited deeply down the subtree. The upper bits only affect</span>
<span class="s0">// this immediate suspense boundary and gets reset each new</span>
<span class="s0">// boundary or suspense list.</span>

<span class="s3">var </span><span class="s1">SubtreeSuspenseContextMask = </span><span class="s4">1</span><span class="s1">; </span><span class="s0">// Subtree Flags:</span>
<span class="s0">// InvisibleParentSuspenseContext indicates that one of our parent Suspense</span>
<span class="s0">// boundaries is not currently showing visible main content.</span>
<span class="s0">// Either because it is already showing a fallback or is not mounted at all.</span>
<span class="s0">// We can use this to determine if it is desirable to trigger a fallback at</span>
<span class="s0">// the parent. If not, then we might need to trigger undesirable boundaries</span>
<span class="s0">// and/or suspend the commit to avoid hiding the parent content.</span>

<span class="s3">var </span><span class="s1">InvisibleParentSuspenseContext = </span><span class="s4">1</span><span class="s1">; </span><span class="s0">// Shallow Flags:</span>
<span class="s0">// ForceSuspenseFallback can be used by SuspenseList to force newly added</span>
<span class="s0">// items into their fallback state during one of the render passes.</span>

<span class="s3">var </span><span class="s1">ForceSuspenseFallback = </span><span class="s4">2</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">suspenseStackCursor = createCursor(DefaultSuspenseContext);</span>
<span class="s3">function </span><span class="s1">hasSuspenseContext(parentContext, flag) {</span>
  <span class="s3">return </span><span class="s1">(parentContext &amp; flag) !== </span><span class="s4">0</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">setDefaultShallowSuspenseContext(parentContext) {</span>
  <span class="s3">return </span><span class="s1">parentContext &amp; SubtreeSuspenseContextMask;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">setShallowSuspenseContext(parentContext, shallowContext) {</span>
  <span class="s3">return </span><span class="s1">(parentContext &amp; SubtreeSuspenseContextMask) | shallowContext;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">addSubtreeSuspenseContext(parentContext, subtreeContext) {</span>
  <span class="s3">return </span><span class="s1">parentContext | subtreeContext;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">pushSuspenseContext(fiber, newContext) {</span>
  <span class="s1">push(suspenseStackCursor, newContext, fiber);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">popSuspenseContext(fiber) {</span>
  <span class="s1">pop(suspenseStackCursor, fiber);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">shouldCaptureSuspense(workInProgress, hasInvisibleParent) {</span>
  <span class="s0">// If it was the primary children that just suspended, capture and render the</span>
  <span class="s0">// fallback. Otherwise, don't capture and bubble to the next boundary.</span>
  <span class="s3">var </span><span class="s1">nextState = workInProgress.memoizedState;</span>

  <span class="s3">if </span><span class="s1">(nextState !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">if </span><span class="s1">(nextState.dehydrated !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// A dehydrated boundary always captures.</span>
      <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">return false</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">props = workInProgress.memoizedProps; </span><span class="s0">// Regular boundaries always capture.</span>

  <span class="s1">{</span>
    <span class="s3">return true</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s0">// If it's a boundary we should avoid, then we prefer to bubble up to the</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">findFirstSuspended(row) {</span>
  <span class="s3">var </span><span class="s1">node = row;</span>

  <span class="s3">while </span><span class="s1">(node !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">if </span><span class="s1">(node.tag === SuspenseComponent) {</span>
      <span class="s3">var </span><span class="s1">state = node.memoizedState;</span>

      <span class="s3">if </span><span class="s1">(state !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">dehydrated = state.dehydrated;</span>

        <span class="s3">if </span><span class="s1">(</span>
          <span class="s1">dehydrated === </span><span class="s3">null </span><span class="s1">||</span>
          <span class="s1">isSuspenseInstancePending() ||</span>
          <span class="s1">isSuspenseInstanceFallback()</span>
        <span class="s1">) {</span>
          <span class="s3">return </span><span class="s1">node;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span>
      <span class="s1">node.tag === SuspenseListComponent &amp;&amp; </span><span class="s0">// revealOrder undefined can't be trusted because it don't</span>
      <span class="s0">// keep track of whether it suspended or not.</span>
      <span class="s1">node.memoizedProps.revealOrder !== undefined</span>
    <span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">didSuspend = (node.flags &amp; DidCapture) !== NoFlags;</span>

      <span class="s3">if </span><span class="s1">(didSuspend) {</span>
        <span class="s3">return </span><span class="s1">node;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(node.child !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">node.child.</span><span class="s3">return </span><span class="s1">= node;</span>
      <span class="s1">node = node.child;</span>
      <span class="s3">continue</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(node === row) {</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">while </span><span class="s1">(node.sibling === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(node.</span><span class="s3">return </span><span class="s1">=== </span><span class="s3">null </span><span class="s1">|| node.</span><span class="s3">return </span><span class="s1">=== row) {</span>
        <span class="s3">return null</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">node = node.</span><span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">node.sibling.</span><span class="s3">return </span><span class="s1">= node.</span><span class="s3">return</span><span class="s1">;</span>
    <span class="s1">node = node.sibling;</span>
  <span class="s1">}</span>

  <span class="s3">return null</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">NoFlags$1 =</span>
  <span class="s0">/*   */</span>
  <span class="s4">0</span><span class="s1">; </span><span class="s0">// Represents whether effect should fire.</span>

<span class="s3">var </span><span class="s1">HasEffect =</span>
  <span class="s0">/* */</span>
  <span class="s4">1</span><span class="s1">; </span><span class="s0">// Represents the phase in which the effect (not the clean-up) fires.</span>

<span class="s3">var </span><span class="s1">Insertion =</span>
  <span class="s0">/*  */</span>
  <span class="s4">2</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">Layout =</span>
  <span class="s0">/*    */</span>
  <span class="s4">4</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">Passive$1 =</span>
  <span class="s0">/*   */</span>
  <span class="s4">8</span><span class="s1">;</span>

<span class="s0">// and should be reset before starting a new render.</span>
<span class="s0">// This tracks which mutable sources need to be reset after a render.</span>

<span class="s3">var </span><span class="s1">workInProgressSources = [];</span>
<span class="s3">function </span><span class="s1">resetWorkInProgressVersions() {</span>
  <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; workInProgressSources.length; i++) {</span>
    <span class="s3">var </span><span class="s1">mutableSource = workInProgressSources[i];</span>

    <span class="s1">{</span>
      <span class="s1">mutableSource._workInProgressVersionSecondary = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">workInProgressSources.length = </span><span class="s4">0</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher,</span>
  <span class="s1">ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig;</span>
<span class="s3">var </span><span class="s1">didWarnAboutMismatchedHooksForComponent;</span>
<span class="s3">var </span><span class="s1">didWarnUncachedGetSnapshot;</span>

<span class="s1">{</span>
  <span class="s1">didWarnAboutMismatchedHooksForComponent = </span><span class="s3">new </span><span class="s1">Set();</span>
<span class="s1">}</span>

<span class="s0">// These are set right before calling the component.</span>
<span class="s3">var </span><span class="s1">renderLanes = NoLanes; </span><span class="s0">// The work-in-progress fiber. I've named it differently to distinguish it from</span>
<span class="s0">// the work-in-progress hook.</span>

<span class="s3">var </span><span class="s1">currentlyRenderingFiber$1 = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// Hooks are stored as a linked list on the fiber's memoizedState field. The</span>
<span class="s0">// current hook list is the list that belongs to the current fiber. The</span>
<span class="s0">// work-in-progress hook list is a new list that will be added to the</span>
<span class="s0">// work-in-progress fiber.</span>

<span class="s3">var </span><span class="s1">currentHook = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">workInProgressHook = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// Whether an update was scheduled at any point during the render phase. This</span>
<span class="s0">// does not get reset if we do another render pass; only when we're completely</span>
<span class="s0">// finished evaluating this component. This is an optimization so we know</span>
<span class="s0">// whether we need to clear render phase updates after a throw.</span>

<span class="s3">var </span><span class="s1">didScheduleRenderPhaseUpdate = </span><span class="s3">false</span><span class="s1">; </span><span class="s0">// Where an update was scheduled only during the current render pass. This</span>
<span class="s0">// gets reset after each attempt.</span>
<span class="s0">// TODO: Maybe there's some way to consolidate this with</span>
<span class="s0">// `didScheduleRenderPhaseUpdate`. Or with `numberOfReRenders`.</span>

<span class="s3">var </span><span class="s1">didScheduleRenderPhaseUpdateDuringThisPass = </span><span class="s3">false</span><span class="s1">; </span><span class="s0">// Counts the number of useId hooks in this component.</span>
<span class="s0">// hydration). This counter is global, so client ids are not stable across</span>
<span class="s0">// render attempts.</span>

<span class="s3">var </span><span class="s1">globalClientIdCounter = </span><span class="s4">0</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">RE_RENDER_LIMIT = </span><span class="s4">25</span><span class="s1">; </span><span class="s0">// In DEV, this is the name of the currently executing primitive hook</span>

<span class="s3">var </span><span class="s1">currentHookNameInDev = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// In DEV, this list ensures that hooks are called in the same order between renders.</span>
<span class="s0">// The list stores the order of hooks used during the initial render (mount).</span>
<span class="s0">// Subsequent renders (updates) reference this list.</span>

<span class="s3">var </span><span class="s1">hookTypesDev = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">hookTypesUpdateIndexDev = -</span><span class="s4">1</span><span class="s1">; </span><span class="s0">// In DEV, this tracks whether currently rendering component needs to ignore</span>
<span class="s0">// the dependencies for Hooks that need them (e.g. useEffect or useMemo).</span>
<span class="s0">// When true, such Hooks will always be &quot;remounted&quot;. Only used during hot reload.</span>

<span class="s3">var </span><span class="s1">ignorePreviousDependencies = </span><span class="s3">false</span><span class="s1">;</span>

<span class="s3">function </span><span class="s1">mountHookTypesDev() {</span>
  <span class="s1">{</span>
    <span class="s3">var </span><span class="s1">hookName = currentHookNameInDev;</span>

    <span class="s3">if </span><span class="s1">(hookTypesDev === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">hookTypesDev = [hookName];</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">hookTypesDev.push(hookName);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">updateHookTypesDev() {</span>
  <span class="s1">{</span>
    <span class="s3">var </span><span class="s1">hookName = currentHookNameInDev;</span>

    <span class="s3">if </span><span class="s1">(hookTypesDev !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">hookTypesUpdateIndexDev++;</span>

      <span class="s3">if </span><span class="s1">(hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {</span>
        <span class="s1">warnOnHookMismatchInDev(hookName);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">checkDepsAreArrayDev(deps) {</span>
  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(deps !== undefined &amp;&amp; deps !== </span><span class="s3">null </span><span class="s1">&amp;&amp; !isArray(deps)) {</span>
      <span class="s0">// Verify deps, but only on mount to avoid extra checks.</span>
      <span class="s0">// It's unlikely their type would change as usually you define them inline.</span>
      <span class="s1">error(</span>
        <span class="s2">&quot;%s received a final argument that is not an array (instead, received `%s`). When &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;specified, the final argument must be an array.&quot;</span><span class="s1">,</span>
        <span class="s1">currentHookNameInDev,</span>
        <span class="s3">typeof </span><span class="s1">deps</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">warnOnHookMismatchInDev(currentHookName) {</span>
  <span class="s1">{</span>
    <span class="s3">var </span><span class="s1">componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);</span>

    <span class="s3">if </span><span class="s1">(!didWarnAboutMismatchedHooksForComponent.has(componentName)) {</span>
      <span class="s1">didWarnAboutMismatchedHooksForComponent.add(componentName);</span>

      <span class="s3">if </span><span class="s1">(hookTypesDev !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">table = </span><span class="s2">&quot;&quot;</span><span class="s1">;</span>
        <span class="s3">var </span><span class="s1">secondColumnStart = </span><span class="s4">30</span><span class="s1">;</span>

        <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt;= hookTypesUpdateIndexDev; i++) {</span>
          <span class="s3">var </span><span class="s1">oldHookName = hookTypesDev[i];</span>
          <span class="s3">var </span><span class="s1">newHookName =</span>
            <span class="s1">i === hookTypesUpdateIndexDev ? currentHookName : oldHookName;</span>
          <span class="s3">var </span><span class="s1">row = i + </span><span class="s4">1 </span><span class="s1">+ </span><span class="s2">&quot;. &quot; </span><span class="s1">+ oldHookName; </span><span class="s0">// Extra space so second column lines up</span>
          <span class="s0">// lol @ IE not supporting String#repeat</span>

          <span class="s3">while </span><span class="s1">(row.length &lt; secondColumnStart) {</span>
            <span class="s1">row += </span><span class="s2">&quot; &quot;</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s1">row += newHookName + </span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot;</span><span class="s1">;</span>
          <span class="s1">table += row;</span>
        <span class="s1">}</span>

        <span class="s1">error(</span>
          <span class="s2">&quot;React has detected a change in the order of Hooks called by %s. &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;This will lead to bugs and errors if not fixed. &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks</span><span class="s5">\n\n</span><span class="s2">&quot; </span><span class="s1">+</span>
            <span class="s2">&quot;   Previous render            Next render</span><span class="s5">\n</span><span class="s2">&quot; </span><span class="s1">+</span>
            <span class="s2">&quot;   ------------------------------------------------------</span><span class="s5">\n</span><span class="s2">&quot; </span><span class="s1">+</span>
            <span class="s2">&quot;%s&quot; </span><span class="s1">+</span>
            <span class="s2">&quot;   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span><span class="s5">\n</span><span class="s2">&quot;</span><span class="s1">,</span>
          <span class="s1">componentName,</span>
          <span class="s1">table</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">throwInvalidHookError() {</span>
  <span class="s3">throw new </span><span class="s1">Error(</span>
    <span class="s2">&quot;Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for&quot; </span><span class="s1">+</span>
      <span class="s2">&quot; one of the following reasons:</span><span class="s5">\n</span><span class="s2">&quot; </span><span class="s1">+</span>
      <span class="s2">&quot;1. You might have mismatching versions of React and the renderer (such as React DOM)</span><span class="s5">\n</span><span class="s2">&quot; </span><span class="s1">+</span>
      <span class="s2">&quot;2. You might be breaking the Rules of Hooks</span><span class="s5">\n</span><span class="s2">&quot; </span><span class="s1">+</span>
      <span class="s2">&quot;3. You might have more than one copy of React in the same app</span><span class="s5">\n</span><span class="s2">&quot; </span><span class="s1">+</span>
      <span class="s2">&quot;See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.&quot;</span>
  <span class="s1">);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">areHookInputsEqual(nextDeps, prevDeps) {</span>
  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(ignorePreviousDependencies) {</span>
      <span class="s0">// Only true when this component is being hot reloaded.</span>
      <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(prevDeps === </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s1">{</span>
      <span class="s1">error(</span>
        <span class="s2">&quot;%s received a final argument during this render, but not during &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;the previous render. Even though the final argument is optional, &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;its type cannot change between renders.&quot;</span><span class="s1">,</span>
        <span class="s1">currentHookNameInDev</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">return false</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s1">{</span>
    <span class="s0">// Don't bother comparing lengths in prod because these arrays should be</span>
    <span class="s0">// passed inline.</span>
    <span class="s3">if </span><span class="s1">(nextDeps.length !== prevDeps.length) {</span>
      <span class="s1">error(</span>
        <span class="s2">&quot;The final argument passed to %s changed size between renders. The &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;order and size of this array must remain constant.</span><span class="s5">\n\n</span><span class="s2">&quot; </span><span class="s1">+</span>
          <span class="s2">&quot;Previous: %s</span><span class="s5">\n</span><span class="s2">&quot; </span><span class="s1">+</span>
          <span class="s2">&quot;Incoming: %s&quot;</span><span class="s1">,</span>
        <span class="s1">currentHookNameInDev,</span>
        <span class="s2">&quot;[&quot; </span><span class="s1">+ prevDeps.join(</span><span class="s2">&quot;, &quot;</span><span class="s1">) + </span><span class="s2">&quot;]&quot;</span><span class="s1">,</span>
        <span class="s2">&quot;[&quot; </span><span class="s1">+ nextDeps.join(</span><span class="s2">&quot;, &quot;</span><span class="s1">) + </span><span class="s2">&quot;]&quot;</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; prevDeps.length &amp;&amp; i &lt; nextDeps.length; i++) {</span>
    <span class="s3">if </span><span class="s1">(objectIs(nextDeps[i], prevDeps[i])) {</span>
      <span class="s3">continue</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">return false</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">return true</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">renderWithHooks(</span>
  <span class="s1">current,</span>
  <span class="s1">workInProgress,</span>
  <span class="s1">Component,</span>
  <span class="s1">props,</span>
  <span class="s1">secondArg,</span>
  <span class="s1">nextRenderLanes</span>
<span class="s1">) {</span>
  <span class="s1">renderLanes = nextRenderLanes;</span>
  <span class="s1">currentlyRenderingFiber$1 = workInProgress;</span>

  <span class="s1">{</span>
    <span class="s1">hookTypesDev = current !== </span><span class="s3">null </span><span class="s1">? current._debugHookTypes : </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">hookTypesUpdateIndexDev = -</span><span class="s4">1</span><span class="s1">; </span><span class="s0">// Used for hot reloading:</span>

    <span class="s1">ignorePreviousDependencies =</span>
      <span class="s1">current !== </span><span class="s3">null </span><span class="s1">&amp;&amp; current.type !== workInProgress.type;</span>
  <span class="s1">}</span>

  <span class="s1">workInProgress.memoizedState = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">workInProgress.updateQueue = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">workInProgress.lanes = NoLanes; </span><span class="s0">// The following should have already been reset</span>
  <span class="s0">// currentHook = null;</span>
  <span class="s0">// workInProgressHook = null;</span>
  <span class="s0">// didScheduleRenderPhaseUpdate = false;</span>
  <span class="s0">// localIdCounter = 0;</span>
  <span class="s0">// TODO Warn if no hooks are used at all during mount, then some are used during update.</span>
  <span class="s0">// Currently we will identify the update render as a mount because memoizedState === null.</span>
  <span class="s0">// This is tricky because it's valid for certain types of components (e.g. React.lazy)</span>
  <span class="s0">// Using memoizedState to differentiate between mount/update only works if at least one stateful hook is used.</span>
  <span class="s0">// Non-stateful hooks (e.g. context) don't get added to memoizedState,</span>
  <span class="s0">// so memoizedState would be null during updates and mounts.</span>

  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(current !== </span><span class="s3">null </span><span class="s1">&amp;&amp; current.memoizedState !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">ReactCurrentDispatcher$1.current = HooksDispatcherOnUpdateInDEV;</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(hookTypesDev !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// This dispatcher handles an edge case where a component is updating,</span>
      <span class="s0">// but no stateful hooks have been used.</span>
      <span class="s0">// We want to match the production code behavior (which will use HooksDispatcherOnMount),</span>
      <span class="s0">// but with the extra DEV validation to ensure hooks ordering hasn't changed.</span>
      <span class="s0">// This dispatcher does that.</span>
      <span class="s1">ReactCurrentDispatcher$1.current = HooksDispatcherOnMountWithHookTypesInDEV;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">ReactCurrentDispatcher$1.current = HooksDispatcherOnMountInDEV;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">children = Component(props, secondArg); </span><span class="s0">// Check if there was a render phase update</span>

  <span class="s3">if </span><span class="s1">(didScheduleRenderPhaseUpdateDuringThisPass) {</span>
    <span class="s0">// Keep rendering in a loop for as long as render phase updates continue to</span>
    <span class="s0">// be scheduled. Use a counter to prevent infinite loops.</span>
    <span class="s3">var </span><span class="s1">numberOfReRenders = </span><span class="s4">0</span><span class="s1">;</span>

    <span class="s3">do </span><span class="s1">{</span>
      <span class="s1">didScheduleRenderPhaseUpdateDuringThisPass = </span><span class="s3">false</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s1">(numberOfReRenders &gt;= RE_RENDER_LIMIT) {</span>
        <span class="s3">throw new </span><span class="s1">Error(</span>
          <span class="s2">&quot;Too many re-renders. React limits the number of renders to prevent &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;an infinite loop.&quot;</span>
        <span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s1">numberOfReRenders += </span><span class="s4">1</span><span class="s1">;</span>

      <span class="s1">{</span>
        <span class="s0">// Even when hot reloading, allow dependencies to stabilize</span>
        <span class="s0">// after first render to prevent infinite render phase updates.</span>
        <span class="s1">ignorePreviousDependencies = </span><span class="s3">false</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// Start over from the beginning of the list</span>

      <span class="s1">currentHook = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">workInProgressHook = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">workInProgress.updateQueue = </span><span class="s3">null</span><span class="s1">;</span>

      <span class="s1">{</span>
        <span class="s0">// Also validate hook order for cascading updates.</span>
        <span class="s1">hookTypesUpdateIndexDev = -</span><span class="s4">1</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">ReactCurrentDispatcher$1.current = HooksDispatcherOnRerenderInDEV;</span>
      <span class="s1">children = Component(props, secondArg);</span>
    <span class="s1">} </span><span class="s3">while </span><span class="s1">(didScheduleRenderPhaseUpdateDuringThisPass);</span>
  <span class="s1">} </span><span class="s0">// We can assume the previous dispatcher is always this one, since we set it</span>
  <span class="s0">// at the beginning of the render phase and there's no re-entrance.</span>

  <span class="s1">ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;</span>

  <span class="s1">{</span>
    <span class="s1">workInProgress._debugHookTypes = hookTypesDev;</span>
  <span class="s1">} </span><span class="s0">// This check uses currentHook so that it works the same in DEV and prod bundles.</span>
  <span class="s0">// hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.</span>

  <span class="s3">var </span><span class="s1">didRenderTooFewHooks = currentHook !== </span><span class="s3">null </span><span class="s1">&amp;&amp; currentHook.next !== </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">renderLanes = NoLanes;</span>
  <span class="s1">currentlyRenderingFiber$1 = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">currentHook = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">workInProgressHook = </span><span class="s3">null</span><span class="s1">;</span>

  <span class="s1">{</span>
    <span class="s1">currentHookNameInDev = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">hookTypesDev = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">hookTypesUpdateIndexDev = -</span><span class="s4">1</span><span class="s1">; </span><span class="s0">// Confirm that a static flag was not added or removed since the last</span>
    <span class="s0">// render. If this fires, it suggests that we incorrectly reset the static</span>
    <span class="s0">// flags in some other part of the codebase. This has happened before, for</span>
    <span class="s0">// example, in the SuspenseList implementation.</span>

    <span class="s3">if </span><span class="s1">(</span>
      <span class="s1">current !== </span><span class="s3">null </span><span class="s1">&amp;&amp;</span>
      <span class="s1">(current.flags &amp; StaticMask) !== (workInProgress.flags &amp; StaticMask) &amp;&amp; </span><span class="s0">// Disable this warning in legacy mode, because legacy Suspense is weird</span>
      <span class="s0">// and creates false positives. To make this work in legacy mode, we'd</span>
      <span class="s0">// need to mark fibers that commit in an incomplete state, somehow. For</span>
      <span class="s0">// now I'll disable the warning that most of the bugs that would trigger</span>
      <span class="s0">// it are either exclusive to concurrent mode or exist in both.</span>
      <span class="s1">(current.mode &amp; ConcurrentMode) !== NoMode</span>
    <span class="s1">) {</span>
      <span class="s1">error(</span>
        <span class="s2">&quot;Internal React error: Expected static flag was missing. Please &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;notify the React team.&quot;</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">didScheduleRenderPhaseUpdate = </span><span class="s3">false</span><span class="s1">; </span><span class="s0">// This is reset by checkDidRenderIdHook</span>
  <span class="s0">// localIdCounter = 0;</span>

  <span class="s3">if </span><span class="s1">(didRenderTooFewHooks) {</span>
    <span class="s3">throw new </span><span class="s1">Error(</span>
      <span class="s2">&quot;Rendered fewer hooks than expected. This may be caused by an accidental &quot; </span><span class="s1">+</span>
        <span class="s2">&quot;early return statement.&quot;</span>
    <span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">children;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">bailoutHooks(current, workInProgress, lanes) {</span>
  <span class="s1">workInProgress.updateQueue = current.updateQueue; </span><span class="s0">// TODO: Don't need to reset the flags here, because they're reset in the</span>
  <span class="s0">// complete phase (bubbleProperties).</span>

  <span class="s1">{</span>
    <span class="s1">workInProgress.flags &amp;= ~(Passive | Update);</span>
  <span class="s1">}</span>

  <span class="s1">current.lanes = removeLanes(current.lanes, lanes);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">resetHooksAfterThrow() {</span>
  <span class="s0">// We can assume the previous dispatcher is always this one, since we set it</span>
  <span class="s0">// at the beginning of the render phase and there's no re-entrance.</span>
  <span class="s1">ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;</span>

  <span class="s3">if </span><span class="s1">(didScheduleRenderPhaseUpdate) {</span>
    <span class="s0">// There were render phase updates. These are only valid for this render</span>
    <span class="s0">// phase, which we are now aborting. Remove the updates from the queues so</span>
    <span class="s0">// they do not persist to the next render. Do not remove updates from hooks</span>
    <span class="s0">// that weren't processed.</span>
    <span class="s0">//</span>
    <span class="s0">// Only reset the updates from the queue if it has a clone. If it does</span>
    <span class="s0">// not have a clone, that means it wasn't processed, and the updates were</span>
    <span class="s0">// scheduled before we entered the render phase.</span>
    <span class="s3">var </span><span class="s1">hook = currentlyRenderingFiber$1.memoizedState;</span>

    <span class="s3">while </span><span class="s1">(hook !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">queue = hook.queue;</span>

      <span class="s3">if </span><span class="s1">(queue !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">queue.pending = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">hook = hook.next;</span>
    <span class="s1">}</span>

    <span class="s1">didScheduleRenderPhaseUpdate = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s1">renderLanes = NoLanes;</span>
  <span class="s1">currentlyRenderingFiber$1 = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">currentHook = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">workInProgressHook = </span><span class="s3">null</span><span class="s1">;</span>

  <span class="s1">{</span>
    <span class="s1">hookTypesDev = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">hookTypesUpdateIndexDev = -</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">currentHookNameInDev = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">isUpdatingOpaqueValueInRenderPhase = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s1">didScheduleRenderPhaseUpdateDuringThisPass = </span><span class="s3">false</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">mountWorkInProgressHook() {</span>
  <span class="s3">var </span><span class="s1">hook = {</span>
    <span class="s1">memoizedState: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">baseState: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">baseQueue: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">queue: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">next: </span><span class="s3">null</span>
  <span class="s1">};</span>

  <span class="s3">if </span><span class="s1">(workInProgressHook === </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s0">// This is the first hook in the list</span>
    <span class="s1">currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s0">// Append to the end of the list</span>
    <span class="s1">workInProgressHook = workInProgressHook.next = hook;</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">workInProgressHook;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">updateWorkInProgressHook() {</span>
  <span class="s0">// This function is used both for updates and for re-renders triggered by a</span>
  <span class="s0">// render phase update. It assumes there is either a current hook we can</span>
  <span class="s0">// clone, or a work-in-progress hook from a previous render pass that we can</span>
  <span class="s0">// use as a base. When we reach the end of the base list, we must switch to</span>
  <span class="s0">// the dispatcher used for mounts.</span>
  <span class="s3">var </span><span class="s1">nextCurrentHook;</span>

  <span class="s3">if </span><span class="s1">(currentHook === </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">current = currentlyRenderingFiber$1.alternate;</span>

    <span class="s3">if </span><span class="s1">(current !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">nextCurrentHook = current.memoizedState;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">nextCurrentHook = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">nextCurrentHook = currentHook.next;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">nextWorkInProgressHook;</span>

  <span class="s3">if </span><span class="s1">(workInProgressHook === </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s1">nextWorkInProgressHook = currentlyRenderingFiber$1.memoizedState;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">nextWorkInProgressHook = workInProgressHook.next;</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(nextWorkInProgressHook !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s0">// There's already a work-in-progress. Reuse it.</span>
    <span class="s1">workInProgressHook = nextWorkInProgressHook;</span>
    <span class="s1">nextWorkInProgressHook = workInProgressHook.next;</span>
    <span class="s1">currentHook = nextCurrentHook;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s0">// Clone from the current hook.</span>
    <span class="s3">if </span><span class="s1">(nextCurrentHook === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Rendered more hooks than during the previous render.&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s1">currentHook = nextCurrentHook;</span>
    <span class="s3">var </span><span class="s1">newHook = {</span>
      <span class="s1">memoizedState: currentHook.memoizedState,</span>
      <span class="s1">baseState: currentHook.baseState,</span>
      <span class="s1">baseQueue: currentHook.baseQueue,</span>
      <span class="s1">queue: currentHook.queue,</span>
      <span class="s1">next: </span><span class="s3">null</span>
    <span class="s1">};</span>

    <span class="s3">if </span><span class="s1">(workInProgressHook === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// This is the first hook in the list.</span>
      <span class="s1">currentlyRenderingFiber$1.memoizedState = workInProgressHook = newHook;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s0">// Append to the end of the list.</span>
      <span class="s1">workInProgressHook = workInProgressHook.next = newHook;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">workInProgressHook;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">createFunctionComponentUpdateQueue() {</span>
  <span class="s3">return </span><span class="s1">{</span>
    <span class="s1">lastEffect: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">stores: </span><span class="s3">null</span>
  <span class="s1">};</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">basicStateReducer(state, action) {</span>
  <span class="s0">// $FlowFixMe: Flow doesn't like mixed types</span>
  <span class="s3">return typeof </span><span class="s1">action === </span><span class="s2">&quot;function&quot; </span><span class="s1">? action(state) : action;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">mountReducer(reducer, initialArg, init) {</span>
  <span class="s3">var </span><span class="s1">hook = mountWorkInProgressHook();</span>
  <span class="s3">var </span><span class="s1">initialState;</span>

  <span class="s3">if </span><span class="s1">(init !== undefined) {</span>
    <span class="s1">initialState = init(initialArg);</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">initialState = initialArg;</span>
  <span class="s1">}</span>

  <span class="s1">hook.memoizedState = hook.baseState = initialState;</span>
  <span class="s3">var </span><span class="s1">queue = {</span>
    <span class="s1">pending: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">interleaved: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">lanes: NoLanes,</span>
    <span class="s1">dispatch: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">lastRenderedReducer: reducer,</span>
    <span class="s1">lastRenderedState: initialState</span>
  <span class="s1">};</span>
  <span class="s1">hook.queue = queue;</span>
  <span class="s3">var </span><span class="s1">dispatch = (queue.dispatch = dispatchReducerAction.bind(</span>
    <span class="s3">null</span><span class="s1">,</span>
    <span class="s1">currentlyRenderingFiber$1,</span>
    <span class="s1">queue</span>
  <span class="s1">));</span>
  <span class="s3">return </span><span class="s1">[hook.memoizedState, dispatch];</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">updateReducer(reducer, initialArg, init) {</span>
  <span class="s3">var </span><span class="s1">hook = updateWorkInProgressHook();</span>
  <span class="s3">var </span><span class="s1">queue = hook.queue;</span>

  <span class="s3">if </span><span class="s1">(queue === </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">throw new </span><span class="s1">Error(</span>
      <span class="s2">&quot;Should have a queue. This is likely a bug in React. Please file an issue.&quot;</span>
    <span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s1">queue.lastRenderedReducer = reducer;</span>
  <span class="s3">var </span><span class="s1">current = currentHook; </span><span class="s0">// The last rebase update that is NOT part of the base state.</span>

  <span class="s3">var </span><span class="s1">baseQueue = current.baseQueue; </span><span class="s0">// The last pending update that hasn't been processed yet.</span>

  <span class="s3">var </span><span class="s1">pendingQueue = queue.pending;</span>

  <span class="s3">if </span><span class="s1">(pendingQueue !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s0">// We have new updates that haven't been processed yet.</span>
    <span class="s0">// We'll add them to the base queue.</span>
    <span class="s3">if </span><span class="s1">(baseQueue !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// Merge the pending queue and the base queue.</span>
      <span class="s3">var </span><span class="s1">baseFirst = baseQueue.next;</span>
      <span class="s3">var </span><span class="s1">pendingFirst = pendingQueue.next;</span>
      <span class="s1">baseQueue.next = pendingFirst;</span>
      <span class="s1">pendingQueue.next = baseFirst;</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(current.baseQueue !== baseQueue) {</span>
        <span class="s0">// Internal invariant that should never happen, but feasibly could in</span>
        <span class="s0">// the future if we implement resuming, or some form of that.</span>
        <span class="s1">error(</span>
          <span class="s2">&quot;Internal error: Expected work-in-progress queue to be a clone. &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;This is a bug in React.&quot;</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">current.baseQueue = baseQueue = pendingQueue;</span>
    <span class="s1">queue.pending = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(baseQueue !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s0">// We have a queue to process.</span>
    <span class="s3">var </span><span class="s1">first = baseQueue.next;</span>
    <span class="s3">var </span><span class="s1">newState = current.baseState;</span>
    <span class="s3">var </span><span class="s1">newBaseState = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">newBaseQueueFirst = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">newBaseQueueLast = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">update = first;</span>

    <span class="s3">do </span><span class="s1">{</span>
      <span class="s3">var </span><span class="s1">updateLane = update.lane;</span>

      <span class="s3">if </span><span class="s1">(!isSubsetOfLanes(renderLanes, updateLane)) {</span>
        <span class="s0">// Priority is insufficient. Skip this update. If this is the first</span>
        <span class="s0">// skipped update, the previous update/state is the new base</span>
        <span class="s0">// update/state.</span>
        <span class="s3">var </span><span class="s1">clone = {</span>
          <span class="s1">lane: updateLane,</span>
          <span class="s1">action: update.action,</span>
          <span class="s1">hasEagerState: update.hasEagerState,</span>
          <span class="s1">eagerState: update.eagerState,</span>
          <span class="s1">next: </span><span class="s3">null</span>
        <span class="s1">};</span>

        <span class="s3">if </span><span class="s1">(newBaseQueueLast === </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">newBaseQueueFirst = newBaseQueueLast = clone;</span>
          <span class="s1">newBaseState = newState;</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s1">newBaseQueueLast = newBaseQueueLast.next = clone;</span>
        <span class="s1">} </span><span class="s0">// Update the remaining priority in the queue.</span>
        <span class="s0">// TODO: Don't need to accumulate this. Instead, we can remove</span>
        <span class="s0">// renderLanes from the original lanes.</span>

        <span class="s1">currentlyRenderingFiber$1.lanes = mergeLanes(</span>
          <span class="s1">currentlyRenderingFiber$1.lanes,</span>
          <span class="s1">updateLane</span>
        <span class="s1">);</span>
        <span class="s1">markSkippedUpdateLanes(updateLane);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s0">// This update does have sufficient priority.</span>
        <span class="s3">if </span><span class="s1">(newBaseQueueLast !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s3">var </span><span class="s1">_clone = {</span>
            <span class="s0">// This update is going to be committed so we never want uncommit</span>
            <span class="s0">// it. Using NoLane works because 0 is a subset of all bitmasks, so</span>
            <span class="s0">// this will never be skipped by the check above.</span>
            <span class="s1">lane: NoLane,</span>
            <span class="s1">action: update.action,</span>
            <span class="s1">hasEagerState: update.hasEagerState,</span>
            <span class="s1">eagerState: update.eagerState,</span>
            <span class="s1">next: </span><span class="s3">null</span>
          <span class="s1">};</span>
          <span class="s1">newBaseQueueLast = newBaseQueueLast.next = _clone;</span>
        <span class="s1">} </span><span class="s0">// Process this update.</span>

        <span class="s3">if </span><span class="s1">(update.hasEagerState) {</span>
          <span class="s0">// If this update is a state update (not a reducer) and was processed eagerly,</span>
          <span class="s0">// we can use the eagerly computed state</span>
          <span class="s1">newState = update.eagerState;</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s3">var </span><span class="s1">action = update.action;</span>
          <span class="s1">newState = reducer(newState, action);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">update = update.next;</span>
    <span class="s1">} </span><span class="s3">while </span><span class="s1">(update !== </span><span class="s3">null </span><span class="s1">&amp;&amp; update !== first);</span>

    <span class="s3">if </span><span class="s1">(newBaseQueueLast === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">newBaseState = newState;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">newBaseQueueLast.next = newBaseQueueFirst;</span>
    <span class="s1">} </span><span class="s0">// Mark that the fiber performed work, but only if the new state is</span>
    <span class="s0">// different from the current state.</span>

    <span class="s3">if </span><span class="s1">(!objectIs(newState, hook.memoizedState)) {</span>
      <span class="s1">markWorkInProgressReceivedUpdate();</span>
    <span class="s1">}</span>

    <span class="s1">hook.memoizedState = newState;</span>
    <span class="s1">hook.baseState = newBaseState;</span>
    <span class="s1">hook.baseQueue = newBaseQueueLast;</span>
    <span class="s1">queue.lastRenderedState = newState;</span>
  <span class="s1">} </span><span class="s0">// Interleaved updates are stored on a separate queue. We aren't going to</span>
  <span class="s0">// process them during this render, but we do need to track which lanes</span>
  <span class="s0">// are remaining.</span>

  <span class="s3">var </span><span class="s1">lastInterleaved = queue.interleaved;</span>

  <span class="s3">if </span><span class="s1">(lastInterleaved !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">interleaved = lastInterleaved;</span>

    <span class="s3">do </span><span class="s1">{</span>
      <span class="s3">var </span><span class="s1">interleavedLane = interleaved.lane;</span>
      <span class="s1">currentlyRenderingFiber$1.lanes = mergeLanes(</span>
        <span class="s1">currentlyRenderingFiber$1.lanes,</span>
        <span class="s1">interleavedLane</span>
      <span class="s1">);</span>
      <span class="s1">markSkippedUpdateLanes(interleavedLane);</span>
      <span class="s1">interleaved = interleaved.next;</span>
    <span class="s1">} </span><span class="s3">while </span><span class="s1">(interleaved !== lastInterleaved);</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(baseQueue === </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s0">// `queue.lanes` is used for entangling transitions. We can set it back to</span>
    <span class="s0">// zero once the queue is empty.</span>
    <span class="s1">queue.lanes = NoLanes;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">dispatch = queue.dispatch;</span>
  <span class="s3">return </span><span class="s1">[hook.memoizedState, dispatch];</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">rerenderReducer(reducer, initialArg, init) {</span>
  <span class="s3">var </span><span class="s1">hook = updateWorkInProgressHook();</span>
  <span class="s3">var </span><span class="s1">queue = hook.queue;</span>

  <span class="s3">if </span><span class="s1">(queue === </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">throw new </span><span class="s1">Error(</span>
      <span class="s2">&quot;Should have a queue. This is likely a bug in React. Please file an issue.&quot;</span>
    <span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s1">queue.lastRenderedReducer = reducer; </span><span class="s0">// This is a re-render. Apply the new render phase updates to the previous</span>
  <span class="s0">// work-in-progress hook.</span>

  <span class="s3">var </span><span class="s1">dispatch = queue.dispatch;</span>
  <span class="s3">var </span><span class="s1">lastRenderPhaseUpdate = queue.pending;</span>
  <span class="s3">var </span><span class="s1">newState = hook.memoizedState;</span>

  <span class="s3">if </span><span class="s1">(lastRenderPhaseUpdate !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s0">// The queue doesn't persist past this render pass.</span>
    <span class="s1">queue.pending = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;</span>
    <span class="s3">var </span><span class="s1">update = firstRenderPhaseUpdate;</span>

    <span class="s3">do </span><span class="s1">{</span>
      <span class="s0">// Process this render phase update. We don't have to check the</span>
      <span class="s0">// priority because it will always be the same as the current</span>
      <span class="s0">// render's.</span>
      <span class="s3">var </span><span class="s1">action = update.action;</span>
      <span class="s1">newState = reducer(newState, action);</span>
      <span class="s1">update = update.next;</span>
    <span class="s1">} </span><span class="s3">while </span><span class="s1">(update !== firstRenderPhaseUpdate); </span><span class="s0">// Mark that the fiber performed work, but only if the new state is</span>
    <span class="s0">// different from the current state.</span>

    <span class="s3">if </span><span class="s1">(!objectIs(newState, hook.memoizedState)) {</span>
      <span class="s1">markWorkInProgressReceivedUpdate();</span>
    <span class="s1">}</span>

    <span class="s1">hook.memoizedState = newState; </span><span class="s0">// Don't persist the state accumulated from the render phase updates to</span>
    <span class="s0">// the base state unless the queue is empty.</span>
    <span class="s0">// TODO: Not sure if this is the desired semantics, but it's what we</span>
    <span class="s0">// do for gDSFP. I can't remember why.</span>

    <span class="s3">if </span><span class="s1">(hook.baseQueue === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">hook.baseState = newState;</span>
    <span class="s1">}</span>

    <span class="s1">queue.lastRenderedState = newState;</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">[newState, dispatch];</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">mountMutableSource(source, getSnapshot, subscribe) {</span>
  <span class="s1">{</span>
    <span class="s3">return </span><span class="s1">undefined;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">updateMutableSource(source, getSnapshot, subscribe) {</span>
  <span class="s1">{</span>
    <span class="s3">return </span><span class="s1">undefined;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {</span>
  <span class="s3">var </span><span class="s1">fiber = currentlyRenderingFiber$1;</span>
  <span class="s3">var </span><span class="s1">hook = mountWorkInProgressHook();</span>
  <span class="s3">var </span><span class="s1">nextSnapshot;</span>

  <span class="s1">{</span>
    <span class="s1">nextSnapshot = getSnapshot();</span>

    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(!didWarnUncachedGetSnapshot) {</span>
        <span class="s3">var </span><span class="s1">cachedSnapshot = getSnapshot();</span>

        <span class="s3">if </span><span class="s1">(!objectIs(nextSnapshot, cachedSnapshot)) {</span>
          <span class="s1">error(</span>
            <span class="s2">&quot;The result of getSnapshot should be cached to avoid an infinite loop&quot;</span>
          <span class="s1">);</span>

          <span class="s1">didWarnUncachedGetSnapshot = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// Unless we're rendering a blocking lane, schedule a consistency check.</span>
    <span class="s0">// Right before committing, we will walk the tree and check if any of the</span>
    <span class="s0">// stores were mutated.</span>
    <span class="s0">//</span>
    <span class="s0">// We won't do this if we're hydrating server-rendered content, because if</span>
    <span class="s0">// the content is stale, it's already visible anyway. Instead we'll patch</span>
    <span class="s0">// it up in a passive effect.</span>

    <span class="s3">var </span><span class="s1">root = getWorkInProgressRoot();</span>

    <span class="s3">if </span><span class="s1">(root === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">throw new </span><span class="s1">Error(</span>
        <span class="s2">&quot;Expected a work-in-progress root. This is a bug in React. Please file an issue.&quot;</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(!includesBlockingLane(root, renderLanes)) {</span>
      <span class="s1">pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s0">// Read the current snapshot from the store on every render. This breaks the</span>
  <span class="s0">// normal rules of React, and only works because store updates are</span>
  <span class="s0">// always synchronous.</span>

  <span class="s1">hook.memoizedState = nextSnapshot;</span>
  <span class="s3">var </span><span class="s1">inst = {</span>
    <span class="s1">value: nextSnapshot,</span>
    <span class="s1">getSnapshot: getSnapshot</span>
  <span class="s1">};</span>
  <span class="s1">hook.queue = inst; </span><span class="s0">// Schedule an effect to subscribe to the store.</span>

  <span class="s1">mountEffect(subscribeToStore.bind(</span><span class="s3">null</span><span class="s1">, fiber, inst, subscribe), [subscribe]); </span><span class="s0">// Schedule an effect to update the mutable instance fields. We will update</span>
  <span class="s0">// this whenever subscribe, getSnapshot, or value changes. Because there's no</span>
  <span class="s0">// clean-up function, and we track the deps correctly, we can call pushEffect</span>
  <span class="s0">// directly, without storing any additional state. For the same reason, we</span>
  <span class="s0">// don't need to set a static flag, either.</span>
  <span class="s0">// TODO: We can move this to the passive phase once we add a pre-commit</span>
  <span class="s0">// consistency check. See the next comment.</span>

  <span class="s1">fiber.flags |= Passive;</span>
  <span class="s1">pushEffect(</span>
    <span class="s1">HasEffect | Passive$1,</span>
    <span class="s1">updateStoreInstance.bind(</span><span class="s3">null</span><span class="s1">, fiber, inst, nextSnapshot, getSnapshot),</span>
    <span class="s1">undefined,</span>
    <span class="s3">null</span>
  <span class="s1">);</span>
  <span class="s3">return </span><span class="s1">nextSnapshot;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {</span>
  <span class="s3">var </span><span class="s1">fiber = currentlyRenderingFiber$1;</span>
  <span class="s3">var </span><span class="s1">hook = updateWorkInProgressHook(); </span><span class="s0">// Read the current snapshot from the store on every render. This breaks the</span>
  <span class="s0">// normal rules of React, and only works because store updates are</span>
  <span class="s0">// always synchronous.</span>

  <span class="s3">var </span><span class="s1">nextSnapshot = getSnapshot();</span>

  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(!didWarnUncachedGetSnapshot) {</span>
      <span class="s3">var </span><span class="s1">cachedSnapshot = getSnapshot();</span>

      <span class="s3">if </span><span class="s1">(!objectIs(nextSnapshot, cachedSnapshot)) {</span>
        <span class="s1">error(</span>
          <span class="s2">&quot;The result of getSnapshot should be cached to avoid an infinite loop&quot;</span>
        <span class="s1">);</span>

        <span class="s1">didWarnUncachedGetSnapshot = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">prevSnapshot = hook.memoizedState;</span>
  <span class="s3">var </span><span class="s1">snapshotChanged = !objectIs(prevSnapshot, nextSnapshot);</span>

  <span class="s3">if </span><span class="s1">(snapshotChanged) {</span>
    <span class="s1">hook.memoizedState = nextSnapshot;</span>
    <span class="s1">markWorkInProgressReceivedUpdate();</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">inst = hook.queue;</span>
  <span class="s1">updateEffect(subscribeToStore.bind(</span><span class="s3">null</span><span class="s1">, fiber, inst, subscribe), [</span>
    <span class="s1">subscribe</span>
  <span class="s1">]); </span><span class="s0">// Whenever getSnapshot or subscribe changes, we need to check in the</span>
  <span class="s0">// commit phase if there was an interleaved mutation. In concurrent mode</span>
  <span class="s0">// this can happen all the time, but even in synchronous mode, an earlier</span>
  <span class="s0">// effect may have mutated the store.</span>

  <span class="s3">if </span><span class="s1">(</span>
    <span class="s1">inst.getSnapshot !== getSnapshot ||</span>
    <span class="s1">snapshotChanged || </span><span class="s0">// Check if the susbcribe function changed. We can save some memory by</span>
    <span class="s0">// checking whether we scheduled a subscription effect above.</span>
    <span class="s1">(workInProgressHook !== </span><span class="s3">null </span><span class="s1">&amp;&amp;</span>
      <span class="s1">workInProgressHook.memoizedState.tag &amp; HasEffect)</span>
  <span class="s1">) {</span>
    <span class="s1">fiber.flags |= Passive;</span>
    <span class="s1">pushEffect(</span>
      <span class="s1">HasEffect | Passive$1,</span>
      <span class="s1">updateStoreInstance.bind(</span><span class="s3">null</span><span class="s1">, fiber, inst, nextSnapshot, getSnapshot),</span>
      <span class="s1">undefined,</span>
      <span class="s3">null</span>
    <span class="s1">); </span><span class="s0">// Unless we're rendering a blocking lane, schedule a consistency check.</span>
    <span class="s0">// Right before committing, we will walk the tree and check if any of the</span>
    <span class="s0">// stores were mutated.</span>

    <span class="s3">var </span><span class="s1">root = getWorkInProgressRoot();</span>

    <span class="s3">if </span><span class="s1">(root === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">throw new </span><span class="s1">Error(</span>
        <span class="s2">&quot;Expected a work-in-progress root. This is a bug in React. Please file an issue.&quot;</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(!includesBlockingLane(root, renderLanes)) {</span>
      <span class="s1">pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">nextSnapshot;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {</span>
  <span class="s1">fiber.flags |= StoreConsistency;</span>
  <span class="s3">var </span><span class="s1">check = {</span>
    <span class="s1">getSnapshot: getSnapshot,</span>
    <span class="s1">value: renderedSnapshot</span>
  <span class="s1">};</span>
  <span class="s3">var </span><span class="s1">componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;</span>

  <span class="s3">if </span><span class="s1">(componentUpdateQueue === </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s1">componentUpdateQueue = createFunctionComponentUpdateQueue();</span>
    <span class="s1">currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;</span>
    <span class="s1">componentUpdateQueue.stores = [check];</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s3">var </span><span class="s1">stores = componentUpdateQueue.stores;</span>

    <span class="s3">if </span><span class="s1">(stores === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">componentUpdateQueue.stores = [check];</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">stores.push(check);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {</span>
  <span class="s0">// These are updated in the passive phase</span>
  <span class="s1">inst.value = nextSnapshot;</span>
  <span class="s1">inst.getSnapshot = getSnapshot; </span><span class="s0">// Something may have been mutated in between render and commit. This could</span>
  <span class="s0">// have been in an event that fired before the passive effects, or it could</span>
  <span class="s0">// have been in a layout effect. In that case, we would have used the old</span>
  <span class="s0">// snapsho and getSnapshot values to bail out. We need to check one more time.</span>

  <span class="s3">if </span><span class="s1">(checkIfSnapshotChanged(inst)) {</span>
    <span class="s0">// Force a re-render.</span>
    <span class="s1">forceStoreRerender(fiber);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">subscribeToStore(fiber, inst, subscribe) {</span>
  <span class="s3">var </span><span class="s1">handleStoreChange = </span><span class="s3">function</span><span class="s1">() {</span>
    <span class="s0">// The store changed. Check if the snapshot changed since the last time we</span>
    <span class="s0">// read from the store.</span>
    <span class="s3">if </span><span class="s1">(checkIfSnapshotChanged(inst)) {</span>
      <span class="s0">// Force a re-render.</span>
      <span class="s1">forceStoreRerender(fiber);</span>
    <span class="s1">}</span>
  <span class="s1">}; </span><span class="s0">// Subscribe to the store and return a clean-up function.</span>

  <span class="s3">return </span><span class="s1">subscribe(handleStoreChange);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">checkIfSnapshotChanged(inst) {</span>
  <span class="s3">var </span><span class="s1">latestGetSnapshot = inst.getSnapshot;</span>
  <span class="s3">var </span><span class="s1">prevValue = inst.value;</span>

  <span class="s3">try </span><span class="s1">{</span>
    <span class="s3">var </span><span class="s1">nextValue = latestGetSnapshot();</span>
    <span class="s3">return </span><span class="s1">!objectIs(prevValue, nextValue);</span>
  <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
    <span class="s3">return true</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">forceStoreRerender(fiber) {</span>
  <span class="s3">var </span><span class="s1">root = enqueueConcurrentRenderForLane(fiber, SyncLane);</span>

  <span class="s3">if </span><span class="s1">(root !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s1">scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">mountState(initialState) {</span>
  <span class="s3">var </span><span class="s1">hook = mountWorkInProgressHook();</span>

  <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">initialState === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
    <span class="s0">// $FlowFixMe: Flow doesn't like mixed types</span>
    <span class="s1">initialState = initialState();</span>
  <span class="s1">}</span>

  <span class="s1">hook.memoizedState = hook.baseState = initialState;</span>
  <span class="s3">var </span><span class="s1">queue = {</span>
    <span class="s1">pending: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">interleaved: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">lanes: NoLanes,</span>
    <span class="s1">dispatch: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">lastRenderedReducer: basicStateReducer,</span>
    <span class="s1">lastRenderedState: initialState</span>
  <span class="s1">};</span>
  <span class="s1">hook.queue = queue;</span>
  <span class="s3">var </span><span class="s1">dispatch = (queue.dispatch = dispatchSetState.bind(</span>
    <span class="s3">null</span><span class="s1">,</span>
    <span class="s1">currentlyRenderingFiber$1,</span>
    <span class="s1">queue</span>
  <span class="s1">));</span>
  <span class="s3">return </span><span class="s1">[hook.memoizedState, dispatch];</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">updateState(initialState) {</span>
  <span class="s3">return </span><span class="s1">updateReducer(basicStateReducer);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">rerenderState(initialState) {</span>
  <span class="s3">return </span><span class="s1">rerenderReducer(basicStateReducer);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">pushEffect(tag, create, destroy, deps) {</span>
  <span class="s3">var </span><span class="s1">effect = {</span>
    <span class="s1">tag: tag,</span>
    <span class="s1">create: create,</span>
    <span class="s1">destroy: destroy,</span>
    <span class="s1">deps: deps,</span>
    <span class="s0">// Circular</span>
    <span class="s1">next: </span><span class="s3">null</span>
  <span class="s1">};</span>
  <span class="s3">var </span><span class="s1">componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;</span>

  <span class="s3">if </span><span class="s1">(componentUpdateQueue === </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s1">componentUpdateQueue = createFunctionComponentUpdateQueue();</span>
    <span class="s1">currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;</span>
    <span class="s1">componentUpdateQueue.lastEffect = effect.next = effect;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s3">var </span><span class="s1">lastEffect = componentUpdateQueue.lastEffect;</span>

    <span class="s3">if </span><span class="s1">(lastEffect === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">componentUpdateQueue.lastEffect = effect.next = effect;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">var </span><span class="s1">firstEffect = lastEffect.next;</span>
      <span class="s1">lastEffect.next = effect;</span>
      <span class="s1">effect.next = firstEffect;</span>
      <span class="s1">componentUpdateQueue.lastEffect = effect;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">effect;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">mountRef(initialValue) {</span>
  <span class="s3">var </span><span class="s1">hook = mountWorkInProgressHook();</span>

  <span class="s1">{</span>
    <span class="s3">var </span><span class="s1">_ref2 = {</span>
      <span class="s1">current: initialValue</span>
    <span class="s1">};</span>
    <span class="s1">hook.memoizedState = _ref2;</span>
    <span class="s3">return </span><span class="s1">_ref2;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">updateRef(initialValue) {</span>
  <span class="s3">var </span><span class="s1">hook = updateWorkInProgressHook();</span>
  <span class="s3">return </span><span class="s1">hook.memoizedState;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">mountEffectImpl(fiberFlags, hookFlags, create, deps) {</span>
  <span class="s3">var </span><span class="s1">hook = mountWorkInProgressHook();</span>
  <span class="s3">var </span><span class="s1">nextDeps = deps === undefined ? </span><span class="s3">null </span><span class="s1">: deps;</span>
  <span class="s1">currentlyRenderingFiber$1.flags |= fiberFlags;</span>
  <span class="s1">hook.memoizedState = pushEffect(</span>
    <span class="s1">HasEffect | hookFlags,</span>
    <span class="s1">create,</span>
    <span class="s1">undefined,</span>
    <span class="s1">nextDeps</span>
  <span class="s1">);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">updateEffectImpl(fiberFlags, hookFlags, create, deps) {</span>
  <span class="s3">var </span><span class="s1">hook = updateWorkInProgressHook();</span>
  <span class="s3">var </span><span class="s1">nextDeps = deps === undefined ? </span><span class="s3">null </span><span class="s1">: deps;</span>
  <span class="s3">var </span><span class="s1">destroy = undefined;</span>

  <span class="s3">if </span><span class="s1">(currentHook !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">prevEffect = currentHook.memoizedState;</span>
    <span class="s1">destroy = prevEffect.destroy;</span>

    <span class="s3">if </span><span class="s1">(nextDeps !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">prevDeps = prevEffect.deps;</span>

      <span class="s3">if </span><span class="s1">(areHookInputsEqual(nextDeps, prevDeps)) {</span>
        <span class="s1">hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">currentlyRenderingFiber$1.flags |= fiberFlags;</span>
  <span class="s1">hook.memoizedState = pushEffect(</span>
    <span class="s1">HasEffect | hookFlags,</span>
    <span class="s1">create,</span>
    <span class="s1">destroy,</span>
    <span class="s1">nextDeps</span>
  <span class="s1">);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">mountEffect(create, deps) {</span>
  <span class="s1">{</span>
    <span class="s3">return </span><span class="s1">mountEffectImpl(Passive | PassiveStatic, Passive$1, create, deps);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">updateEffect(create, deps) {</span>
  <span class="s3">return </span><span class="s1">updateEffectImpl(Passive, Passive$1, create, deps);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">mountInsertionEffect(create, deps) {</span>
  <span class="s3">return </span><span class="s1">mountEffectImpl(Update, Insertion, create, deps);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">updateInsertionEffect(create, deps) {</span>
  <span class="s3">return </span><span class="s1">updateEffectImpl(Update, Insertion, create, deps);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">mountLayoutEffect(create, deps) {</span>
  <span class="s3">var </span><span class="s1">fiberFlags = Update;</span>

  <span class="s3">return </span><span class="s1">mountEffectImpl(fiberFlags, Layout, create, deps);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">updateLayoutEffect(create, deps) {</span>
  <span class="s3">return </span><span class="s1">updateEffectImpl(Update, Layout, create, deps);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">imperativeHandleEffect(create, ref) {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">ref === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">refCallback = ref;</span>

    <span class="s3">var </span><span class="s1">_inst = create();</span>

    <span class="s1">refCallback(_inst);</span>
    <span class="s3">return function</span><span class="s1">() {</span>
      <span class="s1">refCallback(</span><span class="s3">null</span><span class="s1">);</span>
    <span class="s1">};</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(ref !== </span><span class="s3">null </span><span class="s1">&amp;&amp; ref !== undefined) {</span>
    <span class="s3">var </span><span class="s1">refObject = ref;</span>

    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(!refObject.hasOwnProperty(</span><span class="s2">&quot;current&quot;</span><span class="s1">)) {</span>
        <span class="s1">error(</span>
          <span class="s2">&quot;Expected useImperativeHandle() first argument to either be a &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;ref callback or React.createRef() object. Instead received: %s.&quot;</span><span class="s1">,</span>
          <span class="s2">&quot;an object with keys {&quot; </span><span class="s1">+ Object.keys(refObject).join(</span><span class="s2">&quot;, &quot;</span><span class="s1">) + </span><span class="s2">&quot;}&quot;</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">_inst2 = create();</span>

    <span class="s1">refObject.current = _inst2;</span>
    <span class="s3">return function</span><span class="s1">() {</span>
      <span class="s1">refObject.current = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">};</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">mountImperativeHandle(ref, create, deps) {</span>
  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">create !== </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
      <span class="s1">error(</span>
        <span class="s2">&quot;Expected useImperativeHandle() second argument to be a function &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;that creates a handle. Instead received: %s.&quot;</span><span class="s1">,</span>
        <span class="s1">create !== </span><span class="s3">null </span><span class="s1">? </span><span class="s3">typeof </span><span class="s1">create : </span><span class="s2">&quot;null&quot;</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s0">// TODO: If deps are provided, should we skip comparing the ref itself?</span>

  <span class="s3">var </span><span class="s1">effectDeps =</span>
    <span class="s1">deps !== </span><span class="s3">null </span><span class="s1">&amp;&amp; deps !== undefined ? deps.concat([ref]) : </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">fiberFlags = Update;</span>

  <span class="s3">return </span><span class="s1">mountEffectImpl(</span>
    <span class="s1">fiberFlags,</span>
    <span class="s1">Layout,</span>
    <span class="s1">imperativeHandleEffect.bind(</span><span class="s3">null</span><span class="s1">, create, ref),</span>
    <span class="s1">effectDeps</span>
  <span class="s1">);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">updateImperativeHandle(ref, create, deps) {</span>
  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">create !== </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
      <span class="s1">error(</span>
        <span class="s2">&quot;Expected useImperativeHandle() second argument to be a function &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;that creates a handle. Instead received: %s.&quot;</span><span class="s1">,</span>
        <span class="s1">create !== </span><span class="s3">null </span><span class="s1">? </span><span class="s3">typeof </span><span class="s1">create : </span><span class="s2">&quot;null&quot;</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s0">// TODO: If deps are provided, should we skip comparing the ref itself?</span>

  <span class="s3">var </span><span class="s1">effectDeps =</span>
    <span class="s1">deps !== </span><span class="s3">null </span><span class="s1">&amp;&amp; deps !== undefined ? deps.concat([ref]) : </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">return </span><span class="s1">updateEffectImpl(</span>
    <span class="s1">Update,</span>
    <span class="s1">Layout,</span>
    <span class="s1">imperativeHandleEffect.bind(</span><span class="s3">null</span><span class="s1">, create, ref),</span>
    <span class="s1">effectDeps</span>
  <span class="s1">);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">mountDebugValue(value, formatterFn) {</span>
  <span class="s0">// This hook is normally a no-op.</span>
  <span class="s0">// The react-debug-hooks package injects its own implementation</span>
  <span class="s0">// so that e.g. DevTools can display custom hook values.</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">updateDebugValue = mountDebugValue;</span>

<span class="s3">function </span><span class="s1">mountCallback(callback, deps) {</span>
  <span class="s3">var </span><span class="s1">hook = mountWorkInProgressHook();</span>
  <span class="s3">var </span><span class="s1">nextDeps = deps === undefined ? </span><span class="s3">null </span><span class="s1">: deps;</span>
  <span class="s1">hook.memoizedState = [callback, nextDeps];</span>
  <span class="s3">return </span><span class="s1">callback;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">updateCallback(callback, deps) {</span>
  <span class="s3">var </span><span class="s1">hook = updateWorkInProgressHook();</span>
  <span class="s3">var </span><span class="s1">nextDeps = deps === undefined ? </span><span class="s3">null </span><span class="s1">: deps;</span>
  <span class="s3">var </span><span class="s1">prevState = hook.memoizedState;</span>

  <span class="s3">if </span><span class="s1">(prevState !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">if </span><span class="s1">(nextDeps !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">prevDeps = prevState[</span><span class="s4">1</span><span class="s1">];</span>

      <span class="s3">if </span><span class="s1">(areHookInputsEqual(nextDeps, prevDeps)) {</span>
        <span class="s3">return </span><span class="s1">prevState[</span><span class="s4">0</span><span class="s1">];</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">hook.memoizedState = [callback, nextDeps];</span>
  <span class="s3">return </span><span class="s1">callback;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">mountMemo(nextCreate, deps) {</span>
  <span class="s3">var </span><span class="s1">hook = mountWorkInProgressHook();</span>
  <span class="s3">var </span><span class="s1">nextDeps = deps === undefined ? </span><span class="s3">null </span><span class="s1">: deps;</span>
  <span class="s3">var </span><span class="s1">nextValue = nextCreate();</span>
  <span class="s1">hook.memoizedState = [nextValue, nextDeps];</span>
  <span class="s3">return </span><span class="s1">nextValue;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">updateMemo(nextCreate, deps) {</span>
  <span class="s3">var </span><span class="s1">hook = updateWorkInProgressHook();</span>
  <span class="s3">var </span><span class="s1">nextDeps = deps === undefined ? </span><span class="s3">null </span><span class="s1">: deps;</span>
  <span class="s3">var </span><span class="s1">prevState = hook.memoizedState;</span>

  <span class="s3">if </span><span class="s1">(prevState !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s0">// Assume these are defined. If they're not, areHookInputsEqual will warn.</span>
    <span class="s3">if </span><span class="s1">(nextDeps !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">prevDeps = prevState[</span><span class="s4">1</span><span class="s1">];</span>

      <span class="s3">if </span><span class="s1">(areHookInputsEqual(nextDeps, prevDeps)) {</span>
        <span class="s3">return </span><span class="s1">prevState[</span><span class="s4">0</span><span class="s1">];</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">nextValue = nextCreate();</span>
  <span class="s1">hook.memoizedState = [nextValue, nextDeps];</span>
  <span class="s3">return </span><span class="s1">nextValue;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">mountDeferredValue(value) {</span>
  <span class="s3">var </span><span class="s1">hook = mountWorkInProgressHook();</span>
  <span class="s1">hook.memoizedState = value;</span>
  <span class="s3">return </span><span class="s1">value;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">updateDeferredValue(value) {</span>
  <span class="s3">var </span><span class="s1">hook = updateWorkInProgressHook();</span>
  <span class="s3">var </span><span class="s1">resolvedCurrentHook = currentHook;</span>
  <span class="s3">var </span><span class="s1">prevValue = resolvedCurrentHook.memoizedState;</span>
  <span class="s3">return </span><span class="s1">updateDeferredValueImpl(hook, prevValue, value);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">rerenderDeferredValue(value) {</span>
  <span class="s3">var </span><span class="s1">hook = updateWorkInProgressHook();</span>

  <span class="s3">if </span><span class="s1">(currentHook === </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s0">// This is a rerender during a mount.</span>
    <span class="s1">hook.memoizedState = value;</span>
    <span class="s3">return </span><span class="s1">value;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s0">// This is a rerender during an update.</span>
    <span class="s3">var </span><span class="s1">prevValue = currentHook.memoizedState;</span>
    <span class="s3">return </span><span class="s1">updateDeferredValueImpl(hook, prevValue, value);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">updateDeferredValueImpl(hook, prevValue, value) {</span>
  <span class="s3">var </span><span class="s1">shouldDeferValue = !includesOnlyNonUrgentLanes(renderLanes);</span>

  <span class="s3">if </span><span class="s1">(shouldDeferValue) {</span>
    <span class="s0">// This is an urgent update. If the value has changed, keep using the</span>
    <span class="s0">// previous value and spawn a deferred render to update it later.</span>
    <span class="s3">if </span><span class="s1">(!objectIs(value, prevValue)) {</span>
      <span class="s0">// Schedule a deferred render</span>
      <span class="s3">var </span><span class="s1">deferredLane = claimNextTransitionLane();</span>
      <span class="s1">currentlyRenderingFiber$1.lanes = mergeLanes(</span>
        <span class="s1">currentlyRenderingFiber$1.lanes,</span>
        <span class="s1">deferredLane</span>
      <span class="s1">);</span>
      <span class="s1">markSkippedUpdateLanes(deferredLane); </span><span class="s0">// Set this to true to indicate that the rendered value is inconsistent</span>
      <span class="s0">// from the latest value. The name &quot;baseState&quot; doesn't really match how we</span>
      <span class="s0">// use it because we're reusing a state hook field instead of creating a</span>
      <span class="s0">// new one.</span>

      <span class="s1">hook.baseState = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s0">// Reuse the previous value</span>

    <span class="s3">return </span><span class="s1">prevValue;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s0">// This is not an urgent update, so we can use the latest value regardless</span>
    <span class="s0">// of what it is. No need to defer it.</span>
    <span class="s0">// However, if we're currently inside a spawned render, then we need to mark</span>
    <span class="s0">// this as an update to prevent the fiber from bailing out.</span>
    <span class="s0">//</span>
    <span class="s0">// `baseState` is true when the current value is different from the rendered</span>
    <span class="s0">// value. The name doesn't really match how we use it because we're reusing</span>
    <span class="s0">// a state hook field instead of creating a new one.</span>
    <span class="s3">if </span><span class="s1">(hook.baseState) {</span>
      <span class="s0">// Flip this back to false.</span>
      <span class="s1">hook.baseState = </span><span class="s3">false</span><span class="s1">;</span>
      <span class="s1">markWorkInProgressReceivedUpdate();</span>
    <span class="s1">}</span>

    <span class="s1">hook.memoizedState = value;</span>
    <span class="s3">return </span><span class="s1">value;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">startTransition(setPending, callback, options) {</span>
  <span class="s3">var </span><span class="s1">previousPriority = getCurrentUpdatePriority();</span>
  <span class="s1">setCurrentUpdatePriority(</span>
    <span class="s1">higherEventPriority(previousPriority, ContinuousEventPriority)</span>
  <span class="s1">);</span>
  <span class="s1">setPending(</span><span class="s3">true</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">prevTransition = ReactCurrentBatchConfig$1.transition;</span>
  <span class="s1">ReactCurrentBatchConfig$1.transition = {};</span>
  <span class="s3">var </span><span class="s1">currentTransition = ReactCurrentBatchConfig$1.transition;</span>

  <span class="s1">{</span>
    <span class="s1">ReactCurrentBatchConfig$1.transition._updatedFibers = </span><span class="s3">new </span><span class="s1">Set();</span>
  <span class="s1">}</span>

  <span class="s3">try </span><span class="s1">{</span>
    <span class="s1">setPending(</span><span class="s3">false</span><span class="s1">);</span>
    <span class="s1">callback();</span>
  <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
    <span class="s1">setCurrentUpdatePriority(previousPriority);</span>
    <span class="s1">ReactCurrentBatchConfig$1.transition = prevTransition;</span>

    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(prevTransition === </span><span class="s3">null </span><span class="s1">&amp;&amp; currentTransition._updatedFibers) {</span>
        <span class="s3">var </span><span class="s1">updatedFibersCount = currentTransition._updatedFibers.size;</span>

        <span class="s3">if </span><span class="s1">(updatedFibersCount &gt; </span><span class="s4">10</span><span class="s1">) {</span>
          <span class="s1">warn(</span>
            <span class="s2">&quot;Detected a large number of updates inside startTransition. &quot; </span><span class="s1">+</span>
              <span class="s2">&quot;If this is due to a subscription please re-write it to use React provided hooks. &quot; </span><span class="s1">+</span>
              <span class="s2">&quot;Otherwise concurrent mode guarantees are off the table.&quot;</span>
          <span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s1">currentTransition._updatedFibers.clear();</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">mountTransition() {</span>
  <span class="s3">var </span><span class="s1">_mountState = mountState(</span><span class="s3">false</span><span class="s1">),</span>
    <span class="s1">isPending = _mountState[</span><span class="s4">0</span><span class="s1">],</span>
    <span class="s1">setPending = _mountState[</span><span class="s4">1</span><span class="s1">]; </span><span class="s0">// The `start` method never changes.</span>

  <span class="s3">var </span><span class="s1">start = startTransition.bind(</span><span class="s3">null</span><span class="s1">, setPending);</span>
  <span class="s3">var </span><span class="s1">hook = mountWorkInProgressHook();</span>
  <span class="s1">hook.memoizedState = start;</span>
  <span class="s3">return </span><span class="s1">[isPending, start];</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">updateTransition() {</span>
  <span class="s3">var </span><span class="s1">_updateState = updateState(),</span>
    <span class="s1">isPending = _updateState[</span><span class="s4">0</span><span class="s1">];</span>

  <span class="s3">var </span><span class="s1">hook = updateWorkInProgressHook();</span>
  <span class="s3">var </span><span class="s1">start = hook.memoizedState;</span>
  <span class="s3">return </span><span class="s1">[isPending, start];</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">rerenderTransition() {</span>
  <span class="s3">var </span><span class="s1">_rerenderState = rerenderState(),</span>
    <span class="s1">isPending = _rerenderState[</span><span class="s4">0</span><span class="s1">];</span>

  <span class="s3">var </span><span class="s1">hook = updateWorkInProgressHook();</span>
  <span class="s3">var </span><span class="s1">start = hook.memoizedState;</span>
  <span class="s3">return </span><span class="s1">[isPending, start];</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">isUpdatingOpaqueValueInRenderPhase = </span><span class="s3">false</span><span class="s1">;</span>
<span class="s3">function </span><span class="s1">getIsUpdatingOpaqueValueInRenderPhaseInDEV() {</span>
  <span class="s1">{</span>
    <span class="s3">return </span><span class="s1">isUpdatingOpaqueValueInRenderPhase;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">mountId() {</span>
  <span class="s3">var </span><span class="s1">hook = mountWorkInProgressHook();</span>
  <span class="s3">var </span><span class="s1">root = getWorkInProgressRoot(); </span><span class="s0">// TODO: In Fizz, id generation is specific to each server config. Maybe we</span>
  <span class="s0">// should do this in Fiber, too? Deferring this decision for now because</span>
  <span class="s0">// there's no other place to store the prefix except for an internal field on</span>
  <span class="s0">// the public createRoot object, which the fiber tree does not currently have</span>
  <span class="s0">// a reference to.</span>

  <span class="s3">var </span><span class="s1">identifierPrefix = root.identifierPrefix;</span>
  <span class="s3">var </span><span class="s1">id;</span>

  <span class="s1">{</span>
    <span class="s0">// Use a lowercase r prefix for client-generated ids.</span>
    <span class="s3">var </span><span class="s1">globalClientId = globalClientIdCounter++;</span>
    <span class="s1">id = </span><span class="s2">&quot;:&quot; </span><span class="s1">+ identifierPrefix + </span><span class="s2">&quot;r&quot; </span><span class="s1">+ globalClientId.toString(</span><span class="s4">32</span><span class="s1">) + </span><span class="s2">&quot;:&quot;</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s1">hook.memoizedState = id;</span>
  <span class="s3">return </span><span class="s1">id;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">updateId() {</span>
  <span class="s3">var </span><span class="s1">hook = updateWorkInProgressHook();</span>
  <span class="s3">var </span><span class="s1">id = hook.memoizedState;</span>
  <span class="s3">return </span><span class="s1">id;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">dispatchReducerAction(fiber, queue, action) {</span>
  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">arguments[</span><span class="s4">3</span><span class="s1">] === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
      <span class="s1">error(</span>
        <span class="s2">&quot;State updates from the useState() and useReducer() Hooks don't support the &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;second callback argument. To execute a side effect after &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;rendering, declare it in the component body with useEffect().&quot;</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">lane = requestUpdateLane(fiber);</span>
  <span class="s3">var </span><span class="s1">update = {</span>
    <span class="s1">lane: lane,</span>
    <span class="s1">action: action,</span>
    <span class="s1">hasEagerState: </span><span class="s3">false</span><span class="s1">,</span>
    <span class="s1">eagerState: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">next: </span><span class="s3">null</span>
  <span class="s1">};</span>

  <span class="s3">if </span><span class="s1">(isRenderPhaseUpdate(fiber)) {</span>
    <span class="s1">enqueueRenderPhaseUpdate(queue, update);</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s3">var </span><span class="s1">root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);</span>

    <span class="s3">if </span><span class="s1">(root !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">eventTime = requestEventTime();</span>
      <span class="s1">scheduleUpdateOnFiber(root, fiber, lane, eventTime);</span>
      <span class="s1">entangleTransitionUpdate(root, queue, lane);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">dispatchSetState(fiber, queue, action) {</span>
  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">arguments[</span><span class="s4">3</span><span class="s1">] === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
      <span class="s1">error(</span>
        <span class="s2">&quot;State updates from the useState() and useReducer() Hooks don't support the &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;second callback argument. To execute a side effect after &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;rendering, declare it in the component body with useEffect().&quot;</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">lane = requestUpdateLane(fiber);</span>
  <span class="s3">var </span><span class="s1">update = {</span>
    <span class="s1">lane: lane,</span>
    <span class="s1">action: action,</span>
    <span class="s1">hasEagerState: </span><span class="s3">false</span><span class="s1">,</span>
    <span class="s1">eagerState: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">next: </span><span class="s3">null</span>
  <span class="s1">};</span>

  <span class="s3">if </span><span class="s1">(isRenderPhaseUpdate(fiber)) {</span>
    <span class="s1">enqueueRenderPhaseUpdate(queue, update);</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s3">var </span><span class="s1">alternate = fiber.alternate;</span>

    <span class="s3">if </span><span class="s1">(</span>
      <span class="s1">fiber.lanes === NoLanes &amp;&amp;</span>
      <span class="s1">(alternate === </span><span class="s3">null </span><span class="s1">|| alternate.lanes === NoLanes)</span>
    <span class="s1">) {</span>
      <span class="s0">// The queue is currently empty, which means we can eagerly compute the</span>
      <span class="s0">// next state before entering the render phase. If the new state is the</span>
      <span class="s0">// same as the current state, we may be able to bail out entirely.</span>
      <span class="s3">var </span><span class="s1">lastRenderedReducer = queue.lastRenderedReducer;</span>

      <span class="s3">if </span><span class="s1">(lastRenderedReducer !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">prevDispatcher;</span>

        <span class="s1">{</span>
          <span class="s1">prevDispatcher = ReactCurrentDispatcher$1.current;</span>
          <span class="s1">ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;</span>
        <span class="s1">}</span>

        <span class="s3">try </span><span class="s1">{</span>
          <span class="s3">var </span><span class="s1">currentState = queue.lastRenderedState;</span>
          <span class="s3">var </span><span class="s1">eagerState = lastRenderedReducer(currentState, action); </span><span class="s0">// Stash the eagerly computed state, and the reducer used to compute</span>
          <span class="s0">// it, on the update object. If the reducer hasn't changed by the</span>
          <span class="s0">// time we enter the render phase, then the eager state can be used</span>
          <span class="s0">// without calling the reducer again.</span>

          <span class="s1">update.hasEagerState = </span><span class="s3">true</span><span class="s1">;</span>
          <span class="s1">update.eagerState = eagerState;</span>

          <span class="s3">if </span><span class="s1">(objectIs(eagerState, currentState)) {</span>
            <span class="s0">// Fast path. We can bail out without scheduling React to re-render.</span>
            <span class="s0">// It's still possible that we'll need to rebase this update later,</span>
            <span class="s0">// if the component re-renders for a different reason and by that</span>
            <span class="s0">// time the reducer has changed.</span>
            <span class="s0">// TODO: Do we still need to entangle transitions in this case?</span>
            <span class="s1">enqueueConcurrentHookUpdateAndEagerlyBailout(</span>
              <span class="s1">fiber,</span>
              <span class="s1">queue,</span>
              <span class="s1">update,</span>
              <span class="s1">lane</span>
            <span class="s1">);</span>
            <span class="s3">return</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
          <span class="s0">// Suppress the error. It will throw again in the render phase.</span>
        <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
          <span class="s1">{</span>
            <span class="s1">ReactCurrentDispatcher$1.current = prevDispatcher;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);</span>

    <span class="s3">if </span><span class="s1">(root !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">eventTime = requestEventTime();</span>
      <span class="s1">scheduleUpdateOnFiber(root, fiber, lane, eventTime);</span>
      <span class="s1">entangleTransitionUpdate(root, queue, lane);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">isRenderPhaseUpdate(fiber) {</span>
  <span class="s3">var </span><span class="s1">alternate = fiber.alternate;</span>
  <span class="s3">return </span><span class="s1">(</span>
    <span class="s1">fiber === currentlyRenderingFiber$1 ||</span>
    <span class="s1">(alternate !== </span><span class="s3">null </span><span class="s1">&amp;&amp; alternate === currentlyRenderingFiber$1)</span>
  <span class="s1">);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">enqueueRenderPhaseUpdate(queue, update) {</span>
  <span class="s0">// This is a render phase update. Stash it in a lazily-created map of</span>
  <span class="s0">// queue -&gt; linked list of updates. After this render pass, we'll restart</span>
  <span class="s0">// and apply the stashed updates on top of the work-in-progress hook.</span>
  <span class="s1">didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = </span><span class="s3">true</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">pending = queue.pending;</span>

  <span class="s3">if </span><span class="s1">(pending === </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s0">// This is the first update. Create a circular list.</span>
    <span class="s1">update.next = update;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">update.next = pending.next;</span>
    <span class="s1">pending.next = update;</span>
  <span class="s1">}</span>

  <span class="s1">queue.pending = update;</span>
<span class="s1">} </span><span class="s0">// TODO: Move to ReactFiberConcurrentUpdates?</span>

<span class="s3">function </span><span class="s1">entangleTransitionUpdate(root, queue, lane) {</span>
  <span class="s3">if </span><span class="s1">(isTransitionLane(lane)) {</span>
    <span class="s3">var </span><span class="s1">queueLanes = queue.lanes; </span><span class="s0">// If any entangled lanes are no longer pending on the root, then they</span>
    <span class="s0">// must have finished. We can remove them from the shared queue, which</span>
    <span class="s0">// represents a superset of the actually pending lanes. In some cases we</span>
    <span class="s0">// may entangle more than we need to, but that's OK. In fact it's worse if</span>
    <span class="s0">// we *don't* entangle when we should.</span>

    <span class="s1">queueLanes = intersectLanes(queueLanes, root.pendingLanes); </span><span class="s0">// Entangle the new transition lane with the other transition lanes.</span>

    <span class="s3">var </span><span class="s1">newQueueLanes = mergeLanes(queueLanes, lane);</span>
    <span class="s1">queue.lanes = newQueueLanes; </span><span class="s0">// Even if queue.lanes already include lane, we don't know for certain if</span>
    <span class="s0">// the lane finished since the last time we entangled it. So we need to</span>
    <span class="s0">// entangle it again, just to be sure.</span>

    <span class="s1">markRootEntangled(root, newQueueLanes);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">ContextOnlyDispatcher = {</span>
  <span class="s1">readContext: readContext,</span>
  <span class="s1">useCallback: throwInvalidHookError,</span>
  <span class="s1">useContext: throwInvalidHookError,</span>
  <span class="s1">useEffect: throwInvalidHookError,</span>
  <span class="s1">useImperativeHandle: throwInvalidHookError,</span>
  <span class="s1">useInsertionEffect: throwInvalidHookError,</span>
  <span class="s1">useLayoutEffect: throwInvalidHookError,</span>
  <span class="s1">useMemo: throwInvalidHookError,</span>
  <span class="s1">useReducer: throwInvalidHookError,</span>
  <span class="s1">useRef: throwInvalidHookError,</span>
  <span class="s1">useState: throwInvalidHookError,</span>
  <span class="s1">useDebugValue: throwInvalidHookError,</span>
  <span class="s1">useDeferredValue: throwInvalidHookError,</span>
  <span class="s1">useTransition: throwInvalidHookError,</span>
  <span class="s1">useMutableSource: throwInvalidHookError,</span>
  <span class="s1">useSyncExternalStore: throwInvalidHookError,</span>
  <span class="s1">useId: throwInvalidHookError,</span>
  <span class="s1">unstable_isNewReconciler: enableNewReconciler</span>
<span class="s1">};</span>

<span class="s3">var </span><span class="s1">HooksDispatcherOnMountInDEV = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">HooksDispatcherOnMountWithHookTypesInDEV = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">HooksDispatcherOnUpdateInDEV = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">HooksDispatcherOnRerenderInDEV = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">InvalidNestedHooksDispatcherOnMountInDEV = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">InvalidNestedHooksDispatcherOnUpdateInDEV = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">InvalidNestedHooksDispatcherOnRerenderInDEV = </span><span class="s3">null</span><span class="s1">;</span>

<span class="s1">{</span>
  <span class="s3">var </span><span class="s1">warnInvalidContextAccess = </span><span class="s3">function</span><span class="s1">() {</span>
    <span class="s1">error(</span>
      <span class="s2">&quot;Context can only be read while React is rendering. &quot; </span><span class="s1">+</span>
        <span class="s2">&quot;In classes, you can read it in the render method or getDerivedStateFromProps. &quot; </span><span class="s1">+</span>
        <span class="s2">&quot;In function components, you can read it directly in the function body, but not &quot; </span><span class="s1">+</span>
        <span class="s2">&quot;inside Hooks like useReducer() or useMemo().&quot;</span>
    <span class="s1">);</span>
  <span class="s1">};</span>

  <span class="s3">var </span><span class="s1">warnInvalidHookAccess = </span><span class="s3">function</span><span class="s1">() {</span>
    <span class="s1">error(</span>
      <span class="s2">&quot;Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. &quot; </span><span class="s1">+</span>
        <span class="s2">&quot;You can only call Hooks at the top level of your React function. &quot; </span><span class="s1">+</span>
        <span class="s2">&quot;For more information, see &quot; </span><span class="s1">+</span>
        <span class="s2">&quot;https://reactjs.org/link/rules-of-hooks&quot;</span>
    <span class="s1">);</span>
  <span class="s1">};</span>

  <span class="s1">HooksDispatcherOnMountInDEV = {</span>
    <span class="s1">readContext: </span><span class="s3">function</span><span class="s1">(context) {</span>
      <span class="s3">return </span><span class="s1">readContext(context);</span>
    <span class="s1">},</span>
    <span class="s1">useCallback: </span><span class="s3">function</span><span class="s1">(callback, deps) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useCallback&quot;</span><span class="s1">;</span>
      <span class="s1">mountHookTypesDev();</span>
      <span class="s1">checkDepsAreArrayDev(deps);</span>
      <span class="s3">return </span><span class="s1">mountCallback(callback, deps);</span>
    <span class="s1">},</span>
    <span class="s1">useContext: </span><span class="s3">function</span><span class="s1">(context) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useContext&quot;</span><span class="s1">;</span>
      <span class="s1">mountHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">readContext(context);</span>
    <span class="s1">},</span>
    <span class="s1">useEffect: </span><span class="s3">function</span><span class="s1">(create, deps) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useEffect&quot;</span><span class="s1">;</span>
      <span class="s1">mountHookTypesDev();</span>
      <span class="s1">checkDepsAreArrayDev(deps);</span>
      <span class="s3">return </span><span class="s1">mountEffect(create, deps);</span>
    <span class="s1">},</span>
    <span class="s1">useImperativeHandle: </span><span class="s3">function</span><span class="s1">(ref, create, deps) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useImperativeHandle&quot;</span><span class="s1">;</span>
      <span class="s1">mountHookTypesDev();</span>
      <span class="s1">checkDepsAreArrayDev(deps);</span>
      <span class="s3">return </span><span class="s1">mountImperativeHandle(ref, create, deps);</span>
    <span class="s1">},</span>
    <span class="s1">useInsertionEffect: </span><span class="s3">function</span><span class="s1">(create, deps) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useInsertionEffect&quot;</span><span class="s1">;</span>
      <span class="s1">mountHookTypesDev();</span>
      <span class="s1">checkDepsAreArrayDev(deps);</span>
      <span class="s3">return </span><span class="s1">mountInsertionEffect(create, deps);</span>
    <span class="s1">},</span>
    <span class="s1">useLayoutEffect: </span><span class="s3">function</span><span class="s1">(create, deps) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useLayoutEffect&quot;</span><span class="s1">;</span>
      <span class="s1">mountHookTypesDev();</span>
      <span class="s1">checkDepsAreArrayDev(deps);</span>
      <span class="s3">return </span><span class="s1">mountLayoutEffect(create, deps);</span>
    <span class="s1">},</span>
    <span class="s1">useMemo: </span><span class="s3">function</span><span class="s1">(create, deps) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useMemo&quot;</span><span class="s1">;</span>
      <span class="s1">mountHookTypesDev();</span>
      <span class="s1">checkDepsAreArrayDev(deps);</span>
      <span class="s3">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher$1.current;</span>
      <span class="s1">ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;</span>

      <span class="s3">try </span><span class="s1">{</span>
        <span class="s3">return </span><span class="s1">mountMemo(create, deps);</span>
      <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
        <span class="s1">ReactCurrentDispatcher$1.current = prevDispatcher;</span>
      <span class="s1">}</span>
    <span class="s1">},</span>
    <span class="s1">useReducer: </span><span class="s3">function</span><span class="s1">(reducer, initialArg, init) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useReducer&quot;</span><span class="s1">;</span>
      <span class="s1">mountHookTypesDev();</span>
      <span class="s3">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher$1.current;</span>
      <span class="s1">ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;</span>

      <span class="s3">try </span><span class="s1">{</span>
        <span class="s3">return </span><span class="s1">mountReducer(reducer, initialArg, init);</span>
      <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
        <span class="s1">ReactCurrentDispatcher$1.current = prevDispatcher;</span>
      <span class="s1">}</span>
    <span class="s1">},</span>
    <span class="s1">useRef: </span><span class="s3">function</span><span class="s1">(initialValue) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useRef&quot;</span><span class="s1">;</span>
      <span class="s1">mountHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">mountRef(initialValue);</span>
    <span class="s1">},</span>
    <span class="s1">useState: </span><span class="s3">function</span><span class="s1">(initialState) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useState&quot;</span><span class="s1">;</span>
      <span class="s1">mountHookTypesDev();</span>
      <span class="s3">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher$1.current;</span>
      <span class="s1">ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;</span>

      <span class="s3">try </span><span class="s1">{</span>
        <span class="s3">return </span><span class="s1">mountState(initialState);</span>
      <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
        <span class="s1">ReactCurrentDispatcher$1.current = prevDispatcher;</span>
      <span class="s1">}</span>
    <span class="s1">},</span>
    <span class="s1">useDebugValue: </span><span class="s3">function</span><span class="s1">(value, formatterFn) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useDebugValue&quot;</span><span class="s1">;</span>
      <span class="s1">mountHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">mountDebugValue();</span>
    <span class="s1">},</span>
    <span class="s1">useDeferredValue: </span><span class="s3">function</span><span class="s1">(value) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useDeferredValue&quot;</span><span class="s1">;</span>
      <span class="s1">mountHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">mountDeferredValue(value);</span>
    <span class="s1">},</span>
    <span class="s1">useTransition: </span><span class="s3">function</span><span class="s1">() {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useTransition&quot;</span><span class="s1">;</span>
      <span class="s1">mountHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">mountTransition();</span>
    <span class="s1">},</span>
    <span class="s1">useMutableSource: </span><span class="s3">function</span><span class="s1">(source, getSnapshot, subscribe) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useMutableSource&quot;</span><span class="s1">;</span>
      <span class="s1">mountHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">mountMutableSource();</span>
    <span class="s1">},</span>
    <span class="s1">useSyncExternalStore: </span><span class="s3">function</span><span class="s1">(subscribe, getSnapshot, getServerSnapshot) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useSyncExternalStore&quot;</span><span class="s1">;</span>
      <span class="s1">mountHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">mountSyncExternalStore(subscribe, getSnapshot);</span>
    <span class="s1">},</span>
    <span class="s1">useId: </span><span class="s3">function</span><span class="s1">() {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useId&quot;</span><span class="s1">;</span>
      <span class="s1">mountHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">mountId();</span>
    <span class="s1">},</span>
    <span class="s1">unstable_isNewReconciler: enableNewReconciler</span>
  <span class="s1">};</span>

  <span class="s1">HooksDispatcherOnMountWithHookTypesInDEV = {</span>
    <span class="s1">readContext: </span><span class="s3">function</span><span class="s1">(context) {</span>
      <span class="s3">return </span><span class="s1">readContext(context);</span>
    <span class="s1">},</span>
    <span class="s1">useCallback: </span><span class="s3">function</span><span class="s1">(callback, deps) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useCallback&quot;</span><span class="s1">;</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">mountCallback(callback, deps);</span>
    <span class="s1">},</span>
    <span class="s1">useContext: </span><span class="s3">function</span><span class="s1">(context) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useContext&quot;</span><span class="s1">;</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">readContext(context);</span>
    <span class="s1">},</span>
    <span class="s1">useEffect: </span><span class="s3">function</span><span class="s1">(create, deps) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useEffect&quot;</span><span class="s1">;</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">mountEffect(create, deps);</span>
    <span class="s1">},</span>
    <span class="s1">useImperativeHandle: </span><span class="s3">function</span><span class="s1">(ref, create, deps) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useImperativeHandle&quot;</span><span class="s1">;</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">mountImperativeHandle(ref, create, deps);</span>
    <span class="s1">},</span>
    <span class="s1">useInsertionEffect: </span><span class="s3">function</span><span class="s1">(create, deps) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useInsertionEffect&quot;</span><span class="s1">;</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">mountInsertionEffect(create, deps);</span>
    <span class="s1">},</span>
    <span class="s1">useLayoutEffect: </span><span class="s3">function</span><span class="s1">(create, deps) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useLayoutEffect&quot;</span><span class="s1">;</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">mountLayoutEffect(create, deps);</span>
    <span class="s1">},</span>
    <span class="s1">useMemo: </span><span class="s3">function</span><span class="s1">(create, deps) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useMemo&quot;</span><span class="s1">;</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher$1.current;</span>
      <span class="s1">ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;</span>

      <span class="s3">try </span><span class="s1">{</span>
        <span class="s3">return </span><span class="s1">mountMemo(create, deps);</span>
      <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
        <span class="s1">ReactCurrentDispatcher$1.current = prevDispatcher;</span>
      <span class="s1">}</span>
    <span class="s1">},</span>
    <span class="s1">useReducer: </span><span class="s3">function</span><span class="s1">(reducer, initialArg, init) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useReducer&quot;</span><span class="s1">;</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher$1.current;</span>
      <span class="s1">ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;</span>

      <span class="s3">try </span><span class="s1">{</span>
        <span class="s3">return </span><span class="s1">mountReducer(reducer, initialArg, init);</span>
      <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
        <span class="s1">ReactCurrentDispatcher$1.current = prevDispatcher;</span>
      <span class="s1">}</span>
    <span class="s1">},</span>
    <span class="s1">useRef: </span><span class="s3">function</span><span class="s1">(initialValue) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useRef&quot;</span><span class="s1">;</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">mountRef(initialValue);</span>
    <span class="s1">},</span>
    <span class="s1">useState: </span><span class="s3">function</span><span class="s1">(initialState) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useState&quot;</span><span class="s1">;</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher$1.current;</span>
      <span class="s1">ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;</span>

      <span class="s3">try </span><span class="s1">{</span>
        <span class="s3">return </span><span class="s1">mountState(initialState);</span>
      <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
        <span class="s1">ReactCurrentDispatcher$1.current = prevDispatcher;</span>
      <span class="s1">}</span>
    <span class="s1">},</span>
    <span class="s1">useDebugValue: </span><span class="s3">function</span><span class="s1">(value, formatterFn) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useDebugValue&quot;</span><span class="s1">;</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">mountDebugValue();</span>
    <span class="s1">},</span>
    <span class="s1">useDeferredValue: </span><span class="s3">function</span><span class="s1">(value) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useDeferredValue&quot;</span><span class="s1">;</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">mountDeferredValue(value);</span>
    <span class="s1">},</span>
    <span class="s1">useTransition: </span><span class="s3">function</span><span class="s1">() {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useTransition&quot;</span><span class="s1">;</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">mountTransition();</span>
    <span class="s1">},</span>
    <span class="s1">useMutableSource: </span><span class="s3">function</span><span class="s1">(source, getSnapshot, subscribe) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useMutableSource&quot;</span><span class="s1">;</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">mountMutableSource();</span>
    <span class="s1">},</span>
    <span class="s1">useSyncExternalStore: </span><span class="s3">function</span><span class="s1">(subscribe, getSnapshot, getServerSnapshot) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useSyncExternalStore&quot;</span><span class="s1">;</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">mountSyncExternalStore(subscribe, getSnapshot);</span>
    <span class="s1">},</span>
    <span class="s1">useId: </span><span class="s3">function</span><span class="s1">() {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useId&quot;</span><span class="s1">;</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">mountId();</span>
    <span class="s1">},</span>
    <span class="s1">unstable_isNewReconciler: enableNewReconciler</span>
  <span class="s1">};</span>

  <span class="s1">HooksDispatcherOnUpdateInDEV = {</span>
    <span class="s1">readContext: </span><span class="s3">function</span><span class="s1">(context) {</span>
      <span class="s3">return </span><span class="s1">readContext(context);</span>
    <span class="s1">},</span>
    <span class="s1">useCallback: </span><span class="s3">function</span><span class="s1">(callback, deps) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useCallback&quot;</span><span class="s1">;</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">updateCallback(callback, deps);</span>
    <span class="s1">},</span>
    <span class="s1">useContext: </span><span class="s3">function</span><span class="s1">(context) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useContext&quot;</span><span class="s1">;</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">readContext(context);</span>
    <span class="s1">},</span>
    <span class="s1">useEffect: </span><span class="s3">function</span><span class="s1">(create, deps) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useEffect&quot;</span><span class="s1">;</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">updateEffect(create, deps);</span>
    <span class="s1">},</span>
    <span class="s1">useImperativeHandle: </span><span class="s3">function</span><span class="s1">(ref, create, deps) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useImperativeHandle&quot;</span><span class="s1">;</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">updateImperativeHandle(ref, create, deps);</span>
    <span class="s1">},</span>
    <span class="s1">useInsertionEffect: </span><span class="s3">function</span><span class="s1">(create, deps) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useInsertionEffect&quot;</span><span class="s1">;</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">updateInsertionEffect(create, deps);</span>
    <span class="s1">},</span>
    <span class="s1">useLayoutEffect: </span><span class="s3">function</span><span class="s1">(create, deps) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useLayoutEffect&quot;</span><span class="s1">;</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">updateLayoutEffect(create, deps);</span>
    <span class="s1">},</span>
    <span class="s1">useMemo: </span><span class="s3">function</span><span class="s1">(create, deps) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useMemo&quot;</span><span class="s1">;</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher$1.current;</span>
      <span class="s1">ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;</span>

      <span class="s3">try </span><span class="s1">{</span>
        <span class="s3">return </span><span class="s1">updateMemo(create, deps);</span>
      <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
        <span class="s1">ReactCurrentDispatcher$1.current = prevDispatcher;</span>
      <span class="s1">}</span>
    <span class="s1">},</span>
    <span class="s1">useReducer: </span><span class="s3">function</span><span class="s1">(reducer, initialArg, init) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useReducer&quot;</span><span class="s1">;</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher$1.current;</span>
      <span class="s1">ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;</span>

      <span class="s3">try </span><span class="s1">{</span>
        <span class="s3">return </span><span class="s1">updateReducer(reducer, initialArg, init);</span>
      <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
        <span class="s1">ReactCurrentDispatcher$1.current = prevDispatcher;</span>
      <span class="s1">}</span>
    <span class="s1">},</span>
    <span class="s1">useRef: </span><span class="s3">function</span><span class="s1">(initialValue) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useRef&quot;</span><span class="s1">;</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">updateRef();</span>
    <span class="s1">},</span>
    <span class="s1">useState: </span><span class="s3">function</span><span class="s1">(initialState) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useState&quot;</span><span class="s1">;</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher$1.current;</span>
      <span class="s1">ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;</span>

      <span class="s3">try </span><span class="s1">{</span>
        <span class="s3">return </span><span class="s1">updateState(initialState);</span>
      <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
        <span class="s1">ReactCurrentDispatcher$1.current = prevDispatcher;</span>
      <span class="s1">}</span>
    <span class="s1">},</span>
    <span class="s1">useDebugValue: </span><span class="s3">function</span><span class="s1">(value, formatterFn) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useDebugValue&quot;</span><span class="s1">;</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">updateDebugValue();</span>
    <span class="s1">},</span>
    <span class="s1">useDeferredValue: </span><span class="s3">function</span><span class="s1">(value) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useDeferredValue&quot;</span><span class="s1">;</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">updateDeferredValue(value);</span>
    <span class="s1">},</span>
    <span class="s1">useTransition: </span><span class="s3">function</span><span class="s1">() {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useTransition&quot;</span><span class="s1">;</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">updateTransition();</span>
    <span class="s1">},</span>
    <span class="s1">useMutableSource: </span><span class="s3">function</span><span class="s1">(source, getSnapshot, subscribe) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useMutableSource&quot;</span><span class="s1">;</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">updateMutableSource();</span>
    <span class="s1">},</span>
    <span class="s1">useSyncExternalStore: </span><span class="s3">function</span><span class="s1">(subscribe, getSnapshot, getServerSnapshot) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useSyncExternalStore&quot;</span><span class="s1">;</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">updateSyncExternalStore(subscribe, getSnapshot);</span>
    <span class="s1">},</span>
    <span class="s1">useId: </span><span class="s3">function</span><span class="s1">() {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useId&quot;</span><span class="s1">;</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">updateId();</span>
    <span class="s1">},</span>
    <span class="s1">unstable_isNewReconciler: enableNewReconciler</span>
  <span class="s1">};</span>

  <span class="s1">HooksDispatcherOnRerenderInDEV = {</span>
    <span class="s1">readContext: </span><span class="s3">function</span><span class="s1">(context) {</span>
      <span class="s3">return </span><span class="s1">readContext(context);</span>
    <span class="s1">},</span>
    <span class="s1">useCallback: </span><span class="s3">function</span><span class="s1">(callback, deps) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useCallback&quot;</span><span class="s1">;</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">updateCallback(callback, deps);</span>
    <span class="s1">},</span>
    <span class="s1">useContext: </span><span class="s3">function</span><span class="s1">(context) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useContext&quot;</span><span class="s1">;</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">readContext(context);</span>
    <span class="s1">},</span>
    <span class="s1">useEffect: </span><span class="s3">function</span><span class="s1">(create, deps) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useEffect&quot;</span><span class="s1">;</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">updateEffect(create, deps);</span>
    <span class="s1">},</span>
    <span class="s1">useImperativeHandle: </span><span class="s3">function</span><span class="s1">(ref, create, deps) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useImperativeHandle&quot;</span><span class="s1">;</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">updateImperativeHandle(ref, create, deps);</span>
    <span class="s1">},</span>
    <span class="s1">useInsertionEffect: </span><span class="s3">function</span><span class="s1">(create, deps) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useInsertionEffect&quot;</span><span class="s1">;</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">updateInsertionEffect(create, deps);</span>
    <span class="s1">},</span>
    <span class="s1">useLayoutEffect: </span><span class="s3">function</span><span class="s1">(create, deps) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useLayoutEffect&quot;</span><span class="s1">;</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">updateLayoutEffect(create, deps);</span>
    <span class="s1">},</span>
    <span class="s1">useMemo: </span><span class="s3">function</span><span class="s1">(create, deps) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useMemo&quot;</span><span class="s1">;</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher$1.current;</span>
      <span class="s1">ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;</span>

      <span class="s3">try </span><span class="s1">{</span>
        <span class="s3">return </span><span class="s1">updateMemo(create, deps);</span>
      <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
        <span class="s1">ReactCurrentDispatcher$1.current = prevDispatcher;</span>
      <span class="s1">}</span>
    <span class="s1">},</span>
    <span class="s1">useReducer: </span><span class="s3">function</span><span class="s1">(reducer, initialArg, init) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useReducer&quot;</span><span class="s1">;</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher$1.current;</span>
      <span class="s1">ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;</span>

      <span class="s3">try </span><span class="s1">{</span>
        <span class="s3">return </span><span class="s1">rerenderReducer(reducer, initialArg, init);</span>
      <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
        <span class="s1">ReactCurrentDispatcher$1.current = prevDispatcher;</span>
      <span class="s1">}</span>
    <span class="s1">},</span>
    <span class="s1">useRef: </span><span class="s3">function</span><span class="s1">(initialValue) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useRef&quot;</span><span class="s1">;</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">updateRef();</span>
    <span class="s1">},</span>
    <span class="s1">useState: </span><span class="s3">function</span><span class="s1">(initialState) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useState&quot;</span><span class="s1">;</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher$1.current;</span>
      <span class="s1">ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;</span>

      <span class="s3">try </span><span class="s1">{</span>
        <span class="s3">return </span><span class="s1">rerenderState(initialState);</span>
      <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
        <span class="s1">ReactCurrentDispatcher$1.current = prevDispatcher;</span>
      <span class="s1">}</span>
    <span class="s1">},</span>
    <span class="s1">useDebugValue: </span><span class="s3">function</span><span class="s1">(value, formatterFn) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useDebugValue&quot;</span><span class="s1">;</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">updateDebugValue();</span>
    <span class="s1">},</span>
    <span class="s1">useDeferredValue: </span><span class="s3">function</span><span class="s1">(value) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useDeferredValue&quot;</span><span class="s1">;</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">rerenderDeferredValue(value);</span>
    <span class="s1">},</span>
    <span class="s1">useTransition: </span><span class="s3">function</span><span class="s1">() {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useTransition&quot;</span><span class="s1">;</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">rerenderTransition();</span>
    <span class="s1">},</span>
    <span class="s1">useMutableSource: </span><span class="s3">function</span><span class="s1">(source, getSnapshot, subscribe) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useMutableSource&quot;</span><span class="s1">;</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">updateMutableSource();</span>
    <span class="s1">},</span>
    <span class="s1">useSyncExternalStore: </span><span class="s3">function</span><span class="s1">(subscribe, getSnapshot, getServerSnapshot) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useSyncExternalStore&quot;</span><span class="s1">;</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">updateSyncExternalStore(subscribe, getSnapshot);</span>
    <span class="s1">},</span>
    <span class="s1">useId: </span><span class="s3">function</span><span class="s1">() {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useId&quot;</span><span class="s1">;</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">updateId();</span>
    <span class="s1">},</span>
    <span class="s1">unstable_isNewReconciler: enableNewReconciler</span>
  <span class="s1">};</span>

  <span class="s1">InvalidNestedHooksDispatcherOnMountInDEV = {</span>
    <span class="s1">readContext: </span><span class="s3">function</span><span class="s1">(context) {</span>
      <span class="s1">warnInvalidContextAccess();</span>
      <span class="s3">return </span><span class="s1">readContext(context);</span>
    <span class="s1">},</span>
    <span class="s1">useCallback: </span><span class="s3">function</span><span class="s1">(callback, deps) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useCallback&quot;</span><span class="s1">;</span>
      <span class="s1">warnInvalidHookAccess();</span>
      <span class="s1">mountHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">mountCallback(callback, deps);</span>
    <span class="s1">},</span>
    <span class="s1">useContext: </span><span class="s3">function</span><span class="s1">(context) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useContext&quot;</span><span class="s1">;</span>
      <span class="s1">warnInvalidHookAccess();</span>
      <span class="s1">mountHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">readContext(context);</span>
    <span class="s1">},</span>
    <span class="s1">useEffect: </span><span class="s3">function</span><span class="s1">(create, deps) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useEffect&quot;</span><span class="s1">;</span>
      <span class="s1">warnInvalidHookAccess();</span>
      <span class="s1">mountHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">mountEffect(create, deps);</span>
    <span class="s1">},</span>
    <span class="s1">useImperativeHandle: </span><span class="s3">function</span><span class="s1">(ref, create, deps) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useImperativeHandle&quot;</span><span class="s1">;</span>
      <span class="s1">warnInvalidHookAccess();</span>
      <span class="s1">mountHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">mountImperativeHandle(ref, create, deps);</span>
    <span class="s1">},</span>
    <span class="s1">useInsertionEffect: </span><span class="s3">function</span><span class="s1">(create, deps) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useInsertionEffect&quot;</span><span class="s1">;</span>
      <span class="s1">warnInvalidHookAccess();</span>
      <span class="s1">mountHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">mountInsertionEffect(create, deps);</span>
    <span class="s1">},</span>
    <span class="s1">useLayoutEffect: </span><span class="s3">function</span><span class="s1">(create, deps) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useLayoutEffect&quot;</span><span class="s1">;</span>
      <span class="s1">warnInvalidHookAccess();</span>
      <span class="s1">mountHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">mountLayoutEffect(create, deps);</span>
    <span class="s1">},</span>
    <span class="s1">useMemo: </span><span class="s3">function</span><span class="s1">(create, deps) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useMemo&quot;</span><span class="s1">;</span>
      <span class="s1">warnInvalidHookAccess();</span>
      <span class="s1">mountHookTypesDev();</span>
      <span class="s3">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher$1.current;</span>
      <span class="s1">ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;</span>

      <span class="s3">try </span><span class="s1">{</span>
        <span class="s3">return </span><span class="s1">mountMemo(create, deps);</span>
      <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
        <span class="s1">ReactCurrentDispatcher$1.current = prevDispatcher;</span>
      <span class="s1">}</span>
    <span class="s1">},</span>
    <span class="s1">useReducer: </span><span class="s3">function</span><span class="s1">(reducer, initialArg, init) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useReducer&quot;</span><span class="s1">;</span>
      <span class="s1">warnInvalidHookAccess();</span>
      <span class="s1">mountHookTypesDev();</span>
      <span class="s3">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher$1.current;</span>
      <span class="s1">ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;</span>

      <span class="s3">try </span><span class="s1">{</span>
        <span class="s3">return </span><span class="s1">mountReducer(reducer, initialArg, init);</span>
      <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
        <span class="s1">ReactCurrentDispatcher$1.current = prevDispatcher;</span>
      <span class="s1">}</span>
    <span class="s1">},</span>
    <span class="s1">useRef: </span><span class="s3">function</span><span class="s1">(initialValue) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useRef&quot;</span><span class="s1">;</span>
      <span class="s1">warnInvalidHookAccess();</span>
      <span class="s1">mountHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">mountRef(initialValue);</span>
    <span class="s1">},</span>
    <span class="s1">useState: </span><span class="s3">function</span><span class="s1">(initialState) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useState&quot;</span><span class="s1">;</span>
      <span class="s1">warnInvalidHookAccess();</span>
      <span class="s1">mountHookTypesDev();</span>
      <span class="s3">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher$1.current;</span>
      <span class="s1">ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;</span>

      <span class="s3">try </span><span class="s1">{</span>
        <span class="s3">return </span><span class="s1">mountState(initialState);</span>
      <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
        <span class="s1">ReactCurrentDispatcher$1.current = prevDispatcher;</span>
      <span class="s1">}</span>
    <span class="s1">},</span>
    <span class="s1">useDebugValue: </span><span class="s3">function</span><span class="s1">(value, formatterFn) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useDebugValue&quot;</span><span class="s1">;</span>
      <span class="s1">warnInvalidHookAccess();</span>
      <span class="s1">mountHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">mountDebugValue();</span>
    <span class="s1">},</span>
    <span class="s1">useDeferredValue: </span><span class="s3">function</span><span class="s1">(value) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useDeferredValue&quot;</span><span class="s1">;</span>
      <span class="s1">warnInvalidHookAccess();</span>
      <span class="s1">mountHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">mountDeferredValue(value);</span>
    <span class="s1">},</span>
    <span class="s1">useTransition: </span><span class="s3">function</span><span class="s1">() {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useTransition&quot;</span><span class="s1">;</span>
      <span class="s1">warnInvalidHookAccess();</span>
      <span class="s1">mountHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">mountTransition();</span>
    <span class="s1">},</span>
    <span class="s1">useMutableSource: </span><span class="s3">function</span><span class="s1">(source, getSnapshot, subscribe) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useMutableSource&quot;</span><span class="s1">;</span>
      <span class="s1">warnInvalidHookAccess();</span>
      <span class="s1">mountHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">mountMutableSource();</span>
    <span class="s1">},</span>
    <span class="s1">useSyncExternalStore: </span><span class="s3">function</span><span class="s1">(subscribe, getSnapshot, getServerSnapshot) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useSyncExternalStore&quot;</span><span class="s1">;</span>
      <span class="s1">warnInvalidHookAccess();</span>
      <span class="s1">mountHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">mountSyncExternalStore(subscribe, getSnapshot);</span>
    <span class="s1">},</span>
    <span class="s1">useId: </span><span class="s3">function</span><span class="s1">() {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useId&quot;</span><span class="s1">;</span>
      <span class="s1">warnInvalidHookAccess();</span>
      <span class="s1">mountHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">mountId();</span>
    <span class="s1">},</span>
    <span class="s1">unstable_isNewReconciler: enableNewReconciler</span>
  <span class="s1">};</span>

  <span class="s1">InvalidNestedHooksDispatcherOnUpdateInDEV = {</span>
    <span class="s1">readContext: </span><span class="s3">function</span><span class="s1">(context) {</span>
      <span class="s1">warnInvalidContextAccess();</span>
      <span class="s3">return </span><span class="s1">readContext(context);</span>
    <span class="s1">},</span>
    <span class="s1">useCallback: </span><span class="s3">function</span><span class="s1">(callback, deps) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useCallback&quot;</span><span class="s1">;</span>
      <span class="s1">warnInvalidHookAccess();</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">updateCallback(callback, deps);</span>
    <span class="s1">},</span>
    <span class="s1">useContext: </span><span class="s3">function</span><span class="s1">(context) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useContext&quot;</span><span class="s1">;</span>
      <span class="s1">warnInvalidHookAccess();</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">readContext(context);</span>
    <span class="s1">},</span>
    <span class="s1">useEffect: </span><span class="s3">function</span><span class="s1">(create, deps) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useEffect&quot;</span><span class="s1">;</span>
      <span class="s1">warnInvalidHookAccess();</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">updateEffect(create, deps);</span>
    <span class="s1">},</span>
    <span class="s1">useImperativeHandle: </span><span class="s3">function</span><span class="s1">(ref, create, deps) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useImperativeHandle&quot;</span><span class="s1">;</span>
      <span class="s1">warnInvalidHookAccess();</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">updateImperativeHandle(ref, create, deps);</span>
    <span class="s1">},</span>
    <span class="s1">useInsertionEffect: </span><span class="s3">function</span><span class="s1">(create, deps) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useInsertionEffect&quot;</span><span class="s1">;</span>
      <span class="s1">warnInvalidHookAccess();</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">updateInsertionEffect(create, deps);</span>
    <span class="s1">},</span>
    <span class="s1">useLayoutEffect: </span><span class="s3">function</span><span class="s1">(create, deps) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useLayoutEffect&quot;</span><span class="s1">;</span>
      <span class="s1">warnInvalidHookAccess();</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">updateLayoutEffect(create, deps);</span>
    <span class="s1">},</span>
    <span class="s1">useMemo: </span><span class="s3">function</span><span class="s1">(create, deps) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useMemo&quot;</span><span class="s1">;</span>
      <span class="s1">warnInvalidHookAccess();</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher$1.current;</span>
      <span class="s1">ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;</span>

      <span class="s3">try </span><span class="s1">{</span>
        <span class="s3">return </span><span class="s1">updateMemo(create, deps);</span>
      <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
        <span class="s1">ReactCurrentDispatcher$1.current = prevDispatcher;</span>
      <span class="s1">}</span>
    <span class="s1">},</span>
    <span class="s1">useReducer: </span><span class="s3">function</span><span class="s1">(reducer, initialArg, init) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useReducer&quot;</span><span class="s1">;</span>
      <span class="s1">warnInvalidHookAccess();</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher$1.current;</span>
      <span class="s1">ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;</span>

      <span class="s3">try </span><span class="s1">{</span>
        <span class="s3">return </span><span class="s1">updateReducer(reducer, initialArg, init);</span>
      <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
        <span class="s1">ReactCurrentDispatcher$1.current = prevDispatcher;</span>
      <span class="s1">}</span>
    <span class="s1">},</span>
    <span class="s1">useRef: </span><span class="s3">function</span><span class="s1">(initialValue) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useRef&quot;</span><span class="s1">;</span>
      <span class="s1">warnInvalidHookAccess();</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">updateRef();</span>
    <span class="s1">},</span>
    <span class="s1">useState: </span><span class="s3">function</span><span class="s1">(initialState) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useState&quot;</span><span class="s1">;</span>
      <span class="s1">warnInvalidHookAccess();</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher$1.current;</span>
      <span class="s1">ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;</span>

      <span class="s3">try </span><span class="s1">{</span>
        <span class="s3">return </span><span class="s1">updateState(initialState);</span>
      <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
        <span class="s1">ReactCurrentDispatcher$1.current = prevDispatcher;</span>
      <span class="s1">}</span>
    <span class="s1">},</span>
    <span class="s1">useDebugValue: </span><span class="s3">function</span><span class="s1">(value, formatterFn) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useDebugValue&quot;</span><span class="s1">;</span>
      <span class="s1">warnInvalidHookAccess();</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">updateDebugValue();</span>
    <span class="s1">},</span>
    <span class="s1">useDeferredValue: </span><span class="s3">function</span><span class="s1">(value) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useDeferredValue&quot;</span><span class="s1">;</span>
      <span class="s1">warnInvalidHookAccess();</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">updateDeferredValue(value);</span>
    <span class="s1">},</span>
    <span class="s1">useTransition: </span><span class="s3">function</span><span class="s1">() {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useTransition&quot;</span><span class="s1">;</span>
      <span class="s1">warnInvalidHookAccess();</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">updateTransition();</span>
    <span class="s1">},</span>
    <span class="s1">useMutableSource: </span><span class="s3">function</span><span class="s1">(source, getSnapshot, subscribe) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useMutableSource&quot;</span><span class="s1">;</span>
      <span class="s1">warnInvalidHookAccess();</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">updateMutableSource();</span>
    <span class="s1">},</span>
    <span class="s1">useSyncExternalStore: </span><span class="s3">function</span><span class="s1">(subscribe, getSnapshot, getServerSnapshot) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useSyncExternalStore&quot;</span><span class="s1">;</span>
      <span class="s1">warnInvalidHookAccess();</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">updateSyncExternalStore(subscribe, getSnapshot);</span>
    <span class="s1">},</span>
    <span class="s1">useId: </span><span class="s3">function</span><span class="s1">() {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useId&quot;</span><span class="s1">;</span>
      <span class="s1">warnInvalidHookAccess();</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">updateId();</span>
    <span class="s1">},</span>
    <span class="s1">unstable_isNewReconciler: enableNewReconciler</span>
  <span class="s1">};</span>

  <span class="s1">InvalidNestedHooksDispatcherOnRerenderInDEV = {</span>
    <span class="s1">readContext: </span><span class="s3">function</span><span class="s1">(context) {</span>
      <span class="s1">warnInvalidContextAccess();</span>
      <span class="s3">return </span><span class="s1">readContext(context);</span>
    <span class="s1">},</span>
    <span class="s1">useCallback: </span><span class="s3">function</span><span class="s1">(callback, deps) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useCallback&quot;</span><span class="s1">;</span>
      <span class="s1">warnInvalidHookAccess();</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">updateCallback(callback, deps);</span>
    <span class="s1">},</span>
    <span class="s1">useContext: </span><span class="s3">function</span><span class="s1">(context) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useContext&quot;</span><span class="s1">;</span>
      <span class="s1">warnInvalidHookAccess();</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">readContext(context);</span>
    <span class="s1">},</span>
    <span class="s1">useEffect: </span><span class="s3">function</span><span class="s1">(create, deps) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useEffect&quot;</span><span class="s1">;</span>
      <span class="s1">warnInvalidHookAccess();</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">updateEffect(create, deps);</span>
    <span class="s1">},</span>
    <span class="s1">useImperativeHandle: </span><span class="s3">function</span><span class="s1">(ref, create, deps) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useImperativeHandle&quot;</span><span class="s1">;</span>
      <span class="s1">warnInvalidHookAccess();</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">updateImperativeHandle(ref, create, deps);</span>
    <span class="s1">},</span>
    <span class="s1">useInsertionEffect: </span><span class="s3">function</span><span class="s1">(create, deps) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useInsertionEffect&quot;</span><span class="s1">;</span>
      <span class="s1">warnInvalidHookAccess();</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">updateInsertionEffect(create, deps);</span>
    <span class="s1">},</span>
    <span class="s1">useLayoutEffect: </span><span class="s3">function</span><span class="s1">(create, deps) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useLayoutEffect&quot;</span><span class="s1">;</span>
      <span class="s1">warnInvalidHookAccess();</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">updateLayoutEffect(create, deps);</span>
    <span class="s1">},</span>
    <span class="s1">useMemo: </span><span class="s3">function</span><span class="s1">(create, deps) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useMemo&quot;</span><span class="s1">;</span>
      <span class="s1">warnInvalidHookAccess();</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher$1.current;</span>
      <span class="s1">ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;</span>

      <span class="s3">try </span><span class="s1">{</span>
        <span class="s3">return </span><span class="s1">updateMemo(create, deps);</span>
      <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
        <span class="s1">ReactCurrentDispatcher$1.current = prevDispatcher;</span>
      <span class="s1">}</span>
    <span class="s1">},</span>
    <span class="s1">useReducer: </span><span class="s3">function</span><span class="s1">(reducer, initialArg, init) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useReducer&quot;</span><span class="s1">;</span>
      <span class="s1">warnInvalidHookAccess();</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher$1.current;</span>
      <span class="s1">ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;</span>

      <span class="s3">try </span><span class="s1">{</span>
        <span class="s3">return </span><span class="s1">rerenderReducer(reducer, initialArg, init);</span>
      <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
        <span class="s1">ReactCurrentDispatcher$1.current = prevDispatcher;</span>
      <span class="s1">}</span>
    <span class="s1">},</span>
    <span class="s1">useRef: </span><span class="s3">function</span><span class="s1">(initialValue) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useRef&quot;</span><span class="s1">;</span>
      <span class="s1">warnInvalidHookAccess();</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">updateRef();</span>
    <span class="s1">},</span>
    <span class="s1">useState: </span><span class="s3">function</span><span class="s1">(initialState) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useState&quot;</span><span class="s1">;</span>
      <span class="s1">warnInvalidHookAccess();</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher$1.current;</span>
      <span class="s1">ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;</span>

      <span class="s3">try </span><span class="s1">{</span>
        <span class="s3">return </span><span class="s1">rerenderState(initialState);</span>
      <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
        <span class="s1">ReactCurrentDispatcher$1.current = prevDispatcher;</span>
      <span class="s1">}</span>
    <span class="s1">},</span>
    <span class="s1">useDebugValue: </span><span class="s3">function</span><span class="s1">(value, formatterFn) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useDebugValue&quot;</span><span class="s1">;</span>
      <span class="s1">warnInvalidHookAccess();</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">updateDebugValue();</span>
    <span class="s1">},</span>
    <span class="s1">useDeferredValue: </span><span class="s3">function</span><span class="s1">(value) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useDeferredValue&quot;</span><span class="s1">;</span>
      <span class="s1">warnInvalidHookAccess();</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">rerenderDeferredValue(value);</span>
    <span class="s1">},</span>
    <span class="s1">useTransition: </span><span class="s3">function</span><span class="s1">() {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useTransition&quot;</span><span class="s1">;</span>
      <span class="s1">warnInvalidHookAccess();</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">rerenderTransition();</span>
    <span class="s1">},</span>
    <span class="s1">useMutableSource: </span><span class="s3">function</span><span class="s1">(source, getSnapshot, subscribe) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useMutableSource&quot;</span><span class="s1">;</span>
      <span class="s1">warnInvalidHookAccess();</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">updateMutableSource();</span>
    <span class="s1">},</span>
    <span class="s1">useSyncExternalStore: </span><span class="s3">function</span><span class="s1">(subscribe, getSnapshot, getServerSnapshot) {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useSyncExternalStore&quot;</span><span class="s1">;</span>
      <span class="s1">warnInvalidHookAccess();</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">updateSyncExternalStore(subscribe, getSnapshot);</span>
    <span class="s1">},</span>
    <span class="s1">useId: </span><span class="s3">function</span><span class="s1">() {</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">&quot;useId&quot;</span><span class="s1">;</span>
      <span class="s1">warnInvalidHookAccess();</span>
      <span class="s1">updateHookTypesDev();</span>
      <span class="s3">return </span><span class="s1">updateId();</span>
    <span class="s1">},</span>
    <span class="s1">unstable_isNewReconciler: enableNewReconciler</span>
  <span class="s1">};</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">now$1 = Scheduler.unstable_now;</span>
<span class="s3">var </span><span class="s1">commitTime = </span><span class="s4">0</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">layoutEffectStartTime = -</span><span class="s4">1</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">profilerStartTime = -</span><span class="s4">1</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">passiveEffectStartTime = -</span><span class="s4">1</span><span class="s1">;</span>
<span class="s0">/** 
 * Tracks whether the current update was a nested/cascading update (scheduled from a layout effect). 
 * 
 * The overall sequence is: 
 *   1. render 
 *   2. commit (and call `onRender`, `onCommit`) 
 *   3. check for nested updates 
 *   4. flush passive effects (and call `onPostCommit`) 
 * 
 * Nested updates are identified in step 3 above, 
 * but step 4 still applies to the work that was just committed. 
 * We use two flags to track nested updates then: 
 * one tracks whether the upcoming update is a nested update, 
 * and the other tracks whether the current update was a nested update. 
 * The first value gets synced to the second at the start of the render phase. 
 */</span>

<span class="s3">var </span><span class="s1">currentUpdateIsNested = </span><span class="s3">false</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">nestedUpdateScheduled = </span><span class="s3">false</span><span class="s1">;</span>

<span class="s3">function </span><span class="s1">isCurrentUpdateNested() {</span>
  <span class="s3">return </span><span class="s1">currentUpdateIsNested;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">markNestedUpdateScheduled() {</span>
  <span class="s1">{</span>
    <span class="s1">nestedUpdateScheduled = </span><span class="s3">true</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">resetNestedUpdateFlag() {</span>
  <span class="s1">{</span>
    <span class="s1">currentUpdateIsNested = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">nestedUpdateScheduled = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">syncNestedUpdateFlag() {</span>
  <span class="s1">{</span>
    <span class="s1">currentUpdateIsNested = nestedUpdateScheduled;</span>
    <span class="s1">nestedUpdateScheduled = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">getCommitTime() {</span>
  <span class="s3">return </span><span class="s1">commitTime;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">recordCommitTime() {</span>
  <span class="s1">commitTime = now$1();</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">startProfilerTimer(fiber) {</span>
  <span class="s1">profilerStartTime = now$1();</span>

  <span class="s3">if </span><span class="s1">(fiber.actualStartTime &lt; </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s1">fiber.actualStartTime = now$1();</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">stopProfilerTimerIfRunning(fiber) {</span>
  <span class="s1">profilerStartTime = -</span><span class="s4">1</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {</span>
  <span class="s3">if </span><span class="s1">(profilerStartTime &gt;= </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">elapsedTime = now$1() - profilerStartTime;</span>
    <span class="s1">fiber.actualDuration += elapsedTime;</span>

    <span class="s3">if </span><span class="s1">(overrideBaseTime) {</span>
      <span class="s1">fiber.selfBaseDuration = elapsedTime;</span>
    <span class="s1">}</span>

    <span class="s1">profilerStartTime = -</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">recordLayoutEffectDuration(fiber) {</span>
  <span class="s3">if </span><span class="s1">(layoutEffectStartTime &gt;= </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">elapsedTime = now$1() - layoutEffectStartTime;</span>
    <span class="s1">layoutEffectStartTime = -</span><span class="s4">1</span><span class="s1">; </span><span class="s0">// Store duration on the next nearest Profiler ancestor</span>
    <span class="s0">// Or the root (for the DevTools Profiler to read)</span>

    <span class="s3">var </span><span class="s1">parentFiber = fiber.</span><span class="s3">return</span><span class="s1">;</span>

    <span class="s3">while </span><span class="s1">(parentFiber !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">switch </span><span class="s1">(parentFiber.tag) {</span>
        <span class="s3">case </span><span class="s1">HostRoot:</span>
          <span class="s3">var </span><span class="s1">root = parentFiber.stateNode;</span>
          <span class="s1">root.effectDuration += elapsedTime;</span>
          <span class="s3">return</span><span class="s1">;</span>

        <span class="s3">case </span><span class="s1">Profiler:</span>
          <span class="s3">var </span><span class="s1">parentStateNode = parentFiber.stateNode;</span>
          <span class="s1">parentStateNode.effectDuration += elapsedTime;</span>
          <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">parentFiber = parentFiber.</span><span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">recordPassiveEffectDuration(fiber) {</span>
  <span class="s3">if </span><span class="s1">(passiveEffectStartTime &gt;= </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">elapsedTime = now$1() - passiveEffectStartTime;</span>
    <span class="s1">passiveEffectStartTime = -</span><span class="s4">1</span><span class="s1">; </span><span class="s0">// Store duration on the next nearest Profiler ancestor</span>
    <span class="s0">// Or the root (for the DevTools Profiler to read)</span>

    <span class="s3">var </span><span class="s1">parentFiber = fiber.</span><span class="s3">return</span><span class="s1">;</span>

    <span class="s3">while </span><span class="s1">(parentFiber !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">switch </span><span class="s1">(parentFiber.tag) {</span>
        <span class="s3">case </span><span class="s1">HostRoot:</span>
          <span class="s3">var </span><span class="s1">root = parentFiber.stateNode;</span>

          <span class="s3">if </span><span class="s1">(root !== </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s1">root.passiveEffectDuration += elapsedTime;</span>
          <span class="s1">}</span>

          <span class="s3">return</span><span class="s1">;</span>

        <span class="s3">case </span><span class="s1">Profiler:</span>
          <span class="s3">var </span><span class="s1">parentStateNode = parentFiber.stateNode;</span>

          <span class="s3">if </span><span class="s1">(parentStateNode !== </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s0">// Detached fibers have their state node cleared out.</span>
            <span class="s0">// In this case, the return pointer is also cleared out,</span>
            <span class="s0">// so we won't be able to report the time spent in this Profiler's subtree.</span>
            <span class="s1">parentStateNode.passiveEffectDuration += elapsedTime;</span>
          <span class="s1">}</span>

          <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">parentFiber = parentFiber.</span><span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">startLayoutEffectTimer() {</span>
  <span class="s1">layoutEffectStartTime = now$1();</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">startPassiveEffectTimer() {</span>
  <span class="s1">passiveEffectStartTime = now$1();</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">transferActualDuration(fiber) {</span>
  <span class="s0">// Transfer time spent rendering these children so we don't lose it</span>
  <span class="s0">// after we rerender. This is used as a helper in special cases</span>
  <span class="s0">// where we should count the work of multiple passes.</span>
  <span class="s3">var </span><span class="s1">child = fiber.child;</span>

  <span class="s3">while </span><span class="s1">(child) {</span>
    <span class="s1">fiber.actualDuration += child.actualDuration;</span>
    <span class="s1">child = child.sibling;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">createCapturedValueAtFiber(value, source) {</span>
  <span class="s0">// If the value is an error, call this function immediately after it is thrown</span>
  <span class="s0">// so the stack is accurate.</span>
  <span class="s3">return </span><span class="s1">{</span>
    <span class="s1">value: value,</span>
    <span class="s1">source: source,</span>
    <span class="s1">stack: getStackByFiberInDevAndProd(source),</span>
    <span class="s1">digest: </span><span class="s3">null</span>
  <span class="s1">};</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">createCapturedValue(value, digest, stack) {</span>
  <span class="s3">return </span><span class="s1">{</span>
    <span class="s1">value: value,</span>
    <span class="s1">source: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">stack: stack != </span><span class="s3">null </span><span class="s1">? stack : </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">digest: digest != </span><span class="s3">null </span><span class="s1">? digest : </span><span class="s3">null</span>
  <span class="s1">};</span>
<span class="s1">}</span>

<span class="s3">if </span><span class="s1">(</span>
  <span class="s3">typeof </span><span class="s1">ReactNativePrivateInterface.ReactFiberErrorDialog.showErrorDialog !==</span>
  <span class="s2">&quot;function&quot;</span>
<span class="s1">) {</span>
  <span class="s3">throw new </span><span class="s1">Error(</span>
    <span class="s2">&quot;Expected ReactFiberErrorDialog.showErrorDialog to be a function.&quot;</span>
  <span class="s1">);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">showErrorDialog(boundary, errorInfo) {</span>
  <span class="s3">var </span><span class="s1">capturedError = {</span>
    <span class="s1">componentStack: errorInfo.stack !== </span><span class="s3">null </span><span class="s1">? errorInfo.stack : </span><span class="s2">&quot;&quot;</span><span class="s1">,</span>
    <span class="s1">error: errorInfo.value,</span>
    <span class="s1">errorBoundary:</span>
      <span class="s1">boundary !== </span><span class="s3">null </span><span class="s1">&amp;&amp; boundary.tag === ClassComponent</span>
        <span class="s1">? boundary.stateNode</span>
        <span class="s1">: </span><span class="s3">null</span>
  <span class="s1">};</span>
  <span class="s3">return </span><span class="s1">ReactNativePrivateInterface.ReactFiberErrorDialog.showErrorDialog(</span>
    <span class="s1">capturedError</span>
  <span class="s1">);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">logCapturedError(boundary, errorInfo) {</span>
  <span class="s3">try </span><span class="s1">{</span>
    <span class="s3">var </span><span class="s1">logError = showErrorDialog(boundary, errorInfo); </span><span class="s0">// Allow injected showErrorDialog() to prevent default console.error logging.</span>
    <span class="s0">// This enables renderers like ReactNative to better manage redbox behavior.</span>

    <span class="s3">if </span><span class="s1">(logError === </span><span class="s3">false</span><span class="s1">) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">error = errorInfo.value;</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">true</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">source = errorInfo.source;</span>
      <span class="s3">var </span><span class="s1">stack = errorInfo.stack;</span>
      <span class="s3">var </span><span class="s1">componentStack = stack !== </span><span class="s3">null </span><span class="s1">? stack : </span><span class="s2">&quot;&quot;</span><span class="s1">; </span><span class="s0">// Browsers support silencing uncaught errors by calling</span>
      <span class="s0">// `preventDefault()` in window `error` handler.</span>
      <span class="s0">// We record this information as an expando on the error.</span>

      <span class="s3">if </span><span class="s1">(error != </span><span class="s3">null </span><span class="s1">&amp;&amp; error._suppressLogging) {</span>
        <span class="s3">if </span><span class="s1">(boundary.tag === ClassComponent) {</span>
          <span class="s0">// The error is recoverable and was silenced.</span>
          <span class="s0">// Ignore it and don't print the stack addendum.</span>
          <span class="s0">// This is handy for testing error boundaries without noise.</span>
          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s0">// The error is fatal. Since the silencing might have</span>
        <span class="s0">// been accidental, we'll surface it anyway.</span>
        <span class="s0">// However, the browser would have silenced the original error</span>
        <span class="s0">// so we'll print it first, and then print the stack addendum.</span>

        <span class="s1">console[</span><span class="s2">&quot;error&quot;</span><span class="s1">](error); </span><span class="s0">// Don't transform to our wrapper</span>
        <span class="s0">// For a more detailed description of this block, see:</span>
        <span class="s0">// https://github.com/facebook/react/pull/13384</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">componentName = source ? getComponentNameFromFiber(source) : </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s3">var </span><span class="s1">componentNameMessage = componentName</span>
        <span class="s1">? </span><span class="s2">&quot;The above error occurred in the &lt;&quot; </span><span class="s1">+ componentName + </span><span class="s2">&quot;&gt; component:&quot;</span>
        <span class="s1">: </span><span class="s2">&quot;The above error occurred in one of your React components:&quot;</span><span class="s1">;</span>
      <span class="s3">var </span><span class="s1">errorBoundaryMessage;</span>

      <span class="s3">if </span><span class="s1">(boundary.tag === HostRoot) {</span>
        <span class="s1">errorBoundaryMessage =</span>
          <span class="s2">&quot;Consider adding an error boundary to your tree to customize error handling behavior.</span><span class="s5">\n</span><span class="s2">&quot; </span><span class="s1">+</span>
          <span class="s2">&quot;Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.&quot;</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s3">var </span><span class="s1">errorBoundaryName =</span>
          <span class="s1">getComponentNameFromFiber(boundary) || </span><span class="s2">&quot;Anonymous&quot;</span><span class="s1">;</span>
        <span class="s1">errorBoundaryMessage =</span>
          <span class="s2">&quot;React will try to recreate this component tree from scratch &quot; </span><span class="s1">+</span>
          <span class="s1">(</span><span class="s2">&quot;using the error boundary you provided, &quot; </span><span class="s1">+ errorBoundaryName + </span><span class="s2">&quot;.&quot;</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">combinedMessage =</span>
        <span class="s1">componentNameMessage +</span>
        <span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot; </span><span class="s1">+</span>
        <span class="s1">componentStack +</span>
        <span class="s2">&quot;</span><span class="s5">\n\n</span><span class="s2">&quot; </span><span class="s1">+</span>
        <span class="s1">(</span><span class="s2">&quot;&quot; </span><span class="s1">+ errorBoundaryMessage); </span><span class="s0">// In development, we provide our own message with just the component stack.</span>
      <span class="s0">// We don't include the original error message and JS stack because the browser</span>
      <span class="s0">// has already printed it. Even if the application swallows the error, it is still</span>
      <span class="s0">// displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.</span>

      <span class="s1">console[</span><span class="s2">&quot;error&quot;</span><span class="s1">](combinedMessage); </span><span class="s0">// Don't transform to our wrapper</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s0">// In production, we print the error directly.</span>
      <span class="s0">// This will include the message, the JS stack, and anything the browser wants to show.</span>
      <span class="s0">// We pass the error object instead of custom message so that the browser displays the error natively.</span>
      <span class="s1">console[</span><span class="s2">&quot;error&quot;</span><span class="s1">](error); </span><span class="s0">// Don't transform to our wrapper</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s3">catch </span><span class="s1">(e) {</span>
    <span class="s0">// This method must not throw, or React internal state will get messed up.</span>
    <span class="s0">// If console.error is overridden, or logCapturedError() shows a dialog that throws,</span>
    <span class="s0">// we want to report this error outside of the normal stack as a last resort.</span>
    <span class="s0">// https://github.com/facebook/react/issues/13188</span>
    <span class="s1">setTimeout(</span><span class="s3">function</span><span class="s1">() {</span>
      <span class="s3">throw </span><span class="s1">e;</span>
    <span class="s1">});</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">PossiblyWeakMap$1 = </span><span class="s3">typeof </span><span class="s1">WeakMap === </span><span class="s2">&quot;function&quot; </span><span class="s1">? WeakMap : Map;</span>

<span class="s3">function </span><span class="s1">createRootErrorUpdate(fiber, errorInfo, lane) {</span>
  <span class="s3">var </span><span class="s1">update = createUpdate(NoTimestamp, lane); </span><span class="s0">// Unmount the root by rendering null.</span>

  <span class="s1">update.tag = CaptureUpdate; </span><span class="s0">// Caution: React DevTools currently depends on this property</span>
  <span class="s0">// being called &quot;element&quot;.</span>

  <span class="s1">update.payload = {</span>
    <span class="s1">element: </span><span class="s3">null</span>
  <span class="s1">};</span>
  <span class="s3">var </span><span class="s1">error = errorInfo.value;</span>

  <span class="s1">update.callback = </span><span class="s3">function</span><span class="s1">() {</span>
    <span class="s1">onUncaughtError(error);</span>
    <span class="s1">logCapturedError(fiber, errorInfo);</span>
  <span class="s1">};</span>

  <span class="s3">return </span><span class="s1">update;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">createClassErrorUpdate(fiber, errorInfo, lane) {</span>
  <span class="s3">var </span><span class="s1">update = createUpdate(NoTimestamp, lane);</span>
  <span class="s1">update.tag = CaptureUpdate;</span>
  <span class="s3">var </span><span class="s1">getDerivedStateFromError = fiber.type.getDerivedStateFromError;</span>

  <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">getDerivedStateFromError === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">error$1 = errorInfo.value;</span>

    <span class="s1">update.payload = </span><span class="s3">function</span><span class="s1">() {</span>
      <span class="s3">return </span><span class="s1">getDerivedStateFromError(error$1);</span>
    <span class="s1">};</span>

    <span class="s1">update.callback = </span><span class="s3">function</span><span class="s1">() {</span>
      <span class="s1">{</span>
        <span class="s1">markFailedErrorBoundaryForHotReloading(fiber);</span>
      <span class="s1">}</span>

      <span class="s1">logCapturedError(fiber, errorInfo);</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">inst = fiber.stateNode;</span>

  <span class="s3">if </span><span class="s1">(inst !== </span><span class="s3">null </span><span class="s1">&amp;&amp; </span><span class="s3">typeof </span><span class="s1">inst.componentDidCatch === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
    <span class="s1">update.callback = </span><span class="s3">function </span><span class="s1">callback() {</span>
      <span class="s1">{</span>
        <span class="s1">markFailedErrorBoundaryForHotReloading(fiber);</span>
      <span class="s1">}</span>

      <span class="s1">logCapturedError(fiber, errorInfo);</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">getDerivedStateFromError !== </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
        <span class="s0">// To preserve the preexisting retry behavior of error boundaries,</span>
        <span class="s0">// we keep track of which ones already failed during this batch.</span>
        <span class="s0">// This gets reset before we yield back to the browser.</span>
        <span class="s0">// TODO: Warn in strict mode if getDerivedStateFromError is</span>
        <span class="s0">// not defined.</span>
        <span class="s1">markLegacyErrorBoundaryAsFailed(</span><span class="s3">this</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">error$1 = errorInfo.value;</span>
      <span class="s3">var </span><span class="s1">stack = errorInfo.stack;</span>
      <span class="s3">this</span><span class="s1">.componentDidCatch(error$1, {</span>
        <span class="s1">componentStack: stack !== </span><span class="s3">null </span><span class="s1">? stack : </span><span class="s2">&quot;&quot;</span>
      <span class="s1">});</span>

      <span class="s1">{</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">getDerivedStateFromError !== </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
          <span class="s0">// If componentDidCatch is the only error boundary method defined,</span>
          <span class="s0">// then it needs to call setState to recover from errors.</span>
          <span class="s0">// If no state update is scheduled then the boundary will swallow the error.</span>
          <span class="s3">if </span><span class="s1">(!includesSomeLane(fiber.lanes, SyncLane)) {</span>
            <span class="s1">error(</span>
              <span class="s2">&quot;%s: Error boundaries should implement getDerivedStateFromError(). &quot; </span><span class="s1">+</span>
                <span class="s2">&quot;In that method, return a state update to display an error message or fallback UI.&quot;</span><span class="s1">,</span>
              <span class="s1">getComponentNameFromFiber(fiber) || </span><span class="s2">&quot;Unknown&quot;</span>
            <span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">update;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">attachPingListener(root, wakeable, lanes) {</span>
  <span class="s0">// Attach a ping listener</span>
  <span class="s0">//</span>
  <span class="s0">// The data might resolve before we have a chance to commit the fallback. Or,</span>
  <span class="s0">// in the case of a refresh, we'll never commit a fallback. So we need to</span>
  <span class="s0">// attach a listener now. When it resolves (&quot;pings&quot;), we can decide whether to</span>
  <span class="s0">// try rendering the tree again.</span>
  <span class="s0">//</span>
  <span class="s0">// Only attach a listener if one does not already exist for the lanes</span>
  <span class="s0">// we're currently rendering (which acts like a &quot;thread ID&quot; here).</span>
  <span class="s0">//</span>
  <span class="s0">// We only need to do this in concurrent mode. Legacy Suspense always</span>
  <span class="s0">// commits fallbacks synchronously, so there are no pings.</span>
  <span class="s3">var </span><span class="s1">pingCache = root.pingCache;</span>
  <span class="s3">var </span><span class="s1">threadIDs;</span>

  <span class="s3">if </span><span class="s1">(pingCache === </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s1">pingCache = root.pingCache = </span><span class="s3">new </span><span class="s1">PossiblyWeakMap$1();</span>
    <span class="s1">threadIDs = </span><span class="s3">new </span><span class="s1">Set();</span>
    <span class="s1">pingCache.set(wakeable, threadIDs);</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">threadIDs = pingCache.get(wakeable);</span>

    <span class="s3">if </span><span class="s1">(threadIDs === undefined) {</span>
      <span class="s1">threadIDs = </span><span class="s3">new </span><span class="s1">Set();</span>
      <span class="s1">pingCache.set(wakeable, threadIDs);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(!threadIDs.has(lanes)) {</span>
    <span class="s0">// Memoize using the thread ID to prevent redundant listeners.</span>
    <span class="s1">threadIDs.add(lanes);</span>
    <span class="s3">var </span><span class="s1">ping = pingSuspendedRoot.bind(</span><span class="s3">null</span><span class="s1">, root, wakeable, lanes);</span>

    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(isDevToolsPresent) {</span>
        <span class="s0">// If we have pending work still, restore the original updaters</span>
        <span class="s1">restorePendingUpdaters(root, lanes);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">wakeable.then(ping, ping);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">attachRetryListener(suspenseBoundary, root, wakeable, lanes) {</span>
  <span class="s0">// Retry listener</span>
  <span class="s0">//</span>
  <span class="s0">// If the fallback does commit, we need to attach a different type of</span>
  <span class="s0">// listener. This one schedules an update on the Suspense boundary to turn</span>
  <span class="s0">// the fallback state off.</span>
  <span class="s0">//</span>
  <span class="s0">// Stash the wakeable on the boundary fiber so we can access it in the</span>
  <span class="s0">// commit phase.</span>
  <span class="s0">//</span>
  <span class="s0">// When the wakeable resolves, we'll attempt to render the boundary</span>
  <span class="s0">// again (&quot;retry&quot;).</span>
  <span class="s3">var </span><span class="s1">wakeables = suspenseBoundary.updateQueue;</span>

  <span class="s3">if </span><span class="s1">(wakeables === </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">updateQueue = </span><span class="s3">new </span><span class="s1">Set();</span>
    <span class="s1">updateQueue.add(wakeable);</span>
    <span class="s1">suspenseBoundary.updateQueue = updateQueue;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">wakeables.add(wakeable);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">resetSuspendedComponent(sourceFiber, rootRenderLanes) {</span>
  <span class="s0">// A legacy mode Suspense quirk, only relevant to hook components.</span>

  <span class="s3">var </span><span class="s1">tag = sourceFiber.tag;</span>

  <span class="s3">if </span><span class="s1">(</span>
    <span class="s1">(sourceFiber.mode &amp; ConcurrentMode) === NoMode &amp;&amp;</span>
    <span class="s1">(tag === FunctionComponent ||</span>
      <span class="s1">tag === ForwardRef ||</span>
      <span class="s1">tag === SimpleMemoComponent)</span>
  <span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">currentSource = sourceFiber.alternate;</span>

    <span class="s3">if </span><span class="s1">(currentSource) {</span>
      <span class="s1">sourceFiber.updateQueue = currentSource.updateQueue;</span>
      <span class="s1">sourceFiber.memoizedState = currentSource.memoizedState;</span>
      <span class="s1">sourceFiber.lanes = currentSource.lanes;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">sourceFiber.updateQueue = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">sourceFiber.memoizedState = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">getNearestSuspenseBoundaryToCapture(returnFiber) {</span>
  <span class="s3">var </span><span class="s1">node = returnFiber;</span>

  <span class="s3">do </span><span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(node.tag === SuspenseComponent &amp;&amp; shouldCaptureSuspense(node)) {</span>
      <span class="s3">return </span><span class="s1">node;</span>
    <span class="s1">} </span><span class="s0">// This boundary already captured during this render. Continue to the next</span>
    <span class="s0">// boundary.</span>

    <span class="s1">node = node.</span><span class="s3">return</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s3">while </span><span class="s1">(node !== </span><span class="s3">null</span><span class="s1">);</span>

  <span class="s3">return null</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">markSuspenseBoundaryShouldCapture(</span>
  <span class="s1">suspenseBoundary,</span>
  <span class="s1">returnFiber,</span>
  <span class="s1">sourceFiber,</span>
  <span class="s1">root,</span>
  <span class="s1">rootRenderLanes</span>
<span class="s1">) {</span>
  <span class="s0">// This marks a Suspense boundary so that when we're unwinding the stack,</span>
  <span class="s0">// it captures the suspended &quot;exception&quot; and does a second (fallback) pass.</span>
  <span class="s3">if </span><span class="s1">((suspenseBoundary.mode &amp; ConcurrentMode) === NoMode) {</span>
    <span class="s0">// Legacy Mode Suspense</span>
    <span class="s0">//</span>
    <span class="s0">// If the boundary is in legacy mode, we should *not*</span>
    <span class="s0">// suspend the commit. Pretend as if the suspended component rendered</span>
    <span class="s0">// null and keep rendering. When the Suspense boundary completes,</span>
    <span class="s0">// we'll do a second pass to render the fallback.</span>
    <span class="s3">if </span><span class="s1">(suspenseBoundary === returnFiber) {</span>
      <span class="s0">// Special case where we suspended while reconciling the children of</span>
      <span class="s0">// a Suspense boundary's inner Offscreen wrapper fiber. This happens</span>
      <span class="s0">// when a React.lazy component is a direct child of a</span>
      <span class="s0">// Suspense boundary.</span>
      <span class="s0">//</span>
      <span class="s0">// Suspense boundaries are implemented as multiple fibers, but they</span>
      <span class="s0">// are a single conceptual unit. The legacy mode behavior where we</span>
      <span class="s0">// pretend the suspended fiber committed as `null` won't work,</span>
      <span class="s0">// because in this case the &quot;suspended&quot; fiber is the inner</span>
      <span class="s0">// Offscreen wrapper.</span>
      <span class="s0">//</span>
      <span class="s0">// Because the contents of the boundary haven't started rendering</span>
      <span class="s0">// yet (i.e. nothing in the tree has partially rendered) we can</span>
      <span class="s0">// switch to the regular, concurrent mode behavior: mark the</span>
      <span class="s0">// boundary with ShouldCapture and enter the unwind phase.</span>
      <span class="s1">suspenseBoundary.flags |= ShouldCapture;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">suspenseBoundary.flags |= DidCapture;</span>
      <span class="s1">sourceFiber.flags |= ForceUpdateForLegacySuspense; </span><span class="s0">// We're going to commit this fiber even though it didn't complete.</span>
      <span class="s0">// But we shouldn't call any lifecycle methods or callbacks. Remove</span>
      <span class="s0">// all lifecycle effect tags.</span>

      <span class="s1">sourceFiber.flags &amp;= ~(LifecycleEffectMask | Incomplete);</span>

      <span class="s3">if </span><span class="s1">(sourceFiber.tag === ClassComponent) {</span>
        <span class="s3">var </span><span class="s1">currentSourceFiber = sourceFiber.alternate;</span>

        <span class="s3">if </span><span class="s1">(currentSourceFiber === </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s0">// This is a new mount. Change the tag so it's not mistaken for a</span>
          <span class="s0">// completed class component. For example, we should not call</span>
          <span class="s0">// componentWillUnmount if it is deleted.</span>
          <span class="s1">sourceFiber.tag = IncompleteClassComponent;</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s0">// When we try rendering again, we should not reuse the current fiber,</span>
          <span class="s0">// since it's known to be in an inconsistent state. Use a force update to</span>
          <span class="s0">// prevent a bail out.</span>
          <span class="s3">var </span><span class="s1">update = createUpdate(NoTimestamp, SyncLane);</span>
          <span class="s1">update.tag = ForceUpdate;</span>
          <span class="s1">enqueueUpdate(sourceFiber, update, SyncLane);</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s0">// The source fiber did not complete. Mark it with Sync priority to</span>
      <span class="s0">// indicate that it still has pending work.</span>

      <span class="s1">sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane);</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">suspenseBoundary;</span>
  <span class="s1">} </span><span class="s0">// Confirmed that the boundary is in a concurrent mode tree. Continue</span>
  <span class="s0">// with the normal suspend path.</span>
  <span class="s0">//</span>
  <span class="s0">// After this we'll use a set of heuristics to determine whether this</span>
  <span class="s0">// render pass will run to completion or restart or &quot;suspend&quot; the commit.</span>
  <span class="s0">// The actual logic for this is spread out in different places.</span>
  <span class="s0">//</span>
  <span class="s0">// This first principle is that if we're going to suspend when we complete</span>
  <span class="s0">// a root, then we should also restart if we get an update or ping that</span>
  <span class="s0">// might unsuspend it, and vice versa. The only reason to suspend is</span>
  <span class="s0">// because you think you might want to restart before committing. However,</span>
  <span class="s0">// it doesn't make sense to restart only while in the period we're suspended.</span>
  <span class="s0">//</span>
  <span class="s0">// Restarting too aggressively is also not good because it starves out any</span>
  <span class="s0">// intermediate loading state. So we use heuristics to determine when.</span>
  <span class="s0">// Suspense Heuristics</span>
  <span class="s0">//</span>
  <span class="s0">// If nothing threw a Promise or all the same fallbacks are already showing,</span>
  <span class="s0">// then don't suspend/restart.</span>
  <span class="s0">//</span>
  <span class="s0">// If this is an initial render of a new tree of Suspense boundaries and</span>
  <span class="s0">// those trigger a fallback, then don't suspend/restart. We want to ensure</span>
  <span class="s0">// that we can show the initial loading state as quickly as possible.</span>
  <span class="s0">//</span>
  <span class="s0">// If we hit a &quot;Delayed&quot; case, such as when we'd switch from content back into</span>
  <span class="s0">// a fallback, then we should always suspend/restart. Transitions apply</span>
  <span class="s0">// to this case. If none is defined, JND is used instead.</span>
  <span class="s0">//</span>
  <span class="s0">// If we're already showing a fallback and it gets &quot;retried&quot;, allowing us to show</span>
  <span class="s0">// another level, but there's still an inner boundary that would show a fallback,</span>
  <span class="s0">// then we suspend/restart for 500ms since the last time we showed a fallback</span>
  <span class="s0">// anywhere in the tree. This effectively throttles progressive loading into a</span>
  <span class="s0">// consistent train of commits. This also gives us an opportunity to restart to</span>
  <span class="s0">// get to the completed state slightly earlier.</span>
  <span class="s0">//</span>
  <span class="s0">// If there's ambiguity due to batching it's resolved in preference of:</span>
  <span class="s0">// 1) &quot;delayed&quot;, 2) &quot;initial render&quot;, 3) &quot;retry&quot;.</span>
  <span class="s0">//</span>
  <span class="s0">// We want to ensure that a &quot;busy&quot; state doesn't get force committed. We want to</span>
  <span class="s0">// ensure that new initial loading states can commit as soon as possible.</span>

  <span class="s1">suspenseBoundary.flags |= ShouldCapture; </span><span class="s0">// TODO: I think we can remove this, since we now use `DidCapture` in</span>
  <span class="s0">// the begin phase to prevent an early bailout.</span>

  <span class="s1">suspenseBoundary.lanes = rootRenderLanes;</span>
  <span class="s3">return </span><span class="s1">suspenseBoundary;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">throwException(</span>
  <span class="s1">root,</span>
  <span class="s1">returnFiber,</span>
  <span class="s1">sourceFiber,</span>
  <span class="s1">value,</span>
  <span class="s1">rootRenderLanes</span>
<span class="s1">) {</span>
  <span class="s0">// The source fiber did not complete.</span>
  <span class="s1">sourceFiber.flags |= Incomplete;</span>

  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(isDevToolsPresent) {</span>
      <span class="s0">// If we have pending work still, restore the original updaters</span>
      <span class="s1">restorePendingUpdaters(root, rootRenderLanes);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(</span>
    <span class="s1">value !== </span><span class="s3">null </span><span class="s1">&amp;&amp;</span>
    <span class="s3">typeof </span><span class="s1">value === </span><span class="s2">&quot;object&quot; </span><span class="s1">&amp;&amp;</span>
    <span class="s3">typeof </span><span class="s1">value.then === </span><span class="s2">&quot;function&quot;</span>
  <span class="s1">) {</span>
    <span class="s0">// This is a wakeable. The component suspended.</span>
    <span class="s3">var </span><span class="s1">wakeable = value;</span>
    <span class="s1">resetSuspendedComponent(sourceFiber);</span>

    <span class="s3">var </span><span class="s1">suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);</span>

    <span class="s3">if </span><span class="s1">(suspenseBoundary !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">suspenseBoundary.flags &amp;= ~ForceClientRender;</span>
      <span class="s1">markSuspenseBoundaryShouldCapture(</span>
        <span class="s1">suspenseBoundary,</span>
        <span class="s1">returnFiber,</span>
        <span class="s1">sourceFiber,</span>
        <span class="s1">root,</span>
        <span class="s1">rootRenderLanes</span>
      <span class="s1">); </span><span class="s0">// We only attach ping listeners in concurrent mode. Legacy Suspense always</span>
      <span class="s0">// commits fallbacks synchronously, so there are no pings.</span>

      <span class="s3">if </span><span class="s1">(suspenseBoundary.mode &amp; ConcurrentMode) {</span>
        <span class="s1">attachPingListener(root, wakeable, rootRenderLanes);</span>
      <span class="s1">}</span>

      <span class="s1">attachRetryListener(suspenseBoundary, root, wakeable);</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s0">// No boundary was found. Unless this is a sync update, this is OK.</span>
      <span class="s0">// We can suspend and wait for more data to arrive.</span>
      <span class="s3">if </span><span class="s1">(!includesSyncLane(rootRenderLanes)) {</span>
        <span class="s0">// This is not a sync update. Suspend. Since we're not activating a</span>
        <span class="s0">// Suspense boundary, this will unwind all the way to the root without</span>
        <span class="s0">// performing a second pass to render a fallback. (This is arguably how</span>
        <span class="s0">// refresh transitions should work, too, since we're not going to commit</span>
        <span class="s0">// the fallbacks anyway.)</span>
        <span class="s0">//</span>
        <span class="s0">// This case also applies to initial hydration.</span>
        <span class="s1">attachPingListener(root, wakeable, rootRenderLanes);</span>
        <span class="s1">renderDidSuspendDelayIfPossible();</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// This is a sync/discrete update. We treat this case like an error</span>
      <span class="s0">// because discrete renders are expected to produce a complete tree</span>
      <span class="s0">// synchronously to maintain consistency with external state.</span>

      <span class="s3">var </span><span class="s1">uncaughtSuspenseError = </span><span class="s3">new </span><span class="s1">Error(</span>
        <span class="s2">&quot;A component suspended while responding to synchronous input. This &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;will cause the UI to be replaced with a loading indicator. To &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;fix, updates that suspend should be wrapped &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;with startTransition.&quot;</span>
      <span class="s1">); </span><span class="s0">// If we're outside a transition, fall through to the regular error path.</span>
      <span class="s0">// The error will be caught by the nearest suspense boundary.</span>

      <span class="s1">value = uncaughtSuspenseError;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">value = createCapturedValueAtFiber(value, sourceFiber);</span>
  <span class="s1">renderDidError(value); </span><span class="s0">// We didn't find a boundary that could handle this type of exception. Start</span>
  <span class="s0">// over and traverse parent path again, this time treating the exception</span>
  <span class="s0">// as an error.</span>

  <span class="s3">var </span><span class="s1">workInProgress = returnFiber;</span>

  <span class="s3">do </span><span class="s1">{</span>
    <span class="s3">switch </span><span class="s1">(workInProgress.tag) {</span>
      <span class="s3">case </span><span class="s1">HostRoot: {</span>
        <span class="s3">var </span><span class="s1">_errorInfo = value;</span>
        <span class="s1">workInProgress.flags |= ShouldCapture;</span>
        <span class="s3">var </span><span class="s1">lane = pickArbitraryLane(rootRenderLanes);</span>
        <span class="s1">workInProgress.lanes = mergeLanes(workInProgress.lanes, lane);</span>
        <span class="s3">var </span><span class="s1">update = createRootErrorUpdate(workInProgress, _errorInfo, lane);</span>
        <span class="s1">enqueueCapturedUpdate(workInProgress, update);</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">ClassComponent:</span>
        <span class="s0">// Capture and retry</span>
        <span class="s3">var </span><span class="s1">errorInfo = value;</span>
        <span class="s3">var </span><span class="s1">ctor = workInProgress.type;</span>
        <span class="s3">var </span><span class="s1">instance = workInProgress.stateNode;</span>

        <span class="s3">if </span><span class="s1">(</span>
          <span class="s1">(workInProgress.flags &amp; DidCapture) === NoFlags &amp;&amp;</span>
          <span class="s1">(</span><span class="s3">typeof </span><span class="s1">ctor.getDerivedStateFromError === </span><span class="s2">&quot;function&quot; </span><span class="s1">||</span>
            <span class="s1">(instance !== </span><span class="s3">null </span><span class="s1">&amp;&amp;</span>
              <span class="s3">typeof </span><span class="s1">instance.componentDidCatch === </span><span class="s2">&quot;function&quot; </span><span class="s1">&amp;&amp;</span>
              <span class="s1">!isAlreadyFailedLegacyErrorBoundary(instance)))</span>
        <span class="s1">) {</span>
          <span class="s1">workInProgress.flags |= ShouldCapture;</span>

          <span class="s3">var </span><span class="s1">_lane = pickArbitraryLane(rootRenderLanes);</span>

          <span class="s1">workInProgress.lanes = mergeLanes(workInProgress.lanes, _lane); </span><span class="s0">// Schedule the error boundary to re-render using updated state</span>

          <span class="s3">var </span><span class="s1">_update = createClassErrorUpdate(</span>
            <span class="s1">workInProgress,</span>
            <span class="s1">errorInfo,</span>
            <span class="s1">_lane</span>
          <span class="s1">);</span>

          <span class="s1">enqueueCapturedUpdate(workInProgress, _update);</span>
          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">break</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">workInProgress = workInProgress.</span><span class="s3">return</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s3">while </span><span class="s1">(workInProgress !== </span><span class="s3">null</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">getSuspendedCache() {</span>
  <span class="s1">{</span>
    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s0">// This function is called when a Suspense boundary suspends. It returns the</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;</span>
<span class="s3">var </span><span class="s1">didReceiveUpdate = </span><span class="s3">false</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">didWarnAboutBadClass;</span>
<span class="s3">var </span><span class="s1">didWarnAboutModulePatternComponent;</span>
<span class="s3">var </span><span class="s1">didWarnAboutContextTypeOnFunctionComponent;</span>
<span class="s3">var </span><span class="s1">didWarnAboutGetDerivedStateOnFunctionComponent;</span>
<span class="s3">var </span><span class="s1">didWarnAboutFunctionRefs;</span>
<span class="s3">var </span><span class="s1">didWarnAboutReassigningProps;</span>
<span class="s3">var </span><span class="s1">didWarnAboutRevealOrder;</span>
<span class="s3">var </span><span class="s1">didWarnAboutTailOptions;</span>

<span class="s1">{</span>
  <span class="s1">didWarnAboutBadClass = {};</span>
  <span class="s1">didWarnAboutModulePatternComponent = {};</span>
  <span class="s1">didWarnAboutContextTypeOnFunctionComponent = {};</span>
  <span class="s1">didWarnAboutGetDerivedStateOnFunctionComponent = {};</span>
  <span class="s1">didWarnAboutFunctionRefs = {};</span>
  <span class="s1">didWarnAboutReassigningProps = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s1">didWarnAboutRevealOrder = {};</span>
  <span class="s1">didWarnAboutTailOptions = {};</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">reconcileChildren(current, workInProgress, nextChildren, renderLanes) {</span>
  <span class="s3">if </span><span class="s1">(current === </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s0">// If this is a fresh new component that hasn't been rendered yet, we</span>
    <span class="s0">// won't update its child set by applying minimal side-effects. Instead,</span>
    <span class="s0">// we will add them all to the child before it gets rendered. That means</span>
    <span class="s0">// we can optimize this reconciliation pass by not tracking side-effects.</span>
    <span class="s1">workInProgress.child = mountChildFibers(</span>
      <span class="s1">workInProgress,</span>
      <span class="s3">null</span><span class="s1">,</span>
      <span class="s1">nextChildren,</span>
      <span class="s1">renderLanes</span>
    <span class="s1">);</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s0">// If the current child is the same as the work in progress, it means that</span>
    <span class="s0">// we haven't yet started any work on these children. Therefore, we use</span>
    <span class="s0">// the clone algorithm to create a copy of all the current children.</span>
    <span class="s0">// If we had any progressed work already, that is invalid at this point so</span>
    <span class="s0">// let's throw it out.</span>
    <span class="s1">workInProgress.child = reconcileChildFibers(</span>
      <span class="s1">workInProgress,</span>
      <span class="s1">current.child,</span>
      <span class="s1">nextChildren,</span>
      <span class="s1">renderLanes</span>
    <span class="s1">);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">forceUnmountCurrentAndReconcile(</span>
  <span class="s1">current,</span>
  <span class="s1">workInProgress,</span>
  <span class="s1">nextChildren,</span>
  <span class="s1">renderLanes</span>
<span class="s1">) {</span>
  <span class="s0">// This function is fork of reconcileChildren. It's used in cases where we</span>
  <span class="s0">// want to reconcile without matching against the existing set. This has the</span>
  <span class="s0">// effect of all current children being unmounted; even if the type and key</span>
  <span class="s0">// are the same, the old child is unmounted and a new child is created.</span>
  <span class="s0">//</span>
  <span class="s0">// To do this, we're going to go through the reconcile algorithm twice. In</span>
  <span class="s0">// the first pass, we schedule a deletion for all the current children by</span>
  <span class="s0">// passing null.</span>
  <span class="s1">workInProgress.child = reconcileChildFibers(</span>
    <span class="s1">workInProgress,</span>
    <span class="s1">current.child,</span>
    <span class="s3">null</span><span class="s1">,</span>
    <span class="s1">renderLanes</span>
  <span class="s1">); </span><span class="s0">// In the second pass, we mount the new children. The trick here is that we</span>
  <span class="s0">// pass null in place of where we usually pass the current child set. This has</span>
  <span class="s0">// the effect of remounting all children regardless of whether their</span>
  <span class="s0">// identities match.</span>

  <span class="s1">workInProgress.child = reconcileChildFibers(</span>
    <span class="s1">workInProgress,</span>
    <span class="s3">null</span><span class="s1">,</span>
    <span class="s1">nextChildren,</span>
    <span class="s1">renderLanes</span>
  <span class="s1">);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">updateForwardRef(</span>
  <span class="s1">current,</span>
  <span class="s1">workInProgress,</span>
  <span class="s1">Component,</span>
  <span class="s1">nextProps,</span>
  <span class="s1">renderLanes</span>
<span class="s1">) {</span>
  <span class="s0">// TODO: current can be non-null here even if the component</span>
  <span class="s0">// hasn't yet mounted. This happens after the first render suspends.</span>
  <span class="s0">// We'll need to figure out if this is fine or can cause issues.</span>
  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(workInProgress.type !== workInProgress.elementType) {</span>
      <span class="s0">// Lazy component props can't be validated in createElement</span>
      <span class="s0">// because they're only guaranteed to be resolved here.</span>
      <span class="s3">var </span><span class="s1">innerPropTypes = Component.propTypes;</span>

      <span class="s3">if </span><span class="s1">(innerPropTypes) {</span>
        <span class="s1">checkPropTypes(</span>
          <span class="s1">innerPropTypes,</span>
          <span class="s1">nextProps, </span><span class="s0">// Resolved props</span>
          <span class="s2">&quot;prop&quot;</span><span class="s1">,</span>
          <span class="s1">getComponentNameFromType(Component)</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">render = Component.render;</span>
  <span class="s3">var </span><span class="s1">ref = workInProgress.ref; </span><span class="s0">// The rest is a fork of updateFunctionComponent</span>

  <span class="s3">var </span><span class="s1">nextChildren;</span>
  <span class="s1">prepareToReadContext(workInProgress, renderLanes);</span>

  <span class="s1">{</span>
    <span class="s1">ReactCurrentOwner$1.current = workInProgress;</span>
    <span class="s1">setIsRendering(</span><span class="s3">true</span><span class="s1">);</span>
    <span class="s1">nextChildren = renderWithHooks(</span>
      <span class="s1">current,</span>
      <span class="s1">workInProgress,</span>
      <span class="s1">render,</span>
      <span class="s1">nextProps,</span>
      <span class="s1">ref,</span>
      <span class="s1">renderLanes</span>
    <span class="s1">);</span>

    <span class="s1">setIsRendering(</span><span class="s3">false</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(current !== </span><span class="s3">null </span><span class="s1">&amp;&amp; !didReceiveUpdate) {</span>
    <span class="s1">bailoutHooks(current, workInProgress, renderLanes);</span>
    <span class="s3">return </span><span class="s1">bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);</span>
  <span class="s1">}</span>

  <span class="s1">workInProgress.flags |= PerformedWork;</span>
  <span class="s1">reconcileChildren(current, workInProgress, nextChildren, renderLanes);</span>
  <span class="s3">return </span><span class="s1">workInProgress.child;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">updateMemoComponent(</span>
  <span class="s1">current,</span>
  <span class="s1">workInProgress,</span>
  <span class="s1">Component,</span>
  <span class="s1">nextProps,</span>
  <span class="s1">renderLanes</span>
<span class="s1">) {</span>
  <span class="s3">if </span><span class="s1">(current === </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">type = Component.type;</span>

    <span class="s3">if </span><span class="s1">(</span>
      <span class="s1">isSimpleFunctionComponent(type) &amp;&amp;</span>
      <span class="s1">Component.compare === </span><span class="s3">null </span><span class="s1">&amp;&amp; </span><span class="s0">// SimpleMemoComponent codepath doesn't resolve outer props either.</span>
      <span class="s1">Component.defaultProps === undefined</span>
    <span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">resolvedType = type;</span>

      <span class="s1">{</span>
        <span class="s1">resolvedType = resolveFunctionForHotReloading(type);</span>
      <span class="s1">} </span><span class="s0">// If this is a plain function component without default props,</span>
      <span class="s0">// and with only the default shallow comparison, we upgrade it</span>
      <span class="s0">// to a SimpleMemoComponent to allow fast path updates.</span>

      <span class="s1">workInProgress.tag = SimpleMemoComponent;</span>
      <span class="s1">workInProgress.type = resolvedType;</span>

      <span class="s1">{</span>
        <span class="s1">validateFunctionComponentInDev(workInProgress, type);</span>
      <span class="s1">}</span>

      <span class="s3">return </span><span class="s1">updateSimpleMemoComponent(</span>
        <span class="s1">current,</span>
        <span class="s1">workInProgress,</span>
        <span class="s1">resolvedType,</span>
        <span class="s1">nextProps,</span>
        <span class="s1">renderLanes</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s3">var </span><span class="s1">innerPropTypes = type.propTypes;</span>

      <span class="s3">if </span><span class="s1">(innerPropTypes) {</span>
        <span class="s0">// Inner memo component props aren't currently validated in createElement.</span>
        <span class="s0">// We could move it there, but we'd still need this for lazy code path.</span>
        <span class="s1">checkPropTypes(</span>
          <span class="s1">innerPropTypes,</span>
          <span class="s1">nextProps, </span><span class="s0">// Resolved props</span>
          <span class="s2">&quot;prop&quot;</span><span class="s1">,</span>
          <span class="s1">getComponentNameFromType(type)</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">child = createFiberFromTypeAndProps(</span>
      <span class="s1">Component.type,</span>
      <span class="s3">null</span><span class="s1">,</span>
      <span class="s1">nextProps,</span>
      <span class="s1">workInProgress,</span>
      <span class="s1">workInProgress.mode,</span>
      <span class="s1">renderLanes</span>
    <span class="s1">);</span>
    <span class="s1">child.ref = workInProgress.ref;</span>
    <span class="s1">child.</span><span class="s3">return </span><span class="s1">= workInProgress;</span>
    <span class="s1">workInProgress.child = child;</span>
    <span class="s3">return </span><span class="s1">child;</span>
  <span class="s1">}</span>

  <span class="s1">{</span>
    <span class="s3">var </span><span class="s1">_type = Component.type;</span>
    <span class="s3">var </span><span class="s1">_innerPropTypes = _type.propTypes;</span>

    <span class="s3">if </span><span class="s1">(_innerPropTypes) {</span>
      <span class="s0">// Inner memo component props aren't currently validated in createElement.</span>
      <span class="s0">// We could move it there, but we'd still need this for lazy code path.</span>
      <span class="s1">checkPropTypes(</span>
        <span class="s1">_innerPropTypes,</span>
        <span class="s1">nextProps, </span><span class="s0">// Resolved props</span>
        <span class="s2">&quot;prop&quot;</span><span class="s1">,</span>
        <span class="s1">getComponentNameFromType(_type)</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">currentChild = current.child; </span><span class="s0">// This is always exactly one child</span>

  <span class="s3">var </span><span class="s1">hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(</span>
    <span class="s1">current,</span>
    <span class="s1">renderLanes</span>
  <span class="s1">);</span>

  <span class="s3">if </span><span class="s1">(!hasScheduledUpdateOrContext) {</span>
    <span class="s0">// This will be the props with resolved defaultProps,</span>
    <span class="s0">// unlike current.memoizedProps which will be the unresolved ones.</span>
    <span class="s3">var </span><span class="s1">prevProps = currentChild.memoizedProps; </span><span class="s0">// Default to shallow comparison</span>

    <span class="s3">var </span><span class="s1">compare = Component.compare;</span>
    <span class="s1">compare = compare !== </span><span class="s3">null </span><span class="s1">? compare : shallowEqual;</span>

    <span class="s3">if </span><span class="s1">(compare(prevProps, nextProps) &amp;&amp; current.ref === workInProgress.ref) {</span>
      <span class="s3">return </span><span class="s1">bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s0">// React DevTools reads this flag.</span>

  <span class="s1">workInProgress.flags |= PerformedWork;</span>
  <span class="s3">var </span><span class="s1">newChild = createWorkInProgress(currentChild, nextProps);</span>
  <span class="s1">newChild.ref = workInProgress.ref;</span>
  <span class="s1">newChild.</span><span class="s3">return </span><span class="s1">= workInProgress;</span>
  <span class="s1">workInProgress.child = newChild;</span>
  <span class="s3">return </span><span class="s1">newChild;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">updateSimpleMemoComponent(</span>
  <span class="s1">current,</span>
  <span class="s1">workInProgress,</span>
  <span class="s1">Component,</span>
  <span class="s1">nextProps,</span>
  <span class="s1">renderLanes</span>
<span class="s1">) {</span>
  <span class="s0">// TODO: current can be non-null here even if the component</span>
  <span class="s0">// hasn't yet mounted. This happens when the inner render suspends.</span>
  <span class="s0">// We'll need to figure out if this is fine or can cause issues.</span>
  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(workInProgress.type !== workInProgress.elementType) {</span>
      <span class="s0">// Lazy component props can't be validated in createElement</span>
      <span class="s0">// because they're only guaranteed to be resolved here.</span>
      <span class="s3">var </span><span class="s1">outerMemoType = workInProgress.elementType;</span>

      <span class="s3">if </span><span class="s1">(outerMemoType.$$typeof === REACT_LAZY_TYPE) {</span>
        <span class="s0">// We warn when you define propTypes on lazy()</span>
        <span class="s0">// so let's just skip over it to find memo() outer wrapper.</span>
        <span class="s0">// Inner props for memo are validated later.</span>
        <span class="s3">var </span><span class="s1">lazyComponent = outerMemoType;</span>
        <span class="s3">var </span><span class="s1">payload = lazyComponent._payload;</span>
        <span class="s3">var </span><span class="s1">init = lazyComponent._init;</span>

        <span class="s3">try </span><span class="s1">{</span>
          <span class="s1">outerMemoType = init(payload);</span>
        <span class="s1">} </span><span class="s3">catch </span><span class="s1">(x) {</span>
          <span class="s1">outerMemoType = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s0">// Inner propTypes will be validated in the function component path.</span>

        <span class="s3">var </span><span class="s1">outerPropTypes = outerMemoType &amp;&amp; outerMemoType.propTypes;</span>

        <span class="s3">if </span><span class="s1">(outerPropTypes) {</span>
          <span class="s1">checkPropTypes(</span>
            <span class="s1">outerPropTypes,</span>
            <span class="s1">nextProps, </span><span class="s0">// Resolved (SimpleMemoComponent has no defaultProps)</span>
            <span class="s2">&quot;prop&quot;</span><span class="s1">,</span>
            <span class="s1">getComponentNameFromType(outerMemoType)</span>
          <span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(current !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">prevProps = current.memoizedProps;</span>

    <span class="s3">if </span><span class="s1">(</span>
      <span class="s1">shallowEqual(prevProps, nextProps) &amp;&amp;</span>
      <span class="s1">current.ref === workInProgress.ref &amp;&amp; </span><span class="s0">// Prevent bailout if the implementation changed due to hot reload.</span>
      <span class="s1">workInProgress.type === current.type</span>
    <span class="s1">) {</span>
      <span class="s1">didReceiveUpdate = </span><span class="s3">false</span><span class="s1">; </span><span class="s0">// The props are shallowly equal. Reuse the previous props object, like we</span>
      <span class="s0">// would during a normal fiber bailout.</span>
      <span class="s0">//</span>
      <span class="s0">// We don't have strong guarantees that the props object is referentially</span>
      <span class="s0">// equal during updates where we can't bail out anyway  like if the props</span>
      <span class="s0">// are shallowly equal, but there's a local state or context update in the</span>
      <span class="s0">// same batch.</span>
      <span class="s0">//</span>
      <span class="s0">// However, as a principle, we should aim to make the behavior consistent</span>
      <span class="s0">// across different ways of memoizing a component. For example, React.memo</span>
      <span class="s0">// has a different internal Fiber layout if you pass a normal function</span>
      <span class="s0">// component (SimpleMemoComponent) versus if you pass a different type</span>
      <span class="s0">// like forwardRef (MemoComponent). But this is an implementation detail.</span>
      <span class="s0">// Wrapping a component in forwardRef (or React.lazy, etc) shouldn't</span>
      <span class="s0">// affect whether the props object is reused during a bailout.</span>

      <span class="s1">workInProgress.pendingProps = nextProps = prevProps;</span>

      <span class="s3">if </span><span class="s1">(!checkScheduledUpdateOrContext(current, renderLanes)) {</span>
        <span class="s0">// The pending lanes were cleared at the beginning of beginWork. We're</span>
        <span class="s0">// about to bail out, but there might be other lanes that weren't</span>
        <span class="s0">// included in the current render. Usually, the priority level of the</span>
        <span class="s0">// remaining updates is accumulated during the evaluation of the</span>
        <span class="s0">// component (i.e. when processing the update queue). But since since</span>
        <span class="s0">// we're bailing out early *without* evaluating the component, we need</span>
        <span class="s0">// to account for it here, too. Reset to the value of the current fiber.</span>
        <span class="s0">// NOTE: This only applies to SimpleMemoComponent, not MemoComponent,</span>
        <span class="s0">// because a MemoComponent fiber does not have hooks or an update queue;</span>
        <span class="s0">// rather, it wraps around an inner component, which may or may not</span>
        <span class="s0">// contains hooks.</span>
        <span class="s0">// TODO: Move the reset at in beginWork out of the common path so that</span>
        <span class="s0">// this is no longer necessary.</span>
        <span class="s1">workInProgress.lanes = current.lanes;</span>
        <span class="s3">return </span><span class="s1">bailoutOnAlreadyFinishedWork(</span>
          <span class="s1">current,</span>
          <span class="s1">workInProgress,</span>
          <span class="s1">renderLanes</span>
        <span class="s1">);</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">((current.flags &amp; ForceUpdateForLegacySuspense) !== NoFlags) {</span>
        <span class="s0">// This is a special case that only exists for legacy mode.</span>
        <span class="s0">// See https://github.com/facebook/react/pull/19216.</span>
        <span class="s1">didReceiveUpdate = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">updateFunctionComponent(</span>
    <span class="s1">current,</span>
    <span class="s1">workInProgress,</span>
    <span class="s1">Component,</span>
    <span class="s1">nextProps,</span>
    <span class="s1">renderLanes</span>
  <span class="s1">);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">updateOffscreenComponent(current, workInProgress, renderLanes) {</span>
  <span class="s3">var </span><span class="s1">nextProps = workInProgress.pendingProps;</span>
  <span class="s3">var </span><span class="s1">nextChildren = nextProps.children;</span>
  <span class="s3">var </span><span class="s1">prevState = current !== </span><span class="s3">null </span><span class="s1">? current.memoizedState : </span><span class="s3">null</span><span class="s1">;</span>

  <span class="s3">if </span><span class="s1">(nextProps.mode === </span><span class="s2">&quot;hidden&quot; </span><span class="s1">|| enableLegacyHidden) {</span>
    <span class="s0">// Rendering a hidden tree.</span>
    <span class="s3">if </span><span class="s1">((workInProgress.mode &amp; ConcurrentMode) === NoMode) {</span>
      <span class="s0">// In legacy sync mode, don't defer the subtree. Render it now.</span>
      <span class="s0">// TODO: Consider how Offscreen should work with transitions in the future</span>
      <span class="s3">var </span><span class="s1">nextState = {</span>
        <span class="s1">baseLanes: NoLanes,</span>
        <span class="s1">cachePool: </span><span class="s3">null</span><span class="s1">,</span>
        <span class="s1">transitions: </span><span class="s3">null</span>
      <span class="s1">};</span>
      <span class="s1">workInProgress.memoizedState = nextState;</span>

      <span class="s1">pushRenderLanes(workInProgress, renderLanes);</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(!includesSomeLane(renderLanes, OffscreenLane)) {</span>
      <span class="s3">var </span><span class="s1">spawnedCachePool = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// We're hidden, and we're not rendering at Offscreen. We will bail out</span>
      <span class="s0">// and resume this tree later.</span>

      <span class="s3">var </span><span class="s1">nextBaseLanes;</span>

      <span class="s3">if </span><span class="s1">(prevState !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">prevBaseLanes = prevState.baseLanes;</span>
        <span class="s1">nextBaseLanes = mergeLanes(prevBaseLanes, renderLanes);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">nextBaseLanes = renderLanes;</span>
      <span class="s1">} </span><span class="s0">// Schedule this fiber to re-render at offscreen priority. Then bailout.</span>

      <span class="s1">workInProgress.lanes = workInProgress.childLanes = laneToLanes(</span>
        <span class="s1">OffscreenLane</span>
      <span class="s1">);</span>
      <span class="s3">var </span><span class="s1">_nextState = {</span>
        <span class="s1">baseLanes: nextBaseLanes,</span>
        <span class="s1">cachePool: spawnedCachePool,</span>
        <span class="s1">transitions: </span><span class="s3">null</span>
      <span class="s1">};</span>
      <span class="s1">workInProgress.memoizedState = _nextState;</span>
      <span class="s1">workInProgress.updateQueue = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s0">// to avoid a push/pop misalignment.</span>

      <span class="s1">pushRenderLanes(workInProgress, nextBaseLanes);</span>

      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s0">// This is the second render. The surrounding visible content has already</span>
      <span class="s0">// committed. Now we resume rendering the hidden tree.</span>
      <span class="s0">// Rendering at offscreen, so we can clear the base lanes.</span>
      <span class="s3">var </span><span class="s1">_nextState2 = {</span>
        <span class="s1">baseLanes: NoLanes,</span>
        <span class="s1">cachePool: </span><span class="s3">null</span><span class="s1">,</span>
        <span class="s1">transitions: </span><span class="s3">null</span>
      <span class="s1">};</span>
      <span class="s1">workInProgress.memoizedState = _nextState2; </span><span class="s0">// Push the lanes that were skipped when we bailed out.</span>

      <span class="s3">var </span><span class="s1">subtreeRenderLanes =</span>
        <span class="s1">prevState !== </span><span class="s3">null </span><span class="s1">? prevState.baseLanes : renderLanes;</span>

      <span class="s1">pushRenderLanes(workInProgress, subtreeRenderLanes);</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s0">// Rendering a visible tree.</span>
    <span class="s3">var </span><span class="s1">_subtreeRenderLanes;</span>

    <span class="s3">if </span><span class="s1">(prevState !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// We're going from hidden -&gt; visible.</span>
      <span class="s1">_subtreeRenderLanes = mergeLanes(prevState.baseLanes, renderLanes);</span>

      <span class="s1">workInProgress.memoizedState = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s0">// We weren't previously hidden, and we still aren't, so there's nothing</span>
      <span class="s0">// special to do. Need to push to the stack regardless, though, to avoid</span>
      <span class="s0">// a push/pop misalignment.</span>
      <span class="s1">_subtreeRenderLanes = renderLanes;</span>
    <span class="s1">}</span>

    <span class="s1">pushRenderLanes(workInProgress, _subtreeRenderLanes);</span>
  <span class="s1">}</span>

  <span class="s1">reconcileChildren(current, workInProgress, nextChildren, renderLanes);</span>
  <span class="s3">return </span><span class="s1">workInProgress.child;</span>
<span class="s1">} </span><span class="s0">// Note: These happen to have identical begin phases, for now. We shouldn't hold</span>

<span class="s3">function </span><span class="s1">updateFragment(current, workInProgress, renderLanes) {</span>
  <span class="s3">var </span><span class="s1">nextChildren = workInProgress.pendingProps;</span>
  <span class="s1">reconcileChildren(current, workInProgress, nextChildren, renderLanes);</span>
  <span class="s3">return </span><span class="s1">workInProgress.child;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">updateMode(current, workInProgress, renderLanes) {</span>
  <span class="s3">var </span><span class="s1">nextChildren = workInProgress.pendingProps.children;</span>
  <span class="s1">reconcileChildren(current, workInProgress, nextChildren, renderLanes);</span>
  <span class="s3">return </span><span class="s1">workInProgress.child;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">updateProfiler(current, workInProgress, renderLanes) {</span>
  <span class="s1">{</span>
    <span class="s1">workInProgress.flags |= Update;</span>

    <span class="s1">{</span>
      <span class="s0">// Reset effect durations for the next eventual effect phase.</span>
      <span class="s0">// These are reset during render to allow the DevTools commit hook a chance to read them,</span>
      <span class="s3">var </span><span class="s1">stateNode = workInProgress.stateNode;</span>
      <span class="s1">stateNode.effectDuration = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s1">stateNode.passiveEffectDuration = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">nextProps = workInProgress.pendingProps;</span>
  <span class="s3">var </span><span class="s1">nextChildren = nextProps.children;</span>
  <span class="s1">reconcileChildren(current, workInProgress, nextChildren, renderLanes);</span>
  <span class="s3">return </span><span class="s1">workInProgress.child;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">markRef(current, workInProgress) {</span>
  <span class="s3">var </span><span class="s1">ref = workInProgress.ref;</span>

  <span class="s3">if </span><span class="s1">(</span>
    <span class="s1">(current === </span><span class="s3">null </span><span class="s1">&amp;&amp; ref !== </span><span class="s3">null</span><span class="s1">) ||</span>
    <span class="s1">(current !== </span><span class="s3">null </span><span class="s1">&amp;&amp; current.ref !== ref)</span>
  <span class="s1">) {</span>
    <span class="s0">// Schedule a Ref effect</span>
    <span class="s1">workInProgress.flags |= Ref;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">updateFunctionComponent(</span>
  <span class="s1">current,</span>
  <span class="s1">workInProgress,</span>
  <span class="s1">Component,</span>
  <span class="s1">nextProps,</span>
  <span class="s1">renderLanes</span>
<span class="s1">) {</span>
  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(workInProgress.type !== workInProgress.elementType) {</span>
      <span class="s0">// Lazy component props can't be validated in createElement</span>
      <span class="s0">// because they're only guaranteed to be resolved here.</span>
      <span class="s3">var </span><span class="s1">innerPropTypes = Component.propTypes;</span>

      <span class="s3">if </span><span class="s1">(innerPropTypes) {</span>
        <span class="s1">checkPropTypes(</span>
          <span class="s1">innerPropTypes,</span>
          <span class="s1">nextProps, </span><span class="s0">// Resolved props</span>
          <span class="s2">&quot;prop&quot;</span><span class="s1">,</span>
          <span class="s1">getComponentNameFromType(Component)</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">context;</span>

  <span class="s1">{</span>
    <span class="s3">var </span><span class="s1">unmaskedContext = getUnmaskedContext(workInProgress, Component, </span><span class="s3">true</span><span class="s1">);</span>
    <span class="s1">context = getMaskedContext(workInProgress, unmaskedContext);</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">nextChildren;</span>
  <span class="s1">prepareToReadContext(workInProgress, renderLanes);</span>

  <span class="s1">{</span>
    <span class="s1">ReactCurrentOwner$1.current = workInProgress;</span>
    <span class="s1">setIsRendering(</span><span class="s3">true</span><span class="s1">);</span>
    <span class="s1">nextChildren = renderWithHooks(</span>
      <span class="s1">current,</span>
      <span class="s1">workInProgress,</span>
      <span class="s1">Component,</span>
      <span class="s1">nextProps,</span>
      <span class="s1">context,</span>
      <span class="s1">renderLanes</span>
    <span class="s1">);</span>

    <span class="s1">setIsRendering(</span><span class="s3">false</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(current !== </span><span class="s3">null </span><span class="s1">&amp;&amp; !didReceiveUpdate) {</span>
    <span class="s1">bailoutHooks(current, workInProgress, renderLanes);</span>
    <span class="s3">return </span><span class="s1">bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);</span>
  <span class="s1">}</span>

  <span class="s1">workInProgress.flags |= PerformedWork;</span>
  <span class="s1">reconcileChildren(current, workInProgress, nextChildren, renderLanes);</span>
  <span class="s3">return </span><span class="s1">workInProgress.child;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">updateClassComponent(</span>
  <span class="s1">current,</span>
  <span class="s1">workInProgress,</span>
  <span class="s1">Component,</span>
  <span class="s1">nextProps,</span>
  <span class="s1">renderLanes</span>
<span class="s1">) {</span>
  <span class="s1">{</span>
    <span class="s0">// This is used by DevTools to force a boundary to error.</span>
    <span class="s3">switch </span><span class="s1">(shouldError(workInProgress)) {</span>
      <span class="s3">case false</span><span class="s1">: {</span>
        <span class="s3">var </span><span class="s1">_instance = workInProgress.stateNode;</span>
        <span class="s3">var </span><span class="s1">ctor = workInProgress.type; </span><span class="s0">// TODO This way of resetting the error boundary state is a hack.</span>
        <span class="s0">// Is there a better way to do this?</span>

        <span class="s3">var </span><span class="s1">tempInstance = </span><span class="s3">new </span><span class="s1">ctor(</span>
          <span class="s1">workInProgress.memoizedProps,</span>
          <span class="s1">_instance.context</span>
        <span class="s1">);</span>
        <span class="s3">var </span><span class="s1">state = tempInstance.state;</span>

        <span class="s1">_instance.updater.enqueueSetState(_instance, state, </span><span class="s3">null</span><span class="s1">);</span>

        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">case true</span><span class="s1">: {</span>
        <span class="s1">workInProgress.flags |= DidCapture;</span>
        <span class="s1">workInProgress.flags |= ShouldCapture; </span><span class="s0">// eslint-disable-next-line react-internal/prod-error-codes</span>

        <span class="s3">var </span><span class="s1">error$1 = </span><span class="s3">new </span><span class="s1">Error(</span><span class="s2">&quot;Simulated error coming from DevTools&quot;</span><span class="s1">);</span>
        <span class="s3">var </span><span class="s1">lane = pickArbitraryLane(renderLanes);</span>
        <span class="s1">workInProgress.lanes = mergeLanes(workInProgress.lanes, lane); </span><span class="s0">// Schedule the error boundary to re-render using updated state</span>

        <span class="s3">var </span><span class="s1">update = createClassErrorUpdate(</span>
          <span class="s1">workInProgress,</span>
          <span class="s1">createCapturedValueAtFiber(error$1, workInProgress),</span>
          <span class="s1">lane</span>
        <span class="s1">);</span>
        <span class="s1">enqueueCapturedUpdate(workInProgress, update);</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(workInProgress.type !== workInProgress.elementType) {</span>
      <span class="s0">// Lazy component props can't be validated in createElement</span>
      <span class="s0">// because they're only guaranteed to be resolved here.</span>
      <span class="s3">var </span><span class="s1">innerPropTypes = Component.propTypes;</span>

      <span class="s3">if </span><span class="s1">(innerPropTypes) {</span>
        <span class="s1">checkPropTypes(</span>
          <span class="s1">innerPropTypes,</span>
          <span class="s1">nextProps, </span><span class="s0">// Resolved props</span>
          <span class="s2">&quot;prop&quot;</span><span class="s1">,</span>
          <span class="s1">getComponentNameFromType(Component)</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s0">// Push context providers early to prevent context stack mismatches.</span>
  <span class="s0">// During mounting we don't know the child context yet as the instance doesn't exist.</span>
  <span class="s0">// We will invalidate the child context in finishClassComponent() right after rendering.</span>

  <span class="s3">var </span><span class="s1">hasContext;</span>

  <span class="s3">if </span><span class="s1">(isContextProvider(Component)) {</span>
    <span class="s1">hasContext = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">pushContextProvider(workInProgress);</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">hasContext = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s1">prepareToReadContext(workInProgress, renderLanes);</span>
  <span class="s3">var </span><span class="s1">instance = workInProgress.stateNode;</span>
  <span class="s3">var </span><span class="s1">shouldUpdate;</span>

  <span class="s3">if </span><span class="s1">(instance === </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s1">resetSuspendedCurrentOnMountInLegacyMode(current, workInProgress); </span><span class="s0">// In the initial pass we might need to construct the instance.</span>

    <span class="s1">constructClassInstance(workInProgress, Component, nextProps);</span>
    <span class="s1">mountClassInstance(workInProgress, Component, nextProps, renderLanes);</span>
    <span class="s1">shouldUpdate = </span><span class="s3">true</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(current === </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s0">// In a resume, we'll already have an instance we can reuse.</span>
    <span class="s1">shouldUpdate = resumeMountClassInstance(</span>
      <span class="s1">workInProgress,</span>
      <span class="s1">Component,</span>
      <span class="s1">nextProps,</span>
      <span class="s1">renderLanes</span>
    <span class="s1">);</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">shouldUpdate = updateClassInstance(</span>
      <span class="s1">current,</span>
      <span class="s1">workInProgress,</span>
      <span class="s1">Component,</span>
      <span class="s1">nextProps,</span>
      <span class="s1">renderLanes</span>
    <span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">nextUnitOfWork = finishClassComponent(</span>
    <span class="s1">current,</span>
    <span class="s1">workInProgress,</span>
    <span class="s1">Component,</span>
    <span class="s1">shouldUpdate,</span>
    <span class="s1">hasContext,</span>
    <span class="s1">renderLanes</span>
  <span class="s1">);</span>

  <span class="s1">{</span>
    <span class="s3">var </span><span class="s1">inst = workInProgress.stateNode;</span>

    <span class="s3">if </span><span class="s1">(shouldUpdate &amp;&amp; inst.props !== nextProps) {</span>
      <span class="s3">if </span><span class="s1">(!didWarnAboutReassigningProps) {</span>
        <span class="s1">error(</span>
          <span class="s2">&quot;It looks like %s is reassigning its own `this.props` while rendering. &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;This is not supported and can lead to confusing bugs.&quot;</span><span class="s1">,</span>
          <span class="s1">getComponentNameFromFiber(workInProgress) || </span><span class="s2">&quot;a component&quot;</span>
        <span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s1">didWarnAboutReassigningProps = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">nextUnitOfWork;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">finishClassComponent(</span>
  <span class="s1">current,</span>
  <span class="s1">workInProgress,</span>
  <span class="s1">Component,</span>
  <span class="s1">shouldUpdate,</span>
  <span class="s1">hasContext,</span>
  <span class="s1">renderLanes</span>
<span class="s1">) {</span>
  <span class="s0">// Refs should update even if shouldComponentUpdate returns false</span>
  <span class="s1">markRef(current, workInProgress);</span>
  <span class="s3">var </span><span class="s1">didCaptureError = (workInProgress.flags &amp; DidCapture) !== NoFlags;</span>

  <span class="s3">if </span><span class="s1">(!shouldUpdate &amp;&amp; !didCaptureError) {</span>
    <span class="s0">// Context providers should defer to sCU for rendering</span>
    <span class="s3">if </span><span class="s1">(hasContext) {</span>
      <span class="s1">invalidateContextProvider(workInProgress, Component, </span><span class="s3">false</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">instance = workInProgress.stateNode; </span><span class="s0">// Rerender</span>

  <span class="s1">ReactCurrentOwner$1.current = workInProgress;</span>
  <span class="s3">var </span><span class="s1">nextChildren;</span>

  <span class="s3">if </span><span class="s1">(</span>
    <span class="s1">didCaptureError &amp;&amp;</span>
    <span class="s3">typeof </span><span class="s1">Component.getDerivedStateFromError !== </span><span class="s2">&quot;function&quot;</span>
  <span class="s1">) {</span>
    <span class="s0">// If we captured an error, but getDerivedStateFromError is not defined,</span>
    <span class="s0">// unmount all the children. componentDidCatch will schedule an update to</span>
    <span class="s0">// re-render a fallback. This is temporary until we migrate everyone to</span>
    <span class="s0">// the new API.</span>
    <span class="s0">// TODO: Warn in a future release.</span>
    <span class="s1">nextChildren = </span><span class="s3">null</span><span class="s1">;</span>

    <span class="s1">{</span>
      <span class="s1">stopProfilerTimerIfRunning();</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">{</span>
      <span class="s1">setIsRendering(</span><span class="s3">true</span><span class="s1">);</span>
      <span class="s1">nextChildren = instance.render();</span>

      <span class="s1">setIsRendering(</span><span class="s3">false</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s0">// React DevTools reads this flag.</span>

  <span class="s1">workInProgress.flags |= PerformedWork;</span>

  <span class="s3">if </span><span class="s1">(current !== </span><span class="s3">null </span><span class="s1">&amp;&amp; didCaptureError) {</span>
    <span class="s0">// If we're recovering from an error, reconcile without reusing any of</span>
    <span class="s0">// the existing children. Conceptually, the normal children and the children</span>
    <span class="s0">// that are shown on error are two different sets, so we shouldn't reuse</span>
    <span class="s0">// normal children even if their identities match.</span>
    <span class="s1">forceUnmountCurrentAndReconcile(</span>
      <span class="s1">current,</span>
      <span class="s1">workInProgress,</span>
      <span class="s1">nextChildren,</span>
      <span class="s1">renderLanes</span>
    <span class="s1">);</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">reconcileChildren(current, workInProgress, nextChildren, renderLanes);</span>
  <span class="s1">} </span><span class="s0">// Memoize state using the values we just used to render.</span>
  <span class="s0">// TODO: Restructure so we never read values from the instance.</span>

  <span class="s1">workInProgress.memoizedState = instance.state; </span><span class="s0">// The context might have changed so we need to recalculate it.</span>

  <span class="s3">if </span><span class="s1">(hasContext) {</span>
    <span class="s1">invalidateContextProvider(workInProgress, Component, </span><span class="s3">true</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">workInProgress.child;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">pushHostRootContext(workInProgress) {</span>
  <span class="s3">var </span><span class="s1">root = workInProgress.stateNode;</span>

  <span class="s3">if </span><span class="s1">(root.pendingContext) {</span>
    <span class="s1">pushTopLevelContextObject(</span>
      <span class="s1">workInProgress,</span>
      <span class="s1">root.pendingContext,</span>
      <span class="s1">root.pendingContext !== root.context</span>
    <span class="s1">);</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(root.context) {</span>
    <span class="s0">// Should always be set</span>
    <span class="s1">pushTopLevelContextObject(workInProgress, root.context, </span><span class="s3">false</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s1">pushHostContainer(workInProgress, root.containerInfo);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">updateHostRoot(current, workInProgress, renderLanes) {</span>
  <span class="s1">pushHostRootContext(workInProgress);</span>

  <span class="s3">if </span><span class="s1">(current === </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Should have a current fiber. This is a bug in React.&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">nextProps = workInProgress.pendingProps;</span>
  <span class="s3">var </span><span class="s1">prevState = workInProgress.memoizedState;</span>
  <span class="s3">var </span><span class="s1">prevChildren = prevState.element;</span>
  <span class="s1">cloneUpdateQueue(current, workInProgress);</span>
  <span class="s1">processUpdateQueue(workInProgress, nextProps, </span><span class="s3">null</span><span class="s1">, renderLanes);</span>
  <span class="s3">var </span><span class="s1">nextState = workInProgress.memoizedState;</span>
  <span class="s3">var </span><span class="s1">root = workInProgress.stateNode;</span>
  <span class="s0">// being called &quot;element&quot;.</span>

  <span class="s3">var </span><span class="s1">nextChildren = nextState.element;</span>

  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(nextChildren === prevChildren) {</span>
      <span class="s3">return </span><span class="s1">bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);</span>
    <span class="s1">}</span>

    <span class="s1">reconcileChildren(current, workInProgress, nextChildren, renderLanes);</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">workInProgress.child;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">updateHostComponent(current, workInProgress, renderLanes) {</span>
  <span class="s1">pushHostContext(workInProgress);</span>

  <span class="s3">var </span><span class="s1">type = workInProgress.type;</span>
  <span class="s3">var </span><span class="s1">nextProps = workInProgress.pendingProps;</span>
  <span class="s3">var </span><span class="s1">prevProps = current !== </span><span class="s3">null </span><span class="s1">? current.memoizedProps : </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">nextChildren = nextProps.children;</span>

  <span class="s3">if </span><span class="s1">(prevProps !== </span><span class="s3">null </span><span class="s1">&amp;&amp; shouldSetTextContent()) {</span>
    <span class="s0">// If we're switching from a direct text child to a normal child, or to</span>
    <span class="s0">// empty, we need to schedule the text content to be reset.</span>
    <span class="s1">workInProgress.flags |= ContentReset;</span>
  <span class="s1">}</span>

  <span class="s1">markRef(current, workInProgress);</span>
  <span class="s1">reconcileChildren(current, workInProgress, nextChildren, renderLanes);</span>
  <span class="s3">return </span><span class="s1">workInProgress.child;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">updateHostText(current, workInProgress) {</span>
  <span class="s0">// immediately after.</span>

  <span class="s3">return null</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">mountLazyComponent(</span>
  <span class="s1">_current,</span>
  <span class="s1">workInProgress,</span>
  <span class="s1">elementType,</span>
  <span class="s1">renderLanes</span>
<span class="s1">) {</span>
  <span class="s1">resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress);</span>
  <span class="s3">var </span><span class="s1">props = workInProgress.pendingProps;</span>
  <span class="s3">var </span><span class="s1">lazyComponent = elementType;</span>
  <span class="s3">var </span><span class="s1">payload = lazyComponent._payload;</span>
  <span class="s3">var </span><span class="s1">init = lazyComponent._init;</span>
  <span class="s3">var </span><span class="s1">Component = init(payload); </span><span class="s0">// Store the unwrapped component in the type.</span>

  <span class="s1">workInProgress.type = Component;</span>
  <span class="s3">var </span><span class="s1">resolvedTag = (workInProgress.tag = resolveLazyComponentTag(Component));</span>
  <span class="s3">var </span><span class="s1">resolvedProps = resolveDefaultProps(Component, props);</span>
  <span class="s3">var </span><span class="s1">child;</span>

  <span class="s3">switch </span><span class="s1">(resolvedTag) {</span>
    <span class="s3">case </span><span class="s1">FunctionComponent: {</span>
      <span class="s1">{</span>
        <span class="s1">validateFunctionComponentInDev(workInProgress, Component);</span>
        <span class="s1">workInProgress.type = Component = resolveFunctionForHotReloading(</span>
          <span class="s1">Component</span>
        <span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s1">child = updateFunctionComponent(</span>
        <span class="s3">null</span><span class="s1">,</span>
        <span class="s1">workInProgress,</span>
        <span class="s1">Component,</span>
        <span class="s1">resolvedProps,</span>
        <span class="s1">renderLanes</span>
      <span class="s1">);</span>
      <span class="s3">return </span><span class="s1">child;</span>
    <span class="s1">}</span>

    <span class="s3">case </span><span class="s1">ClassComponent: {</span>
      <span class="s1">{</span>
        <span class="s1">workInProgress.type = Component = resolveClassForHotReloading(</span>
          <span class="s1">Component</span>
        <span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s1">child = updateClassComponent(</span>
        <span class="s3">null</span><span class="s1">,</span>
        <span class="s1">workInProgress,</span>
        <span class="s1">Component,</span>
        <span class="s1">resolvedProps,</span>
        <span class="s1">renderLanes</span>
      <span class="s1">);</span>
      <span class="s3">return </span><span class="s1">child;</span>
    <span class="s1">}</span>

    <span class="s3">case </span><span class="s1">ForwardRef: {</span>
      <span class="s1">{</span>
        <span class="s1">workInProgress.type = Component = resolveForwardRefForHotReloading(</span>
          <span class="s1">Component</span>
        <span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s1">child = updateForwardRef(</span>
        <span class="s3">null</span><span class="s1">,</span>
        <span class="s1">workInProgress,</span>
        <span class="s1">Component,</span>
        <span class="s1">resolvedProps,</span>
        <span class="s1">renderLanes</span>
      <span class="s1">);</span>
      <span class="s3">return </span><span class="s1">child;</span>
    <span class="s1">}</span>

    <span class="s3">case </span><span class="s1">MemoComponent: {</span>
      <span class="s1">{</span>
        <span class="s3">if </span><span class="s1">(workInProgress.type !== workInProgress.elementType) {</span>
          <span class="s3">var </span><span class="s1">outerPropTypes = Component.propTypes;</span>

          <span class="s3">if </span><span class="s1">(outerPropTypes) {</span>
            <span class="s1">checkPropTypes(</span>
              <span class="s1">outerPropTypes,</span>
              <span class="s1">resolvedProps, </span><span class="s0">// Resolved for outer only</span>
              <span class="s2">&quot;prop&quot;</span><span class="s1">,</span>
              <span class="s1">getComponentNameFromType(Component)</span>
            <span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">child = updateMemoComponent(</span>
        <span class="s3">null</span><span class="s1">,</span>
        <span class="s1">workInProgress,</span>
        <span class="s1">Component,</span>
        <span class="s1">resolveDefaultProps(Component.type, resolvedProps), </span><span class="s0">// The inner type can have defaults too</span>
        <span class="s1">renderLanes</span>
      <span class="s1">);</span>
      <span class="s3">return </span><span class="s1">child;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">hint = </span><span class="s2">&quot;&quot;</span><span class="s1">;</span>

  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(</span>
      <span class="s1">Component !== </span><span class="s3">null </span><span class="s1">&amp;&amp;</span>
      <span class="s3">typeof </span><span class="s1">Component === </span><span class="s2">&quot;object&quot; </span><span class="s1">&amp;&amp;</span>
      <span class="s1">Component.$$typeof === REACT_LAZY_TYPE</span>
    <span class="s1">) {</span>
      <span class="s1">hint = </span><span class="s2">&quot; Did you wrap a component in React.lazy() more than once?&quot;</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s0">// This message intentionally doesn't mention ForwardRef or MemoComponent</span>
  <span class="s0">// because the fact that it's a separate type of work is an</span>
  <span class="s0">// implementation detail.</span>

  <span class="s3">throw new </span><span class="s1">Error(</span>
    <span class="s2">&quot;Element type is invalid. Received a promise that resolves to: &quot; </span><span class="s1">+</span>
      <span class="s1">Component +</span>
      <span class="s2">&quot;. &quot; </span><span class="s1">+</span>
      <span class="s1">(</span><span class="s2">&quot;Lazy element type must resolve to a class or function.&quot; </span><span class="s1">+ hint)</span>
  <span class="s1">);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">mountIncompleteClassComponent(</span>
  <span class="s1">_current,</span>
  <span class="s1">workInProgress,</span>
  <span class="s1">Component,</span>
  <span class="s1">nextProps,</span>
  <span class="s1">renderLanes</span>
<span class="s1">) {</span>
  <span class="s1">resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress); </span><span class="s0">// Promote the fiber to a class and try rendering again.</span>

  <span class="s1">workInProgress.tag = ClassComponent; </span><span class="s0">// The rest of this function is a fork of `updateClassComponent`</span>
  <span class="s0">// Push context providers early to prevent context stack mismatches.</span>
  <span class="s0">// During mounting we don't know the child context yet as the instance doesn't exist.</span>
  <span class="s0">// We will invalidate the child context in finishClassComponent() right after rendering.</span>

  <span class="s3">var </span><span class="s1">hasContext;</span>

  <span class="s3">if </span><span class="s1">(isContextProvider(Component)) {</span>
    <span class="s1">hasContext = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">pushContextProvider(workInProgress);</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">hasContext = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s1">prepareToReadContext(workInProgress, renderLanes);</span>
  <span class="s1">constructClassInstance(workInProgress, Component, nextProps);</span>
  <span class="s1">mountClassInstance(workInProgress, Component, nextProps, renderLanes);</span>
  <span class="s3">return </span><span class="s1">finishClassComponent(</span>
    <span class="s3">null</span><span class="s1">,</span>
    <span class="s1">workInProgress,</span>
    <span class="s1">Component,</span>
    <span class="s3">true</span><span class="s1">,</span>
    <span class="s1">hasContext,</span>
    <span class="s1">renderLanes</span>
  <span class="s1">);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">mountIndeterminateComponent(</span>
  <span class="s1">_current,</span>
  <span class="s1">workInProgress,</span>
  <span class="s1">Component,</span>
  <span class="s1">renderLanes</span>
<span class="s1">) {</span>
  <span class="s1">resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress);</span>
  <span class="s3">var </span><span class="s1">props = workInProgress.pendingProps;</span>
  <span class="s3">var </span><span class="s1">context;</span>

  <span class="s1">{</span>
    <span class="s3">var </span><span class="s1">unmaskedContext = getUnmaskedContext(workInProgress, Component, </span><span class="s3">false</span><span class="s1">);</span>
    <span class="s1">context = getMaskedContext(workInProgress, unmaskedContext);</span>
  <span class="s1">}</span>

  <span class="s1">prepareToReadContext(workInProgress, renderLanes);</span>
  <span class="s3">var </span><span class="s1">value;</span>

  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(</span>
      <span class="s1">Component.prototype &amp;&amp;</span>
      <span class="s3">typeof </span><span class="s1">Component.prototype.render === </span><span class="s2">&quot;function&quot;</span>
    <span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">componentName = getComponentNameFromType(Component) || </span><span class="s2">&quot;Unknown&quot;</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s1">(!didWarnAboutBadClass[componentName]) {</span>
        <span class="s1">error(</span>
          <span class="s2">&quot;The &lt;%s /&gt; component appears to have a render method, but doesn't extend React.Component. &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;This is likely to cause errors. Change %s to extend React.Component instead.&quot;</span><span class="s1">,</span>
          <span class="s1">componentName,</span>
          <span class="s1">componentName</span>
        <span class="s1">);</span>

        <span class="s1">didWarnAboutBadClass[componentName] = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(workInProgress.mode &amp; StrictLegacyMode) {</span>
      <span class="s1">ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, </span><span class="s3">null</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s1">setIsRendering(</span><span class="s3">true</span><span class="s1">);</span>
    <span class="s1">ReactCurrentOwner$1.current = workInProgress;</span>
    <span class="s1">value = renderWithHooks(</span>
      <span class="s3">null</span><span class="s1">,</span>
      <span class="s1">workInProgress,</span>
      <span class="s1">Component,</span>
      <span class="s1">props,</span>
      <span class="s1">context,</span>
      <span class="s1">renderLanes</span>
    <span class="s1">);</span>
    <span class="s1">setIsRendering(</span><span class="s3">false</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s1">workInProgress.flags |= PerformedWork;</span>

  <span class="s1">{</span>
    <span class="s0">// Support for module components is deprecated and is removed behind a flag.</span>
    <span class="s0">// Whether or not it would crash later, we want to show a good message in DEV first.</span>
    <span class="s3">if </span><span class="s1">(</span>
      <span class="s3">typeof </span><span class="s1">value === </span><span class="s2">&quot;object&quot; </span><span class="s1">&amp;&amp;</span>
      <span class="s1">value !== </span><span class="s3">null </span><span class="s1">&amp;&amp;</span>
      <span class="s3">typeof </span><span class="s1">value.render === </span><span class="s2">&quot;function&quot; </span><span class="s1">&amp;&amp;</span>
      <span class="s1">value.$$typeof === undefined</span>
    <span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">_componentName = getComponentNameFromType(Component) || </span><span class="s2">&quot;Unknown&quot;</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s1">(!didWarnAboutModulePatternComponent[_componentName]) {</span>
        <span class="s1">error(</span>
          <span class="s2">&quot;The &lt;%s /&gt; component appears to be a function component that returns a class instance. &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;Change %s to a class that extends React.Component instead. &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;If you can't use a class try assigning the prototype on the function as a workaround. &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;`%s.prototype = React.Component.prototype`. Don't use an arrow function since it &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;cannot be called with `new` by React.&quot;</span><span class="s1">,</span>
          <span class="s1">_componentName,</span>
          <span class="s1">_componentName,</span>
          <span class="s1">_componentName</span>
        <span class="s1">);</span>

        <span class="s1">didWarnAboutModulePatternComponent[_componentName] = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(</span>
    <span class="s0">// Run these checks in production only if the flag is off.</span>
    <span class="s0">// Eventually we'll delete this branch altogether.</span>
    <span class="s3">typeof </span><span class="s1">value === </span><span class="s2">&quot;object&quot; </span><span class="s1">&amp;&amp;</span>
    <span class="s1">value !== </span><span class="s3">null </span><span class="s1">&amp;&amp;</span>
    <span class="s3">typeof </span><span class="s1">value.render === </span><span class="s2">&quot;function&quot; </span><span class="s1">&amp;&amp;</span>
    <span class="s1">value.$$typeof === undefined</span>
  <span class="s1">) {</span>
    <span class="s1">{</span>
      <span class="s3">var </span><span class="s1">_componentName2 = getComponentNameFromType(Component) || </span><span class="s2">&quot;Unknown&quot;</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s1">(!didWarnAboutModulePatternComponent[_componentName2]) {</span>
        <span class="s1">error(</span>
          <span class="s2">&quot;The &lt;%s /&gt; component appears to be a function component that returns a class instance. &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;Change %s to a class that extends React.Component instead. &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;If you can't use a class try assigning the prototype on the function as a workaround. &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;`%s.prototype = React.Component.prototype`. Don't use an arrow function since it &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;cannot be called with `new` by React.&quot;</span><span class="s1">,</span>
          <span class="s1">_componentName2,</span>
          <span class="s1">_componentName2,</span>
          <span class="s1">_componentName2</span>
        <span class="s1">);</span>

        <span class="s1">didWarnAboutModulePatternComponent[_componentName2] = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// Proceed under the assumption that this is a class instance</span>

    <span class="s1">workInProgress.tag = ClassComponent; </span><span class="s0">// Throw out any hooks that were used.</span>

    <span class="s1">workInProgress.memoizedState = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">workInProgress.updateQueue = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// Push context providers early to prevent context stack mismatches.</span>
    <span class="s0">// During mounting we don't know the child context yet as the instance doesn't exist.</span>
    <span class="s0">// We will invalidate the child context in finishClassComponent() right after rendering.</span>

    <span class="s3">var </span><span class="s1">hasContext = </span><span class="s3">false</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s1">(isContextProvider(Component)) {</span>
      <span class="s1">hasContext = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">pushContextProvider(workInProgress);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">hasContext = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">workInProgress.memoizedState =</span>
      <span class="s1">value.state !== </span><span class="s3">null </span><span class="s1">&amp;&amp; value.state !== undefined ? value.state : </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">initializeUpdateQueue(workInProgress);</span>
    <span class="s1">adoptClassInstance(workInProgress, value);</span>
    <span class="s1">mountClassInstance(workInProgress, Component, props, renderLanes);</span>
    <span class="s3">return </span><span class="s1">finishClassComponent(</span>
      <span class="s3">null</span><span class="s1">,</span>
      <span class="s1">workInProgress,</span>
      <span class="s1">Component,</span>
      <span class="s3">true</span><span class="s1">,</span>
      <span class="s1">hasContext,</span>
      <span class="s1">renderLanes</span>
    <span class="s1">);</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s0">// Proceed under the assumption that this is a function component</span>
    <span class="s1">workInProgress.tag = FunctionComponent;</span>

    <span class="s1">reconcileChildren(</span><span class="s3">null</span><span class="s1">, workInProgress, value, renderLanes);</span>

    <span class="s1">{</span>
      <span class="s1">validateFunctionComponentInDev(workInProgress, Component);</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">workInProgress.child;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">validateFunctionComponentInDev(workInProgress, Component) {</span>
  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(Component) {</span>
      <span class="s3">if </span><span class="s1">(Component.childContextTypes) {</span>
        <span class="s1">error(</span>
          <span class="s2">&quot;%s(...): childContextTypes cannot be defined on a function component.&quot;</span><span class="s1">,</span>
          <span class="s1">Component.displayName || Component.name || </span><span class="s2">&quot;Component&quot;</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(workInProgress.ref !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">info = </span><span class="s2">&quot;&quot;</span><span class="s1">;</span>
      <span class="s3">var </span><span class="s1">ownerName = getCurrentFiberOwnerNameInDevOrNull();</span>

      <span class="s3">if </span><span class="s1">(ownerName) {</span>
        <span class="s1">info += </span><span class="s2">&quot;</span><span class="s5">\n\n</span><span class="s2">Check the render method of `&quot; </span><span class="s1">+ ownerName + </span><span class="s2">&quot;`.&quot;</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">warningKey = ownerName || </span><span class="s2">&quot;&quot;</span><span class="s1">;</span>
      <span class="s3">var </span><span class="s1">debugSource = workInProgress._debugSource;</span>

      <span class="s3">if </span><span class="s1">(debugSource) {</span>
        <span class="s1">warningKey = debugSource.fileName + </span><span class="s2">&quot;:&quot; </span><span class="s1">+ debugSource.lineNumber;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(!didWarnAboutFunctionRefs[warningKey]) {</span>
        <span class="s1">didWarnAboutFunctionRefs[warningKey] = </span><span class="s3">true</span><span class="s1">;</span>

        <span class="s1">error(</span>
          <span class="s2">&quot;Function components cannot be given refs. &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;Attempts to access this ref will fail. &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;Did you mean to use React.forwardRef()?%s&quot;</span><span class="s1">,</span>
          <span class="s1">info</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">Component.getDerivedStateFromProps === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">_componentName3 = getComponentNameFromType(Component) || </span><span class="s2">&quot;Unknown&quot;</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s1">(!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {</span>
        <span class="s1">error(</span>
          <span class="s2">&quot;%s: Function components do not support getDerivedStateFromProps.&quot;</span><span class="s1">,</span>
          <span class="s1">_componentName3</span>
        <span class="s1">);</span>

        <span class="s1">didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span>
      <span class="s3">typeof </span><span class="s1">Component.contextType === </span><span class="s2">&quot;object&quot; </span><span class="s1">&amp;&amp;</span>
      <span class="s1">Component.contextType !== </span><span class="s3">null</span>
    <span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">_componentName4 = getComponentNameFromType(Component) || </span><span class="s2">&quot;Unknown&quot;</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s1">(!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {</span>
        <span class="s1">error(</span>
          <span class="s2">&quot;%s: Function components do not support contextType.&quot;</span><span class="s1">,</span>
          <span class="s1">_componentName4</span>
        <span class="s1">);</span>

        <span class="s1">didWarnAboutContextTypeOnFunctionComponent[_componentName4] = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">SUSPENDED_MARKER = {</span>
  <span class="s1">dehydrated: </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">treeContext: </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">retryLane: NoLane</span>
<span class="s1">};</span>

<span class="s3">function </span><span class="s1">mountSuspenseOffscreenState(renderLanes) {</span>
  <span class="s3">return </span><span class="s1">{</span>
    <span class="s1">baseLanes: renderLanes,</span>
    <span class="s1">cachePool: getSuspendedCache(),</span>
    <span class="s1">transitions: </span><span class="s3">null</span>
  <span class="s1">};</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">updateSuspenseOffscreenState(prevOffscreenState, renderLanes) {</span>
  <span class="s3">var </span><span class="s1">cachePool = </span><span class="s3">null</span><span class="s1">;</span>

  <span class="s3">return </span><span class="s1">{</span>
    <span class="s1">baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes),</span>
    <span class="s1">cachePool: cachePool,</span>
    <span class="s1">transitions: prevOffscreenState.transitions</span>
  <span class="s1">};</span>
<span class="s1">} </span><span class="s0">// TODO: Probably should inline this back</span>

<span class="s3">function </span><span class="s1">shouldRemainOnFallback(</span>
  <span class="s1">suspenseContext,</span>
  <span class="s1">current,</span>
  <span class="s1">workInProgress,</span>
  <span class="s1">renderLanes</span>
<span class="s1">) {</span>
  <span class="s0">// If we're already showing a fallback, there are cases where we need to</span>
  <span class="s0">// remain on that fallback regardless of whether the content has resolved.</span>
  <span class="s0">// For example, SuspenseList coordinates when nested content appears.</span>
  <span class="s3">if </span><span class="s1">(current !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">suspenseState = current.memoizedState;</span>

    <span class="s3">if </span><span class="s1">(suspenseState === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// Currently showing content. Don't hide it, even if ForceSuspenseFallback</span>
      <span class="s0">// is true. More precise name might be &quot;ForceRemainSuspenseFallback&quot;.</span>
      <span class="s0">// Note: This is a factoring smell. Can't remain on a fallback if there's</span>
      <span class="s0">// no fallback to remain on.</span>
      <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s0">// Not currently showing content. Consult the Suspense context.</span>

  <span class="s3">return </span><span class="s1">hasSuspenseContext(suspenseContext, ForceSuspenseFallback);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">getRemainingWorkInPrimaryTree(current, renderLanes) {</span>
  <span class="s0">// TODO: Should not remove render lanes that were pinged during this render</span>
  <span class="s3">return </span><span class="s1">removeLanes(current.childLanes, renderLanes);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">updateSuspenseComponent(current, workInProgress, renderLanes) {</span>
  <span class="s3">var </span><span class="s1">nextProps = workInProgress.pendingProps; </span><span class="s0">// This is used by DevTools to force a boundary to suspend.</span>

  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(shouldSuspend(workInProgress)) {</span>
      <span class="s1">workInProgress.flags |= DidCapture;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">suspenseContext = suspenseStackCursor.current;</span>
  <span class="s3">var </span><span class="s1">showFallback = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">didSuspend = (workInProgress.flags &amp; DidCapture) !== NoFlags;</span>

  <span class="s3">if </span><span class="s1">(didSuspend || shouldRemainOnFallback(suspenseContext, current)) {</span>
    <span class="s0">// Something in this boundary's subtree already suspended. Switch to</span>
    <span class="s0">// rendering the fallback children.</span>
    <span class="s1">showFallback = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">workInProgress.flags &amp;= ~DidCapture;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s0">// Attempting the main content</span>
    <span class="s3">if </span><span class="s1">(current === </span><span class="s3">null </span><span class="s1">|| current.memoizedState !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// This is a new mount or this boundary is already showing a fallback state.</span>
      <span class="s0">// Mark this subtree context as having at least one invisible parent that could</span>
      <span class="s0">// handle the fallback state.</span>
      <span class="s0">// Avoided boundaries are not considered since they cannot handle preferred fallback states.</span>
      <span class="s1">{</span>
        <span class="s1">suspenseContext = addSubtreeSuspenseContext(</span>
          <span class="s1">suspenseContext,</span>
          <span class="s1">InvisibleParentSuspenseContext</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);</span>
  <span class="s1">pushSuspenseContext(workInProgress, suspenseContext); </span><span class="s0">// OK, the next part is confusing. We're about to reconcile the Suspense</span>
  <span class="s0">// boundary's children. This involves some custom reconciliation logic. Two</span>
  <span class="s0">// main reasons this is so complicated.</span>
  <span class="s0">//</span>
  <span class="s0">// First, Legacy Mode has different semantics for backwards compatibility. The</span>
  <span class="s0">// primary tree will commit in an inconsistent state, so when we do the</span>
  <span class="s0">// second pass to render the fallback, we do some exceedingly, uh, clever</span>
  <span class="s0">// hacks to make that not totally break. Like transferring effects and</span>
  <span class="s0">// deletions from hidden tree. In Concurrent Mode, it's much simpler,</span>
  <span class="s0">// because we bailout on the primary tree completely and leave it in its old</span>
  <span class="s0">// state, no effects. Same as what we do for Offscreen (except that</span>
  <span class="s0">// Offscreen doesn't have the first render pass).</span>
  <span class="s0">//</span>
  <span class="s0">// Second is hydration. During hydration, the Suspense fiber has a slightly</span>
  <span class="s0">// different layout, where the child points to a dehydrated fragment, which</span>
  <span class="s0">// contains the DOM rendered by the server.</span>
  <span class="s0">//</span>
  <span class="s0">// Third, even if you set all that aside, Suspense is like error boundaries in</span>
  <span class="s0">// that we first we try to render one tree, and if that fails, we render again</span>
  <span class="s0">// and switch to a different tree. Like a try/catch block. So we have to track</span>
  <span class="s0">// which branch we're currently rendering. Ideally we would model this using</span>
  <span class="s0">// a stack.</span>

  <span class="s3">if </span><span class="s1">(current === </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">suspenseState = workInProgress.memoizedState;</span>

    <span class="s3">if </span><span class="s1">(suspenseState !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">dehydrated = suspenseState.dehydrated;</span>

      <span class="s3">if </span><span class="s1">(dehydrated !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">return </span><span class="s1">mountDehydratedSuspenseComponent(workInProgress);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">nextPrimaryChildren = nextProps.children;</span>
    <span class="s3">var </span><span class="s1">nextFallbackChildren = nextProps.fallback;</span>

    <span class="s3">if </span><span class="s1">(showFallback) {</span>
      <span class="s3">var </span><span class="s1">fallbackFragment = mountSuspenseFallbackChildren(</span>
        <span class="s1">workInProgress,</span>
        <span class="s1">nextPrimaryChildren,</span>
        <span class="s1">nextFallbackChildren,</span>
        <span class="s1">renderLanes</span>
      <span class="s1">);</span>
      <span class="s3">var </span><span class="s1">primaryChildFragment = workInProgress.child;</span>
      <span class="s1">primaryChildFragment.memoizedState = mountSuspenseOffscreenState(</span>
        <span class="s1">renderLanes</span>
      <span class="s1">);</span>
      <span class="s1">workInProgress.memoizedState = SUSPENDED_MARKER;</span>

      <span class="s3">return </span><span class="s1">fallbackFragment;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">return </span><span class="s1">mountSuspensePrimaryChildren(workInProgress, nextPrimaryChildren);</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s0">// This is an update.</span>
    <span class="s0">// Special path for hydration</span>
    <span class="s3">var </span><span class="s1">prevState = current.memoizedState;</span>

    <span class="s3">if </span><span class="s1">(prevState !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">_dehydrated = prevState.dehydrated;</span>

      <span class="s3">if </span><span class="s1">(_dehydrated !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">return </span><span class="s1">updateDehydratedSuspenseComponent(</span>
          <span class="s1">current,</span>
          <span class="s1">workInProgress,</span>
          <span class="s1">didSuspend,</span>
          <span class="s1">nextProps,</span>
          <span class="s1">_dehydrated,</span>
          <span class="s1">prevState,</span>
          <span class="s1">renderLanes</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(showFallback) {</span>
      <span class="s3">var </span><span class="s1">_nextFallbackChildren = nextProps.fallback;</span>
      <span class="s3">var </span><span class="s1">_nextPrimaryChildren = nextProps.children;</span>
      <span class="s3">var </span><span class="s1">fallbackChildFragment = updateSuspenseFallbackChildren(</span>
        <span class="s1">current,</span>
        <span class="s1">workInProgress,</span>
        <span class="s1">_nextPrimaryChildren,</span>
        <span class="s1">_nextFallbackChildren,</span>
        <span class="s1">renderLanes</span>
      <span class="s1">);</span>
      <span class="s3">var </span><span class="s1">_primaryChildFragment2 = workInProgress.child;</span>
      <span class="s3">var </span><span class="s1">prevOffscreenState = current.child.memoizedState;</span>
      <span class="s1">_primaryChildFragment2.memoizedState =</span>
        <span class="s1">prevOffscreenState === </span><span class="s3">null</span>
          <span class="s1">? mountSuspenseOffscreenState(renderLanes)</span>
          <span class="s1">: updateSuspenseOffscreenState(prevOffscreenState, renderLanes);</span>

      <span class="s1">_primaryChildFragment2.childLanes = getRemainingWorkInPrimaryTree(</span>
        <span class="s1">current,</span>
        <span class="s1">renderLanes</span>
      <span class="s1">);</span>
      <span class="s1">workInProgress.memoizedState = SUSPENDED_MARKER;</span>
      <span class="s3">return </span><span class="s1">fallbackChildFragment;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">var </span><span class="s1">_nextPrimaryChildren2 = nextProps.children;</span>

      <span class="s3">var </span><span class="s1">_primaryChildFragment3 = updateSuspensePrimaryChildren(</span>
        <span class="s1">current,</span>
        <span class="s1">workInProgress,</span>
        <span class="s1">_nextPrimaryChildren2,</span>
        <span class="s1">renderLanes</span>
      <span class="s1">);</span>

      <span class="s1">workInProgress.memoizedState = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s3">return </span><span class="s1">_primaryChildFragment3;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">mountSuspensePrimaryChildren(</span>
  <span class="s1">workInProgress,</span>
  <span class="s1">primaryChildren,</span>
  <span class="s1">renderLanes</span>
<span class="s1">) {</span>
  <span class="s3">var </span><span class="s1">mode = workInProgress.mode;</span>
  <span class="s3">var </span><span class="s1">primaryChildProps = {</span>
    <span class="s1">mode: </span><span class="s2">&quot;visible&quot;</span><span class="s1">,</span>
    <span class="s1">children: primaryChildren</span>
  <span class="s1">};</span>
  <span class="s3">var </span><span class="s1">primaryChildFragment = mountWorkInProgressOffscreenFiber(</span>
    <span class="s1">primaryChildProps,</span>
    <span class="s1">mode</span>
  <span class="s1">);</span>
  <span class="s1">primaryChildFragment.</span><span class="s3">return </span><span class="s1">= workInProgress;</span>
  <span class="s1">workInProgress.child = primaryChildFragment;</span>
  <span class="s3">return </span><span class="s1">primaryChildFragment;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">mountSuspenseFallbackChildren(</span>
  <span class="s1">workInProgress,</span>
  <span class="s1">primaryChildren,</span>
  <span class="s1">fallbackChildren,</span>
  <span class="s1">renderLanes</span>
<span class="s1">) {</span>
  <span class="s3">var </span><span class="s1">mode = workInProgress.mode;</span>
  <span class="s3">var </span><span class="s1">progressedPrimaryFragment = workInProgress.child;</span>
  <span class="s3">var </span><span class="s1">primaryChildProps = {</span>
    <span class="s1">mode: </span><span class="s2">&quot;hidden&quot;</span><span class="s1">,</span>
    <span class="s1">children: primaryChildren</span>
  <span class="s1">};</span>
  <span class="s3">var </span><span class="s1">primaryChildFragment;</span>
  <span class="s3">var </span><span class="s1">fallbackChildFragment;</span>

  <span class="s3">if </span><span class="s1">(</span>
    <span class="s1">(mode &amp; ConcurrentMode) === NoMode &amp;&amp;</span>
    <span class="s1">progressedPrimaryFragment !== </span><span class="s3">null</span>
  <span class="s1">) {</span>
    <span class="s0">// In legacy mode, we commit the primary tree as if it successfully</span>
    <span class="s0">// completed, even though it's in an inconsistent state.</span>
    <span class="s1">primaryChildFragment = progressedPrimaryFragment;</span>
    <span class="s1">primaryChildFragment.childLanes = NoLanes;</span>
    <span class="s1">primaryChildFragment.pendingProps = primaryChildProps;</span>

    <span class="s3">if </span><span class="s1">(workInProgress.mode &amp; ProfileMode) {</span>
      <span class="s0">// Reset the durations from the first pass so they aren't included in the</span>
      <span class="s0">// final amounts. This seems counterintuitive, since we're intentionally</span>
      <span class="s0">// not measuring part of the render phase, but this makes it match what we</span>
      <span class="s0">// do in Concurrent Mode.</span>
      <span class="s1">primaryChildFragment.actualDuration = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s1">primaryChildFragment.actualStartTime = -</span><span class="s4">1</span><span class="s1">;</span>
      <span class="s1">primaryChildFragment.selfBaseDuration = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s1">primaryChildFragment.treeBaseDuration = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">fallbackChildFragment = createFiberFromFragment(</span>
      <span class="s1">fallbackChildren,</span>
      <span class="s1">mode,</span>
      <span class="s1">renderLanes,</span>
      <span class="s3">null</span>
    <span class="s1">);</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">primaryChildFragment = mountWorkInProgressOffscreenFiber(</span>
      <span class="s1">primaryChildProps,</span>
      <span class="s1">mode</span>
    <span class="s1">);</span>
    <span class="s1">fallbackChildFragment = createFiberFromFragment(</span>
      <span class="s1">fallbackChildren,</span>
      <span class="s1">mode,</span>
      <span class="s1">renderLanes,</span>
      <span class="s3">null</span>
    <span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s1">primaryChildFragment.</span><span class="s3">return </span><span class="s1">= workInProgress;</span>
  <span class="s1">fallbackChildFragment.</span><span class="s3">return </span><span class="s1">= workInProgress;</span>
  <span class="s1">primaryChildFragment.sibling = fallbackChildFragment;</span>
  <span class="s1">workInProgress.child = primaryChildFragment;</span>
  <span class="s3">return </span><span class="s1">fallbackChildFragment;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">mountWorkInProgressOffscreenFiber(offscreenProps, mode, renderLanes) {</span>
  <span class="s0">// The props argument to `createFiberFromOffscreen` is `any` typed, so we use</span>
  <span class="s0">// this wrapper function to constrain it.</span>
  <span class="s3">return </span><span class="s1">createFiberFromOffscreen(offscreenProps, mode, NoLanes, </span><span class="s3">null</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">updateWorkInProgressOffscreenFiber(current, offscreenProps) {</span>
  <span class="s0">// The props argument to `createWorkInProgress` is `any` typed, so we use this</span>
  <span class="s0">// wrapper function to constrain it.</span>
  <span class="s3">return </span><span class="s1">createWorkInProgress(current, offscreenProps);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">updateSuspensePrimaryChildren(</span>
  <span class="s1">current,</span>
  <span class="s1">workInProgress,</span>
  <span class="s1">primaryChildren,</span>
  <span class="s1">renderLanes</span>
<span class="s1">) {</span>
  <span class="s3">var </span><span class="s1">currentPrimaryChildFragment = current.child;</span>
  <span class="s3">var </span><span class="s1">currentFallbackChildFragment = currentPrimaryChildFragment.sibling;</span>
  <span class="s3">var </span><span class="s1">primaryChildFragment = updateWorkInProgressOffscreenFiber(</span>
    <span class="s1">currentPrimaryChildFragment,</span>
    <span class="s1">{</span>
      <span class="s1">mode: </span><span class="s2">&quot;visible&quot;</span><span class="s1">,</span>
      <span class="s1">children: primaryChildren</span>
    <span class="s1">}</span>
  <span class="s1">);</span>

  <span class="s3">if </span><span class="s1">((workInProgress.mode &amp; ConcurrentMode) === NoMode) {</span>
    <span class="s1">primaryChildFragment.lanes = renderLanes;</span>
  <span class="s1">}</span>

  <span class="s1">primaryChildFragment.</span><span class="s3">return </span><span class="s1">= workInProgress;</span>
  <span class="s1">primaryChildFragment.sibling = </span><span class="s3">null</span><span class="s1">;</span>

  <span class="s3">if </span><span class="s1">(currentFallbackChildFragment !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s0">// Delete the fallback child fragment</span>
    <span class="s3">var </span><span class="s1">deletions = workInProgress.deletions;</span>

    <span class="s3">if </span><span class="s1">(deletions === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">workInProgress.deletions = [currentFallbackChildFragment];</span>
      <span class="s1">workInProgress.flags |= ChildDeletion;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">deletions.push(currentFallbackChildFragment);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">workInProgress.child = primaryChildFragment;</span>
  <span class="s3">return </span><span class="s1">primaryChildFragment;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">updateSuspenseFallbackChildren(</span>
  <span class="s1">current,</span>
  <span class="s1">workInProgress,</span>
  <span class="s1">primaryChildren,</span>
  <span class="s1">fallbackChildren,</span>
  <span class="s1">renderLanes</span>
<span class="s1">) {</span>
  <span class="s3">var </span><span class="s1">mode = workInProgress.mode;</span>
  <span class="s3">var </span><span class="s1">currentPrimaryChildFragment = current.child;</span>
  <span class="s3">var </span><span class="s1">currentFallbackChildFragment = currentPrimaryChildFragment.sibling;</span>
  <span class="s3">var </span><span class="s1">primaryChildProps = {</span>
    <span class="s1">mode: </span><span class="s2">&quot;hidden&quot;</span><span class="s1">,</span>
    <span class="s1">children: primaryChildren</span>
  <span class="s1">};</span>
  <span class="s3">var </span><span class="s1">primaryChildFragment;</span>

  <span class="s3">if </span><span class="s1">(</span>
    <span class="s0">// In legacy mode, we commit the primary tree as if it successfully</span>
    <span class="s0">// completed, even though it's in an inconsistent state.</span>
    <span class="s1">(mode &amp; ConcurrentMode) === NoMode &amp;&amp; </span><span class="s0">// Make sure we're on the second pass, i.e. the primary child fragment was</span>
    <span class="s0">// already cloned. In legacy mode, the only case where this isn't true is</span>
    <span class="s0">// when DevTools forces us to display a fallback; we skip the first render</span>
    <span class="s0">// pass entirely and go straight to rendering the fallback. (In Concurrent</span>
    <span class="s0">// Mode, SuspenseList can also trigger this scenario, but this is a legacy-</span>
    <span class="s0">// only codepath.)</span>
    <span class="s1">workInProgress.child !== currentPrimaryChildFragment</span>
  <span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">progressedPrimaryFragment = workInProgress.child;</span>
    <span class="s1">primaryChildFragment = progressedPrimaryFragment;</span>
    <span class="s1">primaryChildFragment.childLanes = NoLanes;</span>
    <span class="s1">primaryChildFragment.pendingProps = primaryChildProps;</span>

    <span class="s3">if </span><span class="s1">(workInProgress.mode &amp; ProfileMode) {</span>
      <span class="s0">// Reset the durations from the first pass so they aren't included in the</span>
      <span class="s0">// final amounts. This seems counterintuitive, since we're intentionally</span>
      <span class="s0">// not measuring part of the render phase, but this makes it match what we</span>
      <span class="s0">// do in Concurrent Mode.</span>
      <span class="s1">primaryChildFragment.actualDuration = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s1">primaryChildFragment.actualStartTime = -</span><span class="s4">1</span><span class="s1">;</span>
      <span class="s1">primaryChildFragment.selfBaseDuration =</span>
        <span class="s1">currentPrimaryChildFragment.selfBaseDuration;</span>
      <span class="s1">primaryChildFragment.treeBaseDuration =</span>
        <span class="s1">currentPrimaryChildFragment.treeBaseDuration;</span>
    <span class="s1">} </span><span class="s0">// The fallback fiber was added as a deletion during the first pass.</span>
    <span class="s0">// However, since we're going to remain on the fallback, we no longer want</span>
    <span class="s0">// to delete it.</span>

    <span class="s1">workInProgress.deletions = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">primaryChildFragment = updateWorkInProgressOffscreenFiber(</span>
      <span class="s1">currentPrimaryChildFragment,</span>
      <span class="s1">primaryChildProps</span>
    <span class="s1">); </span><span class="s0">// Since we're reusing a current tree, we need to reuse the flags, too.</span>
    <span class="s0">// (We don't do this in legacy mode, because in legacy mode we don't re-use</span>
    <span class="s0">// the current tree; see previous branch.)</span>

    <span class="s1">primaryChildFragment.subtreeFlags =</span>
      <span class="s1">currentPrimaryChildFragment.subtreeFlags &amp; StaticMask;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">fallbackChildFragment;</span>

  <span class="s3">if </span><span class="s1">(currentFallbackChildFragment !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s1">fallbackChildFragment = createWorkInProgress(</span>
      <span class="s1">currentFallbackChildFragment,</span>
      <span class="s1">fallbackChildren</span>
    <span class="s1">);</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">fallbackChildFragment = createFiberFromFragment(</span>
      <span class="s1">fallbackChildren,</span>
      <span class="s1">mode,</span>
      <span class="s1">renderLanes,</span>
      <span class="s3">null</span>
    <span class="s1">); </span><span class="s0">// Needs a placement effect because the parent (the Suspense boundary) already</span>
    <span class="s0">// mounted but this is a new fiber.</span>

    <span class="s1">fallbackChildFragment.flags |= Placement;</span>
  <span class="s1">}</span>

  <span class="s1">fallbackChildFragment.</span><span class="s3">return </span><span class="s1">= workInProgress;</span>
  <span class="s1">primaryChildFragment.</span><span class="s3">return </span><span class="s1">= workInProgress;</span>
  <span class="s1">primaryChildFragment.sibling = fallbackChildFragment;</span>
  <span class="s1">workInProgress.child = primaryChildFragment;</span>
  <span class="s3">return </span><span class="s1">fallbackChildFragment;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">retrySuspenseComponentWithoutHydrating(</span>
  <span class="s1">current,</span>
  <span class="s1">workInProgress,</span>
  <span class="s1">renderLanes,</span>
  <span class="s1">recoverableError</span>
<span class="s1">) {</span>
  <span class="s0">// Falling back to client rendering. Because this has performance</span>
  <span class="s0">// implications, it's considered a recoverable error, even though the user</span>
  <span class="s0">// likely won't observe anything wrong with the UI.</span>
  <span class="s0">//</span>
  <span class="s0">// The error is passed in as an argument to enforce that every caller provide</span>
  <span class="s0">// a custom message, or explicitly opt out (currently the only path that opts</span>
  <span class="s0">// out is legacy mode; every concurrent path provides an error).</span>
  <span class="s3">if </span><span class="s1">(recoverableError !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s1">queueHydrationError(recoverableError);</span>
  <span class="s1">} </span><span class="s0">// This will add the old fiber to the deletion list</span>

  <span class="s1">reconcileChildFibers(workInProgress, current.child, </span><span class="s3">null</span><span class="s1">, renderLanes); </span><span class="s0">// We're now not suspended nor dehydrated.</span>

  <span class="s3">var </span><span class="s1">nextProps = workInProgress.pendingProps;</span>
  <span class="s3">var </span><span class="s1">primaryChildren = nextProps.children;</span>
  <span class="s3">var </span><span class="s1">primaryChildFragment = mountSuspensePrimaryChildren(</span>
    <span class="s1">workInProgress,</span>
    <span class="s1">primaryChildren</span>
  <span class="s1">); </span><span class="s0">// Needs a placement effect because the parent (the Suspense boundary) already</span>
  <span class="s0">// mounted but this is a new fiber.</span>

  <span class="s1">primaryChildFragment.flags |= Placement;</span>
  <span class="s1">workInProgress.memoizedState = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">return </span><span class="s1">primaryChildFragment;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">mountSuspenseFallbackAfterRetryWithoutHydrating(</span>
  <span class="s1">current,</span>
  <span class="s1">workInProgress,</span>
  <span class="s1">primaryChildren,</span>
  <span class="s1">fallbackChildren,</span>
  <span class="s1">renderLanes</span>
<span class="s1">) {</span>
  <span class="s3">var </span><span class="s1">fiberMode = workInProgress.mode;</span>
  <span class="s3">var </span><span class="s1">primaryChildProps = {</span>
    <span class="s1">mode: </span><span class="s2">&quot;visible&quot;</span><span class="s1">,</span>
    <span class="s1">children: primaryChildren</span>
  <span class="s1">};</span>
  <span class="s3">var </span><span class="s1">primaryChildFragment = mountWorkInProgressOffscreenFiber(</span>
    <span class="s1">primaryChildProps,</span>
    <span class="s1">fiberMode</span>
  <span class="s1">);</span>
  <span class="s3">var </span><span class="s1">fallbackChildFragment = createFiberFromFragment(</span>
    <span class="s1">fallbackChildren,</span>
    <span class="s1">fiberMode,</span>
    <span class="s1">renderLanes,</span>
    <span class="s3">null</span>
  <span class="s1">); </span><span class="s0">// Needs a placement effect because the parent (the Suspense</span>
  <span class="s0">// boundary) already mounted but this is a new fiber.</span>

  <span class="s1">fallbackChildFragment.flags |= Placement;</span>
  <span class="s1">primaryChildFragment.</span><span class="s3">return </span><span class="s1">= workInProgress;</span>
  <span class="s1">fallbackChildFragment.</span><span class="s3">return </span><span class="s1">= workInProgress;</span>
  <span class="s1">primaryChildFragment.sibling = fallbackChildFragment;</span>
  <span class="s1">workInProgress.child = primaryChildFragment;</span>

  <span class="s3">if </span><span class="s1">((workInProgress.mode &amp; ConcurrentMode) !== NoMode) {</span>
    <span class="s0">// We will have dropped the effect list which contains the</span>
    <span class="s0">// deletion. We need to reconcile to delete the current child.</span>
    <span class="s1">reconcileChildFibers(workInProgress, current.child, </span><span class="s3">null</span><span class="s1">, renderLanes);</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">fallbackChildFragment;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">mountDehydratedSuspenseComponent(</span>
  <span class="s1">workInProgress,</span>
  <span class="s1">suspenseInstance,</span>
  <span class="s1">renderLanes</span>
<span class="s1">) {</span>
  <span class="s0">// During the first pass, we'll bail out and not drill into the children.</span>
  <span class="s0">// Instead, we'll leave the content in place and try to hydrate it later.</span>
  <span class="s3">if </span><span class="s1">((workInProgress.mode &amp; ConcurrentMode) === NoMode) {</span>
    <span class="s1">{</span>
      <span class="s1">error(</span>
        <span class="s2">&quot;Cannot hydrate Suspense in legacy mode. Switch from &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;ReactDOM.hydrate(element, container) to &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;ReactDOMClient.hydrateRoot(container, &lt;App /&gt;)&quot; </span><span class="s1">+</span>
          <span class="s2">&quot;.render(element) or remove the Suspense components from &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;the server rendered components.&quot;</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s1">workInProgress.lanes = laneToLanes(SyncLane);</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(isSuspenseInstanceFallback()) {</span>
    <span class="s0">// This is a client-only boundary. Since we won't get any content from the server</span>
    <span class="s0">// for this, we need to schedule that at a higher priority based on when it would</span>
    <span class="s0">// have timed out. In theory we could render it in this pass but it would have the</span>
    <span class="s0">// wrong priority associated with it and will prevent hydration of parent path.</span>
    <span class="s0">// Instead, we'll leave work left on it to render it in a separate commit.</span>
    <span class="s0">// TODO This time should be the time at which the server rendered response that is</span>
    <span class="s0">// a parent to this boundary was displayed. However, since we currently don't have</span>
    <span class="s0">// a protocol to transfer that time, we'll just estimate it by using the current</span>
    <span class="s0">// time. This will mean that Suspense timeouts are slightly shifted to later than</span>
    <span class="s0">// they should be.</span>
    <span class="s0">// Schedule a normal pri update to render this content.</span>
    <span class="s1">workInProgress.lanes = laneToLanes(DefaultHydrationLane);</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s0">// We'll continue hydrating the rest at offscreen priority since we'll already</span>
    <span class="s0">// be showing the right content coming from the server, it is no rush.</span>
    <span class="s1">workInProgress.lanes = laneToLanes(OffscreenLane);</span>
  <span class="s1">}</span>

  <span class="s3">return null</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">updateDehydratedSuspenseComponent(</span>
  <span class="s1">current,</span>
  <span class="s1">workInProgress,</span>
  <span class="s1">didSuspend,</span>
  <span class="s1">nextProps,</span>
  <span class="s1">suspenseInstance,</span>
  <span class="s1">suspenseState,</span>
  <span class="s1">renderLanes</span>
<span class="s1">) {</span>
  <span class="s3">if </span><span class="s1">(!didSuspend) {</span>
    <span class="s3">if </span><span class="s1">((workInProgress.mode &amp; ConcurrentMode) === NoMode) {</span>
      <span class="s3">return </span><span class="s1">retrySuspenseComponentWithoutHydrating(</span>
        <span class="s1">current,</span>
        <span class="s1">workInProgress,</span>
        <span class="s1">renderLanes, </span><span class="s0">// TODO: When we delete legacy mode, we should make this error argument</span>
        <span class="s0">// required  every concurrent mode path that causes hydration to</span>
        <span class="s0">// de-opt to client rendering should have an error message.</span>
        <span class="s3">null</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(isSuspenseInstanceFallback()) {</span>
      <span class="s0">// This boundary is in a permanent fallback state. In this case, we'll never</span>
      <span class="s0">// get an update and we'll never be able to hydrate the final content. Let's just try the</span>
      <span class="s0">// client side render instead.</span>
      <span class="s3">var </span><span class="s1">digest, message, stack;</span>

      <span class="s1">{</span>
        <span class="s3">var </span><span class="s1">_getSuspenseInstanceF = getSuspenseInstanceFallbackErrorDetails();</span>

        <span class="s1">digest = _getSuspenseInstanceF.digest;</span>
        <span class="s1">message = _getSuspenseInstanceF.message;</span>
        <span class="s1">stack = _getSuspenseInstanceF.stack;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">error;</span>

      <span class="s3">if </span><span class="s1">(message) {</span>
        <span class="s0">// eslint-disable-next-line react-internal/prod-error-codes</span>
        <span class="s1">error = </span><span class="s3">new </span><span class="s1">Error(message);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">error = </span><span class="s3">new </span><span class="s1">Error(</span>
          <span class="s2">&quot;The server could not finish this Suspense boundary, likely &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;due to an error during server rendering. Switched to &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;client rendering.&quot;</span>
        <span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">capturedValue = createCapturedValue(error, digest, stack);</span>
      <span class="s3">return </span><span class="s1">retrySuspenseComponentWithoutHydrating(</span>
        <span class="s1">current,</span>
        <span class="s1">workInProgress,</span>
        <span class="s1">renderLanes,</span>
        <span class="s1">capturedValue</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s0">// any context has changed, we need to treat is as if the input might have changed.</span>

    <span class="s3">var </span><span class="s1">hasContextChanged = includesSomeLane(renderLanes, current.childLanes);</span>

    <span class="s3">if </span><span class="s1">(didReceiveUpdate || hasContextChanged) {</span>
      <span class="s0">// This boundary has changed since the first render. This means that we are now unable to</span>
      <span class="s0">// hydrate it. We might still be able to hydrate it using a higher priority lane.</span>
      <span class="s3">var </span><span class="s1">root = getWorkInProgressRoot();</span>

      <span class="s3">if </span><span class="s1">(root !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">attemptHydrationAtLane = getBumpedLaneForHydration(</span>
          <span class="s1">root,</span>
          <span class="s1">renderLanes</span>
        <span class="s1">);</span>

        <span class="s3">if </span><span class="s1">(</span>
          <span class="s1">attemptHydrationAtLane !== NoLane &amp;&amp;</span>
          <span class="s1">attemptHydrationAtLane !== suspenseState.retryLane</span>
        <span class="s1">) {</span>
          <span class="s0">// Intentionally mutating since this render will get interrupted. This</span>
          <span class="s0">// is one of the very rare times where we mutate the current tree</span>
          <span class="s0">// during the render phase.</span>
          <span class="s1">suspenseState.retryLane = attemptHydrationAtLane; </span><span class="s0">// TODO: Ideally this would inherit the event time of the current render</span>

          <span class="s3">var </span><span class="s1">eventTime = NoTimestamp;</span>
          <span class="s1">enqueueConcurrentRenderForLane(current, attemptHydrationAtLane);</span>
          <span class="s1">scheduleUpdateOnFiber(</span>
            <span class="s1">root,</span>
            <span class="s1">current,</span>
            <span class="s1">attemptHydrationAtLane,</span>
            <span class="s1">eventTime</span>
          <span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s0">// If we have scheduled higher pri work above, this will probably just abort the render</span>
      <span class="s0">// since we now have higher priority work, but in case it doesn't, we need to prepare to</span>
      <span class="s0">// render something, if we time out. Even if that requires us to delete everything and</span>
      <span class="s0">// skip hydration.</span>
      <span class="s0">// Delay having to do this as long as the suspense timeout allows us.</span>

      <span class="s1">renderDidSuspendDelayIfPossible();</span>

      <span class="s3">var </span><span class="s1">_capturedValue = createCapturedValue(</span>
        <span class="s3">new </span><span class="s1">Error(</span>
          <span class="s2">&quot;This Suspense boundary received an update before it finished &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;hydrating. This caused the boundary to switch to client rendering. &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;The usual way to fix this is to wrap the original update &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;in startTransition.&quot;</span>
        <span class="s1">)</span>
      <span class="s1">);</span>

      <span class="s3">return </span><span class="s1">retrySuspenseComponentWithoutHydrating(</span>
        <span class="s1">current,</span>
        <span class="s1">workInProgress,</span>
        <span class="s1">renderLanes,</span>
        <span class="s1">_capturedValue</span>
      <span class="s1">);</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(isSuspenseInstancePending()) {</span>
      <span class="s0">// This component is still pending more data from the server, so we can't hydrate its</span>
      <span class="s0">// content. We treat it as if this component suspended itself. It might seem as if</span>
      <span class="s0">// we could just try to render it client-side instead. However, this will perform a</span>
      <span class="s0">// lot of unnecessary work and is unlikely to complete since it often will suspend</span>
      <span class="s0">// on missing data anyway. Additionally, the server might be able to render more</span>
      <span class="s0">// than we can on the client yet. In that case we'd end up with more fallback states</span>
      <span class="s0">// on the client than if we just leave it alone. If the server times out or errors</span>
      <span class="s0">// these should update this boundary to the permanent Fallback state instead.</span>
      <span class="s0">// Mark it as having captured (i.e. suspended).</span>
      <span class="s1">workInProgress.flags |= DidCapture; </span><span class="s0">// Leave the child in place. I.e. the dehydrated fragment.</span>

      <span class="s1">workInProgress.child = current.child; </span><span class="s0">// Register a callback to retry this boundary once the server has sent the result.</span>

      <span class="s3">var </span><span class="s1">retry = retryDehydratedSuspenseBoundary.bind(</span><span class="s3">null</span><span class="s1">, current);</span>
      <span class="s1">registerSuspenseInstanceRetry();</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s0">// This is the first attempt.</span>
      <span class="s1">reenterHydrationStateFromDehydratedSuspenseInstance(</span>
        <span class="s1">workInProgress,</span>
        <span class="s1">suspenseInstance,</span>
        <span class="s1">suspenseState.treeContext</span>
      <span class="s1">);</span>
      <span class="s3">var </span><span class="s1">primaryChildren = nextProps.children;</span>
      <span class="s3">var </span><span class="s1">primaryChildFragment = mountSuspensePrimaryChildren(</span>
        <span class="s1">workInProgress,</span>
        <span class="s1">primaryChildren</span>
      <span class="s1">); </span><span class="s0">// Mark the children as hydrating. This is a fast path to know whether this</span>
      <span class="s0">// tree is part of a hydrating tree. This is used to determine if a child</span>
      <span class="s0">// node has fully mounted yet, and for scheduling event replaying.</span>
      <span class="s0">// Conceptually this is similar to Placement in that a new subtree is</span>
      <span class="s0">// inserted into the React tree here. It just happens to not need DOM</span>
      <span class="s0">// mutations because it already exists.</span>

      <span class="s1">primaryChildFragment.flags |= Hydrating;</span>
      <span class="s3">return </span><span class="s1">primaryChildFragment;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s0">// This is the second render pass. We already attempted to hydrated, but</span>
    <span class="s0">// something either suspended or errored.</span>
    <span class="s3">if </span><span class="s1">(workInProgress.flags &amp; ForceClientRender) {</span>
      <span class="s0">// Something errored during hydration. Try again without hydrating.</span>
      <span class="s1">workInProgress.flags &amp;= ~ForceClientRender;</span>

      <span class="s3">var </span><span class="s1">_capturedValue2 = createCapturedValue(</span>
        <span class="s3">new </span><span class="s1">Error(</span>
          <span class="s2">&quot;There was an error while hydrating this Suspense boundary. &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;Switched to client rendering.&quot;</span>
        <span class="s1">)</span>
      <span class="s1">);</span>

      <span class="s3">return </span><span class="s1">retrySuspenseComponentWithoutHydrating(</span>
        <span class="s1">current,</span>
        <span class="s1">workInProgress,</span>
        <span class="s1">renderLanes,</span>
        <span class="s1">_capturedValue2</span>
      <span class="s1">);</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(workInProgress.memoizedState !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// Something suspended and we should still be in dehydrated mode.</span>
      <span class="s0">// Leave the existing child in place.</span>
      <span class="s1">workInProgress.child = current.child; </span><span class="s0">// The dehydrated completion pass expects this flag to be there</span>
      <span class="s0">// but the normal suspense pass doesn't.</span>

      <span class="s1">workInProgress.flags |= DidCapture;</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s0">// Suspended but we should no longer be in dehydrated mode.</span>
      <span class="s0">// Therefore we now have to render the fallback.</span>
      <span class="s3">var </span><span class="s1">nextPrimaryChildren = nextProps.children;</span>
      <span class="s3">var </span><span class="s1">nextFallbackChildren = nextProps.fallback;</span>
      <span class="s3">var </span><span class="s1">fallbackChildFragment = mountSuspenseFallbackAfterRetryWithoutHydrating(</span>
        <span class="s1">current,</span>
        <span class="s1">workInProgress,</span>
        <span class="s1">nextPrimaryChildren,</span>
        <span class="s1">nextFallbackChildren,</span>
        <span class="s1">renderLanes</span>
      <span class="s1">);</span>
      <span class="s3">var </span><span class="s1">_primaryChildFragment4 = workInProgress.child;</span>
      <span class="s1">_primaryChildFragment4.memoizedState = mountSuspenseOffscreenState(</span>
        <span class="s1">renderLanes</span>
      <span class="s1">);</span>
      <span class="s1">workInProgress.memoizedState = SUSPENDED_MARKER;</span>
      <span class="s3">return </span><span class="s1">fallbackChildFragment;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">scheduleSuspenseWorkOnFiber(fiber, renderLanes, propagationRoot) {</span>
  <span class="s1">fiber.lanes = mergeLanes(fiber.lanes, renderLanes);</span>
  <span class="s3">var </span><span class="s1">alternate = fiber.alternate;</span>

  <span class="s3">if </span><span class="s1">(alternate !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s1">alternate.lanes = mergeLanes(alternate.lanes, renderLanes);</span>
  <span class="s1">}</span>

  <span class="s1">scheduleContextWorkOnParentPath(fiber.</span><span class="s3">return</span><span class="s1">, renderLanes, propagationRoot);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">propagateSuspenseContextChange(</span>
  <span class="s1">workInProgress,</span>
  <span class="s1">firstChild,</span>
  <span class="s1">renderLanes</span>
<span class="s1">) {</span>
  <span class="s0">// Mark any Suspense boundaries with fallbacks as having work to do.</span>
  <span class="s0">// If they were previously forced into fallbacks, they may now be able</span>
  <span class="s0">// to unblock.</span>
  <span class="s3">var </span><span class="s1">node = firstChild;</span>

  <span class="s3">while </span><span class="s1">(node !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">if </span><span class="s1">(node.tag === SuspenseComponent) {</span>
      <span class="s3">var </span><span class="s1">state = node.memoizedState;</span>

      <span class="s3">if </span><span class="s1">(state !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">scheduleSuspenseWorkOnFiber(node, renderLanes, workInProgress);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(node.tag === SuspenseListComponent) {</span>
      <span class="s0">// If the tail is hidden there might not be an Suspense boundaries</span>
      <span class="s0">// to schedule work on. In this case we have to schedule it on the</span>
      <span class="s0">// list itself.</span>
      <span class="s0">// We don't have to traverse to the children of the list since</span>
      <span class="s0">// the list will propagate the change when it rerenders.</span>
      <span class="s1">scheduleSuspenseWorkOnFiber(node, renderLanes, workInProgress);</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(node.child !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">node.child.</span><span class="s3">return </span><span class="s1">= node;</span>
      <span class="s1">node = node.child;</span>
      <span class="s3">continue</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(node === workInProgress) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">while </span><span class="s1">(node.sibling === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(node.</span><span class="s3">return </span><span class="s1">=== </span><span class="s3">null </span><span class="s1">|| node.</span><span class="s3">return </span><span class="s1">=== workInProgress) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">node = node.</span><span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">node.sibling.</span><span class="s3">return </span><span class="s1">= node.</span><span class="s3">return</span><span class="s1">;</span>
    <span class="s1">node = node.sibling;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">findLastContentRow(firstChild) {</span>
  <span class="s0">// This is going to find the last row among these children that is already</span>
  <span class="s0">// showing content on the screen, as opposed to being in fallback state or</span>
  <span class="s0">// new. If a row has multiple Suspense boundaries, any of them being in the</span>
  <span class="s0">// fallback state, counts as the whole row being in a fallback state.</span>
  <span class="s0">// Note that the &quot;rows&quot; will be workInProgress, but any nested children</span>
  <span class="s0">// will still be current since we haven't rendered them yet. The mounted</span>
  <span class="s0">// order may not be the same as the new order. We use the new order.</span>
  <span class="s3">var </span><span class="s1">row = firstChild;</span>
  <span class="s3">var </span><span class="s1">lastContentRow = </span><span class="s3">null</span><span class="s1">;</span>

  <span class="s3">while </span><span class="s1">(row !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">currentRow = row.alternate; </span><span class="s0">// New rows can't be content rows.</span>

    <span class="s3">if </span><span class="s1">(currentRow !== </span><span class="s3">null </span><span class="s1">&amp;&amp; findFirstSuspended(currentRow) === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">lastContentRow = row;</span>
    <span class="s1">}</span>

    <span class="s1">row = row.sibling;</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">lastContentRow;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">validateRevealOrder(revealOrder) {</span>
  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(</span>
      <span class="s1">revealOrder !== undefined &amp;&amp;</span>
      <span class="s1">revealOrder !== </span><span class="s2">&quot;forwards&quot; </span><span class="s1">&amp;&amp;</span>
      <span class="s1">revealOrder !== </span><span class="s2">&quot;backwards&quot; </span><span class="s1">&amp;&amp;</span>
      <span class="s1">revealOrder !== </span><span class="s2">&quot;together&quot; </span><span class="s1">&amp;&amp;</span>
      <span class="s1">!didWarnAboutRevealOrder[revealOrder]</span>
    <span class="s1">) {</span>
      <span class="s1">didWarnAboutRevealOrder[revealOrder] = </span><span class="s3">true</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">revealOrder === </span><span class="s2">&quot;string&quot;</span><span class="s1">) {</span>
        <span class="s3">switch </span><span class="s1">(revealOrder.toLowerCase()) {</span>
          <span class="s3">case </span><span class="s2">&quot;together&quot;</span><span class="s1">:</span>
          <span class="s3">case </span><span class="s2">&quot;forwards&quot;</span><span class="s1">:</span>
          <span class="s3">case </span><span class="s2">&quot;backwards&quot;</span><span class="s1">: {</span>
            <span class="s1">error(</span>
              <span class="s2">'&quot;%s&quot; is not a valid value for revealOrder on &lt;SuspenseList /&gt;. ' </span><span class="s1">+</span>
                <span class="s2">'Use lowercase &quot;%s&quot; instead.'</span><span class="s1">,</span>
              <span class="s1">revealOrder,</span>
              <span class="s1">revealOrder.toLowerCase()</span>
            <span class="s1">);</span>

            <span class="s3">break</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s3">case </span><span class="s2">&quot;forward&quot;</span><span class="s1">:</span>
          <span class="s3">case </span><span class="s2">&quot;backward&quot;</span><span class="s1">: {</span>
            <span class="s1">error(</span>
              <span class="s2">'&quot;%s&quot; is not a valid value for revealOrder on &lt;SuspenseList /&gt;. ' </span><span class="s1">+</span>
                <span class="s2">'React uses the -s suffix in the spelling. Use &quot;%ss&quot; instead.'</span><span class="s1">,</span>
              <span class="s1">revealOrder,</span>
              <span class="s1">revealOrder.toLowerCase()</span>
            <span class="s1">);</span>

            <span class="s3">break</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s3">default</span><span class="s1">:</span>
            <span class="s1">error(</span>
              <span class="s2">'&quot;%s&quot; is not a supported revealOrder on &lt;SuspenseList /&gt;. ' </span><span class="s1">+</span>
                <span class="s2">'Did you mean &quot;together&quot;, &quot;forwards&quot; or &quot;backwards&quot;?'</span><span class="s1">,</span>
              <span class="s1">revealOrder</span>
            <span class="s1">);</span>

            <span class="s3">break</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">error(</span>
          <span class="s2">&quot;%s is not a supported value for revealOrder on &lt;SuspenseList /&gt;. &quot; </span><span class="s1">+</span>
            <span class="s2">'Did you mean &quot;together&quot;, &quot;forwards&quot; or &quot;backwards&quot;?'</span><span class="s1">,</span>
          <span class="s1">revealOrder</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">validateTailOptions(tailMode, revealOrder) {</span>
  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(tailMode !== undefined &amp;&amp; !didWarnAboutTailOptions[tailMode]) {</span>
      <span class="s3">if </span><span class="s1">(tailMode !== </span><span class="s2">&quot;collapsed&quot; </span><span class="s1">&amp;&amp; tailMode !== </span><span class="s2">&quot;hidden&quot;</span><span class="s1">) {</span>
        <span class="s1">didWarnAboutTailOptions[tailMode] = </span><span class="s3">true</span><span class="s1">;</span>

        <span class="s1">error(</span>
          <span class="s2">'&quot;%s&quot; is not a supported value for tail on &lt;SuspenseList /&gt;. ' </span><span class="s1">+</span>
            <span class="s2">'Did you mean &quot;collapsed&quot; or &quot;hidden&quot;?'</span><span class="s1">,</span>
          <span class="s1">tailMode</span>
        <span class="s1">);</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(revealOrder !== </span><span class="s2">&quot;forwards&quot; </span><span class="s1">&amp;&amp; revealOrder !== </span><span class="s2">&quot;backwards&quot;</span><span class="s1">) {</span>
        <span class="s1">didWarnAboutTailOptions[tailMode] = </span><span class="s3">true</span><span class="s1">;</span>

        <span class="s1">error(</span>
          <span class="s2">'&lt;SuspenseList tail=&quot;%s&quot; /&gt; is only valid if revealOrder is ' </span><span class="s1">+</span>
            <span class="s2">'&quot;forwards&quot; or &quot;backwards&quot;. ' </span><span class="s1">+</span>
            <span class="s2">'Did you mean to specify revealOrder=&quot;forwards&quot;?'</span><span class="s1">,</span>
          <span class="s1">tailMode</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">validateSuspenseListNestedChild(childSlot, index) {</span>
  <span class="s1">{</span>
    <span class="s3">var </span><span class="s1">isAnArray = isArray(childSlot);</span>
    <span class="s3">var </span><span class="s1">isIterable =</span>
      <span class="s1">!isAnArray &amp;&amp; </span><span class="s3">typeof </span><span class="s1">getIteratorFn(childSlot) === </span><span class="s2">&quot;function&quot;</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s1">(isAnArray || isIterable) {</span>
      <span class="s3">var </span><span class="s1">type = isAnArray ? </span><span class="s2">&quot;array&quot; </span><span class="s1">: </span><span class="s2">&quot;iterable&quot;</span><span class="s1">;</span>

      <span class="s1">error(</span>
        <span class="s2">&quot;A nested %s was passed to row #%s in &lt;SuspenseList /&gt;. Wrap it in &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;an additional SuspenseList to configure its revealOrder: &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;&lt;SuspenseList revealOrder=...&gt; ... &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;&lt;SuspenseList revealOrder=...&gt;{%s}&lt;/SuspenseList&gt; ... &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;&lt;/SuspenseList&gt;&quot;</span><span class="s1">,</span>
        <span class="s1">type,</span>
        <span class="s1">index,</span>
        <span class="s1">type</span>
      <span class="s1">);</span>

      <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">return true</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">validateSuspenseListChildren(children, revealOrder) {</span>
  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(</span>
      <span class="s1">(revealOrder === </span><span class="s2">&quot;forwards&quot; </span><span class="s1">|| revealOrder === </span><span class="s2">&quot;backwards&quot;</span><span class="s1">) &amp;&amp;</span>
      <span class="s1">children !== undefined &amp;&amp;</span>
      <span class="s1">children !== </span><span class="s3">null </span><span class="s1">&amp;&amp;</span>
      <span class="s1">children !== </span><span class="s3">false</span>
    <span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(isArray(children)) {</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; children.length; i++) {</span>
          <span class="s3">if </span><span class="s1">(!validateSuspenseListNestedChild(children[i], i)) {</span>
            <span class="s3">return</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s3">var </span><span class="s1">iteratorFn = getIteratorFn(children);</span>

        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">iteratorFn === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
          <span class="s3">var </span><span class="s1">childrenIterator = iteratorFn.call(children);</span>

          <span class="s3">if </span><span class="s1">(childrenIterator) {</span>
            <span class="s3">var </span><span class="s1">step = childrenIterator.next();</span>
            <span class="s3">var </span><span class="s1">_i = </span><span class="s4">0</span><span class="s1">;</span>

            <span class="s3">for </span><span class="s1">(; !step.done; step = childrenIterator.next()) {</span>
              <span class="s3">if </span><span class="s1">(!validateSuspenseListNestedChild(step.value, _i)) {</span>
                <span class="s3">return</span><span class="s1">;</span>
              <span class="s1">}</span>

              <span class="s1">_i++;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s1">error(</span>
            <span class="s2">'A single row was passed to a &lt;SuspenseList revealOrder=&quot;%s&quot; /&gt;. ' </span><span class="s1">+</span>
              <span class="s2">&quot;This is not useful since it needs multiple rows. &quot; </span><span class="s1">+</span>
              <span class="s2">&quot;Did you mean to pass multiple children or an array?&quot;</span><span class="s1">,</span>
            <span class="s1">revealOrder</span>
          <span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">initSuspenseListRenderState(</span>
  <span class="s1">workInProgress,</span>
  <span class="s1">isBackwards,</span>
  <span class="s1">tail,</span>
  <span class="s1">lastContentRow,</span>
  <span class="s1">tailMode</span>
<span class="s1">) {</span>
  <span class="s3">var </span><span class="s1">renderState = workInProgress.memoizedState;</span>

  <span class="s3">if </span><span class="s1">(renderState === </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s1">workInProgress.memoizedState = {</span>
      <span class="s1">isBackwards: isBackwards,</span>
      <span class="s1">rendering: </span><span class="s3">null</span><span class="s1">,</span>
      <span class="s1">renderingStartTime: </span><span class="s4">0</span><span class="s1">,</span>
      <span class="s1">last: lastContentRow,</span>
      <span class="s1">tail: tail,</span>
      <span class="s1">tailMode: tailMode</span>
    <span class="s1">};</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s0">// We can reuse the existing object from previous renders.</span>
    <span class="s1">renderState.isBackwards = isBackwards;</span>
    <span class="s1">renderState.rendering = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">renderState.renderingStartTime = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">renderState.last = lastContentRow;</span>
    <span class="s1">renderState.tail = tail;</span>
    <span class="s1">renderState.tailMode = tailMode;</span>
  <span class="s1">}</span>
<span class="s1">} </span><span class="s0">// This can end up rendering this component multiple passes.</span>
<span class="s0">// The first pass splits the children fibers into two sets. A head and tail.</span>
<span class="s0">// We first render the head. If anything is in fallback state, we do another</span>
<span class="s0">// pass through beginWork to rerender all children (including the tail) with</span>
<span class="s0">// the force suspend context. If the first render didn't have anything in</span>
<span class="s0">// in fallback state. Then we render each row in the tail one-by-one.</span>
<span class="s0">// That happens in the completeWork phase without going back to beginWork.</span>

<span class="s3">function </span><span class="s1">updateSuspenseListComponent(current, workInProgress, renderLanes) {</span>
  <span class="s3">var </span><span class="s1">nextProps = workInProgress.pendingProps;</span>
  <span class="s3">var </span><span class="s1">revealOrder = nextProps.revealOrder;</span>
  <span class="s3">var </span><span class="s1">tailMode = nextProps.tail;</span>
  <span class="s3">var </span><span class="s1">newChildren = nextProps.children;</span>
  <span class="s1">validateRevealOrder(revealOrder);</span>
  <span class="s1">validateTailOptions(tailMode, revealOrder);</span>
  <span class="s1">validateSuspenseListChildren(newChildren, revealOrder);</span>
  <span class="s1">reconcileChildren(current, workInProgress, newChildren, renderLanes);</span>
  <span class="s3">var </span><span class="s1">suspenseContext = suspenseStackCursor.current;</span>
  <span class="s3">var </span><span class="s1">shouldForceFallback = hasSuspenseContext(</span>
    <span class="s1">suspenseContext,</span>
    <span class="s1">ForceSuspenseFallback</span>
  <span class="s1">);</span>

  <span class="s3">if </span><span class="s1">(shouldForceFallback) {</span>
    <span class="s1">suspenseContext = setShallowSuspenseContext(</span>
      <span class="s1">suspenseContext,</span>
      <span class="s1">ForceSuspenseFallback</span>
    <span class="s1">);</span>
    <span class="s1">workInProgress.flags |= DidCapture;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s3">var </span><span class="s1">didSuspendBefore =</span>
      <span class="s1">current !== </span><span class="s3">null </span><span class="s1">&amp;&amp; (current.flags &amp; DidCapture) !== NoFlags;</span>

    <span class="s3">if </span><span class="s1">(didSuspendBefore) {</span>
      <span class="s0">// If we previously forced a fallback, we need to schedule work</span>
      <span class="s0">// on any nested boundaries to let them know to try to render</span>
      <span class="s0">// again. This is the same as context updating.</span>
      <span class="s1">propagateSuspenseContextChange(</span>
        <span class="s1">workInProgress,</span>
        <span class="s1">workInProgress.child,</span>
        <span class="s1">renderLanes</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s1">suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);</span>
  <span class="s1">}</span>

  <span class="s1">pushSuspenseContext(workInProgress, suspenseContext);</span>

  <span class="s3">if </span><span class="s1">((workInProgress.mode &amp; ConcurrentMode) === NoMode) {</span>
    <span class="s0">// In legacy mode, SuspenseList doesn't work so we just</span>
    <span class="s0">// use make it a noop by treating it as the default revealOrder.</span>
    <span class="s1">workInProgress.memoizedState = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s3">switch </span><span class="s1">(revealOrder) {</span>
      <span class="s3">case </span><span class="s2">&quot;forwards&quot;</span><span class="s1">: {</span>
        <span class="s3">var </span><span class="s1">lastContentRow = findLastContentRow(workInProgress.child);</span>
        <span class="s3">var </span><span class="s1">tail;</span>

        <span class="s3">if </span><span class="s1">(lastContentRow === </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s0">// The whole list is part of the tail.</span>
          <span class="s0">// TODO: We could fast path by just rendering the tail now.</span>
          <span class="s1">tail = workInProgress.child;</span>
          <span class="s1">workInProgress.child = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s0">// Disconnect the tail rows after the content row.</span>
          <span class="s0">// We're going to render them separately later.</span>
          <span class="s1">tail = lastContentRow.sibling;</span>
          <span class="s1">lastContentRow.sibling = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">initSuspenseListRenderState(</span>
          <span class="s1">workInProgress,</span>
          <span class="s3">false</span><span class="s1">, </span><span class="s0">// isBackwards</span>
          <span class="s1">tail,</span>
          <span class="s1">lastContentRow,</span>
          <span class="s1">tailMode</span>
        <span class="s1">);</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">case </span><span class="s2">&quot;backwards&quot;</span><span class="s1">: {</span>
        <span class="s0">// We're going to find the first row that has existing content.</span>
        <span class="s0">// At the same time we're going to reverse the list of everything</span>
        <span class="s0">// we pass in the meantime. That's going to be our tail in reverse</span>
        <span class="s0">// order.</span>
        <span class="s3">var </span><span class="s1">_tail = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s3">var </span><span class="s1">row = workInProgress.child;</span>
        <span class="s1">workInProgress.child = </span><span class="s3">null</span><span class="s1">;</span>

        <span class="s3">while </span><span class="s1">(row !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s3">var </span><span class="s1">currentRow = row.alternate; </span><span class="s0">// New rows can't be content rows.</span>

          <span class="s3">if </span><span class="s1">(currentRow !== </span><span class="s3">null </span><span class="s1">&amp;&amp; findFirstSuspended(currentRow) === </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s0">// This is the beginning of the main content.</span>
            <span class="s1">workInProgress.child = row;</span>
            <span class="s3">break</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s3">var </span><span class="s1">nextRow = row.sibling;</span>
          <span class="s1">row.sibling = _tail;</span>
          <span class="s1">_tail = row;</span>
          <span class="s1">row = nextRow;</span>
        <span class="s1">} </span><span class="s0">// TODO: If workInProgress.child is null, we can continue on the tail immediately.</span>

        <span class="s1">initSuspenseListRenderState(</span>
          <span class="s1">workInProgress,</span>
          <span class="s3">true</span><span class="s1">, </span><span class="s0">// isBackwards</span>
          <span class="s1">_tail,</span>
          <span class="s3">null</span><span class="s1">, </span><span class="s0">// last</span>
          <span class="s1">tailMode</span>
        <span class="s1">);</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">case </span><span class="s2">&quot;together&quot;</span><span class="s1">: {</span>
        <span class="s1">initSuspenseListRenderState(</span>
          <span class="s1">workInProgress,</span>
          <span class="s3">false</span><span class="s1">, </span><span class="s0">// isBackwards</span>
          <span class="s3">null</span><span class="s1">, </span><span class="s0">// tail</span>
          <span class="s3">null</span><span class="s1">, </span><span class="s0">// last</span>
          <span class="s1">undefined</span>
        <span class="s1">);</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">default</span><span class="s1">: {</span>
        <span class="s0">// The default reveal order is the same as not having</span>
        <span class="s0">// a boundary.</span>
        <span class="s1">workInProgress.memoizedState = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">workInProgress.child;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">updatePortalComponent(current, workInProgress, renderLanes) {</span>
  <span class="s1">pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);</span>
  <span class="s3">var </span><span class="s1">nextChildren = workInProgress.pendingProps;</span>

  <span class="s3">if </span><span class="s1">(current === </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s0">// Portals are special because we don't append the children during mount</span>
    <span class="s0">// but at commit. Therefore we need to track insertions which the normal</span>
    <span class="s0">// flow doesn't do during mount. This doesn't happen at the root because</span>
    <span class="s0">// the root always starts with a &quot;current&quot; with a null child.</span>
    <span class="s0">// TODO: Consider unifying this with how the root works.</span>
    <span class="s1">workInProgress.child = reconcileChildFibers(</span>
      <span class="s1">workInProgress,</span>
      <span class="s3">null</span><span class="s1">,</span>
      <span class="s1">nextChildren,</span>
      <span class="s1">renderLanes</span>
    <span class="s1">);</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">reconcileChildren(current, workInProgress, nextChildren, renderLanes);</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">workInProgress.child;</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">hasWarnedAboutUsingNoValuePropOnContextProvider = </span><span class="s3">false</span><span class="s1">;</span>

<span class="s3">function </span><span class="s1">updateContextProvider(current, workInProgress, renderLanes) {</span>
  <span class="s3">var </span><span class="s1">providerType = workInProgress.type;</span>
  <span class="s3">var </span><span class="s1">context = providerType._context;</span>
  <span class="s3">var </span><span class="s1">newProps = workInProgress.pendingProps;</span>
  <span class="s3">var </span><span class="s1">oldProps = workInProgress.memoizedProps;</span>
  <span class="s3">var </span><span class="s1">newValue = newProps.value;</span>

  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(!(</span><span class="s2">&quot;value&quot; </span><span class="s3">in </span><span class="s1">newProps)) {</span>
      <span class="s3">if </span><span class="s1">(!hasWarnedAboutUsingNoValuePropOnContextProvider) {</span>
        <span class="s1">hasWarnedAboutUsingNoValuePropOnContextProvider = </span><span class="s3">true</span><span class="s1">;</span>

        <span class="s1">error(</span>
          <span class="s2">&quot;The `value` prop is required for the `&lt;Context.Provider&gt;`. Did you misspell it or forget to pass it?&quot;</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">providerPropTypes = workInProgress.type.propTypes;</span>

    <span class="s3">if </span><span class="s1">(providerPropTypes) {</span>
      <span class="s1">checkPropTypes(providerPropTypes, newProps, </span><span class="s2">&quot;prop&quot;</span><span class="s1">, </span><span class="s2">&quot;Context.Provider&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">pushProvider(workInProgress, context, newValue);</span>

  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(oldProps !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">oldValue = oldProps.value;</span>

      <span class="s3">if </span><span class="s1">(objectIs(oldValue, newValue)) {</span>
        <span class="s0">// No change. Bailout early if children are the same.</span>
        <span class="s3">if </span><span class="s1">(oldProps.children === newProps.children &amp;&amp; !hasContextChanged()) {</span>
          <span class="s3">return </span><span class="s1">bailoutOnAlreadyFinishedWork(</span>
            <span class="s1">current,</span>
            <span class="s1">workInProgress,</span>
            <span class="s1">renderLanes</span>
          <span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s0">// The context value changed. Search for matching consumers and schedule</span>
        <span class="s0">// them to update.</span>
        <span class="s1">propagateContextChange(workInProgress, context, renderLanes);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">newChildren = newProps.children;</span>
  <span class="s1">reconcileChildren(current, workInProgress, newChildren, renderLanes);</span>
  <span class="s3">return </span><span class="s1">workInProgress.child;</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">hasWarnedAboutUsingContextAsConsumer = </span><span class="s3">false</span><span class="s1">;</span>

<span class="s3">function </span><span class="s1">updateContextConsumer(current, workInProgress, renderLanes) {</span>
  <span class="s3">var </span><span class="s1">context = workInProgress.type; </span><span class="s0">// The logic below for Context differs depending on PROD or DEV mode. In</span>
  <span class="s0">// DEV mode, we create a separate object for Context.Consumer that acts</span>
  <span class="s0">// like a proxy to Context. This proxy object adds unnecessary code in PROD</span>
  <span class="s0">// so we use the old behaviour (Context.Consumer references Context) to</span>
  <span class="s0">// reduce size and overhead. The separate object references context via</span>
  <span class="s0">// a property called &quot;_context&quot;, which also gives us the ability to check</span>
  <span class="s0">// in DEV mode if this property exists or not and warn if it does not.</span>

  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(context._context === undefined) {</span>
      <span class="s0">// This may be because it's a Context (rather than a Consumer).</span>
      <span class="s0">// Or it may be because it's older React where they're the same thing.</span>
      <span class="s0">// We only want to warn if we're sure it's a new React.</span>
      <span class="s3">if </span><span class="s1">(context !== context.Consumer) {</span>
        <span class="s3">if </span><span class="s1">(!hasWarnedAboutUsingContextAsConsumer) {</span>
          <span class="s1">hasWarnedAboutUsingContextAsConsumer = </span><span class="s3">true</span><span class="s1">;</span>

          <span class="s1">error(</span>
            <span class="s2">&quot;Rendering &lt;Context&gt; directly is not supported and will be removed in &quot; </span><span class="s1">+</span>
              <span class="s2">&quot;a future major release. Did you mean to render &lt;Context.Consumer&gt; instead?&quot;</span>
          <span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">context = context._context;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">newProps = workInProgress.pendingProps;</span>
  <span class="s3">var </span><span class="s1">render = newProps.children;</span>

  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">render !== </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
      <span class="s1">error(</span>
        <span class="s2">&quot;A context consumer was rendered with multiple children, or a child &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;that isn't a function. A context consumer expects a single child &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;that is a function. If you did pass a function, make sure there &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;is no trailing or leading whitespace around it.&quot;</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">prepareToReadContext(workInProgress, renderLanes);</span>
  <span class="s3">var </span><span class="s1">newValue = readContext(context);</span>

  <span class="s3">var </span><span class="s1">newChildren;</span>

  <span class="s1">{</span>
    <span class="s1">ReactCurrentOwner$1.current = workInProgress;</span>
    <span class="s1">setIsRendering(</span><span class="s3">true</span><span class="s1">);</span>
    <span class="s1">newChildren = render(newValue);</span>
    <span class="s1">setIsRendering(</span><span class="s3">false</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s1">workInProgress.flags |= PerformedWork;</span>
  <span class="s1">reconcileChildren(current, workInProgress, newChildren, renderLanes);</span>
  <span class="s3">return </span><span class="s1">workInProgress.child;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">markWorkInProgressReceivedUpdate() {</span>
  <span class="s1">didReceiveUpdate = </span><span class="s3">true</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">resetSuspendedCurrentOnMountInLegacyMode(current, workInProgress) {</span>
  <span class="s3">if </span><span class="s1">((workInProgress.mode &amp; ConcurrentMode) === NoMode) {</span>
    <span class="s3">if </span><span class="s1">(current !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// A lazy component only mounts if it suspended inside a non-</span>
      <span class="s0">// concurrent tree, in an inconsistent state. We want to treat it like</span>
      <span class="s0">// a new mount, even though an empty version of it already committed.</span>
      <span class="s0">// Disconnect the alternate pointers.</span>
      <span class="s1">current.alternate = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">workInProgress.alternate = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// Since this is conceptually a new fiber, schedule a Placement effect</span>

      <span class="s1">workInProgress.flags |= Placement;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {</span>
  <span class="s3">if </span><span class="s1">(current !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s0">// Reuse previous dependencies</span>
    <span class="s1">workInProgress.dependencies = current.dependencies;</span>
  <span class="s1">}</span>

  <span class="s1">{</span>
    <span class="s0">// Don't update &quot;base&quot; render times for bailouts.</span>
    <span class="s1">stopProfilerTimerIfRunning();</span>
  <span class="s1">}</span>

  <span class="s1">markSkippedUpdateLanes(workInProgress.lanes); </span><span class="s0">// Check if the children have any pending work.</span>

  <span class="s3">if </span><span class="s1">(!includesSomeLane(renderLanes, workInProgress.childLanes)) {</span>
    <span class="s0">// The children don't have any work either. We can skip them.</span>
    <span class="s0">// TODO: Once we add back resuming, we should check if the children are</span>
    <span class="s0">// a work-in-progress set. If so, we need to transfer their effects.</span>
    <span class="s1">{</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s0">// This fiber doesn't have work, but its subtree does. Clone the child</span>
  <span class="s0">// fibers and continue.</span>

  <span class="s1">cloneChildFibers(current, workInProgress);</span>
  <span class="s3">return </span><span class="s1">workInProgress.child;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">remountFiber(current, oldWorkInProgress, newWorkInProgress) {</span>
  <span class="s1">{</span>
    <span class="s3">var </span><span class="s1">returnFiber = oldWorkInProgress.</span><span class="s3">return</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s1">(returnFiber === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// eslint-disable-next-line react-internal/prod-error-codes</span>
      <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Cannot swap the root fiber.&quot;</span><span class="s1">);</span>
    <span class="s1">} </span><span class="s0">// Disconnect from the old current.</span>
    <span class="s0">// It will get deleted.</span>

    <span class="s1">current.alternate = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">oldWorkInProgress.alternate = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// Connect to the new tree.</span>

    <span class="s1">newWorkInProgress.index = oldWorkInProgress.index;</span>
    <span class="s1">newWorkInProgress.sibling = oldWorkInProgress.sibling;</span>
    <span class="s1">newWorkInProgress.</span><span class="s3">return </span><span class="s1">= oldWorkInProgress.</span><span class="s3">return</span><span class="s1">;</span>
    <span class="s1">newWorkInProgress.ref = oldWorkInProgress.ref; </span><span class="s0">// Replace the child/sibling pointers above it.</span>

    <span class="s3">if </span><span class="s1">(oldWorkInProgress === returnFiber.child) {</span>
      <span class="s1">returnFiber.child = newWorkInProgress;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">var </span><span class="s1">prevSibling = returnFiber.child;</span>

      <span class="s3">if </span><span class="s1">(prevSibling === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s0">// eslint-disable-next-line react-internal/prod-error-codes</span>
        <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Expected parent to have a child.&quot;</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s3">while </span><span class="s1">(prevSibling.sibling !== oldWorkInProgress) {</span>
        <span class="s1">prevSibling = prevSibling.sibling;</span>

        <span class="s3">if </span><span class="s1">(prevSibling === </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s0">// eslint-disable-next-line react-internal/prod-error-codes</span>
          <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Expected to find the previous sibling.&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">prevSibling.sibling = newWorkInProgress;</span>
    <span class="s1">} </span><span class="s0">// Delete the old fiber and place the new one.</span>
    <span class="s0">// Since the old fiber is disconnected, we have to schedule it manually.</span>

    <span class="s3">var </span><span class="s1">deletions = returnFiber.deletions;</span>

    <span class="s3">if </span><span class="s1">(deletions === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">returnFiber.deletions = [current];</span>
      <span class="s1">returnFiber.flags |= ChildDeletion;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">deletions.push(current);</span>
    <span class="s1">}</span>

    <span class="s1">newWorkInProgress.flags |= Placement; </span><span class="s0">// Restart work from the new fiber.</span>

    <span class="s3">return </span><span class="s1">newWorkInProgress;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">checkScheduledUpdateOrContext(current, renderLanes) {</span>
  <span class="s0">// Before performing an early bailout, we must check if there are pending</span>
  <span class="s0">// updates or context.</span>
  <span class="s3">var </span><span class="s1">updateLanes = current.lanes;</span>

  <span class="s3">if </span><span class="s1">(includesSomeLane(updateLanes, renderLanes)) {</span>
    <span class="s3">return true</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s0">// No pending update, but because context is propagated lazily, we need</span>

  <span class="s3">return false</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">attemptEarlyBailoutIfNoScheduledUpdate(</span>
  <span class="s1">current,</span>
  <span class="s1">workInProgress,</span>
  <span class="s1">renderLanes</span>
<span class="s1">) {</span>
  <span class="s0">// This fiber does not have any pending work. Bailout without entering</span>
  <span class="s0">// the begin phase. There's still some bookkeeping we that needs to be done</span>
  <span class="s0">// in this optimized path, mostly pushing stuff onto the stack.</span>
  <span class="s3">switch </span><span class="s1">(workInProgress.tag) {</span>
    <span class="s3">case </span><span class="s1">HostRoot:</span>
      <span class="s1">pushHostRootContext(workInProgress);</span>
      <span class="s3">var </span><span class="s1">root = workInProgress.stateNode;</span>
      <span class="s3">break</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s1">HostComponent:</span>
      <span class="s1">pushHostContext(workInProgress);</span>
      <span class="s3">break</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s1">ClassComponent: {</span>
      <span class="s3">var </span><span class="s1">Component = workInProgress.type;</span>

      <span class="s3">if </span><span class="s1">(isContextProvider(Component)) {</span>
        <span class="s1">pushContextProvider(workInProgress);</span>
      <span class="s1">}</span>

      <span class="s3">break</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">case </span><span class="s1">HostPortal:</span>
      <span class="s1">pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);</span>
      <span class="s3">break</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s1">ContextProvider: {</span>
      <span class="s3">var </span><span class="s1">newValue = workInProgress.memoizedProps.value;</span>
      <span class="s3">var </span><span class="s1">context = workInProgress.type._context;</span>
      <span class="s1">pushProvider(workInProgress, context, newValue);</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">case </span><span class="s1">Profiler:</span>
      <span class="s1">{</span>
        <span class="s0">// Profiler should only call onRender when one of its descendants actually rendered.</span>
        <span class="s3">var </span><span class="s1">hasChildWork = includesSomeLane(</span>
          <span class="s1">renderLanes,</span>
          <span class="s1">workInProgress.childLanes</span>
        <span class="s1">);</span>

        <span class="s3">if </span><span class="s1">(hasChildWork) {</span>
          <span class="s1">workInProgress.flags |= Update;</span>
        <span class="s1">}</span>

        <span class="s1">{</span>
          <span class="s0">// Reset effect durations for the next eventual effect phase.</span>
          <span class="s0">// These are reset during render to allow the DevTools commit hook a chance to read them,</span>
          <span class="s3">var </span><span class="s1">stateNode = workInProgress.stateNode;</span>
          <span class="s1">stateNode.effectDuration = </span><span class="s4">0</span><span class="s1">;</span>
          <span class="s1">stateNode.passiveEffectDuration = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">break</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s1">SuspenseComponent: {</span>
      <span class="s3">var </span><span class="s1">state = workInProgress.memoizedState;</span>

      <span class="s3">if </span><span class="s1">(state !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(state.dehydrated !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">pushSuspenseContext(</span>
            <span class="s1">workInProgress,</span>
            <span class="s1">setDefaultShallowSuspenseContext(suspenseStackCursor.current)</span>
          <span class="s1">); </span><span class="s0">// We know that this component will suspend again because if it has</span>
          <span class="s0">// been unsuspended it has committed as a resolved Suspense component.</span>
          <span class="s0">// If it needs to be retried, it should have work scheduled on it.</span>

          <span class="s1">workInProgress.flags |= DidCapture; </span><span class="s0">// We should never render the children of a dehydrated boundary until we</span>
          <span class="s0">// upgrade it. We return null instead of bailoutOnAlreadyFinishedWork.</span>

          <span class="s3">return null</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s0">// If this boundary is currently timed out, we need to decide</span>
        <span class="s0">// whether to retry the primary children, or to skip over it and</span>
        <span class="s0">// go straight to the fallback. Check the priority of the primary</span>
        <span class="s0">// child fragment.</span>

        <span class="s3">var </span><span class="s1">primaryChildFragment = workInProgress.child;</span>
        <span class="s3">var </span><span class="s1">primaryChildLanes = primaryChildFragment.childLanes;</span>

        <span class="s3">if </span><span class="s1">(includesSomeLane(renderLanes, primaryChildLanes)) {</span>
          <span class="s0">// The primary children have pending work. Use the normal path</span>
          <span class="s0">// to attempt to render the primary children again.</span>
          <span class="s3">return </span><span class="s1">updateSuspenseComponent(current, workInProgress, renderLanes);</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s0">// The primary child fragment does not have pending work marked</span>
          <span class="s0">// on it</span>
          <span class="s1">pushSuspenseContext(</span>
            <span class="s1">workInProgress,</span>
            <span class="s1">setDefaultShallowSuspenseContext(suspenseStackCursor.current)</span>
          <span class="s1">); </span><span class="s0">// The primary children do not have pending work with sufficient</span>
          <span class="s0">// priority. Bailout.</span>

          <span class="s3">var </span><span class="s1">child = bailoutOnAlreadyFinishedWork(</span>
            <span class="s1">current,</span>
            <span class="s1">workInProgress,</span>
            <span class="s1">renderLanes</span>
          <span class="s1">);</span>

          <span class="s3">if </span><span class="s1">(child !== </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s0">// The fallback children have pending work. Skip over the</span>
            <span class="s0">// primary children and work on the fallback.</span>
            <span class="s3">return </span><span class="s1">child.sibling;</span>
          <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s0">// Note: We can return `null` here because we already checked</span>
            <span class="s0">// whether there were nested context consumers, via the call to</span>
            <span class="s0">// `bailoutOnAlreadyFinishedWork` above.</span>
            <span class="s3">return null</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">pushSuspenseContext(</span>
          <span class="s1">workInProgress,</span>
          <span class="s1">setDefaultShallowSuspenseContext(suspenseStackCursor.current)</span>
        <span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s3">break</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">case </span><span class="s1">SuspenseListComponent: {</span>
      <span class="s3">var </span><span class="s1">didSuspendBefore = (current.flags &amp; DidCapture) !== NoFlags;</span>

      <span class="s3">var </span><span class="s1">_hasChildWork = includesSomeLane(</span>
        <span class="s1">renderLanes,</span>
        <span class="s1">workInProgress.childLanes</span>
      <span class="s1">);</span>

      <span class="s3">if </span><span class="s1">(didSuspendBefore) {</span>
        <span class="s3">if </span><span class="s1">(_hasChildWork) {</span>
          <span class="s0">// If something was in fallback state last time, and we have all the</span>
          <span class="s0">// same children then we're still in progressive loading state.</span>
          <span class="s0">// Something might get unblocked by state updates or retries in the</span>
          <span class="s0">// tree which will affect the tail. So we need to use the normal</span>
          <span class="s0">// path to compute the correct tail.</span>
          <span class="s3">return </span><span class="s1">updateSuspenseListComponent(</span>
            <span class="s1">current,</span>
            <span class="s1">workInProgress,</span>
            <span class="s1">renderLanes</span>
          <span class="s1">);</span>
        <span class="s1">} </span><span class="s0">// If none of the children had any work, that means that none of</span>
        <span class="s0">// them got retried so they'll still be blocked in the same way</span>
        <span class="s0">// as before. We can fast bail out.</span>

        <span class="s1">workInProgress.flags |= DidCapture;</span>
      <span class="s1">} </span><span class="s0">// If nothing suspended before and we're rendering the same children,</span>
      <span class="s0">// then the tail doesn't matter. Anything new that suspends will work</span>
      <span class="s0">// in the &quot;together&quot; mode, so we can continue from the state we had.</span>

      <span class="s3">var </span><span class="s1">renderState = workInProgress.memoizedState;</span>

      <span class="s3">if </span><span class="s1">(renderState !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s0">// Reset to the &quot;together&quot; mode in case we've started a different</span>
        <span class="s0">// update in the past but didn't complete it.</span>
        <span class="s1">renderState.rendering = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">renderState.tail = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">renderState.lastEffect = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">pushSuspenseContext(workInProgress, suspenseStackCursor.current);</span>

      <span class="s3">if </span><span class="s1">(_hasChildWork) {</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s0">// If none of the children had any work, that means that none of</span>
        <span class="s0">// them got retried so they'll still be blocked in the same way</span>
        <span class="s0">// as before. We can fast bail out.</span>
        <span class="s3">return null</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">case </span><span class="s1">OffscreenComponent:</span>
    <span class="s3">case </span><span class="s1">LegacyHiddenComponent: {</span>
      <span class="s0">// Need to check if the tree still needs to be deferred. This is</span>
      <span class="s0">// almost identical to the logic used in the normal update path,</span>
      <span class="s0">// so we'll just enter that. The only difference is we'll bail out</span>
      <span class="s0">// at the next level instead of this one, because the child props</span>
      <span class="s0">// have not changed. Which is fine.</span>
      <span class="s0">// TODO: Probably should refactor `beginWork` to split the bailout</span>
      <span class="s0">// path from the normal path. I'm tempted to do a labeled break here</span>
      <span class="s0">// but I won't :)</span>
      <span class="s1">workInProgress.lanes = NoLanes;</span>
      <span class="s3">return </span><span class="s1">updateOffscreenComponent(current, workInProgress, renderLanes);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">beginWork(current, workInProgress, renderLanes) {</span>
  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(workInProgress._debugNeedsRemount &amp;&amp; current !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// This will restart the begin phase with a new fiber.</span>
      <span class="s3">return </span><span class="s1">remountFiber(</span>
        <span class="s1">current,</span>
        <span class="s1">workInProgress,</span>
        <span class="s1">createFiberFromTypeAndProps(</span>
          <span class="s1">workInProgress.type,</span>
          <span class="s1">workInProgress.key,</span>
          <span class="s1">workInProgress.pendingProps,</span>
          <span class="s1">workInProgress._debugOwner || </span><span class="s3">null</span><span class="s1">,</span>
          <span class="s1">workInProgress.mode,</span>
          <span class="s1">workInProgress.lanes</span>
        <span class="s1">)</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(current !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">oldProps = current.memoizedProps;</span>
    <span class="s3">var </span><span class="s1">newProps = workInProgress.pendingProps;</span>

    <span class="s3">if </span><span class="s1">(</span>
      <span class="s1">oldProps !== newProps ||</span>
      <span class="s1">hasContextChanged() || </span><span class="s0">// Force a re-render if the implementation changed due to hot reload:</span>
      <span class="s1">workInProgress.type !== current.type</span>
    <span class="s1">) {</span>
      <span class="s0">// If props or context changed, mark the fiber as having performed work.</span>
      <span class="s0">// This may be unset if the props are determined to be equal later (memo).</span>
      <span class="s1">didReceiveUpdate = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s0">// Neither props nor legacy context changes. Check if there's a pending</span>
      <span class="s0">// update or context change.</span>
      <span class="s3">var </span><span class="s1">hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(</span>
        <span class="s1">current,</span>
        <span class="s1">renderLanes</span>
      <span class="s1">);</span>

      <span class="s3">if </span><span class="s1">(</span>
        <span class="s1">!hasScheduledUpdateOrContext &amp;&amp; </span><span class="s0">// If this is the second pass of an error or suspense boundary, there</span>
        <span class="s0">// may not be work scheduled on `current`, so we check for this flag.</span>
        <span class="s1">(workInProgress.flags &amp; DidCapture) === NoFlags</span>
      <span class="s1">) {</span>
        <span class="s0">// No pending updates or context. Bail out now.</span>
        <span class="s1">didReceiveUpdate = </span><span class="s3">false</span><span class="s1">;</span>
        <span class="s3">return </span><span class="s1">attemptEarlyBailoutIfNoScheduledUpdate(</span>
          <span class="s1">current,</span>
          <span class="s1">workInProgress,</span>
          <span class="s1">renderLanes</span>
        <span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">((current.flags &amp; ForceUpdateForLegacySuspense) !== NoFlags) {</span>
        <span class="s0">// This is a special case that only exists for legacy mode.</span>
        <span class="s0">// See https://github.com/facebook/react/pull/19216.</span>
        <span class="s1">didReceiveUpdate = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s0">// An update was scheduled on this fiber, but there are no new props</span>
        <span class="s0">// nor legacy context. Set this to false. If an update queue or context</span>
        <span class="s0">// consumer produces a changed value, it will set this to true. Otherwise,</span>
        <span class="s0">// the component will assume the children have not changed and bail out.</span>
        <span class="s1">didReceiveUpdate = </span><span class="s3">false</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">didReceiveUpdate = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s0">// Before entering the begin phase, clear pending update priority.</span>
  <span class="s0">// TODO: This assumes that we're about to evaluate the component and process</span>
  <span class="s0">// the update queue. However, there's an exception: SimpleMemoComponent</span>
  <span class="s0">// sometimes bails out later in the begin phase. This indicates that we should</span>
  <span class="s0">// move this assignment out of the common path and into each branch.</span>

  <span class="s1">workInProgress.lanes = NoLanes;</span>

  <span class="s3">switch </span><span class="s1">(workInProgress.tag) {</span>
    <span class="s3">case </span><span class="s1">IndeterminateComponent: {</span>
      <span class="s3">return </span><span class="s1">mountIndeterminateComponent(</span>
        <span class="s1">current,</span>
        <span class="s1">workInProgress,</span>
        <span class="s1">workInProgress.type,</span>
        <span class="s1">renderLanes</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">case </span><span class="s1">LazyComponent: {</span>
      <span class="s3">var </span><span class="s1">elementType = workInProgress.elementType;</span>
      <span class="s3">return </span><span class="s1">mountLazyComponent(</span>
        <span class="s1">current,</span>
        <span class="s1">workInProgress,</span>
        <span class="s1">elementType,</span>
        <span class="s1">renderLanes</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">case </span><span class="s1">FunctionComponent: {</span>
      <span class="s3">var </span><span class="s1">Component = workInProgress.type;</span>
      <span class="s3">var </span><span class="s1">unresolvedProps = workInProgress.pendingProps;</span>
      <span class="s3">var </span><span class="s1">resolvedProps =</span>
        <span class="s1">workInProgress.elementType === Component</span>
          <span class="s1">? unresolvedProps</span>
          <span class="s1">: resolveDefaultProps(Component, unresolvedProps);</span>
      <span class="s3">return </span><span class="s1">updateFunctionComponent(</span>
        <span class="s1">current,</span>
        <span class="s1">workInProgress,</span>
        <span class="s1">Component,</span>
        <span class="s1">resolvedProps,</span>
        <span class="s1">renderLanes</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">case </span><span class="s1">ClassComponent: {</span>
      <span class="s3">var </span><span class="s1">_Component = workInProgress.type;</span>
      <span class="s3">var </span><span class="s1">_unresolvedProps = workInProgress.pendingProps;</span>

      <span class="s3">var </span><span class="s1">_resolvedProps =</span>
        <span class="s1">workInProgress.elementType === _Component</span>
          <span class="s1">? _unresolvedProps</span>
          <span class="s1">: resolveDefaultProps(_Component, _unresolvedProps);</span>

      <span class="s3">return </span><span class="s1">updateClassComponent(</span>
        <span class="s1">current,</span>
        <span class="s1">workInProgress,</span>
        <span class="s1">_Component,</span>
        <span class="s1">_resolvedProps,</span>
        <span class="s1">renderLanes</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">case </span><span class="s1">HostRoot:</span>
      <span class="s3">return </span><span class="s1">updateHostRoot(current, workInProgress, renderLanes);</span>

    <span class="s3">case </span><span class="s1">HostComponent:</span>
      <span class="s3">return </span><span class="s1">updateHostComponent(current, workInProgress, renderLanes);</span>

    <span class="s3">case </span><span class="s1">HostText:</span>
      <span class="s3">return </span><span class="s1">updateHostText();</span>

    <span class="s3">case </span><span class="s1">SuspenseComponent:</span>
      <span class="s3">return </span><span class="s1">updateSuspenseComponent(current, workInProgress, renderLanes);</span>

    <span class="s3">case </span><span class="s1">HostPortal:</span>
      <span class="s3">return </span><span class="s1">updatePortalComponent(current, workInProgress, renderLanes);</span>

    <span class="s3">case </span><span class="s1">ForwardRef: {</span>
      <span class="s3">var </span><span class="s1">type = workInProgress.type;</span>
      <span class="s3">var </span><span class="s1">_unresolvedProps2 = workInProgress.pendingProps;</span>

      <span class="s3">var </span><span class="s1">_resolvedProps2 =</span>
        <span class="s1">workInProgress.elementType === type</span>
          <span class="s1">? _unresolvedProps2</span>
          <span class="s1">: resolveDefaultProps(type, _unresolvedProps2);</span>

      <span class="s3">return </span><span class="s1">updateForwardRef(</span>
        <span class="s1">current,</span>
        <span class="s1">workInProgress,</span>
        <span class="s1">type,</span>
        <span class="s1">_resolvedProps2,</span>
        <span class="s1">renderLanes</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">case </span><span class="s1">Fragment:</span>
      <span class="s3">return </span><span class="s1">updateFragment(current, workInProgress, renderLanes);</span>

    <span class="s3">case </span><span class="s1">Mode:</span>
      <span class="s3">return </span><span class="s1">updateMode(current, workInProgress, renderLanes);</span>

    <span class="s3">case </span><span class="s1">Profiler:</span>
      <span class="s3">return </span><span class="s1">updateProfiler(current, workInProgress, renderLanes);</span>

    <span class="s3">case </span><span class="s1">ContextProvider:</span>
      <span class="s3">return </span><span class="s1">updateContextProvider(current, workInProgress, renderLanes);</span>

    <span class="s3">case </span><span class="s1">ContextConsumer:</span>
      <span class="s3">return </span><span class="s1">updateContextConsumer(current, workInProgress, renderLanes);</span>

    <span class="s3">case </span><span class="s1">MemoComponent: {</span>
      <span class="s3">var </span><span class="s1">_type2 = workInProgress.type;</span>
      <span class="s3">var </span><span class="s1">_unresolvedProps3 = workInProgress.pendingProps; </span><span class="s0">// Resolve outer props first, then resolve inner props.</span>

      <span class="s3">var </span><span class="s1">_resolvedProps3 = resolveDefaultProps(_type2, _unresolvedProps3);</span>

      <span class="s1">{</span>
        <span class="s3">if </span><span class="s1">(workInProgress.type !== workInProgress.elementType) {</span>
          <span class="s3">var </span><span class="s1">outerPropTypes = _type2.propTypes;</span>

          <span class="s3">if </span><span class="s1">(outerPropTypes) {</span>
            <span class="s1">checkPropTypes(</span>
              <span class="s1">outerPropTypes,</span>
              <span class="s1">_resolvedProps3, </span><span class="s0">// Resolved for outer only</span>
              <span class="s2">&quot;prop&quot;</span><span class="s1">,</span>
              <span class="s1">getComponentNameFromType(_type2)</span>
            <span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">_resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3);</span>
      <span class="s3">return </span><span class="s1">updateMemoComponent(</span>
        <span class="s1">current,</span>
        <span class="s1">workInProgress,</span>
        <span class="s1">_type2,</span>
        <span class="s1">_resolvedProps3,</span>
        <span class="s1">renderLanes</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">case </span><span class="s1">SimpleMemoComponent: {</span>
      <span class="s3">return </span><span class="s1">updateSimpleMemoComponent(</span>
        <span class="s1">current,</span>
        <span class="s1">workInProgress,</span>
        <span class="s1">workInProgress.type,</span>
        <span class="s1">workInProgress.pendingProps,</span>
        <span class="s1">renderLanes</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">case </span><span class="s1">IncompleteClassComponent: {</span>
      <span class="s3">var </span><span class="s1">_Component2 = workInProgress.type;</span>
      <span class="s3">var </span><span class="s1">_unresolvedProps4 = workInProgress.pendingProps;</span>

      <span class="s3">var </span><span class="s1">_resolvedProps4 =</span>
        <span class="s1">workInProgress.elementType === _Component2</span>
          <span class="s1">? _unresolvedProps4</span>
          <span class="s1">: resolveDefaultProps(_Component2, _unresolvedProps4);</span>

      <span class="s3">return </span><span class="s1">mountIncompleteClassComponent(</span>
        <span class="s1">current,</span>
        <span class="s1">workInProgress,</span>
        <span class="s1">_Component2,</span>
        <span class="s1">_resolvedProps4,</span>
        <span class="s1">renderLanes</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">case </span><span class="s1">SuspenseListComponent: {</span>
      <span class="s3">return </span><span class="s1">updateSuspenseListComponent(current, workInProgress, renderLanes);</span>
    <span class="s1">}</span>

    <span class="s3">case </span><span class="s1">ScopeComponent: {</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">case </span><span class="s1">OffscreenComponent: {</span>
      <span class="s3">return </span><span class="s1">updateOffscreenComponent(current, workInProgress, renderLanes);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">throw new </span><span class="s1">Error(</span>
    <span class="s2">&quot;Unknown unit of work tag (&quot; </span><span class="s1">+</span>
      <span class="s1">workInProgress.tag +</span>
      <span class="s2">&quot;). This error is likely caused by a bug in &quot; </span><span class="s1">+</span>
      <span class="s2">&quot;React. Please file an issue.&quot;</span>
  <span class="s1">);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">markUpdate(workInProgress) {</span>
  <span class="s0">// Tag the fiber with an update effect. This turns a Placement into</span>
  <span class="s0">// a PlacementAndUpdate.</span>
  <span class="s1">workInProgress.flags |= Update;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">markRef$1(workInProgress) {</span>
  <span class="s1">workInProgress.flags |= Ref;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">hadNoMutationsEffects(current, completedWork) {</span>
  <span class="s3">var </span><span class="s1">didBailout = current !== </span><span class="s3">null </span><span class="s1">&amp;&amp; current.child === completedWork.child;</span>

  <span class="s3">if </span><span class="s1">(didBailout) {</span>
    <span class="s3">return true</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">((completedWork.flags &amp; ChildDeletion) !== NoFlags) {</span>
    <span class="s3">return false</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s0">// TODO: If we move the `hadNoMutationsEffects` call after `bubbleProperties`</span>
  <span class="s0">// then we only have to check the `completedWork.subtreeFlags`.</span>

  <span class="s3">var </span><span class="s1">child = completedWork.child;</span>

  <span class="s3">while </span><span class="s1">(child !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">if </span><span class="s1">(</span>
      <span class="s1">(child.flags &amp; MutationMask) !== NoFlags ||</span>
      <span class="s1">(child.subtreeFlags &amp; MutationMask) !== NoFlags</span>
    <span class="s1">) {</span>
      <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">child = child.sibling;</span>
  <span class="s1">}</span>

  <span class="s3">return true</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">appendAllChildren;</span>
<span class="s3">var </span><span class="s1">updateHostContainer;</span>
<span class="s3">var </span><span class="s1">updateHostComponent$1;</span>
<span class="s3">var </span><span class="s1">updateHostText$1;</span>

<span class="s1">{</span>
  <span class="s0">// Persistent host tree mode</span>
  <span class="s1">appendAllChildren = </span><span class="s3">function</span><span class="s1">(</span>
    <span class="s1">parent,</span>
    <span class="s1">workInProgress,</span>
    <span class="s1">needsVisibilityToggle,</span>
    <span class="s1">isHidden</span>
  <span class="s1">) {</span>
    <span class="s0">// We only have the top Fiber that was created but we need recurse down its</span>
    <span class="s0">// children to find all the terminal nodes.</span>
    <span class="s3">var </span><span class="s1">node = workInProgress.child;</span>

    <span class="s3">while </span><span class="s1">(node !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// eslint-disable-next-line no-labels</span>
      <span class="s3">if </span><span class="s1">(node.tag === HostComponent) {</span>
        <span class="s3">var </span><span class="s1">instance = node.stateNode;</span>

        <span class="s3">if </span><span class="s1">(needsVisibilityToggle &amp;&amp; isHidden) {</span>
          <span class="s0">// This child is inside a timed out tree. Hide it.</span>
          <span class="s3">var </span><span class="s1">props = node.memoizedProps;</span>
          <span class="s3">var </span><span class="s1">type = node.type;</span>
          <span class="s1">instance = cloneHiddenInstance(instance);</span>
        <span class="s1">}</span>

        <span class="s1">appendInitialChild(parent, instance);</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(node.tag === HostText) {</span>
        <span class="s3">var </span><span class="s1">_instance = node.stateNode;</span>

        <span class="s3">if </span><span class="s1">(needsVisibilityToggle &amp;&amp; isHidden) {</span>
          <span class="s0">// This child is inside a timed out tree. Hide it.</span>
          <span class="s3">var </span><span class="s1">text = node.memoizedProps;</span>
          <span class="s1">_instance = cloneHiddenTextInstance();</span>
        <span class="s1">}</span>

        <span class="s1">appendInitialChild(parent, _instance);</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(node.tag === HostPortal);</span>
      <span class="s3">else if </span><span class="s1">(node.tag === OffscreenComponent &amp;&amp; node.memoizedState !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s0">// The children in this boundary are hidden. Toggle their visibility</span>
        <span class="s0">// before appending.</span>
        <span class="s3">var </span><span class="s1">child = node.child;</span>

        <span class="s3">if </span><span class="s1">(child !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">child.</span><span class="s3">return </span><span class="s1">= node;</span>
        <span class="s1">}</span>

        <span class="s1">appendAllChildren(parent, node, </span><span class="s3">true</span><span class="s1">, </span><span class="s3">true</span><span class="s1">);</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(node.child !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">node.child.</span><span class="s3">return </span><span class="s1">= node;</span>
        <span class="s1">node = node.child;</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// $FlowFixMe This is correct but Flow is confused by the labeled break.</span>

      <span class="s1">node = node;</span>

      <span class="s3">if </span><span class="s1">(node === workInProgress) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">while </span><span class="s1">(node.sibling === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(node.</span><span class="s3">return </span><span class="s1">=== </span><span class="s3">null </span><span class="s1">|| node.</span><span class="s3">return </span><span class="s1">=== workInProgress) {</span>
          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">node = node.</span><span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">node.sibling.</span><span class="s3">return </span><span class="s1">= node.</span><span class="s3">return</span><span class="s1">;</span>
      <span class="s1">node = node.sibling;</span>
    <span class="s1">}</span>
  <span class="s1">}; </span><span class="s0">// An unfortunate fork of appendAllChildren because we have two different parent types.</span>

  <span class="s3">var </span><span class="s1">appendAllChildrenToContainer = </span><span class="s3">function</span><span class="s1">(</span>
    <span class="s1">containerChildSet,</span>
    <span class="s1">workInProgress,</span>
    <span class="s1">needsVisibilityToggle,</span>
    <span class="s1">isHidden</span>
  <span class="s1">) {</span>
    <span class="s0">// We only have the top Fiber that was created but we need recurse down its</span>
    <span class="s0">// children to find all the terminal nodes.</span>
    <span class="s3">var </span><span class="s1">node = workInProgress.child;</span>

    <span class="s3">while </span><span class="s1">(node !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// eslint-disable-next-line no-labels</span>
      <span class="s3">if </span><span class="s1">(node.tag === HostComponent) {</span>
        <span class="s3">var </span><span class="s1">instance = node.stateNode;</span>

        <span class="s3">if </span><span class="s1">(needsVisibilityToggle &amp;&amp; isHidden) {</span>
          <span class="s0">// This child is inside a timed out tree. Hide it.</span>
          <span class="s3">var </span><span class="s1">props = node.memoizedProps;</span>
          <span class="s3">var </span><span class="s1">type = node.type;</span>
          <span class="s1">instance = cloneHiddenInstance(instance);</span>
        <span class="s1">}</span>

        <span class="s1">appendChildToContainerChildSet(containerChildSet, instance);</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(node.tag === HostText) {</span>
        <span class="s3">var </span><span class="s1">_instance2 = node.stateNode;</span>

        <span class="s3">if </span><span class="s1">(needsVisibilityToggle &amp;&amp; isHidden) {</span>
          <span class="s0">// This child is inside a timed out tree. Hide it.</span>
          <span class="s3">var </span><span class="s1">text = node.memoizedProps;</span>
          <span class="s1">_instance2 = cloneHiddenTextInstance();</span>
        <span class="s1">}</span>

        <span class="s1">appendChildToContainerChildSet(containerChildSet, _instance2);</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(node.tag === HostPortal);</span>
      <span class="s3">else if </span><span class="s1">(node.tag === OffscreenComponent &amp;&amp; node.memoizedState !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s0">// The children in this boundary are hidden. Toggle their visibility</span>
        <span class="s0">// before appending.</span>
        <span class="s3">var </span><span class="s1">child = node.child;</span>

        <span class="s3">if </span><span class="s1">(child !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">child.</span><span class="s3">return </span><span class="s1">= node;</span>
        <span class="s1">}</span>

        <span class="s1">appendAllChildrenToContainer(containerChildSet, node, </span><span class="s3">true</span><span class="s1">, </span><span class="s3">true</span><span class="s1">);</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(node.child !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">node.child.</span><span class="s3">return </span><span class="s1">= node;</span>
        <span class="s1">node = node.child;</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// $FlowFixMe This is correct but Flow is confused by the labeled break.</span>

      <span class="s1">node = node;</span>

      <span class="s3">if </span><span class="s1">(node === workInProgress) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">while </span><span class="s1">(node.sibling === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(node.</span><span class="s3">return </span><span class="s1">=== </span><span class="s3">null </span><span class="s1">|| node.</span><span class="s3">return </span><span class="s1">=== workInProgress) {</span>
          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">node = node.</span><span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">node.sibling.</span><span class="s3">return </span><span class="s1">= node.</span><span class="s3">return</span><span class="s1">;</span>
      <span class="s1">node = node.sibling;</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s1">updateHostContainer = </span><span class="s3">function</span><span class="s1">(current, workInProgress) {</span>
    <span class="s3">var </span><span class="s1">portalOrRoot = workInProgress.stateNode;</span>
    <span class="s3">var </span><span class="s1">childrenUnchanged = hadNoMutationsEffects(current, workInProgress);</span>

    <span class="s3">if </span><span class="s1">(childrenUnchanged);</span>
    <span class="s3">else </span><span class="s1">{</span>
      <span class="s3">var </span><span class="s1">container = portalOrRoot.containerInfo;</span>
      <span class="s3">var </span><span class="s1">newChildSet = createContainerChildSet(container); </span><span class="s0">// If children might have changed, we have to add them all to the set.</span>

      <span class="s1">appendAllChildrenToContainer(newChildSet, workInProgress, </span><span class="s3">false</span><span class="s1">, </span><span class="s3">false</span><span class="s1">);</span>
      <span class="s1">portalOrRoot.pendingChildren = newChildSet; </span><span class="s0">// Schedule an update on the container to swap out the container.</span>

      <span class="s1">markUpdate(workInProgress);</span>
      <span class="s1">finalizeContainerChildren(container, newChildSet);</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s1">updateHostComponent$1 = </span><span class="s3">function</span><span class="s1">(</span>
    <span class="s1">current,</span>
    <span class="s1">workInProgress,</span>
    <span class="s1">type,</span>
    <span class="s1">newProps,</span>
    <span class="s1">rootContainerInstance</span>
  <span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">currentInstance = current.stateNode;</span>
    <span class="s3">var </span><span class="s1">oldProps = current.memoizedProps; </span><span class="s0">// If there are no effects associated with this node, then none of our children had any updates.</span>
    <span class="s0">// This guarantees that we can reuse all of them.</span>

    <span class="s3">var </span><span class="s1">childrenUnchanged = hadNoMutationsEffects(current, workInProgress);</span>

    <span class="s3">if </span><span class="s1">(childrenUnchanged &amp;&amp; oldProps === newProps) {</span>
      <span class="s0">// No changes, just reuse the existing instance.</span>
      <span class="s0">// Note that this might release a previous clone.</span>
      <span class="s1">workInProgress.stateNode = currentInstance;</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">recyclableInstance = workInProgress.stateNode;</span>
    <span class="s3">var </span><span class="s1">currentHostContext = getHostContext();</span>
    <span class="s3">var </span><span class="s1">updatePayload = </span><span class="s3">null</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s1">(oldProps !== newProps) {</span>
      <span class="s1">updatePayload = prepareUpdate(</span>
        <span class="s1">recyclableInstance,</span>
        <span class="s1">type,</span>
        <span class="s1">oldProps,</span>
        <span class="s1">newProps</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(childrenUnchanged &amp;&amp; updatePayload === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// No changes, just reuse the existing instance.</span>
      <span class="s0">// Note that this might release a previous clone.</span>
      <span class="s1">workInProgress.stateNode = currentInstance;</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">newInstance = cloneInstance(</span>
      <span class="s1">currentInstance,</span>
      <span class="s1">updatePayload,</span>
      <span class="s1">type,</span>
      <span class="s1">oldProps,</span>
      <span class="s1">newProps,</span>
      <span class="s1">workInProgress,</span>
      <span class="s1">childrenUnchanged</span>
    <span class="s1">);</span>

    <span class="s1">workInProgress.stateNode = newInstance;</span>

    <span class="s3">if </span><span class="s1">(childrenUnchanged) {</span>
      <span class="s0">// If there are no other effects in this tree, we need to flag this node as having one.</span>
      <span class="s0">// Even though we're not going to use it for anything.</span>
      <span class="s0">// Otherwise parents won't know that there are new children to propagate upwards.</span>
      <span class="s1">markUpdate(workInProgress);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s0">// If children might have changed, we have to add them all to the set.</span>
      <span class="s1">appendAllChildren(newInstance, workInProgress, </span><span class="s3">false</span><span class="s1">, </span><span class="s3">false</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s1">updateHostText$1 = </span><span class="s3">function</span><span class="s1">(current, workInProgress, oldText, newText) {</span>
    <span class="s3">if </span><span class="s1">(oldText !== newText) {</span>
      <span class="s0">// If the text content differs, we'll create a new text instance for it.</span>
      <span class="s3">var </span><span class="s1">rootContainerInstance = getRootHostContainer();</span>
      <span class="s3">var </span><span class="s1">currentHostContext = getHostContext();</span>
      <span class="s1">workInProgress.stateNode = createTextInstance(</span>
        <span class="s1">newText,</span>
        <span class="s1">rootContainerInstance,</span>
        <span class="s1">currentHostContext,</span>
        <span class="s1">workInProgress</span>
      <span class="s1">); </span><span class="s0">// We'll have to mark it as having an effect, even though we won't use the effect for anything.</span>
      <span class="s0">// This lets the parents know that at least one of their children has changed.</span>

      <span class="s1">markUpdate(workInProgress);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">workInProgress.stateNode = current.stateNode;</span>
    <span class="s1">}</span>
  <span class="s1">};</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {</span>
  <span class="s3">switch </span><span class="s1">(renderState.tailMode) {</span>
    <span class="s3">case </span><span class="s2">&quot;hidden&quot;</span><span class="s1">: {</span>
      <span class="s0">// Any insertions at the end of the tail list after this point</span>
      <span class="s0">// should be invisible. If there are already mounted boundaries</span>
      <span class="s0">// anything before them are not considered for collapsing.</span>
      <span class="s0">// Therefore we need to go through the whole tail to find if</span>
      <span class="s0">// there are any.</span>
      <span class="s3">var </span><span class="s1">tailNode = renderState.tail;</span>
      <span class="s3">var </span><span class="s1">lastTailNode = </span><span class="s3">null</span><span class="s1">;</span>

      <span class="s3">while </span><span class="s1">(tailNode !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(tailNode.alternate !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">lastTailNode = tailNode;</span>
        <span class="s1">}</span>

        <span class="s1">tailNode = tailNode.sibling;</span>
      <span class="s1">} </span><span class="s0">// Next we're simply going to delete all insertions after the</span>
      <span class="s0">// last rendered item.</span>

      <span class="s3">if </span><span class="s1">(lastTailNode === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s0">// All remaining items in the tail are insertions.</span>
        <span class="s1">renderState.tail = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s0">// Detach the insertion after the last node that was already</span>
        <span class="s0">// inserted.</span>
        <span class="s1">lastTailNode.sibling = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">break</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">case </span><span class="s2">&quot;collapsed&quot;</span><span class="s1">: {</span>
      <span class="s0">// Any insertions at the end of the tail list after this point</span>
      <span class="s0">// should be invisible. If there are already mounted boundaries</span>
      <span class="s0">// anything before them are not considered for collapsing.</span>
      <span class="s0">// Therefore we need to go through the whole tail to find if</span>
      <span class="s0">// there are any.</span>
      <span class="s3">var </span><span class="s1">_tailNode = renderState.tail;</span>
      <span class="s3">var </span><span class="s1">_lastTailNode = </span><span class="s3">null</span><span class="s1">;</span>

      <span class="s3">while </span><span class="s1">(_tailNode !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(_tailNode.alternate !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">_lastTailNode = _tailNode;</span>
        <span class="s1">}</span>

        <span class="s1">_tailNode = _tailNode.sibling;</span>
      <span class="s1">} </span><span class="s0">// Next we're simply going to delete all insertions after the</span>
      <span class="s0">// last rendered item.</span>

      <span class="s3">if </span><span class="s1">(_lastTailNode === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s0">// All remaining items in the tail are insertions.</span>
        <span class="s3">if </span><span class="s1">(!hasRenderedATailFallback &amp;&amp; renderState.tail !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s0">// We suspended during the head. We want to show at least one</span>
          <span class="s0">// row at the tail. So we'll keep on and cut off the rest.</span>
          <span class="s1">renderState.tail.sibling = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s1">renderState.tail = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s0">// Detach the insertion after the last node that was already</span>
        <span class="s0">// inserted.</span>
        <span class="s1">_lastTailNode.sibling = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">break</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">bubbleProperties(completedWork) {</span>
  <span class="s3">var </span><span class="s1">didBailout =</span>
    <span class="s1">completedWork.alternate !== </span><span class="s3">null </span><span class="s1">&amp;&amp;</span>
    <span class="s1">completedWork.alternate.child === completedWork.child;</span>
  <span class="s3">var </span><span class="s1">newChildLanes = NoLanes;</span>
  <span class="s3">var </span><span class="s1">subtreeFlags = NoFlags;</span>

  <span class="s3">if </span><span class="s1">(!didBailout) {</span>
    <span class="s0">// Bubble up the earliest expiration time.</span>
    <span class="s3">if </span><span class="s1">((completedWork.mode &amp; ProfileMode) !== NoMode) {</span>
      <span class="s0">// In profiling mode, resetChildExpirationTime is also used to reset</span>
      <span class="s0">// profiler durations.</span>
      <span class="s3">var </span><span class="s1">actualDuration = completedWork.actualDuration;</span>
      <span class="s3">var </span><span class="s1">treeBaseDuration = completedWork.selfBaseDuration;</span>
      <span class="s3">var </span><span class="s1">child = completedWork.child;</span>

      <span class="s3">while </span><span class="s1">(child !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">newChildLanes = mergeLanes(</span>
          <span class="s1">newChildLanes,</span>
          <span class="s1">mergeLanes(child.lanes, child.childLanes)</span>
        <span class="s1">);</span>
        <span class="s1">subtreeFlags |= child.subtreeFlags;</span>
        <span class="s1">subtreeFlags |= child.flags; </span><span class="s0">// When a fiber is cloned, its actualDuration is reset to 0. This value will</span>
        <span class="s0">// only be updated if work is done on the fiber (i.e. it doesn't bailout).</span>
        <span class="s0">// When work is done, it should bubble to the parent's actualDuration. If</span>
        <span class="s0">// the fiber has not been cloned though, (meaning no work was done), then</span>
        <span class="s0">// this value will reflect the amount of time spent working on a previous</span>
        <span class="s0">// render. In that case it should not bubble. We determine whether it was</span>
        <span class="s0">// cloned by comparing the child pointer.</span>

        <span class="s1">actualDuration += child.actualDuration;</span>
        <span class="s1">treeBaseDuration += child.treeBaseDuration;</span>
        <span class="s1">child = child.sibling;</span>
      <span class="s1">}</span>

      <span class="s1">completedWork.actualDuration = actualDuration;</span>
      <span class="s1">completedWork.treeBaseDuration = treeBaseDuration;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">var </span><span class="s1">_child = completedWork.child;</span>

      <span class="s3">while </span><span class="s1">(_child !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">newChildLanes = mergeLanes(</span>
          <span class="s1">newChildLanes,</span>
          <span class="s1">mergeLanes(_child.lanes, _child.childLanes)</span>
        <span class="s1">);</span>
        <span class="s1">subtreeFlags |= _child.subtreeFlags;</span>
        <span class="s1">subtreeFlags |= _child.flags; </span><span class="s0">// Update the return pointer so the tree is consistent. This is a code</span>
        <span class="s0">// smell because it assumes the commit phase is never concurrent with</span>
        <span class="s0">// the render phase. Will address during refactor to alternate model.</span>

        <span class="s1">_child.</span><span class="s3">return </span><span class="s1">= completedWork;</span>
        <span class="s1">_child = _child.sibling;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">completedWork.subtreeFlags |= subtreeFlags;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s0">// Bubble up the earliest expiration time.</span>
    <span class="s3">if </span><span class="s1">((completedWork.mode &amp; ProfileMode) !== NoMode) {</span>
      <span class="s0">// In profiling mode, resetChildExpirationTime is also used to reset</span>
      <span class="s0">// profiler durations.</span>
      <span class="s3">var </span><span class="s1">_treeBaseDuration = completedWork.selfBaseDuration;</span>
      <span class="s3">var </span><span class="s1">_child2 = completedWork.child;</span>

      <span class="s3">while </span><span class="s1">(_child2 !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">newChildLanes = mergeLanes(</span>
          <span class="s1">newChildLanes,</span>
          <span class="s1">mergeLanes(_child2.lanes, _child2.childLanes)</span>
        <span class="s1">); </span><span class="s0">// &quot;Static&quot; flags share the lifetime of the fiber/hook they belong to,</span>
        <span class="s0">// so we should bubble those up even during a bailout. All the other</span>
        <span class="s0">// flags have a lifetime only of a single render + commit, so we should</span>
        <span class="s0">// ignore them.</span>

        <span class="s1">subtreeFlags |= _child2.subtreeFlags &amp; StaticMask;</span>
        <span class="s1">subtreeFlags |= _child2.flags &amp; StaticMask;</span>
        <span class="s1">_treeBaseDuration += _child2.treeBaseDuration;</span>
        <span class="s1">_child2 = _child2.sibling;</span>
      <span class="s1">}</span>

      <span class="s1">completedWork.treeBaseDuration = _treeBaseDuration;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">var </span><span class="s1">_child3 = completedWork.child;</span>

      <span class="s3">while </span><span class="s1">(_child3 !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">newChildLanes = mergeLanes(</span>
          <span class="s1">newChildLanes,</span>
          <span class="s1">mergeLanes(_child3.lanes, _child3.childLanes)</span>
        <span class="s1">); </span><span class="s0">// &quot;Static&quot; flags share the lifetime of the fiber/hook they belong to,</span>
        <span class="s0">// so we should bubble those up even during a bailout. All the other</span>
        <span class="s0">// flags have a lifetime only of a single render + commit, so we should</span>
        <span class="s0">// ignore them.</span>

        <span class="s1">subtreeFlags |= _child3.subtreeFlags &amp; StaticMask;</span>
        <span class="s1">subtreeFlags |= _child3.flags &amp; StaticMask; </span><span class="s0">// Update the return pointer so the tree is consistent. This is a code</span>
        <span class="s0">// smell because it assumes the commit phase is never concurrent with</span>
        <span class="s0">// the render phase. Will address during refactor to alternate model.</span>

        <span class="s1">_child3.</span><span class="s3">return </span><span class="s1">= completedWork;</span>
        <span class="s1">_child3 = _child3.sibling;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">completedWork.subtreeFlags |= subtreeFlags;</span>
  <span class="s1">}</span>

  <span class="s1">completedWork.childLanes = newChildLanes;</span>
  <span class="s3">return </span><span class="s1">didBailout;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">completeDehydratedSuspenseBoundary(</span>
  <span class="s1">current,</span>
  <span class="s1">workInProgress,</span>
  <span class="s1">nextState</span>
<span class="s1">) {</span>
  <span class="s3">var </span><span class="s1">wasHydrated = popHydrationState();</span>

  <span class="s3">if </span><span class="s1">(nextState !== </span><span class="s3">null </span><span class="s1">&amp;&amp; nextState.dehydrated !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s0">// We might be inside a hydration state the first time we're picking up this</span>
    <span class="s0">// Suspense boundary, and also after we've reentered it for further hydration.</span>
    <span class="s3">if </span><span class="s1">(current === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(!wasHydrated) {</span>
        <span class="s3">throw new </span><span class="s1">Error(</span>
          <span class="s2">&quot;A dehydrated suspense component was completed without a hydrated node. &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;This is probably a bug in React.&quot;</span>
        <span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s1">prepareToHydrateHostSuspenseInstance();</span>
      <span class="s1">bubbleProperties(workInProgress);</span>

      <span class="s1">{</span>
        <span class="s3">if </span><span class="s1">((workInProgress.mode &amp; ProfileMode) !== NoMode) {</span>
          <span class="s3">var </span><span class="s1">isTimedOutSuspense = nextState !== </span><span class="s3">null</span><span class="s1">;</span>

          <span class="s3">if </span><span class="s1">(isTimedOutSuspense) {</span>
            <span class="s0">// Don't count time spent in a timed out Suspense subtree as part of the base duration.</span>
            <span class="s3">var </span><span class="s1">primaryChildFragment = workInProgress.child;</span>

            <span class="s3">if </span><span class="s1">(primaryChildFragment !== </span><span class="s3">null</span><span class="s1">) {</span>
              <span class="s0">// $FlowFixMe Flow doesn't support type casting in combination with the -= operator</span>
              <span class="s1">workInProgress.treeBaseDuration -=</span>
                <span class="s1">primaryChildFragment.treeBaseDuration;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">if </span><span class="s1">((workInProgress.flags &amp; DidCapture) === NoFlags) {</span>
        <span class="s0">// This boundary did not suspend so it's now hydrated and unsuspended.</span>
        <span class="s1">workInProgress.memoizedState = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// If nothing suspended, we need to schedule an effect to mark this boundary</span>
      <span class="s0">// as having hydrated so events know that they're free to be invoked.</span>
      <span class="s0">// It's also a signal to replay events and the suspense callback.</span>
      <span class="s0">// If something suspended, schedule an effect to attach retry listeners.</span>
      <span class="s0">// So we might as well always mark this.</span>

      <span class="s1">workInProgress.flags |= Update;</span>
      <span class="s1">bubbleProperties(workInProgress);</span>

      <span class="s1">{</span>
        <span class="s3">if </span><span class="s1">((workInProgress.mode &amp; ProfileMode) !== NoMode) {</span>
          <span class="s3">var </span><span class="s1">_isTimedOutSuspense = nextState !== </span><span class="s3">null</span><span class="s1">;</span>

          <span class="s3">if </span><span class="s1">(_isTimedOutSuspense) {</span>
            <span class="s0">// Don't count time spent in a timed out Suspense subtree as part of the base duration.</span>
            <span class="s3">var </span><span class="s1">_primaryChildFragment = workInProgress.child;</span>

            <span class="s3">if </span><span class="s1">(_primaryChildFragment !== </span><span class="s3">null</span><span class="s1">) {</span>
              <span class="s0">// $FlowFixMe Flow doesn't support type casting in combination with the -= operator</span>
              <span class="s1">workInProgress.treeBaseDuration -=</span>
                <span class="s1">_primaryChildFragment.treeBaseDuration;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s0">// Successfully completed this tree. If this was a forced client render,</span>
    <span class="s0">// there may have been recoverable errors during first hydration</span>
    <span class="s0">// attempt. If so, add them to a queue so we can log them in the</span>
    <span class="s0">// commit phase.</span>
    <span class="s1">upgradeHydrationErrorsToRecoverable(); </span><span class="s0">// Fall through to normal Suspense path</span>

    <span class="s3">return true</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">completeWork(current, workInProgress, renderLanes) {</span>
  <span class="s3">var </span><span class="s1">newProps = workInProgress.pendingProps; </span><span class="s0">// Note: This intentionally doesn't check if we're hydrating because comparing</span>
  <span class="s0">// to the current tree provider fiber is just as fast and less error-prone.</span>
  <span class="s0">// Ideally we would have a special version of the work loop only</span>
  <span class="s0">// for hydration.</span>

  <span class="s1">popTreeContext(workInProgress);</span>

  <span class="s3">switch </span><span class="s1">(workInProgress.tag) {</span>
    <span class="s3">case </span><span class="s1">IndeterminateComponent:</span>
    <span class="s3">case </span><span class="s1">LazyComponent:</span>
    <span class="s3">case </span><span class="s1">SimpleMemoComponent:</span>
    <span class="s3">case </span><span class="s1">FunctionComponent:</span>
    <span class="s3">case </span><span class="s1">ForwardRef:</span>
    <span class="s3">case </span><span class="s1">Fragment:</span>
    <span class="s3">case </span><span class="s1">Mode:</span>
    <span class="s3">case </span><span class="s1">Profiler:</span>
    <span class="s3">case </span><span class="s1">ContextConsumer:</span>
    <span class="s3">case </span><span class="s1">MemoComponent:</span>
      <span class="s1">bubbleProperties(workInProgress);</span>
      <span class="s3">return null</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s1">ClassComponent: {</span>
      <span class="s3">var </span><span class="s1">Component = workInProgress.type;</span>

      <span class="s3">if </span><span class="s1">(isContextProvider(Component)) {</span>
        <span class="s1">popContext(workInProgress);</span>
      <span class="s1">}</span>

      <span class="s1">bubbleProperties(workInProgress);</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">case </span><span class="s1">HostRoot: {</span>
      <span class="s3">var </span><span class="s1">fiberRoot = workInProgress.stateNode;</span>
      <span class="s1">popHostContainer(workInProgress);</span>
      <span class="s1">popTopLevelContextObject(workInProgress);</span>
      <span class="s1">resetWorkInProgressVersions();</span>

      <span class="s3">if </span><span class="s1">(fiberRoot.pendingContext) {</span>
        <span class="s1">fiberRoot.context = fiberRoot.pendingContext;</span>
        <span class="s1">fiberRoot.pendingContext = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(current === </span><span class="s3">null </span><span class="s1">|| current.child === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s0">// If we hydrated, pop so that we can delete any remaining children</span>
        <span class="s0">// that weren't hydrated.</span>
        <span class="s3">var </span><span class="s1">wasHydrated = popHydrationState();</span>

        <span class="s3">if </span><span class="s1">(wasHydrated) {</span>
          <span class="s0">// If we hydrated, then we'll need to schedule an update for</span>
          <span class="s0">// the commit side-effects on the root.</span>
          <span class="s1">markUpdate(workInProgress);</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s3">if </span><span class="s1">(current !== </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s3">var </span><span class="s1">prevState = current.memoizedState;</span>

            <span class="s3">if </span><span class="s1">(</span>
              <span class="s0">// Check if this is a client root</span>
              <span class="s1">!prevState.isDehydrated || </span><span class="s0">// Check if we reverted to client rendering (e.g. due to an error)</span>
              <span class="s1">(workInProgress.flags &amp; ForceClientRender) !== NoFlags</span>
            <span class="s1">) {</span>
              <span class="s0">// Schedule an effect to clear this container at the start of the</span>
              <span class="s0">// next commit. This handles the case of React rendering into a</span>
              <span class="s0">// container with previous children. It's also safe to do for</span>
              <span class="s0">// updates too, because current.child would only be null if the</span>
              <span class="s0">// previous render was null (so the container would already</span>
              <span class="s0">// be empty).</span>
              <span class="s1">workInProgress.flags |= Snapshot; </span><span class="s0">// If this was a forced client render, there may have been</span>
              <span class="s0">// recoverable errors during first hydration attempt. If so, add</span>
              <span class="s0">// them to a queue so we can log them in the commit phase.</span>

              <span class="s1">upgradeHydrationErrorsToRecoverable();</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">updateHostContainer(current, workInProgress);</span>
      <span class="s1">bubbleProperties(workInProgress);</span>

      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">case </span><span class="s1">HostComponent: {</span>
      <span class="s1">popHostContext(workInProgress);</span>
      <span class="s3">var </span><span class="s1">rootContainerInstance = getRootHostContainer();</span>
      <span class="s3">var </span><span class="s1">type = workInProgress.type;</span>

      <span class="s3">if </span><span class="s1">(current !== </span><span class="s3">null </span><span class="s1">&amp;&amp; workInProgress.stateNode != </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">updateHostComponent$1(</span>
          <span class="s1">current,</span>
          <span class="s1">workInProgress,</span>
          <span class="s1">type,</span>
          <span class="s1">newProps,</span>
          <span class="s1">rootContainerInstance</span>
        <span class="s1">);</span>

        <span class="s3">if </span><span class="s1">(current.ref !== workInProgress.ref) {</span>
          <span class="s1">markRef$1(workInProgress);</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s3">if </span><span class="s1">(!newProps) {</span>
          <span class="s3">if </span><span class="s1">(workInProgress.stateNode === </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s3">throw new </span><span class="s1">Error(</span>
              <span class="s2">&quot;We must have new props for new mounts. This error is likely &quot; </span><span class="s1">+</span>
                <span class="s2">&quot;caused by a bug in React. Please file an issue.&quot;</span>
            <span class="s1">);</span>
          <span class="s1">} </span><span class="s0">// This can happen when we abort work.</span>

          <span class="s1">bubbleProperties(workInProgress);</span>
          <span class="s3">return null</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">var </span><span class="s1">currentHostContext = getHostContext(); </span><span class="s0">// TODO: Move createInstance to beginWork and keep it on a context</span>
        <span class="s0">// &quot;stack&quot; as the parent. Then append children as we go in beginWork</span>
        <span class="s0">// or completeWork depending on whether we want to add them top-&gt;down or</span>
        <span class="s0">// bottom-&gt;up. Top-&gt;down is faster in IE11.</span>

        <span class="s3">var </span><span class="s1">_wasHydrated = popHydrationState();</span>

        <span class="s3">if </span><span class="s1">(_wasHydrated) {</span>
          <span class="s0">// TODO: Move this and createInstance step into the beginPhase</span>
          <span class="s0">// to consolidate.</span>
          <span class="s3">if </span><span class="s1">(prepareToHydrateHostInstance()) {</span>
            <span class="s0">// If changes to the hydrated node need to be applied at the</span>
            <span class="s0">// commit-phase we mark this as such.</span>
            <span class="s1">markUpdate(workInProgress);</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s3">var </span><span class="s1">instance = createInstance(</span>
            <span class="s1">type,</span>
            <span class="s1">newProps,</span>
            <span class="s1">rootContainerInstance,</span>
            <span class="s1">currentHostContext,</span>
            <span class="s1">workInProgress</span>
          <span class="s1">);</span>
          <span class="s1">appendAllChildren(instance, workInProgress, </span><span class="s3">false</span><span class="s1">, </span><span class="s3">false</span><span class="s1">);</span>
          <span class="s1">workInProgress.stateNode = instance; </span><span class="s0">// Certain renderers require commit-time effects for initial mount.</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(workInProgress.ref !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s0">// If there is a ref on a host node we need to schedule a callback</span>
          <span class="s1">markRef$1(workInProgress);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">bubbleProperties(workInProgress);</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">case </span><span class="s1">HostText: {</span>
      <span class="s3">var </span><span class="s1">newText = newProps;</span>

      <span class="s3">if </span><span class="s1">(current &amp;&amp; workInProgress.stateNode != </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">oldText = current.memoizedProps; </span><span class="s0">// If we have an alternate, that means this is an update and we need</span>
        <span class="s0">// to schedule a side-effect to do the updates.</span>

        <span class="s1">updateHostText$1(current, workInProgress, oldText, newText);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">newText !== </span><span class="s2">&quot;string&quot;</span><span class="s1">) {</span>
          <span class="s3">if </span><span class="s1">(workInProgress.stateNode === </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s3">throw new </span><span class="s1">Error(</span>
              <span class="s2">&quot;We must have new props for new mounts. This error is likely &quot; </span><span class="s1">+</span>
                <span class="s2">&quot;caused by a bug in React. Please file an issue.&quot;</span>
            <span class="s1">);</span>
          <span class="s1">} </span><span class="s0">// This can happen when we abort work.</span>
        <span class="s1">}</span>

        <span class="s3">var </span><span class="s1">_rootContainerInstance = getRootHostContainer();</span>

        <span class="s3">var </span><span class="s1">_currentHostContext = getHostContext();</span>

        <span class="s3">var </span><span class="s1">_wasHydrated2 = popHydrationState();</span>

        <span class="s3">if </span><span class="s1">(_wasHydrated2) {</span>
          <span class="s3">if </span><span class="s1">(prepareToHydrateHostTextInstance()) {</span>
            <span class="s1">markUpdate(workInProgress);</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s1">workInProgress.stateNode = createTextInstance(</span>
            <span class="s1">newText,</span>
            <span class="s1">_rootContainerInstance,</span>
            <span class="s1">_currentHostContext,</span>
            <span class="s1">workInProgress</span>
          <span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">bubbleProperties(workInProgress);</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">case </span><span class="s1">SuspenseComponent: {</span>
      <span class="s1">popSuspenseContext(workInProgress);</span>
      <span class="s3">var </span><span class="s1">nextState = workInProgress.memoizedState; </span><span class="s0">// Special path for dehydrated boundaries. We may eventually move this</span>
      <span class="s0">// to its own fiber type so that we can add other kinds of hydration</span>
      <span class="s0">// boundaries that aren't associated with a Suspense tree. In anticipation</span>
      <span class="s0">// of such a refactor, all the hydration logic is contained in</span>
      <span class="s0">// this branch.</span>

      <span class="s3">if </span><span class="s1">(</span>
        <span class="s1">current === </span><span class="s3">null </span><span class="s1">||</span>
        <span class="s1">(current.memoizedState !== </span><span class="s3">null </span><span class="s1">&amp;&amp;</span>
          <span class="s1">current.memoizedState.dehydrated !== </span><span class="s3">null</span><span class="s1">)</span>
      <span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">fallthroughToNormalSuspensePath = completeDehydratedSuspenseBoundary(</span>
          <span class="s1">current,</span>
          <span class="s1">workInProgress,</span>
          <span class="s1">nextState</span>
        <span class="s1">);</span>

        <span class="s3">if </span><span class="s1">(!fallthroughToNormalSuspensePath) {</span>
          <span class="s3">if </span><span class="s1">(workInProgress.flags &amp; ShouldCapture) {</span>
            <span class="s0">// Special case. There were remaining unhydrated nodes. We treat</span>
            <span class="s0">// this as a mismatch. Revert to client rendering.</span>
            <span class="s3">return </span><span class="s1">workInProgress;</span>
          <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s0">// Did not finish hydrating, either because this is the initial</span>
            <span class="s0">// render or because something suspended.</span>
            <span class="s3">return null</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s0">// Continue with the normal Suspense path.</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">((workInProgress.flags &amp; DidCapture) !== NoFlags) {</span>
        <span class="s0">// Something suspended. Re-render with the fallback children.</span>
        <span class="s1">workInProgress.lanes = renderLanes; </span><span class="s0">// Do not reset the effect list.</span>

        <span class="s3">if </span><span class="s1">((workInProgress.mode &amp; ProfileMode) !== NoMode) {</span>
          <span class="s1">transferActualDuration(workInProgress);</span>
        <span class="s1">} </span><span class="s0">// Don't bubble properties in this case.</span>

        <span class="s3">return </span><span class="s1">workInProgress;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">nextDidTimeout = nextState !== </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s3">var </span><span class="s1">prevDidTimeout = current !== </span><span class="s3">null </span><span class="s1">&amp;&amp; current.memoizedState !== </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s0">// a passive effect, which is when we process the transitions</span>

      <span class="s3">if </span><span class="s1">(nextDidTimeout !== prevDidTimeout) {</span>
        <span class="s0">// an effect to toggle the subtree's visibility. When we switch from</span>
        <span class="s0">// fallback -&gt; primary, the inner Offscreen fiber schedules this effect</span>
        <span class="s0">// as part of its normal complete phase. But when we switch from</span>
        <span class="s0">// primary -&gt; fallback, the inner Offscreen fiber does not have a complete</span>
        <span class="s0">// phase. So we need to schedule its effect here.</span>
        <span class="s0">//</span>
        <span class="s0">// We also use this flag to connect/disconnect the effects, but the same</span>
        <span class="s0">// logic applies: when re-connecting, the Offscreen fiber's complete</span>
        <span class="s0">// phase will handle scheduling the effect. It's only when the fallback</span>
        <span class="s0">// is active that we have to do anything special.</span>

        <span class="s3">if </span><span class="s1">(nextDidTimeout) {</span>
          <span class="s3">var </span><span class="s1">_offscreenFiber2 = workInProgress.child;</span>
          <span class="s1">_offscreenFiber2.flags |= Visibility; </span><span class="s0">// TODO: This will still suspend a synchronous tree if anything</span>
          <span class="s0">// in the concurrent tree already suspended during this render.</span>
          <span class="s0">// This is a known bug.</span>

          <span class="s3">if </span><span class="s1">((workInProgress.mode &amp; ConcurrentMode) !== NoMode) {</span>
            <span class="s0">// TODO: Move this back to throwException because this is too late</span>
            <span class="s0">// if this is a large tree which is common for initial loads. We</span>
            <span class="s0">// don't know if we should restart a render or not until we get</span>
            <span class="s0">// this marker, and this is too late.</span>
            <span class="s0">// If this render already had a ping or lower pri updates,</span>
            <span class="s0">// and this is the first time we know we're going to suspend we</span>
            <span class="s0">// should be able to immediately restart from within throwException.</span>
            <span class="s3">var </span><span class="s1">hasInvisibleChildContext =</span>
              <span class="s1">current === </span><span class="s3">null </span><span class="s1">&amp;&amp;</span>
              <span class="s1">(workInProgress.memoizedProps.unstable_avoidThisFallback !==</span>
                <span class="s3">true </span><span class="s1">||</span>
                <span class="s1">!enableSuspenseAvoidThisFallback);</span>

            <span class="s3">if </span><span class="s1">(</span>
              <span class="s1">hasInvisibleChildContext ||</span>
              <span class="s1">hasSuspenseContext(</span>
                <span class="s1">suspenseStackCursor.current,</span>
                <span class="s1">InvisibleParentSuspenseContext</span>
              <span class="s1">)</span>
            <span class="s1">) {</span>
              <span class="s0">// If this was in an invisible tree or a new render, then showing</span>
              <span class="s0">// this boundary is ok.</span>
              <span class="s1">renderDidSuspend();</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
              <span class="s0">// Otherwise, we're going to have to hide content so we should</span>
              <span class="s0">// suspend for longer if possible.</span>
              <span class="s1">renderDidSuspendDelayIfPossible();</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">wakeables = workInProgress.updateQueue;</span>

      <span class="s3">if </span><span class="s1">(wakeables !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s0">// Schedule an effect to attach a retry listener to the promise.</span>
        <span class="s0">// TODO: Move to passive phase</span>
        <span class="s1">workInProgress.flags |= Update;</span>
      <span class="s1">}</span>

      <span class="s1">bubbleProperties(workInProgress);</span>

      <span class="s1">{</span>
        <span class="s3">if </span><span class="s1">((workInProgress.mode &amp; ProfileMode) !== NoMode) {</span>
          <span class="s3">if </span><span class="s1">(nextDidTimeout) {</span>
            <span class="s0">// Don't count time spent in a timed out Suspense subtree as part of the base duration.</span>
            <span class="s3">var </span><span class="s1">primaryChildFragment = workInProgress.child;</span>

            <span class="s3">if </span><span class="s1">(primaryChildFragment !== </span><span class="s3">null</span><span class="s1">) {</span>
              <span class="s0">// $FlowFixMe Flow doesn't support type casting in combination with the -= operator</span>
              <span class="s1">workInProgress.treeBaseDuration -=</span>
                <span class="s1">primaryChildFragment.treeBaseDuration;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">case </span><span class="s1">HostPortal:</span>
      <span class="s1">popHostContainer(workInProgress);</span>
      <span class="s1">updateHostContainer(current, workInProgress);</span>

      <span class="s3">if </span><span class="s1">(current === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">preparePortalMount(workInProgress.stateNode.containerInfo);</span>
      <span class="s1">}</span>

      <span class="s1">bubbleProperties(workInProgress);</span>
      <span class="s3">return null</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s1">ContextProvider:</span>
      <span class="s0">// Pop provider fiber</span>
      <span class="s3">var </span><span class="s1">context = workInProgress.type._context;</span>
      <span class="s1">popProvider(context, workInProgress);</span>
      <span class="s1">bubbleProperties(workInProgress);</span>
      <span class="s3">return null</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s1">IncompleteClassComponent: {</span>
      <span class="s0">// Same as class component case. I put it down here so that the tags are</span>
      <span class="s0">// sequential to ensure this switch is compiled to a jump table.</span>
      <span class="s3">var </span><span class="s1">_Component = workInProgress.type;</span>

      <span class="s3">if </span><span class="s1">(isContextProvider(_Component)) {</span>
        <span class="s1">popContext(workInProgress);</span>
      <span class="s1">}</span>

      <span class="s1">bubbleProperties(workInProgress);</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">case </span><span class="s1">SuspenseListComponent: {</span>
      <span class="s1">popSuspenseContext(workInProgress);</span>
      <span class="s3">var </span><span class="s1">renderState = workInProgress.memoizedState;</span>

      <span class="s3">if </span><span class="s1">(renderState === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s0">// We're running in the default, &quot;independent&quot; mode.</span>
        <span class="s0">// We don't do anything in this mode.</span>
        <span class="s1">bubbleProperties(workInProgress);</span>
        <span class="s3">return null</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">didSuspendAlready = (workInProgress.flags &amp; DidCapture) !== NoFlags;</span>
      <span class="s3">var </span><span class="s1">renderedTail = renderState.rendering;</span>

      <span class="s3">if </span><span class="s1">(renderedTail === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s0">// We just rendered the head.</span>
        <span class="s3">if </span><span class="s1">(!didSuspendAlready) {</span>
          <span class="s0">// This is the first pass. We need to figure out if anything is still</span>
          <span class="s0">// suspended in the rendered set.</span>
          <span class="s0">// If new content unsuspended, but there's still some content that</span>
          <span class="s0">// didn't. Then we need to do a second pass that forces everything</span>
          <span class="s0">// to keep showing their fallbacks.</span>
          <span class="s0">// We might be suspended if something in this render pass suspended, or</span>
          <span class="s0">// something in the previous committed pass suspended. Otherwise,</span>
          <span class="s0">// there's no chance so we can skip the expensive call to</span>
          <span class="s0">// findFirstSuspended.</span>
          <span class="s3">var </span><span class="s1">cannotBeSuspended =</span>
            <span class="s1">renderHasNotSuspendedYet() &amp;&amp;</span>
            <span class="s1">(current === </span><span class="s3">null </span><span class="s1">|| (current.flags &amp; DidCapture) === NoFlags);</span>

          <span class="s3">if </span><span class="s1">(!cannotBeSuspended) {</span>
            <span class="s3">var </span><span class="s1">row = workInProgress.child;</span>

            <span class="s3">while </span><span class="s1">(row !== </span><span class="s3">null</span><span class="s1">) {</span>
              <span class="s3">var </span><span class="s1">suspended = findFirstSuspended(row);</span>

              <span class="s3">if </span><span class="s1">(suspended !== </span><span class="s3">null</span><span class="s1">) {</span>
                <span class="s1">didSuspendAlready = </span><span class="s3">true</span><span class="s1">;</span>
                <span class="s1">workInProgress.flags |= DidCapture;</span>
                <span class="s1">cutOffTailIfNeeded(renderState, </span><span class="s3">false</span><span class="s1">); </span><span class="s0">// If this is a newly suspended tree, it might not get committed as</span>
                <span class="s0">// part of the second pass. In that case nothing will subscribe to</span>
                <span class="s0">// its thenables. Instead, we'll transfer its thenables to the</span>
                <span class="s0">// SuspenseList so that it can retry if they resolve.</span>
                <span class="s0">// There might be multiple of these in the list but since we're</span>
                <span class="s0">// going to wait for all of them anyway, it doesn't really matter</span>
                <span class="s0">// which ones gets to ping. In theory we could get clever and keep</span>
                <span class="s0">// track of how many dependencies remain but it gets tricky because</span>
                <span class="s0">// in the meantime, we can add/remove/change items and dependencies.</span>
                <span class="s0">// We might bail out of the loop before finding any but that</span>
                <span class="s0">// doesn't matter since that means that the other boundaries that</span>
                <span class="s0">// we did find already has their listeners attached.</span>

                <span class="s3">var </span><span class="s1">newThenables = suspended.updateQueue;</span>

                <span class="s3">if </span><span class="s1">(newThenables !== </span><span class="s3">null</span><span class="s1">) {</span>
                  <span class="s1">workInProgress.updateQueue = newThenables;</span>
                  <span class="s1">workInProgress.flags |= Update;</span>
                <span class="s1">} </span><span class="s0">// Rerender the whole list, but this time, we'll force fallbacks</span>
                <span class="s0">// to stay in place.</span>
                <span class="s0">// Reset the effect flags before doing the second pass since that's now invalid.</span>
                <span class="s0">// Reset the child fibers to their original state.</span>

                <span class="s1">workInProgress.subtreeFlags = NoFlags;</span>
                <span class="s1">resetChildFibers(workInProgress, renderLanes); </span><span class="s0">// Set up the Suspense Context to force suspense and immediately</span>
                <span class="s0">// rerender the children.</span>

                <span class="s1">pushSuspenseContext(</span>
                  <span class="s1">workInProgress,</span>
                  <span class="s1">setShallowSuspenseContext(</span>
                    <span class="s1">suspenseStackCursor.current,</span>
                    <span class="s1">ForceSuspenseFallback</span>
                  <span class="s1">)</span>
                <span class="s1">); </span><span class="s0">// Don't bubble properties in this case.</span>

                <span class="s3">return </span><span class="s1">workInProgress.child;</span>
              <span class="s1">}</span>

              <span class="s1">row = row.sibling;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s3">if </span><span class="s1">(renderState.tail !== </span><span class="s3">null </span><span class="s1">&amp;&amp; now() &gt; getRenderTargetTime()) {</span>
            <span class="s0">// We have already passed our CPU deadline but we still have rows</span>
            <span class="s0">// left in the tail. We'll just give up further attempts to render</span>
            <span class="s0">// the main content and only render fallbacks.</span>
            <span class="s1">workInProgress.flags |= DidCapture;</span>
            <span class="s1">didSuspendAlready = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s1">cutOffTailIfNeeded(renderState, </span><span class="s3">false</span><span class="s1">); </span><span class="s0">// Since nothing actually suspended, there will nothing to ping this</span>
            <span class="s0">// to get it started back up to attempt the next item. While in terms</span>
            <span class="s0">// of priority this work has the same priority as this current render,</span>
            <span class="s0">// it's not part of the same transition once the transition has</span>
            <span class="s0">// committed. If it's sync, we still want to yield so that it can be</span>
            <span class="s0">// painted. Conceptually, this is really the same as pinging.</span>
            <span class="s0">// We can use any RetryLane even if it's the one currently rendering</span>
            <span class="s0">// since we're leaving it behind on this node.</span>

            <span class="s1">workInProgress.lanes = SomeRetryLane;</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s1">cutOffTailIfNeeded(renderState, </span><span class="s3">false</span><span class="s1">);</span>
        <span class="s1">} </span><span class="s0">// Next we're going to render the tail.</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s0">// Append the rendered row to the child list.</span>
        <span class="s3">if </span><span class="s1">(!didSuspendAlready) {</span>
          <span class="s3">var </span><span class="s1">_suspended = findFirstSuspended(renderedTail);</span>

          <span class="s3">if </span><span class="s1">(_suspended !== </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s1">workInProgress.flags |= DidCapture;</span>
            <span class="s1">didSuspendAlready = </span><span class="s3">true</span><span class="s1">; </span><span class="s0">// Ensure we transfer the update queue to the parent so that it doesn't</span>
            <span class="s0">// get lost if this row ends up dropped during a second pass.</span>

            <span class="s3">var </span><span class="s1">_newThenables = _suspended.updateQueue;</span>

            <span class="s3">if </span><span class="s1">(_newThenables !== </span><span class="s3">null</span><span class="s1">) {</span>
              <span class="s1">workInProgress.updateQueue = _newThenables;</span>
              <span class="s1">workInProgress.flags |= Update;</span>
            <span class="s1">}</span>

            <span class="s1">cutOffTailIfNeeded(renderState, </span><span class="s3">true</span><span class="s1">); </span><span class="s0">// This might have been modified.</span>

            <span class="s3">if </span><span class="s1">(</span>
              <span class="s1">renderState.tail === </span><span class="s3">null </span><span class="s1">&amp;&amp;</span>
              <span class="s1">renderState.tailMode === </span><span class="s2">&quot;hidden&quot; </span><span class="s1">&amp;&amp;</span>
              <span class="s1">!renderedTail.alternate &amp;&amp;</span>
              <span class="s1">!getIsHydrating() </span><span class="s0">// We don't cut it if we're hydrating.</span>
            <span class="s1">) {</span>
              <span class="s0">// We're done.</span>
              <span class="s1">bubbleProperties(workInProgress);</span>
              <span class="s3">return null</span><span class="s1">;</span>
            <span class="s1">}</span>
          <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span>
            <span class="s0">// The time it took to render last row is greater than the remaining</span>
            <span class="s0">// time we have to render. So rendering one more row would likely</span>
            <span class="s0">// exceed it.</span>
            <span class="s1">now() * </span><span class="s4">2 </span><span class="s1">- renderState.renderingStartTime &gt;</span>
              <span class="s1">getRenderTargetTime() &amp;&amp;</span>
            <span class="s1">renderLanes !== OffscreenLane</span>
          <span class="s1">) {</span>
            <span class="s0">// We have now passed our CPU deadline and we'll just give up further</span>
            <span class="s0">// attempts to render the main content and only render fallbacks.</span>
            <span class="s0">// The assumption is that this is usually faster.</span>
            <span class="s1">workInProgress.flags |= DidCapture;</span>
            <span class="s1">didSuspendAlready = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s1">cutOffTailIfNeeded(renderState, </span><span class="s3">false</span><span class="s1">); </span><span class="s0">// Since nothing actually suspended, there will nothing to ping this</span>
            <span class="s0">// to get it started back up to attempt the next item. While in terms</span>
            <span class="s0">// of priority this work has the same priority as this current render,</span>
            <span class="s0">// it's not part of the same transition once the transition has</span>
            <span class="s0">// committed. If it's sync, we still want to yield so that it can be</span>
            <span class="s0">// painted. Conceptually, this is really the same as pinging.</span>
            <span class="s0">// We can use any RetryLane even if it's the one currently rendering</span>
            <span class="s0">// since we're leaving it behind on this node.</span>

            <span class="s1">workInProgress.lanes = SomeRetryLane;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(renderState.isBackwards) {</span>
          <span class="s0">// The effect list of the backwards tail will have been added</span>
          <span class="s0">// to the end. This breaks the guarantee that life-cycles fire in</span>
          <span class="s0">// sibling order but that isn't a strong guarantee promised by React.</span>
          <span class="s0">// Especially since these might also just pop in during future commits.</span>
          <span class="s0">// Append to the beginning of the list.</span>
          <span class="s1">renderedTail.sibling = workInProgress.child;</span>
          <span class="s1">workInProgress.child = renderedTail;</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s3">var </span><span class="s1">previousSibling = renderState.last;</span>

          <span class="s3">if </span><span class="s1">(previousSibling !== </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s1">previousSibling.sibling = renderedTail;</span>
          <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">workInProgress.child = renderedTail;</span>
          <span class="s1">}</span>

          <span class="s1">renderState.last = renderedTail;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(renderState.tail !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s0">// We still have tail rows to render.</span>
        <span class="s0">// Pop a row.</span>
        <span class="s3">var </span><span class="s1">next = renderState.tail;</span>
        <span class="s1">renderState.rendering = next;</span>
        <span class="s1">renderState.tail = next.sibling;</span>
        <span class="s1">renderState.renderingStartTime = now();</span>
        <span class="s1">next.sibling = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// Restore the context.</span>
        <span class="s0">// TODO: We can probably just avoid popping it instead and only</span>
        <span class="s0">// setting it the first time we go from not suspended to suspended.</span>

        <span class="s3">var </span><span class="s1">suspenseContext = suspenseStackCursor.current;</span>

        <span class="s3">if </span><span class="s1">(didSuspendAlready) {</span>
          <span class="s1">suspenseContext = setShallowSuspenseContext(</span>
            <span class="s1">suspenseContext,</span>
            <span class="s1">ForceSuspenseFallback</span>
          <span class="s1">);</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s1">suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);</span>
        <span class="s1">}</span>

        <span class="s1">pushSuspenseContext(workInProgress, suspenseContext); </span><span class="s0">// Do a pass over the next row.</span>
        <span class="s0">// Don't bubble properties in this case.</span>

        <span class="s3">return </span><span class="s1">next;</span>
      <span class="s1">}</span>

      <span class="s1">bubbleProperties(workInProgress);</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">case </span><span class="s1">ScopeComponent: {</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">case </span><span class="s1">OffscreenComponent:</span>
    <span class="s3">case </span><span class="s1">LegacyHiddenComponent: {</span>
      <span class="s1">popRenderLanes(workInProgress);</span>
      <span class="s3">var </span><span class="s1">_nextState = workInProgress.memoizedState;</span>
      <span class="s3">var </span><span class="s1">nextIsHidden = _nextState !== </span><span class="s3">null</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s1">(current !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">_prevState = current.memoizedState;</span>
        <span class="s3">var </span><span class="s1">prevIsHidden = _prevState !== </span><span class="s3">null</span><span class="s1">;</span>

        <span class="s3">if </span><span class="s1">(</span>
          <span class="s1">prevIsHidden !== nextIsHidden &amp;&amp; </span><span class="s0">// LegacyHidden doesn't do any hiding  it only pre-renders.</span>
          <span class="s1">!enableLegacyHidden</span>
        <span class="s1">) {</span>
          <span class="s1">workInProgress.flags |= Visibility;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(!nextIsHidden || (workInProgress.mode &amp; ConcurrentMode) === NoMode) {</span>
        <span class="s1">bubbleProperties(workInProgress);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s0">// Don't bubble properties for hidden children unless we're rendering</span>
        <span class="s0">// at offscreen priority.</span>
        <span class="s3">if </span><span class="s1">(includesSomeLane(subtreeRenderLanes, OffscreenLane)) {</span>
          <span class="s1">bubbleProperties(workInProgress);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">case </span><span class="s1">CacheComponent: {</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">case </span><span class="s1">TracingMarkerComponent: {</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">throw new </span><span class="s1">Error(</span>
    <span class="s2">&quot;Unknown unit of work tag (&quot; </span><span class="s1">+</span>
      <span class="s1">workInProgress.tag +</span>
      <span class="s2">&quot;). This error is likely caused by a bug in &quot; </span><span class="s1">+</span>
      <span class="s2">&quot;React. Please file an issue.&quot;</span>
  <span class="s1">);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">unwindWork(current, workInProgress, renderLanes) {</span>
  <span class="s0">// Note: This intentionally doesn't check if we're hydrating because comparing</span>
  <span class="s0">// to the current tree provider fiber is just as fast and less error-prone.</span>
  <span class="s0">// Ideally we would have a special version of the work loop only</span>
  <span class="s0">// for hydration.</span>
  <span class="s1">popTreeContext(workInProgress);</span>

  <span class="s3">switch </span><span class="s1">(workInProgress.tag) {</span>
    <span class="s3">case </span><span class="s1">ClassComponent: {</span>
      <span class="s3">var </span><span class="s1">Component = workInProgress.type;</span>

      <span class="s3">if </span><span class="s1">(isContextProvider(Component)) {</span>
        <span class="s1">popContext(workInProgress);</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">flags = workInProgress.flags;</span>

      <span class="s3">if </span><span class="s1">(flags &amp; ShouldCapture) {</span>
        <span class="s1">workInProgress.flags = (flags &amp; ~ShouldCapture) | DidCapture;</span>

        <span class="s3">if </span><span class="s1">((workInProgress.mode &amp; ProfileMode) !== NoMode) {</span>
          <span class="s1">transferActualDuration(workInProgress);</span>
        <span class="s1">}</span>

        <span class="s3">return </span><span class="s1">workInProgress;</span>
      <span class="s1">}</span>

      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">case </span><span class="s1">HostRoot: {</span>
      <span class="s3">var </span><span class="s1">root = workInProgress.stateNode;</span>
      <span class="s1">popHostContainer(workInProgress);</span>
      <span class="s1">popTopLevelContextObject(workInProgress);</span>
      <span class="s1">resetWorkInProgressVersions();</span>
      <span class="s3">var </span><span class="s1">_flags = workInProgress.flags;</span>

      <span class="s3">if </span><span class="s1">(</span>
        <span class="s1">(_flags &amp; ShouldCapture) !== NoFlags &amp;&amp;</span>
        <span class="s1">(_flags &amp; DidCapture) === NoFlags</span>
      <span class="s1">) {</span>
        <span class="s0">// There was an error during render that wasn't captured by a suspense</span>
        <span class="s0">// boundary. Do a second pass on the root to unmount the children.</span>
        <span class="s1">workInProgress.flags = (_flags &amp; ~ShouldCapture) | DidCapture;</span>
        <span class="s3">return </span><span class="s1">workInProgress;</span>
      <span class="s1">} </span><span class="s0">// We unwound to the root without completing it. Exit.</span>

      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">case </span><span class="s1">HostComponent: {</span>
      <span class="s0">// TODO: popHydrationState</span>
      <span class="s1">popHostContext(workInProgress);</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">case </span><span class="s1">SuspenseComponent: {</span>
      <span class="s1">popSuspenseContext(workInProgress);</span>
      <span class="s3">var </span><span class="s1">suspenseState = workInProgress.memoizedState;</span>

      <span class="s3">if </span><span class="s1">(suspenseState !== </span><span class="s3">null </span><span class="s1">&amp;&amp; suspenseState.dehydrated !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(workInProgress.alternate === </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s3">throw new </span><span class="s1">Error(</span>
            <span class="s2">&quot;Threw in newly mounted dehydrated component. This is likely a bug in &quot; </span><span class="s1">+</span>
              <span class="s2">&quot;React. Please file an issue.&quot;</span>
          <span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">_flags2 = workInProgress.flags;</span>

      <span class="s3">if </span><span class="s1">(_flags2 &amp; ShouldCapture) {</span>
        <span class="s1">workInProgress.flags = (_flags2 &amp; ~ShouldCapture) | DidCapture; </span><span class="s0">// Captured a suspense effect. Re-render the boundary.</span>

        <span class="s3">if </span><span class="s1">((workInProgress.mode &amp; ProfileMode) !== NoMode) {</span>
          <span class="s1">transferActualDuration(workInProgress);</span>
        <span class="s1">}</span>

        <span class="s3">return </span><span class="s1">workInProgress;</span>
      <span class="s1">}</span>

      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">case </span><span class="s1">SuspenseListComponent: {</span>
      <span class="s1">popSuspenseContext(workInProgress); </span><span class="s0">// SuspenseList doesn't actually catch anything. It should've been</span>
      <span class="s0">// caught by a nested boundary. If not, it should bubble through.</span>

      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">case </span><span class="s1">HostPortal:</span>
      <span class="s1">popHostContainer(workInProgress);</span>
      <span class="s3">return null</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s1">ContextProvider:</span>
      <span class="s3">var </span><span class="s1">context = workInProgress.type._context;</span>
      <span class="s1">popProvider(context, workInProgress);</span>
      <span class="s3">return null</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s1">OffscreenComponent:</span>
    <span class="s3">case </span><span class="s1">LegacyHiddenComponent:</span>
      <span class="s1">popRenderLanes(workInProgress);</span>
      <span class="s3">return null</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s1">CacheComponent:</span>
      <span class="s3">return null</span><span class="s1">;</span>

    <span class="s3">default</span><span class="s1">:</span>
      <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">unwindInterruptedWork(current, interruptedWork, renderLanes) {</span>
  <span class="s0">// Note: This intentionally doesn't check if we're hydrating because comparing</span>
  <span class="s0">// to the current tree provider fiber is just as fast and less error-prone.</span>
  <span class="s0">// Ideally we would have a special version of the work loop only</span>
  <span class="s0">// for hydration.</span>
  <span class="s1">popTreeContext(interruptedWork);</span>

  <span class="s3">switch </span><span class="s1">(interruptedWork.tag) {</span>
    <span class="s3">case </span><span class="s1">ClassComponent: {</span>
      <span class="s3">var </span><span class="s1">childContextTypes = interruptedWork.type.childContextTypes;</span>

      <span class="s3">if </span><span class="s1">(childContextTypes !== </span><span class="s3">null </span><span class="s1">&amp;&amp; childContextTypes !== undefined) {</span>
        <span class="s1">popContext(interruptedWork);</span>
      <span class="s1">}</span>

      <span class="s3">break</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">case </span><span class="s1">HostRoot: {</span>
      <span class="s3">var </span><span class="s1">root = interruptedWork.stateNode;</span>
      <span class="s1">popHostContainer(interruptedWork);</span>
      <span class="s1">popTopLevelContextObject(interruptedWork);</span>
      <span class="s1">resetWorkInProgressVersions();</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">case </span><span class="s1">HostComponent: {</span>
      <span class="s1">popHostContext(interruptedWork);</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">case </span><span class="s1">HostPortal:</span>
      <span class="s1">popHostContainer(interruptedWork);</span>
      <span class="s3">break</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s1">SuspenseComponent:</span>
      <span class="s1">popSuspenseContext(interruptedWork);</span>
      <span class="s3">break</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s1">SuspenseListComponent:</span>
      <span class="s1">popSuspenseContext(interruptedWork);</span>
      <span class="s3">break</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s1">ContextProvider:</span>
      <span class="s3">var </span><span class="s1">context = interruptedWork.type._context;</span>
      <span class="s1">popProvider(context, interruptedWork);</span>
      <span class="s3">break</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s1">OffscreenComponent:</span>
    <span class="s3">case </span><span class="s1">LegacyHiddenComponent:</span>
      <span class="s1">popRenderLanes(interruptedWork);</span>
      <span class="s3">break</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">didWarnAboutUndefinedSnapshotBeforeUpdate = </span><span class="s3">null</span><span class="s1">;</span>

<span class="s1">{</span>
  <span class="s1">didWarnAboutUndefinedSnapshotBeforeUpdate = </span><span class="s3">new </span><span class="s1">Set();</span>
<span class="s1">} </span><span class="s0">// Used during the commit phase to track the state of the Offscreen component stack.</span>
<span class="s3">var </span><span class="s1">PossiblyWeakSet = </span><span class="s3">typeof </span><span class="s1">WeakSet === </span><span class="s2">&quot;function&quot; </span><span class="s1">? WeakSet : Set;</span>
<span class="s3">var </span><span class="s1">nextEffect = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// Used for Profiling builds to track updaters.</span>

<span class="s3">var </span><span class="s1">inProgressLanes = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">inProgressRoot = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s3">function </span><span class="s1">reportUncaughtErrorInDEV(error) {</span>
  <span class="s0">// Wrapping each small part of the commit phase into a guarded</span>
  <span class="s0">// callback is a bit too slow (https://github.com/facebook/react/pull/21666).</span>
  <span class="s0">// But we rely on it to surface errors to DEV tools like overlays</span>
  <span class="s0">// (https://github.com/facebook/react/issues/21712).</span>
  <span class="s0">// As a compromise, rethrow only caught errors in a guard.</span>
  <span class="s1">{</span>
    <span class="s1">invokeGuardedCallback(</span><span class="s3">null</span><span class="s1">, </span><span class="s3">function</span><span class="s1">() {</span>
      <span class="s3">throw </span><span class="s1">error;</span>
    <span class="s1">});</span>
    <span class="s1">clearCaughtError();</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">callComponentWillUnmountWithTimer = </span><span class="s3">function</span><span class="s1">(current, instance) {</span>
  <span class="s1">instance.props = current.memoizedProps;</span>
  <span class="s1">instance.state = current.memoizedState;</span>

  <span class="s3">if </span><span class="s1">(current.mode &amp; ProfileMode) {</span>
    <span class="s3">try </span><span class="s1">{</span>
      <span class="s1">startLayoutEffectTimer();</span>
      <span class="s1">instance.componentWillUnmount();</span>
    <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
      <span class="s1">recordLayoutEffectDuration(current);</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">instance.componentWillUnmount();</span>
  <span class="s1">}</span>
<span class="s1">}; </span><span class="s0">// Capture errors so they don't interrupt mounting.</span>

<span class="s3">function </span><span class="s1">safelyCallComponentWillUnmount(</span>
  <span class="s1">current,</span>
  <span class="s1">nearestMountedAncestor,</span>
  <span class="s1">instance</span>
<span class="s1">) {</span>
  <span class="s3">try </span><span class="s1">{</span>
    <span class="s1">callComponentWillUnmountWithTimer(current, instance);</span>
  <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
    <span class="s1">captureCommitPhaseError(current, nearestMountedAncestor, error);</span>
  <span class="s1">}</span>
<span class="s1">} </span><span class="s0">// Capture errors so they don't interrupt mounting.</span>

<span class="s3">function </span><span class="s1">safelyDetachRef(current, nearestMountedAncestor) {</span>
  <span class="s3">var </span><span class="s1">ref = current.ref;</span>

  <span class="s3">if </span><span class="s1">(ref !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">ref === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">retVal;</span>

      <span class="s3">try </span><span class="s1">{</span>
        <span class="s3">if </span><span class="s1">(</span>
          <span class="s1">enableProfilerTimer &amp;&amp;</span>
          <span class="s1">enableProfilerCommitHooks &amp;&amp;</span>
          <span class="s1">current.mode &amp; ProfileMode</span>
        <span class="s1">) {</span>
          <span class="s3">try </span><span class="s1">{</span>
            <span class="s1">startLayoutEffectTimer();</span>
            <span class="s1">retVal = ref(</span><span class="s3">null</span><span class="s1">);</span>
          <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
            <span class="s1">recordLayoutEffectDuration(current);</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s1">retVal = ref(</span><span class="s3">null</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
        <span class="s1">captureCommitPhaseError(current, nearestMountedAncestor, error);</span>
      <span class="s1">}</span>

      <span class="s1">{</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">retVal === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
          <span class="s1">error(</span>
            <span class="s2">&quot;Unexpected return value from a callback ref in %s. &quot; </span><span class="s1">+</span>
              <span class="s2">&quot;A callback ref should not return a function.&quot;</span><span class="s1">,</span>
            <span class="s1">getComponentNameFromFiber(current)</span>
          <span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">ref.current = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">safelyCallDestroy(current, nearestMountedAncestor, destroy) {</span>
  <span class="s3">try </span><span class="s1">{</span>
    <span class="s1">destroy();</span>
  <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
    <span class="s1">captureCommitPhaseError(current, nearestMountedAncestor, error);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">focusedInstanceHandle = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">shouldFireAfterActiveInstanceBlur = </span><span class="s3">false</span><span class="s1">;</span>
<span class="s3">function </span><span class="s1">commitBeforeMutationEffects(root, firstChild) {</span>
  <span class="s1">focusedInstanceHandle = prepareForCommit(root.containerInfo);</span>
  <span class="s1">nextEffect = firstChild;</span>
  <span class="s1">commitBeforeMutationEffects_begin(); </span><span class="s0">// We no longer need to track the active instance fiber</span>

  <span class="s3">var </span><span class="s1">shouldFire = shouldFireAfterActiveInstanceBlur;</span>
  <span class="s1">shouldFireAfterActiveInstanceBlur = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s1">focusedInstanceHandle = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">return </span><span class="s1">shouldFire;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">commitBeforeMutationEffects_begin() {</span>
  <span class="s3">while </span><span class="s1">(nextEffect !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">fiber = nextEffect; </span><span class="s0">// This phase is only used for beforeActiveInstanceBlur.</span>

    <span class="s3">var </span><span class="s1">child = fiber.child;</span>

    <span class="s3">if </span><span class="s1">(</span>
      <span class="s1">(fiber.subtreeFlags &amp; BeforeMutationMask) !== NoFlags &amp;&amp;</span>
      <span class="s1">child !== </span><span class="s3">null</span>
    <span class="s1">) {</span>
      <span class="s1">child.</span><span class="s3">return </span><span class="s1">= fiber;</span>
      <span class="s1">nextEffect = child;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">commitBeforeMutationEffects_complete();</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">commitBeforeMutationEffects_complete() {</span>
  <span class="s3">while </span><span class="s1">(nextEffect !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">fiber = nextEffect;</span>
    <span class="s1">setCurrentFiber(fiber);</span>

    <span class="s3">try </span><span class="s1">{</span>
      <span class="s1">commitBeforeMutationEffectsOnFiber(fiber);</span>
    <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
      <span class="s1">captureCommitPhaseError(fiber, fiber.</span><span class="s3">return</span><span class="s1">, error);</span>
    <span class="s1">}</span>

    <span class="s1">resetCurrentFiber();</span>
    <span class="s3">var </span><span class="s1">sibling = fiber.sibling;</span>

    <span class="s3">if </span><span class="s1">(sibling !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">sibling.</span><span class="s3">return </span><span class="s1">= fiber.</span><span class="s3">return</span><span class="s1">;</span>
      <span class="s1">nextEffect = sibling;</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">nextEffect = fiber.</span><span class="s3">return</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">commitBeforeMutationEffectsOnFiber(finishedWork) {</span>
  <span class="s3">var </span><span class="s1">current = finishedWork.alternate;</span>
  <span class="s3">var </span><span class="s1">flags = finishedWork.flags;</span>

  <span class="s3">if </span><span class="s1">((flags &amp; Snapshot) !== NoFlags) {</span>
    <span class="s1">setCurrentFiber(finishedWork);</span>

    <span class="s3">switch </span><span class="s1">(finishedWork.tag) {</span>
      <span class="s3">case </span><span class="s1">FunctionComponent:</span>
      <span class="s3">case </span><span class="s1">ForwardRef:</span>
      <span class="s3">case </span><span class="s1">SimpleMemoComponent: {</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">ClassComponent: {</span>
        <span class="s3">if </span><span class="s1">(current !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s3">var </span><span class="s1">prevProps = current.memoizedProps;</span>
          <span class="s3">var </span><span class="s1">prevState = current.memoizedState;</span>
          <span class="s3">var </span><span class="s1">instance = finishedWork.stateNode; </span><span class="s0">// We could update instance props and state here,</span>
          <span class="s0">// but instead we rely on them being set during last render.</span>
          <span class="s0">// TODO: revisit this when we implement resuming.</span>

          <span class="s1">{</span>
            <span class="s3">if </span><span class="s1">(</span>
              <span class="s1">finishedWork.type === finishedWork.elementType &amp;&amp;</span>
              <span class="s1">!didWarnAboutReassigningProps</span>
            <span class="s1">) {</span>
              <span class="s3">if </span><span class="s1">(instance.props !== finishedWork.memoizedProps) {</span>
                <span class="s1">error(</span>
                  <span class="s2">&quot;Expected %s props to match memoized props before &quot; </span><span class="s1">+</span>
                    <span class="s2">&quot;getSnapshotBeforeUpdate. &quot; </span><span class="s1">+</span>
                    <span class="s2">&quot;This might either be because of a bug in React, or because &quot; </span><span class="s1">+</span>
                    <span class="s2">&quot;a component reassigns its own `this.props`. &quot; </span><span class="s1">+</span>
                    <span class="s2">&quot;Please file an issue.&quot;</span><span class="s1">,</span>
                  <span class="s1">getComponentNameFromFiber(finishedWork) || </span><span class="s2">&quot;instance&quot;</span>
                <span class="s1">);</span>
              <span class="s1">}</span>

              <span class="s3">if </span><span class="s1">(instance.state !== finishedWork.memoizedState) {</span>
                <span class="s1">error(</span>
                  <span class="s2">&quot;Expected %s state to match memoized state before &quot; </span><span class="s1">+</span>
                    <span class="s2">&quot;getSnapshotBeforeUpdate. &quot; </span><span class="s1">+</span>
                    <span class="s2">&quot;This might either be because of a bug in React, or because &quot; </span><span class="s1">+</span>
                    <span class="s2">&quot;a component reassigns its own `this.state`. &quot; </span><span class="s1">+</span>
                    <span class="s2">&quot;Please file an issue.&quot;</span><span class="s1">,</span>
                  <span class="s1">getComponentNameFromFiber(finishedWork) || </span><span class="s2">&quot;instance&quot;</span>
                <span class="s1">);</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s3">var </span><span class="s1">snapshot = instance.getSnapshotBeforeUpdate(</span>
            <span class="s1">finishedWork.elementType === finishedWork.type</span>
              <span class="s1">? prevProps</span>
              <span class="s1">: resolveDefaultProps(finishedWork.type, prevProps),</span>
            <span class="s1">prevState</span>
          <span class="s1">);</span>

          <span class="s1">{</span>
            <span class="s3">var </span><span class="s1">didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;</span>

            <span class="s3">if </span><span class="s1">(snapshot === undefined &amp;&amp; !didWarnSet.has(finishedWork.type)) {</span>
              <span class="s1">didWarnSet.add(finishedWork.type);</span>

              <span class="s1">error(</span>
                <span class="s2">&quot;%s.getSnapshotBeforeUpdate(): A snapshot value (or null) &quot; </span><span class="s1">+</span>
                  <span class="s2">&quot;must be returned. You have returned undefined.&quot;</span><span class="s1">,</span>
                <span class="s1">getComponentNameFromFiber(finishedWork)</span>
              <span class="s1">);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s1">instance.__reactInternalSnapshotBeforeUpdate = snapshot;</span>
        <span class="s1">}</span>

        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">HostRoot: {</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">HostComponent:</span>
      <span class="s3">case </span><span class="s1">HostText:</span>
      <span class="s3">case </span><span class="s1">HostPortal:</span>
      <span class="s3">case </span><span class="s1">IncompleteClassComponent:</span>
        <span class="s0">// Nothing to do for these component types</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">default</span><span class="s1">: {</span>
        <span class="s3">throw new </span><span class="s1">Error(</span>
          <span class="s2">&quot;This unit of work tag should not have side-effects. This error is &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;likely caused by a bug in React. Please file an issue.&quot;</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">resetCurrentFiber();</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">commitHookEffectListUnmount(</span>
  <span class="s1">flags,</span>
  <span class="s1">finishedWork,</span>
  <span class="s1">nearestMountedAncestor</span>
<span class="s1">) {</span>
  <span class="s3">var </span><span class="s1">updateQueue = finishedWork.updateQueue;</span>
  <span class="s3">var </span><span class="s1">lastEffect = updateQueue !== </span><span class="s3">null </span><span class="s1">? updateQueue.lastEffect : </span><span class="s3">null</span><span class="s1">;</span>

  <span class="s3">if </span><span class="s1">(lastEffect !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">firstEffect = lastEffect.next;</span>
    <span class="s3">var </span><span class="s1">effect = firstEffect;</span>

    <span class="s3">do </span><span class="s1">{</span>
      <span class="s3">if </span><span class="s1">((effect.tag &amp; flags) === flags) {</span>
        <span class="s0">// Unmount</span>
        <span class="s3">var </span><span class="s1">destroy = effect.destroy;</span>
        <span class="s1">effect.destroy = undefined;</span>

        <span class="s3">if </span><span class="s1">(destroy !== undefined) {</span>
          <span class="s1">{</span>
            <span class="s3">if </span><span class="s1">((flags &amp; Insertion) !== NoFlags$1) {</span>
              <span class="s1">setIsRunningInsertionEffect(</span><span class="s3">true</span><span class="s1">);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s1">safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy);</span>

          <span class="s1">{</span>
            <span class="s3">if </span><span class="s1">((flags &amp; Insertion) !== NoFlags$1) {</span>
              <span class="s1">setIsRunningInsertionEffect(</span><span class="s3">false</span><span class="s1">);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">effect = effect.next;</span>
    <span class="s1">} </span><span class="s3">while </span><span class="s1">(effect !== firstEffect);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">commitHookEffectListMount(flags, finishedWork) {</span>
  <span class="s3">var </span><span class="s1">updateQueue = finishedWork.updateQueue;</span>
  <span class="s3">var </span><span class="s1">lastEffect = updateQueue !== </span><span class="s3">null </span><span class="s1">? updateQueue.lastEffect : </span><span class="s3">null</span><span class="s1">;</span>

  <span class="s3">if </span><span class="s1">(lastEffect !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">firstEffect = lastEffect.next;</span>
    <span class="s3">var </span><span class="s1">effect = firstEffect;</span>

    <span class="s3">do </span><span class="s1">{</span>
      <span class="s3">if </span><span class="s1">((effect.tag &amp; flags) === flags) {</span>
        <span class="s3">var </span><span class="s1">create = effect.create;</span>

        <span class="s1">{</span>
          <span class="s3">if </span><span class="s1">((flags &amp; Insertion) !== NoFlags$1) {</span>
            <span class="s1">setIsRunningInsertionEffect(</span><span class="s3">true</span><span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s1">effect.destroy = create();</span>

        <span class="s1">{</span>
          <span class="s3">if </span><span class="s1">((flags &amp; Insertion) !== NoFlags$1) {</span>
            <span class="s1">setIsRunningInsertionEffect(</span><span class="s3">false</span><span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s1">{</span>
          <span class="s3">var </span><span class="s1">destroy = effect.destroy;</span>

          <span class="s3">if </span><span class="s1">(destroy !== undefined &amp;&amp; </span><span class="s3">typeof </span><span class="s1">destroy !== </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
            <span class="s3">var </span><span class="s1">hookName = </span><span class="s3">void </span><span class="s4">0</span><span class="s1">;</span>

            <span class="s3">if </span><span class="s1">((effect.tag &amp; Layout) !== NoFlags) {</span>
              <span class="s1">hookName = </span><span class="s2">&quot;useLayoutEffect&quot;</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">((effect.tag &amp; Insertion) !== NoFlags) {</span>
              <span class="s1">hookName = </span><span class="s2">&quot;useInsertionEffect&quot;</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
              <span class="s1">hookName = </span><span class="s2">&quot;useEffect&quot;</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s3">var </span><span class="s1">addendum = </span><span class="s3">void </span><span class="s4">0</span><span class="s1">;</span>

            <span class="s3">if </span><span class="s1">(destroy === </span><span class="s3">null</span><span class="s1">) {</span>
              <span class="s1">addendum =</span>
                <span class="s2">&quot; You returned null. If your effect does not require clean &quot; </span><span class="s1">+</span>
                <span class="s2">&quot;up, return undefined (or nothing).&quot;</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">destroy.then === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
              <span class="s1">addendum =</span>
                <span class="s2">&quot;</span><span class="s5">\n\n</span><span class="s2">It looks like you wrote &quot; </span><span class="s1">+</span>
                <span class="s1">hookName +</span>
                <span class="s2">&quot;(async () =&gt; ...) or returned a Promise. &quot; </span><span class="s1">+</span>
                <span class="s2">&quot;Instead, write the async function inside your effect &quot; </span><span class="s1">+</span>
                <span class="s2">&quot;and call it immediately:</span><span class="s5">\n\n</span><span class="s2">&quot; </span><span class="s1">+</span>
                <span class="s1">hookName +</span>
                <span class="s2">&quot;(() =&gt; {</span><span class="s5">\n</span><span class="s2">&quot; </span><span class="s1">+</span>
                <span class="s2">&quot;  async function fetchData() {</span><span class="s5">\n</span><span class="s2">&quot; </span><span class="s1">+</span>
                <span class="s2">&quot;    // You can await here</span><span class="s5">\n</span><span class="s2">&quot; </span><span class="s1">+</span>
                <span class="s2">&quot;    const response = await MyAPI.getData(someId);</span><span class="s5">\n</span><span class="s2">&quot; </span><span class="s1">+</span>
                <span class="s2">&quot;    // ...</span><span class="s5">\n</span><span class="s2">&quot; </span><span class="s1">+</span>
                <span class="s2">&quot;  }</span><span class="s5">\n</span><span class="s2">&quot; </span><span class="s1">+</span>
                <span class="s2">&quot;  fetchData();</span><span class="s5">\n</span><span class="s2">&quot; </span><span class="s1">+</span>
                <span class="s2">&quot;}, [someId]); // Or [] if effect doesn't need props or state</span><span class="s5">\n\n</span><span class="s2">&quot; </span><span class="s1">+</span>
                <span class="s2">&quot;Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching&quot;</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
              <span class="s1">addendum = </span><span class="s2">&quot; You returned: &quot; </span><span class="s1">+ destroy;</span>
            <span class="s1">}</span>

            <span class="s1">error(</span>
              <span class="s2">&quot;%s must not return anything besides a function, &quot; </span><span class="s1">+</span>
                <span class="s2">&quot;which is used for clean-up.%s&quot;</span><span class="s1">,</span>
              <span class="s1">hookName,</span>
              <span class="s1">addendum</span>
            <span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">effect = effect.next;</span>
    <span class="s1">} </span><span class="s3">while </span><span class="s1">(effect !== firstEffect);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">commitPassiveEffectDurations(finishedRoot, finishedWork) {</span>
  <span class="s1">{</span>
    <span class="s0">// Only Profilers with work in their subtree will have an Update effect scheduled.</span>
    <span class="s3">if </span><span class="s1">((finishedWork.flags &amp; Update) !== NoFlags) {</span>
      <span class="s3">switch </span><span class="s1">(finishedWork.tag) {</span>
        <span class="s3">case </span><span class="s1">Profiler: {</span>
          <span class="s3">var </span><span class="s1">passiveEffectDuration =</span>
            <span class="s1">finishedWork.stateNode.passiveEffectDuration;</span>
          <span class="s3">var </span><span class="s1">_finishedWork$memoize = finishedWork.memoizedProps,</span>
            <span class="s1">id = _finishedWork$memoize.id,</span>
            <span class="s1">onPostCommit = _finishedWork$memoize.onPostCommit; </span><span class="s0">// This value will still reflect the previous commit phase.</span>
          <span class="s0">// It does not get reset until the start of the next commit phase.</span>

          <span class="s3">var </span><span class="s1">commitTime = getCommitTime();</span>
          <span class="s3">var </span><span class="s1">phase = finishedWork.alternate === </span><span class="s3">null </span><span class="s1">? </span><span class="s2">&quot;mount&quot; </span><span class="s1">: </span><span class="s2">&quot;update&quot;</span><span class="s1">;</span>

          <span class="s1">{</span>
            <span class="s3">if </span><span class="s1">(isCurrentUpdateNested()) {</span>
              <span class="s1">phase = </span><span class="s2">&quot;nested-update&quot;</span><span class="s1">;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">onPostCommit === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
            <span class="s1">onPostCommit(id, phase, passiveEffectDuration, commitTime);</span>
          <span class="s1">} </span><span class="s0">// Bubble times to the next nearest ancestor Profiler.</span>
          <span class="s0">// After we process that Profiler, we'll bubble further up.</span>

          <span class="s3">var </span><span class="s1">parentFiber = finishedWork.</span><span class="s3">return</span><span class="s1">;</span>

          <span class="s1">outer: </span><span class="s3">while </span><span class="s1">(parentFiber !== </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s3">switch </span><span class="s1">(parentFiber.tag) {</span>
              <span class="s3">case </span><span class="s1">HostRoot:</span>
                <span class="s3">var </span><span class="s1">root = parentFiber.stateNode;</span>
                <span class="s1">root.passiveEffectDuration += passiveEffectDuration;</span>
                <span class="s3">break </span><span class="s1">outer;</span>

              <span class="s3">case </span><span class="s1">Profiler:</span>
                <span class="s3">var </span><span class="s1">parentStateNode = parentFiber.stateNode;</span>
                <span class="s1">parentStateNode.passiveEffectDuration += passiveEffectDuration;</span>
                <span class="s3">break </span><span class="s1">outer;</span>
            <span class="s1">}</span>

            <span class="s1">parentFiber = parentFiber.</span><span class="s3">return</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s3">break</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">commitLayoutEffectOnFiber(</span>
  <span class="s1">finishedRoot,</span>
  <span class="s1">current,</span>
  <span class="s1">finishedWork,</span>
  <span class="s1">committedLanes</span>
<span class="s1">) {</span>
  <span class="s3">if </span><span class="s1">((finishedWork.flags &amp; LayoutMask) !== NoFlags) {</span>
    <span class="s3">switch </span><span class="s1">(finishedWork.tag) {</span>
      <span class="s3">case </span><span class="s1">FunctionComponent:</span>
      <span class="s3">case </span><span class="s1">ForwardRef:</span>
      <span class="s3">case </span><span class="s1">SimpleMemoComponent: {</span>
        <span class="s1">{</span>
          <span class="s0">// At this point layout effects have already been destroyed (during mutation phase).</span>
          <span class="s0">// This is done to prevent sibling component effects from interfering with each other,</span>
          <span class="s0">// e.g. a destroy function in one component should never override a ref set</span>
          <span class="s0">// by a create function in another component during the same commit.</span>
          <span class="s3">if </span><span class="s1">(finishedWork.mode &amp; ProfileMode) {</span>
            <span class="s3">try </span><span class="s1">{</span>
              <span class="s1">startLayoutEffectTimer();</span>
              <span class="s1">commitHookEffectListMount(Layout | HasEffect, finishedWork);</span>
            <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
              <span class="s1">recordLayoutEffectDuration(finishedWork);</span>
            <span class="s1">}</span>
          <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">commitHookEffectListMount(Layout | HasEffect, finishedWork);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">ClassComponent: {</span>
        <span class="s3">var </span><span class="s1">instance = finishedWork.stateNode;</span>

        <span class="s3">if </span><span class="s1">(finishedWork.flags &amp; Update) {</span>
          <span class="s1">{</span>
            <span class="s3">if </span><span class="s1">(current === </span><span class="s3">null</span><span class="s1">) {</span>
              <span class="s0">// We could update instance props and state here,</span>
              <span class="s0">// but instead we rely on them being set during last render.</span>
              <span class="s0">// TODO: revisit this when we implement resuming.</span>
              <span class="s1">{</span>
                <span class="s3">if </span><span class="s1">(</span>
                  <span class="s1">finishedWork.type === finishedWork.elementType &amp;&amp;</span>
                  <span class="s1">!didWarnAboutReassigningProps</span>
                <span class="s1">) {</span>
                  <span class="s3">if </span><span class="s1">(instance.props !== finishedWork.memoizedProps) {</span>
                    <span class="s1">error(</span>
                      <span class="s2">&quot;Expected %s props to match memoized props before &quot; </span><span class="s1">+</span>
                        <span class="s2">&quot;componentDidMount. &quot; </span><span class="s1">+</span>
                        <span class="s2">&quot;This might either be because of a bug in React, or because &quot; </span><span class="s1">+</span>
                        <span class="s2">&quot;a component reassigns its own `this.props`. &quot; </span><span class="s1">+</span>
                        <span class="s2">&quot;Please file an issue.&quot;</span><span class="s1">,</span>
                      <span class="s1">getComponentNameFromFiber(finishedWork) || </span><span class="s2">&quot;instance&quot;</span>
                    <span class="s1">);</span>
                  <span class="s1">}</span>

                  <span class="s3">if </span><span class="s1">(instance.state !== finishedWork.memoizedState) {</span>
                    <span class="s1">error(</span>
                      <span class="s2">&quot;Expected %s state to match memoized state before &quot; </span><span class="s1">+</span>
                        <span class="s2">&quot;componentDidMount. &quot; </span><span class="s1">+</span>
                        <span class="s2">&quot;This might either be because of a bug in React, or because &quot; </span><span class="s1">+</span>
                        <span class="s2">&quot;a component reassigns its own `this.state`. &quot; </span><span class="s1">+</span>
                        <span class="s2">&quot;Please file an issue.&quot;</span><span class="s1">,</span>
                      <span class="s1">getComponentNameFromFiber(finishedWork) || </span><span class="s2">&quot;instance&quot;</span>
                    <span class="s1">);</span>
                  <span class="s1">}</span>
                <span class="s1">}</span>
              <span class="s1">}</span>

              <span class="s3">if </span><span class="s1">(finishedWork.mode &amp; ProfileMode) {</span>
                <span class="s3">try </span><span class="s1">{</span>
                  <span class="s1">startLayoutEffectTimer();</span>
                  <span class="s1">instance.componentDidMount();</span>
                <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
                  <span class="s1">recordLayoutEffectDuration(finishedWork);</span>
                <span class="s1">}</span>
              <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s1">instance.componentDidMount();</span>
              <span class="s1">}</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
              <span class="s3">var </span><span class="s1">prevProps =</span>
                <span class="s1">finishedWork.elementType === finishedWork.type</span>
                  <span class="s1">? current.memoizedProps</span>
                  <span class="s1">: resolveDefaultProps(</span>
                      <span class="s1">finishedWork.type,</span>
                      <span class="s1">current.memoizedProps</span>
                    <span class="s1">);</span>
              <span class="s3">var </span><span class="s1">prevState = current.memoizedState; </span><span class="s0">// We could update instance props and state here,</span>
              <span class="s0">// but instead we rely on them being set during last render.</span>
              <span class="s0">// TODO: revisit this when we implement resuming.</span>

              <span class="s1">{</span>
                <span class="s3">if </span><span class="s1">(</span>
                  <span class="s1">finishedWork.type === finishedWork.elementType &amp;&amp;</span>
                  <span class="s1">!didWarnAboutReassigningProps</span>
                <span class="s1">) {</span>
                  <span class="s3">if </span><span class="s1">(instance.props !== finishedWork.memoizedProps) {</span>
                    <span class="s1">error(</span>
                      <span class="s2">&quot;Expected %s props to match memoized props before &quot; </span><span class="s1">+</span>
                        <span class="s2">&quot;componentDidUpdate. &quot; </span><span class="s1">+</span>
                        <span class="s2">&quot;This might either be because of a bug in React, or because &quot; </span><span class="s1">+</span>
                        <span class="s2">&quot;a component reassigns its own `this.props`. &quot; </span><span class="s1">+</span>
                        <span class="s2">&quot;Please file an issue.&quot;</span><span class="s1">,</span>
                      <span class="s1">getComponentNameFromFiber(finishedWork) || </span><span class="s2">&quot;instance&quot;</span>
                    <span class="s1">);</span>
                  <span class="s1">}</span>

                  <span class="s3">if </span><span class="s1">(instance.state !== finishedWork.memoizedState) {</span>
                    <span class="s1">error(</span>
                      <span class="s2">&quot;Expected %s state to match memoized state before &quot; </span><span class="s1">+</span>
                        <span class="s2">&quot;componentDidUpdate. &quot; </span><span class="s1">+</span>
                        <span class="s2">&quot;This might either be because of a bug in React, or because &quot; </span><span class="s1">+</span>
                        <span class="s2">&quot;a component reassigns its own `this.state`. &quot; </span><span class="s1">+</span>
                        <span class="s2">&quot;Please file an issue.&quot;</span><span class="s1">,</span>
                      <span class="s1">getComponentNameFromFiber(finishedWork) || </span><span class="s2">&quot;instance&quot;</span>
                    <span class="s1">);</span>
                  <span class="s1">}</span>
                <span class="s1">}</span>
              <span class="s1">}</span>

              <span class="s3">if </span><span class="s1">(finishedWork.mode &amp; ProfileMode) {</span>
                <span class="s3">try </span><span class="s1">{</span>
                  <span class="s1">startLayoutEffectTimer();</span>
                  <span class="s1">instance.componentDidUpdate(</span>
                    <span class="s1">prevProps,</span>
                    <span class="s1">prevState,</span>
                    <span class="s1">instance.__reactInternalSnapshotBeforeUpdate</span>
                  <span class="s1">);</span>
                <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
                  <span class="s1">recordLayoutEffectDuration(finishedWork);</span>
                <span class="s1">}</span>
              <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s1">instance.componentDidUpdate(</span>
                  <span class="s1">prevProps,</span>
                  <span class="s1">prevState,</span>
                  <span class="s1">instance.__reactInternalSnapshotBeforeUpdate</span>
                <span class="s1">);</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s0">// TODO: I think this is now always non-null by the time it reaches the</span>
        <span class="s0">// commit phase. Consider removing the type check.</span>

        <span class="s3">var </span><span class="s1">updateQueue = finishedWork.updateQueue;</span>

        <span class="s3">if </span><span class="s1">(updateQueue !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">{</span>
            <span class="s3">if </span><span class="s1">(</span>
              <span class="s1">finishedWork.type === finishedWork.elementType &amp;&amp;</span>
              <span class="s1">!didWarnAboutReassigningProps</span>
            <span class="s1">) {</span>
              <span class="s3">if </span><span class="s1">(instance.props !== finishedWork.memoizedProps) {</span>
                <span class="s1">error(</span>
                  <span class="s2">&quot;Expected %s props to match memoized props before &quot; </span><span class="s1">+</span>
                    <span class="s2">&quot;processing the update queue. &quot; </span><span class="s1">+</span>
                    <span class="s2">&quot;This might either be because of a bug in React, or because &quot; </span><span class="s1">+</span>
                    <span class="s2">&quot;a component reassigns its own `this.props`. &quot; </span><span class="s1">+</span>
                    <span class="s2">&quot;Please file an issue.&quot;</span><span class="s1">,</span>
                  <span class="s1">getComponentNameFromFiber(finishedWork) || </span><span class="s2">&quot;instance&quot;</span>
                <span class="s1">);</span>
              <span class="s1">}</span>

              <span class="s3">if </span><span class="s1">(instance.state !== finishedWork.memoizedState) {</span>
                <span class="s1">error(</span>
                  <span class="s2">&quot;Expected %s state to match memoized state before &quot; </span><span class="s1">+</span>
                    <span class="s2">&quot;processing the update queue. &quot; </span><span class="s1">+</span>
                    <span class="s2">&quot;This might either be because of a bug in React, or because &quot; </span><span class="s1">+</span>
                    <span class="s2">&quot;a component reassigns its own `this.state`. &quot; </span><span class="s1">+</span>
                    <span class="s2">&quot;Please file an issue.&quot;</span><span class="s1">,</span>
                  <span class="s1">getComponentNameFromFiber(finishedWork) || </span><span class="s2">&quot;instance&quot;</span>
                <span class="s1">);</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s1">} </span><span class="s0">// We could update instance props and state here,</span>
          <span class="s0">// but instead we rely on them being set during last render.</span>
          <span class="s0">// TODO: revisit this when we implement resuming.</span>

          <span class="s1">commitUpdateQueue(finishedWork, updateQueue, instance);</span>
        <span class="s1">}</span>

        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">HostRoot: {</span>
        <span class="s0">// TODO: I think this is now always non-null by the time it reaches the</span>
        <span class="s0">// commit phase. Consider removing the type check.</span>
        <span class="s3">var </span><span class="s1">_updateQueue = finishedWork.updateQueue;</span>

        <span class="s3">if </span><span class="s1">(_updateQueue !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s3">var </span><span class="s1">_instance = </span><span class="s3">null</span><span class="s1">;</span>

          <span class="s3">if </span><span class="s1">(finishedWork.child !== </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s3">switch </span><span class="s1">(finishedWork.child.tag) {</span>
              <span class="s3">case </span><span class="s1">HostComponent:</span>
                <span class="s1">_instance = getPublicInstance(finishedWork.child.stateNode);</span>
                <span class="s3">break</span><span class="s1">;</span>

              <span class="s3">case </span><span class="s1">ClassComponent:</span>
                <span class="s1">_instance = finishedWork.child.stateNode;</span>
                <span class="s3">break</span><span class="s1">;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s1">commitUpdateQueue(finishedWork, _updateQueue, _instance);</span>
        <span class="s1">}</span>

        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">HostComponent: {</span>
        <span class="s3">var </span><span class="s1">_instance2 = finishedWork.stateNode; </span><span class="s0">// Renderers may schedule work to be done after host components are mounted</span>
        <span class="s0">// (eg DOM renderer may schedule auto-focus for inputs and form controls).</span>
        <span class="s0">// These effects should only be committed when components are first mounted,</span>
        <span class="s0">// aka when there is no current/alternate.</span>

        <span class="s3">if </span><span class="s1">(current === </span><span class="s3">null </span><span class="s1">&amp;&amp; finishedWork.flags &amp; Update) {</span>
          <span class="s3">var </span><span class="s1">type = finishedWork.type;</span>
          <span class="s3">var </span><span class="s1">props = finishedWork.memoizedProps;</span>
          <span class="s1">commitMount();</span>
        <span class="s1">}</span>

        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">HostText: {</span>
        <span class="s0">// We have no life-cycles associated with text.</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">HostPortal: {</span>
        <span class="s0">// We have no life-cycles associated with portals.</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">Profiler: {</span>
        <span class="s1">{</span>
          <span class="s3">var </span><span class="s1">_finishedWork$memoize2 = finishedWork.memoizedProps,</span>
            <span class="s1">onCommit = _finishedWork$memoize2.onCommit,</span>
            <span class="s1">onRender = _finishedWork$memoize2.onRender;</span>
          <span class="s3">var </span><span class="s1">effectDuration = finishedWork.stateNode.effectDuration;</span>
          <span class="s3">var </span><span class="s1">commitTime = getCommitTime();</span>
          <span class="s3">var </span><span class="s1">phase = current === </span><span class="s3">null </span><span class="s1">? </span><span class="s2">&quot;mount&quot; </span><span class="s1">: </span><span class="s2">&quot;update&quot;</span><span class="s1">;</span>

          <span class="s1">{</span>
            <span class="s3">if </span><span class="s1">(isCurrentUpdateNested()) {</span>
              <span class="s1">phase = </span><span class="s2">&quot;nested-update&quot;</span><span class="s1">;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">onRender === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
            <span class="s1">onRender(</span>
              <span class="s1">finishedWork.memoizedProps.id,</span>
              <span class="s1">phase,</span>
              <span class="s1">finishedWork.actualDuration,</span>
              <span class="s1">finishedWork.treeBaseDuration,</span>
              <span class="s1">finishedWork.actualStartTime,</span>
              <span class="s1">commitTime</span>
            <span class="s1">);</span>
          <span class="s1">}</span>

          <span class="s1">{</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">onCommit === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
              <span class="s1">onCommit(</span>
                <span class="s1">finishedWork.memoizedProps.id,</span>
                <span class="s1">phase,</span>
                <span class="s1">effectDuration,</span>
                <span class="s1">commitTime</span>
              <span class="s1">);</span>
            <span class="s1">} </span><span class="s0">// Schedule a passive effect for this Profiler to call onPostCommit hooks.</span>
            <span class="s0">// This effect should be scheduled even if there is no onPostCommit callback for this Profiler,</span>
            <span class="s0">// because the effect is also where times bubble to parent Profilers.</span>

            <span class="s1">enqueuePendingPassiveProfilerEffect(finishedWork); </span><span class="s0">// Propagate layout effect durations to the next nearest Profiler ancestor.</span>
            <span class="s0">// Do not reset these values until the next render so DevTools has a chance to read them first.</span>

            <span class="s3">var </span><span class="s1">parentFiber = finishedWork.</span><span class="s3">return</span><span class="s1">;</span>

            <span class="s1">outer: </span><span class="s3">while </span><span class="s1">(parentFiber !== </span><span class="s3">null</span><span class="s1">) {</span>
              <span class="s3">switch </span><span class="s1">(parentFiber.tag) {</span>
                <span class="s3">case </span><span class="s1">HostRoot:</span>
                  <span class="s3">var </span><span class="s1">root = parentFiber.stateNode;</span>
                  <span class="s1">root.effectDuration += effectDuration;</span>
                  <span class="s3">break </span><span class="s1">outer;</span>

                <span class="s3">case </span><span class="s1">Profiler:</span>
                  <span class="s3">var </span><span class="s1">parentStateNode = parentFiber.stateNode;</span>
                  <span class="s1">parentStateNode.effectDuration += effectDuration;</span>
                  <span class="s3">break </span><span class="s1">outer;</span>
              <span class="s1">}</span>

              <span class="s1">parentFiber = parentFiber.</span><span class="s3">return</span><span class="s1">;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">SuspenseComponent: {</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">SuspenseListComponent:</span>
      <span class="s3">case </span><span class="s1">IncompleteClassComponent:</span>
      <span class="s3">case </span><span class="s1">ScopeComponent:</span>
      <span class="s3">case </span><span class="s1">OffscreenComponent:</span>
      <span class="s3">case </span><span class="s1">LegacyHiddenComponent:</span>
      <span class="s3">case </span><span class="s1">TracingMarkerComponent: {</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">default</span><span class="s1">:</span>
        <span class="s3">throw new </span><span class="s1">Error(</span>
          <span class="s2">&quot;This unit of work tag should not have side-effects. This error is &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;likely caused by a bug in React. Please file an issue.&quot;</span>
        <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">{</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(finishedWork.flags &amp; Ref) {</span>
        <span class="s1">commitAttachRef(finishedWork);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">commitAttachRef(finishedWork) {</span>
  <span class="s3">var </span><span class="s1">ref = finishedWork.ref;</span>

  <span class="s3">if </span><span class="s1">(ref !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">instance = finishedWork.stateNode;</span>
    <span class="s3">var </span><span class="s1">instanceToUse;</span>

    <span class="s3">switch </span><span class="s1">(finishedWork.tag) {</span>
      <span class="s3">case </span><span class="s1">HostComponent:</span>
        <span class="s1">instanceToUse = getPublicInstance(instance);</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">default</span><span class="s1">:</span>
        <span class="s1">instanceToUse = instance;</span>
    <span class="s1">} </span><span class="s0">// Moved outside to ensure DCE works with this flag</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">ref === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">retVal;</span>

      <span class="s3">if </span><span class="s1">(finishedWork.mode &amp; ProfileMode) {</span>
        <span class="s3">try </span><span class="s1">{</span>
          <span class="s1">startLayoutEffectTimer();</span>
          <span class="s1">retVal = ref(instanceToUse);</span>
        <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
          <span class="s1">recordLayoutEffectDuration(finishedWork);</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">retVal = ref(instanceToUse);</span>
      <span class="s1">}</span>

      <span class="s1">{</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">retVal === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
          <span class="s1">error(</span>
            <span class="s2">&quot;Unexpected return value from a callback ref in %s. &quot; </span><span class="s1">+</span>
              <span class="s2">&quot;A callback ref should not return a function.&quot;</span><span class="s1">,</span>
            <span class="s1">getComponentNameFromFiber(finishedWork)</span>
          <span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">{</span>
        <span class="s3">if </span><span class="s1">(!ref.hasOwnProperty(</span><span class="s2">&quot;current&quot;</span><span class="s1">)) {</span>
          <span class="s1">error(</span>
            <span class="s2">&quot;Unexpected ref object provided for %s. &quot; </span><span class="s1">+</span>
              <span class="s2">&quot;Use either a ref-setter function or React.createRef().&quot;</span><span class="s1">,</span>
            <span class="s1">getComponentNameFromFiber(finishedWork)</span>
          <span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">ref.current = instanceToUse;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">detachFiberMutation(fiber) {</span>
  <span class="s0">// Cut off the return pointer to disconnect it from the tree.</span>
  <span class="s0">// This enables us to detect and warn against state updates on an unmounted component.</span>
  <span class="s0">// It also prevents events from bubbling from within disconnected components.</span>
  <span class="s0">//</span>
  <span class="s0">// Ideally, we should also clear the child pointer of the parent alternate to let this</span>
  <span class="s0">// get GC:ed but we don't know which for sure which parent is the current</span>
  <span class="s0">// one so we'll settle for GC:ing the subtree of this child.</span>
  <span class="s0">// This child itself will be GC:ed when the parent updates the next time.</span>
  <span class="s0">//</span>
  <span class="s0">// Note that we can't clear child or sibling pointers yet.</span>
  <span class="s0">// They're needed for passive effects and for findDOMNode.</span>
  <span class="s0">// We defer those fields, and all other cleanup, to the passive phase (see detachFiberAfterEffects).</span>
  <span class="s0">//</span>
  <span class="s0">// Don't reset the alternate yet, either. We need that so we can detach the</span>
  <span class="s0">// alternate's fields in the passive phase. Clearing the return pointer is</span>
  <span class="s0">// sufficient for findDOMNode semantics.</span>
  <span class="s3">var </span><span class="s1">alternate = fiber.alternate;</span>

  <span class="s3">if </span><span class="s1">(alternate !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s1">alternate.</span><span class="s3">return </span><span class="s1">= </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s1">fiber.</span><span class="s3">return </span><span class="s1">= </span><span class="s3">null</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">detachFiberAfterEffects(fiber) {</span>
  <span class="s3">var </span><span class="s1">alternate = fiber.alternate;</span>

  <span class="s3">if </span><span class="s1">(alternate !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s1">fiber.alternate = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">detachFiberAfterEffects(alternate);</span>
  <span class="s1">} </span><span class="s0">// Note: Defensively using negation instead of &lt; in case</span>
  <span class="s0">// `deletedTreeCleanUpLevel` is undefined.</span>

  <span class="s1">{</span>
    <span class="s0">// Clear cyclical Fiber fields. This level alone is designed to roughly</span>
    <span class="s0">// approximate the planned Fiber refactor. In that world, `setState` will be</span>
    <span class="s0">// bound to a special &quot;instance&quot; object instead of a Fiber. The Instance</span>
    <span class="s0">// object will not have any of these fields. It will only be connected to</span>
    <span class="s0">// the fiber tree via a single link at the root. So if this level alone is</span>
    <span class="s0">// sufficient to fix memory issues, that bodes well for our plans.</span>
    <span class="s1">fiber.child = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">fiber.deletions = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">fiber.sibling = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// The `stateNode` is cyclical because on host nodes it points to the host</span>
    <span class="s0">// tree, which has its own pointers to children, parents, and siblings.</span>
    <span class="s0">// The other host nodes also point back to fibers, so we should detach that</span>
    <span class="s0">// one, too.</span>

    <span class="s3">if </span><span class="s1">(fiber.tag === HostComponent) {</span>
      <span class="s3">var </span><span class="s1">hostInstance = fiber.stateNode;</span>
    <span class="s1">}</span>

    <span class="s1">fiber.stateNode = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// I'm intentionally not clearing the `return` field in this level. We</span>
    <span class="s0">// already disconnect the `return` pointer at the root of the deleted</span>
    <span class="s0">// subtree (in `detachFiberMutation`). Besides, `return` by itself is not</span>
    <span class="s0">// cyclical  it's only cyclical when combined with `child`, `sibling`, and</span>
    <span class="s0">// `alternate`. But we'll clear it in the next level anyway, just in case.</span>

    <span class="s1">{</span>
      <span class="s1">fiber._debugOwner = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s0">// Theoretically, nothing in here should be necessary, because we already</span>
      <span class="s0">// disconnected the fiber from the tree. So even if something leaks this</span>
      <span class="s0">// particular fiber, it won't leak anything else</span>
      <span class="s0">//</span>
      <span class="s0">// The purpose of this branch is to be super aggressive so we can measure</span>
      <span class="s0">// if there's any difference in memory impact. If there is, that could</span>
      <span class="s0">// indicate a React leak we don't know about.</span>
      <span class="s1">fiber.</span><span class="s3">return </span><span class="s1">= </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">fiber.dependencies = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">fiber.memoizedProps = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">fiber.memoizedState = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">fiber.pendingProps = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">fiber.stateNode = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// TODO: Move to `commitPassiveUnmountInsideDeletedTreeOnFiber` instead.</span>

      <span class="s1">fiber.updateQueue = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">emptyPortalContainer(current) {</span>
  <span class="s3">var </span><span class="s1">portal = current.stateNode;</span>
  <span class="s3">var </span><span class="s1">containerInfo = portal.containerInfo;</span>
  <span class="s3">var </span><span class="s1">emptyChildSet = createContainerChildSet(containerInfo);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">commitPlacement(finishedWork) {</span>
  <span class="s1">{</span>
    <span class="s3">return</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s0">// Recursively insert all host nodes into the parent.</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">commitDeletionEffects(root, returnFiber, deletedFiber) {</span>
  <span class="s1">{</span>
    <span class="s0">// Detach refs and call componentWillUnmount() on the whole subtree.</span>
    <span class="s1">commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);</span>
  <span class="s1">}</span>

  <span class="s1">detachFiberMutation(deletedFiber);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">recursivelyTraverseDeletionEffects(</span>
  <span class="s1">finishedRoot,</span>
  <span class="s1">nearestMountedAncestor,</span>
  <span class="s1">parent</span>
<span class="s1">) {</span>
  <span class="s0">// TODO: Use a static flag to skip trees that don't have unmount effects</span>
  <span class="s3">var </span><span class="s1">child = parent.child;</span>

  <span class="s3">while </span><span class="s1">(child !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s1">commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, child);</span>
    <span class="s1">child = child.sibling;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">commitDeletionEffectsOnFiber(</span>
  <span class="s1">finishedRoot,</span>
  <span class="s1">nearestMountedAncestor,</span>
  <span class="s1">deletedFiber</span>
<span class="s1">) {</span>
  <span class="s1">onCommitUnmount(deletedFiber); </span><span class="s0">// The cases in this outer switch modify the stack before they traverse</span>
  <span class="s0">// into their subtree. There are simpler cases in the inner switch</span>
  <span class="s0">// that don't modify the stack.</span>

  <span class="s3">switch </span><span class="s1">(deletedFiber.tag) {</span>
    <span class="s3">case </span><span class="s1">HostComponent: {</span>
      <span class="s1">{</span>
        <span class="s1">safelyDetachRef(deletedFiber, nearestMountedAncestor);</span>
      <span class="s1">} </span><span class="s0">// Intentional fallthrough to next branch</span>
    <span class="s1">}</span>
    <span class="s0">// eslint-disable-next-line-no-fallthrough</span>

    <span class="s3">case </span><span class="s1">HostText: {</span>
      <span class="s0">// We only need to remove the nearest host child. Set the host parent</span>
      <span class="s0">// to `null` on the stack to indicate that nested children don't</span>
      <span class="s0">// need to be removed.</span>
      <span class="s1">{</span>
        <span class="s1">recursivelyTraverseDeletionEffects(</span>
          <span class="s1">finishedRoot,</span>
          <span class="s1">nearestMountedAncestor,</span>
          <span class="s1">deletedFiber</span>
        <span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">case </span><span class="s1">DehydratedFragment: {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">case </span><span class="s1">HostPortal: {</span>
      <span class="s1">{</span>
        <span class="s1">emptyPortalContainer(deletedFiber);</span>
        <span class="s1">recursivelyTraverseDeletionEffects(</span>
          <span class="s1">finishedRoot,</span>
          <span class="s1">nearestMountedAncestor,</span>
          <span class="s1">deletedFiber</span>
        <span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">case </span><span class="s1">FunctionComponent:</span>
    <span class="s3">case </span><span class="s1">ForwardRef:</span>
    <span class="s3">case </span><span class="s1">MemoComponent:</span>
    <span class="s3">case </span><span class="s1">SimpleMemoComponent: {</span>
      <span class="s1">{</span>
        <span class="s3">var </span><span class="s1">updateQueue = deletedFiber.updateQueue;</span>

        <span class="s3">if </span><span class="s1">(updateQueue !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s3">var </span><span class="s1">lastEffect = updateQueue.lastEffect;</span>

          <span class="s3">if </span><span class="s1">(lastEffect !== </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s3">var </span><span class="s1">firstEffect = lastEffect.next;</span>
            <span class="s3">var </span><span class="s1">effect = firstEffect;</span>

            <span class="s3">do </span><span class="s1">{</span>
              <span class="s3">var </span><span class="s1">_effect = effect,</span>
                <span class="s1">destroy = _effect.destroy,</span>
                <span class="s1">tag = _effect.tag;</span>

              <span class="s3">if </span><span class="s1">(destroy !== undefined) {</span>
                <span class="s3">if </span><span class="s1">((tag &amp; Insertion) !== NoFlags$1) {</span>
                  <span class="s1">safelyCallDestroy(</span>
                    <span class="s1">deletedFiber,</span>
                    <span class="s1">nearestMountedAncestor,</span>
                    <span class="s1">destroy</span>
                  <span class="s1">);</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">((tag &amp; Layout) !== NoFlags$1) {</span>
                  <span class="s3">if </span><span class="s1">(deletedFiber.mode &amp; ProfileMode) {</span>
                    <span class="s1">startLayoutEffectTimer();</span>
                    <span class="s1">safelyCallDestroy(</span>
                      <span class="s1">deletedFiber,</span>
                      <span class="s1">nearestMountedAncestor,</span>
                      <span class="s1">destroy</span>
                    <span class="s1">);</span>
                    <span class="s1">recordLayoutEffectDuration(deletedFiber);</span>
                  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s1">safelyCallDestroy(</span>
                      <span class="s1">deletedFiber,</span>
                      <span class="s1">nearestMountedAncestor,</span>
                      <span class="s1">destroy</span>
                    <span class="s1">);</span>
                  <span class="s1">}</span>
                <span class="s1">}</span>
              <span class="s1">}</span>

              <span class="s1">effect = effect.next;</span>
            <span class="s1">} </span><span class="s3">while </span><span class="s1">(effect !== firstEffect);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">recursivelyTraverseDeletionEffects(</span>
        <span class="s1">finishedRoot,</span>
        <span class="s1">nearestMountedAncestor,</span>
        <span class="s1">deletedFiber</span>
      <span class="s1">);</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">case </span><span class="s1">ClassComponent: {</span>
      <span class="s1">{</span>
        <span class="s1">safelyDetachRef(deletedFiber, nearestMountedAncestor);</span>
        <span class="s3">var </span><span class="s1">instance = deletedFiber.stateNode;</span>

        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.componentWillUnmount === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
          <span class="s1">safelyCallComponentWillUnmount(</span>
            <span class="s1">deletedFiber,</span>
            <span class="s1">nearestMountedAncestor,</span>
            <span class="s1">instance</span>
          <span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">recursivelyTraverseDeletionEffects(</span>
        <span class="s1">finishedRoot,</span>
        <span class="s1">nearestMountedAncestor,</span>
        <span class="s1">deletedFiber</span>
      <span class="s1">);</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">case </span><span class="s1">ScopeComponent: {</span>
      <span class="s1">recursivelyTraverseDeletionEffects(</span>
        <span class="s1">finishedRoot,</span>
        <span class="s1">nearestMountedAncestor,</span>
        <span class="s1">deletedFiber</span>
      <span class="s1">);</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">case </span><span class="s1">OffscreenComponent: {</span>
      <span class="s1">{</span>
        <span class="s1">recursivelyTraverseDeletionEffects(</span>
          <span class="s1">finishedRoot,</span>
          <span class="s1">nearestMountedAncestor,</span>
          <span class="s1">deletedFiber</span>
        <span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s3">break</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">default</span><span class="s1">: {</span>
      <span class="s1">recursivelyTraverseDeletionEffects(</span>
        <span class="s1">finishedRoot,</span>
        <span class="s1">nearestMountedAncestor,</span>
        <span class="s1">deletedFiber</span>
      <span class="s1">);</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">commitSuspenseCallback(finishedWork) {</span>
  <span class="s0">// TODO: Move this to passive phase</span>
  <span class="s3">var </span><span class="s1">newState = finishedWork.memoizedState;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">attachSuspenseRetryListeners(finishedWork) {</span>
  <span class="s0">// If this boundary just timed out, then it will have a set of wakeables.</span>
  <span class="s0">// For each wakeable, attach a listener so that when it resolves, React</span>
  <span class="s0">// attempts to re-render the boundary in the primary (pre-timeout) state.</span>
  <span class="s3">var </span><span class="s1">wakeables = finishedWork.updateQueue;</span>

  <span class="s3">if </span><span class="s1">(wakeables !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s1">finishedWork.updateQueue = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">retryCache = finishedWork.stateNode;</span>

    <span class="s3">if </span><span class="s1">(retryCache === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">retryCache = finishedWork.stateNode = </span><span class="s3">new </span><span class="s1">PossiblyWeakSet();</span>
    <span class="s1">}</span>

    <span class="s1">wakeables.forEach(</span><span class="s3">function</span><span class="s1">(wakeable) {</span>
      <span class="s0">// Memoize using the boundary fiber to prevent redundant listeners.</span>
      <span class="s3">var </span><span class="s1">retry = resolveRetryWakeable.bind(</span><span class="s3">null</span><span class="s1">, finishedWork, wakeable);</span>

      <span class="s3">if </span><span class="s1">(!retryCache.has(wakeable)) {</span>
        <span class="s1">retryCache.add(wakeable);</span>

        <span class="s1">{</span>
          <span class="s3">if </span><span class="s1">(isDevToolsPresent) {</span>
            <span class="s3">if </span><span class="s1">(inProgressLanes !== </span><span class="s3">null </span><span class="s1">&amp;&amp; inProgressRoot !== </span><span class="s3">null</span><span class="s1">) {</span>
              <span class="s0">// If we have pending work still, associate the original updaters with it.</span>
              <span class="s1">restorePendingUpdaters(inProgressRoot, inProgressLanes);</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
              <span class="s3">throw </span><span class="s1">Error(</span>
                <span class="s2">&quot;Expected finished root and lanes to be set. This is a bug in React.&quot;</span>
              <span class="s1">);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s1">wakeable.then(retry, retry);</span>
      <span class="s1">}</span>
    <span class="s1">});</span>
  <span class="s1">}</span>
<span class="s1">} </span><span class="s0">// This function detects when a Suspense boundary goes from visible to hidden.</span>
<span class="s3">function </span><span class="s1">commitMutationEffects(root, finishedWork, committedLanes) {</span>
  <span class="s1">inProgressLanes = committedLanes;</span>
  <span class="s1">inProgressRoot = root;</span>
  <span class="s1">setCurrentFiber(finishedWork);</span>
  <span class="s1">commitMutationEffectsOnFiber(finishedWork, root);</span>
  <span class="s1">setCurrentFiber(finishedWork);</span>
  <span class="s1">inProgressLanes = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">inProgressRoot = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">recursivelyTraverseMutationEffects(root, parentFiber, lanes) {</span>
  <span class="s0">// Deletions effects can be scheduled on any fiber type. They need to happen</span>
  <span class="s0">// before the children effects hae fired.</span>
  <span class="s3">var </span><span class="s1">deletions = parentFiber.deletions;</span>

  <span class="s3">if </span><span class="s1">(deletions !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; deletions.length; i++) {</span>
      <span class="s3">var </span><span class="s1">childToDelete = deletions[i];</span>

      <span class="s3">try </span><span class="s1">{</span>
        <span class="s1">commitDeletionEffects(root, parentFiber, childToDelete);</span>
      <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
        <span class="s1">captureCommitPhaseError(childToDelete, parentFiber, error);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">prevDebugFiber = getCurrentFiber();</span>

  <span class="s3">if </span><span class="s1">(parentFiber.subtreeFlags &amp; MutationMask) {</span>
    <span class="s3">var </span><span class="s1">child = parentFiber.child;</span>

    <span class="s3">while </span><span class="s1">(child !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">setCurrentFiber(child);</span>
      <span class="s1">commitMutationEffectsOnFiber(child, root);</span>
      <span class="s1">child = child.sibling;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">setCurrentFiber(prevDebugFiber);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">commitMutationEffectsOnFiber(finishedWork, root, lanes) {</span>
  <span class="s3">var </span><span class="s1">current = finishedWork.alternate;</span>
  <span class="s3">var </span><span class="s1">flags = finishedWork.flags; </span><span class="s0">// The effect flag should be checked *after* we refine the type of fiber,</span>
  <span class="s0">// because the fiber tag is more specific. An exception is any flag related</span>
  <span class="s0">// to reconcilation, because those can be set on all fiber types.</span>

  <span class="s3">switch </span><span class="s1">(finishedWork.tag) {</span>
    <span class="s3">case </span><span class="s1">FunctionComponent:</span>
    <span class="s3">case </span><span class="s1">ForwardRef:</span>
    <span class="s3">case </span><span class="s1">MemoComponent:</span>
    <span class="s3">case </span><span class="s1">SimpleMemoComponent: {</span>
      <span class="s1">recursivelyTraverseMutationEffects(root, finishedWork);</span>
      <span class="s1">commitReconciliationEffects(finishedWork);</span>

      <span class="s3">if </span><span class="s1">(flags &amp; Update) {</span>
        <span class="s3">try </span><span class="s1">{</span>
          <span class="s1">commitHookEffectListUnmount(</span>
            <span class="s1">Insertion | HasEffect,</span>
            <span class="s1">finishedWork,</span>
            <span class="s1">finishedWork.</span><span class="s3">return</span>
          <span class="s1">);</span>
          <span class="s1">commitHookEffectListMount(Insertion | HasEffect, finishedWork);</span>
        <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
          <span class="s1">captureCommitPhaseError(finishedWork, finishedWork.</span><span class="s3">return</span><span class="s1">, error);</span>
        <span class="s1">} </span><span class="s0">// Layout effects are destroyed during the mutation phase so that all</span>
        <span class="s0">// destroy functions for all fibers are called before any create functions.</span>
        <span class="s0">// This prevents sibling component effects from interfering with each other,</span>
        <span class="s0">// e.g. a destroy function in one component should never override a ref set</span>
        <span class="s0">// by a create function in another component during the same commit.</span>

        <span class="s3">if </span><span class="s1">(finishedWork.mode &amp; ProfileMode) {</span>
          <span class="s3">try </span><span class="s1">{</span>
            <span class="s1">startLayoutEffectTimer();</span>
            <span class="s1">commitHookEffectListUnmount(</span>
              <span class="s1">Layout | HasEffect,</span>
              <span class="s1">finishedWork,</span>
              <span class="s1">finishedWork.</span><span class="s3">return</span>
            <span class="s1">);</span>
          <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
            <span class="s1">captureCommitPhaseError(finishedWork, finishedWork.</span><span class="s3">return</span><span class="s1">, error);</span>
          <span class="s1">}</span>

          <span class="s1">recordLayoutEffectDuration(finishedWork);</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s3">try </span><span class="s1">{</span>
            <span class="s1">commitHookEffectListUnmount(</span>
              <span class="s1">Layout | HasEffect,</span>
              <span class="s1">finishedWork,</span>
              <span class="s1">finishedWork.</span><span class="s3">return</span>
            <span class="s1">);</span>
          <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
            <span class="s1">captureCommitPhaseError(finishedWork, finishedWork.</span><span class="s3">return</span><span class="s1">, error);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">case </span><span class="s1">ClassComponent: {</span>
      <span class="s1">recursivelyTraverseMutationEffects(root, finishedWork);</span>
      <span class="s1">commitReconciliationEffects(finishedWork);</span>

      <span class="s3">if </span><span class="s1">(flags &amp; Ref) {</span>
        <span class="s3">if </span><span class="s1">(current !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">safelyDetachRef(current, current.</span><span class="s3">return</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">case </span><span class="s1">HostComponent: {</span>
      <span class="s1">recursivelyTraverseMutationEffects(root, finishedWork);</span>
      <span class="s1">commitReconciliationEffects(finishedWork);</span>

      <span class="s3">if </span><span class="s1">(flags &amp; Ref) {</span>
        <span class="s3">if </span><span class="s1">(current !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">safelyDetachRef(current, current.</span><span class="s3">return</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">case </span><span class="s1">HostText: {</span>
      <span class="s1">recursivelyTraverseMutationEffects(root, finishedWork);</span>
      <span class="s1">commitReconciliationEffects(finishedWork);</span>

      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">case </span><span class="s1">HostRoot: {</span>
      <span class="s1">recursivelyTraverseMutationEffects(root, finishedWork);</span>
      <span class="s1">commitReconciliationEffects(finishedWork);</span>

      <span class="s3">if </span><span class="s1">(flags &amp; Update) {</span>
        <span class="s1">{</span>
          <span class="s3">var </span><span class="s1">containerInfo = root.containerInfo;</span>
          <span class="s3">var </span><span class="s1">pendingChildren = root.pendingChildren;</span>

          <span class="s3">try </span><span class="s1">{</span>
            <span class="s1">replaceContainerChildren(containerInfo, pendingChildren);</span>
          <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
            <span class="s1">captureCommitPhaseError(finishedWork, finishedWork.</span><span class="s3">return</span><span class="s1">, error);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">case </span><span class="s1">HostPortal: {</span>
      <span class="s1">recursivelyTraverseMutationEffects(root, finishedWork);</span>
      <span class="s1">commitReconciliationEffects(finishedWork);</span>

      <span class="s3">if </span><span class="s1">(flags &amp; Update) {</span>
        <span class="s1">{</span>
          <span class="s3">var </span><span class="s1">portal = finishedWork.stateNode;</span>
          <span class="s3">var </span><span class="s1">_containerInfo = portal.containerInfo;</span>
          <span class="s3">var </span><span class="s1">_pendingChildren = portal.pendingChildren;</span>

          <span class="s3">try </span><span class="s1">{</span>
            <span class="s1">replaceContainerChildren(_containerInfo, _pendingChildren);</span>
          <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
            <span class="s1">captureCommitPhaseError(finishedWork, finishedWork.</span><span class="s3">return</span><span class="s1">, error);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">case </span><span class="s1">SuspenseComponent: {</span>
      <span class="s1">recursivelyTraverseMutationEffects(root, finishedWork);</span>
      <span class="s1">commitReconciliationEffects(finishedWork);</span>
      <span class="s3">var </span><span class="s1">offscreenFiber = finishedWork.child;</span>

      <span class="s3">if </span><span class="s1">(offscreenFiber.flags &amp; Visibility) {</span>
        <span class="s3">var </span><span class="s1">offscreenInstance = offscreenFiber.stateNode;</span>
        <span class="s3">var </span><span class="s1">newState = offscreenFiber.memoizedState;</span>
        <span class="s3">var </span><span class="s1">isHidden = newState !== </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// Track the current state on the Offscreen instance so we can</span>
        <span class="s0">// read it during an event</span>

        <span class="s1">offscreenInstance.isHidden = isHidden;</span>

        <span class="s3">if </span><span class="s1">(isHidden) {</span>
          <span class="s3">var </span><span class="s1">wasHidden =</span>
            <span class="s1">offscreenFiber.alternate !== </span><span class="s3">null </span><span class="s1">&amp;&amp;</span>
            <span class="s1">offscreenFiber.alternate.memoizedState !== </span><span class="s3">null</span><span class="s1">;</span>

          <span class="s3">if </span><span class="s1">(!wasHidden) {</span>
            <span class="s0">// TODO: Move to passive phase</span>
            <span class="s1">markCommitTimeOfFallback();</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(flags &amp; Update) {</span>
        <span class="s3">try </span><span class="s1">{</span>
          <span class="s1">commitSuspenseCallback(finishedWork);</span>
        <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
          <span class="s1">captureCommitPhaseError(finishedWork, finishedWork.</span><span class="s3">return</span><span class="s1">, error);</span>
        <span class="s1">}</span>

        <span class="s1">attachSuspenseRetryListeners(finishedWork);</span>
      <span class="s1">}</span>

      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">case </span><span class="s1">OffscreenComponent: {</span>
      <span class="s3">var </span><span class="s1">_wasHidden = current !== </span><span class="s3">null </span><span class="s1">&amp;&amp; current.memoizedState !== </span><span class="s3">null</span><span class="s1">;</span>

      <span class="s1">{</span>
        <span class="s1">recursivelyTraverseMutationEffects(root, finishedWork);</span>
      <span class="s1">}</span>

      <span class="s1">commitReconciliationEffects(finishedWork);</span>

      <span class="s3">if </span><span class="s1">(flags &amp; Visibility) {</span>
        <span class="s3">var </span><span class="s1">_offscreenInstance = finishedWork.stateNode;</span>
        <span class="s3">var </span><span class="s1">_newState = finishedWork.memoizedState;</span>

        <span class="s3">var </span><span class="s1">_isHidden = _newState !== </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s0">// read it during an event</span>

        <span class="s1">_offscreenInstance.isHidden = _isHidden;</span>
      <span class="s1">}</span>

      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">case </span><span class="s1">SuspenseListComponent: {</span>
      <span class="s1">recursivelyTraverseMutationEffects(root, finishedWork);</span>
      <span class="s1">commitReconciliationEffects(finishedWork);</span>

      <span class="s3">if </span><span class="s1">(flags &amp; Update) {</span>
        <span class="s1">attachSuspenseRetryListeners(finishedWork);</span>
      <span class="s1">}</span>

      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">case </span><span class="s1">ScopeComponent: {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">default</span><span class="s1">: {</span>
      <span class="s1">recursivelyTraverseMutationEffects(root, finishedWork);</span>
      <span class="s1">commitReconciliationEffects(finishedWork);</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">commitReconciliationEffects(finishedWork) {</span>
  <span class="s0">// Placement effects (insertions, reorders) can be scheduled on any fiber</span>
  <span class="s0">// type. They needs to happen after the children effects have fired, but</span>
  <span class="s0">// before the effects on this fiber have fired.</span>
  <span class="s3">var </span><span class="s1">flags = finishedWork.flags;</span>

  <span class="s3">if </span><span class="s1">(flags &amp; Placement) {</span>
    <span class="s3">try </span><span class="s1">{</span>
      <span class="s1">commitPlacement(finishedWork);</span>
    <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
      <span class="s1">captureCommitPhaseError(finishedWork, finishedWork.</span><span class="s3">return</span><span class="s1">, error);</span>
    <span class="s1">} </span><span class="s0">// Clear the &quot;placement&quot; from effect tag so that we know that this is</span>
    <span class="s0">// inserted, before any life-cycles like componentDidMount gets called.</span>
    <span class="s0">// TODO: findDOMNode doesn't rely on this any more but isMounted does</span>
    <span class="s0">// and isMounted is deprecated anyway so we should be able to kill this.</span>

    <span class="s1">finishedWork.flags &amp;= ~Placement;</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(flags &amp; Hydrating) {</span>
    <span class="s1">finishedWork.flags &amp;= ~Hydrating;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">commitLayoutEffects(finishedWork, root, committedLanes) {</span>
  <span class="s1">inProgressLanes = committedLanes;</span>
  <span class="s1">inProgressRoot = root;</span>
  <span class="s1">nextEffect = finishedWork;</span>
  <span class="s1">commitLayoutEffects_begin(finishedWork, root, committedLanes);</span>
  <span class="s1">inProgressLanes = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">inProgressRoot = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">commitLayoutEffects_begin(subtreeRoot, root, committedLanes) {</span>
  <span class="s0">// Suspense layout effects semantics don't change for legacy roots.</span>
  <span class="s3">var </span><span class="s1">isModernRoot = (subtreeRoot.mode &amp; ConcurrentMode) !== NoMode;</span>

  <span class="s3">while </span><span class="s1">(nextEffect !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">fiber = nextEffect;</span>
    <span class="s3">var </span><span class="s1">firstChild = fiber.child;</span>

    <span class="s3">if </span><span class="s1">((fiber.subtreeFlags &amp; LayoutMask) !== NoFlags &amp;&amp; firstChild !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">firstChild.</span><span class="s3">return </span><span class="s1">= fiber;</span>
      <span class="s1">nextEffect = firstChild;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes) {</span>
  <span class="s3">while </span><span class="s1">(nextEffect !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">fiber = nextEffect;</span>

    <span class="s3">if </span><span class="s1">((fiber.flags &amp; LayoutMask) !== NoFlags) {</span>
      <span class="s3">var </span><span class="s1">current = fiber.alternate;</span>
      <span class="s1">setCurrentFiber(fiber);</span>

      <span class="s3">try </span><span class="s1">{</span>
        <span class="s1">commitLayoutEffectOnFiber(root, current, fiber, committedLanes);</span>
      <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
        <span class="s1">captureCommitPhaseError(fiber, fiber.</span><span class="s3">return</span><span class="s1">, error);</span>
      <span class="s1">}</span>

      <span class="s1">resetCurrentFiber();</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(fiber === subtreeRoot) {</span>
      <span class="s1">nextEffect = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">sibling = fiber.sibling;</span>

    <span class="s3">if </span><span class="s1">(sibling !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">sibling.</span><span class="s3">return </span><span class="s1">= fiber.</span><span class="s3">return</span><span class="s1">;</span>
      <span class="s1">nextEffect = sibling;</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">nextEffect = fiber.</span><span class="s3">return</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">commitPassiveMountEffects(</span>
  <span class="s1">root,</span>
  <span class="s1">finishedWork,</span>
  <span class="s1">committedLanes,</span>
  <span class="s1">committedTransitions</span>
<span class="s1">) {</span>
  <span class="s1">nextEffect = finishedWork;</span>
  <span class="s1">commitPassiveMountEffects_begin(</span>
    <span class="s1">finishedWork,</span>
    <span class="s1">root,</span>
    <span class="s1">committedLanes,</span>
    <span class="s1">committedTransitions</span>
  <span class="s1">);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">commitPassiveMountEffects_begin(</span>
  <span class="s1">subtreeRoot,</span>
  <span class="s1">root,</span>
  <span class="s1">committedLanes,</span>
  <span class="s1">committedTransitions</span>
<span class="s1">) {</span>
  <span class="s3">while </span><span class="s1">(nextEffect !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">fiber = nextEffect;</span>
    <span class="s3">var </span><span class="s1">firstChild = fiber.child;</span>

    <span class="s3">if </span><span class="s1">((fiber.subtreeFlags &amp; PassiveMask) !== NoFlags &amp;&amp; firstChild !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">firstChild.</span><span class="s3">return </span><span class="s1">= fiber;</span>
      <span class="s1">nextEffect = firstChild;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">commitPassiveMountEffects_complete(</span>
        <span class="s1">subtreeRoot,</span>
        <span class="s1">root,</span>
        <span class="s1">committedLanes,</span>
        <span class="s1">committedTransitions</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">commitPassiveMountEffects_complete(</span>
  <span class="s1">subtreeRoot,</span>
  <span class="s1">root,</span>
  <span class="s1">committedLanes,</span>
  <span class="s1">committedTransitions</span>
<span class="s1">) {</span>
  <span class="s3">while </span><span class="s1">(nextEffect !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">fiber = nextEffect;</span>

    <span class="s3">if </span><span class="s1">((fiber.flags &amp; Passive) !== NoFlags) {</span>
      <span class="s1">setCurrentFiber(fiber);</span>

      <span class="s3">try </span><span class="s1">{</span>
        <span class="s1">commitPassiveMountOnFiber(</span>
          <span class="s1">root,</span>
          <span class="s1">fiber,</span>
          <span class="s1">committedLanes,</span>
          <span class="s1">committedTransitions</span>
        <span class="s1">);</span>
      <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
        <span class="s1">captureCommitPhaseError(fiber, fiber.</span><span class="s3">return</span><span class="s1">, error);</span>
      <span class="s1">}</span>

      <span class="s1">resetCurrentFiber();</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(fiber === subtreeRoot) {</span>
      <span class="s1">nextEffect = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">sibling = fiber.sibling;</span>

    <span class="s3">if </span><span class="s1">(sibling !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">sibling.</span><span class="s3">return </span><span class="s1">= fiber.</span><span class="s3">return</span><span class="s1">;</span>
      <span class="s1">nextEffect = sibling;</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">nextEffect = fiber.</span><span class="s3">return</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">commitPassiveMountOnFiber(</span>
  <span class="s1">finishedRoot,</span>
  <span class="s1">finishedWork,</span>
  <span class="s1">committedLanes,</span>
  <span class="s1">committedTransitions</span>
<span class="s1">) {</span>
  <span class="s3">switch </span><span class="s1">(finishedWork.tag) {</span>
    <span class="s3">case </span><span class="s1">FunctionComponent:</span>
    <span class="s3">case </span><span class="s1">ForwardRef:</span>
    <span class="s3">case </span><span class="s1">SimpleMemoComponent: {</span>
      <span class="s3">if </span><span class="s1">(finishedWork.mode &amp; ProfileMode) {</span>
        <span class="s1">startPassiveEffectTimer();</span>

        <span class="s3">try </span><span class="s1">{</span>
          <span class="s1">commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);</span>
        <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
          <span class="s1">recordPassiveEffectDuration(finishedWork);</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);</span>
      <span class="s1">}</span>

      <span class="s3">break</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">commitPassiveUnmountEffects(firstChild) {</span>
  <span class="s1">nextEffect = firstChild;</span>
  <span class="s1">commitPassiveUnmountEffects_begin();</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">commitPassiveUnmountEffects_begin() {</span>
  <span class="s3">while </span><span class="s1">(nextEffect !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">fiber = nextEffect;</span>
    <span class="s3">var </span><span class="s1">child = fiber.child;</span>

    <span class="s3">if </span><span class="s1">((nextEffect.flags &amp; ChildDeletion) !== NoFlags) {</span>
      <span class="s3">var </span><span class="s1">deletions = fiber.deletions;</span>

      <span class="s3">if </span><span class="s1">(deletions !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; deletions.length; i++) {</span>
          <span class="s3">var </span><span class="s1">fiberToDelete = deletions[i];</span>
          <span class="s1">nextEffect = fiberToDelete;</span>
          <span class="s1">commitPassiveUnmountEffectsInsideOfDeletedTree_begin(</span>
            <span class="s1">fiberToDelete,</span>
            <span class="s1">fiber</span>
          <span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s1">{</span>
          <span class="s0">// A fiber was deleted from this parent fiber, but it's still part of</span>
          <span class="s0">// the previous (alternate) parent fiber's list of children. Because</span>
          <span class="s0">// children are a linked list, an earlier sibling that's still alive</span>
          <span class="s0">// will be connected to the deleted fiber via its `alternate`:</span>
          <span class="s0">//</span>
          <span class="s0">//   live fiber</span>
          <span class="s0">//   --alternate--&gt; previous live fiber</span>
          <span class="s0">//   --sibling--&gt; deleted fiber</span>
          <span class="s0">//</span>
          <span class="s0">// We can't disconnect `alternate` on nodes that haven't been deleted</span>
          <span class="s0">// yet, but we can disconnect the `sibling` and `child` pointers.</span>
          <span class="s3">var </span><span class="s1">previousFiber = fiber.alternate;</span>

          <span class="s3">if </span><span class="s1">(previousFiber !== </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s3">var </span><span class="s1">detachedChild = previousFiber.child;</span>

            <span class="s3">if </span><span class="s1">(detachedChild !== </span><span class="s3">null</span><span class="s1">) {</span>
              <span class="s1">previousFiber.child = </span><span class="s3">null</span><span class="s1">;</span>

              <span class="s3">do </span><span class="s1">{</span>
                <span class="s3">var </span><span class="s1">detachedSibling = detachedChild.sibling;</span>
                <span class="s1">detachedChild.sibling = </span><span class="s3">null</span><span class="s1">;</span>
                <span class="s1">detachedChild = detachedSibling;</span>
              <span class="s1">} </span><span class="s3">while </span><span class="s1">(detachedChild !== </span><span class="s3">null</span><span class="s1">);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s1">nextEffect = fiber;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">((fiber.subtreeFlags &amp; PassiveMask) !== NoFlags &amp;&amp; child !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">child.</span><span class="s3">return </span><span class="s1">= fiber;</span>
      <span class="s1">nextEffect = child;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">commitPassiveUnmountEffects_complete();</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">commitPassiveUnmountEffects_complete() {</span>
  <span class="s3">while </span><span class="s1">(nextEffect !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">fiber = nextEffect;</span>

    <span class="s3">if </span><span class="s1">((fiber.flags &amp; Passive) !== NoFlags) {</span>
      <span class="s1">setCurrentFiber(fiber);</span>
      <span class="s1">commitPassiveUnmountOnFiber(fiber);</span>
      <span class="s1">resetCurrentFiber();</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">sibling = fiber.sibling;</span>

    <span class="s3">if </span><span class="s1">(sibling !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">sibling.</span><span class="s3">return </span><span class="s1">= fiber.</span><span class="s3">return</span><span class="s1">;</span>
      <span class="s1">nextEffect = sibling;</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">nextEffect = fiber.</span><span class="s3">return</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">commitPassiveUnmountOnFiber(finishedWork) {</span>
  <span class="s3">switch </span><span class="s1">(finishedWork.tag) {</span>
    <span class="s3">case </span><span class="s1">FunctionComponent:</span>
    <span class="s3">case </span><span class="s1">ForwardRef:</span>
    <span class="s3">case </span><span class="s1">SimpleMemoComponent: {</span>
      <span class="s3">if </span><span class="s1">(finishedWork.mode &amp; ProfileMode) {</span>
        <span class="s1">startPassiveEffectTimer();</span>
        <span class="s1">commitHookEffectListUnmount(</span>
          <span class="s1">Passive$1 | HasEffect,</span>
          <span class="s1">finishedWork,</span>
          <span class="s1">finishedWork.</span><span class="s3">return</span>
        <span class="s1">);</span>
        <span class="s1">recordPassiveEffectDuration(finishedWork);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">commitHookEffectListUnmount(</span>
          <span class="s1">Passive$1 | HasEffect,</span>
          <span class="s1">finishedWork,</span>
          <span class="s1">finishedWork.</span><span class="s3">return</span>
        <span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s3">break</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">commitPassiveUnmountEffectsInsideOfDeletedTree_begin(</span>
  <span class="s1">deletedSubtreeRoot,</span>
  <span class="s1">nearestMountedAncestor</span>
<span class="s1">) {</span>
  <span class="s3">while </span><span class="s1">(nextEffect !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">fiber = nextEffect; </span><span class="s0">// Deletion effects fire in parent -&gt; child order</span>
    <span class="s0">// TODO: Check if fiber has a PassiveStatic flag</span>

    <span class="s1">setCurrentFiber(fiber);</span>
    <span class="s1">commitPassiveUnmountInsideDeletedTreeOnFiber(fiber, nearestMountedAncestor);</span>
    <span class="s1">resetCurrentFiber();</span>
    <span class="s3">var </span><span class="s1">child = fiber.child; </span><span class="s0">// TODO: Only traverse subtree if it has a PassiveStatic flag. (But, if we</span>
    <span class="s0">// do this, still need to handle `deletedTreeCleanUpLevel` correctly.)</span>

    <span class="s3">if </span><span class="s1">(child !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">child.</span><span class="s3">return </span><span class="s1">= fiber;</span>
      <span class="s1">nextEffect = child;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">commitPassiveUnmountEffectsInsideOfDeletedTree_complete(</span>
        <span class="s1">deletedSubtreeRoot</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">commitPassiveUnmountEffectsInsideOfDeletedTree_complete(</span>
  <span class="s1">deletedSubtreeRoot</span>
<span class="s1">) {</span>
  <span class="s3">while </span><span class="s1">(nextEffect !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">fiber = nextEffect;</span>
    <span class="s3">var </span><span class="s1">sibling = fiber.sibling;</span>
    <span class="s3">var </span><span class="s1">returnFiber = fiber.</span><span class="s3">return</span><span class="s1">;</span>

    <span class="s1">{</span>
      <span class="s0">// Recursively traverse the entire deleted tree and clean up fiber fields.</span>
      <span class="s0">// This is more aggressive than ideal, and the long term goal is to only</span>
      <span class="s0">// have to detach the deleted tree at the root.</span>
      <span class="s1">detachFiberAfterEffects(fiber);</span>

      <span class="s3">if </span><span class="s1">(fiber === deletedSubtreeRoot) {</span>
        <span class="s1">nextEffect = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(sibling !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">sibling.</span><span class="s3">return </span><span class="s1">= returnFiber;</span>
      <span class="s1">nextEffect = sibling;</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">nextEffect = returnFiber;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">commitPassiveUnmountInsideDeletedTreeOnFiber(</span>
  <span class="s1">current,</span>
  <span class="s1">nearestMountedAncestor</span>
<span class="s1">) {</span>
  <span class="s3">switch </span><span class="s1">(current.tag) {</span>
    <span class="s3">case </span><span class="s1">FunctionComponent:</span>
    <span class="s3">case </span><span class="s1">ForwardRef:</span>
    <span class="s3">case </span><span class="s1">SimpleMemoComponent: {</span>
      <span class="s3">if </span><span class="s1">(current.mode &amp; ProfileMode) {</span>
        <span class="s1">startPassiveEffectTimer();</span>
        <span class="s1">commitHookEffectListUnmount(Passive$1, current, nearestMountedAncestor);</span>
        <span class="s1">recordPassiveEffectDuration(current);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">commitHookEffectListUnmount(Passive$1, current, nearestMountedAncestor);</span>
      <span class="s1">}</span>

      <span class="s3">break</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">} </span><span class="s0">// TODO: Reuse reappearLayoutEffects traversal here?</span>

<span class="s3">var </span><span class="s1">COMPONENT_TYPE = </span><span class="s4">0</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">HAS_PSEUDO_CLASS_TYPE = </span><span class="s4">1</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">ROLE_TYPE = </span><span class="s4">2</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">TEST_NAME_TYPE = </span><span class="s4">3</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">TEXT_TYPE = </span><span class="s4">4</span><span class="s1">;</span>

<span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">Symbol === </span><span class="s2">&quot;function&quot; </span><span class="s1">&amp;&amp; Symbol.</span><span class="s3">for</span><span class="s1">) {</span>
  <span class="s3">var </span><span class="s1">symbolFor = Symbol.</span><span class="s3">for</span><span class="s1">;</span>
  <span class="s1">COMPONENT_TYPE = symbolFor(</span><span class="s2">&quot;selector.component&quot;</span><span class="s1">);</span>
  <span class="s1">HAS_PSEUDO_CLASS_TYPE = symbolFor(</span><span class="s2">&quot;selector.has_pseudo_class&quot;</span><span class="s1">);</span>
  <span class="s1">ROLE_TYPE = symbolFor(</span><span class="s2">&quot;selector.role&quot;</span><span class="s1">);</span>
  <span class="s1">TEST_NAME_TYPE = symbolFor(</span><span class="s2">&quot;selector.test_id&quot;</span><span class="s1">);</span>
  <span class="s1">TEXT_TYPE = symbolFor(</span><span class="s2">&quot;selector.text&quot;</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">ReactCurrentActQueue = ReactSharedInternals.ReactCurrentActQueue;</span>
<span class="s3">function </span><span class="s1">isLegacyActEnvironment(fiber) {</span>
  <span class="s1">{</span>
    <span class="s0">// Legacy mode. We preserve the behavior of React 17's act. It assumes an</span>
    <span class="s0">// act environment whenever `jest` is defined, but you can still turn off</span>
    <span class="s0">// spurious warnings by setting IS_REACT_ACT_ENVIRONMENT explicitly</span>
    <span class="s0">// to false.</span>
    <span class="s3">var </span><span class="s1">isReactActEnvironmentGlobal = </span><span class="s0">// $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global</span>
      <span class="s3">typeof </span><span class="s1">IS_REACT_ACT_ENVIRONMENT !== </span><span class="s2">&quot;undefined&quot;</span>
        <span class="s1">? IS_REACT_ACT_ENVIRONMENT</span>
        <span class="s1">: undefined; </span><span class="s0">// $FlowExpectedError - Flow doesn't know about jest</span>
    <span class="s3">return </span><span class="s1">warnsIfNotActing;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">isConcurrentActEnvironment() {</span>
  <span class="s1">{</span>
    <span class="s3">var </span><span class="s1">isReactActEnvironmentGlobal = </span><span class="s0">// $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global</span>
      <span class="s3">typeof </span><span class="s1">IS_REACT_ACT_ENVIRONMENT !== </span><span class="s2">&quot;undefined&quot;</span>
        <span class="s1">? IS_REACT_ACT_ENVIRONMENT</span>
        <span class="s1">: undefined;</span>

    <span class="s3">if </span><span class="s1">(!isReactActEnvironmentGlobal &amp;&amp; ReactCurrentActQueue.current !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// TODO: Include link to relevant documentation page.</span>
      <span class="s1">error(</span>
        <span class="s2">&quot;The current testing environment is not configured to support &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;act(...)&quot;</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">isReactActEnvironmentGlobal;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">ceil = Math.ceil;</span>
<span class="s3">var </span><span class="s1">ReactCurrentDispatcher$2 = ReactSharedInternals.ReactCurrentDispatcher,</span>
  <span class="s1">ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner,</span>
  <span class="s1">ReactCurrentBatchConfig$2 = ReactSharedInternals.ReactCurrentBatchConfig,</span>
  <span class="s1">ReactCurrentActQueue$1 = ReactSharedInternals.ReactCurrentActQueue;</span>
<span class="s3">var </span><span class="s1">NoContext =</span>
  <span class="s0">/*             */</span>
  <span class="s4">0</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">BatchedContext =</span>
  <span class="s0">/*               */</span>
  <span class="s4">1</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">RenderContext =</span>
  <span class="s0">/*                */</span>
  <span class="s4">2</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">CommitContext =</span>
  <span class="s0">/*                */</span>
  <span class="s4">4</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">RootInProgress = </span><span class="s4">0</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">RootFatalErrored = </span><span class="s4">1</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">RootErrored = </span><span class="s4">2</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">RootSuspended = </span><span class="s4">3</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">RootSuspendedWithDelay = </span><span class="s4">4</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">RootCompleted = </span><span class="s4">5</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">RootDidNotComplete = </span><span class="s4">6</span><span class="s1">; </span><span class="s0">// Describes where we are in the React execution stack</span>

<span class="s3">var </span><span class="s1">executionContext = NoContext; </span><span class="s0">// The root we're working on</span>

<span class="s3">var </span><span class="s1">workInProgressRoot = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// The fiber we're working on</span>

<span class="s3">var </span><span class="s1">workInProgress = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// The lanes we're rendering</span>

<span class="s3">var </span><span class="s1">workInProgressRootRenderLanes = NoLanes; </span><span class="s0">// Stack that allows components to change the render lanes for its subtree</span>
<span class="s0">// This is a superset of the lanes we started working on at the root. The only</span>
<span class="s0">// case where it's different from `workInProgressRootRenderLanes` is when we</span>
<span class="s0">// enter a subtree that is hidden and needs to be unhidden: Suspense and</span>
<span class="s0">// Offscreen component.</span>
<span class="s0">//</span>
<span class="s0">// Most things in the work loop should deal with workInProgressRootRenderLanes.</span>
<span class="s0">// Most things in begin/complete phases should deal with subtreeRenderLanes.</span>

<span class="s3">var </span><span class="s1">subtreeRenderLanes = NoLanes;</span>
<span class="s3">var </span><span class="s1">subtreeRenderLanesCursor = createCursor(NoLanes); </span><span class="s0">// Whether to root completed, errored, suspended, etc.</span>

<span class="s3">var </span><span class="s1">workInProgressRootExitStatus = RootInProgress; </span><span class="s0">// A fatal error, if one is thrown</span>

<span class="s3">var </span><span class="s1">workInProgressRootFatalError = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// &quot;Included&quot; lanes refer to lanes that were worked on during this render. It's</span>
<span class="s0">// slightly different than `renderLanes` because `renderLanes` can change as you</span>
<span class="s0">// enter and exit an Offscreen tree. This value is the combination of all render</span>
<span class="s0">// lanes for the entire render phase.</span>

<span class="s3">var </span><span class="s1">workInProgressRootIncludedLanes = NoLanes; </span><span class="s0">// The work left over by components that were visited during this render. Only</span>
<span class="s0">// includes unprocessed updates, not work in bailed out children.</span>

<span class="s3">var </span><span class="s1">workInProgressRootSkippedLanes = NoLanes; </span><span class="s0">// Lanes that were updated (in an interleaved event) during this render.</span>

<span class="s3">var </span><span class="s1">workInProgressRootInterleavedUpdatedLanes = NoLanes; </span><span class="s0">// Lanes that were updated during the render phase (*not* an interleaved event).</span>

<span class="s3">var </span><span class="s1">workInProgressRootPingedLanes = NoLanes; </span><span class="s0">// Errors that are thrown during the render phase.</span>

<span class="s3">var </span><span class="s1">workInProgressRootConcurrentErrors = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// These are errors that we recovered from without surfacing them to the UI.</span>
<span class="s0">// We will log them once the tree commits.</span>

<span class="s3">var </span><span class="s1">workInProgressRootRecoverableErrors = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// The most recent time we committed a fallback. This lets us ensure a train</span>
<span class="s0">// model where we don't commit new loading states in too quick succession.</span>

<span class="s3">var </span><span class="s1">globalMostRecentFallbackTime = </span><span class="s4">0</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">FALLBACK_THROTTLE_MS = </span><span class="s4">500</span><span class="s1">; </span><span class="s0">// The absolute time for when we should start giving up on rendering</span>
<span class="s0">// more and prefer CPU suspense heuristics instead.</span>

<span class="s3">var </span><span class="s1">workInProgressRootRenderTargetTime = Infinity; </span><span class="s0">// How long a render is supposed to take before we start following CPU</span>
<span class="s0">// suspense heuristics and opt out of rendering more content.</span>

<span class="s3">var </span><span class="s1">RENDER_TIMEOUT_MS = </span><span class="s4">500</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">workInProgressTransitions = </span><span class="s3">null</span><span class="s1">;</span>

<span class="s3">function </span><span class="s1">resetRenderTimer() {</span>
  <span class="s1">workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">getRenderTargetTime() {</span>
  <span class="s3">return </span><span class="s1">workInProgressRootRenderTargetTime;</span>
<span class="s1">}</span>
<span class="s3">var </span><span class="s1">hasUncaughtError = </span><span class="s3">false</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">firstUncaughtError = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">legacyErrorBoundariesThatAlreadyFailed = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// Only used when enableProfilerNestedUpdateScheduledHook is true;</span>
<span class="s3">var </span><span class="s1">rootDoesHavePassiveEffects = </span><span class="s3">false</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">rootWithPendingPassiveEffects = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">pendingPassiveEffectsLanes = NoLanes;</span>
<span class="s3">var </span><span class="s1">pendingPassiveProfilerEffects = [];</span>
<span class="s3">var </span><span class="s1">pendingPassiveTransitions = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// Use these to prevent an infinite loop of nested updates</span>

<span class="s3">var </span><span class="s1">NESTED_UPDATE_LIMIT = </span><span class="s4">50</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">nestedUpdateCount = </span><span class="s4">0</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">rootWithNestedUpdates = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">isFlushingPassiveEffects = </span><span class="s3">false</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">didScheduleUpdateDuringPassiveEffects = </span><span class="s3">false</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">NESTED_PASSIVE_UPDATE_LIMIT = </span><span class="s4">50</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">nestedPassiveUpdateCount = </span><span class="s4">0</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">rootWithPassiveNestedUpdates = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// If two updates are scheduled within the same event, we should treat their</span>
<span class="s0">// event times as simultaneous, even if the actual clock time has advanced</span>
<span class="s0">// between the first and second call.</span>

<span class="s3">var </span><span class="s1">currentEventTime = NoTimestamp;</span>
<span class="s3">var </span><span class="s1">currentEventTransitionLane = NoLanes;</span>
<span class="s3">var </span><span class="s1">isRunningInsertionEffect = </span><span class="s3">false</span><span class="s1">;</span>
<span class="s3">function </span><span class="s1">getWorkInProgressRoot() {</span>
  <span class="s3">return </span><span class="s1">workInProgressRoot;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">requestEventTime() {</span>
  <span class="s3">if </span><span class="s1">((executionContext &amp; (RenderContext | CommitContext)) !== NoContext) {</span>
    <span class="s0">// We're inside React, so it's fine to read the actual time.</span>
    <span class="s3">return </span><span class="s1">now();</span>
  <span class="s1">} </span><span class="s0">// We're not inside React, so we may be in the middle of a browser event.</span>

  <span class="s3">if </span><span class="s1">(currentEventTime !== NoTimestamp) {</span>
    <span class="s0">// Use the same start time for all updates until we enter React again.</span>
    <span class="s3">return </span><span class="s1">currentEventTime;</span>
  <span class="s1">} </span><span class="s0">// This is the first update since React yielded. Compute a new start time.</span>

  <span class="s1">currentEventTime = now();</span>
  <span class="s3">return </span><span class="s1">currentEventTime;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">requestUpdateLane(fiber) {</span>
  <span class="s0">// Special cases</span>
  <span class="s3">var </span><span class="s1">mode = fiber.mode;</span>

  <span class="s3">if </span><span class="s1">((mode &amp; ConcurrentMode) === NoMode) {</span>
    <span class="s3">return </span><span class="s1">SyncLane;</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span>
    <span class="s1">(executionContext &amp; RenderContext) !== NoContext &amp;&amp;</span>
    <span class="s1">workInProgressRootRenderLanes !== NoLanes</span>
  <span class="s1">) {</span>
    <span class="s0">// This is a render phase update. These are not officially supported. The</span>
    <span class="s0">// old behavior is to give this the same &quot;thread&quot; (lanes) as</span>
    <span class="s0">// whatever is currently rendering. So if you call `setState` on a component</span>
    <span class="s0">// that happens later in the same render, it will flush. Ideally, we want to</span>
    <span class="s0">// remove the special case and treat them as if they came from an</span>
    <span class="s0">// interleaved event. Regardless, this pattern is not officially supported.</span>
    <span class="s0">// This behavior is only a fallback. The flag only exists until we can roll</span>
    <span class="s0">// out the setState warning, since existing code might accidentally rely on</span>
    <span class="s0">// the current behavior.</span>
    <span class="s3">return </span><span class="s1">pickArbitraryLane(workInProgressRootRenderLanes);</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">isTransition = requestCurrentTransition() !== NoTransition;</span>

  <span class="s3">if </span><span class="s1">(isTransition) {</span>
    <span class="s3">if </span><span class="s1">(ReactCurrentBatchConfig$2.transition !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">transition = ReactCurrentBatchConfig$2.transition;</span>

      <span class="s3">if </span><span class="s1">(!transition._updatedFibers) {</span>
        <span class="s1">transition._updatedFibers = </span><span class="s3">new </span><span class="s1">Set();</span>
      <span class="s1">}</span>

      <span class="s1">transition._updatedFibers.add(fiber);</span>
    <span class="s1">} </span><span class="s0">// The algorithm for assigning an update to a lane should be stable for all</span>
    <span class="s0">// updates at the same priority within the same event. To do this, the</span>
    <span class="s0">// inputs to the algorithm must be the same.</span>
    <span class="s0">//</span>
    <span class="s0">// The trick we use is to cache the first of each of these inputs within an</span>
    <span class="s0">// event. Then reset the cached values once we can be sure the event is</span>
    <span class="s0">// over. Our heuristic for that is whenever we enter a concurrent work loop.</span>

    <span class="s3">if </span><span class="s1">(currentEventTransitionLane === NoLane) {</span>
      <span class="s0">// All transitions within the same event are assigned the same lane.</span>
      <span class="s1">currentEventTransitionLane = claimNextTransitionLane();</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">currentEventTransitionLane;</span>
  <span class="s1">} </span><span class="s0">// Updates originating inside certain React methods, like flushSync, have</span>
  <span class="s0">// their priority set by tracking it with a context variable.</span>
  <span class="s0">//</span>
  <span class="s0">// The opaque type returned by the host config is internally a lane, so we can</span>
  <span class="s0">// use that directly.</span>
  <span class="s0">// TODO: Move this type conversion to the event priority module.</span>

  <span class="s3">var </span><span class="s1">updateLane = getCurrentUpdatePriority();</span>

  <span class="s3">if </span><span class="s1">(updateLane !== NoLane) {</span>
    <span class="s3">return </span><span class="s1">updateLane;</span>
  <span class="s1">} </span><span class="s0">// This update originated outside React. Ask the host environment for an</span>
  <span class="s0">// appropriate priority, based on the type of event.</span>
  <span class="s0">//</span>
  <span class="s0">// The opaque type returned by the host config is internally a lane, so we can</span>
  <span class="s0">// use that directly.</span>
  <span class="s0">// TODO: Move this type conversion to the event priority module.</span>

  <span class="s3">var </span><span class="s1">eventLane = getCurrentEventPriority();</span>
  <span class="s3">return </span><span class="s1">eventLane;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">requestRetryLane(fiber) {</span>
  <span class="s0">// This is a fork of `requestUpdateLane` designed specifically for Suspense</span>
  <span class="s0">// &quot;retries&quot;  a special update that attempts to flip a Suspense boundary</span>
  <span class="s0">// from its placeholder state to its primary/resolved state.</span>
  <span class="s0">// Special cases</span>
  <span class="s3">var </span><span class="s1">mode = fiber.mode;</span>

  <span class="s3">if </span><span class="s1">((mode &amp; ConcurrentMode) === NoMode) {</span>
    <span class="s3">return </span><span class="s1">SyncLane;</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">claimNextRetryLane();</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">scheduleUpdateOnFiber(root, fiber, lane, eventTime) {</span>
  <span class="s1">checkForNestedUpdates();</span>

  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(isRunningInsertionEffect) {</span>
      <span class="s1">error(</span><span class="s2">&quot;useInsertionEffect must not schedule updates.&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(isFlushingPassiveEffects) {</span>
      <span class="s1">didScheduleUpdateDuringPassiveEffects = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s0">// Mark that the root has a pending update.</span>

  <span class="s1">markRootUpdated(root, lane, eventTime);</span>

  <span class="s3">if </span><span class="s1">(</span>
    <span class="s1">(executionContext &amp; RenderContext) !== NoLanes &amp;&amp;</span>
    <span class="s1">root === workInProgressRoot</span>
  <span class="s1">) {</span>
    <span class="s0">// This update was dispatched during the render phase. This is a mistake</span>
    <span class="s0">// if the update originates from user space (with the exception of local</span>
    <span class="s0">// hook updates, which are handled differently and don't reach this</span>
    <span class="s0">// function), but there are some internal React features that use this as</span>
    <span class="s0">// an implementation detail, like selective hydration.</span>
    <span class="s1">warnAboutRenderPhaseUpdatesInDEV(fiber); </span><span class="s0">// Track lanes that were updated during the render phase</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s0">// This is a normal update, scheduled from outside the render phase. For</span>
    <span class="s0">// example, during an input event.</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(isDevToolsPresent) {</span>
        <span class="s1">addFiberToLanesMap(root, fiber, lane);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">warnIfUpdatesNotWrappedWithActDEV(fiber);</span>

    <span class="s3">if </span><span class="s1">(root === workInProgressRoot) {</span>
      <span class="s0">// Received an update to a tree that's in the middle of rendering. Mark</span>
      <span class="s0">// that there was an interleaved update work on this root. Unless the</span>
      <span class="s0">// `deferRenderPhaseUpdateToNextBatch` flag is off and this is a render</span>
      <span class="s0">// phase update. In that case, we don't treat render phase updates as if</span>
      <span class="s0">// they were interleaved, for backwards compat reasons.</span>
      <span class="s3">if </span><span class="s1">((executionContext &amp; RenderContext) === NoContext) {</span>
        <span class="s1">workInProgressRootInterleavedUpdatedLanes = mergeLanes(</span>
          <span class="s1">workInProgressRootInterleavedUpdatedLanes,</span>
          <span class="s1">lane</span>
        <span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(workInProgressRootExitStatus === RootSuspendedWithDelay) {</span>
        <span class="s0">// The root already suspended with a delay, which means this render</span>
        <span class="s0">// definitely won't finish. Since we have a new update, let's mark it as</span>
        <span class="s0">// suspended now, right before marking the incoming update. This has the</span>
        <span class="s0">// effect of interrupting the current render and switching to the update.</span>
        <span class="s0">// TODO: Make sure this doesn't override pings that happen while we've</span>
        <span class="s0">// already started rendering.</span>
        <span class="s1">markRootSuspended$1(root, workInProgressRootRenderLanes);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">ensureRootIsScheduled(root, eventTime);</span>

    <span class="s3">if </span><span class="s1">(</span>
      <span class="s1">lane === SyncLane &amp;&amp;</span>
      <span class="s1">executionContext === NoContext &amp;&amp;</span>
      <span class="s1">(fiber.mode &amp; ConcurrentMode) === NoMode &amp;&amp; </span><span class="s0">// Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.</span>
      <span class="s1">!ReactCurrentActQueue$1.isBatchingLegacy</span>
    <span class="s1">) {</span>
      <span class="s0">// Flush the synchronous work now, unless we're already working or inside</span>
      <span class="s0">// a batch. This is intentionally inside scheduleUpdateOnFiber instead of</span>
      <span class="s0">// scheduleCallbackForFiber to preserve the ability to schedule a callback</span>
      <span class="s0">// without immediately flushing it. We only do this for user-initiated</span>
      <span class="s0">// updates, to preserve historical behavior of legacy mode.</span>
      <span class="s1">resetRenderTimer();</span>
      <span class="s1">flushSyncCallbacksOnlyInLegacyMode();</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">isUnsafeClassRenderPhaseUpdate(fiber) {</span>
  <span class="s0">// Check if this is a render phase update. Only called by class components,</span>
  <span class="s0">// which special (deprecated) behavior for UNSAFE_componentWillReceive props.</span>
  <span class="s3">return </span><span class="s1">(</span>
    <span class="s0">// TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We</span>
    <span class="s0">// decided not to enable it.</span>
    <span class="s1">(executionContext &amp; RenderContext) !== NoContext</span>
  <span class="s1">);</span>
<span class="s1">} </span><span class="s0">// Use this function to schedule a task for a root. There's only one task per</span>
<span class="s0">// root; if a task was already scheduled, we'll check to make sure the priority</span>
<span class="s0">// of the existing task is the same as the priority of the next level that the</span>
<span class="s0">// root has work on. This function is called on every update, and right before</span>
<span class="s0">// exiting a task.</span>

<span class="s3">function </span><span class="s1">ensureRootIsScheduled(root, currentTime) {</span>
  <span class="s3">var </span><span class="s1">existingCallbackNode = root.callbackNode; </span><span class="s0">// Check if any lanes are being starved by other work. If so, mark them as</span>
  <span class="s0">// expired so we know to work on those next.</span>

  <span class="s1">markStarvedLanesAsExpired(root, currentTime); </span><span class="s0">// Determine the next lanes to work on, and their priority.</span>

  <span class="s3">var </span><span class="s1">nextLanes = getNextLanes(</span>
    <span class="s1">root,</span>
    <span class="s1">root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes</span>
  <span class="s1">);</span>

  <span class="s3">if </span><span class="s1">(nextLanes === NoLanes) {</span>
    <span class="s0">// Special case: There's nothing to work on.</span>
    <span class="s3">if </span><span class="s1">(existingCallbackNode !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">cancelCallback$1(existingCallbackNode);</span>
    <span class="s1">}</span>

    <span class="s1">root.callbackNode = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">root.callbackPriority = NoLane;</span>
    <span class="s3">return</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s0">// We use the highest priority lane to represent the priority of the callback.</span>

  <span class="s3">var </span><span class="s1">newCallbackPriority = getHighestPriorityLane(nextLanes); </span><span class="s0">// Check if there's an existing task. We may be able to reuse it.</span>

  <span class="s3">var </span><span class="s1">existingCallbackPriority = root.callbackPriority;</span>

  <span class="s3">if </span><span class="s1">(</span>
    <span class="s1">existingCallbackPriority === newCallbackPriority &amp;&amp; </span><span class="s0">// Special case related to `act`. If the currently scheduled task is a</span>
    <span class="s0">// Scheduler task, rather than an `act` task, cancel it and re-scheduled</span>
    <span class="s0">// on the `act` queue.</span>
    <span class="s1">!(</span>
      <span class="s1">ReactCurrentActQueue$1.current !== </span><span class="s3">null </span><span class="s1">&amp;&amp;</span>
      <span class="s1">existingCallbackNode !== fakeActCallbackNode</span>
    <span class="s1">)</span>
  <span class="s1">) {</span>
    <span class="s1">{</span>
      <span class="s0">// If we're going to re-use an existing task, it needs to exist.</span>
      <span class="s0">// Assume that discrete update microtasks are non-cancellable and null.</span>
      <span class="s0">// TODO: Temporary until we confirm this warning is not fired.</span>
      <span class="s3">if </span><span class="s1">(</span>
        <span class="s1">existingCallbackNode == </span><span class="s3">null </span><span class="s1">&amp;&amp;</span>
        <span class="s1">existingCallbackPriority !== SyncLane</span>
      <span class="s1">) {</span>
        <span class="s1">error(</span>
          <span class="s2">&quot;Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.&quot;</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// The priority hasn't changed. We can reuse the existing task. Exit.</span>

    <span class="s3">return</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(existingCallbackNode != </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s0">// Cancel the existing callback. We'll schedule a new one below.</span>
    <span class="s1">cancelCallback$1(existingCallbackNode);</span>
  <span class="s1">} </span><span class="s0">// Schedule a new callback.</span>

  <span class="s3">var </span><span class="s1">newCallbackNode;</span>

  <span class="s3">if </span><span class="s1">(newCallbackPriority === SyncLane) {</span>
    <span class="s0">// Special case: Sync React callbacks are scheduled on a special</span>
    <span class="s0">// internal queue</span>
    <span class="s3">if </span><span class="s1">(root.tag === LegacyRoot) {</span>
      <span class="s3">if </span><span class="s1">(ReactCurrentActQueue$1.isBatchingLegacy !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">ReactCurrentActQueue$1.didScheduleLegacyUpdate = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(</span><span class="s3">null</span><span class="s1">, root));</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">scheduleSyncCallback(performSyncWorkOnRoot.bind(</span><span class="s3">null</span><span class="s1">, root));</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s0">// Flush the queue in an Immediate task.</span>
      <span class="s1">scheduleCallback$1(ImmediatePriority, flushSyncCallbacks);</span>
    <span class="s1">}</span>

    <span class="s1">newCallbackNode = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s3">var </span><span class="s1">schedulerPriorityLevel;</span>

    <span class="s3">switch </span><span class="s1">(lanesToEventPriority(nextLanes)) {</span>
      <span class="s3">case </span><span class="s1">DiscreteEventPriority:</span>
        <span class="s1">schedulerPriorityLevel = ImmediatePriority;</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s1">ContinuousEventPriority:</span>
        <span class="s1">schedulerPriorityLevel = UserBlockingPriority;</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s1">DefaultEventPriority:</span>
        <span class="s1">schedulerPriorityLevel = NormalPriority;</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s1">IdleEventPriority:</span>
        <span class="s1">schedulerPriorityLevel = IdlePriority;</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">default</span><span class="s1">:</span>
        <span class="s1">schedulerPriorityLevel = NormalPriority;</span>
        <span class="s3">break</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">newCallbackNode = scheduleCallback$1(</span>
      <span class="s1">schedulerPriorityLevel,</span>
      <span class="s1">performConcurrentWorkOnRoot.bind(</span><span class="s3">null</span><span class="s1">, root)</span>
    <span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s1">root.callbackPriority = newCallbackPriority;</span>
  <span class="s1">root.callbackNode = newCallbackNode;</span>
<span class="s1">} </span><span class="s0">// This is the entry point for every concurrent task, i.e. anything that</span>
<span class="s0">// goes through Scheduler.</span>

<span class="s3">function </span><span class="s1">performConcurrentWorkOnRoot(root, didTimeout) {</span>
  <span class="s1">{</span>
    <span class="s1">resetNestedUpdateFlag();</span>
  <span class="s1">} </span><span class="s0">// Since we know we're in a React event, we can clear the current</span>
  <span class="s0">// event time. The next update will compute a new event time.</span>

  <span class="s1">currentEventTime = NoTimestamp;</span>
  <span class="s1">currentEventTransitionLane = NoLanes;</span>

  <span class="s3">if </span><span class="s1">((executionContext &amp; (RenderContext | CommitContext)) !== NoContext) {</span>
    <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Should not already be working.&quot;</span><span class="s1">);</span>
  <span class="s1">} </span><span class="s0">// Flush any pending passive effects before deciding which lanes to work on,</span>
  <span class="s0">// in case they schedule additional work.</span>

  <span class="s3">var </span><span class="s1">originalCallbackNode = root.callbackNode;</span>
  <span class="s3">var </span><span class="s1">didFlushPassiveEffects = flushPassiveEffects();</span>

  <span class="s3">if </span><span class="s1">(didFlushPassiveEffects) {</span>
    <span class="s0">// Something in the passive effect phase may have canceled the current task.</span>
    <span class="s0">// Check if the task node for this root was changed.</span>
    <span class="s3">if </span><span class="s1">(root.callbackNode !== originalCallbackNode) {</span>
      <span class="s0">// The current task was canceled. Exit. We don't need to call</span>
      <span class="s0">// `ensureRootIsScheduled` because the check above implies either that</span>
      <span class="s0">// there's a new task, or that there's no remaining work on this root.</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s0">// Determine the next lanes to work on, using the fields stored</span>
  <span class="s0">// on the root.</span>

  <span class="s3">var </span><span class="s1">lanes = getNextLanes(</span>
    <span class="s1">root,</span>
    <span class="s1">root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes</span>
  <span class="s1">);</span>

  <span class="s3">if </span><span class="s1">(lanes === NoLanes) {</span>
    <span class="s0">// Defensive coding. This is never expected to happen.</span>
    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s0">// We disable time-slicing in some cases: if the work has been CPU-bound</span>
  <span class="s0">// for too long (&quot;expired&quot; work, to prevent starvation), or we're in</span>
  <span class="s0">// sync-updates-by-default mode.</span>
  <span class="s0">// TODO: We only check `didTimeout` defensively, to account for a Scheduler</span>
  <span class="s0">// bug we're still investigating. Once the bug in Scheduler is fixed,</span>
  <span class="s0">// we can remove this, since we track expiration ourselves.</span>

  <span class="s3">var </span><span class="s1">shouldTimeSlice =</span>
    <span class="s1">!includesBlockingLane(root, lanes) &amp;&amp;</span>
    <span class="s1">!includesExpiredLane(root, lanes) &amp;&amp;</span>
    <span class="s1">!didTimeout;</span>
  <span class="s3">var </span><span class="s1">exitStatus = shouldTimeSlice</span>
    <span class="s1">? renderRootConcurrent(root, lanes)</span>
    <span class="s1">: renderRootSync(root, lanes);</span>

  <span class="s3">if </span><span class="s1">(exitStatus !== RootInProgress) {</span>
    <span class="s3">if </span><span class="s1">(exitStatus === RootErrored) {</span>
      <span class="s0">// If something threw an error, try rendering one more time. We'll</span>
      <span class="s0">// render synchronously to block concurrent data mutations, and we'll</span>
      <span class="s0">// includes all pending updates are included. If it still fails after</span>
      <span class="s0">// the second attempt, we'll give up and commit the resulting tree.</span>
      <span class="s3">var </span><span class="s1">errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);</span>

      <span class="s3">if </span><span class="s1">(errorRetryLanes !== NoLanes) {</span>
        <span class="s1">lanes = errorRetryLanes;</span>
        <span class="s1">exitStatus = recoverFromConcurrentError(root, errorRetryLanes);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(exitStatus === RootFatalErrored) {</span>
      <span class="s3">var </span><span class="s1">fatalError = workInProgressRootFatalError;</span>
      <span class="s1">prepareFreshStack(root, NoLanes);</span>
      <span class="s1">markRootSuspended$1(root, lanes);</span>
      <span class="s1">ensureRootIsScheduled(root, now());</span>
      <span class="s3">throw </span><span class="s1">fatalError;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(exitStatus === RootDidNotComplete) {</span>
      <span class="s0">// The render unwound without completing the tree. This happens in special</span>
      <span class="s0">// cases where need to exit the current render without producing a</span>
      <span class="s0">// consistent tree or committing.</span>
      <span class="s0">//</span>
      <span class="s0">// This should only happen during a concurrent render, not a discrete or</span>
      <span class="s0">// synchronous update. We should have already checked for this when we</span>
      <span class="s0">// unwound the stack.</span>
      <span class="s1">markRootSuspended$1(root, lanes);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s0">// The render completed.</span>
      <span class="s0">// Check if this render may have yielded to a concurrent event, and if so,</span>
      <span class="s0">// confirm that any newly rendered stores are consistent.</span>
      <span class="s0">// TODO: It's possible that even a concurrent render may never have yielded</span>
      <span class="s0">// to the main thread, if it was fast enough, or if it expired. We could</span>
      <span class="s0">// skip the consistency check in that case, too.</span>
      <span class="s3">var </span><span class="s1">renderWasConcurrent = !includesBlockingLane(root, lanes);</span>
      <span class="s3">var </span><span class="s1">finishedWork = root.current.alternate;</span>

      <span class="s3">if </span><span class="s1">(</span>
        <span class="s1">renderWasConcurrent &amp;&amp;</span>
        <span class="s1">!isRenderConsistentWithExternalStores(finishedWork)</span>
      <span class="s1">) {</span>
        <span class="s0">// A store was mutated in an interleaved event. Render again,</span>
        <span class="s0">// synchronously, to block further mutations.</span>
        <span class="s1">exitStatus = renderRootSync(root, lanes); </span><span class="s0">// We need to check again if something threw</span>

        <span class="s3">if </span><span class="s1">(exitStatus === RootErrored) {</span>
          <span class="s3">var </span><span class="s1">_errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);</span>

          <span class="s3">if </span><span class="s1">(_errorRetryLanes !== NoLanes) {</span>
            <span class="s1">lanes = _errorRetryLanes;</span>
            <span class="s1">exitStatus = recoverFromConcurrentError(root, _errorRetryLanes); </span><span class="s0">// We assume the tree is now consistent because we didn't yield to any</span>
            <span class="s0">// concurrent events.</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(exitStatus === RootFatalErrored) {</span>
          <span class="s3">var </span><span class="s1">_fatalError = workInProgressRootFatalError;</span>
          <span class="s1">prepareFreshStack(root, NoLanes);</span>
          <span class="s1">markRootSuspended$1(root, lanes);</span>
          <span class="s1">ensureRootIsScheduled(root, now());</span>
          <span class="s3">throw </span><span class="s1">_fatalError;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s0">// We now have a consistent tree. The next step is either to commit it,</span>
      <span class="s0">// or, if something suspended, wait to commit it after a timeout.</span>

      <span class="s1">root.finishedWork = finishedWork;</span>
      <span class="s1">root.finishedLanes = lanes;</span>
      <span class="s1">finishConcurrentRender(root, exitStatus, lanes);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">ensureRootIsScheduled(root, now());</span>

  <span class="s3">if </span><span class="s1">(root.callbackNode === originalCallbackNode) {</span>
    <span class="s0">// The task node scheduled for this root is the same one that's</span>
    <span class="s0">// currently executed. Need to return a continuation.</span>
    <span class="s3">return </span><span class="s1">performConcurrentWorkOnRoot.bind(</span><span class="s3">null</span><span class="s1">, root);</span>
  <span class="s1">}</span>

  <span class="s3">return null</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">recoverFromConcurrentError(root, errorRetryLanes) {</span>
  <span class="s0">// If an error occurred during hydration, discard server response and fall</span>
  <span class="s0">// back to client side render.</span>
  <span class="s0">// Before rendering again, save the errors from the previous attempt.</span>
  <span class="s3">var </span><span class="s1">errorsFromFirstAttempt = workInProgressRootConcurrentErrors;</span>

  <span class="s3">if </span><span class="s1">(isRootDehydrated(root)) {</span>
    <span class="s0">// The shell failed to hydrate. Set a flag to force a client rendering</span>
    <span class="s0">// during the next attempt. To do this, we call prepareFreshStack now</span>
    <span class="s0">// to create the root work-in-progress fiber. This is a bit weird in terms</span>
    <span class="s0">// of factoring, because it relies on renderRootSync not calling</span>
    <span class="s0">// prepareFreshStack again in the call below, which happens because the</span>
    <span class="s0">// root and lanes haven't changed.</span>
    <span class="s0">//</span>
    <span class="s0">// TODO: I think what we should do is set ForceClientRender inside</span>
    <span class="s0">// throwException, like we do for nested Suspense boundaries. The reason</span>
    <span class="s0">// it's here instead is so we can switch to the synchronous work loop, too.</span>
    <span class="s0">// Something to consider for a future refactor.</span>
    <span class="s3">var </span><span class="s1">rootWorkInProgress = prepareFreshStack(root, errorRetryLanes);</span>
    <span class="s1">rootWorkInProgress.flags |= ForceClientRender;</span>

    <span class="s1">{</span>
      <span class="s1">errorHydratingContainer(root.containerInfo);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">exitStatus = renderRootSync(root, errorRetryLanes);</span>

  <span class="s3">if </span><span class="s1">(exitStatus !== RootErrored) {</span>
    <span class="s0">// Successfully finished rendering on retry</span>
    <span class="s0">// The errors from the failed first attempt have been recovered. Add</span>
    <span class="s0">// them to the collection of recoverable errors. We'll log them in the</span>
    <span class="s0">// commit phase.</span>
    <span class="s3">var </span><span class="s1">errorsFromSecondAttempt = workInProgressRootRecoverableErrors;</span>
    <span class="s1">workInProgressRootRecoverableErrors = errorsFromFirstAttempt; </span><span class="s0">// The errors from the second attempt should be queued after the errors</span>
    <span class="s0">// from the first attempt, to preserve the causal sequence.</span>

    <span class="s3">if </span><span class="s1">(errorsFromSecondAttempt !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">queueRecoverableErrors(errorsFromSecondAttempt);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">exitStatus;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">queueRecoverableErrors(errors) {</span>
  <span class="s3">if </span><span class="s1">(workInProgressRootRecoverableErrors === </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s1">workInProgressRootRecoverableErrors = errors;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">workInProgressRootRecoverableErrors.push.apply(</span>
      <span class="s1">workInProgressRootRecoverableErrors,</span>
      <span class="s1">errors</span>
    <span class="s1">);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">finishConcurrentRender(root, exitStatus, lanes) {</span>
  <span class="s3">switch </span><span class="s1">(exitStatus) {</span>
    <span class="s3">case </span><span class="s1">RootInProgress:</span>
    <span class="s3">case </span><span class="s1">RootFatalErrored: {</span>
      <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Root did not complete. This is a bug in React.&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s0">// Flow knows about invariant, so it complains if I add a break</span>
    <span class="s0">// statement, but eslint doesn't know about invariant, so it complains</span>
    <span class="s0">// if I do. eslint-disable-next-line no-fallthrough</span>

    <span class="s3">case </span><span class="s1">RootErrored: {</span>
      <span class="s0">// We should have already attempted to retry this tree. If we reached</span>
      <span class="s0">// this point, it errored again. Commit it.</span>
      <span class="s1">commitRoot(</span>
        <span class="s1">root,</span>
        <span class="s1">workInProgressRootRecoverableErrors,</span>
        <span class="s1">workInProgressTransitions</span>
      <span class="s1">);</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">case </span><span class="s1">RootSuspended: {</span>
      <span class="s1">markRootSuspended$1(root, lanes); </span><span class="s0">// We have an acceptable loading state. We need to figure out if we</span>
      <span class="s0">// should immediately commit it or wait a bit.</span>

      <span class="s3">if </span><span class="s1">(</span>
        <span class="s1">includesOnlyRetries(lanes) &amp;&amp; </span><span class="s0">// do not delay if we're inside an act() scope</span>
        <span class="s1">!shouldForceFlushFallbacksInDEV()</span>
      <span class="s1">) {</span>
        <span class="s0">// This render only included retries, no updates. Throttle committing</span>
        <span class="s0">// retries so that we don't show too many loading states too quickly.</span>
        <span class="s3">var </span><span class="s1">msUntilTimeout =</span>
          <span class="s1">globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now(); </span><span class="s0">// Don't bother with a very short suspense time.</span>

        <span class="s3">if </span><span class="s1">(msUntilTimeout &gt; </span><span class="s4">10</span><span class="s1">) {</span>
          <span class="s3">var </span><span class="s1">nextLanes = getNextLanes(root, NoLanes);</span>

          <span class="s3">if </span><span class="s1">(nextLanes !== NoLanes) {</span>
            <span class="s0">// There's additional work on this root.</span>
            <span class="s3">break</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s3">var </span><span class="s1">suspendedLanes = root.suspendedLanes;</span>

          <span class="s3">if </span><span class="s1">(!isSubsetOfLanes(suspendedLanes, lanes)) {</span>
            <span class="s0">// We should prefer to render the fallback of at the last</span>
            <span class="s0">// suspended level. Ping the last suspended level to try</span>
            <span class="s0">// rendering it again.</span>
            <span class="s0">// FIXME: What if the suspended lanes are Idle? Should not restart.</span>
            <span class="s3">var </span><span class="s1">eventTime = requestEventTime();</span>
            <span class="s1">markRootPinged(root, suspendedLanes);</span>
            <span class="s3">break</span><span class="s1">;</span>
          <span class="s1">} </span><span class="s0">// The render is suspended, it hasn't timed out, and there's no</span>
          <span class="s0">// lower priority work to do. Instead of committing the fallback</span>
          <span class="s0">// immediately, wait for more data to arrive.</span>

          <span class="s1">root.timeoutHandle = scheduleTimeout(</span>
            <span class="s1">commitRoot.bind(</span>
              <span class="s3">null</span><span class="s1">,</span>
              <span class="s1">root,</span>
              <span class="s1">workInProgressRootRecoverableErrors,</span>
              <span class="s1">workInProgressTransitions</span>
            <span class="s1">),</span>
            <span class="s1">msUntilTimeout</span>
          <span class="s1">);</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s0">// The work expired. Commit immediately.</span>

      <span class="s1">commitRoot(</span>
        <span class="s1">root,</span>
        <span class="s1">workInProgressRootRecoverableErrors,</span>
        <span class="s1">workInProgressTransitions</span>
      <span class="s1">);</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">case </span><span class="s1">RootSuspendedWithDelay: {</span>
      <span class="s1">markRootSuspended$1(root, lanes);</span>

      <span class="s3">if </span><span class="s1">(includesOnlyTransitions(lanes)) {</span>
        <span class="s0">// This is a transition, so we should exit without committing a</span>
        <span class="s0">// placeholder and without scheduling a timeout. Delay indefinitely</span>
        <span class="s0">// until we receive more data.</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(!shouldForceFlushFallbacksInDEV()) {</span>
        <span class="s0">// This is not a transition, but we did trigger an avoided state.</span>
        <span class="s0">// Schedule a placeholder to display after a short delay, using the Just</span>
        <span class="s0">// Noticeable Difference.</span>
        <span class="s0">// TODO: Is the JND optimization worth the added complexity? If this is</span>
        <span class="s0">// the only reason we track the event time, then probably not.</span>
        <span class="s0">// Consider removing.</span>
        <span class="s3">var </span><span class="s1">mostRecentEventTime = getMostRecentEventTime(root, lanes);</span>
        <span class="s3">var </span><span class="s1">eventTimeMs = mostRecentEventTime;</span>
        <span class="s3">var </span><span class="s1">timeElapsedMs = now() - eventTimeMs;</span>

        <span class="s3">var </span><span class="s1">_msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs; </span><span class="s0">// Don't bother with a very short suspense time.</span>

        <span class="s3">if </span><span class="s1">(_msUntilTimeout &gt; </span><span class="s4">10</span><span class="s1">) {</span>
          <span class="s0">// Instead of committing the fallback immediately, wait for more data</span>
          <span class="s0">// to arrive.</span>
          <span class="s1">root.timeoutHandle = scheduleTimeout(</span>
            <span class="s1">commitRoot.bind(</span>
              <span class="s3">null</span><span class="s1">,</span>
              <span class="s1">root,</span>
              <span class="s1">workInProgressRootRecoverableErrors,</span>
              <span class="s1">workInProgressTransitions</span>
            <span class="s1">),</span>
            <span class="s1">_msUntilTimeout</span>
          <span class="s1">);</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s0">// Commit the placeholder.</span>

      <span class="s1">commitRoot(</span>
        <span class="s1">root,</span>
        <span class="s1">workInProgressRootRecoverableErrors,</span>
        <span class="s1">workInProgressTransitions</span>
      <span class="s1">);</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">case </span><span class="s1">RootCompleted: {</span>
      <span class="s0">// The work completed. Ready to commit.</span>
      <span class="s1">commitRoot(</span>
        <span class="s1">root,</span>
        <span class="s1">workInProgressRootRecoverableErrors,</span>
        <span class="s1">workInProgressTransitions</span>
      <span class="s1">);</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">default</span><span class="s1">: {</span>
      <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Unknown root exit status.&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">isRenderConsistentWithExternalStores(finishedWork) {</span>
  <span class="s0">// Search the rendered tree for external store reads, and check whether the</span>
  <span class="s0">// stores were mutated in a concurrent event. Intentionally using an iterative</span>
  <span class="s0">// loop instead of recursion so we can exit early.</span>
  <span class="s3">var </span><span class="s1">node = finishedWork;</span>

  <span class="s3">while </span><span class="s1">(</span><span class="s3">true</span><span class="s1">) {</span>
    <span class="s3">if </span><span class="s1">(node.flags &amp; StoreConsistency) {</span>
      <span class="s3">var </span><span class="s1">updateQueue = node.updateQueue;</span>

      <span class="s3">if </span><span class="s1">(updateQueue !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">checks = updateQueue.stores;</span>

        <span class="s3">if </span><span class="s1">(checks !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; checks.length; i++) {</span>
            <span class="s3">var </span><span class="s1">check = checks[i];</span>
            <span class="s3">var </span><span class="s1">getSnapshot = check.getSnapshot;</span>
            <span class="s3">var </span><span class="s1">renderedValue = check.value;</span>

            <span class="s3">try </span><span class="s1">{</span>
              <span class="s3">if </span><span class="s1">(!objectIs(getSnapshot(), renderedValue)) {</span>
                <span class="s0">// Found an inconsistent store.</span>
                <span class="s3">return false</span><span class="s1">;</span>
              <span class="s1">}</span>
            <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
              <span class="s0">// If `getSnapshot` throws, return `false`. This will schedule</span>
              <span class="s0">// a re-render, and the error will be rethrown during render.</span>
              <span class="s3">return false</span><span class="s1">;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">child = node.child;</span>

    <span class="s3">if </span><span class="s1">(node.subtreeFlags &amp; StoreConsistency &amp;&amp; child !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">child.</span><span class="s3">return </span><span class="s1">= node;</span>
      <span class="s1">node = child;</span>
      <span class="s3">continue</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(node === finishedWork) {</span>
      <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">while </span><span class="s1">(node.sibling === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(node.</span><span class="s3">return </span><span class="s1">=== </span><span class="s3">null </span><span class="s1">|| node.</span><span class="s3">return </span><span class="s1">=== finishedWork) {</span>
        <span class="s3">return true</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">node = node.</span><span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">node.sibling.</span><span class="s3">return </span><span class="s1">= node.</span><span class="s3">return</span><span class="s1">;</span>
    <span class="s1">node = node.sibling;</span>
  <span class="s1">} </span><span class="s0">// Flow doesn't know this is unreachable, but eslint does</span>
  <span class="s0">// eslint-disable-next-line no-unreachable</span>

  <span class="s3">return true</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">markRootSuspended$1(root, suspendedLanes) {</span>
  <span class="s0">// When suspending, we should always exclude lanes that were pinged or (more</span>
  <span class="s0">// rarely, since we try to avoid it) updated during the render phase.</span>
  <span class="s0">// TODO: Lol maybe there's a better way to factor this besides this</span>
  <span class="s0">// obnoxiously named function :)</span>
  <span class="s1">suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);</span>
  <span class="s1">suspendedLanes = removeLanes(</span>
    <span class="s1">suspendedLanes,</span>
    <span class="s1">workInProgressRootInterleavedUpdatedLanes</span>
  <span class="s1">);</span>
  <span class="s1">markRootSuspended(root, suspendedLanes);</span>
<span class="s1">} </span><span class="s0">// This is the entry point for synchronous tasks that don't go</span>
<span class="s0">// through Scheduler</span>

<span class="s3">function </span><span class="s1">performSyncWorkOnRoot(root) {</span>
  <span class="s1">{</span>
    <span class="s1">syncNestedUpdateFlag();</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">((executionContext &amp; (RenderContext | CommitContext)) !== NoContext) {</span>
    <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Should not already be working.&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s1">flushPassiveEffects();</span>
  <span class="s3">var </span><span class="s1">lanes = getNextLanes(root, NoLanes);</span>

  <span class="s3">if </span><span class="s1">(!includesSomeLane(lanes, SyncLane)) {</span>
    <span class="s0">// There's no remaining sync work left.</span>
    <span class="s1">ensureRootIsScheduled(root, now());</span>
    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">exitStatus = renderRootSync(root, lanes);</span>

  <span class="s3">if </span><span class="s1">(root.tag !== LegacyRoot &amp;&amp; exitStatus === RootErrored) {</span>
    <span class="s0">// If something threw an error, try rendering one more time. We'll render</span>
    <span class="s0">// synchronously to block concurrent data mutations, and we'll includes</span>
    <span class="s0">// all pending updates are included. If it still fails after the second</span>
    <span class="s0">// attempt, we'll give up and commit the resulting tree.</span>
    <span class="s3">var </span><span class="s1">errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);</span>

    <span class="s3">if </span><span class="s1">(errorRetryLanes !== NoLanes) {</span>
      <span class="s1">lanes = errorRetryLanes;</span>
      <span class="s1">exitStatus = recoverFromConcurrentError(root, errorRetryLanes);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(exitStatus === RootFatalErrored) {</span>
    <span class="s3">var </span><span class="s1">fatalError = workInProgressRootFatalError;</span>
    <span class="s1">prepareFreshStack(root, NoLanes);</span>
    <span class="s1">markRootSuspended$1(root, lanes);</span>
    <span class="s1">ensureRootIsScheduled(root, now());</span>
    <span class="s3">throw </span><span class="s1">fatalError;</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(exitStatus === RootDidNotComplete) {</span>
    <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Root did not complete. This is a bug in React.&quot;</span><span class="s1">);</span>
  <span class="s1">} </span><span class="s0">// We now have a consistent tree. Because this is a sync render, we</span>
  <span class="s0">// will commit it even if something suspended.</span>

  <span class="s3">var </span><span class="s1">finishedWork = root.current.alternate;</span>
  <span class="s1">root.finishedWork = finishedWork;</span>
  <span class="s1">root.finishedLanes = lanes;</span>
  <span class="s1">commitRoot(</span>
    <span class="s1">root,</span>
    <span class="s1">workInProgressRootRecoverableErrors,</span>
    <span class="s1">workInProgressTransitions</span>
  <span class="s1">); </span><span class="s0">// Before exiting, make sure there's a callback scheduled for the next</span>
  <span class="s0">// pending level.</span>

  <span class="s1">ensureRootIsScheduled(root, now());</span>
  <span class="s3">return null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">batchedUpdates$1(fn, a) {</span>
  <span class="s3">var </span><span class="s1">prevExecutionContext = executionContext;</span>
  <span class="s1">executionContext |= BatchedContext;</span>

  <span class="s3">try </span><span class="s1">{</span>
    <span class="s3">return </span><span class="s1">fn(a);</span>
  <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
    <span class="s1">executionContext = prevExecutionContext; </span><span class="s0">// If there were legacy sync updates, flush them at the end of the outer</span>
    <span class="s0">// most batchedUpdates-like method.</span>

    <span class="s3">if </span><span class="s1">(</span>
      <span class="s1">executionContext === NoContext &amp;&amp; </span><span class="s0">// Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.</span>
      <span class="s1">!ReactCurrentActQueue$1.isBatchingLegacy</span>
    <span class="s1">) {</span>
      <span class="s1">resetRenderTimer();</span>
      <span class="s1">flushSyncCallbacksOnlyInLegacyMode();</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">// Warning, this opts-out of checking the function body.</span>

<span class="s0">// eslint-disable-next-line no-redeclare</span>
<span class="s3">function </span><span class="s1">flushSync(fn) {</span>
  <span class="s0">// In legacy mode, we flush pending passive effects at the beginning of the</span>
  <span class="s0">// next event, not at the end of the previous one.</span>
  <span class="s3">if </span><span class="s1">(</span>
    <span class="s1">rootWithPendingPassiveEffects !== </span><span class="s3">null </span><span class="s1">&amp;&amp;</span>
    <span class="s1">rootWithPendingPassiveEffects.tag === LegacyRoot &amp;&amp;</span>
    <span class="s1">(executionContext &amp; (RenderContext | CommitContext)) === NoContext</span>
  <span class="s1">) {</span>
    <span class="s1">flushPassiveEffects();</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">prevExecutionContext = executionContext;</span>
  <span class="s1">executionContext |= BatchedContext;</span>
  <span class="s3">var </span><span class="s1">prevTransition = ReactCurrentBatchConfig$2.transition;</span>
  <span class="s3">var </span><span class="s1">previousPriority = getCurrentUpdatePriority();</span>

  <span class="s3">try </span><span class="s1">{</span>
    <span class="s1">ReactCurrentBatchConfig$2.transition = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">setCurrentUpdatePriority(DiscreteEventPriority);</span>

    <span class="s3">if </span><span class="s1">(fn) {</span>
      <span class="s3">return </span><span class="s1">fn();</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">return </span><span class="s1">undefined;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
    <span class="s1">setCurrentUpdatePriority(previousPriority);</span>
    <span class="s1">ReactCurrentBatchConfig$2.transition = prevTransition;</span>
    <span class="s1">executionContext = prevExecutionContext; </span><span class="s0">// Flush the immediate callbacks that were scheduled during this batch.</span>
    <span class="s0">// Note that this will happen even if batchedUpdates is higher up</span>
    <span class="s0">// the stack.</span>

    <span class="s3">if </span><span class="s1">((executionContext &amp; (RenderContext | CommitContext)) === NoContext) {</span>
      <span class="s1">flushSyncCallbacks();</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">pushRenderLanes(fiber, lanes) {</span>
  <span class="s1">push(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);</span>
  <span class="s1">subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);</span>
  <span class="s1">workInProgressRootIncludedLanes = mergeLanes(</span>
    <span class="s1">workInProgressRootIncludedLanes,</span>
    <span class="s1">lanes</span>
  <span class="s1">);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">popRenderLanes(fiber) {</span>
  <span class="s1">subtreeRenderLanes = subtreeRenderLanesCursor.current;</span>
  <span class="s1">pop(subtreeRenderLanesCursor, fiber);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">prepareFreshStack(root, lanes) {</span>
  <span class="s1">root.finishedWork = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">root.finishedLanes = NoLanes;</span>
  <span class="s3">var </span><span class="s1">timeoutHandle = root.timeoutHandle;</span>

  <span class="s3">if </span><span class="s1">(timeoutHandle !== noTimeout) {</span>
    <span class="s0">// The root previous suspended and scheduled a timeout to commit a fallback</span>
    <span class="s0">// state. Now that we have additional work, cancel the timeout.</span>
    <span class="s1">root.timeoutHandle = noTimeout; </span><span class="s0">// $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above</span>

    <span class="s1">cancelTimeout(timeoutHandle);</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(workInProgress !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">interruptedWork = workInProgress.</span><span class="s3">return</span><span class="s1">;</span>

    <span class="s3">while </span><span class="s1">(interruptedWork !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">current = interruptedWork.alternate;</span>
      <span class="s1">unwindInterruptedWork(current, interruptedWork);</span>
      <span class="s1">interruptedWork = interruptedWork.</span><span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">workInProgressRoot = root;</span>
  <span class="s3">var </span><span class="s1">rootWorkInProgress = createWorkInProgress(root.current, </span><span class="s3">null</span><span class="s1">);</span>
  <span class="s1">workInProgress = rootWorkInProgress;</span>
  <span class="s1">workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;</span>
  <span class="s1">workInProgressRootExitStatus = RootInProgress;</span>
  <span class="s1">workInProgressRootFatalError = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">workInProgressRootSkippedLanes = NoLanes;</span>
  <span class="s1">workInProgressRootInterleavedUpdatedLanes = NoLanes;</span>
  <span class="s1">workInProgressRootPingedLanes = NoLanes;</span>
  <span class="s1">workInProgressRootConcurrentErrors = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">workInProgressRootRecoverableErrors = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">finishQueueingConcurrentUpdates();</span>

  <span class="s1">{</span>
    <span class="s1">ReactStrictModeWarnings.discardPendingWarnings();</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">rootWorkInProgress;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">handleError(root, thrownValue) {</span>
  <span class="s3">do </span><span class="s1">{</span>
    <span class="s3">var </span><span class="s1">erroredWork = workInProgress;</span>

    <span class="s3">try </span><span class="s1">{</span>
      <span class="s0">// Reset module-level state that was set during the render phase.</span>
      <span class="s1">resetContextDependencies();</span>
      <span class="s1">resetHooksAfterThrow();</span>
      <span class="s1">resetCurrentFiber(); </span><span class="s0">// TODO: I found and added this missing line while investigating a</span>
      <span class="s0">// separate issue. Write a regression test using string refs.</span>

      <span class="s1">ReactCurrentOwner$2.current = </span><span class="s3">null</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s1">(erroredWork === </span><span class="s3">null </span><span class="s1">|| erroredWork.</span><span class="s3">return </span><span class="s1">=== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s0">// Expected to be working on a non-root fiber. This is a fatal error</span>
        <span class="s0">// because there's no ancestor that can handle it; the root is</span>
        <span class="s0">// supposed to capture all errors that weren't caught by an error</span>
        <span class="s0">// boundary.</span>
        <span class="s1">workInProgressRootExitStatus = RootFatalErrored;</span>
        <span class="s1">workInProgressRootFatalError = thrownValue; </span><span class="s0">// Set `workInProgress` to null. This represents advancing to the next</span>
        <span class="s0">// sibling, or the parent if there are no siblings. But since the root</span>
        <span class="s0">// has no siblings nor a parent, we set it to null. Usually this is</span>
        <span class="s0">// handled by `completeUnitOfWork` or `unwindWork`, but since we're</span>
        <span class="s0">// intentionally not calling those, we need set it here.</span>
        <span class="s0">// TODO: Consider calling `unwindWork` to pop the contexts.</span>

        <span class="s1">workInProgress = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(enableProfilerTimer &amp;&amp; erroredWork.mode &amp; ProfileMode) {</span>
        <span class="s0">// Record the time spent rendering before an error was thrown. This</span>
        <span class="s0">// avoids inaccurate Profiler durations in the case of a</span>
        <span class="s0">// suspended render.</span>
        <span class="s1">stopProfilerTimerIfRunningAndRecordDelta(erroredWork, </span><span class="s3">true</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(enableSchedulingProfiler) {</span>
        <span class="s1">markComponentRenderStopped();</span>

        <span class="s3">if </span><span class="s1">(</span>
          <span class="s1">thrownValue !== </span><span class="s3">null </span><span class="s1">&amp;&amp;</span>
          <span class="s3">typeof </span><span class="s1">thrownValue === </span><span class="s2">&quot;object&quot; </span><span class="s1">&amp;&amp;</span>
          <span class="s3">typeof </span><span class="s1">thrownValue.then === </span><span class="s2">&quot;function&quot;</span>
        <span class="s1">) {</span>
          <span class="s3">var </span><span class="s1">wakeable = thrownValue;</span>
          <span class="s1">markComponentSuspended(</span>
            <span class="s1">erroredWork,</span>
            <span class="s1">wakeable,</span>
            <span class="s1">workInProgressRootRenderLanes</span>
          <span class="s1">);</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s1">markComponentErrored(</span>
            <span class="s1">erroredWork,</span>
            <span class="s1">thrownValue,</span>
            <span class="s1">workInProgressRootRenderLanes</span>
          <span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">throwException(</span>
        <span class="s1">root,</span>
        <span class="s1">erroredWork.</span><span class="s3">return</span><span class="s1">,</span>
        <span class="s1">erroredWork,</span>
        <span class="s1">thrownValue,</span>
        <span class="s1">workInProgressRootRenderLanes</span>
      <span class="s1">);</span>
      <span class="s1">completeUnitOfWork(erroredWork);</span>
    <span class="s1">} </span><span class="s3">catch </span><span class="s1">(yetAnotherThrownValue) {</span>
      <span class="s0">// Something in the return path also threw.</span>
      <span class="s1">thrownValue = yetAnotherThrownValue;</span>

      <span class="s3">if </span><span class="s1">(workInProgress === erroredWork &amp;&amp; erroredWork !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s0">// If this boundary has already errored, then we had trouble processing</span>
        <span class="s0">// the error. Bubble it to the next boundary.</span>
        <span class="s1">erroredWork = erroredWork.</span><span class="s3">return</span><span class="s1">;</span>
        <span class="s1">workInProgress = erroredWork;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">erroredWork = workInProgress;</span>
      <span class="s1">}</span>

      <span class="s3">continue</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s0">// Return to the normal work loop.</span>

    <span class="s3">return</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s3">while </span><span class="s1">(</span><span class="s3">true</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">pushDispatcher() {</span>
  <span class="s3">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher$2.current;</span>
  <span class="s1">ReactCurrentDispatcher$2.current = ContextOnlyDispatcher;</span>

  <span class="s3">if </span><span class="s1">(prevDispatcher === </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s0">// The React isomorphic package does not include a default dispatcher.</span>
    <span class="s0">// Instead the first renderer will lazily attach one, in order to give</span>
    <span class="s0">// nicer error messages.</span>
    <span class="s3">return </span><span class="s1">ContextOnlyDispatcher;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s3">return </span><span class="s1">prevDispatcher;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">popDispatcher(prevDispatcher) {</span>
  <span class="s1">ReactCurrentDispatcher$2.current = prevDispatcher;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">markCommitTimeOfFallback() {</span>
  <span class="s1">globalMostRecentFallbackTime = now();</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">markSkippedUpdateLanes(lane) {</span>
  <span class="s1">workInProgressRootSkippedLanes = mergeLanes(</span>
    <span class="s1">lane,</span>
    <span class="s1">workInProgressRootSkippedLanes</span>
  <span class="s1">);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">renderDidSuspend() {</span>
  <span class="s3">if </span><span class="s1">(workInProgressRootExitStatus === RootInProgress) {</span>
    <span class="s1">workInProgressRootExitStatus = RootSuspended;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">renderDidSuspendDelayIfPossible() {</span>
  <span class="s3">if </span><span class="s1">(</span>
    <span class="s1">workInProgressRootExitStatus === RootInProgress ||</span>
    <span class="s1">workInProgressRootExitStatus === RootSuspended ||</span>
    <span class="s1">workInProgressRootExitStatus === RootErrored</span>
  <span class="s1">) {</span>
    <span class="s1">workInProgressRootExitStatus = RootSuspendedWithDelay;</span>
  <span class="s1">} </span><span class="s0">// Check if there are updates that we skipped tree that might have unblocked</span>
  <span class="s0">// this render.</span>

  <span class="s3">if </span><span class="s1">(</span>
    <span class="s1">workInProgressRoot !== </span><span class="s3">null </span><span class="s1">&amp;&amp;</span>
    <span class="s1">(includesNonIdleWork(workInProgressRootSkippedLanes) ||</span>
      <span class="s1">includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes))</span>
  <span class="s1">) {</span>
    <span class="s0">// Mark the current render as suspended so that we switch to working on</span>
    <span class="s0">// the updates that were skipped. Usually we only suspend at the end of</span>
    <span class="s0">// the render phase.</span>
    <span class="s0">// TODO: We should probably always mark the root as suspended immediately</span>
    <span class="s0">// (inside this function), since by suspending at the end of the render</span>
    <span class="s0">// phase introduces a potential mistake where we suspend lanes that were</span>
    <span class="s0">// pinged or updated while we were rendering.</span>
    <span class="s1">markRootSuspended$1(workInProgressRoot, workInProgressRootRenderLanes);</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">renderDidError(error) {</span>
  <span class="s3">if </span><span class="s1">(workInProgressRootExitStatus !== RootSuspendedWithDelay) {</span>
    <span class="s1">workInProgressRootExitStatus = RootErrored;</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(workInProgressRootConcurrentErrors === </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s1">workInProgressRootConcurrentErrors = [error];</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">workInProgressRootConcurrentErrors.push(error);</span>
  <span class="s1">}</span>
<span class="s1">} </span><span class="s0">// Called during render to determine if anything has suspended.</span>
<span class="s0">// Returns false if we're not sure.</span>

<span class="s3">function </span><span class="s1">renderHasNotSuspendedYet() {</span>
  <span class="s0">// If something errored or completed, we can't really be sure,</span>
  <span class="s0">// so those are false.</span>
  <span class="s3">return </span><span class="s1">workInProgressRootExitStatus === RootInProgress;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">renderRootSync(root, lanes) {</span>
  <span class="s3">var </span><span class="s1">prevExecutionContext = executionContext;</span>
  <span class="s1">executionContext |= RenderContext;</span>
  <span class="s3">var </span><span class="s1">prevDispatcher = pushDispatcher(); </span><span class="s0">// If the root or lanes have changed, throw out the existing stack</span>
  <span class="s0">// and prepare a fresh one. Otherwise we'll continue where we left off.</span>

  <span class="s3">if </span><span class="s1">(workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(isDevToolsPresent) {</span>
        <span class="s3">var </span><span class="s1">memoizedUpdaters = root.memoizedUpdaters;</span>

        <span class="s3">if </span><span class="s1">(memoizedUpdaters.size &gt; </span><span class="s4">0</span><span class="s1">) {</span>
          <span class="s1">restorePendingUpdaters(root, workInProgressRootRenderLanes);</span>
          <span class="s1">memoizedUpdaters.clear();</span>
        <span class="s1">} </span><span class="s0">// At this point, move Fibers that scheduled the upcoming work from the Map to the Set.</span>
        <span class="s0">// If we bailout on this work, we'll move them back (like above).</span>
        <span class="s0">// It's important to move them now in case the work spawns more work at the same priority with different updaters.</span>
        <span class="s0">// That way we can keep the current update and future updates separate.</span>

        <span class="s1">movePendingFibersToMemoized(root, lanes);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">workInProgressTransitions = getTransitionsForLanes();</span>
    <span class="s1">prepareFreshStack(root, lanes);</span>
  <span class="s1">}</span>

  <span class="s3">do </span><span class="s1">{</span>
    <span class="s3">try </span><span class="s1">{</span>
      <span class="s1">workLoopSync();</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">catch </span><span class="s1">(thrownValue) {</span>
      <span class="s1">handleError(root, thrownValue);</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s3">while </span><span class="s1">(</span><span class="s3">true</span><span class="s1">);</span>

  <span class="s1">resetContextDependencies();</span>
  <span class="s1">executionContext = prevExecutionContext;</span>
  <span class="s1">popDispatcher(prevDispatcher);</span>

  <span class="s3">if </span><span class="s1">(workInProgress !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s0">// This is a sync render, so we should have finished the whole tree.</span>
    <span class="s3">throw new </span><span class="s1">Error(</span>
      <span class="s2">&quot;Cannot commit an incomplete root. This error is likely caused by a &quot; </span><span class="s1">+</span>
        <span class="s2">&quot;bug in React. Please file an issue.&quot;</span>
    <span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s1">workInProgressRoot = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">workInProgressRootRenderLanes = NoLanes;</span>
  <span class="s3">return </span><span class="s1">workInProgressRootExitStatus;</span>
<span class="s1">} </span><span class="s0">// The work loop is an extremely hot path. Tell Closure not to inline it.</span>

<span class="s0">/** @noinline */</span>

<span class="s3">function </span><span class="s1">workLoopSync() {</span>
  <span class="s0">// Already timed out, so perform work without checking if we need to yield.</span>
  <span class="s3">while </span><span class="s1">(workInProgress !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s1">performUnitOfWork(workInProgress);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">renderRootConcurrent(root, lanes) {</span>
  <span class="s3">var </span><span class="s1">prevExecutionContext = executionContext;</span>
  <span class="s1">executionContext |= RenderContext;</span>
  <span class="s3">var </span><span class="s1">prevDispatcher = pushDispatcher(); </span><span class="s0">// If the root or lanes have changed, throw out the existing stack</span>
  <span class="s0">// and prepare a fresh one. Otherwise we'll continue where we left off.</span>

  <span class="s3">if </span><span class="s1">(workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(isDevToolsPresent) {</span>
        <span class="s3">var </span><span class="s1">memoizedUpdaters = root.memoizedUpdaters;</span>

        <span class="s3">if </span><span class="s1">(memoizedUpdaters.size &gt; </span><span class="s4">0</span><span class="s1">) {</span>
          <span class="s1">restorePendingUpdaters(root, workInProgressRootRenderLanes);</span>
          <span class="s1">memoizedUpdaters.clear();</span>
        <span class="s1">} </span><span class="s0">// At this point, move Fibers that scheduled the upcoming work from the Map to the Set.</span>
        <span class="s0">// If we bailout on this work, we'll move them back (like above).</span>
        <span class="s0">// It's important to move them now in case the work spawns more work at the same priority with different updaters.</span>
        <span class="s0">// That way we can keep the current update and future updates separate.</span>

        <span class="s1">movePendingFibersToMemoized(root, lanes);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">workInProgressTransitions = getTransitionsForLanes();</span>
    <span class="s1">resetRenderTimer();</span>
    <span class="s1">prepareFreshStack(root, lanes);</span>
  <span class="s1">}</span>

  <span class="s3">do </span><span class="s1">{</span>
    <span class="s3">try </span><span class="s1">{</span>
      <span class="s1">workLoopConcurrent();</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">catch </span><span class="s1">(thrownValue) {</span>
      <span class="s1">handleError(root, thrownValue);</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s3">while </span><span class="s1">(</span><span class="s3">true</span><span class="s1">);</span>

  <span class="s1">resetContextDependencies();</span>
  <span class="s1">popDispatcher(prevDispatcher);</span>
  <span class="s1">executionContext = prevExecutionContext;</span>

  <span class="s3">if </span><span class="s1">(workInProgress !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">return </span><span class="s1">RootInProgress;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">workInProgressRoot = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">workInProgressRootRenderLanes = NoLanes; </span><span class="s0">// Return the final exit status.</span>

    <span class="s3">return </span><span class="s1">workInProgressRootExitStatus;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">/** @noinline */</span>

<span class="s3">function </span><span class="s1">workLoopConcurrent() {</span>
  <span class="s0">// Perform work until Scheduler asks us to yield</span>
  <span class="s3">while </span><span class="s1">(workInProgress !== </span><span class="s3">null </span><span class="s1">&amp;&amp; !shouldYield()) {</span>
    <span class="s1">performUnitOfWork(workInProgress);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">performUnitOfWork(unitOfWork) {</span>
  <span class="s0">// The current, flushed, state of this fiber is the alternate. Ideally</span>
  <span class="s0">// nothing should rely on this, but relying on it here means that we don't</span>
  <span class="s0">// need an additional field on the work in progress.</span>
  <span class="s3">var </span><span class="s1">current = unitOfWork.alternate;</span>
  <span class="s1">setCurrentFiber(unitOfWork);</span>
  <span class="s3">var </span><span class="s1">next;</span>

  <span class="s3">if </span><span class="s1">((unitOfWork.mode &amp; ProfileMode) !== NoMode) {</span>
    <span class="s1">startProfilerTimer(unitOfWork);</span>
    <span class="s1">next = beginWork$1(current, unitOfWork, subtreeRenderLanes);</span>
    <span class="s1">stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, </span><span class="s3">true</span><span class="s1">);</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">next = beginWork$1(current, unitOfWork, subtreeRenderLanes);</span>
  <span class="s1">}</span>

  <span class="s1">resetCurrentFiber();</span>
  <span class="s1">unitOfWork.memoizedProps = unitOfWork.pendingProps;</span>

  <span class="s3">if </span><span class="s1">(next === </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s0">// If this doesn't spawn new work, complete the current work.</span>
    <span class="s1">completeUnitOfWork(unitOfWork);</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">workInProgress = next;</span>
  <span class="s1">}</span>

  <span class="s1">ReactCurrentOwner$2.current = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">completeUnitOfWork(unitOfWork) {</span>
  <span class="s0">// Attempt to complete the current unit of work, then move to the next</span>
  <span class="s0">// sibling. If there are no more siblings, return to the parent fiber.</span>
  <span class="s3">var </span><span class="s1">completedWork = unitOfWork;</span>

  <span class="s3">do </span><span class="s1">{</span>
    <span class="s0">// The current, flushed, state of this fiber is the alternate. Ideally</span>
    <span class="s0">// nothing should rely on this, but relying on it here means that we don't</span>
    <span class="s0">// need an additional field on the work in progress.</span>
    <span class="s3">var </span><span class="s1">current = completedWork.alternate;</span>
    <span class="s3">var </span><span class="s1">returnFiber = completedWork.</span><span class="s3">return</span><span class="s1">; </span><span class="s0">// Check if the work completed or if something threw.</span>

    <span class="s3">if </span><span class="s1">((completedWork.flags &amp; Incomplete) === NoFlags) {</span>
      <span class="s1">setCurrentFiber(completedWork);</span>
      <span class="s3">var </span><span class="s1">next = </span><span class="s3">void </span><span class="s4">0</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s1">((completedWork.mode &amp; ProfileMode) === NoMode) {</span>
        <span class="s1">next = completeWork(current, completedWork, subtreeRenderLanes);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">startProfilerTimer(completedWork);</span>
        <span class="s1">next = completeWork(current, completedWork, subtreeRenderLanes); </span><span class="s0">// Update render duration assuming we didn't error.</span>

        <span class="s1">stopProfilerTimerIfRunningAndRecordDelta(completedWork, </span><span class="s3">false</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s1">resetCurrentFiber();</span>

      <span class="s3">if </span><span class="s1">(next !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s0">// Completing this fiber spawned new work. Work on that next.</span>
        <span class="s1">workInProgress = next;</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s0">// This fiber did not complete because something threw. Pop values off</span>
      <span class="s0">// the stack without entering the complete phase. If this is a boundary,</span>
      <span class="s0">// capture values if possible.</span>
      <span class="s3">var </span><span class="s1">_next = unwindWork(current, completedWork); </span><span class="s0">// Because this fiber did not complete, don't reset its lanes.</span>

      <span class="s3">if </span><span class="s1">(_next !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s0">// If completing this work spawned new work, do that next. We'll come</span>
        <span class="s0">// back here again.</span>
        <span class="s0">// Since we're restarting, remove anything that is not a host effect</span>
        <span class="s0">// from the effect tag.</span>
        <span class="s1">_next.flags &amp;= HostEffectMask;</span>
        <span class="s1">workInProgress = _next;</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">((completedWork.mode &amp; ProfileMode) !== NoMode) {</span>
        <span class="s0">// Record the render duration for the fiber that errored.</span>
        <span class="s1">stopProfilerTimerIfRunningAndRecordDelta(completedWork, </span><span class="s3">false</span><span class="s1">); </span><span class="s0">// Include the time spent working on failed children before continuing.</span>

        <span class="s3">var </span><span class="s1">actualDuration = completedWork.actualDuration;</span>
        <span class="s3">var </span><span class="s1">child = completedWork.child;</span>

        <span class="s3">while </span><span class="s1">(child !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">actualDuration += child.actualDuration;</span>
          <span class="s1">child = child.sibling;</span>
        <span class="s1">}</span>

        <span class="s1">completedWork.actualDuration = actualDuration;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(returnFiber !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s0">// Mark the parent fiber as incomplete and clear its subtree flags.</span>
        <span class="s1">returnFiber.flags |= Incomplete;</span>
        <span class="s1">returnFiber.subtreeFlags = NoFlags;</span>
        <span class="s1">returnFiber.deletions = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s0">// We've unwound all the way to the root.</span>
        <span class="s1">workInProgressRootExitStatus = RootDidNotComplete;</span>
        <span class="s1">workInProgress = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">siblingFiber = completedWork.sibling;</span>

    <span class="s3">if </span><span class="s1">(siblingFiber !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// If there is more work to do in this returnFiber, do that next.</span>
      <span class="s1">workInProgress = siblingFiber;</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s0">// Otherwise, return to the parent</span>

    <span class="s1">completedWork = returnFiber; </span><span class="s0">// Update the next thing we're working on in case something throws.</span>

    <span class="s1">workInProgress = completedWork;</span>
  <span class="s1">} </span><span class="s3">while </span><span class="s1">(completedWork !== </span><span class="s3">null</span><span class="s1">); </span><span class="s0">// We've reached the root.</span>

  <span class="s3">if </span><span class="s1">(workInProgressRootExitStatus === RootInProgress) {</span>
    <span class="s1">workInProgressRootExitStatus = RootCompleted;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">commitRoot(root, recoverableErrors, transitions) {</span>
  <span class="s0">// TODO: This no longer makes any sense. We already wrap the mutation and</span>
  <span class="s0">// layout phases. Should be able to remove.</span>
  <span class="s3">var </span><span class="s1">previousUpdateLanePriority = getCurrentUpdatePriority();</span>
  <span class="s3">var </span><span class="s1">prevTransition = ReactCurrentBatchConfig$2.transition;</span>

  <span class="s3">try </span><span class="s1">{</span>
    <span class="s1">ReactCurrentBatchConfig$2.transition = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">setCurrentUpdatePriority(DiscreteEventPriority);</span>
    <span class="s1">commitRootImpl(</span>
      <span class="s1">root,</span>
      <span class="s1">recoverableErrors,</span>
      <span class="s1">transitions,</span>
      <span class="s1">previousUpdateLanePriority</span>
    <span class="s1">);</span>
  <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
    <span class="s1">ReactCurrentBatchConfig$2.transition = prevTransition;</span>
    <span class="s1">setCurrentUpdatePriority(previousUpdateLanePriority);</span>
  <span class="s1">}</span>

  <span class="s3">return null</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">commitRootImpl(</span>
  <span class="s1">root,</span>
  <span class="s1">recoverableErrors,</span>
  <span class="s1">transitions,</span>
  <span class="s1">renderPriorityLevel</span>
<span class="s1">) {</span>
  <span class="s3">do </span><span class="s1">{</span>
    <span class="s0">// `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which</span>
    <span class="s0">// means `flushPassiveEffects` will sometimes result in additional</span>
    <span class="s0">// passive effects. So we need to keep flushing in a loop until there are</span>
    <span class="s0">// no more pending effects.</span>
    <span class="s0">// TODO: Might be better if `flushPassiveEffects` did not automatically</span>
    <span class="s0">// flush synchronous work at the end, to avoid factoring hazards like this.</span>
    <span class="s1">flushPassiveEffects();</span>
  <span class="s1">} </span><span class="s3">while </span><span class="s1">(rootWithPendingPassiveEffects !== </span><span class="s3">null</span><span class="s1">);</span>

  <span class="s1">flushRenderPhaseStrictModeWarningsInDEV();</span>

  <span class="s3">if </span><span class="s1">((executionContext &amp; (RenderContext | CommitContext)) !== NoContext) {</span>
    <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Should not already be working.&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">finishedWork = root.finishedWork;</span>
  <span class="s3">var </span><span class="s1">lanes = root.finishedLanes;</span>

  <span class="s3">if </span><span class="s1">(finishedWork === </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(lanes === NoLanes) {</span>
        <span class="s1">error(</span>
          <span class="s2">&quot;root.finishedLanes should not be empty during a commit. This is a &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;bug in React.&quot;</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">root.finishedWork = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">root.finishedLanes = NoLanes;</span>

  <span class="s3">if </span><span class="s1">(finishedWork === root.current) {</span>
    <span class="s3">throw new </span><span class="s1">Error(</span>
      <span class="s2">&quot;Cannot commit the same tree as before. This error is likely caused by &quot; </span><span class="s1">+</span>
        <span class="s2">&quot;a bug in React. Please file an issue.&quot;</span>
    <span class="s1">);</span>
  <span class="s1">} </span><span class="s0">// commitRoot never returns a continuation; it always finishes synchronously.</span>
  <span class="s0">// So we can clear these now to allow a new callback to be scheduled.</span>

  <span class="s1">root.callbackNode = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">root.callbackPriority = NoLane; </span><span class="s0">// Update the first and last pending times on this root. The new first</span>
  <span class="s0">// pending time is whatever is left on the root fiber.</span>

  <span class="s3">var </span><span class="s1">remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);</span>
  <span class="s1">markRootFinished(root, remainingLanes);</span>

  <span class="s3">if </span><span class="s1">(root === workInProgressRoot) {</span>
    <span class="s0">// We can reset these now that they are finished.</span>
    <span class="s1">workInProgressRoot = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">workInProgress = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">workInProgressRootRenderLanes = NoLanes;</span>
  <span class="s1">} </span><span class="s0">// If there are pending passive effects, schedule a callback to process them.</span>
  <span class="s0">// Do this as early as possible, so it is queued before anything else that</span>
  <span class="s0">// might get scheduled in the commit phase. (See #16714.)</span>
  <span class="s0">// TODO: Delete all other places that schedule the passive effect callback</span>
  <span class="s0">// They're redundant.</span>

  <span class="s3">if </span><span class="s1">(</span>
    <span class="s1">(finishedWork.subtreeFlags &amp; PassiveMask) !== NoFlags ||</span>
    <span class="s1">(finishedWork.flags &amp; PassiveMask) !== NoFlags</span>
  <span class="s1">) {</span>
    <span class="s3">if </span><span class="s1">(!rootDoesHavePassiveEffects) {</span>
      <span class="s1">rootDoesHavePassiveEffects = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s0">// to store it in pendingPassiveTransitions until they get processed</span>
      <span class="s0">// We need to pass this through as an argument to commitRoot</span>
      <span class="s0">// because workInProgressTransitions might have changed between</span>
      <span class="s0">// the previous render and commit if we throttle the commit</span>
      <span class="s0">// with setTimeout</span>

      <span class="s1">pendingPassiveTransitions = transitions;</span>
      <span class="s1">scheduleCallback$1(NormalPriority, </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s1">flushPassiveEffects(); </span><span class="s0">// This render triggered passive effects: release the root cache pool</span>
        <span class="s0">// *after* passive effects fire to avoid freeing a cache pool that may</span>
        <span class="s0">// be referenced by a node in the tree (HostRoot, Cache boundary etc)</span>

        <span class="s3">return null</span><span class="s1">;</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s0">// Check if there are any effects in the whole tree.</span>
  <span class="s0">// TODO: This is left over from the effect list implementation, where we had</span>
  <span class="s0">// to check for the existence of `firstEffect` to satisfy Flow. I think the</span>
  <span class="s0">// only other reason this optimization exists is because it affects profiling.</span>
  <span class="s0">// Reconsider whether this is necessary.</span>

  <span class="s3">var </span><span class="s1">subtreeHasEffects =</span>
    <span class="s1">(finishedWork.subtreeFlags &amp;</span>
      <span class="s1">(BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !==</span>
    <span class="s1">NoFlags;</span>
  <span class="s3">var </span><span class="s1">rootHasEffect =</span>
    <span class="s1">(finishedWork.flags &amp;</span>
      <span class="s1">(BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !==</span>
    <span class="s1">NoFlags;</span>

  <span class="s3">if </span><span class="s1">(subtreeHasEffects || rootHasEffect) {</span>
    <span class="s3">var </span><span class="s1">prevTransition = ReactCurrentBatchConfig$2.transition;</span>
    <span class="s1">ReactCurrentBatchConfig$2.transition = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">previousPriority = getCurrentUpdatePriority();</span>
    <span class="s1">setCurrentUpdatePriority(DiscreteEventPriority);</span>
    <span class="s3">var </span><span class="s1">prevExecutionContext = executionContext;</span>
    <span class="s1">executionContext |= CommitContext; </span><span class="s0">// Reset this to null before calling lifecycles</span>

    <span class="s1">ReactCurrentOwner$2.current = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// The commit phase is broken into several sub-phases. We do a separate pass</span>
    <span class="s0">// of the effect list for each phase: all mutation effects come before all</span>
    <span class="s0">// layout effects, and so on.</span>
    <span class="s0">// The first phase a &quot;before mutation&quot; phase. We use this phase to read the</span>
    <span class="s0">// state of the host tree right before we mutate it. This is where</span>
    <span class="s0">// getSnapshotBeforeUpdate is called.</span>

    <span class="s3">var </span><span class="s1">shouldFireAfterActiveInstanceBlur = commitBeforeMutationEffects(</span>
      <span class="s1">root,</span>
      <span class="s1">finishedWork</span>
    <span class="s1">);</span>

    <span class="s1">{</span>
      <span class="s0">// Mark the current commit time to be shared by all Profilers in this</span>
      <span class="s0">// batch. This enables them to be grouped later.</span>
      <span class="s1">recordCommitTime();</span>
    <span class="s1">}</span>

    <span class="s1">commitMutationEffects(root, finishedWork, lanes);</span>

    <span class="s1">resetAfterCommit(root.containerInfo); </span><span class="s0">// The work-in-progress tree is now the current tree. This must come after</span>
    <span class="s0">// the mutation phase, so that the previous tree is still current during</span>
    <span class="s0">// componentWillUnmount, but before the layout phase, so that the finished</span>
    <span class="s0">// work is current during componentDidMount/Update.</span>

    <span class="s1">root.current = finishedWork; </span><span class="s0">// The next phase is the layout phase, where we call effects that read</span>

    <span class="s1">commitLayoutEffects(finishedWork, root, lanes);</span>
    <span class="s0">// opportunity to paint.</span>

    <span class="s1">requestPaint();</span>
    <span class="s1">executionContext = prevExecutionContext; </span><span class="s0">// Reset the priority to the previous non-sync value.</span>

    <span class="s1">setCurrentUpdatePriority(previousPriority);</span>
    <span class="s1">ReactCurrentBatchConfig$2.transition = prevTransition;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s0">// No effects.</span>
    <span class="s1">root.current = finishedWork; </span><span class="s0">// Measure these anyway so the flamegraph explicitly shows that there were</span>
    <span class="s0">// no effects.</span>
    <span class="s0">// TODO: Maybe there's a better way to report this.</span>

    <span class="s1">{</span>
      <span class="s1">recordCommitTime();</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(rootDoesHavePassiveEffects) {</span>
    <span class="s0">// This commit has passive effects. Stash a reference to them. But don't</span>
    <span class="s0">// schedule a callback until after flushing layout work.</span>
    <span class="s1">rootDoesHavePassiveEffects = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">rootWithPendingPassiveEffects = root;</span>
    <span class="s1">pendingPassiveEffectsLanes = lanes;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">{</span>
      <span class="s1">nestedPassiveUpdateCount = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s1">rootWithPassiveNestedUpdates = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s0">// Read this again, since an effect might have updated it</span>

  <span class="s1">remainingLanes = root.pendingLanes; </span><span class="s0">// Check if there's remaining work on this root</span>
  <span class="s0">// TODO: This is part of the `componentDidCatch` implementation. Its purpose</span>
  <span class="s0">// is to detect whether something might have called setState inside</span>
  <span class="s0">// `componentDidCatch`. The mechanism is known to be flawed because `setState`</span>
  <span class="s0">// inside `componentDidCatch` is itself flawed  that's why we recommend</span>
  <span class="s0">// `getDerivedStateFromError` instead. However, it could be improved by</span>
  <span class="s0">// checking if remainingLanes includes Sync work, instead of whether there's</span>
  <span class="s0">// any work remaining at all (which would also include stuff like Suspense</span>
  <span class="s0">// retries or transitions). It's been like this for a while, though, so fixing</span>
  <span class="s0">// it probably isn't that urgent.</span>

  <span class="s3">if </span><span class="s1">(remainingLanes === NoLanes) {</span>
    <span class="s0">// If there's no remaining work, we can clear the set of already failed</span>
    <span class="s0">// error boundaries.</span>
    <span class="s1">legacyErrorBoundariesThatAlreadyFailed = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s1">onCommitRoot(finishedWork.stateNode, renderPriorityLevel);</span>

  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(isDevToolsPresent) {</span>
      <span class="s1">root.memoizedUpdaters.clear();</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">// additional work on this root is scheduled.</span>

  <span class="s1">ensureRootIsScheduled(root, now());</span>

  <span class="s3">if </span><span class="s1">(recoverableErrors !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s0">// There were errors during this render, but recovered from them without</span>
    <span class="s0">// needing to surface it to the UI. We log them here.</span>
    <span class="s3">var </span><span class="s1">onRecoverableError = root.onRecoverableError;</span>

    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; recoverableErrors.length; i++) {</span>
      <span class="s3">var </span><span class="s1">recoverableError = recoverableErrors[i];</span>
      <span class="s3">var </span><span class="s1">componentStack = recoverableError.stack;</span>
      <span class="s3">var </span><span class="s1">digest = recoverableError.digest;</span>
      <span class="s1">onRecoverableError(recoverableError.value, {</span>
        <span class="s1">componentStack: componentStack,</span>
        <span class="s1">digest: digest</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(hasUncaughtError) {</span>
    <span class="s1">hasUncaughtError = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">error$1 = firstUncaughtError;</span>
    <span class="s1">firstUncaughtError = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">throw </span><span class="s1">error$1;</span>
  <span class="s1">} </span><span class="s0">// If the passive effects are the result of a discrete render, flush them</span>
  <span class="s0">// synchronously at the end of the current task so that the result is</span>
  <span class="s0">// immediately observable. Otherwise, we assume that they are not</span>
  <span class="s0">// order-dependent and do not need to be observed by external systems, so we</span>
  <span class="s0">// can wait until after paint.</span>
  <span class="s0">// TODO: We can optimize this by not scheduling the callback earlier. Since we</span>
  <span class="s0">// currently schedule the callback in multiple places, will wait until those</span>
  <span class="s0">// are consolidated.</span>

  <span class="s3">if </span><span class="s1">(</span>
    <span class="s1">includesSomeLane(pendingPassiveEffectsLanes, SyncLane) &amp;&amp;</span>
    <span class="s1">root.tag !== LegacyRoot</span>
  <span class="s1">) {</span>
    <span class="s1">flushPassiveEffects();</span>
  <span class="s1">} </span><span class="s0">// Read this again, since a passive effect might have updated it</span>

  <span class="s1">remainingLanes = root.pendingLanes;</span>

  <span class="s3">if </span><span class="s1">(includesSomeLane(remainingLanes, SyncLane)) {</span>
    <span class="s1">{</span>
      <span class="s1">markNestedUpdateScheduled();</span>
    <span class="s1">} </span><span class="s0">// Count the number of times the root synchronously re-renders without</span>
    <span class="s0">// finishing. If there are too many, it indicates an infinite update loop.</span>

    <span class="s3">if </span><span class="s1">(root === rootWithNestedUpdates) {</span>
      <span class="s1">nestedUpdateCount++;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">nestedUpdateCount = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s1">rootWithNestedUpdates = root;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">nestedUpdateCount = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s0">// If layout work was scheduled, flush it now.</span>

  <span class="s1">flushSyncCallbacks();</span>

  <span class="s3">return null</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">flushPassiveEffects() {</span>
  <span class="s0">// Returns whether passive effects were flushed.</span>
  <span class="s0">// TODO: Combine this check with the one in flushPassiveEFfectsImpl. We should</span>
  <span class="s0">// probably just combine the two functions. I believe they were only separate</span>
  <span class="s0">// in the first place because we used to wrap it with</span>
  <span class="s0">// `Scheduler.runWithPriority`, which accepts a function. But now we track the</span>
  <span class="s0">// priority within React itself, so we can mutate the variable directly.</span>
  <span class="s3">if </span><span class="s1">(rootWithPendingPassiveEffects !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes);</span>
    <span class="s3">var </span><span class="s1">priority = lowerEventPriority(DefaultEventPriority, renderPriority);</span>
    <span class="s3">var </span><span class="s1">prevTransition = ReactCurrentBatchConfig$2.transition;</span>
    <span class="s3">var </span><span class="s1">previousPriority = getCurrentUpdatePriority();</span>

    <span class="s3">try </span><span class="s1">{</span>
      <span class="s1">ReactCurrentBatchConfig$2.transition = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">setCurrentUpdatePriority(priority);</span>
      <span class="s3">return </span><span class="s1">flushPassiveEffectsImpl();</span>
    <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
      <span class="s1">setCurrentUpdatePriority(previousPriority);</span>
      <span class="s1">ReactCurrentBatchConfig$2.transition = prevTransition; </span><span class="s0">// Once passive effects have run for the tree - giving components a</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">return false</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">enqueuePendingPassiveProfilerEffect(fiber) {</span>
  <span class="s1">{</span>
    <span class="s1">pendingPassiveProfilerEffects.push(fiber);</span>

    <span class="s3">if </span><span class="s1">(!rootDoesHavePassiveEffects) {</span>
      <span class="s1">rootDoesHavePassiveEffects = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">scheduleCallback$1(NormalPriority, </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s1">flushPassiveEffects();</span>
        <span class="s3">return null</span><span class="s1">;</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">flushPassiveEffectsImpl() {</span>
  <span class="s3">if </span><span class="s1">(rootWithPendingPassiveEffects === </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">return false</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s0">// Cache and clear the transitions flag</span>

  <span class="s3">var </span><span class="s1">transitions = pendingPassiveTransitions;</span>
  <span class="s1">pendingPassiveTransitions = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">root = rootWithPendingPassiveEffects;</span>
  <span class="s3">var </span><span class="s1">lanes = pendingPassiveEffectsLanes;</span>
  <span class="s1">rootWithPendingPassiveEffects = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// TODO: This is sometimes out of sync with rootWithPendingPassiveEffects.</span>
  <span class="s0">// Figure out why and fix it. It's not causing any known issues (probably</span>
  <span class="s0">// because it's only used for profiling), but it's a refactor hazard.</span>

  <span class="s1">pendingPassiveEffectsLanes = NoLanes;</span>

  <span class="s3">if </span><span class="s1">((executionContext &amp; (RenderContext | CommitContext)) !== NoContext) {</span>
    <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Cannot flush passive effects while already rendering.&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s1">{</span>
    <span class="s1">isFlushingPassiveEffects = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">didScheduleUpdateDuringPassiveEffects = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">prevExecutionContext = executionContext;</span>
  <span class="s1">executionContext |= CommitContext;</span>
  <span class="s1">commitPassiveUnmountEffects(root.current);</span>
  <span class="s1">commitPassiveMountEffects(root, root.current, lanes, transitions); </span><span class="s0">// TODO: Move to commitPassiveMountEffects</span>

  <span class="s1">{</span>
    <span class="s3">var </span><span class="s1">profilerEffects = pendingPassiveProfilerEffects;</span>
    <span class="s1">pendingPassiveProfilerEffects = [];</span>

    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; profilerEffects.length; i++) {</span>
      <span class="s3">var </span><span class="s1">_fiber = profilerEffects[i];</span>
      <span class="s1">commitPassiveEffectDurations(root, _fiber);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">executionContext = prevExecutionContext;</span>
  <span class="s1">flushSyncCallbacks();</span>

  <span class="s1">{</span>
    <span class="s0">// If additional passive effects were scheduled, increment a counter. If this</span>
    <span class="s0">// exceeds the limit, we'll fire a warning.</span>
    <span class="s3">if </span><span class="s1">(didScheduleUpdateDuringPassiveEffects) {</span>
      <span class="s3">if </span><span class="s1">(root === rootWithPassiveNestedUpdates) {</span>
        <span class="s1">nestedPassiveUpdateCount++;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">nestedPassiveUpdateCount = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">rootWithPassiveNestedUpdates = root;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">nestedPassiveUpdateCount = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">isFlushingPassiveEffects = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">didScheduleUpdateDuringPassiveEffects = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s0">// TODO: Move to commitPassiveMountEffects</span>

  <span class="s1">onPostCommitRoot(root);</span>

  <span class="s1">{</span>
    <span class="s3">var </span><span class="s1">stateNode = root.current.stateNode;</span>
    <span class="s1">stateNode.effectDuration = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">stateNode.passiveEffectDuration = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">return true</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">isAlreadyFailedLegacyErrorBoundary(instance) {</span>
  <span class="s3">return </span><span class="s1">(</span>
    <span class="s1">legacyErrorBoundariesThatAlreadyFailed !== </span><span class="s3">null </span><span class="s1">&amp;&amp;</span>
    <span class="s1">legacyErrorBoundariesThatAlreadyFailed.has(instance)</span>
  <span class="s1">);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">markLegacyErrorBoundaryAsFailed(instance) {</span>
  <span class="s3">if </span><span class="s1">(legacyErrorBoundariesThatAlreadyFailed === </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s1">legacyErrorBoundariesThatAlreadyFailed = </span><span class="s3">new </span><span class="s1">Set([instance]);</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">legacyErrorBoundariesThatAlreadyFailed.add(instance);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">prepareToThrowUncaughtError(error) {</span>
  <span class="s3">if </span><span class="s1">(!hasUncaughtError) {</span>
    <span class="s1">hasUncaughtError = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">firstUncaughtError = error;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">onUncaughtError = prepareToThrowUncaughtError;</span>

<span class="s3">function </span><span class="s1">captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {</span>
  <span class="s3">var </span><span class="s1">errorInfo = createCapturedValueAtFiber(error, sourceFiber);</span>
  <span class="s3">var </span><span class="s1">update = createRootErrorUpdate(rootFiber, errorInfo, SyncLane);</span>
  <span class="s3">var </span><span class="s1">root = enqueueUpdate(rootFiber, update, SyncLane);</span>
  <span class="s3">var </span><span class="s1">eventTime = requestEventTime();</span>

  <span class="s3">if </span><span class="s1">(root !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s1">markRootUpdated(root, SyncLane, eventTime);</span>
    <span class="s1">ensureRootIsScheduled(root, eventTime);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error$1) {</span>
  <span class="s1">{</span>
    <span class="s1">reportUncaughtErrorInDEV(error$1);</span>
    <span class="s1">setIsRunningInsertionEffect(</span><span class="s3">false</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(sourceFiber.tag === HostRoot) {</span>
    <span class="s0">// Error was thrown at the root. There is no parent, so the root</span>
    <span class="s0">// itself should capture it.</span>
    <span class="s1">captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error$1);</span>
    <span class="s3">return</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">fiber = </span><span class="s3">null</span><span class="s1">;</span>

  <span class="s1">{</span>
    <span class="s1">fiber = sourceFiber.</span><span class="s3">return</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">while </span><span class="s1">(fiber !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">if </span><span class="s1">(fiber.tag === HostRoot) {</span>
      <span class="s1">captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error$1);</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(fiber.tag === ClassComponent) {</span>
      <span class="s3">var </span><span class="s1">ctor = fiber.type;</span>
      <span class="s3">var </span><span class="s1">instance = fiber.stateNode;</span>

      <span class="s3">if </span><span class="s1">(</span>
        <span class="s3">typeof </span><span class="s1">ctor.getDerivedStateFromError === </span><span class="s2">&quot;function&quot; </span><span class="s1">||</span>
        <span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.componentDidCatch === </span><span class="s2">&quot;function&quot; </span><span class="s1">&amp;&amp;</span>
          <span class="s1">!isAlreadyFailedLegacyErrorBoundary(instance))</span>
      <span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">errorInfo = createCapturedValueAtFiber(error$1, sourceFiber);</span>
        <span class="s3">var </span><span class="s1">update = createClassErrorUpdate(fiber, errorInfo, SyncLane);</span>
        <span class="s3">var </span><span class="s1">root = enqueueUpdate(fiber, update, SyncLane);</span>
        <span class="s3">var </span><span class="s1">eventTime = requestEventTime();</span>

        <span class="s3">if </span><span class="s1">(root !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">markRootUpdated(root, SyncLane, eventTime);</span>
          <span class="s1">ensureRootIsScheduled(root, eventTime);</span>
        <span class="s1">}</span>

        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">fiber = fiber.</span><span class="s3">return</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s1">{</span>
    <span class="s0">// TODO: Until we re-land skipUnmountedBoundaries (see #20147), this warning</span>
    <span class="s0">// will fire for errors that are thrown by destroy functions inside deleted</span>
    <span class="s0">// trees. What it should instead do is propagate the error to the parent of</span>
    <span class="s0">// the deleted tree. In the meantime, do not add this warning to the</span>
    <span class="s0">// allowlist; this is only for our internal use.</span>
    <span class="s1">error(</span>
      <span class="s2">&quot;Internal React error: Attempted to capture a commit phase error &quot; </span><span class="s1">+</span>
        <span class="s2">&quot;inside a detached tree. This indicates a bug in React. Likely &quot; </span><span class="s1">+</span>
        <span class="s2">&quot;causes include deleting the same fiber more than once, committing an &quot; </span><span class="s1">+</span>
        <span class="s2">&quot;already-finished tree, or an inconsistent return pointer.</span><span class="s5">\n\n</span><span class="s2">&quot; </span><span class="s1">+</span>
        <span class="s2">&quot;Error message:</span><span class="s5">\n\n</span><span class="s2">%s&quot;</span><span class="s1">,</span>
      <span class="s1">error$1</span>
    <span class="s1">);</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">pingSuspendedRoot(root, wakeable, pingedLanes) {</span>
  <span class="s3">var </span><span class="s1">pingCache = root.pingCache;</span>

  <span class="s3">if </span><span class="s1">(pingCache !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s0">// The wakeable resolved, so we no longer need to memoize, because it will</span>
    <span class="s0">// never be thrown again.</span>
    <span class="s1">pingCache.</span><span class="s3">delete</span><span class="s1">(wakeable);</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">eventTime = requestEventTime();</span>
  <span class="s1">markRootPinged(root, pingedLanes);</span>
  <span class="s1">warnIfSuspenseResolutionNotWrappedWithActDEV(root);</span>

  <span class="s3">if </span><span class="s1">(</span>
    <span class="s1">workInProgressRoot === root &amp;&amp;</span>
    <span class="s1">isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)</span>
  <span class="s1">) {</span>
    <span class="s0">// Received a ping at the same priority level at which we're currently</span>
    <span class="s0">// rendering. We might want to restart this render. This should mirror</span>
    <span class="s0">// the logic of whether or not a root suspends once it completes.</span>
    <span class="s0">// TODO: If we're rendering sync either due to Sync, Batched or expired,</span>
    <span class="s0">// we should probably never restart.</span>
    <span class="s0">// If we're suspended with delay, or if it's a retry, we'll always suspend</span>
    <span class="s0">// so we can always restart.</span>
    <span class="s3">if </span><span class="s1">(</span>
      <span class="s1">workInProgressRootExitStatus === RootSuspendedWithDelay ||</span>
      <span class="s1">(workInProgressRootExitStatus === RootSuspended &amp;&amp;</span>
        <span class="s1">includesOnlyRetries(workInProgressRootRenderLanes) &amp;&amp;</span>
        <span class="s1">now() - globalMostRecentFallbackTime &lt; FALLBACK_THROTTLE_MS)</span>
    <span class="s1">) {</span>
      <span class="s0">// Restart from the root.</span>
      <span class="s1">prepareFreshStack(root, NoLanes);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s0">// Even though we can't restart right now, we might get an</span>
      <span class="s0">// opportunity later. So we mark this render as having a ping.</span>
      <span class="s1">workInProgressRootPingedLanes = mergeLanes(</span>
        <span class="s1">workInProgressRootPingedLanes,</span>
        <span class="s1">pingedLanes</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">ensureRootIsScheduled(root, eventTime);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">retryTimedOutBoundary(boundaryFiber, retryLane) {</span>
  <span class="s0">// The boundary fiber (a Suspense component or SuspenseList component)</span>
  <span class="s0">// previously was rendered in its fallback state. One of the promises that</span>
  <span class="s0">// suspended it has resolved, which means at least part of the tree was</span>
  <span class="s0">// likely unblocked. Try rendering again, at a new lanes.</span>
  <span class="s3">if </span><span class="s1">(retryLane === NoLane) {</span>
    <span class="s0">// TODO: Assign this to `suspenseState.retryLane`? to avoid</span>
    <span class="s0">// unnecessary entanglement?</span>
    <span class="s1">retryLane = requestRetryLane(boundaryFiber);</span>
  <span class="s1">} </span><span class="s0">// TODO: Special case idle priority?</span>

  <span class="s3">var </span><span class="s1">eventTime = requestEventTime();</span>
  <span class="s3">var </span><span class="s1">root = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);</span>

  <span class="s3">if </span><span class="s1">(root !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s1">markRootUpdated(root, retryLane, eventTime);</span>
    <span class="s1">ensureRootIsScheduled(root, eventTime);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">retryDehydratedSuspenseBoundary(boundaryFiber) {</span>
  <span class="s3">var </span><span class="s1">suspenseState = boundaryFiber.memoizedState;</span>
  <span class="s3">var </span><span class="s1">retryLane = NoLane;</span>

  <span class="s3">if </span><span class="s1">(suspenseState !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s1">retryLane = suspenseState.retryLane;</span>
  <span class="s1">}</span>

  <span class="s1">retryTimedOutBoundary(boundaryFiber, retryLane);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">resolveRetryWakeable(boundaryFiber, wakeable) {</span>
  <span class="s3">var </span><span class="s1">retryLane = NoLane; </span><span class="s0">// Default</span>

  <span class="s3">var </span><span class="s1">retryCache;</span>

  <span class="s3">switch </span><span class="s1">(boundaryFiber.tag) {</span>
    <span class="s3">case </span><span class="s1">SuspenseComponent:</span>
      <span class="s1">retryCache = boundaryFiber.stateNode;</span>
      <span class="s3">var </span><span class="s1">suspenseState = boundaryFiber.memoizedState;</span>

      <span class="s3">if </span><span class="s1">(suspenseState !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">retryLane = suspenseState.retryLane;</span>
      <span class="s1">}</span>

      <span class="s3">break</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s1">SuspenseListComponent:</span>
      <span class="s1">retryCache = boundaryFiber.stateNode;</span>
      <span class="s3">break</span><span class="s1">;</span>

    <span class="s3">default</span><span class="s1">:</span>
      <span class="s3">throw new </span><span class="s1">Error(</span>
        <span class="s2">&quot;Pinged unknown suspense boundary type. &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;This is probably a bug in React.&quot;</span>
      <span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(retryCache !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s0">// The wakeable resolved, so we no longer need to memoize, because it will</span>
    <span class="s0">// never be thrown again.</span>
    <span class="s1">retryCache.</span><span class="s3">delete</span><span class="s1">(wakeable);</span>
  <span class="s1">}</span>

  <span class="s1">retryTimedOutBoundary(boundaryFiber, retryLane);</span>
<span class="s1">} </span><span class="s0">// Computes the next Just Noticeable Difference (JND) boundary.</span>
<span class="s0">// The theory is that a person can't tell the difference between small differences in time.</span>
<span class="s0">// Therefore, if we wait a bit longer than necessary that won't translate to a noticeable</span>
<span class="s0">// difference in the experience. However, waiting for longer might mean that we can avoid</span>
<span class="s0">// showing an intermediate loading state. The longer we have already waited, the harder it</span>
<span class="s0">// is to tell small differences in time. Therefore, the longer we've already waited,</span>
<span class="s0">// the longer we can wait additionally. At some point we have to give up though.</span>
<span class="s0">// We pick a train model where the next boundary commits at a consistent schedule.</span>
<span class="s0">// These particular numbers are vague estimates. We expect to adjust them based on research.</span>

<span class="s3">function </span><span class="s1">jnd(timeElapsed) {</span>
  <span class="s3">return </span><span class="s1">timeElapsed &lt; </span><span class="s4">120</span>
    <span class="s1">? </span><span class="s4">120</span>
    <span class="s1">: timeElapsed &lt; </span><span class="s4">480</span>
    <span class="s1">? </span><span class="s4">480</span>
    <span class="s1">: timeElapsed &lt; </span><span class="s4">1080</span>
    <span class="s1">? </span><span class="s4">1080</span>
    <span class="s1">: timeElapsed &lt; </span><span class="s4">1920</span>
    <span class="s1">? </span><span class="s4">1920</span>
    <span class="s1">: timeElapsed &lt; </span><span class="s4">3000</span>
    <span class="s1">? </span><span class="s4">3000</span>
    <span class="s1">: timeElapsed &lt; </span><span class="s4">4320</span>
    <span class="s1">? </span><span class="s4">4320</span>
    <span class="s1">: ceil(timeElapsed / </span><span class="s4">1960</span><span class="s1">) * </span><span class="s4">1960</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">checkForNestedUpdates() {</span>
  <span class="s3">if </span><span class="s1">(nestedUpdateCount &gt; NESTED_UPDATE_LIMIT) {</span>
    <span class="s1">nestedUpdateCount = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">rootWithNestedUpdates = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">throw new </span><span class="s1">Error(</span>
      <span class="s2">&quot;Maximum update depth exceeded. This can happen when a component &quot; </span><span class="s1">+</span>
        <span class="s2">&quot;repeatedly calls setState inside componentWillUpdate or &quot; </span><span class="s1">+</span>
        <span class="s2">&quot;componentDidUpdate. React limits the number of nested updates to &quot; </span><span class="s1">+</span>
        <span class="s2">&quot;prevent infinite loops.&quot;</span>
    <span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(nestedPassiveUpdateCount &gt; NESTED_PASSIVE_UPDATE_LIMIT) {</span>
      <span class="s1">nestedPassiveUpdateCount = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s1">rootWithPassiveNestedUpdates = </span><span class="s3">null</span><span class="s1">;</span>

      <span class="s1">error(</span>
        <span class="s2">&quot;Maximum update depth exceeded. This can happen when a component &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;calls setState inside useEffect, but useEffect either doesn't &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;have a dependency array, or one of the dependencies changes on &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;every render.&quot;</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">flushRenderPhaseStrictModeWarningsInDEV() {</span>
  <span class="s1">{</span>
    <span class="s1">ReactStrictModeWarnings.flushLegacyContextWarning();</span>

    <span class="s1">{</span>
      <span class="s1">ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">didWarnStateUpdateForNotYetMountedComponent = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s3">function </span><span class="s1">warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {</span>
  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">((executionContext &amp; RenderContext) !== NoContext) {</span>
      <span class="s0">// We let the other warning about render phase updates deal with this one.</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(!(fiber.mode &amp; ConcurrentMode)) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">tag = fiber.tag;</span>

    <span class="s3">if </span><span class="s1">(</span>
      <span class="s1">tag !== IndeterminateComponent &amp;&amp;</span>
      <span class="s1">tag !== HostRoot &amp;&amp;</span>
      <span class="s1">tag !== ClassComponent &amp;&amp;</span>
      <span class="s1">tag !== FunctionComponent &amp;&amp;</span>
      <span class="s1">tag !== ForwardRef &amp;&amp;</span>
      <span class="s1">tag !== MemoComponent &amp;&amp;</span>
      <span class="s1">tag !== SimpleMemoComponent</span>
    <span class="s1">) {</span>
      <span class="s0">// Only warn for user-defined components, not internal ones like Suspense.</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s0">// We show the whole stack but dedupe on the top component's name because</span>
    <span class="s0">// the problematic code almost always lies inside that component.</span>

    <span class="s3">var </span><span class="s1">componentName = getComponentNameFromFiber(fiber) || </span><span class="s2">&quot;ReactComponent&quot;</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s1">(didWarnStateUpdateForNotYetMountedComponent !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">didWarnStateUpdateForNotYetMountedComponent.add(componentName);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">didWarnStateUpdateForNotYetMountedComponent = </span><span class="s3">new </span><span class="s1">Set([componentName]);</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">previousFiber = current;</span>

    <span class="s3">try </span><span class="s1">{</span>
      <span class="s1">setCurrentFiber(fiber);</span>

      <span class="s1">error(</span>
        <span class="s2">&quot;Can't perform a React state update on a component that hasn't mounted yet. &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;This indicates that you have a side-effect in your render function that &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;asynchronously later calls tries to update the component. Move this work to &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;useEffect instead.&quot;</span>
      <span class="s1">);</span>
    <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(previousFiber) {</span>
        <span class="s1">setCurrentFiber(fiber);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">resetCurrentFiber();</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">var </span><span class="s1">beginWork$1;</span>

<span class="s1">{</span>
  <span class="s3">var </span><span class="s1">dummyFiber = </span><span class="s3">null</span><span class="s1">;</span>

  <span class="s1">beginWork$1 = </span><span class="s3">function</span><span class="s1">(current, unitOfWork, lanes) {</span>
    <span class="s0">// If a component throws an error, we replay it again in a synchronously</span>
    <span class="s0">// dispatched event, so that the debugger will treat it as an uncaught</span>
    <span class="s0">// error See ReactErrorUtils for more information.</span>
    <span class="s0">// Before entering the begin phase, copy the work-in-progress onto a dummy</span>
    <span class="s0">// fiber. If beginWork throws, we'll use this to reset the state.</span>
    <span class="s3">var </span><span class="s1">originalWorkInProgressCopy = assignFiberPropertiesInDEV(</span>
      <span class="s1">dummyFiber,</span>
      <span class="s1">unitOfWork</span>
    <span class="s1">);</span>

    <span class="s3">try </span><span class="s1">{</span>
      <span class="s3">return </span><span class="s1">beginWork(current, unitOfWork, lanes);</span>
    <span class="s1">} </span><span class="s3">catch </span><span class="s1">(originalError) {</span>
      <span class="s3">if </span><span class="s1">(</span>
        <span class="s1">didSuspendOrErrorWhileHydratingDEV() ||</span>
        <span class="s1">(originalError !== </span><span class="s3">null </span><span class="s1">&amp;&amp;</span>
          <span class="s3">typeof </span><span class="s1">originalError === </span><span class="s2">&quot;object&quot; </span><span class="s1">&amp;&amp;</span>
          <span class="s3">typeof </span><span class="s1">originalError.then === </span><span class="s2">&quot;function&quot;</span><span class="s1">)</span>
      <span class="s1">) {</span>
        <span class="s0">// Don't replay promises.</span>
        <span class="s0">// Don't replay errors if we are hydrating and have already suspended or handled an error</span>
        <span class="s3">throw </span><span class="s1">originalError;</span>
      <span class="s1">} </span><span class="s0">// Keep this code in sync with handleError; any changes here must have</span>
      <span class="s0">// corresponding changes there.</span>

      <span class="s1">resetContextDependencies();</span>
      <span class="s1">resetHooksAfterThrow(); </span><span class="s0">// Don't reset current debug fiber, since we're about to work on the</span>
      <span class="s0">// same fiber again.</span>
      <span class="s0">// Unwind the failed stack frame</span>

      <span class="s1">unwindInterruptedWork(current, unitOfWork); </span><span class="s0">// Restore the original properties of the fiber.</span>

      <span class="s1">assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);</span>

      <span class="s3">if </span><span class="s1">(unitOfWork.mode &amp; ProfileMode) {</span>
        <span class="s0">// Reset the profiler timer.</span>
        <span class="s1">startProfilerTimer(unitOfWork);</span>
      <span class="s1">} </span><span class="s0">// Run beginWork again.</span>

      <span class="s1">invokeGuardedCallback(</span><span class="s3">null</span><span class="s1">, beginWork, </span><span class="s3">null</span><span class="s1">, current, unitOfWork, lanes);</span>

      <span class="s3">if </span><span class="s1">(hasCaughtError()) {</span>
        <span class="s3">var </span><span class="s1">replayError = clearCaughtError();</span>

        <span class="s3">if </span><span class="s1">(</span>
          <span class="s3">typeof </span><span class="s1">replayError === </span><span class="s2">&quot;object&quot; </span><span class="s1">&amp;&amp;</span>
          <span class="s1">replayError !== </span><span class="s3">null </span><span class="s1">&amp;&amp;</span>
          <span class="s1">replayError._suppressLogging &amp;&amp;</span>
          <span class="s3">typeof </span><span class="s1">originalError === </span><span class="s2">&quot;object&quot; </span><span class="s1">&amp;&amp;</span>
          <span class="s1">originalError !== </span><span class="s3">null </span><span class="s1">&amp;&amp;</span>
          <span class="s1">!originalError._suppressLogging</span>
        <span class="s1">) {</span>
          <span class="s0">// If suppressed, let the flag carry over to the original error which is the one we'll rethrow.</span>
          <span class="s1">originalError._suppressLogging = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s0">// We always throw the original error in case the second render pass is not idempotent.</span>
      <span class="s0">// This can happen if a memoized function or CommonJS module doesn't throw after first invocation.</span>

      <span class="s3">throw </span><span class="s1">originalError;</span>
    <span class="s1">}</span>
  <span class="s1">};</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">didWarnAboutUpdateInRender = </span><span class="s3">false</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">didWarnAboutUpdateInRenderForAnotherComponent;</span>

<span class="s1">{</span>
  <span class="s1">didWarnAboutUpdateInRenderForAnotherComponent = </span><span class="s3">new </span><span class="s1">Set();</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">warnAboutRenderPhaseUpdatesInDEV(fiber) {</span>
  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(isRendering &amp;&amp; !getIsUpdatingOpaqueValueInRenderPhaseInDEV()) {</span>
      <span class="s3">switch </span><span class="s1">(fiber.tag) {</span>
        <span class="s3">case </span><span class="s1">FunctionComponent:</span>
        <span class="s3">case </span><span class="s1">ForwardRef:</span>
        <span class="s3">case </span><span class="s1">SimpleMemoComponent: {</span>
          <span class="s3">var </span><span class="s1">renderingComponentName =</span>
            <span class="s1">(workInProgress &amp;&amp; getComponentNameFromFiber(workInProgress)) ||</span>
            <span class="s2">&quot;Unknown&quot;</span><span class="s1">; </span><span class="s0">// Dedupe by the rendering component because it's the one that needs to be fixed.</span>

          <span class="s3">var </span><span class="s1">dedupeKey = renderingComponentName;</span>

          <span class="s3">if </span><span class="s1">(!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {</span>
            <span class="s1">didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);</span>
            <span class="s3">var </span><span class="s1">setStateComponentName =</span>
              <span class="s1">getComponentNameFromFiber(fiber) || </span><span class="s2">&quot;Unknown&quot;</span><span class="s1">;</span>

            <span class="s1">error(</span>
              <span class="s2">&quot;Cannot update a component (`%s`) while rendering a &quot; </span><span class="s1">+</span>
                <span class="s2">&quot;different component (`%s`). To locate the bad setState() call inside `%s`, &quot; </span><span class="s1">+</span>
                <span class="s2">&quot;follow the stack trace as described in https://reactjs.org/link/setstate-in-render&quot;</span><span class="s1">,</span>
              <span class="s1">setStateComponentName,</span>
              <span class="s1">renderingComponentName,</span>
              <span class="s1">renderingComponentName</span>
            <span class="s1">);</span>
          <span class="s1">}</span>

          <span class="s3">break</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">case </span><span class="s1">ClassComponent: {</span>
          <span class="s3">if </span><span class="s1">(!didWarnAboutUpdateInRender) {</span>
            <span class="s1">error(</span>
              <span class="s2">&quot;Cannot update during an existing state transition (such as &quot; </span><span class="s1">+</span>
                <span class="s2">&quot;within `render`). Render methods should be a pure &quot; </span><span class="s1">+</span>
                <span class="s2">&quot;function of props and state.&quot;</span>
            <span class="s1">);</span>

            <span class="s1">didWarnAboutUpdateInRender = </span><span class="s3">true</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s3">break</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">restorePendingUpdaters(root, lanes) {</span>
  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(isDevToolsPresent) {</span>
      <span class="s3">var </span><span class="s1">memoizedUpdaters = root.memoizedUpdaters;</span>
      <span class="s1">memoizedUpdaters.forEach(</span><span class="s3">function</span><span class="s1">(schedulingFiber) {</span>
        <span class="s1">addFiberToLanesMap(root, schedulingFiber, lanes);</span>
      <span class="s1">}); </span><span class="s0">// This function intentionally does not clear memoized updaters.</span>
      <span class="s0">// Those may still be relevant to the current commit</span>
      <span class="s0">// and a future one (e.g. Suspense).</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">var </span><span class="s1">fakeActCallbackNode = {};</span>

<span class="s3">function </span><span class="s1">scheduleCallback$1(priorityLevel, callback) {</span>
  <span class="s1">{</span>
    <span class="s0">// If we're currently inside an `act` scope, bypass Scheduler and push to</span>
    <span class="s0">// the `act` queue instead.</span>
    <span class="s3">var </span><span class="s1">actQueue = ReactCurrentActQueue$1.current;</span>

    <span class="s3">if </span><span class="s1">(actQueue !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">actQueue.push(callback);</span>
      <span class="s3">return </span><span class="s1">fakeActCallbackNode;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">return </span><span class="s1">scheduleCallback(priorityLevel, callback);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">cancelCallback$1(callbackNode) {</span>
  <span class="s3">if </span><span class="s1">(callbackNode === fakeActCallbackNode) {</span>
    <span class="s3">return</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s0">// In production, always call Scheduler. This function will be stripped out.</span>

  <span class="s3">return </span><span class="s1">cancelCallback(callbackNode);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">shouldForceFlushFallbacksInDEV() {</span>
  <span class="s0">// Never force flush in production. This function should get stripped out.</span>
  <span class="s3">return </span><span class="s1">ReactCurrentActQueue$1.current !== </span><span class="s3">null</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">warnIfUpdatesNotWrappedWithActDEV(fiber) {</span>
  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(fiber.mode &amp; ConcurrentMode) {</span>
      <span class="s3">if </span><span class="s1">(!isConcurrentActEnvironment()) {</span>
        <span class="s0">// Not in an act environment. No need to warn.</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s0">// Legacy mode has additional cases where we suppress a warning.</span>
      <span class="s3">if </span><span class="s1">(!isLegacyActEnvironment()) {</span>
        <span class="s0">// Not in an act environment. No need to warn.</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(executionContext !== NoContext) {</span>
        <span class="s0">// Legacy mode doesn't warn if the update is batched, i.e.</span>
        <span class="s0">// batchedUpdates or flushSync.</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(</span>
        <span class="s1">fiber.tag !== FunctionComponent &amp;&amp;</span>
        <span class="s1">fiber.tag !== ForwardRef &amp;&amp;</span>
        <span class="s1">fiber.tag !== SimpleMemoComponent</span>
      <span class="s1">) {</span>
        <span class="s0">// For backwards compatibility with pre-hooks code, legacy mode only</span>
        <span class="s0">// warns for updates that originate from a hook.</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(ReactCurrentActQueue$1.current === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">previousFiber = current;</span>

      <span class="s3">try </span><span class="s1">{</span>
        <span class="s1">setCurrentFiber(fiber);</span>

        <span class="s1">error(</span>
          <span class="s2">&quot;An update to %s inside a test was not wrapped in act(...).</span><span class="s5">\n\n</span><span class="s2">&quot; </span><span class="s1">+</span>
            <span class="s2">&quot;When testing, code that causes React state updates should be &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;wrapped into act(...):</span><span class="s5">\n\n</span><span class="s2">&quot; </span><span class="s1">+</span>
            <span class="s2">&quot;act(() =&gt; {</span><span class="s5">\n</span><span class="s2">&quot; </span><span class="s1">+</span>
            <span class="s2">&quot;  /* fire events that update state */</span><span class="s5">\n</span><span class="s2">&quot; </span><span class="s1">+</span>
            <span class="s2">&quot;});</span><span class="s5">\n</span><span class="s2">&quot; </span><span class="s1">+</span>
            <span class="s2">&quot;/* assert on the output */</span><span class="s5">\n\n</span><span class="s2">&quot; </span><span class="s1">+</span>
            <span class="s2">&quot;This ensures that you're testing the behavior the user would see &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;in the browser.&quot; </span><span class="s1">+</span>
            <span class="s2">&quot; Learn more at https://reactjs.org/link/wrap-tests-with-act&quot;</span><span class="s1">,</span>
          <span class="s1">getComponentNameFromFiber(fiber)</span>
        <span class="s1">);</span>
      <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
        <span class="s3">if </span><span class="s1">(previousFiber) {</span>
          <span class="s1">setCurrentFiber(fiber);</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s1">resetCurrentFiber();</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">warnIfSuspenseResolutionNotWrappedWithActDEV(root) {</span>
  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(</span>
      <span class="s1">root.tag !== LegacyRoot &amp;&amp;</span>
      <span class="s1">isConcurrentActEnvironment() &amp;&amp;</span>
      <span class="s1">ReactCurrentActQueue$1.current === </span><span class="s3">null</span>
    <span class="s1">) {</span>
      <span class="s1">error(</span>
        <span class="s2">&quot;A suspended resource finished loading inside a test, but the event &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;was not wrapped in act(...).</span><span class="s5">\n\n</span><span class="s2">&quot; </span><span class="s1">+</span>
          <span class="s2">&quot;When testing, code that resolves suspended data should be wrapped &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;into act(...):</span><span class="s5">\n\n</span><span class="s2">&quot; </span><span class="s1">+</span>
          <span class="s2">&quot;act(() =&gt; {</span><span class="s5">\n</span><span class="s2">&quot; </span><span class="s1">+</span>
          <span class="s2">&quot;  /* finish loading suspended data */</span><span class="s5">\n</span><span class="s2">&quot; </span><span class="s1">+</span>
          <span class="s2">&quot;});</span><span class="s5">\n</span><span class="s2">&quot; </span><span class="s1">+</span>
          <span class="s2">&quot;/* assert on the output */</span><span class="s5">\n\n</span><span class="s2">&quot; </span><span class="s1">+</span>
          <span class="s2">&quot;This ensures that you're testing the behavior the user would see &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;in the browser.&quot; </span><span class="s1">+</span>
          <span class="s2">&quot; Learn more at https://reactjs.org/link/wrap-tests-with-act&quot;</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">setIsRunningInsertionEffect(isRunning) {</span>
  <span class="s1">{</span>
    <span class="s1">isRunningInsertionEffect = isRunning;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">/* eslint-disable react-internal/prod-error-codes */</span>
<span class="s3">var </span><span class="s1">resolveFamily = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// $FlowFixMe Flow gets confused by a WeakSet feature check below.</span>

<span class="s3">var </span><span class="s1">failedBoundaries = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">setRefreshHandler = </span><span class="s3">function</span><span class="s1">(handler) {</span>
  <span class="s1">{</span>
    <span class="s1">resolveFamily = handler;</span>
  <span class="s1">}</span>
<span class="s1">};</span>
<span class="s3">function </span><span class="s1">resolveFunctionForHotReloading(type) {</span>
  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(resolveFamily === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// Hot reloading is disabled.</span>
      <span class="s3">return </span><span class="s1">type;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">family = resolveFamily(type);</span>

    <span class="s3">if </span><span class="s1">(family === undefined) {</span>
      <span class="s3">return </span><span class="s1">type;</span>
    <span class="s1">} </span><span class="s0">// Use the latest known implementation.</span>

    <span class="s3">return </span><span class="s1">family.current;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">resolveClassForHotReloading(type) {</span>
  <span class="s0">// No implementation differences.</span>
  <span class="s3">return </span><span class="s1">resolveFunctionForHotReloading(type);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">resolveForwardRefForHotReloading(type) {</span>
  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(resolveFamily === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// Hot reloading is disabled.</span>
      <span class="s3">return </span><span class="s1">type;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">family = resolveFamily(type);</span>

    <span class="s3">if </span><span class="s1">(family === undefined) {</span>
      <span class="s0">// Check if we're dealing with a real forwardRef. Don't want to crash early.</span>
      <span class="s3">if </span><span class="s1">(</span>
        <span class="s1">type !== </span><span class="s3">null </span><span class="s1">&amp;&amp;</span>
        <span class="s1">type !== undefined &amp;&amp;</span>
        <span class="s3">typeof </span><span class="s1">type.render === </span><span class="s2">&quot;function&quot;</span>
      <span class="s1">) {</span>
        <span class="s0">// ForwardRef is special because its resolved .type is an object,</span>
        <span class="s0">// but it's possible that we only have its inner render function in the map.</span>
        <span class="s0">// If that inner render function is different, we'll build a new forwardRef type.</span>
        <span class="s3">var </span><span class="s1">currentRender = resolveFunctionForHotReloading(type.render);</span>

        <span class="s3">if </span><span class="s1">(type.render !== currentRender) {</span>
          <span class="s3">var </span><span class="s1">syntheticType = {</span>
            <span class="s1">$$typeof: REACT_FORWARD_REF_TYPE,</span>
            <span class="s1">render: currentRender</span>
          <span class="s1">};</span>

          <span class="s3">if </span><span class="s1">(type.displayName !== undefined) {</span>
            <span class="s1">syntheticType.displayName = type.displayName;</span>
          <span class="s1">}</span>

          <span class="s3">return </span><span class="s1">syntheticType;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">return </span><span class="s1">type;</span>
    <span class="s1">} </span><span class="s0">// Use the latest known implementation.</span>

    <span class="s3">return </span><span class="s1">family.current;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">isCompatibleFamilyForHotReloading(fiber, element) {</span>
  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(resolveFamily === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// Hot reloading is disabled.</span>
      <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">prevType = fiber.elementType;</span>
    <span class="s3">var </span><span class="s1">nextType = element.type; </span><span class="s0">// If we got here, we know types aren't === equal.</span>

    <span class="s3">var </span><span class="s1">needsCompareFamilies = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">$$typeofNextType =</span>
      <span class="s3">typeof </span><span class="s1">nextType === </span><span class="s2">&quot;object&quot; </span><span class="s1">&amp;&amp; nextType !== </span><span class="s3">null</span>
        <span class="s1">? nextType.$$typeof</span>
        <span class="s1">: </span><span class="s3">null</span><span class="s1">;</span>

    <span class="s3">switch </span><span class="s1">(fiber.tag) {</span>
      <span class="s3">case </span><span class="s1">ClassComponent: {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">nextType === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
          <span class="s1">needsCompareFamilies = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">FunctionComponent: {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">nextType === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
          <span class="s1">needsCompareFamilies = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">($$typeofNextType === REACT_LAZY_TYPE) {</span>
          <span class="s0">// We don't know the inner type yet.</span>
          <span class="s0">// We're going to assume that the lazy inner type is stable,</span>
          <span class="s0">// and so it is sufficient to avoid reconciling it away.</span>
          <span class="s0">// We're not going to unwrap or actually use the new lazy type.</span>
          <span class="s1">needsCompareFamilies = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">ForwardRef: {</span>
        <span class="s3">if </span><span class="s1">($$typeofNextType === REACT_FORWARD_REF_TYPE) {</span>
          <span class="s1">needsCompareFamilies = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">($$typeofNextType === REACT_LAZY_TYPE) {</span>
          <span class="s1">needsCompareFamilies = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">MemoComponent:</span>
      <span class="s3">case </span><span class="s1">SimpleMemoComponent: {</span>
        <span class="s3">if </span><span class="s1">($$typeofNextType === REACT_MEMO_TYPE) {</span>
          <span class="s0">// TODO: if it was but can no longer be simple,</span>
          <span class="s0">// we shouldn't set this.</span>
          <span class="s1">needsCompareFamilies = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">($$typeofNextType === REACT_LAZY_TYPE) {</span>
          <span class="s1">needsCompareFamilies = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">default</span><span class="s1">:</span>
        <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s0">// Check if both types have a family and it's the same one.</span>

    <span class="s3">if </span><span class="s1">(needsCompareFamilies) {</span>
      <span class="s0">// Note: memo() and forwardRef() we'll compare outer rather than inner type.</span>
      <span class="s0">// This means both of them need to be registered to preserve state.</span>
      <span class="s0">// If we unwrapped and compared the inner types for wrappers instead,</span>
      <span class="s0">// then we would risk falsely saying two separate memo(Foo)</span>
      <span class="s0">// calls are equivalent because they wrap the same Foo function.</span>
      <span class="s3">var </span><span class="s1">prevFamily = resolveFamily(prevType);</span>

      <span class="s3">if </span><span class="s1">(prevFamily !== undefined &amp;&amp; prevFamily === resolveFamily(nextType)) {</span>
        <span class="s3">return true</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return false</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">markFailedErrorBoundaryForHotReloading(fiber) {</span>
  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(resolveFamily === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// Hot reloading is disabled.</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">WeakSet !== </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(failedBoundaries === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">failedBoundaries = </span><span class="s3">new </span><span class="s1">WeakSet();</span>
    <span class="s1">}</span>

    <span class="s1">failedBoundaries.add(fiber);</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">var </span><span class="s1">scheduleRefresh = </span><span class="s3">function</span><span class="s1">(root, update) {</span>
  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(resolveFamily === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// Hot reloading is disabled.</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">staleFamilies = update.staleFamilies,</span>
      <span class="s1">updatedFamilies = update.updatedFamilies;</span>
    <span class="s1">flushPassiveEffects();</span>
    <span class="s1">flushSync(</span><span class="s3">function</span><span class="s1">() {</span>
      <span class="s1">scheduleFibersWithFamiliesRecursively(</span>
        <span class="s1">root.current,</span>
        <span class="s1">updatedFamilies,</span>
        <span class="s1">staleFamilies</span>
      <span class="s1">);</span>
    <span class="s1">});</span>
  <span class="s1">}</span>
<span class="s1">};</span>
<span class="s3">var </span><span class="s1">scheduleRoot = </span><span class="s3">function</span><span class="s1">(root, element) {</span>
  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(root.context !== emptyContextObject) {</span>
      <span class="s0">// Super edge case: root has a legacy _renderSubtree context</span>
      <span class="s0">// but we don't know the parentComponent so we can't pass it.</span>
      <span class="s0">// Just ignore. We'll delete this with _renderSubtree code path later.</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">flushPassiveEffects();</span>
    <span class="s1">flushSync(</span><span class="s3">function</span><span class="s1">() {</span>
      <span class="s1">updateContainer(element, root, </span><span class="s3">null</span><span class="s1">, </span><span class="s3">null</span><span class="s1">);</span>
    <span class="s1">});</span>
  <span class="s1">}</span>
<span class="s1">};</span>

<span class="s3">function </span><span class="s1">scheduleFibersWithFamiliesRecursively(</span>
  <span class="s1">fiber,</span>
  <span class="s1">updatedFamilies,</span>
  <span class="s1">staleFamilies</span>
<span class="s1">) {</span>
  <span class="s1">{</span>
    <span class="s3">var </span><span class="s1">alternate = fiber.alternate,</span>
      <span class="s1">child = fiber.child,</span>
      <span class="s1">sibling = fiber.sibling,</span>
      <span class="s1">tag = fiber.tag,</span>
      <span class="s1">type = fiber.type;</span>
    <span class="s3">var </span><span class="s1">candidateType = </span><span class="s3">null</span><span class="s1">;</span>

    <span class="s3">switch </span><span class="s1">(tag) {</span>
      <span class="s3">case </span><span class="s1">FunctionComponent:</span>
      <span class="s3">case </span><span class="s1">SimpleMemoComponent:</span>
      <span class="s3">case </span><span class="s1">ClassComponent:</span>
        <span class="s1">candidateType = type;</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s1">ForwardRef:</span>
        <span class="s1">candidateType = type.render;</span>
        <span class="s3">break</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(resolveFamily === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Expected resolveFamily to be set during hot reload.&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">needsRender = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">needsRemount = </span><span class="s3">false</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s1">(candidateType !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">family = resolveFamily(candidateType);</span>

      <span class="s3">if </span><span class="s1">(family !== undefined) {</span>
        <span class="s3">if </span><span class="s1">(staleFamilies.has(family)) {</span>
          <span class="s1">needsRemount = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(updatedFamilies.has(family)) {</span>
          <span class="s3">if </span><span class="s1">(tag === ClassComponent) {</span>
            <span class="s1">needsRemount = </span><span class="s3">true</span><span class="s1">;</span>
          <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">needsRender = </span><span class="s3">true</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(failedBoundaries !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(</span>
        <span class="s1">failedBoundaries.has(fiber) ||</span>
        <span class="s1">(alternate !== </span><span class="s3">null </span><span class="s1">&amp;&amp; failedBoundaries.has(alternate))</span>
      <span class="s1">) {</span>
        <span class="s1">needsRemount = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(needsRemount) {</span>
      <span class="s1">fiber._debugNeedsRemount = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(needsRemount || needsRender) {</span>
      <span class="s3">var </span><span class="s1">_root = enqueueConcurrentRenderForLane(fiber, SyncLane);</span>

      <span class="s3">if </span><span class="s1">(_root !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">scheduleUpdateOnFiber(_root, fiber, SyncLane, NoTimestamp);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(child !== </span><span class="s3">null </span><span class="s1">&amp;&amp; !needsRemount) {</span>
      <span class="s1">scheduleFibersWithFamiliesRecursively(</span>
        <span class="s1">child,</span>
        <span class="s1">updatedFamilies,</span>
        <span class="s1">staleFamilies</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(sibling !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">scheduleFibersWithFamiliesRecursively(</span>
        <span class="s1">sibling,</span>
        <span class="s1">updatedFamilies,</span>
        <span class="s1">staleFamilies</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">findHostInstancesForRefresh = </span><span class="s3">function</span><span class="s1">(root, families) {</span>
  <span class="s1">{</span>
    <span class="s3">var </span><span class="s1">hostInstances = </span><span class="s3">new </span><span class="s1">Set();</span>
    <span class="s3">var </span><span class="s1">types = </span><span class="s3">new </span><span class="s1">Set(</span>
      <span class="s1">families.map(</span><span class="s3">function</span><span class="s1">(family) {</span>
        <span class="s3">return </span><span class="s1">family.current;</span>
      <span class="s1">})</span>
    <span class="s1">);</span>
    <span class="s1">findHostInstancesForMatchingFibersRecursively(</span>
      <span class="s1">root.current,</span>
      <span class="s1">types,</span>
      <span class="s1">hostInstances</span>
    <span class="s1">);</span>
    <span class="s3">return </span><span class="s1">hostInstances;</span>
  <span class="s1">}</span>
<span class="s1">};</span>

<span class="s3">function </span><span class="s1">findHostInstancesForMatchingFibersRecursively(</span>
  <span class="s1">fiber,</span>
  <span class="s1">types,</span>
  <span class="s1">hostInstances</span>
<span class="s1">) {</span>
  <span class="s1">{</span>
    <span class="s3">var </span><span class="s1">child = fiber.child,</span>
      <span class="s1">sibling = fiber.sibling,</span>
      <span class="s1">tag = fiber.tag,</span>
      <span class="s1">type = fiber.type;</span>
    <span class="s3">var </span><span class="s1">candidateType = </span><span class="s3">null</span><span class="s1">;</span>

    <span class="s3">switch </span><span class="s1">(tag) {</span>
      <span class="s3">case </span><span class="s1">FunctionComponent:</span>
      <span class="s3">case </span><span class="s1">SimpleMemoComponent:</span>
      <span class="s3">case </span><span class="s1">ClassComponent:</span>
        <span class="s1">candidateType = type;</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s1">ForwardRef:</span>
        <span class="s1">candidateType = type.render;</span>
        <span class="s3">break</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">didMatch = </span><span class="s3">false</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s1">(candidateType !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(types.has(candidateType)) {</span>
        <span class="s1">didMatch = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(didMatch) {</span>
      <span class="s0">// We have a match. This only drills down to the closest host components.</span>
      <span class="s0">// There's no need to search deeper because for the purpose of giving</span>
      <span class="s0">// visual feedback, &quot;flashing&quot; outermost parent rectangles is sufficient.</span>
      <span class="s1">findHostInstancesForFiberShallowly(fiber, hostInstances);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s0">// If there's no match, maybe there will be one further down in the child tree.</span>
      <span class="s3">if </span><span class="s1">(child !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">findHostInstancesForMatchingFibersRecursively(</span>
          <span class="s1">child,</span>
          <span class="s1">types,</span>
          <span class="s1">hostInstances</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(sibling !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">findHostInstancesForMatchingFibersRecursively(</span>
        <span class="s1">sibling,</span>
        <span class="s1">types,</span>
        <span class="s1">hostInstances</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">findHostInstancesForFiberShallowly(fiber, hostInstances) {</span>
  <span class="s1">{</span>
    <span class="s3">var </span><span class="s1">foundHostInstances = findChildHostInstancesForFiberShallowly(</span>
      <span class="s1">fiber,</span>
      <span class="s1">hostInstances</span>
    <span class="s1">);</span>

    <span class="s3">if </span><span class="s1">(foundHostInstances) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s0">// If we didn't find any host children, fallback to closest host parent.</span>

    <span class="s3">var </span><span class="s1">node = fiber;</span>

    <span class="s3">while </span><span class="s1">(</span><span class="s3">true</span><span class="s1">) {</span>
      <span class="s3">switch </span><span class="s1">(node.tag) {</span>
        <span class="s3">case </span><span class="s1">HostComponent:</span>
          <span class="s1">hostInstances.add(node.stateNode);</span>
          <span class="s3">return</span><span class="s1">;</span>

        <span class="s3">case </span><span class="s1">HostPortal:</span>
          <span class="s1">hostInstances.add(node.stateNode.containerInfo);</span>
          <span class="s3">return</span><span class="s1">;</span>

        <span class="s3">case </span><span class="s1">HostRoot:</span>
          <span class="s1">hostInstances.add(node.stateNode.containerInfo);</span>
          <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(node.</span><span class="s3">return </span><span class="s1">=== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Expected to reach root first.&quot;</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s1">node = node.</span><span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">findChildHostInstancesForFiberShallowly(fiber, hostInstances) {</span>
  <span class="s1">{</span>
    <span class="s3">var </span><span class="s1">node = fiber;</span>
    <span class="s3">var </span><span class="s1">foundHostInstances = </span><span class="s3">false</span><span class="s1">;</span>

    <span class="s3">while </span><span class="s1">(</span><span class="s3">true</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(node.tag === HostComponent) {</span>
        <span class="s0">// We got a match.</span>
        <span class="s1">foundHostInstances = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s1">hostInstances.add(node.stateNode); </span><span class="s0">// There may still be more, so keep searching.</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(node.child !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">node.child.</span><span class="s3">return </span><span class="s1">= node;</span>
        <span class="s1">node = node.child;</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(node === fiber) {</span>
        <span class="s3">return </span><span class="s1">foundHostInstances;</span>
      <span class="s1">}</span>

      <span class="s3">while </span><span class="s1">(node.sibling === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(node.</span><span class="s3">return </span><span class="s1">=== </span><span class="s3">null </span><span class="s1">|| node.</span><span class="s3">return </span><span class="s1">=== fiber) {</span>
          <span class="s3">return </span><span class="s1">foundHostInstances;</span>
        <span class="s1">}</span>

        <span class="s1">node = node.</span><span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">node.sibling.</span><span class="s3">return </span><span class="s1">= node.</span><span class="s3">return</span><span class="s1">;</span>
      <span class="s1">node = node.sibling;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">return false</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">hasBadMapPolyfill;</span>

<span class="s1">{</span>
  <span class="s1">hasBadMapPolyfill = </span><span class="s3">false</span><span class="s1">;</span>

  <span class="s3">try </span><span class="s1">{</span>
    <span class="s3">var </span><span class="s1">nonExtensibleObject = Object.preventExtensions({});</span>
    <span class="s0">/* eslint-disable no-new */</span>

    <span class="s3">new </span><span class="s1">Map([[nonExtensibleObject, </span><span class="s3">null</span><span class="s1">]]);</span>
    <span class="s3">new </span><span class="s1">Set([nonExtensibleObject]);</span>
    <span class="s0">/* eslint-enable no-new */</span>
  <span class="s1">} </span><span class="s3">catch </span><span class="s1">(e) {</span>
    <span class="s0">// TODO: Consider warning about bad polyfills</span>
    <span class="s1">hasBadMapPolyfill = </span><span class="s3">true</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">FiberNode(tag, pendingProps, key, mode) {</span>
  <span class="s0">// Instance</span>
  <span class="s3">this</span><span class="s1">.tag = tag;</span>
  <span class="s3">this</span><span class="s1">.key = key;</span>
  <span class="s3">this</span><span class="s1">.elementType = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.type = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.stateNode = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// Fiber</span>

  <span class="s3">this</span><span class="s1">.</span><span class="s3">return </span><span class="s1">= </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.child = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.sibling = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.index = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.ref = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.pendingProps = pendingProps;</span>
  <span class="s3">this</span><span class="s1">.memoizedProps = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.updateQueue = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.memoizedState = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.dependencies = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.mode = mode; </span><span class="s0">// Effects</span>

  <span class="s3">this</span><span class="s1">.flags = NoFlags;</span>
  <span class="s3">this</span><span class="s1">.subtreeFlags = NoFlags;</span>
  <span class="s3">this</span><span class="s1">.deletions = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.lanes = NoLanes;</span>
  <span class="s3">this</span><span class="s1">.childLanes = NoLanes;</span>
  <span class="s3">this</span><span class="s1">.alternate = </span><span class="s3">null</span><span class="s1">;</span>

  <span class="s1">{</span>
    <span class="s0">// Note: The following is done to avoid a v8 performance cliff.</span>
    <span class="s0">//</span>
    <span class="s0">// Initializing the fields below to smis and later updating them with</span>
    <span class="s0">// double values will cause Fibers to end up having separate shapes.</span>
    <span class="s0">// This behavior/bug has something to do with Object.preventExtension().</span>
    <span class="s0">// Fortunately this only impacts DEV builds.</span>
    <span class="s0">// Unfortunately it makes React unusably slow for some applications.</span>
    <span class="s0">// To work around this, initialize the fields below with doubles.</span>
    <span class="s0">//</span>
    <span class="s0">// Learn more about this here:</span>
    <span class="s0">// https://github.com/facebook/react/issues/14365</span>
    <span class="s0">// https://bugs.chromium.org/p/v8/issues/detail?id=8538</span>
    <span class="s3">this</span><span class="s1">.actualDuration = Number.NaN;</span>
    <span class="s3">this</span><span class="s1">.actualStartTime = Number.NaN;</span>
    <span class="s3">this</span><span class="s1">.selfBaseDuration = Number.NaN;</span>
    <span class="s3">this</span><span class="s1">.treeBaseDuration = Number.NaN; </span><span class="s0">// It's okay to replace the initial doubles with smis after initialization.</span>
    <span class="s0">// This won't trigger the performance cliff mentioned above,</span>
    <span class="s0">// and it simplifies other profiler code (including DevTools).</span>

    <span class="s3">this</span><span class="s1">.actualDuration = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s1">.actualStartTime = -</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s1">.selfBaseDuration = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s1">.treeBaseDuration = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s1">{</span>
    <span class="s0">// This isn't directly used but is handy for debugging internals:</span>
    <span class="s3">this</span><span class="s1">._debugSource = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s1">._debugOwner = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s1">._debugNeedsRemount = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s1">._debugHookTypes = </span><span class="s3">null</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s1">(!hasBadMapPolyfill &amp;&amp; </span><span class="s3">typeof </span><span class="s1">Object.preventExtensions === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
      <span class="s1">Object.preventExtensions(</span><span class="s3">this</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">} </span><span class="s0">// This is a constructor function, rather than a POJO constructor, still</span>
<span class="s0">// please ensure we do the following:</span>
<span class="s0">// 1) Nobody should add any instance methods on this. Instance methods can be</span>
<span class="s0">//    more difficult to predict when they get optimized and they are almost</span>
<span class="s0">//    never inlined properly in static compilers.</span>
<span class="s0">// 2) Nobody should rely on `instanceof Fiber` for type testing. We should</span>
<span class="s0">//    always know when it is a fiber.</span>
<span class="s0">// 3) We might want to experiment with using numeric keys since they are easier</span>
<span class="s0">//    to optimize in a non-JIT environment.</span>
<span class="s0">// 4) We can easily go from a constructor to a createFiber object literal if that</span>
<span class="s0">//    is faster.</span>
<span class="s0">// 5) It should be easy to port this to a C struct and keep a C implementation</span>
<span class="s0">//    compatible.</span>

<span class="s3">var </span><span class="s1">createFiber = </span><span class="s3">function</span><span class="s1">(tag, pendingProps, key, mode) {</span>
  <span class="s0">// $FlowFixMe: the shapes are exact here but Flow doesn't like constructors</span>
  <span class="s3">return new </span><span class="s1">FiberNode(tag, pendingProps, key, mode);</span>
<span class="s1">};</span>

<span class="s3">function </span><span class="s1">shouldConstruct(Component) {</span>
  <span class="s3">var </span><span class="s1">prototype = Component.prototype;</span>
  <span class="s3">return </span><span class="s1">!!(prototype &amp;&amp; prototype.isReactComponent);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">isSimpleFunctionComponent(type) {</span>
  <span class="s3">return </span><span class="s1">(</span>
    <span class="s3">typeof </span><span class="s1">type === </span><span class="s2">&quot;function&quot; </span><span class="s1">&amp;&amp;</span>
    <span class="s1">!shouldConstruct(type) &amp;&amp;</span>
    <span class="s1">type.defaultProps === undefined</span>
  <span class="s1">);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">resolveLazyComponentTag(Component) {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">Component === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
    <span class="s3">return </span><span class="s1">shouldConstruct(Component) ? ClassComponent : FunctionComponent;</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(Component !== undefined &amp;&amp; Component !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">$$typeof = Component.$$typeof;</span>

    <span class="s3">if </span><span class="s1">($$typeof === REACT_FORWARD_REF_TYPE) {</span>
      <span class="s3">return </span><span class="s1">ForwardRef;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">($$typeof === REACT_MEMO_TYPE) {</span>
      <span class="s3">return </span><span class="s1">MemoComponent;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">IndeterminateComponent;</span>
<span class="s1">} </span><span class="s0">// This is used to create an alternate fiber to do work on.</span>

<span class="s3">function </span><span class="s1">createWorkInProgress(current, pendingProps) {</span>
  <span class="s3">var </span><span class="s1">workInProgress = current.alternate;</span>

  <span class="s3">if </span><span class="s1">(workInProgress === </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s0">// We use a double buffering pooling technique because we know that we'll</span>
    <span class="s0">// only ever need at most two versions of a tree. We pool the &quot;other&quot; unused</span>
    <span class="s0">// node that we're free to reuse. This is lazily created to avoid allocating</span>
    <span class="s0">// extra objects for things that are never updated. It also allow us to</span>
    <span class="s0">// reclaim the extra memory if needed.</span>
    <span class="s1">workInProgress = createFiber(</span>
      <span class="s1">current.tag,</span>
      <span class="s1">pendingProps,</span>
      <span class="s1">current.key,</span>
      <span class="s1">current.mode</span>
    <span class="s1">);</span>
    <span class="s1">workInProgress.elementType = current.elementType;</span>
    <span class="s1">workInProgress.type = current.type;</span>
    <span class="s1">workInProgress.stateNode = current.stateNode;</span>

    <span class="s1">{</span>
      <span class="s0">// DEV-only fields</span>
      <span class="s1">workInProgress._debugSource = current._debugSource;</span>
      <span class="s1">workInProgress._debugOwner = current._debugOwner;</span>
      <span class="s1">workInProgress._debugHookTypes = current._debugHookTypes;</span>
    <span class="s1">}</span>

    <span class="s1">workInProgress.alternate = current;</span>
    <span class="s1">current.alternate = workInProgress;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">workInProgress.pendingProps = pendingProps; </span><span class="s0">// Needed because Blocks store data on type.</span>

    <span class="s1">workInProgress.type = current.type; </span><span class="s0">// We already have an alternate.</span>
    <span class="s0">// Reset the effect tag.</span>

    <span class="s1">workInProgress.flags = NoFlags; </span><span class="s0">// The effects are no longer valid.</span>

    <span class="s1">workInProgress.subtreeFlags = NoFlags;</span>
    <span class="s1">workInProgress.deletions = </span><span class="s3">null</span><span class="s1">;</span>

    <span class="s1">{</span>
      <span class="s0">// We intentionally reset, rather than copy, actualDuration &amp; actualStartTime.</span>
      <span class="s0">// This prevents time from endlessly accumulating in new commits.</span>
      <span class="s0">// This has the downside of resetting values for different priority renders,</span>
      <span class="s0">// But works for yielding (the common case) and should support resuming.</span>
      <span class="s1">workInProgress.actualDuration = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s1">workInProgress.actualStartTime = -</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s0">// Reset all effects except static ones.</span>
  <span class="s0">// Static effects are not specific to a render.</span>

  <span class="s1">workInProgress.flags = current.flags &amp; StaticMask;</span>
  <span class="s1">workInProgress.childLanes = current.childLanes;</span>
  <span class="s1">workInProgress.lanes = current.lanes;</span>
  <span class="s1">workInProgress.child = current.child;</span>
  <span class="s1">workInProgress.memoizedProps = current.memoizedProps;</span>
  <span class="s1">workInProgress.memoizedState = current.memoizedState;</span>
  <span class="s1">workInProgress.updateQueue = current.updateQueue; </span><span class="s0">// Clone the dependencies object. This is mutated during the render phase, so</span>
  <span class="s0">// it cannot be shared with the current fiber.</span>

  <span class="s3">var </span><span class="s1">currentDependencies = current.dependencies;</span>
  <span class="s1">workInProgress.dependencies =</span>
    <span class="s1">currentDependencies === </span><span class="s3">null</span>
      <span class="s1">? </span><span class="s3">null</span>
      <span class="s1">: {</span>
          <span class="s1">lanes: currentDependencies.lanes,</span>
          <span class="s1">firstContext: currentDependencies.firstContext</span>
        <span class="s1">}; </span><span class="s0">// These will be overridden during the parent's reconciliation</span>

  <span class="s1">workInProgress.sibling = current.sibling;</span>
  <span class="s1">workInProgress.index = current.index;</span>
  <span class="s1">workInProgress.ref = current.ref;</span>

  <span class="s1">{</span>
    <span class="s1">workInProgress.selfBaseDuration = current.selfBaseDuration;</span>
    <span class="s1">workInProgress.treeBaseDuration = current.treeBaseDuration;</span>
  <span class="s1">}</span>

  <span class="s1">{</span>
    <span class="s1">workInProgress._debugNeedsRemount = current._debugNeedsRemount;</span>

    <span class="s3">switch </span><span class="s1">(workInProgress.tag) {</span>
      <span class="s3">case </span><span class="s1">IndeterminateComponent:</span>
      <span class="s3">case </span><span class="s1">FunctionComponent:</span>
      <span class="s3">case </span><span class="s1">SimpleMemoComponent:</span>
        <span class="s1">workInProgress.type = resolveFunctionForHotReloading(current.type);</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s1">ClassComponent:</span>
        <span class="s1">workInProgress.type = resolveClassForHotReloading(current.type);</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s1">ForwardRef:</span>
        <span class="s1">workInProgress.type = resolveForwardRefForHotReloading(current.type);</span>
        <span class="s3">break</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">workInProgress;</span>
<span class="s1">} </span><span class="s0">// Used to reuse a Fiber for a second pass.</span>

<span class="s3">function </span><span class="s1">resetWorkInProgress(workInProgress, renderLanes) {</span>
  <span class="s0">// This resets the Fiber to what createFiber or createWorkInProgress would</span>
  <span class="s0">// have set the values to before during the first pass. Ideally this wouldn't</span>
  <span class="s0">// be necessary but unfortunately many code paths reads from the workInProgress</span>
  <span class="s0">// when they should be reading from current and writing to workInProgress.</span>
  <span class="s0">// We assume pendingProps, index, key, ref, return are still untouched to</span>
  <span class="s0">// avoid doing another reconciliation.</span>
  <span class="s0">// Reset the effect flags but keep any Placement tags, since that's something</span>
  <span class="s0">// that child fiber is setting, not the reconciliation.</span>
  <span class="s1">workInProgress.flags &amp;= StaticMask | Placement; </span><span class="s0">// The effects are no longer valid.</span>

  <span class="s3">var </span><span class="s1">current = workInProgress.alternate;</span>

  <span class="s3">if </span><span class="s1">(current === </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s0">// Reset to createFiber's initial values.</span>
    <span class="s1">workInProgress.childLanes = NoLanes;</span>
    <span class="s1">workInProgress.lanes = renderLanes;</span>
    <span class="s1">workInProgress.child = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">workInProgress.subtreeFlags = NoFlags;</span>
    <span class="s1">workInProgress.memoizedProps = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">workInProgress.memoizedState = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">workInProgress.updateQueue = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">workInProgress.dependencies = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">workInProgress.stateNode = </span><span class="s3">null</span><span class="s1">;</span>

    <span class="s1">{</span>
      <span class="s0">// Note: We don't reset the actualTime counts. It's useful to accumulate</span>
      <span class="s0">// actual time across multiple render passes.</span>
      <span class="s1">workInProgress.selfBaseDuration = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s1">workInProgress.treeBaseDuration = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s0">// Reset to the cloned values that createWorkInProgress would've.</span>
    <span class="s1">workInProgress.childLanes = current.childLanes;</span>
    <span class="s1">workInProgress.lanes = current.lanes;</span>
    <span class="s1">workInProgress.child = current.child;</span>
    <span class="s1">workInProgress.subtreeFlags = NoFlags;</span>
    <span class="s1">workInProgress.deletions = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">workInProgress.memoizedProps = current.memoizedProps;</span>
    <span class="s1">workInProgress.memoizedState = current.memoizedState;</span>
    <span class="s1">workInProgress.updateQueue = current.updateQueue; </span><span class="s0">// Needed because Blocks store data on type.</span>

    <span class="s1">workInProgress.type = current.type; </span><span class="s0">// Clone the dependencies object. This is mutated during the render phase, so</span>
    <span class="s0">// it cannot be shared with the current fiber.</span>

    <span class="s3">var </span><span class="s1">currentDependencies = current.dependencies;</span>
    <span class="s1">workInProgress.dependencies =</span>
      <span class="s1">currentDependencies === </span><span class="s3">null</span>
        <span class="s1">? </span><span class="s3">null</span>
        <span class="s1">: {</span>
            <span class="s1">lanes: currentDependencies.lanes,</span>
            <span class="s1">firstContext: currentDependencies.firstContext</span>
          <span class="s1">};</span>

    <span class="s1">{</span>
      <span class="s0">// Note: We don't reset the actualTime counts. It's useful to accumulate</span>
      <span class="s0">// actual time across multiple render passes.</span>
      <span class="s1">workInProgress.selfBaseDuration = current.selfBaseDuration;</span>
      <span class="s1">workInProgress.treeBaseDuration = current.treeBaseDuration;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">workInProgress;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">createHostRootFiber(</span>
  <span class="s1">tag,</span>
  <span class="s1">isStrictMode,</span>
  <span class="s1">concurrentUpdatesByDefaultOverride</span>
<span class="s1">) {</span>
  <span class="s3">var </span><span class="s1">mode;</span>

  <span class="s3">if </span><span class="s1">(tag === ConcurrentRoot) {</span>
    <span class="s1">mode = ConcurrentMode;</span>

    <span class="s3">if </span><span class="s1">(isStrictMode === </span><span class="s3">true</span><span class="s1">) {</span>
      <span class="s1">mode |= StrictLegacyMode;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">mode = NoMode;</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(isDevToolsPresent) {</span>
    <span class="s0">// Always collect profile timings when DevTools are present.</span>
    <span class="s0">// This enables DevTools to start capturing timing at any point</span>
    <span class="s0">// Without some nodes in the tree having empty base times.</span>
    <span class="s1">mode |= ProfileMode;</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">createFiber(HostRoot, </span><span class="s3">null</span><span class="s1">, </span><span class="s3">null</span><span class="s1">, mode);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">createFiberFromTypeAndProps(</span>
  <span class="s1">type, </span><span class="s0">// React$ElementType</span>
  <span class="s1">key,</span>
  <span class="s1">pendingProps,</span>
  <span class="s1">owner,</span>
  <span class="s1">mode,</span>
  <span class="s1">lanes</span>
<span class="s1">) {</span>
  <span class="s3">var </span><span class="s1">fiberTag = IndeterminateComponent; </span><span class="s0">// The resolved type is set if we know what the final type will be. I.e. it's not lazy.</span>

  <span class="s3">var </span><span class="s1">resolvedType = type;</span>

  <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">type === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
    <span class="s3">if </span><span class="s1">(shouldConstruct(type)) {</span>
      <span class="s1">fiberTag = ClassComponent;</span>

      <span class="s1">{</span>
        <span class="s1">resolvedType = resolveClassForHotReloading(resolvedType);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">{</span>
        <span class="s1">resolvedType = resolveFunctionForHotReloading(resolvedType);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">type === </span><span class="s2">&quot;string&quot;</span><span class="s1">) {</span>
    <span class="s1">fiberTag = HostComponent;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">getTag: </span><span class="s3">switch </span><span class="s1">(type) {</span>
      <span class="s3">case </span><span class="s1">REACT_FRAGMENT_TYPE:</span>
        <span class="s3">return </span><span class="s1">createFiberFromFragment(pendingProps.children, mode, lanes, key);</span>

      <span class="s3">case </span><span class="s1">REACT_STRICT_MODE_TYPE:</span>
        <span class="s1">fiberTag = Mode;</span>
        <span class="s1">mode |= StrictLegacyMode;</span>

        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s1">REACT_PROFILER_TYPE:</span>
        <span class="s3">return </span><span class="s1">createFiberFromProfiler(pendingProps, mode, lanes, key);</span>

      <span class="s3">case </span><span class="s1">REACT_SUSPENSE_TYPE:</span>
        <span class="s3">return </span><span class="s1">createFiberFromSuspense(pendingProps, mode, lanes, key);</span>

      <span class="s3">case </span><span class="s1">REACT_SUSPENSE_LIST_TYPE:</span>
        <span class="s3">return </span><span class="s1">createFiberFromSuspenseList(pendingProps, mode, lanes, key);</span>

      <span class="s3">case </span><span class="s1">REACT_OFFSCREEN_TYPE:</span>
        <span class="s3">return </span><span class="s1">createFiberFromOffscreen(pendingProps, mode, lanes, key);</span>

      <span class="s3">case </span><span class="s1">REACT_LEGACY_HIDDEN_TYPE:</span>

      <span class="s0">// eslint-disable-next-line no-fallthrough</span>

      <span class="s3">case </span><span class="s1">REACT_SCOPE_TYPE:</span>

      <span class="s0">// eslint-disable-next-line no-fallthrough</span>

      <span class="s3">case </span><span class="s1">REACT_CACHE_TYPE:</span>

      <span class="s0">// eslint-disable-next-line no-fallthrough</span>

      <span class="s3">case </span><span class="s1">REACT_TRACING_MARKER_TYPE:</span>

      <span class="s0">// eslint-disable-next-line no-fallthrough</span>

      <span class="s3">case </span><span class="s1">REACT_DEBUG_TRACING_MODE_TYPE:</span>

      <span class="s0">// eslint-disable-next-line no-fallthrough</span>

      <span class="s3">default</span><span class="s1">: {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">type === </span><span class="s2">&quot;object&quot; </span><span class="s1">&amp;&amp; type !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s3">switch </span><span class="s1">(type.$$typeof) {</span>
            <span class="s3">case </span><span class="s1">REACT_PROVIDER_TYPE:</span>
              <span class="s1">fiberTag = ContextProvider;</span>
              <span class="s3">break </span><span class="s1">getTag;</span>

            <span class="s3">case </span><span class="s1">REACT_CONTEXT_TYPE:</span>
              <span class="s0">// This is a consumer</span>
              <span class="s1">fiberTag = ContextConsumer;</span>
              <span class="s3">break </span><span class="s1">getTag;</span>

            <span class="s3">case </span><span class="s1">REACT_FORWARD_REF_TYPE:</span>
              <span class="s1">fiberTag = ForwardRef;</span>

              <span class="s1">{</span>
                <span class="s1">resolvedType = resolveForwardRefForHotReloading(resolvedType);</span>
              <span class="s1">}</span>

              <span class="s3">break </span><span class="s1">getTag;</span>

            <span class="s3">case </span><span class="s1">REACT_MEMO_TYPE:</span>
              <span class="s1">fiberTag = MemoComponent;</span>
              <span class="s3">break </span><span class="s1">getTag;</span>

            <span class="s3">case </span><span class="s1">REACT_LAZY_TYPE:</span>
              <span class="s1">fiberTag = LazyComponent;</span>
              <span class="s1">resolvedType = </span><span class="s3">null</span><span class="s1">;</span>
              <span class="s3">break </span><span class="s1">getTag;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">var </span><span class="s1">info = </span><span class="s2">&quot;&quot;</span><span class="s1">;</span>

        <span class="s1">{</span>
          <span class="s3">if </span><span class="s1">(</span>
            <span class="s1">type === undefined ||</span>
            <span class="s1">(</span><span class="s3">typeof </span><span class="s1">type === </span><span class="s2">&quot;object&quot; </span><span class="s1">&amp;&amp;</span>
              <span class="s1">type !== </span><span class="s3">null </span><span class="s1">&amp;&amp;</span>
              <span class="s1">Object.keys(type).length === </span><span class="s4">0</span><span class="s1">)</span>
          <span class="s1">) {</span>
            <span class="s1">info +=</span>
              <span class="s2">&quot; You likely forgot to export your component from the file &quot; </span><span class="s1">+</span>
              <span class="s2">&quot;it's defined in, or you might have mixed up default and &quot; </span><span class="s1">+</span>
              <span class="s2">&quot;named imports.&quot;</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s3">var </span><span class="s1">ownerName = owner ? getComponentNameFromFiber(owner) : </span><span class="s3">null</span><span class="s1">;</span>

          <span class="s3">if </span><span class="s1">(ownerName) {</span>
            <span class="s1">info += </span><span class="s2">&quot;</span><span class="s5">\n\n</span><span class="s2">Check the render method of `&quot; </span><span class="s1">+ ownerName + </span><span class="s2">&quot;`.&quot;</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">throw new </span><span class="s1">Error(</span>
          <span class="s2">&quot;Element type is invalid: expected a string (for built-in &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;components) or a class/function (for composite components) &quot; </span><span class="s1">+</span>
            <span class="s1">(</span><span class="s2">&quot;but got: &quot; </span><span class="s1">+ (type == </span><span class="s3">null </span><span class="s1">? type : </span><span class="s3">typeof </span><span class="s1">type) + </span><span class="s2">&quot;.&quot; </span><span class="s1">+ info)</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">fiber = createFiber(fiberTag, pendingProps, key, mode);</span>
  <span class="s1">fiber.elementType = type;</span>
  <span class="s1">fiber.type = resolvedType;</span>
  <span class="s1">fiber.lanes = lanes;</span>

  <span class="s1">{</span>
    <span class="s1">fiber._debugOwner = owner;</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">fiber;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">createFiberFromElement(element, mode, lanes) {</span>
  <span class="s3">var </span><span class="s1">owner = </span><span class="s3">null</span><span class="s1">;</span>

  <span class="s1">{</span>
    <span class="s1">owner = element._owner;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">type = element.type;</span>
  <span class="s3">var </span><span class="s1">key = element.key;</span>
  <span class="s3">var </span><span class="s1">pendingProps = element.props;</span>
  <span class="s3">var </span><span class="s1">fiber = createFiberFromTypeAndProps(</span>
    <span class="s1">type,</span>
    <span class="s1">key,</span>
    <span class="s1">pendingProps,</span>
    <span class="s1">owner,</span>
    <span class="s1">mode,</span>
    <span class="s1">lanes</span>
  <span class="s1">);</span>

  <span class="s1">{</span>
    <span class="s1">fiber._debugSource = element._source;</span>
    <span class="s1">fiber._debugOwner = element._owner;</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">fiber;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">createFiberFromFragment(elements, mode, lanes, key) {</span>
  <span class="s3">var </span><span class="s1">fiber = createFiber(Fragment, elements, key, mode);</span>
  <span class="s1">fiber.lanes = lanes;</span>
  <span class="s3">return </span><span class="s1">fiber;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">createFiberFromProfiler(pendingProps, mode, lanes, key) {</span>
  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">pendingProps.id !== </span><span class="s2">&quot;string&quot;</span><span class="s1">) {</span>
      <span class="s1">error(</span>
        <span class="s2">'Profiler must specify an &quot;id&quot; of type `string` as a prop. Received the type `%s` instead.'</span><span class="s1">,</span>
        <span class="s3">typeof </span><span class="s1">pendingProps.id</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode);</span>
  <span class="s1">fiber.elementType = REACT_PROFILER_TYPE;</span>
  <span class="s1">fiber.lanes = lanes;</span>

  <span class="s1">{</span>
    <span class="s1">fiber.stateNode = {</span>
      <span class="s1">effectDuration: </span><span class="s4">0</span><span class="s1">,</span>
      <span class="s1">passiveEffectDuration: </span><span class="s4">0</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">fiber;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">createFiberFromSuspense(pendingProps, mode, lanes, key) {</span>
  <span class="s3">var </span><span class="s1">fiber = createFiber(SuspenseComponent, pendingProps, key, mode);</span>
  <span class="s1">fiber.elementType = REACT_SUSPENSE_TYPE;</span>
  <span class="s1">fiber.lanes = lanes;</span>
  <span class="s3">return </span><span class="s1">fiber;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">createFiberFromSuspenseList(pendingProps, mode, lanes, key) {</span>
  <span class="s3">var </span><span class="s1">fiber = createFiber(SuspenseListComponent, pendingProps, key, mode);</span>
  <span class="s1">fiber.elementType = REACT_SUSPENSE_LIST_TYPE;</span>
  <span class="s1">fiber.lanes = lanes;</span>
  <span class="s3">return </span><span class="s1">fiber;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">createFiberFromOffscreen(pendingProps, mode, lanes, key) {</span>
  <span class="s3">var </span><span class="s1">fiber = createFiber(OffscreenComponent, pendingProps, key, mode);</span>
  <span class="s1">fiber.elementType = REACT_OFFSCREEN_TYPE;</span>
  <span class="s1">fiber.lanes = lanes;</span>
  <span class="s3">var </span><span class="s1">primaryChildInstance = {</span>
    <span class="s1">isHidden: </span><span class="s3">false</span>
  <span class="s1">};</span>
  <span class="s1">fiber.stateNode = primaryChildInstance;</span>
  <span class="s3">return </span><span class="s1">fiber;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">createFiberFromText(content, mode, lanes) {</span>
  <span class="s3">var </span><span class="s1">fiber = createFiber(HostText, content, </span><span class="s3">null</span><span class="s1">, mode);</span>
  <span class="s1">fiber.lanes = lanes;</span>
  <span class="s3">return </span><span class="s1">fiber;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">createFiberFromPortal(portal, mode, lanes) {</span>
  <span class="s3">var </span><span class="s1">pendingProps = portal.children !== </span><span class="s3">null </span><span class="s1">? portal.children : [];</span>
  <span class="s3">var </span><span class="s1">fiber = createFiber(HostPortal, pendingProps, portal.key, mode);</span>
  <span class="s1">fiber.lanes = lanes;</span>
  <span class="s1">fiber.stateNode = {</span>
    <span class="s1">containerInfo: portal.containerInfo,</span>
    <span class="s1">pendingChildren: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s0">// Used by persistent updates</span>
    <span class="s1">implementation: portal.implementation</span>
  <span class="s1">};</span>
  <span class="s3">return </span><span class="s1">fiber;</span>
<span class="s1">} </span><span class="s0">// Used for stashing WIP properties to replay failed work in DEV.</span>

<span class="s3">function </span><span class="s1">assignFiberPropertiesInDEV(target, source) {</span>
  <span class="s3">if </span><span class="s1">(target === </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s0">// This Fiber's initial properties will always be overwritten.</span>
    <span class="s0">// We only use a Fiber to ensure the same hidden class so DEV isn't slow.</span>
    <span class="s1">target = createFiber(IndeterminateComponent, </span><span class="s3">null</span><span class="s1">, </span><span class="s3">null</span><span class="s1">, NoMode);</span>
  <span class="s1">} </span><span class="s0">// This is intentionally written as a list of all properties.</span>
  <span class="s0">// We tried to use Object.assign() instead but this is called in</span>
  <span class="s0">// the hottest path, and Object.assign() was too slow:</span>
  <span class="s0">// https://github.com/facebook/react/issues/12502</span>
  <span class="s0">// This code is DEV-only so size is not a concern.</span>

  <span class="s1">target.tag = source.tag;</span>
  <span class="s1">target.key = source.key;</span>
  <span class="s1">target.elementType = source.elementType;</span>
  <span class="s1">target.type = source.type;</span>
  <span class="s1">target.stateNode = source.stateNode;</span>
  <span class="s1">target.</span><span class="s3">return </span><span class="s1">= source.</span><span class="s3">return</span><span class="s1">;</span>
  <span class="s1">target.child = source.child;</span>
  <span class="s1">target.sibling = source.sibling;</span>
  <span class="s1">target.index = source.index;</span>
  <span class="s1">target.ref = source.ref;</span>
  <span class="s1">target.pendingProps = source.pendingProps;</span>
  <span class="s1">target.memoizedProps = source.memoizedProps;</span>
  <span class="s1">target.updateQueue = source.updateQueue;</span>
  <span class="s1">target.memoizedState = source.memoizedState;</span>
  <span class="s1">target.dependencies = source.dependencies;</span>
  <span class="s1">target.mode = source.mode;</span>
  <span class="s1">target.flags = source.flags;</span>
  <span class="s1">target.subtreeFlags = source.subtreeFlags;</span>
  <span class="s1">target.deletions = source.deletions;</span>
  <span class="s1">target.lanes = source.lanes;</span>
  <span class="s1">target.childLanes = source.childLanes;</span>
  <span class="s1">target.alternate = source.alternate;</span>

  <span class="s1">{</span>
    <span class="s1">target.actualDuration = source.actualDuration;</span>
    <span class="s1">target.actualStartTime = source.actualStartTime;</span>
    <span class="s1">target.selfBaseDuration = source.selfBaseDuration;</span>
    <span class="s1">target.treeBaseDuration = source.treeBaseDuration;</span>
  <span class="s1">}</span>

  <span class="s1">target._debugSource = source._debugSource;</span>
  <span class="s1">target._debugOwner = source._debugOwner;</span>
  <span class="s1">target._debugNeedsRemount = source._debugNeedsRemount;</span>
  <span class="s1">target._debugHookTypes = source._debugHookTypes;</span>
  <span class="s3">return </span><span class="s1">target;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">FiberRootNode(</span>
  <span class="s1">containerInfo,</span>
  <span class="s1">tag,</span>
  <span class="s1">hydrate,</span>
  <span class="s1">identifierPrefix,</span>
  <span class="s1">onRecoverableError</span>
<span class="s1">) {</span>
  <span class="s3">this</span><span class="s1">.tag = tag;</span>
  <span class="s3">this</span><span class="s1">.containerInfo = containerInfo;</span>
  <span class="s3">this</span><span class="s1">.pendingChildren = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.current = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.pingCache = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.finishedWork = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.timeoutHandle = noTimeout;</span>
  <span class="s3">this</span><span class="s1">.context = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.pendingContext = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.callbackNode = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.callbackPriority = NoLane;</span>
  <span class="s3">this</span><span class="s1">.eventTimes = createLaneMap(NoLanes);</span>
  <span class="s3">this</span><span class="s1">.expirationTimes = createLaneMap(NoTimestamp);</span>
  <span class="s3">this</span><span class="s1">.pendingLanes = NoLanes;</span>
  <span class="s3">this</span><span class="s1">.suspendedLanes = NoLanes;</span>
  <span class="s3">this</span><span class="s1">.pingedLanes = NoLanes;</span>
  <span class="s3">this</span><span class="s1">.expiredLanes = NoLanes;</span>
  <span class="s3">this</span><span class="s1">.mutableReadLanes = NoLanes;</span>
  <span class="s3">this</span><span class="s1">.finishedLanes = NoLanes;</span>
  <span class="s3">this</span><span class="s1">.entangledLanes = NoLanes;</span>
  <span class="s3">this</span><span class="s1">.entanglements = createLaneMap(NoLanes);</span>
  <span class="s3">this</span><span class="s1">.identifierPrefix = identifierPrefix;</span>
  <span class="s3">this</span><span class="s1">.onRecoverableError = onRecoverableError;</span>

  <span class="s1">{</span>
    <span class="s3">this</span><span class="s1">.effectDuration = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s1">.passiveEffectDuration = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s1">{</span>
    <span class="s3">this</span><span class="s1">.memoizedUpdaters = </span><span class="s3">new </span><span class="s1">Set();</span>
    <span class="s3">var </span><span class="s1">pendingUpdatersLaneMap = (</span><span class="s3">this</span><span class="s1">.pendingUpdatersLaneMap = []);</span>

    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">_i = </span><span class="s4">0</span><span class="s1">; _i &lt; TotalLanes; _i++) {</span>
      <span class="s1">pendingUpdatersLaneMap.push(</span><span class="s3">new </span><span class="s1">Set());</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">{</span>
    <span class="s3">switch </span><span class="s1">(tag) {</span>
      <span class="s3">case </span><span class="s1">ConcurrentRoot:</span>
        <span class="s3">this</span><span class="s1">._debugRootType = hydrate ? </span><span class="s2">&quot;hydrateRoot()&quot; </span><span class="s1">: </span><span class="s2">&quot;createRoot()&quot;</span><span class="s1">;</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s1">LegacyRoot:</span>
        <span class="s3">this</span><span class="s1">._debugRootType = hydrate ? </span><span class="s2">&quot;hydrate()&quot; </span><span class="s1">: </span><span class="s2">&quot;render()&quot;</span><span class="s1">;</span>
        <span class="s3">break</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">createFiberRoot(</span>
  <span class="s1">containerInfo,</span>
  <span class="s1">tag,</span>
  <span class="s1">hydrate,</span>
  <span class="s1">initialChildren,</span>
  <span class="s1">hydrationCallbacks,</span>
  <span class="s1">isStrictMode,</span>
  <span class="s1">concurrentUpdatesByDefaultOverride, </span><span class="s0">// TODO: We have several of these arguments that are conceptually part of the</span>
  <span class="s0">// host config, but because they are passed in at runtime, we have to thread</span>
  <span class="s0">// them through the root constructor. Perhaps we should put them all into a</span>
  <span class="s0">// single type, like a DynamicHostConfig that is defined by the renderer.</span>
  <span class="s1">identifierPrefix,</span>
  <span class="s1">onRecoverableError,</span>
  <span class="s1">transitionCallbacks</span>
<span class="s1">) {</span>
  <span class="s3">var </span><span class="s1">root = </span><span class="s3">new </span><span class="s1">FiberRootNode(</span>
    <span class="s1">containerInfo,</span>
    <span class="s1">tag,</span>
    <span class="s1">hydrate,</span>
    <span class="s1">identifierPrefix,</span>
    <span class="s1">onRecoverableError</span>
  <span class="s1">);</span>
  <span class="s0">// stateNode is any.</span>

  <span class="s3">var </span><span class="s1">uninitializedFiber = createHostRootFiber(tag, isStrictMode);</span>
  <span class="s1">root.current = uninitializedFiber;</span>
  <span class="s1">uninitializedFiber.stateNode = root;</span>

  <span class="s1">{</span>
    <span class="s3">var </span><span class="s1">_initialState = {</span>
      <span class="s1">element: initialChildren,</span>
      <span class="s1">isDehydrated: hydrate,</span>
      <span class="s1">cache: </span><span class="s3">null</span><span class="s1">,</span>
      <span class="s0">// not enabled yet</span>
      <span class="s1">transitions: </span><span class="s3">null</span><span class="s1">,</span>
      <span class="s1">pendingSuspenseBoundaries: </span><span class="s3">null</span>
    <span class="s1">};</span>
    <span class="s1">uninitializedFiber.memoizedState = _initialState;</span>
  <span class="s1">}</span>

  <span class="s1">initializeUpdateQueue(uninitializedFiber);</span>
  <span class="s3">return </span><span class="s1">root;</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">ReactVersion = </span><span class="s2">&quot;18.2.0-next-9e3b772b8-20220608&quot;</span><span class="s1">;</span>

<span class="s3">function </span><span class="s1">createPortal(</span>
  <span class="s1">children,</span>
  <span class="s1">containerInfo, </span><span class="s0">// TODO: figure out the API for cross-renderer implementation.</span>
  <span class="s1">implementation</span>
<span class="s1">) {</span>
  <span class="s3">var </span><span class="s1">key =</span>
    <span class="s1">arguments.length &gt; </span><span class="s4">3 </span><span class="s1">&amp;&amp; arguments[</span><span class="s4">3</span><span class="s1">] !== undefined ? arguments[</span><span class="s4">3</span><span class="s1">] : </span><span class="s3">null</span><span class="s1">;</span>

  <span class="s1">{</span>
    <span class="s1">checkKeyStringCoercion(key);</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">{</span>
    <span class="s0">// This tag allow us to uniquely identify this as a React Portal</span>
    <span class="s1">$$typeof: REACT_PORTAL_TYPE,</span>
    <span class="s1">key: key == </span><span class="s3">null </span><span class="s1">? </span><span class="s3">null </span><span class="s1">: </span><span class="s2">&quot;&quot; </span><span class="s1">+ key,</span>
    <span class="s1">children: children,</span>
    <span class="s1">containerInfo: containerInfo,</span>
    <span class="s1">implementation: implementation</span>
  <span class="s1">};</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">didWarnAboutNestedUpdates;</span>
<span class="s3">var </span><span class="s1">didWarnAboutFindNodeInStrictMode;</span>

<span class="s1">{</span>
  <span class="s1">didWarnAboutNestedUpdates = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s1">didWarnAboutFindNodeInStrictMode = {};</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">getContextForSubtree(parentComponent) {</span>
  <span class="s3">if </span><span class="s1">(!parentComponent) {</span>
    <span class="s3">return </span><span class="s1">emptyContextObject;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">fiber = get(parentComponent);</span>
  <span class="s3">var </span><span class="s1">parentContext = findCurrentUnmaskedContext(fiber);</span>

  <span class="s3">if </span><span class="s1">(fiber.tag === ClassComponent) {</span>
    <span class="s3">var </span><span class="s1">Component = fiber.type;</span>

    <span class="s3">if </span><span class="s1">(isContextProvider(Component)) {</span>
      <span class="s3">return </span><span class="s1">processChildContext(fiber, Component, parentContext);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">parentContext;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">findHostInstanceWithWarning(component, methodName) {</span>
  <span class="s1">{</span>
    <span class="s3">var </span><span class="s1">fiber = get(component);</span>

    <span class="s3">if </span><span class="s1">(fiber === undefined) {</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">component.render === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
        <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Unable to find node on an unmounted component.&quot;</span><span class="s1">);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s3">var </span><span class="s1">keys = Object.keys(component).join(</span><span class="s2">&quot;,&quot;</span><span class="s1">);</span>
        <span class="s3">throw new </span><span class="s1">Error(</span>
          <span class="s2">&quot;Argument appears to not be a ReactComponent. Keys: &quot; </span><span class="s1">+ keys</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">hostFiber = findCurrentHostFiber(fiber);</span>

    <span class="s3">if </span><span class="s1">(hostFiber === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(hostFiber.mode &amp; StrictLegacyMode) {</span>
      <span class="s3">var </span><span class="s1">componentName = getComponentNameFromFiber(fiber) || </span><span class="s2">&quot;Component&quot;</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s1">(!didWarnAboutFindNodeInStrictMode[componentName]) {</span>
        <span class="s1">didWarnAboutFindNodeInStrictMode[componentName] = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s3">var </span><span class="s1">previousFiber = current;</span>

        <span class="s3">try </span><span class="s1">{</span>
          <span class="s1">setCurrentFiber(hostFiber);</span>

          <span class="s3">if </span><span class="s1">(fiber.mode &amp; StrictLegacyMode) {</span>
            <span class="s1">error(</span>
              <span class="s2">&quot;%s is deprecated in StrictMode. &quot; </span><span class="s1">+</span>
                <span class="s2">&quot;%s was passed an instance of %s which is inside StrictMode. &quot; </span><span class="s1">+</span>
                <span class="s2">&quot;Instead, add a ref directly to the element you want to reference. &quot; </span><span class="s1">+</span>
                <span class="s2">&quot;Learn more about using refs safely here: &quot; </span><span class="s1">+</span>
                <span class="s2">&quot;https://reactjs.org/link/strict-mode-find-node&quot;</span><span class="s1">,</span>
              <span class="s1">methodName,</span>
              <span class="s1">methodName,</span>
              <span class="s1">componentName</span>
            <span class="s1">);</span>
          <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">error(</span>
              <span class="s2">&quot;%s is deprecated in StrictMode. &quot; </span><span class="s1">+</span>
                <span class="s2">&quot;%s was passed an instance of %s which renders StrictMode children. &quot; </span><span class="s1">+</span>
                <span class="s2">&quot;Instead, add a ref directly to the element you want to reference. &quot; </span><span class="s1">+</span>
                <span class="s2">&quot;Learn more about using refs safely here: &quot; </span><span class="s1">+</span>
                <span class="s2">&quot;https://reactjs.org/link/strict-mode-find-node&quot;</span><span class="s1">,</span>
              <span class="s1">methodName,</span>
              <span class="s1">methodName,</span>
              <span class="s1">componentName</span>
            <span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
          <span class="s0">// Ideally this should reset to previous but this shouldn't be called in</span>
          <span class="s0">// render and there's another warning for that anyway.</span>
          <span class="s3">if </span><span class="s1">(previousFiber) {</span>
            <span class="s1">setCurrentFiber(previousFiber);</span>
          <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">resetCurrentFiber();</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">hostFiber.stateNode;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">createContainer(</span>
  <span class="s1">containerInfo,</span>
  <span class="s1">tag,</span>
  <span class="s1">hydrationCallbacks,</span>
  <span class="s1">isStrictMode,</span>
  <span class="s1">concurrentUpdatesByDefaultOverride,</span>
  <span class="s1">identifierPrefix,</span>
  <span class="s1">onRecoverableError,</span>
  <span class="s1">transitionCallbacks</span>
<span class="s1">) {</span>
  <span class="s3">var </span><span class="s1">hydrate = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">initialChildren = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">return </span><span class="s1">createFiberRoot(</span>
    <span class="s1">containerInfo,</span>
    <span class="s1">tag,</span>
    <span class="s1">hydrate,</span>
    <span class="s1">initialChildren,</span>
    <span class="s1">hydrationCallbacks,</span>
    <span class="s1">isStrictMode,</span>
    <span class="s1">concurrentUpdatesByDefaultOverride,</span>
    <span class="s1">identifierPrefix,</span>
    <span class="s1">onRecoverableError</span>
  <span class="s1">);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">updateContainer(element, container, parentComponent, callback) {</span>
  <span class="s1">{</span>
    <span class="s1">onScheduleRoot(container, element);</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">current$1 = container.current;</span>
  <span class="s3">var </span><span class="s1">eventTime = requestEventTime();</span>
  <span class="s3">var </span><span class="s1">lane = requestUpdateLane(current$1);</span>

  <span class="s3">var </span><span class="s1">context = getContextForSubtree(parentComponent);</span>

  <span class="s3">if </span><span class="s1">(container.context === </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s1">container.context = context;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">container.pendingContext = context;</span>
  <span class="s1">}</span>

  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(isRendering &amp;&amp; current !== </span><span class="s3">null </span><span class="s1">&amp;&amp; !didWarnAboutNestedUpdates) {</span>
      <span class="s1">didWarnAboutNestedUpdates = </span><span class="s3">true</span><span class="s1">;</span>

      <span class="s1">error(</span>
        <span class="s2">&quot;Render methods should be a pure function of props and state; &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;triggering nested component updates from render is not allowed. &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;If necessary, trigger nested updates in componentDidUpdate.</span><span class="s5">\n\n</span><span class="s2">&quot; </span><span class="s1">+</span>
          <span class="s2">&quot;Check the render method of %s.&quot;</span><span class="s1">,</span>
        <span class="s1">getComponentNameFromFiber(current) || </span><span class="s2">&quot;Unknown&quot;</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">update = createUpdate(eventTime, lane); </span><span class="s0">// Caution: React DevTools currently depends on this property</span>
  <span class="s0">// being called &quot;element&quot;.</span>

  <span class="s1">update.payload = {</span>
    <span class="s1">element: element</span>
  <span class="s1">};</span>
  <span class="s1">callback = callback === undefined ? </span><span class="s3">null </span><span class="s1">: callback;</span>

  <span class="s3">if </span><span class="s1">(callback !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">callback !== </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
        <span class="s1">error(</span>
          <span class="s2">&quot;render(...): Expected the last optional `callback` argument to be a &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;function. Instead received: %s.&quot;</span><span class="s1">,</span>
          <span class="s1">callback</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">update.callback = callback;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">root = enqueueUpdate(current$1, update, lane);</span>

  <span class="s3">if </span><span class="s1">(root !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s1">scheduleUpdateOnFiber(root, current$1, lane, eventTime);</span>
    <span class="s1">entangleTransitions(root, current$1, lane);</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">lane;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">getPublicRootInstance(container) {</span>
  <span class="s3">var </span><span class="s1">containerFiber = container.current;</span>

  <span class="s3">if </span><span class="s1">(!containerFiber.child) {</span>
    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">switch </span><span class="s1">(containerFiber.child.tag) {</span>
    <span class="s3">case </span><span class="s1">HostComponent:</span>
      <span class="s3">return </span><span class="s1">getPublicInstance(containerFiber.child.stateNode);</span>

    <span class="s3">default</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">containerFiber.child.stateNode;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">shouldErrorImpl = </span><span class="s3">function</span><span class="s1">(fiber) {</span>
  <span class="s3">return null</span><span class="s1">;</span>
<span class="s1">};</span>

<span class="s3">function </span><span class="s1">shouldError(fiber) {</span>
  <span class="s3">return </span><span class="s1">shouldErrorImpl(fiber);</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">shouldSuspendImpl = </span><span class="s3">function</span><span class="s1">(fiber) {</span>
  <span class="s3">return false</span><span class="s1">;</span>
<span class="s1">};</span>

<span class="s3">function </span><span class="s1">shouldSuspend(fiber) {</span>
  <span class="s3">return </span><span class="s1">shouldSuspendImpl(fiber);</span>
<span class="s1">}</span>
<span class="s3">var </span><span class="s1">overrideHookState = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">overrideHookStateDeletePath = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">overrideHookStateRenamePath = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">overrideProps = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">overridePropsDeletePath = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">overridePropsRenamePath = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">scheduleUpdate = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">setErrorHandler = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">setSuspenseHandler = </span><span class="s3">null</span><span class="s1">;</span>

<span class="s1">{</span>
  <span class="s3">var </span><span class="s1">copyWithDeleteImpl = </span><span class="s3">function</span><span class="s1">(obj, path, index) {</span>
    <span class="s3">var </span><span class="s1">key = path[index];</span>
    <span class="s3">var </span><span class="s1">updated = isArray(obj) ? obj.slice() : assign({}, obj);</span>

    <span class="s3">if </span><span class="s1">(index + </span><span class="s4">1 </span><span class="s1">=== path.length) {</span>
      <span class="s3">if </span><span class="s1">(isArray(updated)) {</span>
        <span class="s1">updated.splice(key, </span><span class="s4">1</span><span class="s1">);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s3">delete </span><span class="s1">updated[key];</span>
      <span class="s1">}</span>

      <span class="s3">return </span><span class="s1">updated;</span>
    <span class="s1">} </span><span class="s0">// $FlowFixMe number or string is fine here</span>

    <span class="s1">updated[key] = copyWithDeleteImpl(obj[key], path, index + </span><span class="s4">1</span><span class="s1">);</span>
    <span class="s3">return </span><span class="s1">updated;</span>
  <span class="s1">};</span>

  <span class="s3">var </span><span class="s1">copyWithDelete = </span><span class="s3">function</span><span class="s1">(obj, path) {</span>
    <span class="s3">return </span><span class="s1">copyWithDeleteImpl(obj, path, </span><span class="s4">0</span><span class="s1">);</span>
  <span class="s1">};</span>

  <span class="s3">var </span><span class="s1">copyWithRenameImpl = </span><span class="s3">function</span><span class="s1">(obj, oldPath, newPath, index) {</span>
    <span class="s3">var </span><span class="s1">oldKey = oldPath[index];</span>
    <span class="s3">var </span><span class="s1">updated = isArray(obj) ? obj.slice() : assign({}, obj);</span>

    <span class="s3">if </span><span class="s1">(index + </span><span class="s4">1 </span><span class="s1">=== oldPath.length) {</span>
      <span class="s3">var </span><span class="s1">newKey = newPath[index]; </span><span class="s0">// $FlowFixMe number or string is fine here</span>

      <span class="s1">updated[newKey] = updated[oldKey];</span>

      <span class="s3">if </span><span class="s1">(isArray(updated)) {</span>
        <span class="s1">updated.splice(oldKey, </span><span class="s4">1</span><span class="s1">);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s3">delete </span><span class="s1">updated[oldKey];</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s0">// $FlowFixMe number or string is fine here</span>
      <span class="s1">updated[oldKey] = copyWithRenameImpl(</span>
        <span class="s0">// $FlowFixMe number or string is fine here</span>
        <span class="s1">obj[oldKey],</span>
        <span class="s1">oldPath,</span>
        <span class="s1">newPath,</span>
        <span class="s1">index + </span><span class="s4">1</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">updated;</span>
  <span class="s1">};</span>

  <span class="s3">var </span><span class="s1">copyWithRename = </span><span class="s3">function</span><span class="s1">(obj, oldPath, newPath) {</span>
    <span class="s3">if </span><span class="s1">(oldPath.length !== newPath.length) {</span>
      <span class="s1">warn(</span><span class="s2">&quot;copyWithRename() expects paths of the same length&quot;</span><span class="s1">);</span>

      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; newPath.length - </span><span class="s4">1</span><span class="s1">; i++) {</span>
        <span class="s3">if </span><span class="s1">(oldPath[i] !== newPath[i]) {</span>
          <span class="s1">warn(</span>
            <span class="s2">&quot;copyWithRename() expects paths to be the same except for the deepest key&quot;</span>
          <span class="s1">);</span>

          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">copyWithRenameImpl(obj, oldPath, newPath, </span><span class="s4">0</span><span class="s1">);</span>
  <span class="s1">};</span>

  <span class="s3">var </span><span class="s1">copyWithSetImpl = </span><span class="s3">function</span><span class="s1">(obj, path, index, value) {</span>
    <span class="s3">if </span><span class="s1">(index &gt;= path.length) {</span>
      <span class="s3">return </span><span class="s1">value;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">key = path[index];</span>
    <span class="s3">var </span><span class="s1">updated = isArray(obj) ? obj.slice() : assign({}, obj); </span><span class="s0">// $FlowFixMe number or string is fine here</span>

    <span class="s1">updated[key] = copyWithSetImpl(obj[key], path, index + </span><span class="s4">1</span><span class="s1">, value);</span>
    <span class="s3">return </span><span class="s1">updated;</span>
  <span class="s1">};</span>

  <span class="s3">var </span><span class="s1">copyWithSet = </span><span class="s3">function</span><span class="s1">(obj, path, value) {</span>
    <span class="s3">return </span><span class="s1">copyWithSetImpl(obj, path, </span><span class="s4">0</span><span class="s1">, value);</span>
  <span class="s1">};</span>

  <span class="s3">var </span><span class="s1">findHook = </span><span class="s3">function</span><span class="s1">(fiber, id) {</span>
    <span class="s0">// For now, the &quot;id&quot; of stateful hooks is just the stateful hook index.</span>
    <span class="s0">// This may change in the future with e.g. nested hooks.</span>
    <span class="s3">var </span><span class="s1">currentHook = fiber.memoizedState;</span>

    <span class="s3">while </span><span class="s1">(currentHook !== </span><span class="s3">null </span><span class="s1">&amp;&amp; id &gt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s1">currentHook = currentHook.next;</span>
      <span class="s1">id--;</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">currentHook;</span>
  <span class="s1">}; </span><span class="s0">// Support DevTools editable values for useState and useReducer.</span>

  <span class="s1">overrideHookState = </span><span class="s3">function</span><span class="s1">(fiber, id, path, value) {</span>
    <span class="s3">var </span><span class="s1">hook = findHook(fiber, id);</span>

    <span class="s3">if </span><span class="s1">(hook !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">newState = copyWithSet(hook.memoizedState, path, value);</span>
      <span class="s1">hook.memoizedState = newState;</span>
      <span class="s1">hook.baseState = newState; </span><span class="s0">// We aren't actually adding an update to the queue,</span>
      <span class="s0">// because there is no update we can add for useReducer hooks that won't trigger an error.</span>
      <span class="s0">// (There's no appropriate action type for DevTools overrides.)</span>
      <span class="s0">// As a result though, React will see the scheduled update as a noop and bailout.</span>
      <span class="s0">// Shallow cloning props works as a workaround for now to bypass the bailout check.</span>

      <span class="s1">fiber.memoizedProps = assign({}, fiber.memoizedProps);</span>
      <span class="s3">var </span><span class="s1">root = enqueueConcurrentRenderForLane(fiber, SyncLane);</span>

      <span class="s3">if </span><span class="s1">(root !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s1">overrideHookStateDeletePath = </span><span class="s3">function</span><span class="s1">(fiber, id, path) {</span>
    <span class="s3">var </span><span class="s1">hook = findHook(fiber, id);</span>

    <span class="s3">if </span><span class="s1">(hook !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">newState = copyWithDelete(hook.memoizedState, path);</span>
      <span class="s1">hook.memoizedState = newState;</span>
      <span class="s1">hook.baseState = newState; </span><span class="s0">// We aren't actually adding an update to the queue,</span>
      <span class="s0">// because there is no update we can add for useReducer hooks that won't trigger an error.</span>
      <span class="s0">// (There's no appropriate action type for DevTools overrides.)</span>
      <span class="s0">// As a result though, React will see the scheduled update as a noop and bailout.</span>
      <span class="s0">// Shallow cloning props works as a workaround for now to bypass the bailout check.</span>

      <span class="s1">fiber.memoizedProps = assign({}, fiber.memoizedProps);</span>
      <span class="s3">var </span><span class="s1">root = enqueueConcurrentRenderForLane(fiber, SyncLane);</span>

      <span class="s3">if </span><span class="s1">(root !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s1">overrideHookStateRenamePath = </span><span class="s3">function</span><span class="s1">(fiber, id, oldPath, newPath) {</span>
    <span class="s3">var </span><span class="s1">hook = findHook(fiber, id);</span>

    <span class="s3">if </span><span class="s1">(hook !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">newState = copyWithRename(hook.memoizedState, oldPath, newPath);</span>
      <span class="s1">hook.memoizedState = newState;</span>
      <span class="s1">hook.baseState = newState; </span><span class="s0">// We aren't actually adding an update to the queue,</span>
      <span class="s0">// because there is no update we can add for useReducer hooks that won't trigger an error.</span>
      <span class="s0">// (There's no appropriate action type for DevTools overrides.)</span>
      <span class="s0">// As a result though, React will see the scheduled update as a noop and bailout.</span>
      <span class="s0">// Shallow cloning props works as a workaround for now to bypass the bailout check.</span>

      <span class="s1">fiber.memoizedProps = assign({}, fiber.memoizedProps);</span>
      <span class="s3">var </span><span class="s1">root = enqueueConcurrentRenderForLane(fiber, SyncLane);</span>

      <span class="s3">if </span><span class="s1">(root !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}; </span><span class="s0">// Support DevTools props for function components, forwardRef, memo, host components, etc.</span>

  <span class="s1">overrideProps = </span><span class="s3">function</span><span class="s1">(fiber, path, value) {</span>
    <span class="s1">fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);</span>

    <span class="s3">if </span><span class="s1">(fiber.alternate) {</span>
      <span class="s1">fiber.alternate.pendingProps = fiber.pendingProps;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">root = enqueueConcurrentRenderForLane(fiber, SyncLane);</span>

    <span class="s3">if </span><span class="s1">(root !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s1">overridePropsDeletePath = </span><span class="s3">function</span><span class="s1">(fiber, path) {</span>
    <span class="s1">fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path);</span>

    <span class="s3">if </span><span class="s1">(fiber.alternate) {</span>
      <span class="s1">fiber.alternate.pendingProps = fiber.pendingProps;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">root = enqueueConcurrentRenderForLane(fiber, SyncLane);</span>

    <span class="s3">if </span><span class="s1">(root !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s1">overridePropsRenamePath = </span><span class="s3">function</span><span class="s1">(fiber, oldPath, newPath) {</span>
    <span class="s1">fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);</span>

    <span class="s3">if </span><span class="s1">(fiber.alternate) {</span>
      <span class="s1">fiber.alternate.pendingProps = fiber.pendingProps;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">root = enqueueConcurrentRenderForLane(fiber, SyncLane);</span>

    <span class="s3">if </span><span class="s1">(root !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s1">scheduleUpdate = </span><span class="s3">function</span><span class="s1">(fiber) {</span>
    <span class="s3">var </span><span class="s1">root = enqueueConcurrentRenderForLane(fiber, SyncLane);</span>

    <span class="s3">if </span><span class="s1">(root !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s1">setErrorHandler = </span><span class="s3">function</span><span class="s1">(newShouldErrorImpl) {</span>
    <span class="s1">shouldErrorImpl = newShouldErrorImpl;</span>
  <span class="s1">};</span>

  <span class="s1">setSuspenseHandler = </span><span class="s3">function</span><span class="s1">(newShouldSuspendImpl) {</span>
    <span class="s1">shouldSuspendImpl = newShouldSuspendImpl;</span>
  <span class="s1">};</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">findHostInstanceByFiber(fiber) {</span>
  <span class="s3">var </span><span class="s1">hostFiber = findCurrentHostFiber(fiber);</span>

  <span class="s3">if </span><span class="s1">(hostFiber === </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">hostFiber.stateNode;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">emptyFindFiberByHostInstance(instance) {</span>
  <span class="s3">return null</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">getCurrentFiberForDevTools() {</span>
  <span class="s3">return </span><span class="s1">current;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">injectIntoDevTools(devToolsConfig) {</span>
  <span class="s3">var </span><span class="s1">findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;</span>
  <span class="s3">var </span><span class="s1">ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;</span>
  <span class="s3">return </span><span class="s1">injectInternals({</span>
    <span class="s1">bundleType: devToolsConfig.bundleType,</span>
    <span class="s1">version: devToolsConfig.version,</span>
    <span class="s1">rendererPackageName: devToolsConfig.rendererPackageName,</span>
    <span class="s1">rendererConfig: devToolsConfig.rendererConfig,</span>
    <span class="s1">overrideHookState: overrideHookState,</span>
    <span class="s1">overrideHookStateDeletePath: overrideHookStateDeletePath,</span>
    <span class="s1">overrideHookStateRenamePath: overrideHookStateRenamePath,</span>
    <span class="s1">overrideProps: overrideProps,</span>
    <span class="s1">overridePropsDeletePath: overridePropsDeletePath,</span>
    <span class="s1">overridePropsRenamePath: overridePropsRenamePath,</span>
    <span class="s1">setErrorHandler: setErrorHandler,</span>
    <span class="s1">setSuspenseHandler: setSuspenseHandler,</span>
    <span class="s1">scheduleUpdate: scheduleUpdate,</span>
    <span class="s1">currentDispatcherRef: ReactCurrentDispatcher,</span>
    <span class="s1">findHostInstanceByFiber: findHostInstanceByFiber,</span>
    <span class="s1">findFiberByHostInstance:</span>
      <span class="s1">findFiberByHostInstance || emptyFindFiberByHostInstance,</span>
    <span class="s0">// React Refresh</span>
    <span class="s1">findHostInstancesForRefresh: findHostInstancesForRefresh,</span>
    <span class="s1">scheduleRefresh: scheduleRefresh,</span>
    <span class="s1">scheduleRoot: scheduleRoot,</span>
    <span class="s1">setRefreshHandler: setRefreshHandler,</span>
    <span class="s0">// Enables DevTools to append owner stacks to error messages in DEV mode.</span>
    <span class="s1">getCurrentFiber: getCurrentFiberForDevTools,</span>
    <span class="s0">// Enables DevTools to detect reconciler version rather than renderer version</span>
    <span class="s0">// which may not match for third party renderers.</span>
    <span class="s1">reconcilerVersion: ReactVersion</span>
  <span class="s1">});</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">instanceCache = </span><span class="s3">new </span><span class="s1">Map();</span>

<span class="s3">function </span><span class="s1">getInstanceFromTag(tag) {</span>
  <span class="s3">return </span><span class="s1">instanceCache.get(tag) || </span><span class="s3">null</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">emptyObject$1 = {};</span>

<span class="s1">{</span>
  <span class="s1">Object.freeze(emptyObject$1);</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">createHierarchy;</span>
<span class="s3">var </span><span class="s1">getHostNode;</span>
<span class="s3">var </span><span class="s1">getHostProps;</span>
<span class="s3">var </span><span class="s1">lastNonHostInstance;</span>

<span class="s3">var </span><span class="s1">getOwnerHierarchy;</span>
<span class="s3">var </span><span class="s1">traverseOwnerTreeUp;</span>

<span class="s1">{</span>
  <span class="s1">createHierarchy = </span><span class="s3">function</span><span class="s1">(fiberHierarchy) {</span>
    <span class="s3">return </span><span class="s1">fiberHierarchy.map(</span><span class="s3">function</span><span class="s1">(fiber) {</span>
      <span class="s3">return </span><span class="s1">{</span>
        <span class="s1">name: getComponentNameFromType(fiber.type),</span>
        <span class="s1">getInspectorData: </span><span class="s3">function</span><span class="s1">(findNodeHandle) {</span>
          <span class="s3">return </span><span class="s1">{</span>
            <span class="s1">props: getHostProps(fiber),</span>
            <span class="s1">source: fiber._debugSource,</span>
            <span class="s1">measure: </span><span class="s3">function</span><span class="s1">(callback) {</span>
              <span class="s0">// If this is Fabric, we'll find a ShadowNode and use that to measure.</span>
              <span class="s3">var </span><span class="s1">hostFiber = findCurrentHostFiber(fiber);</span>
              <span class="s3">var </span><span class="s1">shadowNode =</span>
                <span class="s1">hostFiber != </span><span class="s3">null </span><span class="s1">&amp;&amp;</span>
                <span class="s1">hostFiber.stateNode !== </span><span class="s3">null </span><span class="s1">&amp;&amp;</span>
                <span class="s1">hostFiber.stateNode.node;</span>

              <span class="s3">if </span><span class="s1">(shadowNode) {</span>
                <span class="s1">nativeFabricUIManager.measure(shadowNode, callback);</span>
              <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s3">return </span><span class="s1">ReactNativePrivateInterface.UIManager.measure(</span>
                  <span class="s1">getHostNode(fiber, findNodeHandle),</span>
                  <span class="s1">callback</span>
                <span class="s1">);</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s1">};</span>
        <span class="s1">}</span>
      <span class="s1">};</span>
    <span class="s1">});</span>
  <span class="s1">};</span>

  <span class="s1">getHostNode = </span><span class="s3">function</span><span class="s1">(fiber, findNodeHandle) {</span>
    <span class="s3">var </span><span class="s1">hostNode; </span><span class="s0">// look for children first for the hostNode</span>
    <span class="s0">// as composite fibers do not have a hostNode</span>

    <span class="s3">while </span><span class="s1">(fiber) {</span>
      <span class="s3">if </span><span class="s1">(fiber.stateNode !== </span><span class="s3">null </span><span class="s1">&amp;&amp; fiber.tag === HostComponent) {</span>
        <span class="s1">hostNode = findNodeHandle(fiber.stateNode);</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(hostNode) {</span>
        <span class="s3">return </span><span class="s1">hostNode;</span>
      <span class="s1">}</span>

      <span class="s1">fiber = fiber.child;</span>
    <span class="s1">}</span>

    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">};</span>

  <span class="s1">getHostProps = </span><span class="s3">function</span><span class="s1">(fiber) {</span>
    <span class="s3">var </span><span class="s1">host = findCurrentHostFiber(fiber);</span>

    <span class="s3">if </span><span class="s1">(host) {</span>
      <span class="s3">return </span><span class="s1">host.memoizedProps || emptyObject$1;</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">emptyObject$1;</span>
  <span class="s1">};</span>

  <span class="s1">exports.getInspectorDataForInstance = </span><span class="s3">function</span><span class="s1">(closestInstance) {</span>
    <span class="s0">// Handle case where user clicks outside of ReactNative</span>
    <span class="s3">if </span><span class="s1">(!closestInstance) {</span>
      <span class="s3">return </span><span class="s1">{</span>
        <span class="s1">hierarchy: [],</span>
        <span class="s1">props: emptyObject$1,</span>
        <span class="s1">selectedIndex: </span><span class="s3">null</span><span class="s1">,</span>
        <span class="s1">source: </span><span class="s3">null</span>
      <span class="s1">};</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">fiber = findCurrentFiberUsingSlowPath(closestInstance);</span>
    <span class="s3">var </span><span class="s1">fiberHierarchy = getOwnerHierarchy(fiber);</span>
    <span class="s3">var </span><span class="s1">instance = lastNonHostInstance(fiberHierarchy);</span>
    <span class="s3">var </span><span class="s1">hierarchy = createHierarchy(fiberHierarchy);</span>
    <span class="s3">var </span><span class="s1">props = getHostProps(instance);</span>
    <span class="s3">var </span><span class="s1">source = instance._debugSource;</span>
    <span class="s3">var </span><span class="s1">selectedIndex = fiberHierarchy.indexOf(instance);</span>
    <span class="s3">return </span><span class="s1">{</span>
      <span class="s1">hierarchy: hierarchy,</span>
      <span class="s1">props: props,</span>
      <span class="s1">selectedIndex: selectedIndex,</span>
      <span class="s1">source: source</span>
    <span class="s1">};</span>
  <span class="s1">};</span>

  <span class="s1">getOwnerHierarchy = </span><span class="s3">function</span><span class="s1">(instance) {</span>
    <span class="s3">var </span><span class="s1">hierarchy = [];</span>
    <span class="s1">traverseOwnerTreeUp(hierarchy, instance);</span>
    <span class="s3">return </span><span class="s1">hierarchy;</span>
  <span class="s1">};</span>

  <span class="s1">lastNonHostInstance = </span><span class="s3">function</span><span class="s1">(hierarchy) {</span>
    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = hierarchy.length - </span><span class="s4">1</span><span class="s1">; i &gt; </span><span class="s4">1</span><span class="s1">; i--) {</span>
      <span class="s3">var </span><span class="s1">instance = hierarchy[i];</span>

      <span class="s3">if </span><span class="s1">(instance.tag !== HostComponent) {</span>
        <span class="s3">return </span><span class="s1">instance;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">hierarchy[</span><span class="s4">0</span><span class="s1">];</span>
  <span class="s1">};</span>

  <span class="s1">traverseOwnerTreeUp = </span><span class="s3">function</span><span class="s1">(hierarchy, instance) {</span>
    <span class="s3">if </span><span class="s1">(instance) {</span>
      <span class="s1">hierarchy.unshift(instance);</span>
      <span class="s1">traverseOwnerTreeUp(hierarchy, instance._debugOwner);</span>
    <span class="s1">}</span>
  <span class="s1">};</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">getInspectorDataForViewTag;</span>
<span class="s3">var </span><span class="s1">getInspectorDataForViewAtPoint;</span>

<span class="s1">{</span>
  <span class="s1">getInspectorDataForViewTag = </span><span class="s3">function</span><span class="s1">(viewTag) {</span>
    <span class="s3">var </span><span class="s1">closestInstance = getInstanceFromTag(viewTag); </span><span class="s0">// Handle case where user clicks outside of ReactNative</span>

    <span class="s3">if </span><span class="s1">(!closestInstance) {</span>
      <span class="s3">return </span><span class="s1">{</span>
        <span class="s1">hierarchy: [],</span>
        <span class="s1">props: emptyObject$1,</span>
        <span class="s1">selectedIndex: </span><span class="s3">null</span><span class="s1">,</span>
        <span class="s1">source: </span><span class="s3">null</span>
      <span class="s1">};</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">fiber = findCurrentFiberUsingSlowPath(closestInstance);</span>
    <span class="s3">var </span><span class="s1">fiberHierarchy = getOwnerHierarchy(fiber);</span>
    <span class="s3">var </span><span class="s1">instance = lastNonHostInstance(fiberHierarchy);</span>
    <span class="s3">var </span><span class="s1">hierarchy = createHierarchy(fiberHierarchy);</span>
    <span class="s3">var </span><span class="s1">props = getHostProps(instance);</span>
    <span class="s3">var </span><span class="s1">source = instance._debugSource;</span>
    <span class="s3">var </span><span class="s1">selectedIndex = fiberHierarchy.indexOf(instance);</span>
    <span class="s3">return </span><span class="s1">{</span>
      <span class="s1">hierarchy: hierarchy,</span>
      <span class="s1">props: props,</span>
      <span class="s1">selectedIndex: selectedIndex,</span>
      <span class="s1">source: source</span>
    <span class="s1">};</span>
  <span class="s1">};</span>

  <span class="s1">getInspectorDataForViewAtPoint = </span><span class="s3">function</span><span class="s1">(</span>
    <span class="s1">findNodeHandle,</span>
    <span class="s1">inspectedView,</span>
    <span class="s1">locationX,</span>
    <span class="s1">locationY,</span>
    <span class="s1">callback</span>
  <span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">closestInstance = </span><span class="s3">null</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s1">(inspectedView._internalInstanceHandle != </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// For Fabric we can look up the instance handle directly and measure it.</span>
      <span class="s1">nativeFabricUIManager.findNodeAtPoint(</span>
        <span class="s1">inspectedView._internalInstanceHandle.stateNode.node,</span>
        <span class="s1">locationX,</span>
        <span class="s1">locationY,</span>
        <span class="s3">function</span><span class="s1">(internalInstanceHandle) {</span>
          <span class="s3">if </span><span class="s1">(internalInstanceHandle == </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s1">callback(</span>
              <span class="s1">assign(</span>
                <span class="s1">{</span>
                  <span class="s1">pointerY: locationY,</span>
                  <span class="s1">frame: {</span>
                    <span class="s1">left: </span><span class="s4">0</span><span class="s1">,</span>
                    <span class="s1">top: </span><span class="s4">0</span><span class="s1">,</span>
                    <span class="s1">width: </span><span class="s4">0</span><span class="s1">,</span>
                    <span class="s1">height: </span><span class="s4">0</span>
                  <span class="s1">}</span>
                <span class="s1">},</span>
                <span class="s1">exports.getInspectorDataForInstance(closestInstance)</span>
              <span class="s1">)</span>
            <span class="s1">);</span>
          <span class="s1">}</span>

          <span class="s1">closestInstance =</span>
            <span class="s1">internalInstanceHandle.stateNode.canonical._internalInstanceHandle; </span><span class="s0">// Note: this is deprecated and we want to remove it ASAP. Keeping it here for React DevTools compatibility for now.</span>

          <span class="s3">var </span><span class="s1">nativeViewTag =</span>
            <span class="s1">internalInstanceHandle.stateNode.canonical._nativeTag;</span>
          <span class="s1">nativeFabricUIManager.measure(</span>
            <span class="s1">internalInstanceHandle.stateNode.node,</span>
            <span class="s3">function</span><span class="s1">(x, y, width, height, pageX, pageY) {</span>
              <span class="s3">var </span><span class="s1">inspectorData = exports.getInspectorDataForInstance(</span>
                <span class="s1">closestInstance</span>
              <span class="s1">);</span>
              <span class="s1">callback(</span>
                <span class="s1">assign({}, inspectorData, {</span>
                  <span class="s1">pointerY: locationY,</span>
                  <span class="s1">frame: {</span>
                    <span class="s1">left: pageX,</span>
                    <span class="s1">top: pageY,</span>
                    <span class="s1">width: width,</span>
                    <span class="s1">height: height</span>
                  <span class="s1">},</span>
                  <span class="s1">touchedViewTag: nativeViewTag</span>
                <span class="s1">})</span>
              <span class="s1">);</span>
            <span class="s1">}</span>
          <span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">);</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(inspectedView._internalFiberInstanceHandleDEV != </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// For Paper we fall back to the old strategy using the React tag.</span>
      <span class="s1">ReactNativePrivateInterface.UIManager.findSubviewIn(</span>
        <span class="s1">findNodeHandle(inspectedView),</span>
        <span class="s1">[locationX, locationY],</span>
        <span class="s3">function</span><span class="s1">(nativeViewTag, left, top, width, height) {</span>
          <span class="s3">var </span><span class="s1">inspectorData = exports.getInspectorDataForInstance(</span>
            <span class="s1">getInstanceFromTag(nativeViewTag)</span>
          <span class="s1">);</span>
          <span class="s1">callback(</span>
            <span class="s1">assign({}, inspectorData, {</span>
              <span class="s1">pointerY: locationY,</span>
              <span class="s1">frame: {</span>
                <span class="s1">left: left,</span>
                <span class="s1">top: top,</span>
                <span class="s1">width: width,</span>
                <span class="s1">height: height</span>
              <span class="s1">},</span>
              <span class="s1">touchedViewTag: nativeViewTag</span>
            <span class="s1">})</span>
          <span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">error(</span>
        <span class="s2">&quot;getInspectorDataForViewAtPoint expects to receive a host component&quot;</span>
      <span class="s1">);</span>

      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">};</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;</span>

<span class="s3">function </span><span class="s1">findHostInstance_DEPRECATED(componentOrHandle) {</span>
  <span class="s1">{</span>
    <span class="s3">var </span><span class="s1">owner = ReactCurrentOwner$3.current;</span>

    <span class="s3">if </span><span class="s1">(owner !== </span><span class="s3">null </span><span class="s1">&amp;&amp; owner.stateNode !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(!owner.stateNode._warnedAboutRefsInRender) {</span>
        <span class="s1">error(</span>
          <span class="s2">&quot;%s is accessing findNodeHandle inside its render(). &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;render() should be a pure function of props and state. It should &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;never access something that requires stale data from the previous &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;render, such as refs. Move this logic to componentDidMount and &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;componentDidUpdate instead.&quot;</span><span class="s1">,</span>
          <span class="s1">getComponentNameFromType(owner.type) || </span><span class="s2">&quot;A component&quot;</span>
        <span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s1">owner.stateNode._warnedAboutRefsInRender = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(componentOrHandle == </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s0">// $FlowIssue Flow has hardcoded values for React DOM that don't work with RN</span>

  <span class="s3">if </span><span class="s1">(componentOrHandle._nativeTag) {</span>
    <span class="s0">// $FlowIssue Flow has hardcoded values for React DOM that don't work with RN</span>
    <span class="s3">return </span><span class="s1">componentOrHandle;</span>
  <span class="s1">} </span><span class="s0">// $FlowIssue Flow has hardcoded values for React DOM that don't work with RN</span>

  <span class="s3">if </span><span class="s1">(componentOrHandle.canonical &amp;&amp; componentOrHandle.canonical._nativeTag) {</span>
    <span class="s0">// $FlowIssue Flow has hardcoded values for React DOM that don't work with RN</span>
    <span class="s3">return </span><span class="s1">componentOrHandle.canonical;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">hostInstance;</span>

  <span class="s1">{</span>
    <span class="s1">hostInstance = findHostInstanceWithWarning(</span>
      <span class="s1">componentOrHandle,</span>
      <span class="s2">&quot;findHostInstance_DEPRECATED&quot;</span>
    <span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(hostInstance == </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">return </span><span class="s1">hostInstance;</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(hostInstance.canonical) {</span>
    <span class="s0">// Fabric</span>
    <span class="s3">return </span><span class="s1">hostInstance.canonical;</span>
  <span class="s1">} </span><span class="s0">// $FlowFixMe[incompatible-return]</span>

  <span class="s3">return </span><span class="s1">hostInstance;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">findNodeHandle(componentOrHandle) {</span>
  <span class="s1">{</span>
    <span class="s3">var </span><span class="s1">owner = ReactCurrentOwner$3.current;</span>

    <span class="s3">if </span><span class="s1">(owner !== </span><span class="s3">null </span><span class="s1">&amp;&amp; owner.stateNode !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(!owner.stateNode._warnedAboutRefsInRender) {</span>
        <span class="s1">error(</span>
          <span class="s2">&quot;%s is accessing findNodeHandle inside its render(). &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;render() should be a pure function of props and state. It should &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;never access something that requires stale data from the previous &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;render, such as refs. Move this logic to componentDidMount and &quot; </span><span class="s1">+</span>
            <span class="s2">&quot;componentDidUpdate instead.&quot;</span><span class="s1">,</span>
          <span class="s1">getComponentNameFromType(owner.type) || </span><span class="s2">&quot;A component&quot;</span>
        <span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s1">owner.stateNode._warnedAboutRefsInRender = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(componentOrHandle == </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">componentOrHandle === </span><span class="s2">&quot;number&quot;</span><span class="s1">) {</span>
    <span class="s0">// Already a node handle</span>
    <span class="s3">return </span><span class="s1">componentOrHandle;</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(componentOrHandle._nativeTag) {</span>
    <span class="s3">return </span><span class="s1">componentOrHandle._nativeTag;</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(componentOrHandle.canonical &amp;&amp; componentOrHandle.canonical._nativeTag) {</span>
    <span class="s3">return </span><span class="s1">componentOrHandle.canonical._nativeTag;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">hostInstance;</span>

  <span class="s1">{</span>
    <span class="s1">hostInstance = findHostInstanceWithWarning(</span>
      <span class="s1">componentOrHandle,</span>
      <span class="s2">&quot;findNodeHandle&quot;</span>
    <span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(hostInstance == </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">return </span><span class="s1">hostInstance;</span>
  <span class="s1">} </span><span class="s0">// TODO: the code is right but the types here are wrong.</span>
  <span class="s0">// https://github.com/facebook/react/pull/12863</span>

  <span class="s3">if </span><span class="s1">(hostInstance.canonical) {</span>
    <span class="s0">// Fabric</span>
    <span class="s3">return </span><span class="s1">hostInstance.canonical._nativeTag;</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">hostInstance._nativeTag;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">dispatchCommand(handle, command, args) {</span>
  <span class="s3">if </span><span class="s1">(handle._nativeTag == </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s1">{</span>
      <span class="s1">error(</span>
        <span class="s2">&quot;dispatchCommand was called with a ref that isn't a &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;native component. Use React.forwardRef to get access to the underlying native component&quot;</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">return</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(handle._internalInstanceHandle != </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">stateNode = handle._internalInstanceHandle.stateNode;</span>

    <span class="s3">if </span><span class="s1">(stateNode != </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">nativeFabricUIManager.dispatchCommand(stateNode.node, command, args);</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">ReactNativePrivateInterface.UIManager.dispatchViewManagerCommand(</span>
      <span class="s1">handle._nativeTag,</span>
      <span class="s1">command,</span>
      <span class="s1">args</span>
    <span class="s1">);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">sendAccessibilityEvent(handle, eventType) {</span>
  <span class="s3">if </span><span class="s1">(handle._nativeTag == </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s1">{</span>
      <span class="s1">error(</span>
        <span class="s2">&quot;sendAccessibilityEvent was called with a ref that isn't a &quot; </span><span class="s1">+</span>
          <span class="s2">&quot;native component. Use React.forwardRef to get access to the underlying native component&quot;</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">return</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(handle._internalInstanceHandle != </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">stateNode = handle._internalInstanceHandle.stateNode;</span>

    <span class="s3">if </span><span class="s1">(stateNode != </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">nativeFabricUIManager.sendAccessibilityEvent(stateNode.node, eventType);</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">ReactNativePrivateInterface.legacySendAccessibilityEvent(</span>
      <span class="s1">handle._nativeTag,</span>
      <span class="s1">eventType</span>
    <span class="s1">);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">onRecoverableError(error$1) {</span>
  <span class="s0">// TODO: Expose onRecoverableError option to userspace</span>
  <span class="s0">// eslint-disable-next-line react-internal/no-production-logging, react-internal/warning-args</span>
  <span class="s1">error(error$1);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">render(element, containerTag, callback, concurrentRoot) {</span>
  <span class="s3">var </span><span class="s1">root = roots.get(containerTag);</span>

  <span class="s3">if </span><span class="s1">(!root) {</span>
    <span class="s0">// TODO (bvaughn): If we decide to keep the wrapper component,</span>
    <span class="s0">// We could create a wrapper for containerTag as well to reduce special casing.</span>
    <span class="s1">root = createContainer(</span>
      <span class="s1">containerTag,</span>
      <span class="s1">concurrentRoot ? ConcurrentRoot : LegacyRoot,</span>
      <span class="s3">null</span><span class="s1">,</span>
      <span class="s3">false</span><span class="s1">,</span>
      <span class="s3">null</span><span class="s1">,</span>
      <span class="s2">&quot;&quot;</span><span class="s1">,</span>
      <span class="s1">onRecoverableError</span>
    <span class="s1">);</span>
    <span class="s1">roots.set(containerTag, root);</span>
  <span class="s1">}</span>

  <span class="s1">updateContainer(element, root, </span><span class="s3">null</span><span class="s1">, callback); </span><span class="s0">// $FlowIssue Flow has hardcoded values for React DOM that don't work with RN</span>

  <span class="s3">return </span><span class="s1">getPublicRootInstance(root);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">unmountComponentAtNode(containerTag) {</span>
  <span class="s3">this</span><span class="s1">.stopSurface(containerTag);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">stopSurface(containerTag) {</span>
  <span class="s3">var </span><span class="s1">root = roots.get(containerTag);</span>

  <span class="s3">if </span><span class="s1">(root) {</span>
    <span class="s0">// TODO: Is it safe to reset this now or should I wait since this unmount could be deferred?</span>
    <span class="s1">updateContainer(</span><span class="s3">null</span><span class="s1">, root, </span><span class="s3">null</span><span class="s1">, </span><span class="s3">function</span><span class="s1">() {</span>
      <span class="s1">roots.</span><span class="s3">delete</span><span class="s1">(containerTag);</span>
    <span class="s1">});</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">createPortal$1(children, containerTag) {</span>
  <span class="s3">var </span><span class="s1">key =</span>
    <span class="s1">arguments.length &gt; </span><span class="s4">2 </span><span class="s1">&amp;&amp; arguments[</span><span class="s4">2</span><span class="s1">] !== undefined ? arguments[</span><span class="s4">2</span><span class="s1">] : </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">return </span><span class="s1">createPortal(children, containerTag, </span><span class="s3">null</span><span class="s1">, key);</span>
<span class="s1">}</span>

<span class="s1">setBatchingImplementation(batchedUpdates$1);</span>
<span class="s3">var </span><span class="s1">roots = </span><span class="s3">new </span><span class="s1">Map();</span>
<span class="s1">injectIntoDevTools({</span>
  <span class="s1">findFiberByHostInstance: getInstanceFromInstance,</span>
  <span class="s1">bundleType: </span><span class="s4">1</span><span class="s1">,</span>
  <span class="s1">version: ReactVersion,</span>
  <span class="s1">rendererPackageName: </span><span class="s2">&quot;react-native-renderer&quot;</span><span class="s1">,</span>
  <span class="s1">rendererConfig: {</span>
    <span class="s1">getInspectorDataForViewTag: getInspectorDataForViewTag,</span>
    <span class="s1">getInspectorDataForViewAtPoint: getInspectorDataForViewAtPoint.bind(</span>
      <span class="s3">null</span><span class="s1">,</span>
      <span class="s1">findNodeHandle</span>
    <span class="s1">)</span>
  <span class="s1">}</span>
<span class="s1">});</span>

<span class="s1">exports.createPortal = createPortal$1;</span>
<span class="s1">exports.dispatchCommand = dispatchCommand;</span>
<span class="s1">exports.findHostInstance_DEPRECATED = findHostInstance_DEPRECATED;</span>
<span class="s1">exports.findNodeHandle = findNodeHandle;</span>
<span class="s1">exports.render = render;</span>
<span class="s1">exports.sendAccessibilityEvent = sendAccessibilityEvent;</span>
<span class="s1">exports.stopSurface = stopSurface;</span>
<span class="s1">exports.unmountComponentAtNode = unmountComponentAtNode;</span>

          <span class="s0">/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */</span>
<span class="s3">if </span><span class="s1">(</span>
  <span class="s3">typeof </span><span class="s1">__REACT_DEVTOOLS_GLOBAL_HOOK__ !== </span><span class="s2">'undefined' </span><span class="s1">&amp;&amp;</span>
  <span class="s3">typeof </span><span class="s1">__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop ===</span>
    <span class="s2">'function'</span>
<span class="s1">) {</span>
  <span class="s1">__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(</span><span class="s3">new </span><span class="s1">Error());</span>
<span class="s1">}</span>
        
  <span class="s1">})();</span>
<span class="s1">}</span>
</pre>
</body>
</html>
<html>
<head>
<title>NativeAnimatedModule.java</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #77b767; font-style: italic;}
.s5 { color: #629755; font-weight: bold; font-style: italic;}
.s6 { color: #6897bb;}
.s7 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
NativeAnimatedModule.java</font>
</center></td></tr></table>
<pre><span class="s0">/* 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>

<span class="s2">package </span><span class="s1">com.facebook.react.animated</span><span class="s2">;</span>

<span class="s2">import </span><span class="s1">androidx.annotation.AnyThread</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">androidx.annotation.NonNull</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">androidx.annotation.Nullable</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">androidx.annotation.UiThread</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.common.logging.FLog</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.fbreact.specs.NativeAnimatedModuleSpec</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.infer.annotation.Assertions</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.Arguments</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.Callback</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.LifecycleEventListener</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.ReactApplicationContext</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.ReactSoftExceptionLogger</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.ReadableArray</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.ReadableMap</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.UIManager</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.UIManagerListener</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.WritableMap</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.common.annotations.VisibleForTesting</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.module.annotations.ReactModule</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.modules.core.ReactChoreographer</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.GuardedFrameCallback</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.NativeViewHierarchyManager</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.UIBlock</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.UIManagerHelper</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.UIManagerModule</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.common.UIManagerType</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.common.ViewUtil</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.ArrayList</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.List</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.Queue</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.concurrent.ConcurrentLinkedQueue</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.concurrent.atomic.AtomicReference</span><span class="s2">;</span>

<span class="s3">/**</span>
 <span class="s3">* Module that exposes interface for creating and managing animated nodes on the &quot;native&quot; side.</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s4">&lt;p&gt;</span><span class="s3">Animated.js library is based on a concept of a graph where nodes are values or transform</span>
 <span class="s3">* operations (such as interpolation, addition, etc) and connection are used to describe how change</span>
 <span class="s3">* of the value in one node can affect other nodes.</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s4">&lt;p&gt;</span><span class="s3">Few examples of the nodes that can be created on the JS side:</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s4">&lt;ul&gt;</span>
 <span class="s3">*   </span><span class="s4">&lt;li&gt;</span><span class="s3">Animated.Value is a simplest type of node with a numeric value which can be driven by an</span>
 <span class="s3">*       animation engine (spring, decay, etc) or by calling setValue on it directly from JS</span>
 <span class="s3">*   </span><span class="s4">&lt;li&gt;</span><span class="s3">Animated.add is a type of node that may have two or more input nodes. It outputs the sum of</span>
 <span class="s3">*       all the input node values</span>
 <span class="s3">*   </span><span class="s4">&lt;li&gt;</span><span class="s3">interpolate - is actually a method you can call on any node and it creates a new node that</span>
 <span class="s3">*       takes the parent node as an input and outputs its interpolated value (e.g. if you have</span>
 <span class="s3">*       value that can animate from 0 to 1 you can create interpolated node and set output range to</span>
 <span class="s3">*       be 0 to 100 and when the input node changes the output of interpolated node will multiply</span>
 <span class="s3">*       the values by 100)</span>
 <span class="s3">* </span><span class="s4">&lt;/ul&gt;</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s4">&lt;p&gt;</span><span class="s3">You can mix and chain nodes however you like and this way create nodes graph with connections</span>
 <span class="s3">* between them.</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s4">&lt;p&gt;</span><span class="s3">To map animated node values to view properties there is a special type of a node:</span>
 <span class="s3">* AnimatedProps. It is created by AnimatedImplementation whenever you render Animated.View and</span>
 <span class="s3">* stores a mapping from the view properties to the corresponding animated values (so it's actually</span>
 <span class="s3">* also a node with connections to the value nodes).</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s4">&lt;p&gt;</span><span class="s3">Last &quot;special&quot; elements of the graph are &quot;animation drivers&quot;. Those are objects (represented</span>
 <span class="s3">* as a graph nodes too) that based on some criteria updates attached values every frame (we have</span>
 <span class="s3">* few types of those, e.g., spring, timing, decay). Animation objects can be &quot;started&quot; and</span>
 <span class="s3">* &quot;stopped&quot;. Those are like &quot;pulse generators&quot; for the rest of the nodes graph. Those pulses then</span>
 <span class="s3">* propagate along the graph to the children nodes up to the special node type: AnimatedProps which</span>
 <span class="s3">* then can be used to calculate property update map for a view.</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s4">&lt;p&gt;</span><span class="s3">This class acts as a proxy between the &quot;native&quot; API that can be called from JS and the main</span>
 <span class="s3">* class that coordinates all the action: {</span><span class="s5">@link </span><span class="s3">NativeAnimatedNodesManager}. Since all the methods</span>
 <span class="s3">* from {</span><span class="s5">@link </span><span class="s3">NativeAnimatedNodesManager} need to be called from the UI thread, we we create a</span>
 <span class="s3">* queue of animated graph operations that is then enqueued to be executed in the UI Thread at the</span>
 <span class="s3">* end of the batch of JS-&gt;native calls (similarly to how it's handled in {</span><span class="s5">@link </span><span class="s3">UIManagerModule}).</span>
 <span class="s3">* This isolates us from the problems that may be caused by concurrent updates of animated graph</span>
 <span class="s3">* while UI thread is &quot;executing&quot; the animation loop.</span>
 <span class="s3">*/</span>
<span class="s1">@ReactModule(name = NativeAnimatedModuleSpec.NAME)</span>
<span class="s2">public class </span><span class="s1">NativeAnimatedModule </span><span class="s2">extends </span><span class="s1">NativeAnimatedModuleSpec</span>
    <span class="s2">implements </span><span class="s1">LifecycleEventListener</span><span class="s2">, </span><span class="s1">UIManagerListener {</span>

  <span class="s2">public static final boolean </span><span class="s1">ANIMATED_MODULE_DEBUG = </span><span class="s2">false;</span>

  <span class="s0">// For `queueAndExecuteBatchedOperations`</span>
  <span class="s2">private enum </span><span class="s1">BatchExecutionOpCodes {</span>
    <span class="s1">OP_CODE_CREATE_ANIMATED_NODE(</span><span class="s6">1</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">OP_CODE_UPDATE_ANIMATED_NODE_CONFIG(</span><span class="s6">2</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">OP_CODE_GET_VALUE(</span><span class="s6">3</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">OP_START_LISTENING_TO_ANIMATED_NODE_VALUE(</span><span class="s6">4</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">OP_STOP_LISTENING_TO_ANIMATED_NODE_VALUE(</span><span class="s6">5</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">OP_CODE_CONNECT_ANIMATED_NODES(</span><span class="s6">6</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">OP_CODE_DISCONNECT_ANIMATED_NODES(</span><span class="s6">7</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">OP_CODE_START_ANIMATING_NODE(</span><span class="s6">8</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">OP_CODE_STOP_ANIMATION(</span><span class="s6">9</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">OP_CODE_SET_ANIMATED_NODE_VALUE(</span><span class="s6">10</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">OP_CODE_SET_ANIMATED_NODE_OFFSET(</span><span class="s6">11</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">OP_CODE_FLATTEN_ANIMATED_NODE_OFFSET(</span><span class="s6">12</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">OP_CODE_EXTRACT_ANIMATED_NODE_OFFSET(</span><span class="s6">13</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">OP_CODE_CONNECT_ANIMATED_NODE_TO_VIEW(</span><span class="s6">14</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">OP_CODE_DISCONNECT_ANIMATED_NODE_FROM_VIEW(</span><span class="s6">15</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">OP_CODE_RESTORE_DEFAULT_VALUES(</span><span class="s6">16</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">OP_CODE_DROP_ANIMATED_NODE(</span><span class="s6">17</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">OP_CODE_ADD_ANIMATED_EVENT_TO_VIEW(</span><span class="s6">18</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">OP_CODE_REMOVE_ANIMATED_EVENT_FROM_VIEW(</span><span class="s6">19</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">OP_CODE_ADD_LISTENER(</span><span class="s6">20</span><span class="s1">)</span><span class="s2">, </span><span class="s0">// ios only</span>
    <span class="s1">OP_CODE_REMOVE_LISTENERS(</span><span class="s6">21</span><span class="s1">)</span><span class="s2">; </span><span class="s0">// ios only</span>

    <span class="s2">private static </span><span class="s1">BatchExecutionOpCodes[] valueMap = </span><span class="s2">null;</span>
    <span class="s2">private final int </span><span class="s1">value</span><span class="s2">;</span>

    <span class="s2">private </span><span class="s1">BatchExecutionOpCodes(</span><span class="s2">int </span><span class="s1">value) {</span>
      <span class="s2">this</span><span class="s1">.value = value</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">public int </span><span class="s1">getValue() {</span>
      <span class="s2">return this</span><span class="s1">.value</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">public static </span><span class="s1">BatchExecutionOpCodes fromId(</span><span class="s2">int </span><span class="s1">id) {</span>
      <span class="s2">if </span><span class="s1">(BatchExecutionOpCodes.valueMap == </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">BatchExecutionOpCodes.valueMap = BatchExecutionOpCodes.values()</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s0">// Enum values are 1-indexed, but the value array is 0-indexed</span>
      <span class="s2">return </span><span class="s1">BatchExecutionOpCodes.valueMap[id - </span><span class="s6">1</span><span class="s1">]</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">private abstract class </span><span class="s1">UIThreadOperation {</span>
    <span class="s2">abstract void </span><span class="s1">execute(NativeAnimatedNodesManager animatedNodesManager)</span><span class="s2">;</span>

    <span class="s2">long </span><span class="s1">mBatchNumber = -</span><span class="s6">1</span><span class="s2">;</span>

    <span class="s2">public void </span><span class="s1">setBatchNumber(</span><span class="s2">long </span><span class="s1">batchNumber) {</span>
      <span class="s1">mBatchNumber = batchNumber</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">public long </span><span class="s1">getBatchNumber() {</span>
      <span class="s2">return </span><span class="s1">mBatchNumber</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">private class </span><span class="s1">ConcurrentOperationQueue {</span>
    <span class="s2">private final </span><span class="s1">Queue&lt;UIThreadOperation&gt; mQueue = </span><span class="s2">new </span><span class="s1">ConcurrentLinkedQueue&lt;&gt;()</span><span class="s2">;</span>
    <span class="s1">@Nullable </span><span class="s2">private </span><span class="s1">UIThreadOperation mPeekedOperation = </span><span class="s2">null;</span>

    <span class="s1">@AnyThread</span>
    <span class="s2">boolean </span><span class="s1">isEmpty() {</span>
      <span class="s2">return </span><span class="s1">mQueue.isEmpty() &amp;&amp; mPeekedOperation == </span><span class="s2">null;</span>
    <span class="s1">}</span>

    <span class="s1">@AnyThread</span>
    <span class="s2">void </span><span class="s1">add(UIThreadOperation operation) {</span>
      <span class="s1">mQueue.add(operation)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">@UiThread</span>
    <span class="s2">void </span><span class="s1">executeBatch(</span><span class="s2">long </span><span class="s1">maxBatchNumber</span><span class="s2">, </span><span class="s1">NativeAnimatedNodesManager nodesManager) {</span>
      <span class="s1">List&lt;UIThreadOperation&gt; operations</span><span class="s2">;</span>
      <span class="s1">operations = drainQueueIntoList(maxBatchNumber)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(operations != </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">for </span><span class="s1">(UIThreadOperation operation : operations) {</span>
          <span class="s1">operation.execute(nodesManager)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">@UiThread</span>
    <span class="s2">private </span><span class="s1">@Nullable List&lt;UIThreadOperation&gt; drainQueueIntoList(</span><span class="s2">long </span><span class="s1">maxBatchNumber) {</span>
      <span class="s2">if </span><span class="s1">(isEmpty()) {</span>
        <span class="s2">return null;</span>
      <span class="s1">}</span>

      <span class="s1">List&lt;UIThreadOperation&gt; operations = </span><span class="s2">new </span><span class="s1">ArrayList&lt;&gt;()</span><span class="s2">;</span>
      <span class="s2">while </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s0">// Due to a race condition, we manually &quot;carry-over&quot; a polled item from previous batch</span>
        <span class="s0">// instead of peeking the queue itself for consistency.</span>
        <span class="s0">// TODO(T112522554): Clean up the queue access</span>
        <span class="s2">if </span><span class="s1">(mPeekedOperation != </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s2">if </span><span class="s1">(mPeekedOperation.getBatchNumber() &gt; maxBatchNumber) {</span>
            <span class="s2">break;</span>
          <span class="s1">}</span>
          <span class="s1">operations.add(mPeekedOperation)</span><span class="s2">;</span>
          <span class="s1">mPeekedOperation = </span><span class="s2">null;</span>
        <span class="s1">}</span>

        <span class="s1">UIThreadOperation polledOperation = mQueue.poll()</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(polledOperation == </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s0">// This is the same as mQueue.isEmpty()</span>
          <span class="s2">break;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(polledOperation.getBatchNumber() &gt; maxBatchNumber) {</span>
          <span class="s0">// Because the operation is already retrieved from the queue, there's no way of placing it</span>
          <span class="s0">// back as the head element, so we remember it manually here</span>
          <span class="s1">mPeekedOperation = polledOperation</span><span class="s2">;</span>
          <span class="s2">break;</span>
        <span class="s1">}</span>
        <span class="s1">operations.add(polledOperation)</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s2">return </span><span class="s1">operations</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@NonNull </span><span class="s2">private final </span><span class="s1">GuardedFrameCallback mAnimatedFrameCallback</span><span class="s2">;</span>
  <span class="s2">private final </span><span class="s1">ReactChoreographer mReactChoreographer</span><span class="s2">;</span>

  <span class="s1">@NonNull </span><span class="s2">private final </span><span class="s1">ConcurrentOperationQueue mOperations = </span><span class="s2">new </span><span class="s1">ConcurrentOperationQueue()</span><span class="s2">;</span>
  <span class="s1">@NonNull </span><span class="s2">private final </span><span class="s1">ConcurrentOperationQueue mPreOperations = </span><span class="s2">new </span><span class="s1">ConcurrentOperationQueue()</span><span class="s2">;</span>

  <span class="s2">private final </span><span class="s1">AtomicReference&lt;NativeAnimatedNodesManager&gt; mNodesManager = </span><span class="s2">new </span><span class="s1">AtomicReference&lt;&gt;()</span><span class="s2">;</span>

  <span class="s2">private boolean </span><span class="s1">mBatchingControlledByJS = </span><span class="s2">false; </span><span class="s0">// TODO T71377544: delete</span>
  <span class="s2">private volatile long </span><span class="s1">mCurrentFrameNumber</span><span class="s2">; </span><span class="s0">// TODO T71377544: delete</span>
  <span class="s2">private volatile long </span><span class="s1">mCurrentBatchNumber</span><span class="s2">;</span>

  <span class="s2">private boolean </span><span class="s1">mInitializedForFabric = </span><span class="s2">false;</span>
  <span class="s2">private boolean </span><span class="s1">mInitializedForNonFabric = </span><span class="s2">false;</span>
  <span class="s2">private </span><span class="s1">@UIManagerType </span><span class="s2">int </span><span class="s1">mUIManagerType = UIManagerType.DEFAULT</span><span class="s2">;</span>
  <span class="s2">private int </span><span class="s1">mNumFabricAnimations = </span><span class="s6">0</span><span class="s2">;</span>
  <span class="s2">private int </span><span class="s1">mNumNonFabricAnimations = </span><span class="s6">0</span><span class="s2">;</span>

  <span class="s2">public </span><span class="s1">NativeAnimatedModule(ReactApplicationContext reactContext) {</span>
    <span class="s2">super</span><span class="s1">(reactContext)</span><span class="s2">;</span>

    <span class="s1">mReactChoreographer = ReactChoreographer.getInstance()</span><span class="s2">;</span>
    <span class="s1">mAnimatedFrameCallback =</span>
        <span class="s2">new </span><span class="s1">GuardedFrameCallback(reactContext) {</span>
          <span class="s1">@Override</span>
          <span class="s2">protected void </span><span class="s1">doFrameGuarded(</span><span class="s2">final long </span><span class="s1">frameTimeNanos) {</span>
            <span class="s2">try </span><span class="s1">{</span>
              <span class="s1">NativeAnimatedNodesManager nodesManager = getNodesManager()</span><span class="s2">;</span>
              <span class="s2">if </span><span class="s1">(nodesManager != </span><span class="s2">null </span><span class="s1">&amp;&amp; nodesManager.hasActiveAnimations()) {</span>
                <span class="s1">nodesManager.runUpdates(frameTimeNanos)</span><span class="s2">;</span>
              <span class="s1">}</span>
              <span class="s0">// This is very unlikely to ever be hit.</span>
              <span class="s2">if </span><span class="s1">(nodesManager == </span><span class="s2">null </span><span class="s1">&amp;&amp; mReactChoreographer == </span><span class="s2">null</span><span class="s1">) {</span>
                <span class="s2">return;</span>
              <span class="s1">}</span>

              <span class="s0">// TODO: Would be great to avoid adding this callback in case there are no active</span>
              <span class="s0">// animations and no outstanding tasks on the operations queue. Apparently frame</span>
              <span class="s0">// callbacks can only be posted from the UI thread and therefore we cannot schedule</span>
              <span class="s0">// them directly from other threads.</span>
              <span class="s1">Assertions.assertNotNull(mReactChoreographer)</span>
                  <span class="s1">.postFrameCallback(</span>
                      <span class="s1">ReactChoreographer.CallbackType.NATIVE_ANIMATED_MODULE</span><span class="s2">,</span>
                      <span class="s1">mAnimatedFrameCallback)</span><span class="s2">;</span>
            <span class="s1">} </span><span class="s2">catch </span><span class="s1">(Exception ex) {</span>
              <span class="s2">throw new </span><span class="s1">RuntimeException(ex)</span><span class="s2">;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">initialize() {</span>
    <span class="s2">super</span><span class="s1">.initialize()</span><span class="s2">;</span>

    <span class="s1">getReactApplicationContext().addLifecycleEventListener(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">onHostResume() {</span>
    <span class="s1">enqueueFrameCallback()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private void </span><span class="s1">addOperation(UIThreadOperation operation) {</span>
    <span class="s1">operation.setBatchNumber(mCurrentBatchNumber)</span><span class="s2">;</span>
    <span class="s1">mOperations.add(operation)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private void </span><span class="s1">addUnbatchedOperation(UIThreadOperation operation) {</span>
    <span class="s1">operation.setBatchNumber(-</span><span class="s6">1</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">mOperations.add(operation)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private void </span><span class="s1">addPreOperation(UIThreadOperation operation) {</span>
    <span class="s1">operation.setBatchNumber(mCurrentBatchNumber)</span><span class="s2">;</span>
    <span class="s1">mPreOperations.add(operation)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">// For FabricUIManager only</span>
  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">didScheduleMountItems(UIManager uiManager) {</span>
    <span class="s1">mCurrentFrameNumber++</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">willMountItems(UIManager uiManager) {</span>
    <span class="s0">// noop</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">didMountItems(UIManager uiManager) {</span>
    <span class="s0">// noop</span>
  <span class="s1">}</span>

  <span class="s0">// For FabricUIManager only</span>
  <span class="s1">@Override</span>
  <span class="s1">@UiThread</span>
  <span class="s2">public void </span><span class="s1">didDispatchMountItems(UIManager uiManager) {</span>
    <span class="s2">if </span><span class="s1">(mUIManagerType != UIManagerType.FABRIC) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s2">long </span><span class="s1">batchNumber = mCurrentBatchNumber - </span><span class="s6">1</span><span class="s2">;</span>

    <span class="s0">// TODO T71377544: delete this when the JS method is confirmed safe</span>
    <span class="s2">if </span><span class="s1">(!mBatchingControlledByJS) {</span>
      <span class="s0">// The problem we're trying to solve here: we could be in the middle of queueing</span>
      <span class="s0">// a batch of related animation operations when Fabric flushes a batch of MountItems.</span>
      <span class="s0">// It's visually bad if we execute half of the animation ops and then wait another frame</span>
      <span class="s0">// (or more) to execute the rest.</span>
      <span class="s0">// See mFrameNumber. If the dispatchedFrameNumber drifts too far - that</span>
      <span class="s0">// is, if no MountItems are scheduled for a while, which can happen if a tree</span>
      <span class="s0">// is committed but there are no changes - bring these counts back in sync and</span>
      <span class="s0">// execute any queued operations. This number is arbitrary, but we want it low</span>
      <span class="s0">// enough that the user shouldn't be able to see this delay in most cases.</span>
      <span class="s1">mCurrentFrameNumber++</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">((mCurrentFrameNumber - mCurrentBatchNumber) &gt; </span><span class="s6">2</span><span class="s1">) {</span>
        <span class="s1">mCurrentBatchNumber = mCurrentFrameNumber</span><span class="s2">;</span>
        <span class="s1">batchNumber = mCurrentBatchNumber</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">mPreOperations.executeBatch(batchNumber</span><span class="s2">, </span><span class="s1">getNodesManager())</span><span class="s2">;</span>
    <span class="s1">mOperations.executeBatch(batchNumber</span><span class="s2">, </span><span class="s1">getNodesManager())</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">// For non-FabricUIManager only</span>
  <span class="s1">@Override</span>
  <span class="s1">@UiThread</span>
  <span class="s2">public void </span><span class="s1">willDispatchViewUpdates(</span><span class="s2">final </span><span class="s1">UIManager uiManager) {</span>
    <span class="s2">if </span><span class="s1">(mOperations.isEmpty() &amp;&amp; mPreOperations.isEmpty()) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(mUIManagerType == UIManagerType.FABRIC) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s2">final long </span><span class="s1">frameNo = mCurrentBatchNumber++</span><span class="s2">;</span>

    <span class="s1">UIBlock preOperationsUIBlock =</span>
        <span class="s2">new </span><span class="s1">UIBlock() {</span>
          <span class="s1">@Override</span>
          <span class="s2">public void </span><span class="s1">execute(NativeViewHierarchyManager nativeViewHierarchyManager) {</span>
            <span class="s1">mPreOperations.executeBatch(frameNo</span><span class="s2">, </span><span class="s1">getNodesManager())</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span><span class="s2">;</span>

    <span class="s1">UIBlock operationsUIBlock =</span>
        <span class="s2">new </span><span class="s1">UIBlock() {</span>
          <span class="s1">@Override</span>
          <span class="s2">public void </span><span class="s1">execute(NativeViewHierarchyManager nativeViewHierarchyManager) {</span>
            <span class="s1">mOperations.executeBatch(frameNo</span><span class="s2">, </span><span class="s1">getNodesManager())</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span><span class="s2">;</span>

    <span class="s2">assert </span><span class="s1">(uiManager </span><span class="s2">instanceof </span><span class="s1">UIManagerModule)</span><span class="s2">;</span>
    <span class="s1">UIManagerModule uiManagerModule = (UIManagerModule) uiManager</span><span class="s2">;</span>
    <span class="s1">uiManagerModule.prependUIBlock(preOperationsUIBlock)</span><span class="s2">;</span>
    <span class="s1">uiManagerModule.addUIBlock(operationsUIBlock)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">onHostPause() {</span>
    <span class="s1">clearFrameCallback()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">onHostDestroy() {</span>
    <span class="s0">// Is it possible for onHostDestroy to be called without a corresponding onHostPause?</span>
    <span class="s1">clearFrameCallback()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Returns a {</span><span class="s5">@link </span><span class="s3">NativeAnimatedNodesManager}, either the existing instance or a new one. Will</span>
   <span class="s3">* return null if and only if the {</span><span class="s5">@link </span><span class="s3">ReactApplicationContext} is also null.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">@return </span><span class="s3">{</span><span class="s5">@link </span><span class="s3">NativeAnimatedNodesManager}</span>
   <span class="s3">*/</span>
  <span class="s1">@Nullable</span>
  <span class="s2">public </span><span class="s1">NativeAnimatedNodesManager getNodesManager() {</span>
    <span class="s2">if </span><span class="s1">(mNodesManager.get() == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">ReactApplicationContext reactApplicationContext = getReactApplicationContextIfActiveOrWarn()</span><span class="s2">;</span>

      <span class="s2">if </span><span class="s1">(reactApplicationContext != </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">mNodesManager.compareAndSet(</span><span class="s2">null, new </span><span class="s1">NativeAnimatedNodesManager(reactApplicationContext))</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">mNodesManager.get()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private void </span><span class="s1">clearFrameCallback() {</span>
    <span class="s1">Assertions.assertNotNull(mReactChoreographer)</span>
        <span class="s1">.removeFrameCallback(</span>
            <span class="s1">ReactChoreographer.CallbackType.NATIVE_ANIMATED_MODULE</span><span class="s2">, </span><span class="s1">mAnimatedFrameCallback)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private void </span><span class="s1">enqueueFrameCallback() {</span>
    <span class="s1">Assertions.assertNotNull(mReactChoreographer)</span>
        <span class="s1">.postFrameCallback(</span>
            <span class="s1">ReactChoreographer.CallbackType.NATIVE_ANIMATED_MODULE</span><span class="s2">, </span><span class="s1">mAnimatedFrameCallback)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@VisibleForTesting</span>
  <span class="s2">public void </span><span class="s1">setNodesManager(NativeAnimatedNodesManager nodesManager) {</span>
    <span class="s1">mNodesManager.set(nodesManager)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Given a viewTag, detect if we're running in Fabric or non-Fabric and attach an event listener</span>
   <span class="s3">* to the correct UIManager, if necessary. This is expected to only be called from the native</span>
   <span class="s3">* module thread, and not concurrently.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">viewTag</span>
   <span class="s3">*/</span>
  <span class="s2">private void </span><span class="s1">initializeLifecycleEventListenersForViewTag(</span><span class="s2">final int </span><span class="s1">viewTag) {</span>
    <span class="s1">mUIManagerType = ViewUtil.getUIManagerType(viewTag)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(mUIManagerType == UIManagerType.FABRIC) {</span>
      <span class="s1">mNumFabricAnimations++</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">mNumNonFabricAnimations++</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">NativeAnimatedNodesManager nodesManager = getNodesManager()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(nodesManager != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">nodesManager.initializeEventListenerForUIManagerType(mUIManagerType)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">ReactSoftExceptionLogger.logSoftException(</span>
          <span class="s1">NAME</span><span class="s2">,</span>
          <span class="s2">new </span><span class="s1">RuntimeException(</span>
              <span class="s7">&quot;initializeLifecycleEventListenersForViewTag could not get NativeAnimatedNodesManager&quot;</span><span class="s1">))</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s0">// Subscribe to UIManager (Fabric or non-Fabric) lifecycle events if we haven't yet</span>
    <span class="s2">if </span><span class="s1">(mUIManagerType == UIManagerType.FABRIC ? mInitializedForFabric : mInitializedForNonFabric) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s1">ReactApplicationContext reactApplicationContext = getReactApplicationContext()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(reactApplicationContext != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">@Nullable</span>
      <span class="s1">UIManager uiManager = UIManagerHelper.getUIManager(reactApplicationContext</span><span class="s2">, </span><span class="s1">mUIManagerType)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(uiManager != </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">uiManager.addUIManagerEventListener(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(mUIManagerType == UIManagerType.FABRIC) {</span>
          <span class="s1">mInitializedForFabric = </span><span class="s2">true;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">mInitializedForNonFabric = </span><span class="s2">true;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Given a viewTag and the knowledge that a &quot;disconnect&quot; or &quot;stop&quot;-type imperative command is</span>
   <span class="s3">* being executed, decrement the number of inflight animations and possibly switch UIManager</span>
   <span class="s3">* modes.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">viewTag</span>
   <span class="s3">*/</span>
  <span class="s2">private void </span><span class="s1">decrementInFlightAnimationsForViewTag(</span><span class="s2">final int </span><span class="s1">viewTag) {</span>
    <span class="s1">@UIManagerType </span><span class="s2">int </span><span class="s1">animationManagerType = ViewUtil.getUIManagerType(viewTag)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(animationManagerType == UIManagerType.FABRIC) {</span>
      <span class="s1">mNumFabricAnimations--</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">mNumNonFabricAnimations--</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s0">// Should we switch to a different animation mode?</span>
    <span class="s0">// This can be useful when navigating between Fabric and non-Fabric screens:</span>
    <span class="s0">// If there are ongoing Fabric animations from a previous screen,</span>
    <span class="s0">// and we tear down the current non-Fabric screen, we should expect</span>
    <span class="s0">// the animation mode to switch back - and vice-versa.</span>
    <span class="s2">if </span><span class="s1">(mNumNonFabricAnimations == </span><span class="s6">0</span>
        <span class="s1">&amp;&amp; mNumFabricAnimations &gt; </span><span class="s6">0</span>
        <span class="s1">&amp;&amp; mUIManagerType != UIManagerType.FABRIC) {</span>
      <span class="s1">mUIManagerType = UIManagerType.FABRIC</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(mNumFabricAnimations == </span><span class="s6">0</span>
        <span class="s1">&amp;&amp; mNumNonFabricAnimations &gt; </span><span class="s6">0</span>
        <span class="s1">&amp;&amp; mUIManagerType != UIManagerType.DEFAULT) {</span>
      <span class="s1">mUIManagerType = UIManagerType.DEFAULT</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">startOperationBatch() {</span>
    <span class="s1">mBatchingControlledByJS = </span><span class="s2">true;</span>
    <span class="s1">mCurrentBatchNumber++</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">finishOperationBatch() {</span>
    <span class="s1">mBatchingControlledByJS = </span><span class="s2">true;</span>
    <span class="s1">mCurrentBatchNumber++</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">createAnimatedNode(</span><span class="s2">final double </span><span class="s1">tagDouble</span><span class="s2">, final </span><span class="s1">ReadableMap config) {</span>
    <span class="s2">final int </span><span class="s1">tag = (</span><span class="s2">int</span><span class="s1">) tagDouble</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(ANIMATED_MODULE_DEBUG) {</span>
      <span class="s1">FLog.d(</span>
          <span class="s1">NAME</span><span class="s2">, </span><span class="s7">&quot;queue createAnimatedNode: &quot; </span><span class="s1">+ tag + </span><span class="s7">&quot; config: &quot; </span><span class="s1">+ config.toHashMap().toString())</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">addOperation(</span>
        <span class="s2">new </span><span class="s1">UIThreadOperation() {</span>
          <span class="s1">@Override</span>
          <span class="s2">public void </span><span class="s1">execute(NativeAnimatedNodesManager animatedNodesManager) {</span>
            <span class="s2">if </span><span class="s1">(ANIMATED_MODULE_DEBUG) {</span>
              <span class="s1">FLog.d(</span>
                  <span class="s1">NAME</span><span class="s2">,</span>
                  <span class="s7">&quot;execute createAnimatedNode: &quot;</span>
                      <span class="s1">+ tag</span>
                      <span class="s1">+ </span><span class="s7">&quot; config: &quot;</span>
                      <span class="s1">+ config.toHashMap().toString())</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">animatedNodesManager.createAnimatedNode(tag</span><span class="s2">, </span><span class="s1">config)</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">})</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">updateAnimatedNodeConfig(</span><span class="s2">final double </span><span class="s1">tagDouble</span><span class="s2">, final </span><span class="s1">ReadableMap config) {</span>
    <span class="s2">final int </span><span class="s1">tag = (</span><span class="s2">int</span><span class="s1">) tagDouble</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(ANIMATED_MODULE_DEBUG) {</span>
      <span class="s1">FLog.d(</span>
          <span class="s1">NAME</span><span class="s2">,</span>
          <span class="s7">&quot;queue updateAnimatedNodeConfig: &quot; </span><span class="s1">+ tag + </span><span class="s7">&quot; config: &quot; </span><span class="s1">+ config.toHashMap().toString())</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">addOperation(</span>
        <span class="s2">new </span><span class="s1">UIThreadOperation() {</span>
          <span class="s1">@Override</span>
          <span class="s2">public void </span><span class="s1">execute(NativeAnimatedNodesManager animatedNodesManager) {</span>
            <span class="s2">if </span><span class="s1">(ANIMATED_MODULE_DEBUG) {</span>
              <span class="s1">FLog.d(</span>
                  <span class="s1">NAME</span><span class="s2">,</span>
                  <span class="s7">&quot;execute updateAnimatedNodeConfig: &quot;</span>
                      <span class="s1">+ tag</span>
                      <span class="s1">+ </span><span class="s7">&quot; config: &quot;</span>
                      <span class="s1">+ config.toHashMap().toString())</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">animatedNodesManager.updateAnimatedNodeConfig(tag</span><span class="s2">, </span><span class="s1">config)</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">})</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">startListeningToAnimatedNodeValue(</span><span class="s2">final double </span><span class="s1">tagDouble) {</span>
    <span class="s2">final int </span><span class="s1">tag = (</span><span class="s2">int</span><span class="s1">) tagDouble</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(ANIMATED_MODULE_DEBUG) {</span>
      <span class="s1">FLog.d(NAME</span><span class="s2">, </span><span class="s7">&quot;queue startListeningToAnimatedNodeValue: &quot; </span><span class="s1">+ tag)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">final </span><span class="s1">AnimatedNodeValueListener listener =</span>
        <span class="s2">new </span><span class="s1">AnimatedNodeValueListener() {</span>
          <span class="s2">public void </span><span class="s1">onValueUpdate(</span><span class="s2">double </span><span class="s1">value) {</span>
            <span class="s1">WritableMap onAnimatedValueData = Arguments.createMap()</span><span class="s2">;</span>
            <span class="s1">onAnimatedValueData.putInt(</span><span class="s7">&quot;tag&quot;</span><span class="s2">, </span><span class="s1">tag)</span><span class="s2">;</span>
            <span class="s1">onAnimatedValueData.putDouble(</span><span class="s7">&quot;value&quot;</span><span class="s2">, </span><span class="s1">value)</span><span class="s2">;</span>

            <span class="s1">ReactApplicationContext reactApplicationContext =</span>
                <span class="s1">getReactApplicationContextIfActiveOrWarn()</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(reactApplicationContext != </span><span class="s2">null</span><span class="s1">) {</span>
              <span class="s1">reactApplicationContext.emitDeviceEvent(</span><span class="s7">&quot;onAnimatedValueUpdate&quot;</span><span class="s2">, </span><span class="s1">onAnimatedValueData)</span><span class="s2">;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span><span class="s2">;</span>

    <span class="s1">addOperation(</span>
        <span class="s2">new </span><span class="s1">UIThreadOperation() {</span>
          <span class="s1">@Override</span>
          <span class="s2">public void </span><span class="s1">execute(NativeAnimatedNodesManager animatedNodesManager) {</span>
            <span class="s2">if </span><span class="s1">(ANIMATED_MODULE_DEBUG) {</span>
              <span class="s1">FLog.d(NAME</span><span class="s2">, </span><span class="s7">&quot;execute startListeningToAnimatedNodeValue: &quot; </span><span class="s1">+ tag)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">animatedNodesManager.startListeningToAnimatedNodeValue(tag</span><span class="s2">, </span><span class="s1">listener)</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">})</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">stopListeningToAnimatedNodeValue(</span><span class="s2">final double </span><span class="s1">tagDouble) {</span>
    <span class="s2">final int </span><span class="s1">tag = (</span><span class="s2">int</span><span class="s1">) tagDouble</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(ANIMATED_MODULE_DEBUG) {</span>
      <span class="s1">FLog.d(NAME</span><span class="s2">, </span><span class="s7">&quot;queue stopListeningToAnimatedNodeValue: &quot; </span><span class="s1">+ tag)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">addOperation(</span>
        <span class="s2">new </span><span class="s1">UIThreadOperation() {</span>
          <span class="s1">@Override</span>
          <span class="s2">public void </span><span class="s1">execute(NativeAnimatedNodesManager animatedNodesManager) {</span>
            <span class="s2">if </span><span class="s1">(ANIMATED_MODULE_DEBUG) {</span>
              <span class="s1">FLog.d(NAME</span><span class="s2">, </span><span class="s7">&quot;execute stopListeningToAnimatedNodeValue: &quot; </span><span class="s1">+ tag)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">animatedNodesManager.stopListeningToAnimatedNodeValue(tag)</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">})</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">dropAnimatedNode(</span><span class="s2">final double </span><span class="s1">tagDouble) {</span>
    <span class="s2">final int </span><span class="s1">tag = (</span><span class="s2">int</span><span class="s1">) tagDouble</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(ANIMATED_MODULE_DEBUG) {</span>
      <span class="s1">FLog.d(NAME</span><span class="s2">, </span><span class="s7">&quot;queue dropAnimatedNode: &quot; </span><span class="s1">+ tag)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">addOperation(</span>
        <span class="s2">new </span><span class="s1">UIThreadOperation() {</span>
          <span class="s1">@Override</span>
          <span class="s2">public void </span><span class="s1">execute(NativeAnimatedNodesManager animatedNodesManager) {</span>
            <span class="s2">if </span><span class="s1">(ANIMATED_MODULE_DEBUG) {</span>
              <span class="s1">FLog.d(NAME</span><span class="s2">, </span><span class="s7">&quot;execute dropAnimatedNode: &quot; </span><span class="s1">+ tag)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">animatedNodesManager.dropAnimatedNode(tag)</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">})</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setAnimatedNodeValue(</span><span class="s2">final double </span><span class="s1">tagDouble</span><span class="s2">, final double </span><span class="s1">value) {</span>
    <span class="s2">final int </span><span class="s1">tag = (</span><span class="s2">int</span><span class="s1">) tagDouble</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(ANIMATED_MODULE_DEBUG) {</span>
      <span class="s1">FLog.d(NAME</span><span class="s2">, </span><span class="s7">&quot;queue setAnimatedNodeValue: &quot; </span><span class="s1">+ tag + </span><span class="s7">&quot; value: &quot; </span><span class="s1">+ value)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">addOperation(</span>
        <span class="s2">new </span><span class="s1">UIThreadOperation() {</span>
          <span class="s1">@Override</span>
          <span class="s2">public void </span><span class="s1">execute(NativeAnimatedNodesManager animatedNodesManager) {</span>
            <span class="s2">if </span><span class="s1">(ANIMATED_MODULE_DEBUG) {</span>
              <span class="s1">FLog.d(NAME</span><span class="s2">, </span><span class="s7">&quot;execute setAnimatedNodeValue: &quot; </span><span class="s1">+ tag + </span><span class="s7">&quot; value: &quot; </span><span class="s1">+ value)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">animatedNodesManager.setAnimatedNodeValue(tag</span><span class="s2">, </span><span class="s1">value)</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">})</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setAnimatedNodeOffset(</span><span class="s2">final double </span><span class="s1">tagDouble</span><span class="s2">, final double </span><span class="s1">value) {</span>
    <span class="s2">final int </span><span class="s1">tag = (</span><span class="s2">int</span><span class="s1">) tagDouble</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(ANIMATED_MODULE_DEBUG) {</span>
      <span class="s1">FLog.d(NAME</span><span class="s2">, </span><span class="s7">&quot;queue setAnimatedNodeOffset: &quot; </span><span class="s1">+ tag + </span><span class="s7">&quot; offset: &quot; </span><span class="s1">+ value)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">addOperation(</span>
        <span class="s2">new </span><span class="s1">UIThreadOperation() {</span>
          <span class="s1">@Override</span>
          <span class="s2">public void </span><span class="s1">execute(NativeAnimatedNodesManager animatedNodesManager) {</span>
            <span class="s2">if </span><span class="s1">(ANIMATED_MODULE_DEBUG) {</span>
              <span class="s1">FLog.d(NAME</span><span class="s2">, </span><span class="s7">&quot;execute setAnimatedNodeOffset: &quot; </span><span class="s1">+ tag + </span><span class="s7">&quot; offset: &quot; </span><span class="s1">+ value)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">animatedNodesManager.setAnimatedNodeOffset(tag</span><span class="s2">, </span><span class="s1">value)</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">})</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">flattenAnimatedNodeOffset(</span><span class="s2">final double </span><span class="s1">tagDouble) {</span>
    <span class="s2">final int </span><span class="s1">tag = (</span><span class="s2">int</span><span class="s1">) tagDouble</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(ANIMATED_MODULE_DEBUG) {</span>
      <span class="s1">FLog.d(NAME</span><span class="s2">, </span><span class="s7">&quot;queue flattenAnimatedNodeOffset: &quot; </span><span class="s1">+ tag)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">addOperation(</span>
        <span class="s2">new </span><span class="s1">UIThreadOperation() {</span>
          <span class="s1">@Override</span>
          <span class="s2">public void </span><span class="s1">execute(NativeAnimatedNodesManager animatedNodesManager) {</span>
            <span class="s2">if </span><span class="s1">(ANIMATED_MODULE_DEBUG) {</span>
              <span class="s1">FLog.d(NAME</span><span class="s2">, </span><span class="s7">&quot;execute flattenAnimatedNodeOffset: &quot; </span><span class="s1">+ tag)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">animatedNodesManager.flattenAnimatedNodeOffset(tag)</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">})</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">extractAnimatedNodeOffset(</span><span class="s2">final double </span><span class="s1">tagDouble) {</span>
    <span class="s2">final int </span><span class="s1">tag = (</span><span class="s2">int</span><span class="s1">) tagDouble</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(ANIMATED_MODULE_DEBUG) {</span>
      <span class="s1">FLog.d(NAME</span><span class="s2">, </span><span class="s7">&quot;queue extractAnimatedNodeOffset: &quot; </span><span class="s1">+ tag)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">addOperation(</span>
        <span class="s2">new </span><span class="s1">UIThreadOperation() {</span>
          <span class="s1">@Override</span>
          <span class="s2">public void </span><span class="s1">execute(NativeAnimatedNodesManager animatedNodesManager) {</span>
            <span class="s2">if </span><span class="s1">(ANIMATED_MODULE_DEBUG) {</span>
              <span class="s1">FLog.d(NAME</span><span class="s2">, </span><span class="s7">&quot;execute extractAnimatedNodeOffset: &quot; </span><span class="s1">+ tag)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">animatedNodesManager.extractAnimatedNodeOffset(tag)</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">})</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">startAnimatingNode(</span>
      <span class="s2">final double </span><span class="s1">animationIdDouble</span><span class="s2">,</span>
      <span class="s2">final double </span><span class="s1">animatedNodeTagDouble</span><span class="s2">,</span>
      <span class="s2">final </span><span class="s1">ReadableMap animationConfig</span><span class="s2">,</span>
      <span class="s2">final </span><span class="s1">Callback endCallback) {</span>
    <span class="s2">final int </span><span class="s1">animationId = (</span><span class="s2">int</span><span class="s1">) animationIdDouble</span><span class="s2">;</span>
    <span class="s2">final int </span><span class="s1">animatedNodeTag = (</span><span class="s2">int</span><span class="s1">) animatedNodeTagDouble</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(ANIMATED_MODULE_DEBUG) {</span>
      <span class="s1">FLog.d(NAME</span><span class="s2">, </span><span class="s7">&quot;queue startAnimatingNode: ID: &quot; </span><span class="s1">+ animationId + </span><span class="s7">&quot; tag: &quot; </span><span class="s1">+ animatedNodeTag)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">addUnbatchedOperation(</span>
        <span class="s2">new </span><span class="s1">UIThreadOperation() {</span>
          <span class="s1">@Override</span>
          <span class="s2">public void </span><span class="s1">execute(NativeAnimatedNodesManager animatedNodesManager) {</span>
            <span class="s2">if </span><span class="s1">(ANIMATED_MODULE_DEBUG) {</span>
              <span class="s1">FLog.d(</span>
                  <span class="s1">NAME</span><span class="s2">,</span>
                  <span class="s7">&quot;execute startAnimatingNode: ID: &quot; </span><span class="s1">+ animationId + </span><span class="s7">&quot; tag: &quot; </span><span class="s1">+ animatedNodeTag)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">animatedNodesManager.startAnimatingNode(</span>
                <span class="s1">animationId</span><span class="s2">, </span><span class="s1">animatedNodeTag</span><span class="s2">, </span><span class="s1">animationConfig</span><span class="s2">, </span><span class="s1">endCallback)</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">})</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">stopAnimation(</span><span class="s2">final double </span><span class="s1">animationIdDouble) {</span>
    <span class="s2">final int </span><span class="s1">animationId = (</span><span class="s2">int</span><span class="s1">) animationIdDouble</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(ANIMATED_MODULE_DEBUG) {</span>
      <span class="s1">FLog.d(NAME</span><span class="s2">, </span><span class="s7">&quot;queue stopAnimation: ID: &quot; </span><span class="s1">+ animationId)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">addOperation(</span>
        <span class="s2">new </span><span class="s1">UIThreadOperation() {</span>
          <span class="s1">@Override</span>
          <span class="s2">public void </span><span class="s1">execute(NativeAnimatedNodesManager animatedNodesManager) {</span>
            <span class="s2">if </span><span class="s1">(ANIMATED_MODULE_DEBUG) {</span>
              <span class="s1">FLog.d(NAME</span><span class="s2">, </span><span class="s7">&quot;execute stopAnimation: ID: &quot; </span><span class="s1">+ animationId)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">animatedNodesManager.stopAnimation(animationId)</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">})</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">connectAnimatedNodes(</span>
      <span class="s2">final double </span><span class="s1">parentNodeTagDouble</span><span class="s2">, final double </span><span class="s1">childNodeTagDouble) {</span>
    <span class="s2">final int </span><span class="s1">parentNodeTag = (</span><span class="s2">int</span><span class="s1">) parentNodeTagDouble</span><span class="s2">;</span>
    <span class="s2">final int </span><span class="s1">childNodeTag = (</span><span class="s2">int</span><span class="s1">) childNodeTagDouble</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(ANIMATED_MODULE_DEBUG) {</span>
      <span class="s1">FLog.d(</span>
          <span class="s1">NAME</span><span class="s2">, </span><span class="s7">&quot;queue connectAnimatedNodes: parent: &quot; </span><span class="s1">+ parentNodeTag + </span><span class="s7">&quot; child: &quot; </span><span class="s1">+ childNodeTag)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">addOperation(</span>
        <span class="s2">new </span><span class="s1">UIThreadOperation() {</span>
          <span class="s1">@Override</span>
          <span class="s2">public void </span><span class="s1">execute(NativeAnimatedNodesManager animatedNodesManager) {</span>
            <span class="s2">if </span><span class="s1">(ANIMATED_MODULE_DEBUG) {</span>
              <span class="s1">FLog.d(</span>
                  <span class="s1">NAME</span><span class="s2">,</span>
                  <span class="s7">&quot;execute connectAnimatedNodes: parent: &quot;</span>
                      <span class="s1">+ parentNodeTag</span>
                      <span class="s1">+ </span><span class="s7">&quot; child: &quot;</span>
                      <span class="s1">+ childNodeTag)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">animatedNodesManager.connectAnimatedNodes(parentNodeTag</span><span class="s2">, </span><span class="s1">childNodeTag)</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">})</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">disconnectAnimatedNodes(</span>
      <span class="s2">final double </span><span class="s1">parentNodeTagDouble</span><span class="s2">, final double </span><span class="s1">childNodeTagDouble) {</span>
    <span class="s2">final int </span><span class="s1">parentNodeTag = (</span><span class="s2">int</span><span class="s1">) parentNodeTagDouble</span><span class="s2">;</span>
    <span class="s2">final int </span><span class="s1">childNodeTag = (</span><span class="s2">int</span><span class="s1">) childNodeTagDouble</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(ANIMATED_MODULE_DEBUG) {</span>
      <span class="s1">FLog.d(</span>
          <span class="s1">NAME</span><span class="s2">,</span>
          <span class="s7">&quot;queue disconnectAnimatedNodes: parent: &quot; </span><span class="s1">+ parentNodeTag + </span><span class="s7">&quot; child: &quot; </span><span class="s1">+ childNodeTag)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">addOperation(</span>
        <span class="s2">new </span><span class="s1">UIThreadOperation() {</span>
          <span class="s1">@Override</span>
          <span class="s2">public void </span><span class="s1">execute(NativeAnimatedNodesManager animatedNodesManager) {</span>
            <span class="s2">if </span><span class="s1">(ANIMATED_MODULE_DEBUG) {</span>
              <span class="s1">FLog.d(</span>
                  <span class="s1">NAME</span><span class="s2">,</span>
                  <span class="s7">&quot;execute disconnectAnimatedNodes: parent: &quot;</span>
                      <span class="s1">+ parentNodeTag</span>
                      <span class="s1">+ </span><span class="s7">&quot; child: &quot;</span>
                      <span class="s1">+ childNodeTag)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">animatedNodesManager.disconnectAnimatedNodes(parentNodeTag</span><span class="s2">, </span><span class="s1">childNodeTag)</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">})</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">connectAnimatedNodeToView(</span>
      <span class="s2">final double </span><span class="s1">animatedNodeTagDouble</span><span class="s2">, final double </span><span class="s1">viewTagDouble) {</span>
    <span class="s2">final int </span><span class="s1">animatedNodeTag = (</span><span class="s2">int</span><span class="s1">) animatedNodeTagDouble</span><span class="s2">;</span>
    <span class="s2">final int </span><span class="s1">viewTag = (</span><span class="s2">int</span><span class="s1">) viewTagDouble</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(ANIMATED_MODULE_DEBUG) {</span>
      <span class="s1">FLog.d(</span>
          <span class="s1">NAME</span><span class="s2">,</span>
          <span class="s7">&quot;queue connectAnimatedNodeToView: animatedNodeTag: &quot;</span>
              <span class="s1">+ animatedNodeTag</span>
              <span class="s1">+ </span><span class="s7">&quot; viewTag: &quot;</span>
              <span class="s1">+ viewTag)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">initializeLifecycleEventListenersForViewTag(viewTag)</span><span class="s2">;</span>

    <span class="s1">addOperation(</span>
        <span class="s2">new </span><span class="s1">UIThreadOperation() {</span>
          <span class="s1">@Override</span>
          <span class="s2">public void </span><span class="s1">execute(NativeAnimatedNodesManager animatedNodesManager) {</span>
            <span class="s2">if </span><span class="s1">(ANIMATED_MODULE_DEBUG) {</span>
              <span class="s1">FLog.d(</span>
                  <span class="s1">NAME</span><span class="s2">,</span>
                  <span class="s7">&quot;execute connectAnimatedNodeToView: animatedNodeTag: &quot;</span>
                      <span class="s1">+ animatedNodeTag</span>
                      <span class="s1">+ </span><span class="s7">&quot; viewTag: &quot;</span>
                      <span class="s1">+ viewTag)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">animatedNodesManager.connectAnimatedNodeToView(animatedNodeTag</span><span class="s2">, </span><span class="s1">viewTag)</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">})</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">disconnectAnimatedNodeFromView(</span>
      <span class="s2">final double </span><span class="s1">animatedNodeTagDouble</span><span class="s2">, final double </span><span class="s1">viewTagDouble) {</span>
    <span class="s2">final int </span><span class="s1">animatedNodeTag = (</span><span class="s2">int</span><span class="s1">) animatedNodeTagDouble</span><span class="s2">;</span>
    <span class="s2">final int </span><span class="s1">viewTag = (</span><span class="s2">int</span><span class="s1">) viewTagDouble</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(ANIMATED_MODULE_DEBUG) {</span>
      <span class="s1">FLog.d(</span>
          <span class="s1">NAME</span><span class="s2">,</span>
          <span class="s7">&quot;queue disconnectAnimatedNodeFromView: &quot; </span><span class="s1">+ animatedNodeTag + </span><span class="s7">&quot; viewTag: &quot; </span><span class="s1">+ viewTag)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">decrementInFlightAnimationsForViewTag(viewTag)</span><span class="s2">;</span>

    <span class="s1">addOperation(</span>
        <span class="s2">new </span><span class="s1">UIThreadOperation() {</span>
          <span class="s1">@Override</span>
          <span class="s2">public void </span><span class="s1">execute(NativeAnimatedNodesManager animatedNodesManager) {</span>
            <span class="s2">if </span><span class="s1">(ANIMATED_MODULE_DEBUG) {</span>
              <span class="s1">FLog.d(</span>
                  <span class="s1">NAME</span><span class="s2">,</span>
                  <span class="s7">&quot;execute disconnectAnimatedNodeFromView: &quot;</span>
                      <span class="s1">+ animatedNodeTag</span>
                      <span class="s1">+ </span><span class="s7">&quot; viewTag: &quot;</span>
                      <span class="s1">+ viewTag)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">animatedNodesManager.disconnectAnimatedNodeFromView(animatedNodeTag</span><span class="s2">, </span><span class="s1">viewTag)</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">})</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">restoreDefaultValues(</span><span class="s2">final double </span><span class="s1">animatedNodeTagDouble) {</span>
    <span class="s2">final int </span><span class="s1">animatedNodeTag = (</span><span class="s2">int</span><span class="s1">) animatedNodeTagDouble</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(ANIMATED_MODULE_DEBUG) {</span>
      <span class="s1">FLog.d(NAME</span><span class="s2">, </span><span class="s7">&quot;queue restoreDefaultValues: &quot; </span><span class="s1">+ animatedNodeTag)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">addPreOperation(</span>
        <span class="s2">new </span><span class="s1">UIThreadOperation() {</span>
          <span class="s1">@Override</span>
          <span class="s2">public void </span><span class="s1">execute(NativeAnimatedNodesManager animatedNodesManager) {</span>
            <span class="s2">if </span><span class="s1">(ANIMATED_MODULE_DEBUG) {</span>
              <span class="s1">FLog.d(NAME</span><span class="s2">, </span><span class="s7">&quot;execute restoreDefaultValues: &quot; </span><span class="s1">+ animatedNodeTag)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">animatedNodesManager.restoreDefaultValues(animatedNodeTag)</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">})</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">addAnimatedEventToView(</span>
      <span class="s2">final double </span><span class="s1">viewTagDouble</span><span class="s2">, final </span><span class="s1">String eventName</span><span class="s2">, final </span><span class="s1">ReadableMap eventMapping) {</span>
    <span class="s2">final int </span><span class="s1">viewTag = (</span><span class="s2">int</span><span class="s1">) viewTagDouble</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(ANIMATED_MODULE_DEBUG) {</span>
      <span class="s1">FLog.d(</span>
          <span class="s1">NAME</span><span class="s2">,</span>
          <span class="s7">&quot;queue addAnimatedEventToView: &quot;</span>
              <span class="s1">+ viewTag</span>
              <span class="s1">+ </span><span class="s7">&quot; eventName: &quot;</span>
              <span class="s1">+ eventName</span>
              <span class="s1">+ </span><span class="s7">&quot; eventMapping: &quot;</span>
              <span class="s1">+ eventMapping.toHashMap().toString())</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">initializeLifecycleEventListenersForViewTag(viewTag)</span><span class="s2">;</span>

    <span class="s1">addOperation(</span>
        <span class="s2">new </span><span class="s1">UIThreadOperation() {</span>
          <span class="s1">@Override</span>
          <span class="s2">public void </span><span class="s1">execute(NativeAnimatedNodesManager animatedNodesManager) {</span>
            <span class="s2">if </span><span class="s1">(ANIMATED_MODULE_DEBUG) {</span>
              <span class="s1">FLog.d(</span>
                  <span class="s1">NAME</span><span class="s2">,</span>
                  <span class="s7">&quot;execute addAnimatedEventToView: &quot;</span>
                      <span class="s1">+ viewTag</span>
                      <span class="s1">+ </span><span class="s7">&quot; eventName: &quot;</span>
                      <span class="s1">+ eventName</span>
                      <span class="s1">+ </span><span class="s7">&quot; eventMapping: &quot;</span>
                      <span class="s1">+ eventMapping.toHashMap().toString())</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">animatedNodesManager.addAnimatedEventToView(viewTag</span><span class="s2">, </span><span class="s1">eventName</span><span class="s2">, </span><span class="s1">eventMapping)</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">})</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">removeAnimatedEventFromView(</span>
      <span class="s2">final double </span><span class="s1">viewTagDouble</span><span class="s2">, final </span><span class="s1">String eventName</span><span class="s2">, final double </span><span class="s1">animatedValueTagDouble) {</span>
    <span class="s2">final int </span><span class="s1">viewTag = (</span><span class="s2">int</span><span class="s1">) viewTagDouble</span><span class="s2">;</span>
    <span class="s2">final int </span><span class="s1">animatedValueTag = (</span><span class="s2">int</span><span class="s1">) animatedValueTagDouble</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(ANIMATED_MODULE_DEBUG) {</span>
      <span class="s1">FLog.d(</span>
          <span class="s1">NAME</span><span class="s2">,</span>
          <span class="s7">&quot;queue removeAnimatedEventFromView: viewTag: &quot;</span>
              <span class="s1">+ viewTag</span>
              <span class="s1">+ </span><span class="s7">&quot; eventName: &quot;</span>
              <span class="s1">+ eventName</span>
              <span class="s1">+ </span><span class="s7">&quot; animatedValueTag: &quot;</span>
              <span class="s1">+ animatedValueTag)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">decrementInFlightAnimationsForViewTag(viewTag)</span><span class="s2">;</span>

    <span class="s1">addOperation(</span>
        <span class="s2">new </span><span class="s1">UIThreadOperation() {</span>
          <span class="s1">@Override</span>
          <span class="s2">public void </span><span class="s1">execute(NativeAnimatedNodesManager animatedNodesManager) {</span>
            <span class="s2">if </span><span class="s1">(ANIMATED_MODULE_DEBUG) {</span>
              <span class="s1">FLog.d(</span>
                  <span class="s1">NAME</span><span class="s2">,</span>
                  <span class="s7">&quot;execute removeAnimatedEventFromView: viewTag: &quot;</span>
                      <span class="s1">+ viewTag</span>
                      <span class="s1">+ </span><span class="s7">&quot; eventName: &quot;</span>
                      <span class="s1">+ eventName</span>
                      <span class="s1">+ </span><span class="s7">&quot; animatedValueTag: &quot;</span>
                      <span class="s1">+ animatedValueTag)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">animatedNodesManager.removeAnimatedEventFromView(viewTag</span><span class="s2">, </span><span class="s1">eventName</span><span class="s2">, </span><span class="s1">animatedValueTag)</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">})</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">addListener(String eventName) {</span>
    <span class="s0">// iOS only</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">removeListeners(</span><span class="s2">double </span><span class="s1">count) {</span>
    <span class="s0">// iOS only</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">getValue(</span><span class="s2">final double </span><span class="s1">animatedValueNodeTagDouble</span><span class="s2">, final </span><span class="s1">Callback callback) {</span>
    <span class="s2">final int </span><span class="s1">animatedValueNodeTag = (</span><span class="s2">int</span><span class="s1">) animatedValueNodeTagDouble</span><span class="s2">;</span>
    <span class="s1">addOperation(</span>
        <span class="s2">new </span><span class="s1">UIThreadOperation() {</span>
          <span class="s1">@Override</span>
          <span class="s2">public void </span><span class="s1">execute(NativeAnimatedNodesManager animatedNodesManager) {</span>
            <span class="s1">animatedNodesManager.getValue(animatedValueNodeTag</span><span class="s2">, </span><span class="s1">callback)</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">})</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">invalidate() {</span>
    <span class="s2">super</span><span class="s1">.invalidate()</span><span class="s2">;</span>

    <span class="s1">getReactApplicationContext().removeLifecycleEventListener(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* This is a currently-experimental method that allows JS to queue and immediately execute many</span>
   <span class="s3">* instructions at once. Since we make 1 JNI/JSI call instead of N, this should significantly</span>
   <span class="s3">* improve performance.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s4">&lt;p&gt;</span><span class="s3">The arguments operate as a byte buffer. All integer command IDs and any args are packed into</span>
   <span class="s3">* opsAndArgs.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s4">&lt;p&gt;</span><span class="s3">For the getValue callback: since this is batched, we accumulate a list of all requested</span>
   <span class="s3">* values, in order, and call the callback once at the end (if present) with the list of requested</span>
   <span class="s3">* values.</span>
   <span class="s3">*/</span>
  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">queueAndExecuteBatchedOperations(</span><span class="s2">final </span><span class="s1">ReadableArray opsAndArgs) {</span>
    <span class="s2">final int </span><span class="s1">opBufferSize = opsAndArgs.size()</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(ANIMATED_MODULE_DEBUG) {</span>
      <span class="s1">FLog.e(NAME</span><span class="s2">, </span><span class="s7">&quot;queueAndExecuteBatchedOperations: opBufferSize: &quot; </span><span class="s1">+ opBufferSize)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s0">// This block of code is unfortunate and should be refactored - we just want to</span>
    <span class="s0">// extract the ViewTags in the ReadableArray to mark animations on views as being enabled.</span>
    <span class="s0">// We only do this for initializing animations on views - disabling animations on views</span>
    <span class="s0">// happens later, when the disconnect/stop operations are actually executed.</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s6">0</span><span class="s2">; </span><span class="s1">i &lt; opBufferSize</span><span class="s2">; </span><span class="s1">) {</span>
      <span class="s1">BatchExecutionOpCodes command = BatchExecutionOpCodes.fromId(opsAndArgs.getInt(i++))</span><span class="s2">;</span>
      <span class="s2">switch </span><span class="s1">(command) {</span>
        <span class="s2">case </span><span class="s1">OP_CODE_GET_VALUE:</span>
        <span class="s2">case </span><span class="s1">OP_START_LISTENING_TO_ANIMATED_NODE_VALUE:</span>
        <span class="s2">case </span><span class="s1">OP_STOP_LISTENING_TO_ANIMATED_NODE_VALUE:</span>
        <span class="s2">case </span><span class="s1">OP_CODE_STOP_ANIMATION:</span>
        <span class="s2">case </span><span class="s1">OP_CODE_FLATTEN_ANIMATED_NODE_OFFSET:</span>
        <span class="s2">case </span><span class="s1">OP_CODE_EXTRACT_ANIMATED_NODE_OFFSET:</span>
        <span class="s2">case </span><span class="s1">OP_CODE_RESTORE_DEFAULT_VALUES:</span>
        <span class="s2">case </span><span class="s1">OP_CODE_DROP_ANIMATED_NODE:</span>
        <span class="s2">case </span><span class="s1">OP_CODE_ADD_LISTENER:</span>
        <span class="s2">case </span><span class="s1">OP_CODE_REMOVE_LISTENERS:</span>
          <span class="s1">i++</span><span class="s2">;</span>
          <span class="s2">break;</span>
        <span class="s2">case </span><span class="s1">OP_CODE_CREATE_ANIMATED_NODE:</span>
        <span class="s2">case </span><span class="s1">OP_CODE_UPDATE_ANIMATED_NODE_CONFIG:</span>
        <span class="s2">case </span><span class="s1">OP_CODE_CONNECT_ANIMATED_NODES:</span>
        <span class="s2">case </span><span class="s1">OP_CODE_DISCONNECT_ANIMATED_NODES:</span>
        <span class="s2">case </span><span class="s1">OP_CODE_SET_ANIMATED_NODE_VALUE:</span>
        <span class="s2">case </span><span class="s1">OP_CODE_SET_ANIMATED_NODE_OFFSET:</span>
        <span class="s2">case </span><span class="s1">OP_CODE_DISCONNECT_ANIMATED_NODE_FROM_VIEW:</span>
          <span class="s1">i += </span><span class="s6">2</span><span class="s2">;</span>
          <span class="s2">break;</span>
        <span class="s2">case </span><span class="s1">OP_CODE_START_ANIMATING_NODE:</span>
        <span class="s2">case </span><span class="s1">OP_CODE_REMOVE_ANIMATED_EVENT_FROM_VIEW:</span>
          <span class="s1">i += </span><span class="s6">3</span><span class="s2">;</span>
          <span class="s2">break;</span>
        <span class="s2">case </span><span class="s1">OP_CODE_CONNECT_ANIMATED_NODE_TO_VIEW:</span>
          <span class="s1">i++</span><span class="s2">; </span><span class="s0">// tag</span>
          <span class="s1">initializeLifecycleEventListenersForViewTag(opsAndArgs.getInt(i++))</span><span class="s2">; </span><span class="s0">// viewTag</span>
          <span class="s2">break;</span>
        <span class="s2">case </span><span class="s1">OP_CODE_ADD_ANIMATED_EVENT_TO_VIEW:</span>
          <span class="s1">initializeLifecycleEventListenersForViewTag(opsAndArgs.getInt(i++))</span><span class="s2">; </span><span class="s0">// viewTag</span>
          <span class="s1">i++</span><span class="s2">; </span><span class="s0">// eventName</span>
          <span class="s1">i++</span><span class="s2">; </span><span class="s0">// eventMapping</span>
          <span class="s2">break;</span>
        <span class="s2">default</span><span class="s1">:</span>
          <span class="s2">throw new </span><span class="s1">IllegalArgumentException(</span>
              <span class="s7">&quot;Batch animation execution op: fetching viewTag: unknown op code&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">// Batching happens inside this operation - so signal to the thread loop that</span>
    <span class="s0">// this operation should be executed as soon as possible, &quot;unbatched&quot; with other</span>
    <span class="s0">// UIThreadOperations</span>
    <span class="s1">startOperationBatch()</span><span class="s2">;</span>
    <span class="s1">addUnbatchedOperation(</span>
        <span class="s2">new </span><span class="s1">UIThreadOperation() {</span>
          <span class="s1">@Override</span>
          <span class="s2">public void </span><span class="s1">execute(NativeAnimatedNodesManager animatedNodesManager) {</span>
            <span class="s1">ReactApplicationContext reactApplicationContext =</span>
                <span class="s1">getReactApplicationContextIfActiveOrWarn()</span><span class="s2">;</span>

            <span class="s2">int </span><span class="s1">viewTag = -</span><span class="s6">1</span><span class="s2">;</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s6">0</span><span class="s2">; </span><span class="s1">i &lt; opBufferSize</span><span class="s2">; </span><span class="s1">) {</span>
              <span class="s1">BatchExecutionOpCodes command = BatchExecutionOpCodes.fromId(opsAndArgs.getInt(i++))</span><span class="s2">;</span>

              <span class="s2">switch </span><span class="s1">(command) {</span>
                <span class="s2">case </span><span class="s1">OP_CODE_CREATE_ANIMATED_NODE:</span>
                  <span class="s1">animatedNodesManager.createAnimatedNode(</span>
                      <span class="s1">opsAndArgs.getInt(i++)</span><span class="s2">, </span><span class="s1">opsAndArgs.getMap(i++))</span><span class="s2">;</span>
                  <span class="s2">break;</span>
                <span class="s2">case </span><span class="s1">OP_CODE_UPDATE_ANIMATED_NODE_CONFIG:</span>
                  <span class="s1">animatedNodesManager.updateAnimatedNodeConfig(</span>
                      <span class="s1">opsAndArgs.getInt(i++)</span><span class="s2">, </span><span class="s1">opsAndArgs.getMap(i++))</span><span class="s2">;</span>
                  <span class="s2">break;</span>
                <span class="s2">case </span><span class="s1">OP_CODE_GET_VALUE:</span>
                  <span class="s1">animatedNodesManager.getValue(opsAndArgs.getInt(i++)</span><span class="s2">, null</span><span class="s1">)</span><span class="s2">;</span>
                  <span class="s2">break;</span>
                <span class="s2">case </span><span class="s1">OP_START_LISTENING_TO_ANIMATED_NODE_VALUE:</span>
                  <span class="s2">final int </span><span class="s1">tag = opsAndArgs.getInt(i++)</span><span class="s2">;</span>
                  <span class="s2">final </span><span class="s1">AnimatedNodeValueListener listener =</span>
                      <span class="s2">new </span><span class="s1">AnimatedNodeValueListener() {</span>
                        <span class="s2">public void </span><span class="s1">onValueUpdate(</span><span class="s2">double </span><span class="s1">value) {</span>
                          <span class="s1">WritableMap onAnimatedValueData = Arguments.createMap()</span><span class="s2">;</span>
                          <span class="s1">onAnimatedValueData.putInt(</span><span class="s7">&quot;tag&quot;</span><span class="s2">, </span><span class="s1">tag)</span><span class="s2">;</span>
                          <span class="s1">onAnimatedValueData.putDouble(</span><span class="s7">&quot;value&quot;</span><span class="s2">, </span><span class="s1">value)</span><span class="s2">;</span>

                          <span class="s1">ReactApplicationContext reactApplicationContext =</span>
                              <span class="s1">getReactApplicationContextIfActiveOrWarn()</span><span class="s2">;</span>
                          <span class="s2">if </span><span class="s1">(reactApplicationContext != </span><span class="s2">null</span><span class="s1">) {</span>
                            <span class="s1">reactApplicationContext.emitDeviceEvent(</span>
                                <span class="s7">&quot;onAnimatedValueUpdate&quot;</span><span class="s2">, </span><span class="s1">onAnimatedValueData)</span><span class="s2">;</span>
                          <span class="s1">}</span>
                        <span class="s1">}</span>
                      <span class="s1">}</span><span class="s2">;</span>
                  <span class="s1">animatedNodesManager.startListeningToAnimatedNodeValue(tag</span><span class="s2">, </span><span class="s1">listener)</span><span class="s2">;</span>
                  <span class="s2">break;</span>
                <span class="s2">case </span><span class="s1">OP_STOP_LISTENING_TO_ANIMATED_NODE_VALUE:</span>
                  <span class="s1">animatedNodesManager.stopListeningToAnimatedNodeValue(opsAndArgs.getInt(i++))</span><span class="s2">;</span>
                  <span class="s2">break;</span>
                <span class="s2">case </span><span class="s1">OP_CODE_CONNECT_ANIMATED_NODES:</span>
                  <span class="s1">animatedNodesManager.connectAnimatedNodes(</span>
                      <span class="s1">opsAndArgs.getInt(i++)</span><span class="s2">, </span><span class="s1">opsAndArgs.getInt(i++))</span><span class="s2">;</span>
                  <span class="s2">break;</span>
                <span class="s2">case </span><span class="s1">OP_CODE_DISCONNECT_ANIMATED_NODES:</span>
                  <span class="s1">animatedNodesManager.disconnectAnimatedNodes(</span>
                      <span class="s1">opsAndArgs.getInt(i++)</span><span class="s2">, </span><span class="s1">opsAndArgs.getInt(i++))</span><span class="s2">;</span>
                  <span class="s2">break;</span>
                <span class="s2">case </span><span class="s1">OP_CODE_START_ANIMATING_NODE:</span>
                  <span class="s1">animatedNodesManager.startAnimatingNode(</span>
                      <span class="s1">opsAndArgs.getInt(i++)</span><span class="s2">, </span><span class="s1">opsAndArgs.getInt(i++)</span><span class="s2">, </span><span class="s1">opsAndArgs.getMap(i++)</span><span class="s2">, null</span><span class="s1">)</span><span class="s2">;</span>
                  <span class="s2">break;</span>
                <span class="s2">case </span><span class="s1">OP_CODE_STOP_ANIMATION:</span>
                  <span class="s1">animatedNodesManager.stopAnimation(opsAndArgs.getInt(i++))</span><span class="s2">;</span>
                  <span class="s2">break;</span>
                <span class="s2">case </span><span class="s1">OP_CODE_SET_ANIMATED_NODE_VALUE:</span>
                  <span class="s1">animatedNodesManager.setAnimatedNodeValue(</span>
                      <span class="s1">opsAndArgs.getInt(i++)</span><span class="s2">, </span><span class="s1">opsAndArgs.getDouble(i++))</span><span class="s2">;</span>
                  <span class="s2">break;</span>
                <span class="s2">case </span><span class="s1">OP_CODE_SET_ANIMATED_NODE_OFFSET:</span>
                  <span class="s1">animatedNodesManager.setAnimatedNodeValue(</span>
                      <span class="s1">opsAndArgs.getInt(i++)</span><span class="s2">, </span><span class="s1">opsAndArgs.getDouble(i++))</span><span class="s2">;</span>
                  <span class="s2">break;</span>
                <span class="s2">case </span><span class="s1">OP_CODE_FLATTEN_ANIMATED_NODE_OFFSET:</span>
                  <span class="s1">animatedNodesManager.flattenAnimatedNodeOffset(opsAndArgs.getInt(i++))</span><span class="s2">;</span>
                  <span class="s2">break;</span>
                <span class="s2">case </span><span class="s1">OP_CODE_EXTRACT_ANIMATED_NODE_OFFSET:</span>
                  <span class="s1">animatedNodesManager.extractAnimatedNodeOffset(opsAndArgs.getInt(i++))</span><span class="s2">;</span>
                  <span class="s2">break;</span>
                <span class="s2">case </span><span class="s1">OP_CODE_CONNECT_ANIMATED_NODE_TO_VIEW:</span>
                  <span class="s1">animatedNodesManager.connectAnimatedNodeToView(</span>
                      <span class="s1">opsAndArgs.getInt(i++)</span><span class="s2">, </span><span class="s1">opsAndArgs.getInt(i++))</span><span class="s2">;</span>
                  <span class="s2">break;</span>
                <span class="s2">case </span><span class="s1">OP_CODE_DISCONNECT_ANIMATED_NODE_FROM_VIEW:</span>
                  <span class="s2">int </span><span class="s1">animatedNodeTag = opsAndArgs.getInt(i++)</span><span class="s2">;</span>
                  <span class="s1">viewTag = opsAndArgs.getInt(i++)</span><span class="s2">;</span>
                  <span class="s1">decrementInFlightAnimationsForViewTag(viewTag)</span><span class="s2">;</span>
                  <span class="s1">animatedNodesManager.disconnectAnimatedNodeFromView(animatedNodeTag</span><span class="s2">, </span><span class="s1">viewTag)</span><span class="s2">;</span>
                  <span class="s2">break;</span>
                <span class="s2">case </span><span class="s1">OP_CODE_RESTORE_DEFAULT_VALUES:</span>
                  <span class="s1">animatedNodesManager.restoreDefaultValues(opsAndArgs.getInt(i++))</span><span class="s2">;</span>
                  <span class="s2">break;</span>
                <span class="s2">case </span><span class="s1">OP_CODE_DROP_ANIMATED_NODE:</span>
                  <span class="s1">animatedNodesManager.dropAnimatedNode(opsAndArgs.getInt(i++))</span><span class="s2">;</span>
                  <span class="s2">break;</span>
                <span class="s2">case </span><span class="s1">OP_CODE_ADD_ANIMATED_EVENT_TO_VIEW:</span>
                  <span class="s1">animatedNodesManager.addAnimatedEventToView(</span>
                      <span class="s1">opsAndArgs.getInt(i++)</span><span class="s2">, </span><span class="s1">opsAndArgs.getString(i++)</span><span class="s2">, </span><span class="s1">opsAndArgs.getMap(i++))</span><span class="s2">;</span>
                  <span class="s2">break;</span>
                <span class="s2">case </span><span class="s1">OP_CODE_REMOVE_ANIMATED_EVENT_FROM_VIEW:</span>
                  <span class="s1">viewTag = opsAndArgs.getInt(i++)</span><span class="s2">;</span>
                  <span class="s1">decrementInFlightAnimationsForViewTag(viewTag)</span><span class="s2">;</span>
                  <span class="s1">animatedNodesManager.removeAnimatedEventFromView(</span>
                      <span class="s1">viewTag</span><span class="s2">, </span><span class="s1">opsAndArgs.getString(i++)</span><span class="s2">, </span><span class="s1">opsAndArgs.getInt(i++))</span><span class="s2">;</span>
                  <span class="s2">break;</span>
                <span class="s2">case </span><span class="s1">OP_CODE_ADD_LISTENER:</span>
                <span class="s2">case </span><span class="s1">OP_CODE_REMOVE_LISTENERS:</span>
                  <span class="s1">i++</span><span class="s2">;</span>
                  <span class="s0">// ios only, do nothing on android besides incrementing the arg counter</span>
                  <span class="s2">break;</span>
                <span class="s2">default</span><span class="s1">:</span>
                  <span class="s2">throw new </span><span class="s1">IllegalArgumentException(</span>
                      <span class="s7">&quot;Batch animation execution op: unknown op code&quot;</span><span class="s1">)</span><span class="s2">;</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">finishOperationBatch()</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
</pre>
</body>
</html>
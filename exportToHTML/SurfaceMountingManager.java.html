<html>
<head>
<title>SurfaceMountingManager.java</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #629755; font-style: italic;}
.s6 { color: #77b767; font-style: italic;}
.s7 { color: #629755; font-weight: bold; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
SurfaceMountingManager.java</font>
</center></td></tr></table>
<pre><span class="s0">/* 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>

<span class="s2">package </span><span class="s1">com.facebook.react.fabric.mounting</span><span class="s2">;</span>

<span class="s2">import static </span><span class="s1">com.facebook.infer.annotation.ThreadConfined.ANY</span><span class="s2">;</span>
<span class="s2">import static </span><span class="s1">com.facebook.infer.annotation.ThreadConfined.UI</span><span class="s2">;</span>

<span class="s2">import </span><span class="s1">android.view.View</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.view.ViewGroup</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.view.ViewParent</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">androidx.annotation.AnyThread</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">androidx.annotation.NonNull</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">androidx.annotation.UiThread</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.common.logging.FLog</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.infer.annotation.Assertions</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.infer.annotation.ThreadConfined</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.ReactContext</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.ReactSoftExceptionLogger</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.ReadableArray</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.ReadableMap</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.RetryableMountingLayerException</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.SoftAssertions</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.UiThreadUtil</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.WritableMap</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.common.build.ReactBuildConfig</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.common.mapbuffer.ReadableMapBuffer</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.config.ReactFeatureFlags</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.fabric.GuardedFrameCallback</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.fabric.events.EventEmitterWrapper</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.fabric.mounting.MountingManager.MountItemExecutor</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.fabric.mounting.mountitems.MountItem</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.modules.core.ReactChoreographer</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.touch.JSResponderHandler</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.IViewGroupManager</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.IllegalViewOperationException</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.ReactOverflowViewWithInset</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.ReactRoot</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.ReactStylesDiffMap</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.RootView</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.RootViewManager</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.StateWrapper</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.ThemedReactContext</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.ViewManager</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.ViewManagerRegistry</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.events.EventCategoryDef</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.views.view.ReactMapBufferViewManager</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.views.view.ReactViewManagerWrapper</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.HashSet</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.LinkedList</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.Queue</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.Set</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.Stack</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.concurrent.ConcurrentHashMap</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.concurrent.ConcurrentLinkedQueue</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">javax.annotation.Nullable</span><span class="s2">;</span>

<span class="s2">public class </span><span class="s1">SurfaceMountingManager {</span>
  <span class="s2">public static final </span><span class="s1">String TAG = SurfaceMountingManager.</span><span class="s2">class</span><span class="s1">.getSimpleName()</span><span class="s2">;</span>

  <span class="s2">private static final boolean </span><span class="s1">SHOW_CHANGED_VIEW_HIERARCHIES = ReactBuildConfig.DEBUG &amp;&amp; </span><span class="s2">false;</span>

  <span class="s2">private volatile boolean </span><span class="s1">mIsStopped = </span><span class="s2">false;</span>
  <span class="s2">private volatile boolean </span><span class="s1">mRootViewAttached = </span><span class="s2">false;</span>

  <span class="s1">@Nullable </span><span class="s2">private </span><span class="s1">ThemedReactContext mThemedReactContext</span><span class="s2">;</span>

  <span class="s0">// These are all non-null, until StopSurface is called</span>
  <span class="s2">private </span><span class="s1">ConcurrentHashMap&lt;Integer</span><span class="s2">, </span><span class="s1">ViewState&gt; mTagToViewState =</span>
      <span class="s2">new </span><span class="s1">ConcurrentHashMap&lt;&gt;()</span><span class="s2">; </span><span class="s0">// any thread</span>
  <span class="s2">private </span><span class="s1">ConcurrentLinkedQueue&lt;MountItem&gt; mOnViewAttachItems = </span><span class="s2">new </span><span class="s1">ConcurrentLinkedQueue&lt;&gt;()</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">JSResponderHandler mJSResponderHandler</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">ViewManagerRegistry mViewManagerRegistry</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">RootViewManager mRootViewManager</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">MountItemExecutor mMountItemExecutor</span><span class="s2">;</span>

  <span class="s0">// Stack of deferred-removal tags for Views that can be</span>
  <span class="s0">// removed asynchronously. Guaranteed to be disconnected</span>
  <span class="s0">// from the viewport and these tags will not be reused in the future.</span>
  <span class="s1">@ThreadConfined(UI)</span>
  <span class="s2">private final </span><span class="s1">Stack&lt;Integer&gt; mReactTagsToRemove = </span><span class="s2">new </span><span class="s1">Stack&lt;&gt;()</span><span class="s2">;</span>

  <span class="s1">@ThreadConfined(UI)</span>
  <span class="s2">private final </span><span class="s1">Set&lt;Integer&gt; mErroneouslyReaddedReactTags = </span><span class="s2">new </span><span class="s1">HashSet&lt;&gt;()</span><span class="s2">;</span>

  <span class="s1">@ThreadConfined(UI)</span>
  <span class="s2">private </span><span class="s1">RemoveDeleteTreeUIFrameCallback mRemoveDeleteTreeUIFrameCallback</span><span class="s2">;</span>

  <span class="s0">// This is null *until* StopSurface is called.</span>
  <span class="s2">private </span><span class="s1">Set&lt;Integer&gt; mTagSetForStoppedSurface</span><span class="s2">;</span>

  <span class="s2">private final int </span><span class="s1">mSurfaceId</span><span class="s2">;</span>

  <span class="s2">public </span><span class="s1">SurfaceMountingManager(</span>
      <span class="s2">int </span><span class="s1">surfaceId</span><span class="s2">,</span>
      <span class="s1">@NonNull JSResponderHandler jsResponderHandler</span><span class="s2">,</span>
      <span class="s1">@NonNull ViewManagerRegistry viewManagerRegistry</span><span class="s2">,</span>
      <span class="s1">@NonNull RootViewManager rootViewManager</span><span class="s2">,</span>
      <span class="s1">@NonNull MountItemExecutor mountItemExecutor</span><span class="s2">,</span>
      <span class="s1">@NonNull ThemedReactContext reactContext) {</span>
    <span class="s1">mSurfaceId = surfaceId</span><span class="s2">;</span>

    <span class="s1">mJSResponderHandler = jsResponderHandler</span><span class="s2">;</span>
    <span class="s1">mViewManagerRegistry = viewManagerRegistry</span><span class="s2">;</span>
    <span class="s1">mRootViewManager = rootViewManager</span><span class="s2">;</span>
    <span class="s1">mMountItemExecutor = mountItemExecutor</span><span class="s2">;</span>
    <span class="s1">mThemedReactContext = reactContext</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public boolean </span><span class="s1">isStopped() {</span>
    <span class="s2">return </span><span class="s1">mIsStopped</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">attachRootView(View rootView</span><span class="s2">, </span><span class="s1">ThemedReactContext themedReactContext) {</span>
    <span class="s1">mThemedReactContext = themedReactContext</span><span class="s2">;</span>
    <span class="s1">addRootView(rootView)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public int </span><span class="s1">getSurfaceId() {</span>
    <span class="s2">return </span><span class="s1">mSurfaceId</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public boolean </span><span class="s1">isRootViewAttached() {</span>
    <span class="s2">return </span><span class="s1">mRootViewAttached</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Nullable</span>
  <span class="s2">public </span><span class="s1">ThemedReactContext getContext() {</span>
    <span class="s2">return </span><span class="s1">mThemedReactContext</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private static void </span><span class="s1">logViewHierarchy(ViewGroup parent</span><span class="s2">, boolean </span><span class="s1">recurse) {</span>
    <span class="s2">int </span><span class="s1">parentTag = parent.getId()</span><span class="s2">;</span>
    <span class="s1">FLog.e(TAG</span><span class="s2">, </span><span class="s3">&quot;  &lt;ViewGroup tag=&quot; </span><span class="s1">+ parentTag + </span><span class="s3">&quot; class=&quot; </span><span class="s1">+ parent.getClass().toString() + </span><span class="s3">&quot;&gt;&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; parent.getChildCount()</span><span class="s2">; </span><span class="s1">i++) {</span>
      <span class="s1">FLog.e(</span>
          <span class="s1">TAG</span><span class="s2">,</span>
          <span class="s3">&quot;     &lt;View idx=&quot;</span>
              <span class="s1">+ i</span>
              <span class="s1">+ </span><span class="s3">&quot; tag=&quot;</span>
              <span class="s1">+ parent.getChildAt(i).getId()</span>
              <span class="s1">+ </span><span class="s3">&quot; class=&quot;</span>
              <span class="s1">+ parent.getChildAt(i).getClass().toString()</span>
              <span class="s1">+ </span><span class="s3">&quot;&gt;&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">FLog.e(TAG</span><span class="s2">, </span><span class="s3">&quot;  &lt;/ViewGroup tag=&quot; </span><span class="s1">+ parentTag + </span><span class="s3">&quot;&gt;&quot;</span><span class="s1">)</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(recurse) {</span>
      <span class="s1">FLog.e(TAG</span><span class="s2">, </span><span class="s3">&quot;Displaying Ancestors:&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">ViewParent ancestor = parent.getParent()</span><span class="s2">;</span>
      <span class="s2">while </span><span class="s1">(ancestor != </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">ViewGroup ancestorViewGroup = (ancestor </span><span class="s2">instanceof </span><span class="s1">ViewGroup ? (ViewGroup) ancestor : </span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">int </span><span class="s1">ancestorId = ancestorViewGroup == </span><span class="s2">null </span><span class="s1">? View.NO_ID : ancestorViewGroup.getId()</span><span class="s2">;</span>
        <span class="s1">FLog.e(</span>
            <span class="s1">TAG</span><span class="s2">,</span>
            <span class="s3">&quot;&lt;ViewParent tag=&quot; </span><span class="s1">+ ancestorId + </span><span class="s3">&quot; class=&quot; </span><span class="s1">+ ancestor.getClass().toString() + </span><span class="s3">&quot;&gt;&quot;</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">ancestor = ancestor.getParent()</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">public boolean </span><span class="s1">getViewExists(</span><span class="s2">int </span><span class="s1">tag) {</span>
    <span class="s0">// If Surface stopped, check if tag *was* associated with this Surface, even though it's been</span>
    <span class="s0">// deleted. This helps distinguish between scenarios where an invalid tag is referenced, vs</span>
    <span class="s0">// race conditions where an imperative method is called on a tag during/just after StopSurface.</span>
    <span class="s2">if </span><span class="s1">(mTagSetForStoppedSurface != </span><span class="s2">null </span><span class="s1">&amp;&amp; mTagSetForStoppedSurface.contains(tag)) {</span>
      <span class="s2">return true;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(mTagToViewState == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">return false;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">mTagToViewState.containsKey(tag)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@AnyThread</span>
  <span class="s2">public void </span><span class="s1">executeOnViewAttach(MountItem item) {</span>
    <span class="s1">mOnViewAttachItems.add(item)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@AnyThread</span>
  <span class="s2">private void </span><span class="s1">addRootView(@NonNull </span><span class="s2">final </span><span class="s1">View rootView) {</span>
    <span class="s2">if </span><span class="s1">(isStopped()) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s1">mTagToViewState.put(</span>
        <span class="s1">mSurfaceId</span><span class="s2">,</span>
        <span class="s2">new </span><span class="s1">ViewState(</span>
            <span class="s1">mSurfaceId</span><span class="s2">,</span>
            <span class="s1">rootView</span><span class="s2">,</span>
            <span class="s2">new </span><span class="s1">ReactViewManagerWrapper.DefaultViewManager((ViewManager) mRootViewManager)</span><span class="s2">,</span>
            <span class="s2">true</span><span class="s1">))</span><span class="s2">;</span>

    <span class="s1">Runnable runnable =</span>
        <span class="s2">new </span><span class="s1">Runnable() {</span>
          <span class="s1">@Override</span>
          <span class="s2">public void </span><span class="s1">run() {</span>
            <span class="s0">// The CPU has ticked since `addRootView` was called, so the surface could technically</span>
            <span class="s0">// have already stopped here.</span>
            <span class="s2">if </span><span class="s1">(isStopped()) {</span>
              <span class="s2">return;</span>
            <span class="s1">}</span>

            <span class="s2">if </span><span class="s1">(rootView.getId() == mSurfaceId) {</span>
              <span class="s1">ReactSoftExceptionLogger.logSoftException(</span>
                  <span class="s1">TAG</span><span class="s2">,</span>
                  <span class="s2">new </span><span class="s1">IllegalViewOperationException(</span>
                      <span class="s3">&quot;Race condition in addRootView detected. Trying to set an id of [&quot;</span>
                          <span class="s1">+ mSurfaceId</span>
                          <span class="s1">+ </span><span class="s3">&quot;] on the RootView, but that id has already been set. &quot;</span><span class="s1">))</span><span class="s2">;</span>
            <span class="s1">} </span><span class="s2">else if </span><span class="s1">(rootView.getId() != View.NO_ID) {</span>
              <span class="s1">FLog.e(</span>
                  <span class="s1">TAG</span><span class="s2">,</span>
                  <span class="s3">&quot;Trying to add RootTag to RootView that already has a tag: existing tag: [%d] new tag: [%d]&quot;</span><span class="s2">,</span>
                  <span class="s1">rootView.getId()</span><span class="s2">,</span>
                  <span class="s1">mSurfaceId)</span><span class="s2">;</span>
              <span class="s2">throw new </span><span class="s1">IllegalViewOperationException(</span>
                  <span class="s3">&quot;Trying to add a root view with an explicit id already set. React Native uses &quot;</span>
                      <span class="s1">+ </span><span class="s3">&quot;the id field to track react tags and will overwrite this field. If that is fine, &quot;</span>
                      <span class="s1">+ </span><span class="s3">&quot;explicitly overwrite the id field to View.NO_ID before calling addRootView.&quot;</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">rootView.setId(mSurfaceId)</span><span class="s2">;</span>

            <span class="s2">if </span><span class="s1">(rootView </span><span class="s2">instanceof </span><span class="s1">ReactRoot) {</span>
              <span class="s1">((ReactRoot) rootView).setRootViewTag(mSurfaceId)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">mRootViewAttached = </span><span class="s2">true;</span>

            <span class="s1">executeViewAttachMountItems()</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(UiThreadUtil.isOnUiThread()) {</span>
      <span class="s1">runnable.run()</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">UiThreadUtil.runOnUiThread(runnable)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@UiThread</span>
  <span class="s1">@ThreadConfined(UI)</span>
  <span class="s2">private void </span><span class="s1">executeViewAttachMountItems() {</span>
    <span class="s1">mMountItemExecutor.executeItems(mOnViewAttachItems)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s5">/**</span>
   <span class="s5">* Stop surface and all operations within it. Garbage-collect Views (caller is responsible for</span>
   <span class="s5">* removing RootView from View layer).</span>
   <span class="s5">*</span>
   <span class="s5">* </span><span class="s6">&lt;p&gt;</span><span class="s5">Delete rootView from cache. Since RN does not control the RootView, in a sense, the fragment</span>
   <span class="s5">* is responsible for actually removing the RootView from the hierarchy / tearing down the</span>
   <span class="s5">* fragment.</span>
   <span class="s5">*</span>
   <span class="s5">* </span><span class="s6">&lt;p&gt;</span><span class="s5">In the original version(s) of this function, we recursively went through all children of the</span>
   <span class="s5">* View and dropped those Views as well; ad infinitum. This was before we had a</span>
   <span class="s5">* SurfaceMountingManager, and all tags were in one global map. Doing this was particularly</span>
   <span class="s5">* important in the case of StopSurface, where race conditions between threads meant you couldn't</span>
   <span class="s5">* rely on DELETE instructions actually deleting all Views in the Surface.</span>
   <span class="s5">*</span>
   <span class="s5">* </span><span class="s6">&lt;p&gt;</span><span class="s5">Now that we have SurfaceMountingManager, we can simply drop our local reference to the View.</span>
   <span class="s5">* Since it will be removed from the View hierarchy entirely (outside of the scope of this class),</span>
   <span class="s5">* garbage collection will take care of destroying it and all descendents.</span>
   <span class="s5">*/</span>
  <span class="s1">@AnyThread</span>
  <span class="s2">public void </span><span class="s1">stopSurface() {</span>
    <span class="s1">FLog.e(TAG</span><span class="s2">, </span><span class="s3">&quot;Stopping surface [&quot; </span><span class="s1">+ mSurfaceId + </span><span class="s3">&quot;]&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isStopped()) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s0">// Prevent more views from being created, or the hierarchy from being manipulated at all. This</span>
    <span class="s0">// causes further operations to noop.</span>
    <span class="s1">mIsStopped = </span><span class="s2">true;</span>

    <span class="s0">// Reset all StateWrapper objects</span>
    <span class="s0">// Since this can happen on any thread, is it possible to race between StateWrapper destruction</span>
    <span class="s0">// and some accesses from View classes in the UI thread?</span>
    <span class="s2">for </span><span class="s1">(ViewState viewState : mTagToViewState.values()) {</span>
      <span class="s2">if </span><span class="s1">(viewState.mStateWrapper != </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">viewState.mStateWrapper.destroyState()</span><span class="s2">;</span>
        <span class="s1">viewState.mStateWrapper = </span><span class="s2">null;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(viewState.mEventEmitter != </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">viewState.mEventEmitter.destroy()</span><span class="s2">;</span>
        <span class="s1">viewState.mEventEmitter = </span><span class="s2">null;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">Runnable runnable =</span>
        <span class="s2">new </span><span class="s1">Runnable() {</span>
          <span class="s1">@Override</span>
          <span class="s2">public void </span><span class="s1">run() {</span>
            <span class="s0">// We must call `onDropViewInstance` on all remaining Views</span>
            <span class="s2">for </span><span class="s1">(ViewState viewState : mTagToViewState.values()) {</span>
              <span class="s1">onViewStateDeleted(viewState)</span><span class="s2">;</span>
            <span class="s1">}</span>

            <span class="s0">// Evict all views from cache and memory</span>
            <span class="s1">mTagSetForStoppedSurface = mTagToViewState.keySet()</span><span class="s2">;</span>
            <span class="s1">mTagToViewState = </span><span class="s2">null;</span>
            <span class="s1">mJSResponderHandler = </span><span class="s2">null;</span>
            <span class="s1">mRootViewManager = </span><span class="s2">null;</span>
            <span class="s1">mMountItemExecutor = </span><span class="s2">null;</span>
            <span class="s1">mOnViewAttachItems.clear()</span><span class="s2">;</span>

            <span class="s2">if </span><span class="s1">(ReactFeatureFlags.enableViewRecycling) {</span>
              <span class="s1">mViewManagerRegistry.onSurfaceStopped(mSurfaceId)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">FLog.e(TAG</span><span class="s2">, </span><span class="s3">&quot;Surface [&quot; </span><span class="s1">+ mSurfaceId + </span><span class="s3">&quot;] was stopped on SurfaceMountingManager.&quot;</span><span class="s1">)</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(UiThreadUtil.isOnUiThread()) {</span>
      <span class="s1">runnable.run()</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">UiThreadUtil.runOnUiThread(runnable)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@UiThread</span>
  <span class="s2">public void </span><span class="s1">addViewAt(</span><span class="s2">final int </span><span class="s1">parentTag</span><span class="s2">, final int </span><span class="s1">tag</span><span class="s2">, final int </span><span class="s1">index) {</span>
    <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isStopped()) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s1">ViewState parentViewState = getViewState(parentTag)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!(parentViewState.mView </span><span class="s2">instanceof </span><span class="s1">ViewGroup)) {</span>
      <span class="s1">String message =</span>
          <span class="s3">&quot;Unable to add a view into a view that is not a ViewGroup. ParentTag: &quot;</span>
              <span class="s1">+ parentTag</span>
              <span class="s1">+ </span><span class="s3">&quot; - Tag: &quot;</span>
              <span class="s1">+ tag</span>
              <span class="s1">+ </span><span class="s3">&quot; - Index: &quot;</span>
              <span class="s1">+ index</span><span class="s2">;</span>
      <span class="s1">FLog.e(TAG</span><span class="s2">, </span><span class="s1">message)</span><span class="s2">;</span>
      <span class="s2">throw new </span><span class="s1">IllegalStateException(message)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">final </span><span class="s1">ViewGroup parentView = (ViewGroup) parentViewState.mView</span><span class="s2">;</span>
    <span class="s1">ViewState viewState = getViewState(tag)</span><span class="s2">;</span>
    <span class="s2">final </span><span class="s1">View view = viewState.mView</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(view == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">IllegalStateException(</span>
          <span class="s3">&quot;Unable to find view for viewState &quot; </span><span class="s1">+ viewState + </span><span class="s3">&quot; and tag &quot; </span><span class="s1">+ tag)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s0">// Display children before inserting</span>
    <span class="s2">if </span><span class="s1">(SHOW_CHANGED_VIEW_HIERARCHIES) {</span>
      <span class="s1">FLog.e(TAG</span><span class="s2">, </span><span class="s3">&quot;addViewAt: [&quot; </span><span class="s1">+ tag + </span><span class="s3">&quot;] -&gt; [&quot; </span><span class="s1">+ parentTag + </span><span class="s3">&quot;] idx: &quot; </span><span class="s1">+ index + </span><span class="s3">&quot; BEFORE&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">logViewHierarchy(parentView</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">ViewParent viewParent = view.getParent()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(viewParent != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">int </span><span class="s1">actualParentId =</span>
          <span class="s1">viewParent </span><span class="s2">instanceof </span><span class="s1">ViewGroup ? ((ViewGroup) viewParent).getId() : View.NO_ID</span><span class="s2">;</span>
      <span class="s1">ReactSoftExceptionLogger.logSoftException(</span>
          <span class="s1">TAG</span><span class="s2">,</span>
          <span class="s2">new </span><span class="s1">IllegalStateException(</span>
              <span class="s3">&quot;addViewAt: cannot insert view [&quot;</span>
                  <span class="s1">+ tag</span>
                  <span class="s1">+ </span><span class="s3">&quot;] into parent [&quot;</span>
                  <span class="s1">+ parentTag</span>
                  <span class="s1">+ </span><span class="s3">&quot;]: View already has a parent: [&quot;</span>
                  <span class="s1">+ actualParentId</span>
                  <span class="s1">+ </span><span class="s3">&quot;] &quot;</span>
                  <span class="s1">+ </span><span class="s3">&quot; Parent: &quot;</span>
                  <span class="s1">+ viewParent.getClass().getSimpleName()</span>
                  <span class="s1">+ </span><span class="s3">&quot; View: &quot;</span>
                  <span class="s1">+ view.getClass().getSimpleName()))</span><span class="s2">;</span>

      <span class="s0">// We've hit an error case, and `addView` will crash below</span>
      <span class="s0">// if we don't take evasive action (it is an error to add a View</span>
      <span class="s0">// to the hierarchy if it already has a parent).</span>
      <span class="s0">// We don't know /why/ this happens yet, but it does happen</span>
      <span class="s0">// very infrequently in production.</span>
      <span class="s0">// Thus, we do three things here:</span>
      <span class="s0">// (1) We logged a SoftException above, so if there's a crash later</span>
      <span class="s0">// on, we might have some hints about what caused it.</span>
      <span class="s0">// (2) We remove the View from its parent.</span>
      <span class="s0">// (3) In case the View was removed from the hierarchy with the</span>
      <span class="s0">// RemoveDeleteTree instruction, and is now being readded - which</span>
      <span class="s0">// should be impossible - we mark this as a &quot;readded&quot; View and</span>
      <span class="s0">// thus prevent the RemoveDeleteTree worker from deleting this</span>
      <span class="s0">// View in the future.</span>
      <span class="s2">if </span><span class="s1">(viewParent </span><span class="s2">instanceof </span><span class="s1">ViewGroup) {</span>
        <span class="s1">((ViewGroup) viewParent).removeView(view)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s1">mErroneouslyReaddedReactTags.add(tag)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">try </span><span class="s1">{</span>
      <span class="s1">getViewGroupManager(parentViewState).addView(parentView</span><span class="s2">, </span><span class="s1">view</span><span class="s2">, </span><span class="s1">index)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(IllegalStateException e) {</span>
      <span class="s0">// Wrap error with more context for debugging</span>
      <span class="s2">throw new </span><span class="s1">IllegalStateException(</span>
          <span class="s3">&quot;addViewAt: failed to insert view [&quot;</span>
              <span class="s1">+ tag</span>
              <span class="s1">+ </span><span class="s3">&quot;] into parent [&quot;</span>
              <span class="s1">+ parentTag</span>
              <span class="s1">+ </span><span class="s3">&quot;] at index &quot;</span>
              <span class="s1">+ index</span><span class="s2">,</span>
          <span class="s1">e)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s0">// Display children after inserting</span>
    <span class="s2">if </span><span class="s1">(SHOW_CHANGED_VIEW_HIERARCHIES) {</span>
      <span class="s0">// Why are we calling `runOnUiThread`? We're already on the UI thread, right?!</span>
      <span class="s0">// Yes - but if you get the children of the View here and display them, *it might show you</span>
      <span class="s0">// the previous children*. Without getting too much into Android internals, basically if we</span>
      <span class="s0">// wait a tick, everything is what we expect.</span>
      <span class="s0">// tldr is that `parent.children == []; parent.addView(x); parent.children == []`</span>
      <span class="s0">// and you need to wait a tick for `parent.children == [x]`.</span>
      <span class="s1">UiThreadUtil.runOnUiThread(</span>
          <span class="s2">new </span><span class="s1">Runnable() {</span>
            <span class="s1">@Override</span>
            <span class="s2">public void </span><span class="s1">run() {</span>
              <span class="s1">FLog.e(</span>
                  <span class="s1">TAG</span><span class="s2">, </span><span class="s3">&quot;addViewAt: [&quot; </span><span class="s1">+ tag + </span><span class="s3">&quot;] -&gt; [&quot; </span><span class="s1">+ parentTag + </span><span class="s3">&quot;] idx: &quot; </span><span class="s1">+ index + </span><span class="s3">&quot; AFTER&quot;</span><span class="s1">)</span><span class="s2">;</span>
              <span class="s1">logViewHierarchy(parentView</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
          <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@UiThread</span>
  <span class="s2">public void </span><span class="s1">removeViewAt(</span><span class="s2">final int </span><span class="s1">tag</span><span class="s2">, final int </span><span class="s1">parentTag</span><span class="s2">, int </span><span class="s1">index) {</span>
    <span class="s2">if </span><span class="s1">(isStopped()) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s0">// This is &quot;impossible&quot;. See comments above.</span>
    <span class="s2">if </span><span class="s1">(mErroneouslyReaddedReactTags.contains(tag)) {</span>
      <span class="s1">ReactSoftExceptionLogger.logSoftException(</span>
          <span class="s1">TAG</span><span class="s2">,</span>
          <span class="s2">new </span><span class="s1">IllegalViewOperationException(</span>
              <span class="s3">&quot;removeViewAt tried to remove a React View that was actually reused. This indicates a bug in the Differ (specifically instruction ordering). [&quot;</span>
                  <span class="s1">+ tag</span>
                  <span class="s1">+ </span><span class="s3">&quot;]&quot;</span><span class="s1">))</span><span class="s2">;</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>
    <span class="s1">ViewState parentViewState = getNullableViewState(parentTag)</span><span class="s2">;</span>

    <span class="s0">// TODO: throw exception here?</span>
    <span class="s2">if </span><span class="s1">(parentViewState == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">ReactSoftExceptionLogger.logSoftException(</span>
          <span class="s1">MountingManager.TAG</span><span class="s2">,</span>
          <span class="s2">new </span><span class="s1">IllegalStateException(</span>
              <span class="s3">&quot;Unable to find viewState for tag: [&quot; </span><span class="s1">+ parentTag + </span><span class="s3">&quot;] for removeViewAt&quot;</span><span class="s1">))</span><span class="s2">;</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(!(parentViewState.mView </span><span class="s2">instanceof </span><span class="s1">ViewGroup)) {</span>
      <span class="s1">String message =</span>
          <span class="s3">&quot;Unable to remove a view from a view that is not a ViewGroup. ParentTag: &quot;</span>
              <span class="s1">+ parentTag</span>
              <span class="s1">+ </span><span class="s3">&quot; - Tag: &quot;</span>
              <span class="s1">+ tag</span>
              <span class="s1">+ </span><span class="s3">&quot; - Index: &quot;</span>
              <span class="s1">+ index</span><span class="s2">;</span>
      <span class="s1">FLog.e(TAG</span><span class="s2">, </span><span class="s1">message)</span><span class="s2">;</span>
      <span class="s2">throw new </span><span class="s1">IllegalStateException(message)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">final </span><span class="s1">ViewGroup parentView = (ViewGroup) parentViewState.mView</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(parentView == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">IllegalStateException(</span><span class="s3">&quot;Unable to find view for tag [&quot; </span><span class="s1">+ parentTag + </span><span class="s3">&quot;]&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(SHOW_CHANGED_VIEW_HIERARCHIES) {</span>
      <span class="s0">// Display children before deleting any</span>
      <span class="s1">FLog.e(TAG</span><span class="s2">, </span><span class="s3">&quot;removeViewAt: [&quot; </span><span class="s1">+ tag + </span><span class="s3">&quot;] -&gt; [&quot; </span><span class="s1">+ parentTag + </span><span class="s3">&quot;] idx: &quot; </span><span class="s1">+ index + </span><span class="s3">&quot; BEFORE&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">logViewHierarchy(parentView</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">IViewGroupManager&lt;ViewGroup&gt; viewGroupManager = getViewGroupManager(parentViewState)</span><span class="s2">;</span>

    <span class="s0">// Verify that the view we're about to remove has the same tag we expect</span>
    <span class="s1">View view = viewGroupManager.getChildAt(parentView</span><span class="s2">, </span><span class="s1">index)</span><span class="s2">;</span>
    <span class="s2">int </span><span class="s1">actualTag = (view != </span><span class="s2">null </span><span class="s1">? view.getId() : -</span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(actualTag != tag) {</span>
      <span class="s2">int </span><span class="s1">tagActualIndex = -</span><span class="s4">1</span><span class="s2">;</span>
      <span class="s2">int </span><span class="s1">parentChildrenCount = parentView.getChildCount()</span><span class="s2">;</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; parentChildrenCount</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s2">if </span><span class="s1">(parentView.getChildAt(i).getId() == tag) {</span>
          <span class="s1">tagActualIndex = i</span><span class="s2">;</span>
          <span class="s2">break;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s0">// TODO T74425739: previously, we did not do this check and `removeViewAt` would be executed</span>
      <span class="s0">// below, sometimes crashing there. *However*, interestingly enough, `removeViewAt` would not</span>
      <span class="s0">// complain if you removed views from an already-empty parent. This seems necessary currently</span>
      <span class="s0">// for certain ViewManagers that remove their own children - like BottomSheet?</span>
      <span class="s0">// This workaround seems not-great, but for now, we just return here for</span>
      <span class="s0">// backwards-compatibility. Essentially, if a view has already been removed from the</span>
      <span class="s0">// hierarchy, we treat it as a noop.</span>
      <span class="s2">if </span><span class="s1">(tagActualIndex == -</span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s1">FLog.e(</span>
            <span class="s1">TAG</span><span class="s2">,</span>
            <span class="s3">&quot;removeViewAt: [&quot;</span>
                <span class="s1">+ tag</span>
                <span class="s1">+ </span><span class="s3">&quot;] -&gt; [&quot;</span>
                <span class="s1">+ parentTag</span>
                <span class="s1">+ </span><span class="s3">&quot;] @&quot;</span>
                <span class="s1">+ index</span>
                <span class="s1">+ </span><span class="s3">&quot;: view already removed from parent! Children in parent: &quot;</span>
                <span class="s1">+ parentChildrenCount)</span><span class="s2">;</span>
        <span class="s2">return;</span>
      <span class="s1">}</span>

      <span class="s0">// Here we are guaranteed that the view is still in the View hierarchy, just</span>
      <span class="s0">// at a different index. In debug mode we'll crash here; in production, we'll remove</span>
      <span class="s0">// the child from the parent and move on.</span>
      <span class="s0">// This is an issue that is safely recoverable 95% of the time. If this allows corruption</span>
      <span class="s0">// of the view hierarchy and causes bugs or a crash after this point, there will be logs</span>
      <span class="s0">// indicating that this happened.</span>
      <span class="s0">// This is likely *only* necessary because of Fabric's LayoutAnimations implementation.</span>
      <span class="s0">// If we can fix the bug there, or remove the need for LayoutAnimation index adjustment</span>
      <span class="s0">// entirely, we can just throw this exception without regression user experience.</span>
      <span class="s1">logViewHierarchy(parentView</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">ReactSoftExceptionLogger.logSoftException(</span>
          <span class="s1">TAG</span><span class="s2">,</span>
          <span class="s2">new </span><span class="s1">IllegalStateException(</span>
              <span class="s3">&quot;Tried to remove view [&quot;</span>
                  <span class="s1">+ tag</span>
                  <span class="s1">+ </span><span class="s3">&quot;] of parent [&quot;</span>
                  <span class="s1">+ parentTag</span>
                  <span class="s1">+ </span><span class="s3">&quot;] at index &quot;</span>
                  <span class="s1">+ index</span>
                  <span class="s1">+ </span><span class="s3">&quot;, but got view tag &quot;</span>
                  <span class="s1">+ actualTag</span>
                  <span class="s1">+ </span><span class="s3">&quot; - actual index of view: &quot;</span>
                  <span class="s1">+ tagActualIndex))</span><span class="s2">;</span>
      <span class="s1">index = tagActualIndex</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">try </span><span class="s1">{</span>
      <span class="s1">viewGroupManager.removeViewAt(parentView</span><span class="s2">, </span><span class="s1">index)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(RuntimeException e) {</span>
      <span class="s0">// Note: `getChildCount` may not always be accurate!</span>
      <span class="s0">// We don't currently have a good explanation other than, in situations where you</span>
      <span class="s0">// would empirically expect to see childCount &gt; 0, the childCount is reported as 0.</span>
      <span class="s0">// This is likely due to a ViewManager overriding getChildCount or some other methods</span>
      <span class="s0">// in a way that is strictly incorrect, but potentially only visible here.</span>
      <span class="s0">// The failure mode is actually that in `removeViewAt`, a NullPointerException is</span>
      <span class="s0">// thrown when we try to perform an operation on a View that doesn't exist, and</span>
      <span class="s0">// is therefore null.</span>
      <span class="s0">// We try to add some extra diagnostics here, but we always try to remove the View</span>
      <span class="s0">// from the hierarchy first because detecting by looking at childCount will not work.</span>
      <span class="s0">//</span>
      <span class="s0">// Note that the lesson here is that `getChildCount` is not /required/ to adhere to</span>
      <span class="s0">// any invariants. If you add 9 children to a parent, the `getChildCount` of the parent</span>
      <span class="s0">// may not be equal to 9. This apparently causes no issues with Android and is common</span>
      <span class="s0">// enough that we shouldn't try to change this invariant, without a lot of thought.</span>
      <span class="s2">int </span><span class="s1">childCount = viewGroupManager.getChildCount(parentView)</span><span class="s2">;</span>

      <span class="s1">logViewHierarchy(parentView</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>

      <span class="s2">throw new </span><span class="s1">IllegalStateException(</span>
          <span class="s3">&quot;Cannot remove child at index &quot;</span>
              <span class="s1">+ index</span>
              <span class="s1">+ </span><span class="s3">&quot; from parent ViewGroup [&quot;</span>
              <span class="s1">+ parentView.getId()</span>
              <span class="s1">+ </span><span class="s3">&quot;], only &quot;</span>
              <span class="s1">+ childCount</span>
              <span class="s1">+ </span><span class="s3">&quot; children in parent. Warning: childCount may be incorrect!&quot;</span><span class="s2">,</span>
          <span class="s1">e)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s0">// Display children after deleting any</span>
    <span class="s2">if </span><span class="s1">(SHOW_CHANGED_VIEW_HIERARCHIES) {</span>
      <span class="s2">final int </span><span class="s1">finalIndex = index</span><span class="s2">;</span>
      <span class="s1">UiThreadUtil.runOnUiThread(</span>
          <span class="s2">new </span><span class="s1">Runnable() {</span>
            <span class="s1">@Override</span>
            <span class="s2">public void </span><span class="s1">run() {</span>
              <span class="s1">FLog.e(</span>
                  <span class="s1">TAG</span><span class="s2">,</span>
                  <span class="s3">&quot;removeViewAt: [&quot;</span>
                      <span class="s1">+ tag</span>
                      <span class="s1">+ </span><span class="s3">&quot;] -&gt; [&quot;</span>
                      <span class="s1">+ parentTag</span>
                      <span class="s1">+ </span><span class="s3">&quot;] idx: &quot;</span>
                      <span class="s1">+ finalIndex</span>
                      <span class="s1">+ </span><span class="s3">&quot; AFTER&quot;</span><span class="s1">)</span><span class="s2">;</span>
              <span class="s1">logViewHierarchy(parentView</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
          <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@UiThread</span>
  <span class="s2">public void </span><span class="s1">removeDeleteTreeAt(</span><span class="s2">final int </span><span class="s1">tag</span><span class="s2">, final int </span><span class="s1">parentTag</span><span class="s2">, int </span><span class="s1">index) {</span>
    <span class="s2">if </span><span class="s1">(isStopped()) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>
    <span class="s1">ViewState parentViewState = getNullableViewState(parentTag)</span><span class="s2">;</span>

    <span class="s0">// TODO: throw exception here?</span>
    <span class="s2">if </span><span class="s1">(parentViewState == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">ReactSoftExceptionLogger.logSoftException(</span>
          <span class="s1">MountingManager.TAG</span><span class="s2">,</span>
          <span class="s2">new </span><span class="s1">IllegalStateException(</span>
              <span class="s3">&quot;Unable to find viewState for tag: [&quot; </span><span class="s1">+ parentTag + </span><span class="s3">&quot;] for removeDeleteTreeAt&quot;</span><span class="s1">))</span><span class="s2">;</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(!(parentViewState.mView </span><span class="s2">instanceof </span><span class="s1">ViewGroup)) {</span>
      <span class="s1">String message =</span>
          <span class="s3">&quot;Unable to remove+delete a view from a view that is not a ViewGroup. ParentTag: &quot;</span>
              <span class="s1">+ parentTag</span>
              <span class="s1">+ </span><span class="s3">&quot; - Tag: &quot;</span>
              <span class="s1">+ tag</span>
              <span class="s1">+ </span><span class="s3">&quot; - Index: &quot;</span>
              <span class="s1">+ index</span><span class="s2">;</span>
      <span class="s1">FLog.e(TAG</span><span class="s2">, </span><span class="s1">message)</span><span class="s2">;</span>
      <span class="s2">throw new </span><span class="s1">IllegalStateException(message)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">final </span><span class="s1">ViewGroup parentView = (ViewGroup) parentViewState.mView</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(parentView == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">IllegalStateException(</span><span class="s3">&quot;Unable to find view for tag [&quot; </span><span class="s1">+ parentTag + </span><span class="s3">&quot;]&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(SHOW_CHANGED_VIEW_HIERARCHIES) {</span>
      <span class="s0">// Display children before deleting any</span>
      <span class="s1">FLog.e(</span>
          <span class="s1">TAG</span><span class="s2">,</span>
          <span class="s3">&quot;removeDeleteTreeAt: [&quot; </span><span class="s1">+ tag + </span><span class="s3">&quot;] -&gt; [&quot; </span><span class="s1">+ parentTag + </span><span class="s3">&quot;] idx: &quot; </span><span class="s1">+ index + </span><span class="s3">&quot; BEFORE&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">logViewHierarchy(parentView</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">IViewGroupManager&lt;ViewGroup&gt; viewGroupManager = getViewGroupManager(parentViewState)</span><span class="s2">;</span>

    <span class="s0">// Verify that the view we're about to remove has the same tag we expect</span>
    <span class="s1">View view = viewGroupManager.getChildAt(parentView</span><span class="s2">, </span><span class="s1">index)</span><span class="s2">;</span>
    <span class="s2">int </span><span class="s1">actualTag = (view != </span><span class="s2">null </span><span class="s1">? view.getId() : -</span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(actualTag != tag) {</span>
      <span class="s2">int </span><span class="s1">tagActualIndex = -</span><span class="s4">1</span><span class="s2">;</span>
      <span class="s2">int </span><span class="s1">parentChildrenCount = parentView.getChildCount()</span><span class="s2">;</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; parentChildrenCount</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s2">if </span><span class="s1">(parentView.getChildAt(i).getId() == tag) {</span>
          <span class="s1">tagActualIndex = i</span><span class="s2">;</span>
          <span class="s2">break;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s0">// TODO T74425739: previously, we did not do this check and `removeViewAt` would be executed</span>
      <span class="s0">// below, sometimes crashing there. *However*, interestingly enough, `removeViewAt` would not</span>
      <span class="s0">// complain if you removed views from an already-empty parent. This seems necessary currently</span>
      <span class="s0">// for certain ViewManagers that remove their own children - like BottomSheet?</span>
      <span class="s0">// This workaround seems not-great, but for now, we just return here for</span>
      <span class="s0">// backwards-compatibility. Essentially, if a view has already been removed from the</span>
      <span class="s0">// hierarchy, we treat it as a noop.</span>
      <span class="s2">if </span><span class="s1">(tagActualIndex == -</span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s1">FLog.e(</span>
            <span class="s1">TAG</span><span class="s2">,</span>
            <span class="s3">&quot;removeDeleteTreeAt: [&quot;</span>
                <span class="s1">+ tag</span>
                <span class="s1">+ </span><span class="s3">&quot;] -&gt; [&quot;</span>
                <span class="s1">+ parentTag</span>
                <span class="s1">+ </span><span class="s3">&quot;] @&quot;</span>
                <span class="s1">+ index</span>
                <span class="s1">+ </span><span class="s3">&quot;: view already removed from parent! Children in parent: &quot;</span>
                <span class="s1">+ parentChildrenCount)</span><span class="s2">;</span>
        <span class="s2">return;</span>
      <span class="s1">}</span>

      <span class="s0">// Here we are guaranteed that the view is still in the View hierarchy, just</span>
      <span class="s0">// at a different index. In debug mode we'll crash here; in production, we'll remove</span>
      <span class="s0">// the child from the parent and move on.</span>
      <span class="s0">// This is an issue that is safely recoverable 95% of the time. If this allows corruption</span>
      <span class="s0">// of the view hierarchy and causes bugs or a crash after this point, there will be logs</span>
      <span class="s0">// indicating that this happened.</span>
      <span class="s0">// This is likely *only* necessary because of Fabric's LayoutAnimations implementation.</span>
      <span class="s0">// If we can fix the bug there, or remove the need for LayoutAnimation index adjustment</span>
      <span class="s0">// entirely, we can just throw this exception without regression user experience.</span>
      <span class="s1">logViewHierarchy(parentView</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">ReactSoftExceptionLogger.logSoftException(</span>
          <span class="s1">TAG</span><span class="s2">,</span>
          <span class="s2">new </span><span class="s1">IllegalStateException(</span>
              <span class="s3">&quot;Tried to remove+delete view [&quot;</span>
                  <span class="s1">+ tag</span>
                  <span class="s1">+ </span><span class="s3">&quot;] of parent [&quot;</span>
                  <span class="s1">+ parentTag</span>
                  <span class="s1">+ </span><span class="s3">&quot;] at index &quot;</span>
                  <span class="s1">+ index</span>
                  <span class="s1">+ </span><span class="s3">&quot;, but got view tag &quot;</span>
                  <span class="s1">+ actualTag</span>
                  <span class="s1">+ </span><span class="s3">&quot; - actual index of view: &quot;</span>
                  <span class="s1">+ tagActualIndex))</span><span class="s2">;</span>
      <span class="s1">index = tagActualIndex</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">try </span><span class="s1">{</span>
      <span class="s1">viewGroupManager.removeViewAt(parentView</span><span class="s2">, </span><span class="s1">index)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(RuntimeException e) {</span>
      <span class="s0">// Note: `getChildCount` may not always be accurate!</span>
      <span class="s0">// We don't currently have a good explanation other than, in situations where you</span>
      <span class="s0">// would empirically expect to see childCount &gt; 0, the childCount is reported as 0.</span>
      <span class="s0">// This is likely due to a ViewManager overriding getChildCount or some other methods</span>
      <span class="s0">// in a way that is strictly incorrect, but potentially only visible here.</span>
      <span class="s0">// The failure mode is actually that in `removeViewAt`, a NullPointerException is</span>
      <span class="s0">// thrown when we try to perform an operation on a View that doesn't exist, and</span>
      <span class="s0">// is therefore null.</span>
      <span class="s0">// We try to add some extra diagnostics here, but we always try to remove the View</span>
      <span class="s0">// from the hierarchy first because detecting by looking at childCount will not work.</span>
      <span class="s0">//</span>
      <span class="s0">// Note that the lesson here is that `getChildCount` is not /required/ to adhere to</span>
      <span class="s0">// any invariants. If you add 9 children to a parent, the `getChildCount` of the parent</span>
      <span class="s0">// may not be equal to 9. This apparently causes no issues with Android and is common</span>
      <span class="s0">// enough that we shouldn't try to change this invariant, without a lot of thought.</span>
      <span class="s2">int </span><span class="s1">childCount = viewGroupManager.getChildCount(parentView)</span><span class="s2">;</span>

      <span class="s1">logViewHierarchy(parentView</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>

      <span class="s2">throw new </span><span class="s1">IllegalStateException(</span>
          <span class="s3">&quot;Cannot remove child at index &quot;</span>
              <span class="s1">+ index</span>
              <span class="s1">+ </span><span class="s3">&quot; from parent ViewGroup [&quot;</span>
              <span class="s1">+ parentView.getId()</span>
              <span class="s1">+ </span><span class="s3">&quot;], only &quot;</span>
              <span class="s1">+ childCount</span>
              <span class="s1">+ </span><span class="s3">&quot; children in parent. Warning: childCount may be incorrect!&quot;</span><span class="s2">,</span>
          <span class="s1">e)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s0">// Display children after deleting any</span>
    <span class="s2">if </span><span class="s1">(SHOW_CHANGED_VIEW_HIERARCHIES) {</span>
      <span class="s2">final int </span><span class="s1">finalIndex = index</span><span class="s2">;</span>
      <span class="s1">UiThreadUtil.runOnUiThread(</span>
          <span class="s2">new </span><span class="s1">Runnable() {</span>
            <span class="s1">@Override</span>
            <span class="s2">public void </span><span class="s1">run() {</span>
              <span class="s1">FLog.e(</span>
                  <span class="s1">TAG</span><span class="s2">,</span>
                  <span class="s3">&quot;removeViewAt: [&quot;</span>
                      <span class="s1">+ tag</span>
                      <span class="s1">+ </span><span class="s3">&quot;] -&gt; [&quot;</span>
                      <span class="s1">+ parentTag</span>
                      <span class="s1">+ </span><span class="s3">&quot;] idx: &quot;</span>
                      <span class="s1">+ finalIndex</span>
                      <span class="s1">+ </span><span class="s3">&quot; AFTER&quot;</span><span class="s1">)</span><span class="s2">;</span>
              <span class="s1">logViewHierarchy(parentView</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
          <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s0">// The View has been removed from the View hierarchy; now it</span>
    <span class="s0">// and all of its children, if any, need to be deleted, recursively.</span>
    <span class="s0">// We want to maintain the legacy ordering: delete (and call onViewStateDeleted)</span>
    <span class="s0">// for leaf nodes, and then parents, recursively.</span>
    <span class="s0">// Schedule the Runnable first, to detect if we need to schedule a Runnable at all.</span>
    <span class="s0">// Since this current function and the Runnable both run on the UI thread, there is</span>
    <span class="s0">// no race condition here.</span>
    <span class="s1">runDeferredTagRemovalAndDeletion()</span><span class="s2">;</span>
    <span class="s1">mReactTagsToRemove.push(tag)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@UiThread</span>
  <span class="s2">private void </span><span class="s1">runDeferredTagRemovalAndDeletion() {</span>
    <span class="s2">if </span><span class="s1">(mReactTagsToRemove.empty()) {</span>
      <span class="s2">if </span><span class="s1">(mRemoveDeleteTreeUIFrameCallback == </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">mRemoveDeleteTreeUIFrameCallback = </span><span class="s2">new </span><span class="s1">RemoveDeleteTreeUIFrameCallback(mThemedReactContext)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s1">ReactChoreographer.getInstance()</span>
          <span class="s1">.postFrameCallback(</span>
              <span class="s1">ReactChoreographer.CallbackType.IDLE_EVENT</span><span class="s2">, </span><span class="s1">mRemoveDeleteTreeUIFrameCallback)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@UiThread</span>
  <span class="s2">public void </span><span class="s1">createView(</span>
      <span class="s1">@NonNull String componentName</span><span class="s2">,</span>
      <span class="s2">int </span><span class="s1">reactTag</span><span class="s2">,</span>
      <span class="s1">@Nullable Object props</span><span class="s2">,</span>
      <span class="s1">@Nullable StateWrapper stateWrapper</span><span class="s2">,</span>
      <span class="s1">@Nullable EventEmitterWrapper eventEmitterWrapper</span><span class="s2">,</span>
      <span class="s2">boolean </span><span class="s1">isLayoutable) {</span>
    <span class="s2">if </span><span class="s1">(isStopped()) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s0">// We treat this as a perf problem and not a logical error. View Preallocation or unexpected</span>
    <span class="s0">// changes to Differ or C++ Binding could cause some redundant Create instructions.</span>
    <span class="s0">// There are cases where preallocation happens and a node is recreated: if a node is</span>
    <span class="s0">// preallocated and then committed with revision 2+, an extra CREATE instruction will be</span>
    <span class="s0">// generated.</span>
    <span class="s0">// This represents a perf issue only, not a correctness issue. In the future we need to</span>
    <span class="s0">// refactor View preallocation to correct the currently incorrect assumptions.</span>
    <span class="s1">ViewState viewState = getNullableViewState(reactTag)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(viewState != </span><span class="s2">null </span><span class="s1">&amp;&amp; viewState.mView != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s1">createViewUnsafe(</span>
        <span class="s1">componentName</span><span class="s2">, </span><span class="s1">reactTag</span><span class="s2">, </span><span class="s1">props</span><span class="s2">, </span><span class="s1">stateWrapper</span><span class="s2">, </span><span class="s1">eventEmitterWrapper</span><span class="s2">, </span><span class="s1">isLayoutable)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s5">/**</span>
   <span class="s5">* Perform view creation without any safety checks. You must ensure safety before calling this</span>
   <span class="s5">* method (see existing callsites).</span>
   <span class="s5">*</span>
   <span class="s5">* </span><span class="s7">@param </span><span class="s5">componentName</span>
   <span class="s5">* </span><span class="s7">@param </span><span class="s5">reactTag</span>
   <span class="s5">* </span><span class="s7">@param </span><span class="s5">props</span>
   <span class="s5">* </span><span class="s7">@param </span><span class="s5">stateWrapper</span>
   <span class="s5">* </span><span class="s7">@param </span><span class="s5">eventEmitterWrapper</span>
   <span class="s5">* </span><span class="s7">@param </span><span class="s5">isLayoutable</span>
   <span class="s5">*/</span>
  <span class="s1">@UiThread</span>
  <span class="s2">public void </span><span class="s1">createViewUnsafe(</span>
      <span class="s1">@NonNull String componentName</span><span class="s2">,</span>
      <span class="s2">int </span><span class="s1">reactTag</span><span class="s2">,</span>
      <span class="s1">@Nullable Object props</span><span class="s2">,</span>
      <span class="s1">@Nullable StateWrapper stateWrapper</span><span class="s2">,</span>
      <span class="s1">@Nullable EventEmitterWrapper eventEmitterWrapper</span><span class="s2">,</span>
      <span class="s2">boolean </span><span class="s1">isLayoutable) {</span>
    <span class="s1">View view = </span><span class="s2">null;</span>
    <span class="s1">ReactViewManagerWrapper viewManager = </span><span class="s2">null;</span>

    <span class="s1">Object propMap</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(props </span><span class="s2">instanceof </span><span class="s1">ReadableMap) {</span>
      <span class="s1">propMap = </span><span class="s2">new </span><span class="s1">ReactStylesDiffMap((ReadableMap) props)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">propMap = props</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(isLayoutable) {</span>
      <span class="s1">viewManager =</span>
          <span class="s1">props </span><span class="s2">instanceof </span><span class="s1">ReadableMapBuffer</span>
              <span class="s1">? ReactMapBufferViewManager.INSTANCE</span>
              <span class="s1">: </span><span class="s2">new </span><span class="s1">ReactViewManagerWrapper.DefaultViewManager(</span>
                  <span class="s1">mViewManagerRegistry.get(componentName))</span><span class="s2">;</span>
      <span class="s0">// View Managers are responsible for dealing with initial state and props.</span>
      <span class="s1">view =</span>
          <span class="s1">viewManager.createView(</span>
              <span class="s1">reactTag</span><span class="s2">, </span><span class="s1">mThemedReactContext</span><span class="s2">, </span><span class="s1">propMap</span><span class="s2">, </span><span class="s1">stateWrapper</span><span class="s2">, </span><span class="s1">mJSResponderHandler)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">ViewState viewState = </span><span class="s2">new </span><span class="s1">ViewState(reactTag</span><span class="s2">, </span><span class="s1">view</span><span class="s2">, </span><span class="s1">viewManager)</span><span class="s2">;</span>
    <span class="s1">viewState.mCurrentProps = propMap</span><span class="s2">;</span>
    <span class="s1">viewState.mStateWrapper = stateWrapper</span><span class="s2">;</span>
    <span class="s1">viewState.mEventEmitter = eventEmitterWrapper</span><span class="s2">;</span>

    <span class="s1">mTagToViewState.put(reactTag</span><span class="s2">, </span><span class="s1">viewState)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">updateProps(</span><span class="s2">int </span><span class="s1">reactTag</span><span class="s2">, </span><span class="s1">Object props) {</span>
    <span class="s2">if </span><span class="s1">(isStopped()) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s1">ViewState viewState = getViewState(reactTag)</span><span class="s2">;</span>
    <span class="s1">viewState.mCurrentProps =</span>
        <span class="s1">props </span><span class="s2">instanceof </span><span class="s1">ReadableMap ? </span><span class="s2">new </span><span class="s1">ReactStylesDiffMap((ReadableMap) props) : props</span><span class="s2">;</span>
    <span class="s1">View view = viewState.mView</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(view == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">IllegalStateException(</span><span class="s3">&quot;Unable to find view for tag [&quot; </span><span class="s1">+ reactTag + </span><span class="s3">&quot;]&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">Assertions.assertNotNull(viewState.mViewManager)</span>
        <span class="s1">.updateProperties(view</span><span class="s2">, </span><span class="s1">viewState.mCurrentProps)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Deprecated</span>
  <span class="s2">public void </span><span class="s1">receiveCommand(</span><span class="s2">int </span><span class="s1">reactTag</span><span class="s2">, int </span><span class="s1">commandId</span><span class="s2">, </span><span class="s1">@Nullable ReadableArray commandArgs) {</span>
    <span class="s2">if </span><span class="s1">(isStopped()) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s1">ViewState viewState = getNullableViewState(reactTag)</span><span class="s2">;</span>

    <span class="s0">// It's not uncommon for JS to send events as/after a component is being removed from the</span>
    <span class="s0">// view hierarchy. For example, TextInput may send a &quot;blur&quot; command in response to the view</span>
    <span class="s0">// disappearing. Throw `ReactNoCrashSoftException` so they're logged but don't crash in dev</span>
    <span class="s0">// for now.</span>
    <span class="s2">if </span><span class="s1">(viewState == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">RetryableMountingLayerException(</span>
          <span class="s3">&quot;Unable to find viewState for tag: [&quot; </span><span class="s1">+ reactTag + </span><span class="s3">&quot;] for commandId: &quot; </span><span class="s1">+ commandId)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(viewState.mViewManager == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">RetryableMountingLayerException(</span><span class="s3">&quot;Unable to find viewManager for tag &quot; </span><span class="s1">+ reactTag)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(viewState.mView == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">RetryableMountingLayerException(</span>
          <span class="s3">&quot;Unable to find viewState view for tag &quot; </span><span class="s1">+ reactTag)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">viewState.mViewManager.receiveCommand(viewState.mView</span><span class="s2">, </span><span class="s1">commandId</span><span class="s2">, </span><span class="s1">commandArgs)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">receiveCommand(</span>
      <span class="s2">int </span><span class="s1">reactTag</span><span class="s2">, </span><span class="s1">@NonNull String commandId</span><span class="s2">, </span><span class="s1">@Nullable ReadableArray commandArgs) {</span>
    <span class="s2">if </span><span class="s1">(isStopped()) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s1">ViewState viewState = getNullableViewState(reactTag)</span><span class="s2">;</span>

    <span class="s0">// It's not uncommon for JS to send events as/after a component is being removed from the</span>
    <span class="s0">// view hierarchy. For example, TextInput may send a &quot;blur&quot; command in response to the view</span>
    <span class="s0">// disappearing. Throw `ReactNoCrashSoftException` so they're logged but don't crash in dev</span>
    <span class="s0">// for now.</span>
    <span class="s2">if </span><span class="s1">(viewState == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">RetryableMountingLayerException(</span>
          <span class="s3">&quot;Unable to find viewState for tag: &quot; </span><span class="s1">+ reactTag + </span><span class="s3">&quot; for commandId: &quot; </span><span class="s1">+ commandId)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(viewState.mViewManager == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">RetryableMountingLayerException(</span>
          <span class="s3">&quot;Unable to find viewState manager for tag &quot; </span><span class="s1">+ reactTag)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(viewState.mView == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">RetryableMountingLayerException(</span>
          <span class="s3">&quot;Unable to find viewState view for tag &quot; </span><span class="s1">+ reactTag)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">viewState.mViewManager.receiveCommand(viewState.mView</span><span class="s2">, </span><span class="s1">commandId</span><span class="s2">, </span><span class="s1">commandArgs)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">sendAccessibilityEvent(</span><span class="s2">int </span><span class="s1">reactTag</span><span class="s2">, int </span><span class="s1">eventType) {</span>
    <span class="s2">if </span><span class="s1">(isStopped()) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s1">ViewState viewState = getViewState(reactTag)</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(viewState.mViewManager == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">RetryableMountingLayerException(</span>
          <span class="s3">&quot;Unable to find viewState manager for tag &quot; </span><span class="s1">+ reactTag)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(viewState.mView == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">RetryableMountingLayerException(</span>
          <span class="s3">&quot;Unable to find viewState view for tag &quot; </span><span class="s1">+ reactTag)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">viewState.mView.sendAccessibilityEvent(eventType)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@UiThread</span>
  <span class="s2">public void </span><span class="s1">updateLayout(</span>
      <span class="s2">int </span><span class="s1">reactTag</span><span class="s2">, int </span><span class="s1">parentTag</span><span class="s2">, int </span><span class="s1">x</span><span class="s2">, int </span><span class="s1">y</span><span class="s2">, int </span><span class="s1">width</span><span class="s2">, int </span><span class="s1">height</span><span class="s2">, int </span><span class="s1">displayType) {</span>
    <span class="s2">if </span><span class="s1">(isStopped()) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s1">ViewState viewState = getViewState(reactTag)</span><span class="s2">;</span>
    <span class="s0">// Do not layout Root Views</span>
    <span class="s2">if </span><span class="s1">(viewState.mIsRoot) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s1">View viewToUpdate = viewState.mView</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(viewToUpdate == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">IllegalStateException(</span><span class="s3">&quot;Unable to find View for tag: &quot; </span><span class="s1">+ reactTag)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">viewToUpdate.measure(</span>
        <span class="s1">View.MeasureSpec.makeMeasureSpec(width</span><span class="s2">, </span><span class="s1">View.MeasureSpec.EXACTLY)</span><span class="s2">,</span>
        <span class="s1">View.MeasureSpec.makeMeasureSpec(height</span><span class="s2">, </span><span class="s1">View.MeasureSpec.EXACTLY))</span><span class="s2">;</span>

    <span class="s1">ViewParent parent = viewToUpdate.getParent()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(parent </span><span class="s2">instanceof </span><span class="s1">RootView) {</span>
      <span class="s1">parent.requestLayout()</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">ViewState parentViewState = getViewState(parentTag)</span><span class="s2">;</span>
    <span class="s1">IViewGroupManager&lt;?&gt; parentViewManager = </span><span class="s2">null;</span>
    <span class="s2">if </span><span class="s1">(parentViewState.mViewManager != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">parentViewManager = parentViewState.mViewManager.getViewGroupManager()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(parentViewManager == </span><span class="s2">null </span><span class="s1">|| !parentViewManager.needsCustomLayoutForChildren()) {</span>
      <span class="s1">viewToUpdate.layout(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">x + width</span><span class="s2">, </span><span class="s1">y + height)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s0">// displayType: 0 represents display: 'none'</span>
    <span class="s2">int </span><span class="s1">visibility = displayType == </span><span class="s4">0 </span><span class="s1">? View.INVISIBLE : View.VISIBLE</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(viewToUpdate.getVisibility() != visibility) {</span>
      <span class="s1">viewToUpdate.setVisibility(visibility)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@UiThread</span>
  <span class="s2">public void </span><span class="s1">updatePadding(</span><span class="s2">int </span><span class="s1">reactTag</span><span class="s2">, int </span><span class="s1">left</span><span class="s2">, int </span><span class="s1">top</span><span class="s2">, int </span><span class="s1">right</span><span class="s2">, int </span><span class="s1">bottom) {</span>
    <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isStopped()) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s1">ViewState viewState = getViewState(reactTag)</span><span class="s2">;</span>
    <span class="s0">// Do not layout Root Views</span>
    <span class="s2">if </span><span class="s1">(viewState.mIsRoot) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s1">View viewToUpdate = viewState.mView</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(viewToUpdate == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">IllegalStateException(</span><span class="s3">&quot;Unable to find View for tag: &quot; </span><span class="s1">+ reactTag)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">ReactViewManagerWrapper viewManager = viewState.mViewManager</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(viewManager == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">IllegalStateException(</span><span class="s3">&quot;Unable to find ViewManager for view: &quot; </span><span class="s1">+ viewState)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s0">//noinspection unchecked</span>
    <span class="s1">viewManager.setPadding(viewToUpdate</span><span class="s2">, </span><span class="s1">left</span><span class="s2">, </span><span class="s1">top</span><span class="s2">, </span><span class="s1">right</span><span class="s2">, </span><span class="s1">bottom)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@UiThread</span>
  <span class="s2">public void </span><span class="s1">updateOverflowInset(</span>
      <span class="s2">int </span><span class="s1">reactTag</span><span class="s2">,</span>
      <span class="s2">int </span><span class="s1">overflowInsetLeft</span><span class="s2">,</span>
      <span class="s2">int </span><span class="s1">overflowInsetTop</span><span class="s2">,</span>
      <span class="s2">int </span><span class="s1">overflowInsetRight</span><span class="s2">,</span>
      <span class="s2">int </span><span class="s1">overflowInsetBottom) {</span>
    <span class="s2">if </span><span class="s1">(isStopped()) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s1">ViewState viewState = getViewState(reactTag)</span><span class="s2">;</span>
    <span class="s0">// Do not layout Root Views</span>
    <span class="s2">if </span><span class="s1">(viewState.mIsRoot) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s1">View viewToUpdate = viewState.mView</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(viewToUpdate == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">IllegalStateException(</span><span class="s3">&quot;Unable to find View for tag: &quot; </span><span class="s1">+ reactTag)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(viewToUpdate </span><span class="s2">instanceof </span><span class="s1">ReactOverflowViewWithInset) {</span>
      <span class="s1">((ReactOverflowViewWithInset) viewToUpdate)</span>
          <span class="s1">.setOverflowInset(</span>
              <span class="s1">overflowInsetLeft</span><span class="s2">, </span><span class="s1">overflowInsetTop</span><span class="s2">, </span><span class="s1">overflowInsetRight</span><span class="s2">, </span><span class="s1">overflowInsetBottom)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@UiThread</span>
  <span class="s2">public void </span><span class="s1">updateState(</span><span class="s2">final int </span><span class="s1">reactTag</span><span class="s2">, </span><span class="s1">@Nullable StateWrapper stateWrapper) {</span>
    <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isStopped()) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s1">ViewState viewState = getViewState(reactTag)</span><span class="s2">;</span>

    <span class="s1">StateWrapper prevStateWrapper = viewState.mStateWrapper</span><span class="s2">;</span>
    <span class="s1">viewState.mStateWrapper = stateWrapper</span><span class="s2">;</span>

    <span class="s1">ReactViewManagerWrapper viewManager = viewState.mViewManager</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(viewManager == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">IllegalStateException(</span><span class="s3">&quot;Unable to find ViewManager for tag: &quot; </span><span class="s1">+ reactTag)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">Object extraData =</span>
        <span class="s1">viewManager.updateState(viewState.mView</span><span class="s2">, </span><span class="s1">viewState.mCurrentProps</span><span class="s2">, </span><span class="s1">stateWrapper)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(extraData != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">viewManager.updateExtraData(viewState.mView</span><span class="s2">, </span><span class="s1">extraData)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s0">// Immediately clear native side of previous state wrapper. This causes the State object in C++</span>
    <span class="s0">// to be destroyed immediately instead of waiting for Java GC to kick in.</span>
    <span class="s2">if </span><span class="s1">(prevStateWrapper != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">prevStateWrapper.destroyState()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s5">/** We update the event emitter from the main thread when the view is mounted. */</span>
  <span class="s1">@UiThread</span>
  <span class="s2">public void </span><span class="s1">updateEventEmitter(</span><span class="s2">int </span><span class="s1">reactTag</span><span class="s2">, </span><span class="s1">@NonNull EventEmitterWrapper eventEmitter) {</span>
    <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isStopped()) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s1">ViewState viewState = mTagToViewState.get(reactTag)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(viewState == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s0">// TODO T62717437 - Use a flag to determine that these event emitters belong to virtual nodes</span>
      <span class="s0">// only.</span>
      <span class="s1">viewState = </span><span class="s2">new </span><span class="s1">ViewState(reactTag</span><span class="s2">, null, null</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">mTagToViewState.put(reactTag</span><span class="s2">, </span><span class="s1">viewState)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">EventEmitterWrapper previousEventEmitterWrapper = viewState.mEventEmitter</span><span class="s2">;</span>
    <span class="s1">viewState.mEventEmitter = eventEmitter</span><span class="s2">;</span>

    <span class="s0">// Immediately destroy native side of wrapper, instead of waiting for Java GC.</span>
    <span class="s2">if </span><span class="s1">(previousEventEmitterWrapper != eventEmitter &amp;&amp; previousEventEmitterWrapper != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">previousEventEmitterWrapper.destroy()</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(viewState.mPendingEventQueue != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s0">// Invoke pending event queued to the view state</span>
      <span class="s2">for </span><span class="s1">(ViewEvent viewEvent : viewState.mPendingEventQueue) {</span>
        <span class="s2">if </span><span class="s1">(viewEvent.canCoalesceEvent()) {</span>
          <span class="s1">eventEmitter.invokeUnique(</span>
              <span class="s1">viewEvent.getEventName()</span><span class="s2">, </span><span class="s1">viewEvent.getParams()</span><span class="s2">, </span><span class="s1">viewEvent.getCustomCoalesceKey())</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">eventEmitter.invoke(</span>
              <span class="s1">viewEvent.getEventName()</span><span class="s2">, </span><span class="s1">viewEvent.getParams()</span><span class="s2">, </span><span class="s1">viewEvent.getEventCategory())</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s1">viewState.mPendingEventQueue = </span><span class="s2">null;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@UiThread</span>
  <span class="s2">public synchronized void </span><span class="s1">setJSResponder(</span>
      <span class="s2">int </span><span class="s1">reactTag</span><span class="s2">, int </span><span class="s1">initialReactTag</span><span class="s2">, boolean </span><span class="s1">blockNativeResponder) {</span>
    <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isStopped()) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(!blockNativeResponder) {</span>
      <span class="s1">mJSResponderHandler.setJSResponder(initialReactTag</span><span class="s2">, null</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s1">ViewState viewState = getViewState(reactTag)</span><span class="s2">;</span>
    <span class="s1">View view = viewState.mView</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(initialReactTag != reactTag &amp;&amp; view </span><span class="s2">instanceof </span><span class="s1">ViewParent) {</span>
      <span class="s0">// In this case, initialReactTag corresponds to a virtual/layout-only View, and we already</span>
      <span class="s0">// have a parent of that View in reactTag, so we can use it.</span>
      <span class="s1">mJSResponderHandler.setJSResponder(initialReactTag</span><span class="s2">, </span><span class="s1">(ViewParent) view)</span><span class="s2">;</span>
      <span class="s2">return;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(view == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">SoftAssertions.assertUnreachable(</span><span class="s3">&quot;Cannot find view for tag [&quot; </span><span class="s1">+ reactTag + </span><span class="s3">&quot;].&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(viewState.mIsRoot) {</span>
      <span class="s1">SoftAssertions.assertUnreachable(</span>
          <span class="s3">&quot;Cannot block native responder on [&quot; </span><span class="s1">+ reactTag + </span><span class="s3">&quot;] that is a root view&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">mJSResponderHandler.setJSResponder(initialReactTag</span><span class="s2">, </span><span class="s1">view.getParent())</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@UiThread</span>
  <span class="s2">private void </span><span class="s1">onViewStateDeleted(ViewState viewState) {</span>
    <span class="s0">// Destroy state immediately instead of waiting for Java GC.</span>
    <span class="s2">if </span><span class="s1">(viewState.mStateWrapper != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">viewState.mStateWrapper.destroyState()</span><span class="s2">;</span>
      <span class="s1">viewState.mStateWrapper = </span><span class="s2">null;</span>
    <span class="s1">}</span>

    <span class="s0">// Destroy EventEmitterWrapper immediately instead of waiting for Java GC.</span>
    <span class="s0">// Notably, this is also required to ensure that the EventEmitterWrapper is deallocated</span>
    <span class="s0">// before the JS VM is deallocated, since it holds onto a JSI::Pointer.</span>
    <span class="s2">if </span><span class="s1">(viewState.mEventEmitter != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">viewState.mEventEmitter.destroy()</span><span class="s2">;</span>
      <span class="s1">viewState.mEventEmitter = </span><span class="s2">null;</span>
    <span class="s1">}</span>

    <span class="s0">// For non-root views we notify viewmanager with {@link ViewManager#onDropInstance}</span>
    <span class="s1">ReactViewManagerWrapper viewManager = viewState.mViewManager</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!viewState.mIsRoot &amp;&amp; viewManager != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">viewManager.onDropViewInstance(viewState.mView)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@UiThread</span>
  <span class="s2">public void </span><span class="s1">deleteView(</span><span class="s2">int </span><span class="s1">reactTag) {</span>
    <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isStopped()) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s1">ViewState viewState = getNullableViewState(reactTag)</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(viewState == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">ReactSoftExceptionLogger.logSoftException(</span>
          <span class="s1">MountingManager.TAG</span><span class="s2">,</span>
          <span class="s2">new </span><span class="s1">IllegalStateException(</span>
              <span class="s3">&quot;Unable to find viewState for tag: &quot; </span><span class="s1">+ reactTag + </span><span class="s3">&quot; for deleteView&quot;</span><span class="s1">))</span><span class="s2">;</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s0">// To delete we simply remove the tag from the registry.</span>
    <span class="s0">// We want to rely on the correct set of MountInstructions being sent to the platform,</span>
    <span class="s0">// or StopSurface being called, so we do not handle deleting descendents of the View.</span>
    <span class="s1">mTagToViewState.remove(reactTag)</span><span class="s2">;</span>

    <span class="s1">onViewStateDeleted(viewState)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@UiThread</span>
  <span class="s2">public void </span><span class="s1">preallocateView(</span>
      <span class="s1">String componentName</span><span class="s2">,</span>
      <span class="s2">int </span><span class="s1">reactTag</span><span class="s2">,</span>
      <span class="s1">@Nullable Object props</span><span class="s2">,</span>
      <span class="s1">@Nullable StateWrapper stateWrapper</span><span class="s2">,</span>
      <span class="s1">@Nullable EventEmitterWrapper eventEmitterWrapper</span><span class="s2">,</span>
      <span class="s2">boolean </span><span class="s1">isLayoutable) {</span>
    <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(isStopped()) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s0">// We treat this as a perf problem and not a logical error. View Preallocation or unexpected</span>
    <span class="s0">// changes to Differ or C++ Binding could cause some redundant Create instructions.</span>
    <span class="s2">if </span><span class="s1">(getNullableViewState(reactTag) != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s1">createViewUnsafe(</span>
        <span class="s1">componentName</span><span class="s2">, </span><span class="s1">reactTag</span><span class="s2">, </span><span class="s1">props</span><span class="s2">, </span><span class="s1">stateWrapper</span><span class="s2">, </span><span class="s1">eventEmitterWrapper</span><span class="s2">, </span><span class="s1">isLayoutable)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@AnyThread</span>
  <span class="s1">@ThreadConfined(ANY)</span>
  <span class="s2">public </span><span class="s1">@Nullable EventEmitterWrapper getEventEmitter(</span><span class="s2">int </span><span class="s1">reactTag) {</span>
    <span class="s1">ViewState viewState = getNullableViewState(reactTag)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">viewState == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">null </span><span class="s1">: viewState.mEventEmitter</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@UiThread</span>
  <span class="s2">public </span><span class="s1">View getView(</span><span class="s2">int </span><span class="s1">reactTag) {</span>
    <span class="s1">ViewState state = getNullableViewState(reactTag)</span><span class="s2">;</span>
    <span class="s1">View view = state == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">null </span><span class="s1">: state.mView</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(view == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">IllegalViewOperationException(</span>
          <span class="s3">&quot;Trying to resolve view with tag &quot; </span><span class="s1">+ reactTag + </span><span class="s3">&quot; which doesn't exist&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">view</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private </span><span class="s1">@NonNull ViewState getViewState(</span><span class="s2">int </span><span class="s1">tag) {</span>
    <span class="s1">ViewState viewState = mTagToViewState.get(tag)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(viewState == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">RetryableMountingLayerException(</span>
          <span class="s3">&quot;Unable to find viewState for tag &quot; </span><span class="s1">+ tag + </span><span class="s3">&quot;. Surface stopped: &quot; </span><span class="s1">+ isStopped())</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">viewState</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private </span><span class="s1">@Nullable ViewState getNullableViewState(</span><span class="s2">int </span><span class="s1">tag) {</span>
    <span class="s1">ConcurrentHashMap&lt;Integer</span><span class="s2">, </span><span class="s1">ViewState&gt; viewStates = mTagToViewState</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(viewStates == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">return null;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">viewStates.get(tag)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@SuppressWarnings(</span><span class="s3">&quot;unchecked&quot;</span><span class="s1">) </span><span class="s0">// prevents unchecked conversion warn of the &lt;ViewGroup&gt; type</span>
  <span class="s2">private static </span><span class="s1">@NonNull IViewGroupManager&lt;ViewGroup&gt; getViewGroupManager(</span>
      <span class="s1">@NonNull ViewState viewState) {</span>
    <span class="s2">if </span><span class="s1">(viewState.mViewManager == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">IllegalStateException(</span><span class="s3">&quot;Unable to find ViewManager for view: &quot; </span><span class="s1">+ viewState)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">(IViewGroupManager&lt;ViewGroup&gt;) viewState.mViewManager.getViewGroupManager()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">printSurfaceState() {</span>
    <span class="s1">FLog.e(TAG</span><span class="s2">, </span><span class="s3">&quot;Views created for surface {%d}:&quot;</span><span class="s2">, </span><span class="s1">getSurfaceId())</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(ViewState viewState : mTagToViewState.values()) {</span>
      <span class="s1">String viewManagerName =</span>
          <span class="s1">viewState.mViewManager != </span><span class="s2">null </span><span class="s1">? viewState.mViewManager.getName() : </span><span class="s2">null;</span>
      <span class="s1">@Nullable View view = viewState.mView</span><span class="s2">;</span>
      <span class="s1">@Nullable View parent = view != </span><span class="s2">null </span><span class="s1">? (View) view.getParent() : </span><span class="s2">null;</span>
      <span class="s1">@Nullable Integer parentTag = parent != </span><span class="s2">null </span><span class="s1">? parent.getId() : </span><span class="s2">null;</span>

      <span class="s1">FLog.e(</span>
          <span class="s1">TAG</span><span class="s2">,</span>
          <span class="s3">&quot;&lt;%s id=%d parentTag=%s isRoot=%b /&gt;&quot;</span><span class="s2">,</span>
          <span class="s1">viewManagerName</span><span class="s2">,</span>
          <span class="s1">viewState.mReactTag</span><span class="s2">,</span>
          <span class="s1">parentTag</span><span class="s2">,</span>
          <span class="s1">viewState.mIsRoot)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@UiThread</span>
  <span class="s2">public void </span><span class="s1">enqueuePendingEvent(</span><span class="s2">int </span><span class="s1">reactTag</span><span class="s2">, </span><span class="s1">ViewEvent viewEvent) {</span>
    <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>

    <span class="s0">// When the surface stopped we will reset the view state map. We are not going to enqueue</span>
    <span class="s0">// pending events as they are not expected to be dispatched anyways.</span>
    <span class="s2">if </span><span class="s1">(mTagToViewState == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s1">ViewState viewState = mTagToViewState.get(reactTag)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(viewState == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s0">// Cannot queue event without view state. Do nothing here.</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s1">Assertions.assertCondition(</span>
        <span class="s1">viewState.mEventEmitter == </span><span class="s2">null,</span>
        <span class="s3">&quot;Only queue pending events when event emitter is null for the given view state&quot;</span><span class="s1">)</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(viewState.mPendingEventQueue == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">viewState.mPendingEventQueue = </span><span class="s2">new </span><span class="s1">LinkedList&lt;&gt;()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">viewState.mPendingEventQueue.add(viewEvent)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s5">/**</span>
   <span class="s5">* This class holds view state for react tags. Objects of this class are stored into the {</span><span class="s7">@link</span>
   <span class="s5">* #mTagToViewState}, and they should be updated in the same thread.</span>
   <span class="s5">*/</span>
  <span class="s2">private static class </span><span class="s1">ViewState {</span>
    <span class="s1">@Nullable </span><span class="s2">final </span><span class="s1">View mView</span><span class="s2">;</span>
    <span class="s2">final int </span><span class="s1">mReactTag</span><span class="s2">;</span>
    <span class="s2">final boolean </span><span class="s1">mIsRoot</span><span class="s2">;</span>
    <span class="s1">@Nullable </span><span class="s2">final </span><span class="s1">ReactViewManagerWrapper mViewManager</span><span class="s2">;</span>
    <span class="s1">@Nullable </span><span class="s2">public </span><span class="s1">Object mCurrentProps = </span><span class="s2">null;</span>
    <span class="s1">@Nullable </span><span class="s2">public </span><span class="s1">ReadableMap mCurrentLocalData = </span><span class="s2">null;</span>
    <span class="s1">@Nullable </span><span class="s2">public </span><span class="s1">StateWrapper mStateWrapper = </span><span class="s2">null;</span>
    <span class="s1">@Nullable </span><span class="s2">public </span><span class="s1">EventEmitterWrapper mEventEmitter = </span><span class="s2">null;</span>
    <span class="s1">@Nullable </span><span class="s2">public </span><span class="s1">Queue&lt;ViewEvent&gt; mPendingEventQueue = </span><span class="s2">null;</span>

    <span class="s2">private </span><span class="s1">ViewState(</span>
        <span class="s2">int </span><span class="s1">reactTag</span><span class="s2">, </span><span class="s1">@Nullable View view</span><span class="s2">, </span><span class="s1">@Nullable ReactViewManagerWrapper viewManager) {</span>
      <span class="s2">this</span><span class="s1">(reactTag</span><span class="s2">, </span><span class="s1">view</span><span class="s2">, </span><span class="s1">viewManager</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">private </span><span class="s1">ViewState(</span>
        <span class="s2">int </span><span class="s1">reactTag</span><span class="s2">,</span>
        <span class="s1">@Nullable View view</span><span class="s2">,</span>
        <span class="s1">@Nullable ReactViewManagerWrapper viewManager</span><span class="s2">,</span>
        <span class="s2">boolean </span><span class="s1">isRoot) {</span>
      <span class="s1">mReactTag = reactTag</span><span class="s2">;</span>
      <span class="s1">mView = view</span><span class="s2">;</span>
      <span class="s1">mIsRoot = isRoot</span><span class="s2">;</span>
      <span class="s1">mViewManager = viewManager</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">@Override</span>
    <span class="s2">public </span><span class="s1">String toString() {</span>
      <span class="s2">boolean </span><span class="s1">isLayoutOnly = mViewManager == </span><span class="s2">null;</span>
      <span class="s2">return </span><span class="s3">&quot;ViewState [&quot;</span>
          <span class="s1">+ mReactTag</span>
          <span class="s1">+ </span><span class="s3">&quot;] - isRoot: &quot;</span>
          <span class="s1">+ mIsRoot</span>
          <span class="s1">+ </span><span class="s3">&quot; - props: &quot;</span>
          <span class="s1">+ mCurrentProps</span>
          <span class="s1">+ </span><span class="s3">&quot; - localData: &quot;</span>
          <span class="s1">+ mCurrentLocalData</span>
          <span class="s1">+ </span><span class="s3">&quot; - viewManager: &quot;</span>
          <span class="s1">+ mViewManager</span>
          <span class="s1">+ </span><span class="s3">&quot; - isLayoutOnly: &quot;</span>
          <span class="s1">+ isLayoutOnly</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">public static class </span><span class="s1">ViewEvent {</span>
    <span class="s2">private final </span><span class="s1">String mEventName</span><span class="s2">;</span>
    <span class="s2">private final boolean </span><span class="s1">mCanCoalesceEvent</span><span class="s2">;</span>
    <span class="s2">private final int </span><span class="s1">mCustomCoalesceKey</span><span class="s2">;</span>
    <span class="s2">private final </span><span class="s1">@EventCategoryDef </span><span class="s2">int </span><span class="s1">mEventCategory</span><span class="s2">;</span>
    <span class="s2">private </span><span class="s1">@Nullable WritableMap mParams</span><span class="s2">;</span>

    <span class="s2">public </span><span class="s1">ViewEvent(</span>
        <span class="s1">String eventName</span><span class="s2">,</span>
        <span class="s1">@Nullable WritableMap params</span><span class="s2">,</span>
        <span class="s1">@EventCategoryDef </span><span class="s2">int </span><span class="s1">eventCategory</span><span class="s2">,</span>
        <span class="s2">boolean </span><span class="s1">canCoalesceEvent</span><span class="s2">,</span>
        <span class="s2">int </span><span class="s1">customCoalesceKey) {</span>
      <span class="s1">mEventName = eventName</span><span class="s2">;</span>
      <span class="s1">mParams = params</span><span class="s2">;</span>
      <span class="s1">mEventCategory = eventCategory</span><span class="s2">;</span>
      <span class="s1">mCanCoalesceEvent = canCoalesceEvent</span><span class="s2">;</span>
      <span class="s1">mCustomCoalesceKey = customCoalesceKey</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">public </span><span class="s1">String getEventName() {</span>
      <span class="s2">return </span><span class="s1">mEventName</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">public boolean </span><span class="s1">canCoalesceEvent() {</span>
      <span class="s2">return </span><span class="s1">mCanCoalesceEvent</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">public int </span><span class="s1">getCustomCoalesceKey() {</span>
      <span class="s2">return </span><span class="s1">mCustomCoalesceKey</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">public </span><span class="s1">@EventCategoryDef </span><span class="s2">int </span><span class="s1">getEventCategory() {</span>
      <span class="s2">return </span><span class="s1">mEventCategory</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">public </span><span class="s1">@Nullable WritableMap getParams() {</span>
      <span class="s2">return </span><span class="s1">mParams</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">private class </span><span class="s1">RemoveDeleteTreeUIFrameCallback </span><span class="s2">extends </span><span class="s1">GuardedFrameCallback {</span>
    <span class="s2">private static final long </span><span class="s1">FRAME_TIME_MS = </span><span class="s4">16</span><span class="s2">;</span>
    <span class="s2">private static final long </span><span class="s1">MAX_TIME_IN_FRAME = </span><span class="s4">9</span><span class="s2">;</span>

    <span class="s2">private </span><span class="s1">RemoveDeleteTreeUIFrameCallback(@NonNull ReactContext reactContext) {</span>
      <span class="s2">super</span><span class="s1">(reactContext)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s5">/**</span>
     <span class="s5">* Detect if we still have processing time left in this frame. Technically, it should be fine</span>
     <span class="s5">* for this to take up to 15ms since it executes after all other important UI work.</span>
     <span class="s5">*/</span>
    <span class="s2">private boolean </span><span class="s1">haveExceededNonBatchedFrameTime(</span><span class="s2">long </span><span class="s1">frameTimeNanos) {</span>
      <span class="s2">long </span><span class="s1">timeLeftInFrame = FRAME_TIME_MS - ((System.nanoTime() - frameTimeNanos) / </span><span class="s4">1000000</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">return </span><span class="s1">timeLeftInFrame &lt; MAX_TIME_IN_FRAME</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">@Override</span>
    <span class="s1">@UiThread</span>
    <span class="s1">@ThreadConfined(UI)</span>
    <span class="s2">public void </span><span class="s1">doFrameGuarded(</span><span class="s2">long </span><span class="s1">frameTimeNanos) {</span>
      <span class="s2">int </span><span class="s1">deletedViews = </span><span class="s4">0</span><span class="s2">;</span>
      <span class="s1">Stack&lt;Integer&gt; localChildren = </span><span class="s2">new </span><span class="s1">Stack&lt;&gt;()</span><span class="s2">;</span>
      <span class="s2">try </span><span class="s1">{</span>
        <span class="s2">while </span><span class="s1">(!mReactTagsToRemove.empty()) {</span>
          <span class="s2">int </span><span class="s1">reactTag = mReactTagsToRemove.pop()</span><span class="s2">;</span>
          <span class="s1">deletedViews++</span><span class="s2">;</span>

          <span class="s0">// This is &quot;impossible&quot;. See comments above.</span>
          <span class="s2">if </span><span class="s1">(mErroneouslyReaddedReactTags.contains(reactTag)) {</span>
            <span class="s1">ReactSoftExceptionLogger.logSoftException(</span>
                <span class="s1">TAG</span><span class="s2">,</span>
                <span class="s2">new </span><span class="s1">IllegalViewOperationException(</span>
                    <span class="s3">&quot;RemoveDeleteTree recursively tried to remove a React View that was actually reused. This indicates a bug in the Differ. [&quot;</span>
                        <span class="s1">+ reactTag</span>
                        <span class="s1">+ </span><span class="s3">&quot;]&quot;</span><span class="s1">))</span><span class="s2">;</span>
            <span class="s2">continue;</span>
          <span class="s1">}</span>

          <span class="s1">localChildren.clear()</span><span class="s2">;</span>

          <span class="s1">ViewState thisViewState = getNullableViewState(reactTag)</span><span class="s2">;</span>
          <span class="s2">if </span><span class="s1">(thisViewState != </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">View thisView = thisViewState.mView</span><span class="s2">;</span>
            <span class="s2">int </span><span class="s1">numChildren = </span><span class="s4">0</span><span class="s2">;</span>

            <span class="s0">// Children are managed by React Native if both of the following are true:</span>
            <span class="s0">// 1) There are 1 or more children of this View, which must be a ViewGroup</span>
            <span class="s0">// 2) Those children are managed by RN (this is not the case for certain native</span>
            <span class="s0">// components, like embedded Litho hierarchies)</span>
            <span class="s2">boolean </span><span class="s1">childrenAreManaged = </span><span class="s2">false;</span>

            <span class="s2">if </span><span class="s1">(thisView </span><span class="s2">instanceof </span><span class="s1">ViewGroup) {</span>
              <span class="s1">View nextChild = </span><span class="s2">null;</span>
              <span class="s0">// For reasons documented elsewhere in this class, getChildCount is not</span>
              <span class="s0">// necessarily reliable, and so we rely instead on requesting children directly.</span>
              <span class="s2">while </span><span class="s1">((nextChild = ((ViewGroup) thisView).getChildAt(numChildren)) != </span><span class="s2">null</span><span class="s1">) {</span>
                <span class="s2">int </span><span class="s1">childId = nextChild.getId()</span><span class="s2">;</span>
                <span class="s1">childrenAreManaged = childrenAreManaged || getNullableViewState(childId) != </span><span class="s2">null;</span>
                <span class="s1">localChildren.push(nextChild.getId())</span><span class="s2">;</span>
                <span class="s1">numChildren++</span><span class="s2">;</span>
              <span class="s1">}</span>
              <span class="s0">// Removing all at once is more efficient than removing one-by-one</span>
              <span class="s0">// If the children are not managed by RN, we simply drop the entire</span>
              <span class="s0">// subtree instead of recursing further.</span>
              <span class="s2">if </span><span class="s1">(childrenAreManaged) {</span>
                <span class="s2">try </span><span class="s1">{</span>
                  <span class="s0">// This can happen if the removeAllViews method is overridden to throw,</span>
                  <span class="s0">// which it is explicitly in some cases (for example embedded Litho views,</span>
                  <span class="s0">// but there could be other cases). In those cases, we want to fail silently</span>
                  <span class="s0">// and then assume the subtree is /not/ managed by React Native.</span>
                  <span class="s0">// In this case short-lived memory-leaks could occur if we aren't clearing</span>
                  <span class="s0">// out the ViewState map properly; but the risk should be small.</span>
                  <span class="s0">// In debug mode, the SoftException will cause a crash. In production it</span>
                  <span class="s0">// will not. This should give good visibility into whether or not this is</span>
                  <span class="s0">// a problem without causing user-facing errors.</span>
                  <span class="s1">((ViewGroup) thisView).removeAllViews()</span><span class="s2">;</span>
                <span class="s1">} </span><span class="s2">catch </span><span class="s1">(RuntimeException e) {</span>
                  <span class="s1">childrenAreManaged = </span><span class="s2">false;</span>
                  <span class="s1">ReactSoftExceptionLogger.logSoftException(TAG</span><span class="s2">, </span><span class="s1">e)</span><span class="s2">;</span>
                <span class="s1">}</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(childrenAreManaged) {</span>
              <span class="s0">// Push tags onto the stack so we process all children</span>
              <span class="s1">mReactTagsToRemove.addAll(localChildren)</span><span class="s2">;</span>
            <span class="s1">}</span>

            <span class="s0">// Immediately remove tag and notify listeners.</span>
            <span class="s0">// Note that this causes RemoveDeleteTree to call onViewStateDeleted</span>
            <span class="s0">// in a top-down matter (parents first) vs a bottom-up matter (leaf nodes first).</span>
            <span class="s0">// Hopefully this doesn't matter but you should ensure that any custom</span>
            <span class="s0">// onViewStateDeleted logic is resilient to both semantics.</span>
            <span class="s0">// In the initial version of RemoveDeleteTree we attempted to maintain</span>
            <span class="s0">// the bottom-up event listener behavior but this causes additional</span>
            <span class="s0">// memory pressure as well as complexity.</span>
            <span class="s1">mTagToViewState.remove(reactTag)</span><span class="s2">;</span>
            <span class="s1">onViewStateDeleted(thisViewState)</span><span class="s2">;</span>

            <span class="s0">// Circuit breaker: after processing every N tags, check that we haven't</span>
            <span class="s0">// exceeded the max allowed time. Since we don't know what other work needs</span>
            <span class="s0">// to happen on the UI thread during this frame, and since this works tends to be</span>
            <span class="s0">// low-priority, we only give this function a fraction of a frame to run.</span>
            <span class="s2">if </span><span class="s1">(deletedViews % </span><span class="s4">20 </span><span class="s1">== </span><span class="s4">0 </span><span class="s1">&amp;&amp; haveExceededNonBatchedFrameTime(frameTimeNanos)) {</span>
              <span class="s2">break;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(!mReactTagsToRemove.empty()) {</span>
          <span class="s1">ReactChoreographer.getInstance()</span>
              <span class="s1">.postFrameCallback(ReactChoreographer.CallbackType.IDLE_EVENT</span><span class="s2">, this</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s0">// If there are no more tags to process, then clear the &quot;reused&quot;</span>
          <span class="s0">// tag set. Since the RemoveDeleteTree runner executes /after/ all</span>
          <span class="s0">// other mounting instructions have been executed, all in-band Remove</span>
          <span class="s0">// instructions have already had a chance to execute here.</span>
          <span class="s1">mErroneouslyReaddedReactTags.clear()</span><span class="s2">;</span>
          <span class="s1">mReactTagsToRemove.clear()</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
</pre>
</body>
</html>
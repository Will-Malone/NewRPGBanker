<html>
<head>
<title>namespace.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
.s1 { color: #6a8759;}
.s2 { color: #6897bb; font-style: italic;}
.s3 { color: #cc7832; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
namespace.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_core&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;transpileNamespace&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;allowNamespaces&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;declare&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;remove&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;buildCodeFrameError&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;handleNested&quot;</span><span class="s0">,</span><span class="s1">&quot;t&quot;</span><span class="s0">,</span><span class="s1">&quot;cloneNode&quot;</span><span class="s0">,</span><span class="s1">&quot;bound&quot;</span><span class="s0">,</span><span class="s1">&quot;scope&quot;</span><span class="s0">,</span><span class="s1">&quot;hasOwnBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;parent&quot;</span><span class="s0">,</span><span class="s1">&quot;parentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;insertAfter&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceWith&quot;</span><span class="s0">,</span><span class="s1">&quot;getDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;registerDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceWithMultiple&quot;</span><span class="s0">,</span><span class="s1">&quot;variableDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;variableDeclarator&quot;</span><span class="s0">,</span><span class="s1">&quot;identifier&quot;</span><span class="s0">,</span><span class="s1">&quot;getMemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;itemName&quot;</span><span class="s0">,</span><span class="s1">&quot;memberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;handleVariableDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;hub&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">,</span><span class="s1">&quot;declarations&quot;</span><span class="s0">,</span><span class="s1">&quot;every&quot;</span><span class="s0">,</span><span class="s1">&quot;declarator&quot;</span><span class="s0">,</span><span class="s1">&quot;isIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;init&quot;</span><span class="s0">,</span><span class="s1">&quot;assignmentExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;bindingIdentifiers&quot;</span><span class="s0">,</span><span class="s1">&quot;getBindingIdentifiers&quot;</span><span class="s0">,</span><span class="s1">&quot;assignments&quot;</span><span class="s0">,</span><span class="s1">&quot;idName&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;expressionStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;sequenceExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;buildNestedAmbientModuleError&quot;</span><span class="s0">,</span><span class="s1">&quot;buildError&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;parentExport&quot;</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">,</span><span class="s1">&quot;Set&quot;</span><span class="s0">,</span><span class="s1">&quot;realName&quot;</span><span class="s0">,</span><span class="s1">&quot;assertIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;generateUid&quot;</span><span class="s0">,</span><span class="s1">&quot;namespaceTopLevel&quot;</span><span class="s0">,</span><span class="s1">&quot;isTSModuleBlock&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;exportNamedDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;subNode&quot;</span><span class="s0">,</span><span class="s1">&quot;transformed&quot;</span><span class="s0">,</span><span class="s1">&quot;moduleName&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;add&quot;</span><span class="s0">,</span><span class="s1">&quot;splice&quot;</span><span class="s0">,</span><span class="s1">&quot;declaration&quot;</span><span class="s0">,</span><span class="s1">&quot;nodes&quot;</span><span class="s0">,</span><span class="s1">&quot;fallthroughValue&quot;</span><span class="s0">,</span><span class="s1">&quot;objectExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;memberExpr&quot;</span><span class="s0">,</span><span class="s1">&quot;template&quot;</span><span class="s0">,</span><span class="s1">&quot;expression&quot;</span><span class="s0">,</span><span class="s1">&quot;ast&quot;</span><span class="s0">,</span><span class="s1">&quot;statement&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../src/namespace.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { template, types as t } from </span><span class="s3">\&quot;</span><span class="s1">@babel/core</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { NodePath } from </span><span class="s3">\&quot;</span><span class="s1">@babel/traverse</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">export default function transpileNamespace(</span><span class="s3">\n  </span><span class="s1">path: NodePath&lt;t.TSModuleDeclaration&gt;,</span><span class="s3">\n  </span><span class="s1">allowNamespaces: boolean,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (path.node.declare || path.node.id.type === </span><span class="s3">\&quot;</span><span class="s1">StringLiteral</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">path.remove();</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (!allowNamespaces) {</span><span class="s3">\n    </span><span class="s1">throw path</span><span class="s3">\n      </span><span class="s1">.get(</span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">.buildCodeFrameError(</span><span class="s3">\n        \&quot;</span><span class="s1">Namespace not marked type-only declare.</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n          \&quot; </span><span class="s1">Non-declarative namespaces are only supported experimentally in Babel.</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n          \&quot; </span><span class="s1">To enable and review caveats see:</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n          \&quot; </span><span class="s1">https://babeljs.io/docs/en/babel-plugin-transform-typescript</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const name = path.node.id.name;</span><span class="s3">\n  </span><span class="s1">const value = handleNested(path, t.cloneNode(path.node, true));</span><span class="s3">\n  </span><span class="s1">const bound = path.scope.hasOwnBinding(name);</span><span class="s3">\n  </span><span class="s1">if (path.parent.type === </span><span class="s3">\&quot;</span><span class="s1">ExportNamedDeclaration</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">if (!bound) {</span><span class="s3">\n      </span><span class="s1">path.parentPath.insertAfter(value);</span><span class="s3">\n      </span><span class="s1">path.replaceWith(getDeclaration(name));</span><span class="s3">\n      </span><span class="s1">path.scope.registerDeclaration(path.parentPath);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">path.parentPath.replaceWith(value);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else if (bound) {</span><span class="s3">\n    </span><span class="s1">path.replaceWith(value);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">path.scope.registerDeclaration(</span><span class="s3">\n      </span><span class="s1">path.replaceWithMultiple([getDeclaration(name), value])[0],</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getDeclaration(name: string) {</span><span class="s3">\n  </span><span class="s1">return t.variableDeclaration(</span><span class="s3">\&quot;</span><span class="s1">let</span><span class="s3">\&quot;</span><span class="s1">, [</span><span class="s3">\n    </span><span class="s1">t.variableDeclarator(t.identifier(name)),</span><span class="s3">\n  </span><span class="s1">]);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getMemberExpression(name: string, itemName: string) {</span><span class="s3">\n  </span><span class="s1">return t.memberExpression(t.identifier(name), t.identifier(itemName));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Convert export const foo = 1 to Namespace.foo = 1;</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {t.VariableDeclaration} node given variable declaration, e.g. `const foo = 1`</span><span class="s3">\n </span><span class="s1">* @param {string} name the generated unique namespace member name</span><span class="s3">\n </span><span class="s1">* @param {*} hub An instance implements HubInterface defined in `@babel/traverse` that can throw a code frame error</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function handleVariableDeclaration(</span><span class="s3">\n  </span><span class="s1">node: t.VariableDeclaration,</span><span class="s3">\n  </span><span class="s1">name: string,</span><span class="s3">\n  </span><span class="s1">hub: any,</span><span class="s3">\n</span><span class="s1">): t.Statement[] {</span><span class="s3">\n  </span><span class="s1">if (node.kind !== </span><span class="s3">\&quot;</span><span class="s1">const</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">throw hub.file.buildCodeFrameError(</span><span class="s3">\n      </span><span class="s1">node,</span><span class="s3">\n      \&quot;</span><span class="s1">Namespaces exporting non-const are not supported by Babel.</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n        \&quot; </span><span class="s1">Change to const or see:</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n        \&quot; </span><span class="s1">https://babeljs.io/docs/en/babel-plugin-transform-typescript</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const { declarations } = node;</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">declarations.every(</span><span class="s3">\n      </span><span class="s1">(declarator): declarator is t.VariableDeclarator &amp; { id: t.Identifier } =&gt;</span><span class="s3">\n        </span><span class="s1">t.isIdentifier(declarator.id),</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">// `export const a = 1` transforms to `const a = N.a = 1`, the output</span><span class="s3">\n    </span><span class="s1">// is smaller than `const a = 1; N.a = a`;</span><span class="s3">\n    </span><span class="s1">for (const declarator of declarations) {</span><span class="s3">\n      </span><span class="s1">declarator.init = t.assignmentExpression(</span><span class="s3">\n        \&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">getMemberExpression(name, declarator.id.name),</span><span class="s3">\n        </span><span class="s1">declarator.init,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return [node];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// Now we have pattern in declarators</span><span class="s3">\n  </span><span class="s1">// `export const [a] = 1` transforms to `const [a] = 1; N.a = a`</span><span class="s3">\n  </span><span class="s1">const bindingIdentifiers = t.getBindingIdentifiers(node);</span><span class="s3">\n  </span><span class="s1">const assignments = [];</span><span class="s3">\n  </span><span class="s1">// getBindingIdentifiers returns an object without prototype.</span><span class="s3">\n  </span><span class="s1">// eslint-disable-next-line guard-for-in</span><span class="s3">\n  </span><span class="s1">for (const idName in bindingIdentifiers) {</span><span class="s3">\n    </span><span class="s1">assignments.push(</span><span class="s3">\n      </span><span class="s1">t.assignmentExpression(</span><span class="s3">\n        \&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">getMemberExpression(name, idName),</span><span class="s3">\n        </span><span class="s1">t.cloneNode(bindingIdentifiers[idName]),</span><span class="s3">\n      </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return [node, t.expressionStatement(t.sequenceExpression(assignments))];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function buildNestedAmbientModuleError(path: NodePath, node: t.Node) {</span><span class="s3">\n  </span><span class="s1">return path.hub.buildError(</span><span class="s3">\n    </span><span class="s1">node,</span><span class="s3">\n    \&quot;</span><span class="s1">Ambient modules cannot be nested in other modules or namespaces.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">Error,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function handleNested(</span><span class="s3">\n  </span><span class="s1">path: NodePath,</span><span class="s3">\n  </span><span class="s1">node: t.TSModuleDeclaration,</span><span class="s3">\n  </span><span class="s1">parentExport?: t.Expression,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const names = new Set();</span><span class="s3">\n  </span><span class="s1">const realName = node.id;</span><span class="s3">\n  </span><span class="s1">t.assertIdentifier(realName);</span><span class="s3">\n\n  </span><span class="s1">const name = path.scope.generateUid(realName.name);</span><span class="s3">\n\n  </span><span class="s1">const namespaceTopLevel: t.Statement[] = t.isTSModuleBlock(node.body)</span><span class="s3">\n    </span><span class="s1">? node.body.body</span><span class="s3">\n    </span><span class="s1">: // We handle `namespace X.Y {}` as if it was</span><span class="s3">\n      </span><span class="s1">//   namespace X {</span><span class="s3">\n      </span><span class="s1">//     export namespace Y {}</span><span class="s3">\n      </span><span class="s1">//   }</span><span class="s3">\n      </span><span class="s1">[t.exportNamedDeclaration(node.body)];</span><span class="s3">\n\n  </span><span class="s1">for (let i = 0; i &lt; namespaceTopLevel.length; i++) {</span><span class="s3">\n    </span><span class="s1">const subNode = namespaceTopLevel[i];</span><span class="s3">\n\n    </span><span class="s1">// The first switch is mainly to detect name usage. Only export</span><span class="s3">\n    </span><span class="s1">// declarations require further transformation.</span><span class="s3">\n    </span><span class="s1">switch (subNode.type) {</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">TSModuleDeclaration</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">if (!t.isIdentifier(subNode.id)) {</span><span class="s3">\n          </span><span class="s1">throw buildNestedAmbientModuleError(path, subNode);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const transformed = handleNested(path, subNode);</span><span class="s3">\n        </span><span class="s1">const moduleName = subNode.id.name;</span><span class="s3">\n        </span><span class="s1">if (names.has(moduleName)) {</span><span class="s3">\n          </span><span class="s1">namespaceTopLevel[i] = transformed;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">names.add(moduleName);</span><span class="s3">\n          </span><span class="s1">namespaceTopLevel.splice(</span><span class="s3">\n            </span><span class="s1">i++,</span><span class="s3">\n            </span><span class="s1">1,</span><span class="s3">\n            </span><span class="s1">getDeclaration(moduleName),</span><span class="s3">\n            </span><span class="s1">transformed,</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">TSEnumDeclaration</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">FunctionDeclaration</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ClassDeclaration</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">names.add(subNode.id.name);</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">VariableDeclaration</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">// getBindingIdentifiers returns an object without prototype.</span><span class="s3">\n        </span><span class="s1">// eslint-disable-next-line guard-for-in</span><span class="s3">\n        </span><span class="s1">for (const name in t.getBindingIdentifiers(subNode)) {</span><span class="s3">\n          </span><span class="s1">names.add(name);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">default:</span><span class="s3">\n        </span><span class="s1">// Neither named declaration nor export, continue to next item.</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ExportNamedDeclaration</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">// Export declarations get parsed using the next switch.</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\&quot;</span><span class="s1">declare</span><span class="s3">\&quot; </span><span class="s1">in subNode.declaration &amp;&amp; subNode.declaration.declare) {</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Transform the export declarations that occur inside of a namespace.</span><span class="s3">\n    </span><span class="s1">switch (subNode.declaration.type) {</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">TSEnumDeclaration</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">FunctionDeclaration</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ClassDeclaration</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">const itemName = subNode.declaration.id.name;</span><span class="s3">\n        </span><span class="s1">names.add(itemName);</span><span class="s3">\n        </span><span class="s1">namespaceTopLevel.splice(</span><span class="s3">\n          </span><span class="s1">i++,</span><span class="s3">\n          </span><span class="s1">1,</span><span class="s3">\n          </span><span class="s1">subNode.declaration,</span><span class="s3">\n          </span><span class="s1">t.expressionStatement(</span><span class="s3">\n            </span><span class="s1">t.assignmentExpression(</span><span class="s3">\n              \&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n              </span><span class="s1">getMemberExpression(name, itemName),</span><span class="s3">\n              </span><span class="s1">t.identifier(itemName),</span><span class="s3">\n            </span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">VariableDeclaration</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">const nodes = handleVariableDeclaration(</span><span class="s3">\n          </span><span class="s1">subNode.declaration,</span><span class="s3">\n          </span><span class="s1">name,</span><span class="s3">\n          </span><span class="s1">path.hub,</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">namespaceTopLevel.splice(i, nodes.length, ...nodes);</span><span class="s3">\n        </span><span class="s1">i += nodes.length - 1;</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">TSModuleDeclaration</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">if (!t.isIdentifier(subNode.declaration.id)) {</span><span class="s3">\n          </span><span class="s1">throw buildNestedAmbientModuleError(path, subNode.declaration);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const transformed = handleNested(</span><span class="s3">\n          </span><span class="s1">path,</span><span class="s3">\n          </span><span class="s1">subNode.declaration,</span><span class="s3">\n          </span><span class="s1">t.identifier(name),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">const moduleName = subNode.declaration.id.name;</span><span class="s3">\n        </span><span class="s1">if (names.has(moduleName)) {</span><span class="s3">\n          </span><span class="s1">namespaceTopLevel[i] = transformed;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">names.add(moduleName);</span><span class="s3">\n          </span><span class="s1">namespaceTopLevel.splice(</span><span class="s3">\n            </span><span class="s1">i++,</span><span class="s3">\n            </span><span class="s1">1,</span><span class="s3">\n            </span><span class="s1">getDeclaration(moduleName),</span><span class="s3">\n            </span><span class="s1">transformed,</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// {}</span><span class="s3">\n  </span><span class="s1">let fallthroughValue: t.Expression = t.objectExpression([]);</span><span class="s3">\n\n  </span><span class="s1">if (parentExport) {</span><span class="s3">\n    </span><span class="s1">const memberExpr = t.memberExpression(parentExport, realName);</span><span class="s3">\n    </span><span class="s1">fallthroughValue = template.expression.ast`</span><span class="s3">\n      </span><span class="s1">${t.cloneNode(memberExpr)} ||</span><span class="s3">\n        </span><span class="s1">(${t.cloneNode(memberExpr)} = ${fallthroughValue})</span><span class="s3">\n    </span><span class="s1">`;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return template.statement.ast`</span><span class="s3">\n    </span><span class="s1">(function (${t.identifier(name)}) {</span><span class="s3">\n      </span><span class="s1">${namespaceTopLevel}</span><span class="s3">\n    </span><span class="s1">})(${realName} || (${t.cloneNode(realName)} = ${fallthroughValue}));</span><span class="s3">\n  </span><span class="s1">`;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">}</span></pre>
</body>
</html>
<html>
<head>
<title>runJest.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6a8759;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #4646f1;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
runJest.js</font>
</center></td></tr></table>
<pre><span class="s0">'use strict'</span><span class="s1">;</span>

<span class="s1">Object.defineProperty(exports, </span><span class="s0">'__esModule'</span><span class="s1">, {</span>
  <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s1">exports.</span><span class="s2">default </span><span class="s1">= runJest;</span>
<span class="s2">function </span><span class="s1">path() {</span>
  <span class="s1">const data = _interopRequireWildcard(require(</span><span class="s0">'path'</span><span class="s1">));</span>
  <span class="s1">path = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_perf_hooks() {</span>
  <span class="s1">const data = require(</span><span class="s0">'perf_hooks'</span><span class="s1">);</span>
  <span class="s1">_perf_hooks = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_chalk() {</span>
  <span class="s1">const data = _interopRequireDefault(require(</span><span class="s0">'chalk'</span><span class="s1">));</span>
  <span class="s1">_chalk = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_exit() {</span>
  <span class="s1">const data = _interopRequireDefault(require(</span><span class="s0">'exit'</span><span class="s1">));</span>
  <span class="s1">_exit = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">fs() {</span>
  <span class="s1">const data = _interopRequireWildcard(require(</span><span class="s0">'graceful-fs'</span><span class="s1">));</span>
  <span class="s1">fs = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_console() {</span>
  <span class="s1">const data = require(</span><span class="s0">'@jest/console'</span><span class="s1">);</span>
  <span class="s1">_console = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_testResult() {</span>
  <span class="s1">const data = require(</span><span class="s0">'@jest/test-result'</span><span class="s1">);</span>
  <span class="s1">_testResult = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_jestResolve() {</span>
  <span class="s1">const data = _interopRequireDefault(require(</span><span class="s0">'jest-resolve'</span><span class="s1">));</span>
  <span class="s1">_jestResolve = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_jestUtil() {</span>
  <span class="s1">const data = require(</span><span class="s0">'jest-util'</span><span class="s1">);</span>
  <span class="s1">_jestUtil = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_jestWatcher() {</span>
  <span class="s1">const data = require(</span><span class="s0">'jest-watcher'</span><span class="s1">);</span>
  <span class="s1">_jestWatcher = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">_SearchSource = _interopRequireDefault(require(</span><span class="s0">'./SearchSource'</span><span class="s1">));</span>
<span class="s2">var </span><span class="s1">_TestScheduler = require(</span><span class="s0">'./TestScheduler'</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_collectHandles = _interopRequireDefault(require(</span><span class="s0">'./collectHandles'</span><span class="s1">));</span>
<span class="s2">var </span><span class="s1">_getNoTestsFoundMessage = _interopRequireDefault(</span>
  <span class="s1">require(</span><span class="s0">'./getNoTestsFoundMessage'</span><span class="s1">)</span>
<span class="s1">);</span>
<span class="s2">var </span><span class="s1">_runGlobalHook = _interopRequireDefault(require(</span><span class="s0">'./runGlobalHook'</span><span class="s1">));</span>
<span class="s2">function </span><span class="s1">_interopRequireDefault(obj) {</span>
  <span class="s2">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : {</span><span class="s2">default</span><span class="s1">: obj};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_getRequireWildcardCache(nodeInterop) {</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">WeakMap !== </span><span class="s0">'function'</span><span class="s1">) </span><span class="s2">return null</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">cacheBabelInterop = </span><span class="s2">new </span><span class="s1">WeakMap();</span>
  <span class="s2">var </span><span class="s1">cacheNodeInterop = </span><span class="s2">new </span><span class="s1">WeakMap();</span>
  <span class="s2">return </span><span class="s1">(_getRequireWildcardCache = </span><span class="s2">function </span><span class="s1">(nodeInterop) {</span>
    <span class="s2">return </span><span class="s1">nodeInterop ? cacheNodeInterop : cacheBabelInterop;</span>
  <span class="s1">})(nodeInterop);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_interopRequireWildcard(obj, nodeInterop) {</span>
  <span class="s2">if </span><span class="s1">(!nodeInterop &amp;&amp; obj &amp;&amp; obj.__esModule) {</span>
    <span class="s2">return </span><span class="s1">obj;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(obj === </span><span class="s2">null </span><span class="s1">|| (</span><span class="s2">typeof </span><span class="s1">obj !== </span><span class="s0">'object' </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">obj !== </span><span class="s0">'function'</span><span class="s1">)) {</span>
    <span class="s2">return </span><span class="s1">{</span><span class="s2">default</span><span class="s1">: obj};</span>
  <span class="s1">}</span>
  <span class="s2">var </span><span class="s1">cache = _getRequireWildcardCache(nodeInterop);</span>
  <span class="s2">if </span><span class="s1">(cache &amp;&amp; cache.has(obj)) {</span>
    <span class="s2">return </span><span class="s1">cache.get(obj);</span>
  <span class="s1">}</span>
  <span class="s2">var </span><span class="s1">newObj = {};</span>
  <span class="s2">var </span><span class="s1">hasPropertyDescriptor =</span>
    <span class="s1">Object.defineProperty &amp;&amp; Object.getOwnPropertyDescriptor;</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">key </span><span class="s2">in </span><span class="s1">obj) {</span>
    <span class="s2">if </span><span class="s1">(key !== </span><span class="s0">'default' </span><span class="s1">&amp;&amp; Object.prototype.hasOwnProperty.call(obj, key)) {</span>
      <span class="s2">var </span><span class="s1">desc = hasPropertyDescriptor</span>
        <span class="s1">? Object.getOwnPropertyDescriptor(obj, key)</span>
        <span class="s1">: </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s2">if </span><span class="s1">(desc &amp;&amp; (desc.get || desc.set)) {</span>
        <span class="s1">Object.defineProperty(newObj, key, desc);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">newObj[key] = obj[key];</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">newObj.</span><span class="s2">default </span><span class="s1">= obj;</span>
  <span class="s2">if </span><span class="s1">(cache) {</span>
    <span class="s1">cache.set(obj, newObj);</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">newObj;</span>
<span class="s1">}</span>
<span class="s3">/** 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>

<span class="s1">const getTestPaths = async (</span>
  <span class="s1">globalConfig,</span>
  <span class="s1">source,</span>
  <span class="s1">outputStream,</span>
  <span class="s1">changedFiles,</span>
  <span class="s1">jestHooks,</span>
  <span class="s1">filter</span>
<span class="s1">) =&gt; {</span>
  <span class="s1">const data = await source.getTestPaths(globalConfig, changedFiles, filter);</span>
  <span class="s2">if </span><span class="s1">(!data.tests.length &amp;&amp; globalConfig.onlyChanged &amp;&amp; data.noSCM) {</span>
    <span class="s2">new </span><span class="s1">(_console().CustomConsole)(outputStream, outputStream).log(</span>
      <span class="s0">'Jest can only find uncommitted changed files in a git or hg ' </span><span class="s1">+</span>
        <span class="s0">'repository. If you make your project a git or hg ' </span><span class="s1">+</span>
        <span class="s0">'repository (`git init` or `hg init`), Jest will be able ' </span><span class="s1">+</span>
        <span class="s0">'to only run tests related to files changed since the last ' </span><span class="s1">+</span>
        <span class="s0">'commit.'</span>
    <span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">const shouldTestArray = await Promise.all(</span>
    <span class="s1">data.tests.map(test =&gt;</span>
      <span class="s1">jestHooks.shouldRunTestSuite({</span>
        <span class="s1">config: test.context.config,</span>
        <span class="s1">duration: test.duration,</span>
        <span class="s1">testPath: test.path</span>
      <span class="s1">})</span>
    <span class="s1">)</span>
  <span class="s1">);</span>
  <span class="s1">const filteredTests = data.tests.filter((_test, i) =&gt; shouldTestArray[i]);</span>
  <span class="s2">return </span><span class="s1">{</span>
    <span class="s1">...data,</span>
    <span class="s1">allTests: filteredTests.length,</span>
    <span class="s1">tests: filteredTests</span>
  <span class="s1">};</span>
<span class="s1">};</span>
<span class="s1">const processResults = async (runResults, options) =&gt; {</span>
  <span class="s1">const {</span>
    <span class="s1">outputFile,</span>
    <span class="s1">json: isJSON,</span>
    <span class="s1">onComplete,</span>
    <span class="s1">outputStream,</span>
    <span class="s1">testResultsProcessor,</span>
    <span class="s1">collectHandles</span>
  <span class="s1">} = options;</span>
  <span class="s2">if </span><span class="s1">(collectHandles) {</span>
    <span class="s1">runResults.openHandles = await collectHandles();</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s1">runResults.openHandles = [];</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(testResultsProcessor) {</span>
    <span class="s1">const processor = await (</span><span class="s4">0</span><span class="s1">, _jestUtil().requireOrImportModule)(</span>
      <span class="s1">testResultsProcessor</span>
    <span class="s1">);</span>
    <span class="s1">runResults = await processor(runResults);</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(isJSON) {</span>
    <span class="s2">if </span><span class="s1">(outputFile) {</span>
      <span class="s1">const cwd = (</span><span class="s4">0</span><span class="s1">, _jestUtil().tryRealpath)(process.cwd());</span>
      <span class="s1">const filePath = path().resolve(cwd, outputFile);</span>
      <span class="s1">fs().writeFileSync(</span>
        <span class="s1">filePath,</span>
        <span class="s1">`${JSON.stringify((</span><span class="s4">0</span><span class="s1">, _testResult().formatTestResults)(runResults))}\n`</span>
      <span class="s1">);</span>
      <span class="s1">outputStream.write(</span>
        <span class="s1">`Test results written to: ${path().relative(cwd, filePath)}\n`</span>
      <span class="s1">);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">process.stdout.write(</span>
        <span class="s1">`${JSON.stringify((</span><span class="s4">0</span><span class="s1">, _testResult().formatTestResults)(runResults))}\n`</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">onComplete?.(runResults);</span>
<span class="s1">};</span>
<span class="s1">const testSchedulerContext = {</span>
  <span class="s1">firstRun: </span><span class="s2">true</span><span class="s1">,</span>
  <span class="s1">previousSuccess: </span><span class="s2">true</span>
<span class="s1">};</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">runJest({</span>
  <span class="s1">contexts,</span>
  <span class="s1">globalConfig,</span>
  <span class="s1">outputStream,</span>
  <span class="s1">testWatcher,</span>
  <span class="s1">jestHooks = </span><span class="s2">new </span><span class="s1">(_jestWatcher().JestHook)().getEmitter(),</span>
  <span class="s1">startRun,</span>
  <span class="s1">changedFilesPromise,</span>
  <span class="s1">onComplete,</span>
  <span class="s1">failedTestsCache,</span>
  <span class="s1">filter</span>
<span class="s1">}) {</span>
  <span class="s3">// Clear cache for required modules - there might be different resolutions</span>
  <span class="s3">// from Jest's config loading to running the tests</span>
  <span class="s1">_jestResolve().</span><span class="s2">default</span><span class="s1">.clearDefaultResolverCache();</span>
  <span class="s1">const Sequencer = await (</span><span class="s4">0</span><span class="s1">, _jestUtil().requireOrImportModule)(</span>
    <span class="s1">globalConfig.testSequencer</span>
  <span class="s1">);</span>
  <span class="s1">const sequencer = </span><span class="s2">new </span><span class="s1">Sequencer();</span>
  <span class="s1">let allTests = [];</span>
  <span class="s2">if </span><span class="s1">(changedFilesPromise &amp;&amp; globalConfig.watch) {</span>
    <span class="s1">const {repos} = await changedFilesPromise;</span>
    <span class="s1">const noSCM = Object.keys(repos).every(scm =&gt; repos[scm].size === </span><span class="s4">0</span><span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(noSCM) {</span>
      <span class="s1">process.stderr.write(</span>
        <span class="s1">`\n${_chalk().</span><span class="s2">default</span><span class="s1">.bold(</span>
          <span class="s0">'--watch'</span>
        <span class="s1">)} is not supported without git/hg, please use --watchAll\n`</span>
      <span class="s1">);</span>
      <span class="s1">(</span><span class="s4">0</span><span class="s1">, _exit().</span><span class="s2">default</span><span class="s1">)(</span><span class="s4">1</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">const searchSources = contexts.map(</span>
    <span class="s1">context =&gt; </span><span class="s2">new </span><span class="s1">_SearchSource.</span><span class="s2">default</span><span class="s1">(context)</span>
  <span class="s1">);</span>
  <span class="s1">_perf_hooks().performance.mark(</span><span class="s0">'jest/getTestPaths:start'</span><span class="s1">);</span>
  <span class="s1">const testRunData = await Promise.all(</span>
    <span class="s1">contexts.map(async (context, index) =&gt; {</span>
      <span class="s1">const searchSource = searchSources[index];</span>
      <span class="s1">const matches = await getTestPaths(</span>
        <span class="s1">globalConfig,</span>
        <span class="s1">searchSource,</span>
        <span class="s1">outputStream,</span>
        <span class="s1">changedFilesPromise &amp;&amp; (await changedFilesPromise),</span>
        <span class="s1">jestHooks,</span>
        <span class="s1">filter</span>
      <span class="s1">);</span>
      <span class="s1">allTests = allTests.concat(matches.tests);</span>
      <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">context,</span>
        <span class="s1">matches</span>
      <span class="s1">};</span>
    <span class="s1">})</span>
  <span class="s1">);</span>
  <span class="s1">_perf_hooks().performance.mark(</span><span class="s0">'jest/getTestPaths:end'</span><span class="s1">);</span>
  <span class="s2">if </span><span class="s1">(globalConfig.shard) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">sequencer.shard !== </span><span class="s0">'function'</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">Error(</span>
        <span class="s1">`Shard ${globalConfig.shard.shardIndex}/${globalConfig.shard.shardCount} requested, but test sequencer ${Sequencer.name} </span><span class="s2">in </span><span class="s1">${globalConfig.testSequencer} has no shard method.`</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">allTests = await sequencer.shard(allTests, globalConfig.shard);</span>
  <span class="s1">}</span>
  <span class="s1">allTests = await sequencer.sort(allTests);</span>
  <span class="s2">if </span><span class="s1">(globalConfig.listTests) {</span>
    <span class="s1">const testsPaths = Array.from(</span><span class="s2">new </span><span class="s1">Set(allTests.map(test =&gt; test.path)));</span>
    <span class="s3">/* eslint-disable no-console */</span>
    <span class="s2">if </span><span class="s1">(globalConfig.json) {</span>
      <span class="s1">console.log(JSON.stringify(testsPaths));</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">console.log(testsPaths.join(</span><span class="s0">'</span><span class="s5">\n</span><span class="s0">'</span><span class="s1">));</span>
    <span class="s1">}</span>
    <span class="s3">/* eslint-enable */</span>

    <span class="s1">onComplete &amp;&amp;</span>
      <span class="s1">onComplete((</span><span class="s4">0</span><span class="s1">, _testResult().makeEmptyAggregatedTestResult)());</span>
    <span class="s2">return</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(globalConfig.onlyFailures) {</span>
    <span class="s2">if </span><span class="s1">(failedTestsCache) {</span>
      <span class="s1">allTests = failedTestsCache.filterTests(allTests);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">allTests = await sequencer.allFailedTests(allTests);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">const hasTests = allTests.length &gt; </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s2">if </span><span class="s1">(!hasTests) {</span>
    <span class="s1">const {exitWith0, message: noTestsFoundMessage} = (</span><span class="s4">0</span><span class="s1">,</span>
    <span class="s1">_getNoTestsFoundMessage.</span><span class="s2">default</span><span class="s1">)(testRunData, globalConfig);</span>
    <span class="s2">if </span><span class="s1">(exitWith0) {</span>
      <span class="s2">new </span><span class="s1">(_console().CustomConsole)(outputStream, outputStream).log(</span>
        <span class="s1">noTestsFoundMessage</span>
      <span class="s1">);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">new </span><span class="s1">(_console().CustomConsole)(outputStream, outputStream).error(</span>
        <span class="s1">noTestsFoundMessage</span>
      <span class="s1">);</span>
      <span class="s1">(</span><span class="s4">0</span><span class="s1">, _exit().</span><span class="s2">default</span><span class="s1">)(</span><span class="s4">1</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span>
    <span class="s1">allTests.length === </span><span class="s4">1 </span><span class="s1">&amp;&amp;</span>
    <span class="s1">globalConfig.silent !== </span><span class="s2">true </span><span class="s1">&amp;&amp;</span>
    <span class="s1">globalConfig.verbose !== </span><span class="s2">false</span>
  <span class="s1">) {</span>
    <span class="s1">const newConfig = {</span>
      <span class="s1">...globalConfig,</span>
      <span class="s1">verbose: </span><span class="s2">true</span>
    <span class="s1">};</span>
    <span class="s1">globalConfig = Object.freeze(newConfig);</span>
  <span class="s1">}</span>
  <span class="s1">let collectHandles;</span>
  <span class="s2">if </span><span class="s1">(globalConfig.detectOpenHandles) {</span>
    <span class="s1">collectHandles = (</span><span class="s4">0</span><span class="s1">, _collectHandles.</span><span class="s2">default</span><span class="s1">)();</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(hasTests) {</span>
    <span class="s1">_perf_hooks().performance.mark(</span><span class="s0">'jest/globalSetup:start'</span><span class="s1">);</span>
    <span class="s1">await (</span><span class="s4">0</span><span class="s1">, _runGlobalHook.</span><span class="s2">default</span><span class="s1">)({</span>
      <span class="s1">allTests,</span>
      <span class="s1">globalConfig,</span>
      <span class="s1">moduleName: </span><span class="s0">'globalSetup'</span>
    <span class="s1">});</span>
    <span class="s1">_perf_hooks().performance.mark(</span><span class="s0">'jest/globalSetup:end'</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(changedFilesPromise) {</span>
    <span class="s1">const changedFilesInfo = await changedFilesPromise;</span>
    <span class="s2">if </span><span class="s1">(changedFilesInfo.changedFiles) {</span>
      <span class="s1">testSchedulerContext.changedFiles = changedFilesInfo.changedFiles;</span>
      <span class="s1">const sourcesRelatedToTestsInChangedFilesArray = (</span>
        <span class="s1">await Promise.all(</span>
          <span class="s1">contexts.map(async (_, index) =&gt; {</span>
            <span class="s1">const searchSource = searchSources[index];</span>
            <span class="s2">return </span><span class="s1">searchSource.findRelatedSourcesFromTestsInChangedFiles(</span>
              <span class="s1">changedFilesInfo</span>
            <span class="s1">);</span>
          <span class="s1">})</span>
        <span class="s1">)</span>
      <span class="s1">).reduce((total, paths) =&gt; total.concat(paths), []);</span>
      <span class="s1">testSchedulerContext.sourcesRelatedToTestsInChangedFiles = </span><span class="s2">new </span><span class="s1">Set(</span>
        <span class="s1">sourcesRelatedToTestsInChangedFilesArray</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">const scheduler = await (</span><span class="s4">0</span><span class="s1">, _TestScheduler.createTestScheduler)(</span>
    <span class="s1">globalConfig,</span>
    <span class="s1">{</span>
      <span class="s1">startRun,</span>
      <span class="s1">...testSchedulerContext</span>
    <span class="s1">}</span>
  <span class="s1">);</span>

  <span class="s3">// @ts-expect-error - second arg is unsupported (but harmless) in Node 14</span>
  <span class="s1">_perf_hooks().performance.mark(</span><span class="s0">'jest/scheduleAndRun:start'</span><span class="s1">, {</span>
    <span class="s1">detail: {</span>
      <span class="s1">numTests: allTests.length</span>
    <span class="s1">}</span>
  <span class="s1">});</span>
  <span class="s1">const results = await scheduler.scheduleTests(allTests, testWatcher);</span>
  <span class="s1">_perf_hooks().performance.mark(</span><span class="s0">'jest/scheduleAndRun:start'</span><span class="s1">);</span>
  <span class="s1">_perf_hooks().performance.mark(</span><span class="s0">'jest/cacheResults:start'</span><span class="s1">);</span>
  <span class="s1">sequencer.cacheResults(allTests, results);</span>
  <span class="s1">_perf_hooks().performance.mark(</span><span class="s0">'jest/cacheResults:end'</span><span class="s1">);</span>
  <span class="s2">if </span><span class="s1">(hasTests) {</span>
    <span class="s1">_perf_hooks().performance.mark(</span><span class="s0">'jest/globalTeardown:start'</span><span class="s1">);</span>
    <span class="s1">await (</span><span class="s4">0</span><span class="s1">, _runGlobalHook.</span><span class="s2">default</span><span class="s1">)({</span>
      <span class="s1">allTests,</span>
      <span class="s1">globalConfig,</span>
      <span class="s1">moduleName: </span><span class="s0">'globalTeardown'</span>
    <span class="s1">});</span>
    <span class="s1">_perf_hooks().performance.mark(</span><span class="s0">'jest/globalTeardown:end'</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">_perf_hooks().performance.mark(</span><span class="s0">'jest/processResults:start'</span><span class="s1">);</span>
  <span class="s1">await processResults(results, {</span>
    <span class="s1">collectHandles,</span>
    <span class="s1">json: globalConfig.json,</span>
    <span class="s1">onComplete,</span>
    <span class="s1">outputFile: globalConfig.outputFile,</span>
    <span class="s1">outputStream,</span>
    <span class="s1">testResultsProcessor: globalConfig.testResultsProcessor</span>
  <span class="s1">});</span>
  <span class="s1">_perf_hooks().performance.mark(</span><span class="s0">'jest/processResults:end'</span><span class="s1">);</span>
<span class="s1">}</span>
</pre>
</body>
</html>
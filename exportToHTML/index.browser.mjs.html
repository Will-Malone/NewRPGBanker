<html>
<head>
<title>index.browser.mjs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #a9b7c6;}
.s3 { color: #6a8759;}
.s4 { color: #9876aa; font-style: italic;}
.s5 { color: #ffc66d;}
.s6 { color: #808080;}
.s7 { color: #6897bb; font-style: italic;}
.s8 { color: #cc7832; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
index.browser.mjs</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">{ </span><span class="s2">declare </span><span class="s1">} </span><span class="s0">from </span><span class="s3">'@babel/helper-plugin-utils'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s2">_getTargets</span><span class="s1">, { </span><span class="s2">prettifyTargets</span><span class="s1">, </span><span class="s2">getInclusionReasons</span><span class="s1">, </span><span class="s2">isRequired </span><span class="s1">} </span><span class="s0">from </span><span class="s3">'@babel/helper-compilation-targets'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s4">* </span><span class="s0">as </span><span class="s2">_babel </span><span class="s0">from </span><span class="s3">'@babel/core'</span><span class="s1">;</span>

<span class="s0">const </span><span class="s1">{</span>
  <span class="s2">types</span><span class="s1">: t$1,</span>
  <span class="s2">template</span><span class="s1">: template</span>
<span class="s1">} = _babel.default || _babel; 
function intersection(a, b) {</span>
  <span class="s1">const result </span><span class="s0">= new </span><span class="s5">Set</span><span class="s1">(); 
  a.forEach(v </span><span class="s0">=&gt; </span><span class="s2">b</span><span class="s1">.</span><span class="s5">has</span><span class="s1">(</span><span class="s2">v</span><span class="s1">) </span><span class="s0">&amp;&amp; </span><span class="s2">result</span><span class="s1">.</span><span class="s5">add</span><span class="s1">(</span><span class="s2">v</span><span class="s1">)); 
  return result; 
}</span>
<span class="s1">function has$1(object, key) {</span>
  <span class="s1">return Object.prototype.hasOwnProperty.call(object, key); 
}</span>
<span class="s1">function getType(target) {</span>
  <span class="s1">return Object.prototype.toString.call(target).slice(8, -1); 
}</span>
<span class="s1">function resolveId(path) {</span>
  <span class="s1">if (path.isIdentifier() &amp;&amp; !path.scope.hasBinding(path.node.name, </span><span class="s6">/* noGlobals */</span><span class="s1">true)) {</span>
    <span class="s1">return path.node.name; 
  }</span>
  <span class="s1">const {</span>
    <span class="s1">deopt</span>
  <span class="s1">} </span><span class="s0">= </span><span class="s2">path</span><span class="s1">.</span><span class="s5">evaluate</span><span class="s1">(); 
  if (deopt &amp;&amp; deopt.isIdentifier()) {</span>
    <span class="s1">return deopt.node.name; 
  }</span>
<span class="s1">}</span>
<span class="s1">function resolveKey(path, computed </span><span class="s0">= </span><span class="s4">false</span><span class="s1">) {</span>
  <span class="s1">const {</span>
    <span class="s1">scope</span>
  <span class="s1">} </span><span class="s0">= </span><span class="s2">path</span><span class="s1">; 
  if (path.isStringLiteral()) return path.node.value; 
  const isIdentifier </span><span class="s0">= </span><span class="s2">path</span><span class="s1">.</span><span class="s5">isIdentifier</span><span class="s1">(); 
  if (isIdentifier &amp;&amp; !(computed || path.parent.computed)) {</span>
    <span class="s1">return path.node.name; 
  }</span>
  <span class="s1">if (computed &amp;&amp; path.isMemberExpression() &amp;&amp; path.get(&quot;object&quot;).isIdentifier({</span>
    <span class="s2">name</span><span class="s1">: </span><span class="s3">&quot;Symbol&quot;</span>
  <span class="s1">}) &amp;&amp; !scope.hasBinding(&quot;Symbol&quot;, </span><span class="s6">/* noGlobals */</span><span class="s1">true)) {</span>
    <span class="s1">const sym </span><span class="s0">= </span><span class="s5">resolveKey</span><span class="s1">(</span><span class="s2">path</span><span class="s1">.</span><span class="s5">get</span><span class="s1">(</span><span class="s3">&quot;property&quot;</span><span class="s1">), </span><span class="s2">path</span><span class="s1">.</span><span class="s2">node</span><span class="s1">.</span><span class="s2">computed</span><span class="s1">); 
    if (sym) return &quot;Symbol.&quot; + sym; 
  }</span>
  <span class="s1">if (!isIdentifier || scope.hasBinding(path.node.name, </span><span class="s6">/* noGlobals */</span><span class="s1">true)) {</span>
    <span class="s1">const {</span>
      <span class="s1">value</span>
    <span class="s1">} </span><span class="s0">= </span><span class="s2">path</span><span class="s1">.</span><span class="s5">evaluate</span><span class="s1">(); 
    if (typeof value === &quot;string&quot;) return value; 
  }</span>
<span class="s1">}</span>
<span class="s1">function resolveSource(obj) {</span>
  <span class="s1">if (obj.isMemberExpression() &amp;&amp; obj.get(&quot;property&quot;).isIdentifier({</span>
    <span class="s2">name</span><span class="s1">: </span><span class="s3">&quot;prototype&quot;</span>
  <span class="s1">})) {</span>
    <span class="s1">const id </span><span class="s0">= </span><span class="s5">resolveId</span><span class="s1">(</span><span class="s2">obj</span><span class="s1">.</span><span class="s5">get</span><span class="s1">(</span><span class="s3">&quot;object&quot;</span><span class="s1">)); 
    if (id) {</span>
      <span class="s1">return {</span>
        <span class="s1">id,</span>
        <span class="s2">placement</span><span class="s1">: </span><span class="s3">&quot;prototype&quot;</span>
      <span class="s1">}; 
    }</span>
    <span class="s1">return {</span>
      <span class="s2">id</span><span class="s1">: null,</span>
      <span class="s2">placement</span><span class="s1">: null</span>
    <span class="s1">}; 
  }</span>
  <span class="s1">const id </span><span class="s0">= </span><span class="s5">resolveId</span><span class="s1">(</span><span class="s2">obj</span><span class="s1">); 
  if (id) {</span>
    <span class="s1">return {</span>
      <span class="s1">id,</span>
      <span class="s2">placement</span><span class="s1">: </span><span class="s3">&quot;static&quot;</span>
    <span class="s1">}; 
  }</span>
  <span class="s1">const {</span>
    <span class="s1">value</span>
  <span class="s1">} </span><span class="s0">= </span><span class="s2">obj</span><span class="s1">.</span><span class="s5">evaluate</span><span class="s1">(); 
  if (value !== undefined) {</span>
    <span class="s1">return {</span>
      <span class="s2">id</span><span class="s1">: getType(value),</span>
      <span class="s2">placement</span><span class="s1">: </span><span class="s3">&quot;prototype&quot;</span>
    <span class="s1">}; 
  } else if (obj.isRegExpLiteral()) {</span>
    <span class="s1">return {</span>
      <span class="s2">id</span><span class="s1">: </span><span class="s3">&quot;RegExp&quot;</span><span class="s1">,</span>
      <span class="s2">placement</span><span class="s1">: </span><span class="s3">&quot;prototype&quot;</span>
    <span class="s1">}; 
  } else if (obj.isFunction()) {</span>
    <span class="s1">return {</span>
      <span class="s2">id</span><span class="s1">: </span><span class="s3">&quot;Function&quot;</span><span class="s1">,</span>
      <span class="s2">placement</span><span class="s1">: </span><span class="s3">&quot;prototype&quot;</span>
    <span class="s1">}; 
  }</span>
  <span class="s1">return {</span>
    <span class="s2">id</span><span class="s1">: null,</span>
    <span class="s2">placement</span><span class="s1">: null</span>
  <span class="s1">}; 
}</span>
<span class="s1">function getImportSource({</span>
  <span class="s1">node</span>
<span class="s1">}) {</span>
  <span class="s1">if (node.specifiers.length === 0) return node.source.value; 
}</span>
<span class="s1">function getRequireSource({</span>
  <span class="s1">node</span>
<span class="s1">}) {</span>
  <span class="s1">if (!t$1.isExpressionStatement(node)) return; 
  const {</span>
    <span class="s1">expression</span>
  <span class="s1">} </span><span class="s0">= </span><span class="s2">node</span><span class="s1">; 
  if (t$1.isCallExpression(expression) &amp;&amp; t$1.isIdentifier(expression.callee) &amp;&amp; expression.callee.name === &quot;require&quot; &amp;&amp; expression.arguments.length === 1 &amp;&amp; t$1.isStringLiteral(expression.arguments[0])) {</span>
    <span class="s1">return expression.arguments[0].value; 
  }</span>
<span class="s1">}</span>
<span class="s1">function hoist(node) {</span>
  <span class="s6">// @ts-expect-error</span>
  <span class="s1">node._blockHoist </span><span class="s0">= </span><span class="s7">3</span><span class="s1">; 
  return node; 
}</span>
<span class="s1">function createUtilsGetter(cache) {</span>
  <span class="s1">return path </span><span class="s0">=&gt; </span><span class="s1">{</span>
    <span class="s1">const </span><span class="s2">prog </span><span class="s0">= </span><span class="s2">path</span><span class="s1">.</span><span class="s5">findParent</span><span class="s1">(</span><span class="s2">p </span><span class="s0">=&gt; </span><span class="s2">p</span><span class="s1">.</span><span class="s5">isProgram</span><span class="s1">());</span>
    <span class="s1">return { 
      injectGlobalImport(</span><span class="s2">url</span><span class="s1">) {</span>
        <span class="s2">cache</span><span class="s1">.</span><span class="s5">storeAnonymous</span><span class="s1">(</span><span class="s2">prog</span><span class="s1">, </span><span class="s2">url</span><span class="s1">, (</span><span class="s2">isScript</span><span class="s1">, </span><span class="s2">source</span><span class="s1">) </span><span class="s0">=&gt; </span><span class="s1">{</span>
          <span class="s0">return </span><span class="s2">isScript </span><span class="s0">? </span><span class="s2">template</span><span class="s3">.</span><span class="s2">statement</span><span class="s3">.</span><span class="s5">ast</span><span class="s3">`require(${</span><span class="s2">source</span><span class="s3">})` </span><span class="s0">: </span><span class="s2">t$1</span><span class="s1">.</span><span class="s5">importDeclaration</span><span class="s1">([], </span><span class="s2">source</span><span class="s1">);</span>
        <span class="s1">});</span>
      <span class="s1">},</span>
      <span class="s1">injectNamedImport(</span><span class="s2">url</span><span class="s1">, </span><span class="s2">name</span><span class="s1">, </span><span class="s2">hint </span><span class="s0">= </span><span class="s2">name</span><span class="s1">) {</span>
        <span class="s0">return </span><span class="s2">cache</span><span class="s1">.</span><span class="s5">storeNamed</span><span class="s1">(</span><span class="s2">prog</span><span class="s1">, </span><span class="s2">url</span><span class="s1">, </span><span class="s2">name</span><span class="s1">, (</span><span class="s2">isScript</span><span class="s1">, </span><span class="s2">source</span><span class="s1">, </span><span class="s2">name</span><span class="s1">) </span><span class="s0">=&gt; </span><span class="s1">{</span>
          <span class="s0">const </span><span class="s1">id </span><span class="s0">= </span><span class="s2">prog</span><span class="s1">.</span><span class="s2">scope</span><span class="s1">.</span><span class="s5">generateUidIdentifier</span><span class="s1">(</span><span class="s2">hint</span><span class="s1">);</span>
          <span class="s0">return </span><span class="s1">{</span>
            <span class="s1">node: </span><span class="s2">isScript </span><span class="s0">? </span><span class="s5">hoist</span><span class="s1">(</span><span class="s2">template</span><span class="s3">.</span><span class="s2">statement</span><span class="s3">.</span><span class="s5">ast</span><span class="s3">`</span>
                  <span class="s3">var ${</span><span class="s2">id</span><span class="s3">} = require(${</span><span class="s2">source</span><span class="s3">}).${</span><span class="s2">name</span><span class="s3">}</span>
                <span class="s3">`</span><span class="s1">) </span><span class="s0">: </span><span class="s2">t$1</span><span class="s1">.</span><span class="s5">importDeclaration</span><span class="s1">([</span><span class="s2">t$1</span><span class="s1">.</span><span class="s5">importSpecifier</span><span class="s1">(</span><span class="s2">id</span><span class="s1">, </span><span class="s2">name</span><span class="s1">)], </span><span class="s2">source</span><span class="s1">),</span>
            <span class="s1">name: </span><span class="s2">id</span><span class="s1">.</span><span class="s2">name</span>
          <span class="s1">};</span>
        <span class="s1">});</span>
      <span class="s1">},</span>
      <span class="s1">injectDefaultImport(</span><span class="s2">url</span><span class="s1">, </span><span class="s2">hint </span><span class="s0">= </span><span class="s2">url</span><span class="s1">) {</span>
        <span class="s0">return </span><span class="s2">cache</span><span class="s1">.</span><span class="s5">storeNamed</span><span class="s1">(</span><span class="s2">prog</span><span class="s1">, </span><span class="s2">url</span><span class="s1">, </span><span class="s3">&quot;default&quot;</span><span class="s1">, (</span><span class="s2">isScript</span><span class="s1">, </span><span class="s2">source</span><span class="s1">) </span><span class="s0">=&gt; </span><span class="s1">{</span>
          <span class="s0">const </span><span class="s1">id </span><span class="s0">= </span><span class="s2">prog</span><span class="s1">.</span><span class="s2">scope</span><span class="s1">.</span><span class="s5">generateUidIdentifier</span><span class="s1">(</span><span class="s2">hint</span><span class="s1">);</span>
          <span class="s0">return </span><span class="s1">{</span>
            <span class="s1">node: </span><span class="s2">isScript </span><span class="s0">? </span><span class="s5">hoist</span><span class="s1">(</span><span class="s2">template</span><span class="s3">.</span><span class="s2">statement</span><span class="s3">.</span><span class="s5">ast</span><span class="s3">`var ${</span><span class="s2">id</span><span class="s3">} = require(${</span><span class="s2">source</span><span class="s3">})`</span><span class="s1">) </span><span class="s0">: </span><span class="s2">t$1</span><span class="s1">.</span><span class="s5">importDeclaration</span><span class="s1">([</span><span class="s2">t$1</span><span class="s1">.</span><span class="s5">importDefaultSpecifier</span><span class="s1">(</span><span class="s2">id</span><span class="s1">)], </span><span class="s2">source</span><span class="s1">),</span>
            <span class="s1">name: </span><span class="s2">id</span><span class="s1">.</span><span class="s2">name</span>
          <span class="s1">};</span>
        <span class="s1">});</span>
      <span class="s1">}</span>
    <span class="s1">}; 
  }; 
}</span>

<span class="s0">const </span><span class="s1">{</span>
  <span class="s2">types</span><span class="s1">: t</span>
<span class="s1">} = _babel.default || _babel; 
class ImportsCache {</span>
  <span class="s1">constructor(resolver) {</span>
    <span class="s1">this._imports </span><span class="s0">= new </span><span class="s5">WeakMap</span><span class="s1">(); 
    this._anonymousImports </span><span class="s0">= new </span><span class="s5">WeakMap</span><span class="s1">(); 
    this._lastImports </span><span class="s0">= new </span><span class="s5">WeakMap</span><span class="s1">(); 
    this._resolver </span><span class="s0">= </span><span class="s2">resolver</span><span class="s1">; 
  }</span>
  <span class="s1">storeAnonymous(programPath, url,</span>
  <span class="s6">// eslint-disable-next-line no-undef</span>
  <span class="s1">getVal) {</span>
    <span class="s1">const key </span><span class="s0">= </span><span class="s2">this</span><span class="s1">.</span><span class="s5">_normalizeKey</span><span class="s1">(</span><span class="s2">programPath</span><span class="s1">, </span><span class="s2">url</span><span class="s1">); 
    const imports </span><span class="s0">= </span><span class="s2">this</span><span class="s1">.</span><span class="s5">_ensure</span><span class="s1">(</span><span class="s2">this</span><span class="s1">.</span><span class="s2">_anonymousImports</span><span class="s1">, </span><span class="s2">programPath</span><span class="s1">, </span><span class="s2">Set</span><span class="s1">); 
    if (imports.has(key)) return; 
    const node </span><span class="s0">= </span><span class="s5">getVal</span><span class="s1">(</span><span class="s2">programPath</span><span class="s1">.</span><span class="s2">node</span><span class="s1">.</span><span class="s2">sourceType </span><span class="s0">=== </span><span class="s3">&quot;script&quot;</span><span class="s1">, </span><span class="s2">t</span><span class="s1">.</span><span class="s5">stringLiteral</span><span class="s1">(</span><span class="s2">this</span><span class="s1">.</span><span class="s5">_resolver</span><span class="s1">(</span><span class="s2">url</span><span class="s1">))); 
    imports.add(key); 
    this._injectImport(programPath, node); 
  }</span>
  <span class="s1">storeNamed(programPath, url, name, getVal) {</span>
    <span class="s1">const key </span><span class="s0">= </span><span class="s2">this</span><span class="s1">.</span><span class="s5">_normalizeKey</span><span class="s1">(</span><span class="s2">programPath</span><span class="s1">, </span><span class="s2">url</span><span class="s1">, </span><span class="s2">name</span><span class="s1">); 
    const imports </span><span class="s0">= </span><span class="s2">this</span><span class="s1">.</span><span class="s5">_ensure</span><span class="s1">(</span><span class="s2">this</span><span class="s1">.</span><span class="s2">_imports</span><span class="s1">, </span><span class="s2">programPath</span><span class="s1">, </span><span class="s2">Map</span><span class="s1">); 
    if (!imports.has(key)) {</span>
      <span class="s1">const {</span>
        <span class="s1">node,</span>
        <span class="s2">name</span><span class="s1">: id</span>
      <span class="s1">} </span><span class="s0">= </span><span class="s5">getVal</span><span class="s1">(</span><span class="s2">programPath</span><span class="s1">.</span><span class="s2">node</span><span class="s1">.</span><span class="s2">sourceType </span><span class="s0">=== </span><span class="s3">&quot;script&quot;</span><span class="s1">, </span><span class="s2">t</span><span class="s1">.</span><span class="s5">stringLiteral</span><span class="s1">(</span><span class="s2">this</span><span class="s1">.</span><span class="s5">_resolver</span><span class="s1">(</span><span class="s2">url</span><span class="s1">)), </span><span class="s2">t</span><span class="s1">.</span><span class="s5">identifier</span><span class="s1">(</span><span class="s2">name</span><span class="s1">)); 
      imports.set(key, id); 
      this._injectImport(programPath, node); 
    }</span>
    <span class="s1">return t.identifier(imports.get(key)); 
  }</span>
  <span class="s1">_injectImport(programPath, node) {</span>
    <span class="s1">const lastImport </span><span class="s0">= </span><span class="s2">this</span><span class="s1">.</span><span class="s2">_lastImports</span><span class="s1">.</span><span class="s5">get</span><span class="s1">(</span><span class="s2">programPath</span><span class="s1">); 
    let newNodes; 
    if (lastImport &amp;&amp; lastImport.node &amp;&amp; 
    </span><span class="s6">// Sometimes the AST is modified and the &quot;last import&quot;</span>
    <span class="s6">// we have has been replaced</span>
    <span class="s1">lastImport.parent === programPath.node &amp;&amp; lastImport.container === programPath.node.body) {</span>
      <span class="s1">newNodes </span><span class="s0">= </span><span class="s2">lastImport</span><span class="s1">.</span><span class="s5">insertAfter</span><span class="s1">(</span><span class="s2">node</span><span class="s1">); 
    } else {</span>
      <span class="s1">newNodes </span><span class="s0">= </span><span class="s2">programPath</span><span class="s1">.</span><span class="s5">unshiftContainer</span><span class="s1">(</span><span class="s3">&quot;body&quot;</span><span class="s1">, </span><span class="s2">node</span><span class="s1">); 
    }</span>
    <span class="s1">const newNode </span><span class="s0">= </span><span class="s2">newNodes</span><span class="s1">[</span><span class="s2">newNodes</span><span class="s1">.length </span><span class="s0">- </span><span class="s7">1</span><span class="s1">]; 
    this._lastImports.set(programPath, newNode); 
</span>
    <span class="s6">/*</span>
    <span class="s6">let lastImport; 
     programPath.get(&quot;body&quot;).forEach(path =&gt; { 
      if (path.isImportDeclaration()) lastImport = path; 
      if ( 
        path.isExpressionStatement() &amp;&amp; 
        isRequireCall(path.get(&quot;expression&quot;)) 
      ) { 
        lastImport = path; 
      } 
      if ( 
        path.isVariableDeclaration() &amp;&amp; 
        path.get(&quot;declarations&quot;).length === 1 &amp;&amp; 
        (isRequireCall(path.get(&quot;declarations.0.init&quot;)) || 
          (path.get(&quot;declarations.0.init&quot;).isMemberExpression() &amp;&amp; 
            isRequireCall(path.get(&quot;declarations.0.init.object&quot;)))) 
      ) { 
        lastImport = path; 
      } 
    });*/</span>
  <span class="s1">}</span>

  <span class="s1">_ensure(map, programPath, Collection) {</span>
    <span class="s1">let collection </span><span class="s0">= </span><span class="s2">map</span><span class="s1">.</span><span class="s5">get</span><span class="s1">(</span><span class="s2">programPath</span><span class="s1">); 
    if (!collection) {</span>
      <span class="s1">collection </span><span class="s0">= new </span><span class="s5">Collection</span><span class="s1">(); 
      map.set(programPath, collection); 
    }</span>
    <span class="s1">return collection; 
  }</span>
  <span class="s1">_normalizeKey(programPath, url, name </span><span class="s0">= </span><span class="s3">&quot;&quot;</span><span class="s1">) {</span>
    <span class="s1">const {</span>
      <span class="s1">sourceType</span>
    <span class="s1">} </span><span class="s0">= </span><span class="s2">programPath</span><span class="s1">.</span><span class="s2">node</span><span class="s1">; 
</span>
    <span class="s6">// If we rely on the imported binding (the &quot;name&quot; parameter), we also need to cache</span>
    <span class="s6">// based on the sourceType. This is because the module transforms change the names</span>
    <span class="s6">// of the import variables.</span>
    <span class="s1">return `${name &amp;&amp; sourceType}::${url}::${name}`; 
  }</span>
<span class="s1">}</span>

<span class="s1">const presetEnvSilentDebugHeader </span><span class="s0">= </span><span class="s3">&quot;#__secret_key__@babel/preset-env__don't_log_debug_header_and_resolved_targets&quot;</span><span class="s1">; 
function stringifyTargetsMultiline(targets) {</span>
  <span class="s1">return JSON.stringify(prettifyTargets(targets), null, 2); 
}</span>

<span class="s1">function patternToRegExp(pattern) {</span>
  <span class="s1">if (pattern instanceof RegExp) return pattern; 
  try {</span>
    <span class="s1">return new RegExp(`^${pattern}$`); 
  } catch {</span>
    <span class="s1">return null; 
  }</span>
<span class="s1">}</span>
<span class="s1">function buildUnusedError(label, unused) {</span>
  <span class="s1">if (!unused.length) return &quot;&quot;; 
  return `  - The following &quot;${label}&quot; patterns didn't match any </span><span class="s2">polyfill</span><span class="s1">:\</span><span class="s5">n</span><span class="s3">` + unused.map(original =&gt; `    </span><span class="s1">${String(original)}\</span><span class="s5">n</span><span class="s3">`).join(&quot;&quot;); 
} 
function buldDuplicatesError(duplicates) { 
  if (!duplicates.size) return &quot;&quot;; 
  return `  </span><span class="s1">- The following polyfills were matched both by </span><span class="s3">&quot;include&quot; </span><span class="s1">and </span><span class="s3">&quot;exclude&quot; </span><span class="s2">patterns</span><span class="s1">:\</span><span class="s5">n</span><span class="s3">` + Array.from(duplicates, name =&gt; `    </span><span class="s1">${name}\</span><span class="s5">n</span><span class="s3">`).join(&quot;&quot;); 
} 
function validateIncludeExclude(provider, polyfills, includePatterns, excludePatterns) { 
  let current; 
  const filter = pattern =&gt; { 
    const regexp = patternToRegExp(pattern); 
    if (!regexp) return false; 
    let matched = false; 
    for (const polyfill of polyfills) { 
      if (regexp.test(polyfill)) { 
        matched = true; 
        current.add(polyfill); 
      } 
    } 
    return !matched; 
  }; 
</span>
  <span class="s3">// prettier-ignore 
  const include = current = new Set(); 
  const unusedInclude = Array.from(includePatterns).filter(filter); 
</span>
  <span class="s3">// prettier-ignore 
  const exclude = current = new Set(); 
  const unusedExclude = Array.from(excludePatterns).filter(filter); 
  const duplicates = intersection(include, exclude); 
  if (duplicates.size &gt; 0 || unusedInclude.length &gt; 0 || unusedExclude.length &gt; 0) { 
    throw new Error(`</span><span class="s1">Error while validating the </span><span class="s3">&quot;${provider}&quot; </span><span class="s1">provider </span><span class="s2">options</span><span class="s1">:\</span><span class="s5">n</span><span class="s3">` + buildUnusedError(&quot;include&quot;, unusedInclude) + buildUnusedError(&quot;exclude&quot;, unusedExclude) + buldDuplicatesError(duplicates)); 
  } 
  return { 
    include, 
    exclude 
  }; 
} 
function applyMissingDependenciesDefaults(options, babelApi) { 
  const { 
    missingDependencies = {} 
  } = options; 
  if (missingDependencies === false) return false; 
  const caller = babelApi.caller(caller =&gt; caller == null ? void 0 : caller.name); 
  const { 
    log = &quot;deferred&quot;, 
    inject = caller === &quot;rollup-plugin-babel&quot; ? &quot;throw&quot; : &quot;import&quot;, 
    all = false 
  } = missingDependencies; 
  return { 
    log, 
    inject, 
    all 
  }; 
} 
</span>
<span class="s3">var usage = (callProvider =&gt; { 
  function property(object, key, placement, path) { 
    return callProvider({ 
      kind: &quot;property&quot;, 
      object, 
      key, 
      placement 
    }, path); 
  } 
  return { 
    // Symbol(), new Promise 
    ReferencedIdentifier(path) { 
      const { 
        node: { 
          name 
        }, 
        scope 
      } = path; 
      if (scope.getBindingIdentifier(name)) return; 
      callProvider({ 
        kind: &quot;global&quot;, 
        name 
      }, path); 
    }, 
    MemberExpression(path) { 
      const key = resolveKey(path.get(&quot;property&quot;), path.node.computed); 
      if (!key || key === &quot;prototype&quot;) return; 
      const object = path.get(&quot;object&quot;); 
      if (object.isIdentifier()) { 
        const binding = object.scope.getBinding(object.node.name); 
        if (binding &amp;&amp; binding.path.isImportNamespaceSpecifier()) return; 
      } 
      const source = resolveSource(object); 
      return property(source.id, key, source.placement, path); 
    }, 
    ObjectPattern(path) { 
      const { 
        parentPath, 
        parent 
      } = path; 
      let obj; 
</span>
      <span class="s3">// const { keys, values } = Object 
      if (parentPath.isVariableDeclarator()) { 
        obj = parentPath.get(&quot;init&quot;); 
        // ({ keys, values } = Object) 
      } else if (parentPath.isAssignmentExpression()) { 
        obj = parentPath.get(&quot;right&quot;); 
        // !function ({ keys, values }) {...} (Object) 
        // resolution does not work after properties transform :-( 
      } else if (parentPath.isFunction()) { 
        const grand = parentPath.parentPath; 
        if (grand.isCallExpression() || grand.isNewExpression()) { 
          if (grand.node.callee === parent) { 
            obj = grand.get(&quot;arguments&quot;)[path.key]; 
          } 
        } 
      } 
      let id = null; 
      let placement = null; 
      if (obj) ({ 
        id, 
        placement 
      } = resolveSource(obj)); 
      for (const prop of path.get(&quot;properties&quot;)) { 
        if (prop.isObjectProperty()) { 
          const key = resolveKey(prop.get(&quot;key&quot;)); 
          if (key) property(id, key, placement, prop); 
        } 
      } 
    }, 
    BinaryExpression(path) { 
      if (path.node.operator !== &quot;in&quot;) return; 
      const source = resolveSource(path.get(&quot;right&quot;)); 
      const key = resolveKey(path.get(&quot;left&quot;), true); 
      if (!key) return; 
      callProvider({ 
        kind: &quot;in&quot;, 
        object: source.id, 
        key, 
        placement: source.placement 
      }, path); 
    } 
  }; 
}); 
</span>
<span class="s3">var entry = (callProvider =&gt; ({ 
  ImportDeclaration(path) { 
    const source = getImportSource(path); 
    if (!source) return; 
    callProvider({ 
      kind: &quot;import&quot;, 
      source 
    }, path); 
  }, 
  Program(path) { 
    path.get(&quot;body&quot;).forEach(bodyPath =&gt; { 
      const source = getRequireSource(bodyPath); 
      if (!source) return; 
      callProvider({ 
        kind: &quot;import&quot;, 
        source 
      }, bodyPath); 
    }); 
  } 
})); 
</span>
<span class="s3">function resolve(dirname, moduleName, absoluteImports) { 
  if (absoluteImports === false) return moduleName; 
  throw new Error(`&quot;absoluteImports&quot; </span><span class="s1">is not supported in bundles prepared for the browser.</span><span class="s3">`); 
} 
</span>
<span class="s3">// eslint-disable-next-line @typescript-eslint/no-unused-vars 
function has(basedir, name) { 
  return true; 
} 
</span>
<span class="s3">// eslint-disable-next-line @typescript-eslint/no-unused-vars 
function logMissing(missingDeps) {} 
</span>
<span class="s3">// eslint-disable-next-line @typescript-eslint/no-unused-vars 
function laterLogMissing(missingDeps) {} 
</span>
<span class="s3">const PossibleGlobalObjects = new Set([&quot;global&quot;, &quot;globalThis&quot;, &quot;self&quot;, &quot;window&quot;]); 
function createMetaResolver(polyfills) { 
  const { 
    static: staticP, 
    instance: instanceP, 
    global: globalP 
  } = polyfills; 
  return meta =&gt; { 
    if (meta.kind === &quot;global&quot; &amp;&amp; globalP &amp;&amp; has$1(globalP, meta.name)) { 
      return { 
        kind: &quot;global&quot;, 
        desc: globalP[meta.name], 
        name: meta.name 
      }; 
    } 
    if (meta.kind === &quot;property&quot; || meta.kind === &quot;in&quot;) { 
      const { 
        placement, 
        object, 
        key 
      } = meta; 
      if (object &amp;&amp; placement === &quot;static&quot;) { 
        if (globalP &amp;&amp; PossibleGlobalObjects.has(object) &amp;&amp; has$1(globalP, key)) { 
          return { 
            kind: &quot;global&quot;, 
            desc: globalP[key], 
            name: key 
          }; 
        } 
        if (staticP &amp;&amp; has$1(staticP, object) &amp;&amp; has$1(staticP[object], key)) { 
          return { 
            kind: &quot;static&quot;, 
            desc: staticP[object][key], 
            name: `</span><span class="s1">${object}$${key}</span><span class="s3">`</span>
          <span class="s3">}; 
        } 
      } 
      if (instanceP &amp;&amp; has$1(instanceP, key)) { 
        return { 
          kind: &quot;instance&quot;, 
          desc: instanceP[key], 
          name: `</span><span class="s1">${key}</span><span class="s3">`</span>
        <span class="s3">}; 
      } 
    } 
  }; 
} 
</span>
<span class="s3">const getTargets = _getTargets.default || _getTargets; 
function resolveOptions(options, babelApi) { 
  const { 
    method, 
    targets: targetsOption, 
    ignoreBrowserslistConfig, 
    configPath, 
    debug, 
    shouldInjectPolyfill, 
    absoluteImports, 
    ...providerOptions 
  } = options; 
  if (isEmpty(options)) { 
    throw new Error(`</span><span class="s1">\ 
This plugin requires options, for </span><span class="s2">example</span><span class="s1">:</span>
    <span class="s1">{</span>
      <span class="s3">&quot;plugins&quot;</span><span class="s1">: [</span>
        <span class="s1">[</span><span class="s3">&quot;&lt;plugin name&gt;&quot;</span><span class="s1">, { </span><span class="s2">method</span><span class="s1">: </span><span class="s3">&quot;usage-pure&quot; </span><span class="s1">}]</span>
      <span class="s1">]</span>
    <span class="s1">}</span>

<span class="s1">See more options at </span><span class="s2">https</span><span class="s1">:</span><span class="s6">//github.com/babel/babel-polyfills/blob/main/docs/usage.md`);</span>
  <span class="s1">}</span>
  <span class="s1">let methodName; 
  if (method === &quot;usage-global&quot;) methodName </span><span class="s0">= </span><span class="s3">&quot;usageGlobal&quot;</span><span class="s1">;else if (method === &quot;entry-global&quot;) methodName </span><span class="s0">= </span><span class="s3">&quot;entryGlobal&quot;</span><span class="s1">;else if (method === &quot;usage-pure&quot;) methodName </span><span class="s0">= </span><span class="s3">&quot;usagePure&quot;</span><span class="s1">;else if (typeof method !== &quot;string&quot;) {</span>
    <span class="s1">throw new Error(&quot;.method must be a string&quot;); 
  } else {</span>
    <span class="s1">throw new Error(`.method must be one of &quot;entry-global&quot;, &quot;usage-global&quot;` + ` or &quot;usage-pure&quot; (received ${JSON.stringify(method)})`); 
  }</span>
  <span class="s1">if (typeof shouldInjectPolyfill === &quot;function&quot;) {</span>
    <span class="s1">if (options.include || options.exclude) {</span>
      <span class="s1">throw new Error(`.include and .exclude are not supported when using the` + ` .shouldInjectPolyfill function.`); 
    }</span>
  <span class="s1">} else if (shouldInjectPolyfill != null) {</span>
    <span class="s1">throw new Error(`.shouldInjectPolyfill must be a function, or undefined` + ` (received ${JSON.stringify(shouldInjectPolyfill)})`); 
  }</span>
  <span class="s1">if (absoluteImports != null &amp;&amp; typeof absoluteImports !== &quot;boolean&quot; &amp;&amp; typeof absoluteImports !== &quot;string&quot;) {</span>
    <span class="s1">throw new Error(`.absoluteImports must be a boolean, a string, or undefined` + ` (received ${JSON.stringify(absoluteImports)})`); 
  }</span>
  <span class="s1">let targets; 
  if ( 
  </span><span class="s6">// If any browserslist-related option is specified, fallback to the old</span>
  <span class="s6">// behavior of not using the targets specified in the top-level options.</span>
  <span class="s1">targetsOption || configPath || ignoreBrowserslistConfig) {</span>
    <span class="s1">const targetsObj </span><span class="s0">= typeof </span><span class="s2">targetsOption </span><span class="s0">=== </span><span class="s3">&quot;string&quot; </span><span class="s0">|| </span><span class="s2">Array</span><span class="s1">.</span><span class="s5">isArray</span><span class="s1">(</span><span class="s2">targetsOption</span><span class="s1">) </span><span class="s0">? </span><span class="s1">{</span>
      <span class="s1">browsers: </span><span class="s2">targetsOption</span>
    <span class="s1">} </span><span class="s0">: </span><span class="s2">targetsOption</span><span class="s1">; 
    targets </span><span class="s0">= </span><span class="s5">getTargets</span><span class="s1">(</span><span class="s2">targetsObj</span><span class="s1">, {</span>
      <span class="s2">ignoreBrowserslistConfig</span><span class="s1">,</span>
      <span class="s2">configPath</span>
    <span class="s1">}); 
  } else {</span>
    <span class="s1">targets </span><span class="s0">= </span><span class="s2">babelApi</span><span class="s1">.</span><span class="s5">targets</span><span class="s1">(); 
  }</span>
  <span class="s1">return {</span>
    <span class="s1">method,</span>
    <span class="s1">methodName,</span>
    <span class="s1">targets,</span>
    <span class="s2">absoluteImports</span><span class="s1">: absoluteImports != null ? </span><span class="s2">absoluteImports </span><span class="s1">: false,</span>
    <span class="s1">shouldInjectPolyfill,</span>
    <span class="s2">debug</span><span class="s1">: !!debug,</span>
    <span class="s2">providerOptions</span><span class="s1">: providerOptions</span>
  <span class="s1">}; 
}</span>
<span class="s0">function </span><span class="s1">instantiateProvider(</span><span class="s2">factory</span><span class="s1">, </span><span class="s2">options</span><span class="s1">, </span><span class="s2">missingDependencies</span><span class="s1">, </span><span class="s2">dirname</span><span class="s1">, </span><span class="s2">debugLog</span><span class="s1">, </span><span class="s2">babelApi</span><span class="s1">) {</span>
  <span class="s0">const </span><span class="s1">{</span>
    <span class="s1">method,</span>
    <span class="s1">methodName,</span>
    <span class="s1">targets,</span>
    <span class="s1">debug,</span>
    <span class="s1">shouldInjectPolyfill,</span>
    <span class="s1">providerOptions,</span>
    <span class="s1">absoluteImports</span>
  <span class="s1">} </span><span class="s0">= </span><span class="s5">resolveOptions</span><span class="s1">(</span><span class="s2">options</span><span class="s1">, </span><span class="s2">babelApi</span><span class="s1">);</span>
  <span class="s0">const </span><span class="s1">getUtils </span><span class="s0">= </span><span class="s5">createUtilsGetter</span><span class="s1">(</span><span class="s0">new </span><span class="s5">ImportsCache</span><span class="s1">(</span><span class="s2">moduleName </span><span class="s0">=&gt; </span><span class="s5">resolve</span><span class="s1">(</span><span class="s2">dirname</span><span class="s1">, </span><span class="s2">moduleName</span><span class="s1">, </span><span class="s2">absoluteImports</span><span class="s1">)));</span>

  <span class="s6">// eslint-disable-next-line prefer-const</span>
  <span class="s0">let </span><span class="s1">include, exclude;</span>
  <span class="s0">let </span><span class="s1">polyfillsSupport;</span>
  <span class="s0">let </span><span class="s1">polyfillsNames;</span>
  <span class="s0">let </span><span class="s1">filterPolyfills;</span>
  <span class="s0">const </span><span class="s1">depsCache </span><span class="s0">= new </span><span class="s5">Map</span><span class="s1">();</span>
  <span class="s0">const </span><span class="s1">api </span><span class="s0">= </span><span class="s1">{</span>
    <span class="s1">babel: </span><span class="s2">babelApi</span><span class="s1">,</span>
    <span class="s2">getUtils</span><span class="s1">,</span>
    <span class="s1">method: </span><span class="s2">options</span><span class="s1">.</span><span class="s2">method</span><span class="s1">,</span>
    <span class="s2">targets</span><span class="s1">,</span>
    <span class="s2">createMetaResolver</span><span class="s1">,</span>
    <span class="s1">shouldInjectPolyfill(</span><span class="s2">name</span><span class="s1">) {</span>
      <span class="s0">if </span><span class="s1">(</span><span class="s2">polyfillsNames </span><span class="s0">=== </span><span class="s4">undefined</span><span class="s1">) {</span>
        <span class="s0">throw new </span><span class="s5">Error</span><span class="s1">(</span><span class="s3">`Internal error in the ${</span><span class="s2">factory</span><span class="s3">.</span><span class="s2">name</span><span class="s3">} provider: ` </span><span class="s0">+ </span><span class="s3">`shouldInjectPolyfill() can't be called during initialization.`</span><span class="s1">);</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(</span><span class="s0">!</span><span class="s2">polyfillsNames</span><span class="s1">.</span><span class="s5">has</span><span class="s1">(</span><span class="s2">name</span><span class="s1">)) {</span>
        <span class="s2">console</span><span class="s1">.</span><span class="s5">warn</span><span class="s1">(</span><span class="s3">`Internal error in the ${</span><span class="s2">providerName</span><span class="s3">} provider: ` </span><span class="s0">+ </span><span class="s3">`unknown polyfill &quot;${</span><span class="s2">name</span><span class="s3">}&quot;.`</span><span class="s1">);</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(</span><span class="s2">filterPolyfills </span><span class="s0">&amp;&amp; !</span><span class="s5">filterPolyfills</span><span class="s1">(</span><span class="s2">name</span><span class="s1">)) </span><span class="s0">return </span><span class="s4">false</span><span class="s1">;</span>
      <span class="s0">let </span><span class="s1">shouldInject </span><span class="s0">= </span><span class="s5">isRequired</span><span class="s1">(</span><span class="s2">name</span><span class="s1">, </span><span class="s2">targets</span><span class="s1">, {</span>
        <span class="s1">compatData: </span><span class="s2">polyfillsSupport</span><span class="s1">,</span>
        <span class="s1">includes: </span><span class="s2">include</span><span class="s1">,</span>
        <span class="s1">excludes: </span><span class="s2">exclude</span>
      <span class="s1">});</span>
      <span class="s0">if </span><span class="s1">(</span><span class="s2">shouldInjectPolyfill</span><span class="s1">) {</span>
        <span class="s2">shouldInject </span><span class="s0">= </span><span class="s5">shouldInjectPolyfill</span><span class="s1">(</span><span class="s2">name</span><span class="s1">, </span><span class="s2">shouldInject</span><span class="s1">);</span>
        <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s2">shouldInject </span><span class="s0">!== </span><span class="s3">&quot;boolean&quot;</span><span class="s1">) {</span>
          <span class="s0">throw new </span><span class="s5">Error</span><span class="s1">(</span><span class="s3">`.shouldInjectPolyfill must return a boolean.`</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">return </span><span class="s2">shouldInject</span><span class="s1">;</span>
    <span class="s1">},</span>
    <span class="s1">debug(</span><span class="s2">name</span><span class="s1">) {</span>
      <span class="s0">var </span><span class="s1">_debugLog, _debugLog$polyfillsSu;</span>
      <span class="s5">debugLog</span><span class="s1">().</span><span class="s2">found </span><span class="s0">= </span><span class="s4">true</span><span class="s1">;</span>
      <span class="s0">if </span><span class="s1">(</span><span class="s0">!</span><span class="s2">debug </span><span class="s0">|| !</span><span class="s2">name</span><span class="s1">) </span><span class="s0">return</span><span class="s1">;</span>
      <span class="s0">if </span><span class="s1">(</span><span class="s5">debugLog</span><span class="s1">().</span><span class="s2">polyfills</span><span class="s1">.</span><span class="s5">has</span><span class="s1">(</span><span class="s2">providerName</span><span class="s1">)) </span><span class="s0">return</span><span class="s1">;</span>
      <span class="s5">debugLog</span><span class="s1">().</span><span class="s2">polyfills</span><span class="s1">.</span><span class="s5">add</span><span class="s1">(</span><span class="s2">name</span><span class="s1">);</span>
      <span class="s1">(</span><span class="s2">_debugLog$polyfillsSu </span><span class="s0">= </span><span class="s1">(</span><span class="s2">_debugLog </span><span class="s0">= </span><span class="s5">debugLog</span><span class="s1">()).</span><span class="s2">polyfillsSupport</span><span class="s1">) </span><span class="s0">!= </span><span class="s4">null </span><span class="s0">? </span><span class="s2">_debugLog$polyfillsSu </span><span class="s0">: </span><span class="s2">_debugLog</span><span class="s1">.</span><span class="s2">polyfillsSupport </span><span class="s0">= </span><span class="s2">polyfillsSupport</span><span class="s1">;</span>
    <span class="s1">},</span>
    <span class="s1">assertDependency(</span><span class="s2">name</span><span class="s1">, </span><span class="s2">version </span><span class="s0">= </span><span class="s3">&quot;*&quot;</span><span class="s1">) {</span>
      <span class="s0">if </span><span class="s1">(</span><span class="s2">missingDependencies </span><span class="s0">=== </span><span class="s4">false</span><span class="s1">) </span><span class="s0">return</span><span class="s1">;</span>
      <span class="s0">if </span><span class="s1">(</span><span class="s2">absoluteImports</span><span class="s1">) {</span>
        <span class="s6">// If absoluteImports is not false, we will try resolving</span>
        <span class="s6">// the dependency and throw if it's not possible. We can</span>
        <span class="s6">// skip the check here.</span>
        <span class="s0">return</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s0">const </span><span class="s1">dep </span><span class="s0">= </span><span class="s2">version </span><span class="s0">=== </span><span class="s3">&quot;*&quot; </span><span class="s0">? </span><span class="s2">name </span><span class="s0">: </span><span class="s3">`${</span><span class="s2">name</span><span class="s3">}@^${</span><span class="s2">version</span><span class="s3">}`</span><span class="s1">;</span>
      <span class="s0">const </span><span class="s1">found </span><span class="s0">= </span><span class="s2">missingDependencies</span><span class="s1">.</span><span class="s2">all </span><span class="s0">? </span><span class="s4">false </span><span class="s0">: </span><span class="s5">mapGetOr</span><span class="s1">(</span><span class="s2">depsCache</span><span class="s1">, </span><span class="s3">`${</span><span class="s2">name</span><span class="s3">} :: ${</span><span class="s2">dirname</span><span class="s3">}`</span><span class="s1">, () </span><span class="s0">=&gt; </span><span class="s5">has</span><span class="s1">());</span>
      <span class="s0">if </span><span class="s1">(</span><span class="s0">!</span><span class="s2">found</span><span class="s1">) {</span>
        <span class="s5">debugLog</span><span class="s1">().</span><span class="s2">missingDeps</span><span class="s1">.</span><span class="s5">add</span><span class="s1">(</span><span class="s2">dep</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">};</span>
  <span class="s0">const </span><span class="s1">provider </span><span class="s0">= </span><span class="s5">factory</span><span class="s1">(</span><span class="s2">api</span><span class="s1">, </span><span class="s2">providerOptions</span><span class="s1">, </span><span class="s2">dirname</span><span class="s1">);</span>
  <span class="s0">const </span><span class="s1">providerName </span><span class="s0">= </span><span class="s2">provider</span><span class="s1">.</span><span class="s2">name </span><span class="s0">|| </span><span class="s2">factory</span><span class="s1">.</span><span class="s2">name</span><span class="s1">;</span>
  <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s2">provider</span><span class="s1">[</span><span class="s2">methodName</span><span class="s1">] </span><span class="s0">!== </span><span class="s3">&quot;function&quot;</span><span class="s1">) {</span>
    <span class="s0">throw new </span><span class="s5">Error</span><span class="s1">(</span><span class="s3">`The &quot;${</span><span class="s2">providerName</span><span class="s3">}&quot; provider doesn't support the &quot;${</span><span class="s2">method</span><span class="s3">}&quot; polyfilling method.`</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s0">if </span><span class="s1">(</span><span class="s2">Array</span><span class="s1">.</span><span class="s5">isArray</span><span class="s1">(</span><span class="s2">provider</span><span class="s1">.</span><span class="s2">polyfills</span><span class="s1">)) {</span>
    <span class="s2">polyfillsNames </span><span class="s0">= new </span><span class="s5">Set</span><span class="s1">(</span><span class="s2">provider</span><span class="s1">.</span><span class="s2">polyfills</span><span class="s1">);</span>
    <span class="s2">filterPolyfills </span><span class="s0">= </span><span class="s2">provider</span><span class="s1">.</span><span class="s2">filterPolyfills</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s0">else if </span><span class="s1">(</span><span class="s2">provider</span><span class="s1">.</span><span class="s2">polyfills</span><span class="s1">) {</span>
    <span class="s2">polyfillsNames </span><span class="s0">= new </span><span class="s5">Set</span><span class="s1">(</span><span class="s2">Object</span><span class="s1">.</span><span class="s5">keys</span><span class="s1">(</span><span class="s2">provider</span><span class="s1">.</span><span class="s2">polyfills</span><span class="s1">));</span>
    <span class="s2">polyfillsSupport </span><span class="s0">= </span><span class="s2">provider</span><span class="s1">.</span><span class="s2">polyfills</span><span class="s1">;</span>
    <span class="s2">filterPolyfills </span><span class="s0">= </span><span class="s2">provider</span><span class="s1">.</span><span class="s2">filterPolyfills</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
    <span class="s2">polyfillsNames </span><span class="s0">= new </span><span class="s5">Set</span><span class="s1">();</span>
  <span class="s1">}</span>
  <span class="s1">({</span>
    <span class="s2">include</span><span class="s1">,</span>
    <span class="s2">exclude</span>
  <span class="s1">} </span><span class="s0">= </span><span class="s5">validateIncludeExclude</span><span class="s1">(</span><span class="s2">providerName</span><span class="s1">, </span><span class="s2">polyfillsNames</span><span class="s1">, </span><span class="s2">providerOptions</span><span class="s1">.</span><span class="s2">include </span><span class="s0">|| </span><span class="s1">[], </span><span class="s2">providerOptions</span><span class="s1">.</span><span class="s2">exclude </span><span class="s0">|| </span><span class="s1">[]));</span>
  <span class="s0">return </span><span class="s1">{</span>
    <span class="s2">debug</span><span class="s1">,</span>
    <span class="s2">method</span><span class="s1">,</span>
    <span class="s2">targets</span><span class="s1">,</span>
    <span class="s2">provider</span><span class="s1">,</span>
    <span class="s2">providerName</span><span class="s1">,</span>
    <span class="s1">callProvider(</span><span class="s2">payload</span><span class="s1">, </span><span class="s2">path</span><span class="s1">) {</span>
      <span class="s0">const </span><span class="s1">utils </span><span class="s0">= </span><span class="s5">getUtils</span><span class="s1">(</span><span class="s2">path</span><span class="s1">);</span>
      <span class="s2">provider</span><span class="s1">[</span><span class="s2">methodName</span><span class="s1">](</span><span class="s2">payload</span><span class="s1">, </span><span class="s2">utils</span><span class="s1">, </span><span class="s2">path</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">};</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">definePolyfillProvider(</span><span class="s2">factory</span><span class="s1">) {</span>
  <span class="s0">return </span><span class="s5">declare</span><span class="s1">((</span><span class="s2">babelApi</span><span class="s1">, </span><span class="s2">options</span><span class="s1">, </span><span class="s2">dirname</span><span class="s1">) </span><span class="s0">=&gt; </span><span class="s1">{</span>
    <span class="s2">babelApi</span><span class="s1">.</span><span class="s5">assertVersion</span><span class="s1">(</span><span class="s7">7</span><span class="s1">);</span>
    <span class="s0">const </span><span class="s1">{</span>
      <span class="s1">traverse</span>
    <span class="s1">} </span><span class="s0">= </span><span class="s2">babelApi</span><span class="s1">;</span>
    <span class="s0">let </span><span class="s1">debugLog;</span>
    <span class="s0">const </span><span class="s1">missingDependencies </span><span class="s0">= </span><span class="s5">applyMissingDependenciesDefaults</span><span class="s1">(</span><span class="s2">options</span><span class="s1">, </span><span class="s2">babelApi</span><span class="s1">);</span>
    <span class="s0">const </span><span class="s1">{</span>
      <span class="s1">debug,</span>
      <span class="s1">method,</span>
      <span class="s1">targets,</span>
      <span class="s1">provider,</span>
      <span class="s1">providerName,</span>
      <span class="s1">callProvider</span>
    <span class="s1">} </span><span class="s0">= </span><span class="s5">instantiateProvider</span><span class="s1">(</span><span class="s2">factory</span><span class="s1">, </span><span class="s2">options</span><span class="s1">, </span><span class="s2">missingDependencies</span><span class="s1">, </span><span class="s2">dirname</span><span class="s1">, () </span><span class="s0">=&gt; </span><span class="s2">debugLog</span><span class="s1">, </span><span class="s2">babelApi</span><span class="s1">);</span>
    <span class="s0">const </span><span class="s1">createVisitor </span><span class="s0">= </span><span class="s2">method </span><span class="s0">=== </span><span class="s3">&quot;entry-global&quot; </span><span class="s0">? </span><span class="s2">entry </span><span class="s0">: </span><span class="s2">usage</span><span class="s1">;</span>
    <span class="s0">const </span><span class="s1">visitor </span><span class="s0">= </span><span class="s2">provider</span><span class="s1">.</span><span class="s2">visitor </span><span class="s0">? </span><span class="s2">traverse</span><span class="s1">.</span><span class="s2">visitors</span><span class="s1">.</span><span class="s5">merge</span><span class="s1">([</span><span class="s5">createVisitor</span><span class="s1">(</span><span class="s2">callProvider</span><span class="s1">), </span><span class="s2">provider</span><span class="s1">.</span><span class="s2">visitor</span><span class="s1">]) </span><span class="s0">: </span><span class="s5">createVisitor</span><span class="s1">(</span><span class="s2">callProvider</span><span class="s1">);</span>
    <span class="s0">if </span><span class="s1">(</span><span class="s2">debug </span><span class="s0">&amp;&amp; </span><span class="s2">debug </span><span class="s0">!== </span><span class="s2">presetEnvSilentDebugHeader</span><span class="s1">) {</span>
      <span class="s2">console</span><span class="s1">.</span><span class="s5">log</span><span class="s1">(</span><span class="s3">`${</span><span class="s2">providerName</span><span class="s3">}: </span><span class="s8">\`</span><span class="s3">DEBUG</span><span class="s8">\` </span><span class="s3">option`</span><span class="s1">);</span>
      <span class="s2">console</span><span class="s1">.</span><span class="s5">log</span><span class="s1">(</span><span class="s3">`</span><span class="s8">\n</span><span class="s3">Using targets: ${</span><span class="s5">stringifyTargetsMultiline</span><span class="s3">(</span><span class="s2">targets</span><span class="s3">)}`</span><span class="s1">);</span>
      <span class="s2">console</span><span class="s1">.</span><span class="s5">log</span><span class="s1">(</span><span class="s3">`</span><span class="s8">\n</span><span class="s3">Using polyfills with </span><span class="s8">\`</span><span class="s3">${</span><span class="s2">method</span><span class="s3">}</span><span class="s8">\` </span><span class="s3">method:`</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s0">const </span><span class="s1">{</span>
      <span class="s1">runtimeName</span>
    <span class="s1">} </span><span class="s0">= </span><span class="s2">provider</span><span class="s1">;</span>
    <span class="s0">return </span><span class="s1">{</span>
      <span class="s1">name: </span><span class="s3">&quot;inject-polyfills&quot;</span><span class="s1">,</span>
      <span class="s2">visitor</span><span class="s1">,</span>
      <span class="s1">pre(</span><span class="s2">file</span><span class="s1">) {</span>
        <span class="s0">var </span><span class="s1">_provider$pre;</span>
        <span class="s0">if </span><span class="s1">(</span><span class="s2">runtimeName</span><span class="s1">) {</span>
          <span class="s0">if </span><span class="s1">(</span><span class="s2">file</span><span class="s1">.</span><span class="s5">get</span><span class="s1">(</span><span class="s3">&quot;runtimeHelpersModuleName&quot;</span><span class="s1">) </span><span class="s0">&amp;&amp; </span><span class="s2">file</span><span class="s1">.</span><span class="s5">get</span><span class="s1">(</span><span class="s3">&quot;runtimeHelpersModuleName&quot;</span><span class="s1">) </span><span class="s0">!== </span><span class="s2">runtimeName</span><span class="s1">) {</span>
            <span class="s2">console</span><span class="s1">.</span><span class="s5">warn</span><span class="s1">(</span><span class="s3">`Two different polyfill providers` </span><span class="s0">+ </span><span class="s3">` (${</span><span class="s2">file</span><span class="s3">.</span><span class="s5">get</span><span class="s3">(&quot;runtimeHelpersModuleProvider&quot;)}` </span><span class="s0">+ </span><span class="s3">` and ${</span><span class="s2">providerName</span><span class="s3">}) are trying to define two` </span><span class="s0">+ </span><span class="s3">` conflicting @babel/runtime alternatives:` </span><span class="s0">+ </span><span class="s3">` ${</span><span class="s2">file</span><span class="s3">.</span><span class="s5">get</span><span class="s3">(&quot;runtimeHelpersModuleName&quot;)} and ${</span><span class="s2">runtimeName</span><span class="s3">}.` </span><span class="s0">+ </span><span class="s3">` The second one will be ignored.`</span><span class="s1">);</span>
          <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
            <span class="s2">file</span><span class="s1">.</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;runtimeHelpersModuleName&quot;</span><span class="s1">, </span><span class="s2">runtimeName</span><span class="s1">);</span>
            <span class="s2">file</span><span class="s1">.</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;runtimeHelpersModuleProvider&quot;</span><span class="s1">, </span><span class="s2">providerName</span><span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">debugLog </span><span class="s0">= </span><span class="s1">{</span>
          <span class="s1">polyfills: </span><span class="s0">new </span><span class="s5">Set</span><span class="s1">(),</span>
          <span class="s1">polyfillsSupport: </span><span class="s4">undefined</span><span class="s1">,</span>
          <span class="s1">found: </span><span class="s4">false</span><span class="s1">,</span>
          <span class="s1">providers: </span><span class="s0">new </span><span class="s5">Set</span><span class="s1">(),</span>
          <span class="s1">missingDeps: </span><span class="s0">new </span><span class="s5">Set</span><span class="s1">()</span>
        <span class="s1">};</span>
        <span class="s1">(</span><span class="s2">_provider$pre </span><span class="s0">= </span><span class="s2">provider</span><span class="s1">.</span><span class="s2">pre</span><span class="s1">) </span><span class="s0">== </span><span class="s4">null </span><span class="s0">? void </span><span class="s7">0 </span><span class="s0">: </span><span class="s2">_provider$pre</span><span class="s1">.</span><span class="s5">apply</span><span class="s1">(</span><span class="s2">this</span><span class="s1">, </span><span class="s2">arguments</span><span class="s1">);</span>
      <span class="s1">},</span>
      <span class="s1">post() {</span>
        <span class="s0">var </span><span class="s1">_provider$post;</span>
        <span class="s1">(</span><span class="s2">_provider$post </span><span class="s0">= </span><span class="s2">provider</span><span class="s1">.</span><span class="s2">post</span><span class="s1">) </span><span class="s0">== </span><span class="s4">null </span><span class="s0">? void </span><span class="s7">0 </span><span class="s0">: </span><span class="s2">_provider$post</span><span class="s1">.</span><span class="s5">apply</span><span class="s1">(</span><span class="s2">this</span><span class="s1">, </span><span class="s2">arguments</span><span class="s1">);</span>
        <span class="s0">if </span><span class="s1">(</span><span class="s2">missingDependencies </span><span class="s0">!== </span><span class="s4">false</span><span class="s1">) {</span>
          <span class="s0">if </span><span class="s1">(</span><span class="s2">missingDependencies</span><span class="s1">.</span><span class="s2">log </span><span class="s0">=== </span><span class="s3">&quot;per-file&quot;</span><span class="s1">) {</span>
            <span class="s5">logMissing</span><span class="s1">(</span><span class="s2">debugLog</span><span class="s1">.</span><span class="s2">missingDeps</span><span class="s1">);</span>
          <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
            <span class="s5">laterLogMissing</span><span class="s1">(</span><span class="s2">debugLog</span><span class="s1">.</span><span class="s2">missingDeps</span><span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(</span><span class="s0">!</span><span class="s2">debug</span><span class="s1">) </span><span class="s0">return</span><span class="s1">;</span>
        <span class="s0">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.</span><span class="s2">filename</span><span class="s1">) </span><span class="s2">console</span><span class="s1">.</span><span class="s5">log</span><span class="s1">(</span><span class="s3">`</span><span class="s8">\n</span><span class="s3">[${</span><span class="s2">this</span><span class="s3">.</span><span class="s2">filename</span><span class="s3">}]`</span><span class="s1">);</span>
        <span class="s0">if </span><span class="s1">(</span><span class="s2">debugLog</span><span class="s1">.</span><span class="s2">polyfills</span><span class="s1">.</span><span class="s2">size </span><span class="s0">=== </span><span class="s7">0</span><span class="s1">) {</span>
          <span class="s2">console</span><span class="s1">.</span><span class="s5">log</span><span class="s1">(</span><span class="s2">method </span><span class="s0">=== </span><span class="s3">&quot;entry-global&quot; </span><span class="s0">? </span><span class="s2">debugLog</span><span class="s1">.</span><span class="s2">found </span><span class="s0">? </span><span class="s3">`Based on your targets, the ${</span><span class="s2">providerName</span><span class="s3">} polyfill did not add any polyfill.` </span><span class="s0">: </span><span class="s3">`The entry point for the ${</span><span class="s2">providerName</span><span class="s3">} polyfill has not been found.` </span><span class="s0">: </span><span class="s3">`Based on your code and targets, the ${</span><span class="s2">providerName</span><span class="s3">} polyfill did not add any polyfill.`</span><span class="s1">);</span>
          <span class="s0">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(</span><span class="s2">method </span><span class="s0">=== </span><span class="s3">&quot;entry-global&quot;</span><span class="s1">) {</span>
          <span class="s2">console</span><span class="s1">.</span><span class="s5">log</span><span class="s1">(</span><span class="s3">`The ${</span><span class="s2">providerName</span><span class="s3">} polyfill entry has been replaced with ` </span><span class="s0">+ </span><span class="s3">`the following polyfills:`</span><span class="s1">);</span>
        <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
          <span class="s2">console</span><span class="s1">.</span><span class="s5">log</span><span class="s1">(</span><span class="s3">`The ${</span><span class="s2">providerName</span><span class="s3">} polyfill added the following polyfills:`</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s0">for </span><span class="s1">(</span><span class="s0">const </span><span class="s1">name </span><span class="s0">of </span><span class="s2">debugLog</span><span class="s1">.</span><span class="s2">polyfills</span><span class="s1">) {</span>
          <span class="s0">var </span><span class="s1">_debugLog$polyfillsSu2;</span>
          <span class="s0">if </span><span class="s1">((</span><span class="s2">_debugLog$polyfillsSu2 </span><span class="s0">= </span><span class="s2">debugLog</span><span class="s1">.</span><span class="s2">polyfillsSupport</span><span class="s1">) </span><span class="s0">!= </span><span class="s4">null </span><span class="s0">&amp;&amp; </span><span class="s2">_debugLog$polyfillsSu2</span><span class="s1">[</span><span class="s2">name</span><span class="s1">]) {</span>
            <span class="s0">const </span><span class="s1">filteredTargets </span><span class="s0">= </span><span class="s5">getInclusionReasons</span><span class="s1">(</span><span class="s2">name</span><span class="s1">, </span><span class="s2">targets</span><span class="s1">, </span><span class="s2">debugLog</span><span class="s1">.</span><span class="s2">polyfillsSupport</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">formattedTargets </span><span class="s0">= </span><span class="s2">JSON</span><span class="s1">.</span><span class="s5">stringify</span><span class="s1">(</span><span class="s2">filteredTargets</span><span class="s1">).</span><span class="s5">replace</span><span class="s1">(</span><span class="s3">/,/</span><span class="s0">g</span><span class="s1">, </span><span class="s3">&quot;, &quot;</span><span class="s1">).</span><span class="s5">replace</span><span class="s1">(</span><span class="s3">/</span><span class="s0">^</span><span class="s8">\{</span><span class="s3">&quot;/</span><span class="s1">, </span><span class="s3">'{ &quot;'</span><span class="s1">).</span><span class="s5">replace</span><span class="s1">(</span><span class="s3">/&quot;</span><span class="s8">\}</span><span class="s0">$</span><span class="s3">/</span><span class="s1">, </span><span class="s3">'&quot; }'</span><span class="s1">);</span>
            <span class="s2">console</span><span class="s1">.</span><span class="s5">log</span><span class="s1">(</span><span class="s3">`  ${</span><span class="s2">name</span><span class="s3">} ${</span><span class="s2">formattedTargets</span><span class="s3">}`</span><span class="s1">);</span>
          <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
            <span class="s2">console</span><span class="s1">.</span><span class="s5">log</span><span class="s1">(</span><span class="s3">`  ${</span><span class="s2">name</span><span class="s3">}`</span><span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">};</span>
  <span class="s1">});</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">mapGetOr(</span><span class="s2">map</span><span class="s1">, </span><span class="s2">key</span><span class="s1">, </span><span class="s2">getDefault</span><span class="s1">) {</span>
  <span class="s0">let </span><span class="s1">val </span><span class="s0">= </span><span class="s2">map</span><span class="s1">.</span><span class="s5">get</span><span class="s1">(</span><span class="s2">key</span><span class="s1">);</span>
  <span class="s0">if </span><span class="s1">(</span><span class="s2">val </span><span class="s0">=== </span><span class="s4">undefined</span><span class="s1">) {</span>
    <span class="s2">val </span><span class="s0">= </span><span class="s5">getDefault</span><span class="s1">();</span>
    <span class="s2">map</span><span class="s1">.</span><span class="s5">set</span><span class="s1">(</span><span class="s2">key</span><span class="s1">, </span><span class="s2">val</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s0">return </span><span class="s2">val</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">isEmpty(</span><span class="s2">obj</span><span class="s1">) {</span>
  <span class="s0">return </span><span class="s2">Object</span><span class="s1">.</span><span class="s5">keys</span><span class="s1">(</span><span class="s2">obj</span><span class="s1">).length </span><span class="s0">=== </span><span class="s7">0</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">export default </span><span class="s2">definePolyfillProvider</span><span class="s1">;</span>
<span class="s6">//# sourceMappingURL=index.browser.mjs.map</span>
</pre>
</body>
</html>
<html>
<head>
<title>create-plugin.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6a8759;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
create-plugin.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>

<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
  <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s1">exports.</span><span class="s2">default </span><span class="s1">= createPlugin;</span>
<span class="s2">var </span><span class="s1">_pluginSyntaxJsx = require(</span><span class="s0">&quot;@babel/plugin-syntax-jsx&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_helperPluginUtils = require(</span><span class="s0">&quot;@babel/helper-plugin-utils&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_core = require(</span><span class="s0">&quot;@babel/core&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_helperModuleImports = require(</span><span class="s0">&quot;@babel/helper-module-imports&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_helperAnnotateAsPure = require(</span><span class="s0">&quot;@babel/helper-annotate-as-pure&quot;</span><span class="s1">);</span>
<span class="s1">const DEFAULT = {</span>
  <span class="s1">importSource: </span><span class="s0">&quot;react&quot;</span><span class="s1">,</span>
  <span class="s1">runtime: </span><span class="s0">&quot;automatic&quot;</span><span class="s1">,</span>
  <span class="s1">pragma: </span><span class="s0">&quot;React.createElement&quot;</span><span class="s1">,</span>
  <span class="s1">pragmaFrag: </span><span class="s0">&quot;React.Fragment&quot;</span>
<span class="s1">};</span>
<span class="s1">const JSX_SOURCE_ANNOTATION_REGEX = /^\s*\*?\s*@jsxImportSource\s+([^\s]+)\s*$/m;</span>
<span class="s1">const JSX_RUNTIME_ANNOTATION_REGEX = /^\s*\*?\s*@jsxRuntime\s+([^\s]+)\s*$/m;</span>
<span class="s1">const JSX_ANNOTATION_REGEX = /^\s*\*?\s*@jsx\s+([^\s]+)\s*$/m;</span>
<span class="s1">const JSX_FRAG_ANNOTATION_REGEX = /^\s*\*?\s*@jsxFrag\s+([^\s]+)\s*$/m;</span>
<span class="s1">const get = (pass, name) =&gt; pass.get(`@babel/plugin-react-jsx/${name}`);</span>
<span class="s1">const set = (pass, name, v) =&gt; pass.set(`@babel/plugin-react-jsx/${name}`, v);</span>
<span class="s2">function </span><span class="s1">hasProto(node) {</span>
  <span class="s2">return </span><span class="s1">node.properties.some(value =&gt; _core.types.isObjectProperty(value, {</span>
    <span class="s1">computed: </span><span class="s2">false</span><span class="s1">,</span>
    <span class="s1">shorthand: </span><span class="s2">false</span>
  <span class="s1">}) &amp;&amp; (_core.types.isIdentifier(value.key, {</span>
    <span class="s1">name: </span><span class="s0">&quot;__proto__&quot;</span>
  <span class="s1">}) || _core.types.isStringLiteral(value.key, {</span>
    <span class="s1">value: </span><span class="s0">&quot;__proto__&quot;</span>
  <span class="s1">})));</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createPlugin({</span>
  <span class="s1">name,</span>
  <span class="s1">development</span>
<span class="s1">}) {</span>
  <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _helperPluginUtils.declare)((_, options) =&gt; {</span>
    <span class="s1">const {</span>
      <span class="s1">pure: PURE_ANNOTATION,</span>
      <span class="s1">throwIfNamespace = </span><span class="s2">true</span><span class="s1">,</span>
      <span class="s1">filter,</span>
      <span class="s1">runtime: RUNTIME_DEFAULT = development ? </span><span class="s0">&quot;automatic&quot; </span><span class="s1">: </span><span class="s0">&quot;classic&quot;</span><span class="s1">,</span>
      <span class="s1">importSource: IMPORT_SOURCE_DEFAULT = DEFAULT.importSource,</span>
      <span class="s1">pragma: PRAGMA_DEFAULT = DEFAULT.pragma,</span>
      <span class="s1">pragmaFrag: PRAGMA_FRAG_DEFAULT = DEFAULT.pragmaFrag</span>
    <span class="s1">} = options;</span>
    <span class="s1">{</span>
      <span class="s2">var </span><span class="s1">{</span>
        <span class="s1">useSpread = </span><span class="s2">false</span><span class="s1">,</span>
        <span class="s1">useBuiltIns = </span><span class="s2">false</span>
      <span class="s1">} = options;</span>
      <span class="s2">if </span><span class="s1">(RUNTIME_DEFAULT === </span><span class="s0">&quot;classic&quot;</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">useSpread !== </span><span class="s0">&quot;boolean&quot;</span><span class="s1">) {</span>
          <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">&quot;transform-react-jsx currently only accepts a boolean option for &quot; </span><span class="s1">+ </span><span class="s0">&quot;useSpread (defaults to false)&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">useBuiltIns !== </span><span class="s0">&quot;boolean&quot;</span><span class="s1">) {</span>
          <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">&quot;transform-react-jsx currently only accepts a boolean option for &quot; </span><span class="s1">+ </span><span class="s0">&quot;useBuiltIns (defaults to false)&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(useSpread &amp;&amp; useBuiltIns) {</span>
          <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">&quot;transform-react-jsx currently only accepts useBuiltIns or useSpread &quot; </span><span class="s1">+ </span><span class="s0">&quot;but not both&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">const injectMetaPropertiesVisitor = {</span>
      <span class="s1">JSXOpeningElement(path, state) {</span>
        <span class="s1">const attributes = [];</span>
        <span class="s2">if </span><span class="s1">(isThisAllowed(path.scope)) {</span>
          <span class="s1">attributes.push(_core.types.jsxAttribute(_core.types.jsxIdentifier(</span><span class="s0">&quot;__self&quot;</span><span class="s1">), _core.types.jsxExpressionContainer(_core.types.thisExpression())));</span>
        <span class="s1">}</span>
        <span class="s1">attributes.push(_core.types.jsxAttribute(_core.types.jsxIdentifier(</span><span class="s0">&quot;__source&quot;</span><span class="s1">), _core.types.jsxExpressionContainer(makeSource(path, state))));</span>
        <span class="s1">path.pushContainer(</span><span class="s0">&quot;attributes&quot;</span><span class="s1">, attributes);</span>
      <span class="s1">}</span>
    <span class="s1">};</span>
    <span class="s2">return </span><span class="s1">{</span>
      <span class="s1">name,</span>
      <span class="s1">inherits: _pluginSyntaxJsx.</span><span class="s2">default</span><span class="s1">,</span>
      <span class="s1">visitor: {</span>
        <span class="s1">JSXNamespacedName(path) {</span>
          <span class="s2">if </span><span class="s1">(throwIfNamespace) {</span>
            <span class="s2">throw </span><span class="s1">path.buildCodeFrameError(`Namespace tags are not supported by </span><span class="s2">default</span><span class="s1">. React</span><span class="s0">'s JSX doesn'</span><span class="s1">t support namespace tags. \</span>
<span class="s1">You can set \`throwIfNamespace: </span><span class="s2">false</span><span class="s1">\` to bypass </span><span class="s2">this </span><span class="s1">warning.`);</span>
          <span class="s1">}</span>
        <span class="s1">},</span>
        <span class="s1">JSXSpreadChild(path) {</span>
          <span class="s2">throw </span><span class="s1">path.buildCodeFrameError(</span><span class="s0">&quot;Spread children are not supported in React.&quot;</span><span class="s1">);</span>
        <span class="s1">},</span>
        <span class="s1">Program: {</span>
          <span class="s1">enter(path, state) {</span>
            <span class="s1">const {</span>
              <span class="s1">file</span>
            <span class="s1">} = state;</span>
            <span class="s1">let runtime = RUNTIME_DEFAULT;</span>
            <span class="s1">let source = IMPORT_SOURCE_DEFAULT;</span>
            <span class="s1">let pragma = PRAGMA_DEFAULT;</span>
            <span class="s1">let pragmaFrag = PRAGMA_FRAG_DEFAULT;</span>
            <span class="s1">let sourceSet = !!options.importSource;</span>
            <span class="s1">let pragmaSet = !!options.pragma;</span>
            <span class="s1">let pragmaFragSet = !!options.pragmaFrag;</span>
            <span class="s2">if </span><span class="s1">(file.ast.comments) {</span>
              <span class="s2">for </span><span class="s1">(const comment of file.ast.comments) {</span>
                <span class="s1">const sourceMatches = JSX_SOURCE_ANNOTATION_REGEX.exec(comment.value);</span>
                <span class="s2">if </span><span class="s1">(sourceMatches) {</span>
                  <span class="s1">source = sourceMatches[</span><span class="s3">1</span><span class="s1">];</span>
                  <span class="s1">sourceSet = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s1">const runtimeMatches = JSX_RUNTIME_ANNOTATION_REGEX.exec(comment.value);</span>
                <span class="s2">if </span><span class="s1">(runtimeMatches) {</span>
                  <span class="s1">runtime = runtimeMatches[</span><span class="s3">1</span><span class="s1">];</span>
                <span class="s1">}</span>
                <span class="s1">const jsxMatches = JSX_ANNOTATION_REGEX.exec(comment.value);</span>
                <span class="s2">if </span><span class="s1">(jsxMatches) {</span>
                  <span class="s1">pragma = jsxMatches[</span><span class="s3">1</span><span class="s1">];</span>
                  <span class="s1">pragmaSet = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s1">const jsxFragMatches = JSX_FRAG_ANNOTATION_REGEX.exec(comment.value);</span>
                <span class="s2">if </span><span class="s1">(jsxFragMatches) {</span>
                  <span class="s1">pragmaFrag = jsxFragMatches[</span><span class="s3">1</span><span class="s1">];</span>
                  <span class="s1">pragmaFragSet = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s1">}</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">set(state, </span><span class="s0">&quot;runtime&quot;</span><span class="s1">, runtime);</span>
            <span class="s2">if </span><span class="s1">(runtime === </span><span class="s0">&quot;classic&quot;</span><span class="s1">) {</span>
              <span class="s2">if </span><span class="s1">(sourceSet) {</span>
                <span class="s2">throw </span><span class="s1">path.buildCodeFrameError(`importSource cannot be set when runtime is classic.`);</span>
              <span class="s1">}</span>
              <span class="s1">const createElement = toMemberExpression(pragma);</span>
              <span class="s1">const fragment = toMemberExpression(pragmaFrag);</span>
              <span class="s1">set(state, </span><span class="s0">&quot;id/createElement&quot;</span><span class="s1">, () =&gt; _core.types.cloneNode(createElement));</span>
              <span class="s1">set(state, </span><span class="s0">&quot;id/fragment&quot;</span><span class="s1">, () =&gt; _core.types.cloneNode(fragment));</span>
              <span class="s1">set(state, </span><span class="s0">&quot;defaultPure&quot;</span><span class="s1">, pragma === DEFAULT.pragma);</span>
            <span class="s1">} </span><span class="s2">else if </span><span class="s1">(runtime === </span><span class="s0">&quot;automatic&quot;</span><span class="s1">) {</span>
              <span class="s2">if </span><span class="s1">(pragmaSet || pragmaFragSet) {</span>
                <span class="s2">throw </span><span class="s1">path.buildCodeFrameError(`pragma and pragmaFrag cannot be set when runtime is automatic.`);</span>
              <span class="s1">}</span>
              <span class="s1">const define = (name, id) =&gt; set(state, name, createImportLazily(state, path, id, source));</span>
              <span class="s1">define(</span><span class="s0">&quot;id/jsx&quot;</span><span class="s1">, development ? </span><span class="s0">&quot;jsxDEV&quot; </span><span class="s1">: </span><span class="s0">&quot;jsx&quot;</span><span class="s1">);</span>
              <span class="s1">define(</span><span class="s0">&quot;id/jsxs&quot;</span><span class="s1">, development ? </span><span class="s0">&quot;jsxDEV&quot; </span><span class="s1">: </span><span class="s0">&quot;jsxs&quot;</span><span class="s1">);</span>
              <span class="s1">define(</span><span class="s0">&quot;id/createElement&quot;</span><span class="s1">, </span><span class="s0">&quot;createElement&quot;</span><span class="s1">);</span>
              <span class="s1">define(</span><span class="s0">&quot;id/fragment&quot;</span><span class="s1">, </span><span class="s0">&quot;Fragment&quot;</span><span class="s1">);</span>
              <span class="s1">set(state, </span><span class="s0">&quot;defaultPure&quot;</span><span class="s1">, source === DEFAULT.importSource);</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
              <span class="s2">throw </span><span class="s1">path.buildCodeFrameError(`Runtime must be either </span><span class="s0">&quot;classic&quot; </span><span class="s1">or </span><span class="s0">&quot;automatic&quot;</span><span class="s1">.`);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(development) {</span>
              <span class="s1">path.traverse(injectMetaPropertiesVisitor, state);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">},</span>
        <span class="s1">JSXFragment: {</span>
          <span class="s1">exit(path, file) {</span>
            <span class="s1">let callExpr;</span>
            <span class="s2">if </span><span class="s1">(get(file, </span><span class="s0">&quot;runtime&quot;</span><span class="s1">) === </span><span class="s0">&quot;classic&quot;</span><span class="s1">) {</span>
              <span class="s1">callExpr = buildCreateElementFragmentCall(path, file);</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
              <span class="s1">callExpr = buildJSXFragmentCall(path, file);</span>
            <span class="s1">}</span>
            <span class="s1">path.replaceWith(_core.types.inherits(callExpr, path.node));</span>
          <span class="s1">}</span>
        <span class="s1">},</span>
        <span class="s1">JSXElement: {</span>
          <span class="s1">exit(path, file) {</span>
            <span class="s1">let callExpr;</span>
            <span class="s2">if </span><span class="s1">(get(file, </span><span class="s0">&quot;runtime&quot;</span><span class="s1">) === </span><span class="s0">&quot;classic&quot; </span><span class="s1">|| shouldUseCreateElement(path)) {</span>
              <span class="s1">callExpr = buildCreateElementCall(path, file);</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
              <span class="s1">callExpr = buildJSXElementCall(path, file);</span>
            <span class="s1">}</span>
            <span class="s1">path.replaceWith(_core.types.inherits(callExpr, path.node));</span>
          <span class="s1">}</span>
        <span class="s1">},</span>
        <span class="s1">JSXAttribute(path) {</span>
          <span class="s2">if </span><span class="s1">(_core.types.isJSXElement(path.node.value)) {</span>
            <span class="s1">path.node.value = _core.types.jsxExpressionContainer(path.node.value);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">};</span>
    <span class="s2">function </span><span class="s1">isDerivedClass(classPath) {</span>
      <span class="s2">return </span><span class="s1">classPath.node.superClass !== </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">isThisAllowed(scope) {</span>
      <span class="s2">do </span><span class="s1">{</span>
        <span class="s1">const {</span>
          <span class="s1">path</span>
        <span class="s1">} = scope;</span>
        <span class="s2">if </span><span class="s1">(path.isFunctionParent() &amp;&amp; !path.isArrowFunctionExpression()) {</span>
          <span class="s2">if </span><span class="s1">(!path.isMethod()) {</span>
            <span class="s2">return true</span><span class="s1">;</span>
          <span class="s1">}</span>
          <span class="s2">if </span><span class="s1">(path.node.kind !== </span><span class="s0">&quot;constructor&quot;</span><span class="s1">) {</span>
            <span class="s2">return true</span><span class="s1">;</span>
          <span class="s1">}</span>
          <span class="s2">return </span><span class="s1">!isDerivedClass(path.parentPath.parentPath);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(path.isTSModuleBlock()) {</span>
          <span class="s2">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">while </span><span class="s1">(scope = scope.parent);</span>
      <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">call(pass, name, args) {</span>
      <span class="s1">const node = _core.types.callExpression(get(pass, `id/${name}`)(), args);</span>
      <span class="s2">if </span><span class="s1">(PURE_ANNOTATION != </span><span class="s2">null </span><span class="s1">? PURE_ANNOTATION : get(pass, </span><span class="s0">&quot;defaultPure&quot;</span><span class="s1">)) (</span><span class="s3">0</span><span class="s1">, _helperAnnotateAsPure.</span><span class="s2">default</span><span class="s1">)(node);</span>
      <span class="s2">return </span><span class="s1">node;</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">shouldUseCreateElement(path) {</span>
      <span class="s1">const openingPath = path.get(</span><span class="s0">&quot;openingElement&quot;</span><span class="s1">);</span>
      <span class="s1">const attributes = openingPath.node.attributes;</span>
      <span class="s1">let seenPropsSpread = </span><span class="s2">false</span><span class="s1">;</span>
      <span class="s2">for </span><span class="s1">(let i = </span><span class="s3">0</span><span class="s1">; i &lt; attributes.length; i++) {</span>
        <span class="s1">const attr = attributes[i];</span>
        <span class="s2">if </span><span class="s1">(seenPropsSpread &amp;&amp; _core.types.isJSXAttribute(attr) &amp;&amp; attr.name.name === </span><span class="s0">&quot;key&quot;</span><span class="s1">) {</span>
          <span class="s2">return true</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(_core.types.isJSXSpreadAttribute(attr)) {</span>
          <span class="s1">seenPropsSpread = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">convertJSXIdentifier(node, parent) {</span>
      <span class="s2">if </span><span class="s1">(_core.types.isJSXIdentifier(node)) {</span>
        <span class="s2">if </span><span class="s1">(node.name === </span><span class="s0">&quot;this&quot; </span><span class="s1">&amp;&amp; _core.types.isReferenced(node, parent)) {</span>
          <span class="s2">return </span><span class="s1">_core.types.thisExpression();</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(_core.types.isValidIdentifier(node.name, </span><span class="s2">false</span><span class="s1">)) {</span>
          <span class="s1">node.type = </span><span class="s0">&quot;Identifier&quot;</span><span class="s1">;</span>
          <span class="s2">return </span><span class="s1">node;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s2">return </span><span class="s1">_core.types.stringLiteral(node.name);</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(_core.types.isJSXMemberExpression(node)) {</span>
        <span class="s2">return </span><span class="s1">_core.types.memberExpression(convertJSXIdentifier(node.object, node), convertJSXIdentifier(node.property, node));</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(_core.types.isJSXNamespacedName(node)) {</span>
        <span class="s2">return </span><span class="s1">_core.types.stringLiteral(`${node.namespace.name}:${node.name.name}`);</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">node;</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">convertAttributeValue(node) {</span>
      <span class="s2">if </span><span class="s1">(_core.types.isJSXExpressionContainer(node)) {</span>
        <span class="s2">return </span><span class="s1">node.expression;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">return </span><span class="s1">node;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">accumulateAttribute(array, attribute) {</span>
      <span class="s2">if </span><span class="s1">(_core.types.isJSXSpreadAttribute(attribute.node)) {</span>
        <span class="s1">const arg = attribute.node.argument;</span>
        <span class="s2">if </span><span class="s1">(_core.types.isObjectExpression(arg) &amp;&amp; !hasProto(arg)) {</span>
          <span class="s1">array.push(...arg.properties);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">array.push(_core.types.spreadElement(arg));</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">array;</span>
      <span class="s1">}</span>
      <span class="s1">const value = convertAttributeValue(attribute.node.name.name !== </span><span class="s0">&quot;key&quot; </span><span class="s1">? attribute.node.value || _core.types.booleanLiteral(</span><span class="s2">true</span><span class="s1">) : attribute.node.value);</span>
      <span class="s2">if </span><span class="s1">(attribute.node.name.name === </span><span class="s0">&quot;key&quot; </span><span class="s1">&amp;&amp; value === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">throw </span><span class="s1">attribute.buildCodeFrameError(</span><span class="s0">'Please provide an explicit key value. Using &quot;key&quot; as a shorthand for &quot;key={true}&quot; is not allowed.'</span><span class="s1">);</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(_core.types.isStringLiteral(value) &amp;&amp; !_core.types.isJSXExpressionContainer(attribute.node.value)) {</span>
        <span class="s2">var </span><span class="s1">_value$extra;</span>
        <span class="s1">value.value = value.value.replace(/\n\s+/g, </span><span class="s0">&quot; &quot;</span><span class="s1">);</span>
        <span class="s1">(_value$extra = value.extra) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">true </span><span class="s1">: </span><span class="s2">delete </span><span class="s1">_value$extra.raw;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(_core.types.isJSXNamespacedName(attribute.node.name)) {</span>
        <span class="s1">attribute.node.name = _core.types.stringLiteral(attribute.node.name.namespace.name + </span><span class="s0">&quot;:&quot; </span><span class="s1">+ attribute.node.name.name.name);</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(_core.types.isValidIdentifier(attribute.node.name.name, </span><span class="s2">false</span><span class="s1">)) {</span>
        <span class="s1">attribute.node.name.type = </span><span class="s0">&quot;Identifier&quot;</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">attribute.node.name = _core.types.stringLiteral(attribute.node.name.name);</span>
      <span class="s1">}</span>
      <span class="s1">array.push(_core.types.inherits(_core.types.objectProperty(attribute.node.name, value), attribute.node));</span>
      <span class="s2">return </span><span class="s1">array;</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">buildChildrenProperty(children) {</span>
      <span class="s1">let childrenNode;</span>
      <span class="s2">if </span><span class="s1">(children.length === </span><span class="s3">1</span><span class="s1">) {</span>
        <span class="s1">childrenNode = children[</span><span class="s3">0</span><span class="s1">];</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(children.length &gt; </span><span class="s3">1</span><span class="s1">) {</span>
        <span class="s1">childrenNode = _core.types.arrayExpression(children);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">return </span><span class="s1">undefined;</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">_core.types.objectProperty(_core.types.identifier(</span><span class="s0">&quot;children&quot;</span><span class="s1">), childrenNode);</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">buildJSXElementCall(path, file) {</span>
      <span class="s1">const openingPath = path.get(</span><span class="s0">&quot;openingElement&quot;</span><span class="s1">);</span>
      <span class="s1">const args = [getTag(openingPath)];</span>
      <span class="s1">const attribsArray = [];</span>
      <span class="s1">const extracted = Object.create(</span><span class="s2">null</span><span class="s1">);</span>
      <span class="s2">for </span><span class="s1">(const attr of openingPath.get(</span><span class="s0">&quot;attributes&quot;</span><span class="s1">)) {</span>
        <span class="s2">if </span><span class="s1">(attr.isJSXAttribute() &amp;&amp; _core.types.isJSXIdentifier(attr.node.name)) {</span>
          <span class="s1">const {</span>
            <span class="s1">name</span>
          <span class="s1">} = attr.node.name;</span>
          <span class="s2">switch </span><span class="s1">(name) {</span>
            <span class="s2">case </span><span class="s0">&quot;__source&quot;</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">&quot;__self&quot;</span><span class="s1">:</span>
              <span class="s2">if </span><span class="s1">(extracted[name]) </span><span class="s2">throw </span><span class="s1">sourceSelfError(path, name);</span>
            <span class="s2">case </span><span class="s0">&quot;key&quot;</span><span class="s1">:</span>
              <span class="s1">{</span>
                <span class="s1">const keyValue = convertAttributeValue(attr.node.value);</span>
                <span class="s2">if </span><span class="s1">(keyValue === </span><span class="s2">null</span><span class="s1">) {</span>
                  <span class="s2">throw </span><span class="s1">attr.buildCodeFrameError(</span><span class="s0">'Please provide an explicit key value. Using &quot;key&quot; as a shorthand for &quot;key={true}&quot; is not allowed.'</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s1">extracted[name] = keyValue;</span>
                <span class="s2">break</span><span class="s1">;</span>
              <span class="s1">}</span>
            <span class="s2">default</span><span class="s1">:</span>
              <span class="s1">attribsArray.push(attr);</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">attribsArray.push(attr);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s1">const children = _core.types.react.buildChildren(path.node);</span>
      <span class="s1">let attribs;</span>
      <span class="s2">if </span><span class="s1">(attribsArray.length || children.length) {</span>
        <span class="s1">attribs = buildJSXOpeningElementAttributes(attribsArray, children);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">attribs = _core.types.objectExpression([]);</span>
      <span class="s1">}</span>
      <span class="s1">args.push(attribs);</span>
      <span class="s2">if </span><span class="s1">(development) {</span>
        <span class="s2">var </span><span class="s1">_extracted$key;</span>
        <span class="s1">args.push((_extracted$key = extracted.key) != </span><span class="s2">null </span><span class="s1">? _extracted$key : path.scope.buildUndefinedNode(), _core.types.booleanLiteral(children.length &gt; </span><span class="s3">1</span><span class="s1">));</span>
        <span class="s2">if </span><span class="s1">(extracted.__source) {</span>
          <span class="s1">args.push(extracted.__source);</span>
          <span class="s2">if </span><span class="s1">(extracted.__self) args.push(extracted.__self);</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(extracted.__self) {</span>
          <span class="s1">args.push(path.scope.buildUndefinedNode(), extracted.__self);</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(extracted.key !== undefined) {</span>
        <span class="s1">args.push(extracted.key);</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">call(file, children.length &gt; </span><span class="s3">1 </span><span class="s1">? </span><span class="s0">&quot;jsxs&quot; </span><span class="s1">: </span><span class="s0">&quot;jsx&quot;</span><span class="s1">, args);</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">buildJSXOpeningElementAttributes(attribs, children) {</span>
      <span class="s1">const props = attribs.reduce(accumulateAttribute, []);</span>
      <span class="s2">if </span><span class="s1">((children == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: children.length) &gt; </span><span class="s3">0</span><span class="s1">) {</span>
        <span class="s1">props.push(buildChildrenProperty(children));</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">_core.types.objectExpression(props);</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">buildJSXFragmentCall(path, file) {</span>
      <span class="s1">const args = [get(file, </span><span class="s0">&quot;id/fragment&quot;</span><span class="s1">)()];</span>
      <span class="s1">const children = _core.types.react.buildChildren(path.node);</span>
      <span class="s1">args.push(_core.types.objectExpression(children.length &gt; </span><span class="s3">0 </span><span class="s1">? [buildChildrenProperty(children)] : []));</span>
      <span class="s2">if </span><span class="s1">(development) {</span>
        <span class="s1">args.push(path.scope.buildUndefinedNode(), _core.types.booleanLiteral(children.length &gt; </span><span class="s3">1</span><span class="s1">));</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">call(file, children.length &gt; </span><span class="s3">1 </span><span class="s1">? </span><span class="s0">&quot;jsxs&quot; </span><span class="s1">: </span><span class="s0">&quot;jsx&quot;</span><span class="s1">, args);</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">buildCreateElementFragmentCall(path, file) {</span>
      <span class="s2">if </span><span class="s1">(filter &amp;&amp; !filter(path.node, file)) </span><span class="s2">return</span><span class="s1">;</span>
      <span class="s2">return </span><span class="s1">call(file, </span><span class="s0">&quot;createElement&quot;</span><span class="s1">, [get(file, </span><span class="s0">&quot;id/fragment&quot;</span><span class="s1">)(), _core.types.nullLiteral(), ..._core.types.react.buildChildren(path.node)]);</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">buildCreateElementCall(path, file) {</span>
      <span class="s1">const openingPath = path.get(</span><span class="s0">&quot;openingElement&quot;</span><span class="s1">);</span>
      <span class="s2">return </span><span class="s1">call(file, </span><span class="s0">&quot;createElement&quot;</span><span class="s1">, [getTag(openingPath), buildCreateElementOpeningElementAttributes(file, path, openingPath.get(</span><span class="s0">&quot;attributes&quot;</span><span class="s1">)), ..._core.types.react.buildChildren(path.node)]);</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">getTag(openingPath) {</span>
      <span class="s1">const tagExpr = convertJSXIdentifier(openingPath.node.name, openingPath.node);</span>
      <span class="s1">let tagName;</span>
      <span class="s2">if </span><span class="s1">(_core.types.isIdentifier(tagExpr)) {</span>
        <span class="s1">tagName = tagExpr.name;</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(_core.types.isStringLiteral(tagExpr)) {</span>
        <span class="s1">tagName = tagExpr.value;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(_core.types.react.isCompatTag(tagName)) {</span>
        <span class="s2">return </span><span class="s1">_core.types.stringLiteral(tagName);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">return </span><span class="s1">tagExpr;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">buildCreateElementOpeningElementAttributes(file, path, attribs) {</span>
      <span class="s1">const runtime = get(file, </span><span class="s0">&quot;runtime&quot;</span><span class="s1">);</span>
      <span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(runtime !== </span><span class="s0">&quot;automatic&quot;</span><span class="s1">) {</span>
          <span class="s1">const objs = [];</span>
          <span class="s1">const props = attribs.reduce(accumulateAttribute, []);</span>
          <span class="s2">if </span><span class="s1">(!useSpread) {</span>
            <span class="s1">let start = </span><span class="s3">0</span><span class="s1">;</span>
            <span class="s1">props.forEach((prop, i) =&gt; {</span>
              <span class="s2">if </span><span class="s1">(_core.types.isSpreadElement(prop)) {</span>
                <span class="s2">if </span><span class="s1">(i &gt; start) {</span>
                  <span class="s1">objs.push(_core.types.objectExpression(props.slice(start, i)));</span>
                <span class="s1">}</span>
                <span class="s1">objs.push(prop.argument);</span>
                <span class="s1">start = i + </span><span class="s3">1</span><span class="s1">;</span>
              <span class="s1">}</span>
            <span class="s1">});</span>
            <span class="s2">if </span><span class="s1">(props.length &gt; start) {</span>
              <span class="s1">objs.push(_core.types.objectExpression(props.slice(start)));</span>
            <span class="s1">}</span>
          <span class="s1">} </span><span class="s2">else if </span><span class="s1">(props.length) {</span>
            <span class="s1">objs.push(_core.types.objectExpression(props));</span>
          <span class="s1">}</span>
          <span class="s2">if </span><span class="s1">(!objs.length) {</span>
            <span class="s2">return </span><span class="s1">_core.types.nullLiteral();</span>
          <span class="s1">}</span>
          <span class="s2">if </span><span class="s1">(objs.length === </span><span class="s3">1</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(!(_core.types.isSpreadElement(props[</span><span class="s3">0</span><span class="s1">]) &amp;&amp; _core.types.isObjectExpression(props[</span><span class="s3">0</span><span class="s1">].argument))) {</span>
              <span class="s2">return </span><span class="s1">objs[</span><span class="s3">0</span><span class="s1">];</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
          <span class="s2">if </span><span class="s1">(!_core.types.isObjectExpression(objs[</span><span class="s3">0</span><span class="s1">])) {</span>
            <span class="s1">objs.unshift(_core.types.objectExpression([]));</span>
          <span class="s1">}</span>
          <span class="s1">const helper = useBuiltIns ? _core.types.memberExpression(_core.types.identifier(</span><span class="s0">&quot;Object&quot;</span><span class="s1">), _core.types.identifier(</span><span class="s0">&quot;assign&quot;</span><span class="s1">)) : file.addHelper(</span><span class="s0">&quot;extends&quot;</span><span class="s1">);</span>
          <span class="s2">return </span><span class="s1">_core.types.callExpression(helper, objs);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s1">const props = [];</span>
      <span class="s1">const found = Object.create(</span><span class="s2">null</span><span class="s1">);</span>
      <span class="s2">for </span><span class="s1">(const attr of attribs) {</span>
        <span class="s1">const {</span>
          <span class="s1">node</span>
        <span class="s1">} = attr;</span>
        <span class="s1">const name = _core.types.isJSXAttribute(node) &amp;&amp; _core.types.isJSXIdentifier(node.name) &amp;&amp; node.name.name;</span>
        <span class="s2">if </span><span class="s1">(runtime === </span><span class="s0">&quot;automatic&quot; </span><span class="s1">&amp;&amp; (name === </span><span class="s0">&quot;__source&quot; </span><span class="s1">|| name === </span><span class="s0">&quot;__self&quot;</span><span class="s1">)) {</span>
          <span class="s2">if </span><span class="s1">(found[name]) </span><span class="s2">throw </span><span class="s1">sourceSelfError(path, name);</span>
          <span class="s1">found[name] = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">accumulateAttribute(props, attr);</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">props.length === </span><span class="s3">1 </span><span class="s1">&amp;&amp; _core.types.isSpreadElement(props[</span><span class="s3">0</span><span class="s1">]) &amp;&amp; !_core.types.isObjectExpression(props[</span><span class="s3">0</span><span class="s1">].argument) ? props[</span><span class="s3">0</span><span class="s1">].argument : props.length &gt; </span><span class="s3">0 </span><span class="s1">? _core.types.objectExpression(props) : _core.types.nullLiteral();</span>
    <span class="s1">}</span>
  <span class="s1">});</span>
  <span class="s2">function </span><span class="s1">getSource(source, importName) {</span>
    <span class="s2">switch </span><span class="s1">(importName) {</span>
      <span class="s2">case </span><span class="s0">&quot;Fragment&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">`${source}/${development ? </span><span class="s0">&quot;jsx-dev-runtime&quot; </span><span class="s1">: </span><span class="s0">&quot;jsx-runtime&quot;</span><span class="s1">}`;</span>
      <span class="s2">case </span><span class="s0">&quot;jsxDEV&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">`${source}/jsx-dev-runtime`;</span>
      <span class="s2">case </span><span class="s0">&quot;jsx&quot;</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">&quot;jsxs&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">`${source}/jsx-runtime`;</span>
      <span class="s2">case </span><span class="s0">&quot;createElement&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">source;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">createImportLazily(pass, path, importName, source) {</span>
    <span class="s2">return </span><span class="s1">() =&gt; {</span>
      <span class="s1">const actualSource = getSource(source, importName);</span>
      <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _helperModuleImports.isModule)(path)) {</span>
        <span class="s1">let reference = get(pass, `imports/${importName}`);</span>
        <span class="s2">if </span><span class="s1">(reference) </span><span class="s2">return </span><span class="s1">_core.types.cloneNode(reference);</span>
        <span class="s1">reference = (</span><span class="s3">0</span><span class="s1">, _helperModuleImports.addNamed)(path, importName, actualSource, {</span>
          <span class="s1">importedInterop: </span><span class="s0">&quot;uncompiled&quot;</span><span class="s1">,</span>
          <span class="s1">importPosition: </span><span class="s0">&quot;after&quot;</span>
        <span class="s1">});</span>
        <span class="s1">set(pass, `imports/${importName}`, reference);</span>
        <span class="s2">return </span><span class="s1">reference;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">let reference = get(pass, `requires/${actualSource}`);</span>
        <span class="s2">if </span><span class="s1">(reference) {</span>
          <span class="s1">reference = _core.types.cloneNode(reference);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">reference = (</span><span class="s3">0</span><span class="s1">, _helperModuleImports.addNamespace)(path, actualSource, {</span>
            <span class="s1">importedInterop: </span><span class="s0">&quot;uncompiled&quot;</span>
          <span class="s1">});</span>
          <span class="s1">set(pass, `requires/${actualSource}`, reference);</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">_core.types.memberExpression(reference, _core.types.identifier(importName));</span>
      <span class="s1">}</span>
    <span class="s1">};</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">toMemberExpression(id) {</span>
  <span class="s2">return </span><span class="s1">id.split(</span><span class="s0">&quot;.&quot;</span><span class="s1">).map(name =&gt; _core.types.identifier(name)).reduce((object, property) =&gt; _core.types.memberExpression(object, property));</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">makeSource(path, state) {</span>
  <span class="s1">const location = path.node.loc;</span>
  <span class="s2">if </span><span class="s1">(!location) {</span>
    <span class="s2">return </span><span class="s1">path.scope.buildUndefinedNode();</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(!state.fileNameIdentifier) {</span>
    <span class="s1">const {</span>
      <span class="s1">filename = </span><span class="s0">&quot;&quot;</span>
    <span class="s1">} = state;</span>
    <span class="s1">const fileNameIdentifier = path.scope.generateUidIdentifier(</span><span class="s0">&quot;_jsxFileName&quot;</span><span class="s1">);</span>
    <span class="s1">path.scope.getProgramParent().push({</span>
      <span class="s1">id: fileNameIdentifier,</span>
      <span class="s1">init: _core.types.stringLiteral(filename)</span>
    <span class="s1">});</span>
    <span class="s1">state.fileNameIdentifier = fileNameIdentifier;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">makeTrace(_core.types.cloneNode(state.fileNameIdentifier), location.start.line, location.start.column);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">makeTrace(fileNameIdentifier, lineNumber, column0Based) {</span>
  <span class="s1">const fileLineLiteral = lineNumber != </span><span class="s2">null </span><span class="s1">? _core.types.numericLiteral(lineNumber) : _core.types.nullLiteral();</span>
  <span class="s1">const fileColumnLiteral = column0Based != </span><span class="s2">null </span><span class="s1">? _core.types.numericLiteral(column0Based + </span><span class="s3">1</span><span class="s1">) : _core.types.nullLiteral();</span>
  <span class="s2">return </span><span class="s1">_core.template.expression.ast`{</span>
    <span class="s1">fileName: ${fileNameIdentifier},</span>
    <span class="s1">lineNumber: ${fileLineLiteral},</span>
    <span class="s1">columnNumber: ${fileColumnLiteral},</span>
  <span class="s1">}`;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">sourceSelfError(path, name) {</span>
  <span class="s1">const pluginName = `transform-react-jsx-${name.slice(</span><span class="s3">2</span><span class="s1">)}`;</span>
  <span class="s2">return </span><span class="s1">path.buildCodeFrameError(`Duplicate ${name} prop found. You are most likely using the deprecated ${pluginName} Babel plugin. Both __source and __self are automatically set when using the automatic runtime. Please remove transform-react-jsx-source and transform-react-jsx-self from your Babel config.`);</span>
<span class="s1">}</span>

<span class="s4">//# sourceMappingURL=create-plugin.js.map</span>
</pre>
</body>
</html>
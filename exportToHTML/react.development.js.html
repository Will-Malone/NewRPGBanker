<html>
<head>
<title>react.development.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #4646f1;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
react.development.js</font>
</center></td></tr></table>
<pre><span class="s0">/** 
 * @license React 
 * react.development.js 
 * 
 * Copyright (c) Facebook, Inc. and its affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>
<span class="s1">(</span><span class="s2">function </span><span class="s1">(global, factory) {</span>
  <span class="s2">typeof </span><span class="s1">exports === </span><span class="s3">'object' </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">module !== </span><span class="s3">'undefined' </span><span class="s1">? factory(exports) :</span>
  <span class="s2">typeof </span><span class="s1">define === </span><span class="s3">'function' </span><span class="s1">&amp;&amp; define.amd ? define([</span><span class="s3">'exports'</span><span class="s1">], factory) :</span>
  <span class="s1">(global = global || self, factory(global.React = {}));</span>
<span class="s1">}(</span><span class="s2">this</span><span class="s1">, (</span><span class="s2">function </span><span class="s1">(exports) { </span><span class="s3">'use strict'</span><span class="s1">;</span>

  <span class="s2">var </span><span class="s1">ReactVersion = </span><span class="s3">'18.2.0'</span><span class="s1">;</span>

  <span class="s0">// ATTENTION</span>
  <span class="s0">// When adding new symbols to this file,</span>
  <span class="s0">// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'</span>
  <span class="s0">// The Symbol used to tag the ReactElement-like types.</span>
  <span class="s2">var </span><span class="s1">REACT_ELEMENT_TYPE = Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.element'</span><span class="s1">);</span>
  <span class="s2">var </span><span class="s1">REACT_PORTAL_TYPE = Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.portal'</span><span class="s1">);</span>
  <span class="s2">var </span><span class="s1">REACT_FRAGMENT_TYPE = Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.fragment'</span><span class="s1">);</span>
  <span class="s2">var </span><span class="s1">REACT_STRICT_MODE_TYPE = Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.strict_mode'</span><span class="s1">);</span>
  <span class="s2">var </span><span class="s1">REACT_PROFILER_TYPE = Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.profiler'</span><span class="s1">);</span>
  <span class="s2">var </span><span class="s1">REACT_PROVIDER_TYPE = Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.provider'</span><span class="s1">);</span>
  <span class="s2">var </span><span class="s1">REACT_CONTEXT_TYPE = Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.context'</span><span class="s1">);</span>
  <span class="s2">var </span><span class="s1">REACT_FORWARD_REF_TYPE = Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.forward_ref'</span><span class="s1">);</span>
  <span class="s2">var </span><span class="s1">REACT_SUSPENSE_TYPE = Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.suspense'</span><span class="s1">);</span>
  <span class="s2">var </span><span class="s1">REACT_SUSPENSE_LIST_TYPE = Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.suspense_list'</span><span class="s1">);</span>
  <span class="s2">var </span><span class="s1">REACT_MEMO_TYPE = Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.memo'</span><span class="s1">);</span>
  <span class="s2">var </span><span class="s1">REACT_LAZY_TYPE = Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.lazy'</span><span class="s1">);</span>
  <span class="s2">var </span><span class="s1">REACT_OFFSCREEN_TYPE = Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.offscreen'</span><span class="s1">);</span>
  <span class="s2">var </span><span class="s1">MAYBE_ITERATOR_SYMBOL = Symbol.iterator;</span>
  <span class="s2">var </span><span class="s1">FAUX_ITERATOR_SYMBOL = </span><span class="s3">'@@iterator'</span><span class="s1">;</span>
  <span class="s2">function </span><span class="s1">getIteratorFn(maybeIterable) {</span>
    <span class="s2">if </span><span class="s1">(maybeIterable === </span><span class="s2">null </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">maybeIterable !== </span><span class="s3">'object'</span><span class="s1">) {</span>
      <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">maybeIterator = MAYBE_ITERATOR_SYMBOL &amp;&amp; maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];</span>

    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">maybeIterator === </span><span class="s3">'function'</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">maybeIterator;</span>
    <span class="s1">}</span>

    <span class="s2">return null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Keeps track of the current dispatcher. 
   */</span>
  <span class="s2">var </span><span class="s1">ReactCurrentDispatcher = {</span>
    <span class="s0">/** 
     * @internal 
     * @type {ReactComponent} 
     */</span>
    <span class="s1">current: </span><span class="s2">null</span>
  <span class="s1">};</span>

  <span class="s0">/** 
   * Keeps track of the current batch's configuration such as how long an update 
   * should suspend for if it needs to. 
   */</span>
  <span class="s2">var </span><span class="s1">ReactCurrentBatchConfig = {</span>
    <span class="s1">transition: </span><span class="s2">null</span>
  <span class="s1">};</span>

  <span class="s2">var </span><span class="s1">ReactCurrentActQueue = {</span>
    <span class="s1">current: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s0">// Used to reproduce behavior of `batchedUpdates` in legacy mode.</span>
    <span class="s1">isBatchingLegacy: </span><span class="s2">false</span><span class="s1">,</span>
    <span class="s1">didScheduleLegacyUpdate: </span><span class="s2">false</span>
  <span class="s1">};</span>

  <span class="s0">/** 
   * Keeps track of the current owner. 
   * 
   * The current owner is the component who should own any components that are 
   * currently being constructed. 
   */</span>
  <span class="s2">var </span><span class="s1">ReactCurrentOwner = {</span>
    <span class="s0">/** 
     * @internal 
     * @type {ReactComponent} 
     */</span>
    <span class="s1">current: </span><span class="s2">null</span>
  <span class="s1">};</span>

  <span class="s2">var </span><span class="s1">ReactDebugCurrentFrame = {};</span>
  <span class="s2">var </span><span class="s1">currentExtraStackFrame = </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s2">function </span><span class="s1">setExtraStackFrame(stack) {</span>
    <span class="s1">{</span>
      <span class="s1">currentExtraStackFrame = stack;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">{</span>
    <span class="s1">ReactDebugCurrentFrame.setExtraStackFrame = </span><span class="s2">function </span><span class="s1">(stack) {</span>
      <span class="s1">{</span>
        <span class="s1">currentExtraStackFrame = stack;</span>
      <span class="s1">}</span>
    <span class="s1">}; </span><span class="s0">// Stack implementation injected by the current renderer.</span>


    <span class="s1">ReactDebugCurrentFrame.getCurrentStack = </span><span class="s2">null</span><span class="s1">;</span>

    <span class="s1">ReactDebugCurrentFrame.getStackAddendum = </span><span class="s2">function </span><span class="s1">() {</span>
      <span class="s2">var </span><span class="s1">stack = </span><span class="s3">''</span><span class="s1">; </span><span class="s0">// Add an extra top frame while an element is being validated</span>

      <span class="s2">if </span><span class="s1">(currentExtraStackFrame) {</span>
        <span class="s1">stack += currentExtraStackFrame;</span>
      <span class="s1">} </span><span class="s0">// Delegate to the injected renderer-specific implementation</span>


      <span class="s2">var </span><span class="s1">impl = ReactDebugCurrentFrame.getCurrentStack;</span>

      <span class="s2">if </span><span class="s1">(impl) {</span>
        <span class="s1">stack += impl() || </span><span class="s3">''</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">return </span><span class="s1">stack;</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s0">// -----------------------------------------------------------------------------</span>

  <span class="s2">var </span><span class="s1">enableScopeAPI = </span><span class="s2">false</span><span class="s1">; </span><span class="s0">// Experimental Create Event Handle API.</span>
  <span class="s2">var </span><span class="s1">enableCacheElement = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">enableTransitionTracing = </span><span class="s2">false</span><span class="s1">; </span><span class="s0">// No known bugs, but needs performance testing</span>

  <span class="s2">var </span><span class="s1">enableLegacyHidden = </span><span class="s2">false</span><span class="s1">; </span><span class="s0">// Enables unstable_avoidThisFallback feature in Fiber</span>
  <span class="s0">// stuff. Intended to enable React core members to more easily debug scheduling</span>
  <span class="s0">// issues in DEV builds.</span>

  <span class="s2">var </span><span class="s1">enableDebugTracing = </span><span class="s2">false</span><span class="s1">; </span><span class="s0">// Track which Fiber(s) schedule render work.</span>

  <span class="s2">var </span><span class="s1">ReactSharedInternals = {</span>
    <span class="s1">ReactCurrentDispatcher: ReactCurrentDispatcher,</span>
    <span class="s1">ReactCurrentBatchConfig: ReactCurrentBatchConfig,</span>
    <span class="s1">ReactCurrentOwner: ReactCurrentOwner</span>
  <span class="s1">};</span>

  <span class="s1">{</span>
    <span class="s1">ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;</span>
    <span class="s1">ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;</span>
  <span class="s1">}</span>

  <span class="s0">// by calls to these methods by a Babel plugin.</span>
  <span class="s0">//</span>
  <span class="s0">// In PROD (or in packages without access to React internals),</span>
  <span class="s0">// they are left as they are instead.</span>

  <span class="s2">function </span><span class="s1">warn(format) {</span>
    <span class="s1">{</span>
      <span class="s1">{</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">_len = arguments.length, args = </span><span class="s2">new </span><span class="s1">Array(_len &gt; </span><span class="s4">1 </span><span class="s1">? _len - </span><span class="s4">1 </span><span class="s1">: </span><span class="s4">0</span><span class="s1">), _key = </span><span class="s4">1</span><span class="s1">; _key &lt; _len; _key++) {</span>
          <span class="s1">args[_key - </span><span class="s4">1</span><span class="s1">] = arguments[_key];</span>
        <span class="s1">}</span>

        <span class="s1">printWarning(</span><span class="s3">'warn'</span><span class="s1">, format, args);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">error(format) {</span>
    <span class="s1">{</span>
      <span class="s1">{</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">_len2 = arguments.length, args = </span><span class="s2">new </span><span class="s1">Array(_len2 &gt; </span><span class="s4">1 </span><span class="s1">? _len2 - </span><span class="s4">1 </span><span class="s1">: </span><span class="s4">0</span><span class="s1">), _key2 = </span><span class="s4">1</span><span class="s1">; _key2 &lt; _len2; _key2++) {</span>
          <span class="s1">args[_key2 - </span><span class="s4">1</span><span class="s1">] = arguments[_key2];</span>
        <span class="s1">}</span>

        <span class="s1">printWarning(</span><span class="s3">'error'</span><span class="s1">, format, args);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">printWarning(level, format, args) {</span>
    <span class="s0">// When changing this logic, you might want to also</span>
    <span class="s0">// update consoleWithStackDev.www.js as well.</span>
    <span class="s1">{</span>
      <span class="s2">var </span><span class="s1">ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;</span>
      <span class="s2">var </span><span class="s1">stack = ReactDebugCurrentFrame.getStackAddendum();</span>

      <span class="s2">if </span><span class="s1">(stack !== </span><span class="s3">''</span><span class="s1">) {</span>
        <span class="s1">format += </span><span class="s3">'%s'</span><span class="s1">;</span>
        <span class="s1">args = args.concat([stack]);</span>
      <span class="s1">} </span><span class="s0">// eslint-disable-next-line react-internal/safe-string-coercion</span>


      <span class="s2">var </span><span class="s1">argsWithFormat = args.map(</span><span class="s2">function </span><span class="s1">(item) {</span>
        <span class="s2">return </span><span class="s1">String(item);</span>
      <span class="s1">}); </span><span class="s0">// Careful: RN currently depends on this prefix</span>

      <span class="s1">argsWithFormat.unshift(</span><span class="s3">'Warning: ' </span><span class="s1">+ format); </span><span class="s0">// We intentionally don't use spread (or .apply) directly because it</span>
      <span class="s0">// breaks IE9: https://github.com/facebook/react/issues/13610</span>
      <span class="s0">// eslint-disable-next-line react-internal/no-production-logging</span>

      <span class="s1">Function.prototype.apply.call(console[level], console, argsWithFormat);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">didWarnStateUpdateForUnmountedComponent = {};</span>

  <span class="s2">function </span><span class="s1">warnNoop(publicInstance, callerName) {</span>
    <span class="s1">{</span>
      <span class="s2">var </span><span class="s1">_constructor = publicInstance.constructor;</span>
      <span class="s2">var </span><span class="s1">componentName = _constructor &amp;&amp; (_constructor.displayName || _constructor.name) || </span><span class="s3">'ReactClass'</span><span class="s1">;</span>
      <span class="s2">var </span><span class="s1">warningKey = componentName + </span><span class="s3">&quot;.&quot; </span><span class="s1">+ callerName;</span>

      <span class="s2">if </span><span class="s1">(didWarnStateUpdateForUnmountedComponent[warningKey]) {</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">error(</span><span class="s3">&quot;Can't call %s on a component that is not yet mounted. &quot; </span><span class="s1">+ </span><span class="s3">'This is a no-op, but it might indicate a bug in your application. ' </span><span class="s1">+ </span><span class="s3">'Instead, assign to `this.state` directly or define a `state = {};` ' </span><span class="s1">+ </span><span class="s3">'class property with the desired state in the %s component.'</span><span class="s1">, callerName, componentName);</span>

      <span class="s1">didWarnStateUpdateForUnmountedComponent[warningKey] = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * This is the abstract API for an update queue. 
   */</span>


  <span class="s2">var </span><span class="s1">ReactNoopUpdateQueue = {</span>
    <span class="s0">/** 
     * Checks whether or not this composite component is mounted. 
     * @param {ReactClass} publicInstance The instance we want to test. 
     * @return {boolean} True if mounted, false otherwise. 
     * @protected 
     * @final 
     */</span>
    <span class="s1">isMounted: </span><span class="s2">function </span><span class="s1">(publicInstance) {</span>
      <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">},</span>

    <span class="s0">/** 
     * Forces an update. This should only be invoked when it is known with 
     * certainty that we are **not** in a DOM transaction. 
     * 
     * You may want to call this when you know that some deeper aspect of the 
     * component's state has changed but `setState` was not called. 
     * 
     * This will not invoke `shouldComponentUpdate`, but it will invoke 
     * `componentWillUpdate` and `componentDidUpdate`. 
     * 
     * @param {ReactClass} publicInstance The instance that should rerender. 
     * @param {?function} callback Called after component is updated. 
     * @param {?string} callerName name of the calling function in the public API. 
     * @internal 
     */</span>
    <span class="s1">enqueueForceUpdate: </span><span class="s2">function </span><span class="s1">(publicInstance, callback, callerName) {</span>
      <span class="s1">warnNoop(publicInstance, </span><span class="s3">'forceUpdate'</span><span class="s1">);</span>
    <span class="s1">},</span>

    <span class="s0">/** 
     * Replaces all of the state. Always use this or `setState` to mutate state. 
     * You should treat `this.state` as immutable. 
     * 
     * There is no guarantee that `this.state` will be immediately updated, so 
     * accessing `this.state` after calling this method may return the old value. 
     * 
     * @param {ReactClass} publicInstance The instance that should rerender. 
     * @param {object} completeState Next state. 
     * @param {?function} callback Called after component is updated. 
     * @param {?string} callerName name of the calling function in the public API. 
     * @internal 
     */</span>
    <span class="s1">enqueueReplaceState: </span><span class="s2">function </span><span class="s1">(publicInstance, completeState, callback, callerName) {</span>
      <span class="s1">warnNoop(publicInstance, </span><span class="s3">'replaceState'</span><span class="s1">);</span>
    <span class="s1">},</span>

    <span class="s0">/** 
     * Sets a subset of the state. This only exists because _pendingState is 
     * internal. This provides a merging strategy that is not available to deep 
     * properties which is confusing. TODO: Expose pendingState or don't use it 
     * during the merge. 
     * 
     * @param {ReactClass} publicInstance The instance that should rerender. 
     * @param {object} partialState Next partial state to be merged with state. 
     * @param {?function} callback Called after component is updated. 
     * @param {?string} Name of the calling function in the public API. 
     * @internal 
     */</span>
    <span class="s1">enqueueSetState: </span><span class="s2">function </span><span class="s1">(publicInstance, partialState, callback, callerName) {</span>
      <span class="s1">warnNoop(publicInstance, </span><span class="s3">'setState'</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s2">var </span><span class="s1">assign = Object.assign;</span>

  <span class="s2">var </span><span class="s1">emptyObject = {};</span>

  <span class="s1">{</span>
    <span class="s1">Object.freeze(emptyObject);</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Base class helpers for the updating state of a component. 
   */</span>


  <span class="s2">function </span><span class="s1">Component(props, context, updater) {</span>
    <span class="s2">this</span><span class="s1">.props = props;</span>
    <span class="s2">this</span><span class="s1">.context = context; </span><span class="s0">// If a component has string refs, we will assign a different object later.</span>

    <span class="s2">this</span><span class="s1">.refs = emptyObject; </span><span class="s0">// We initialize the default updater but the real one gets injected by the</span>
    <span class="s0">// renderer.</span>

    <span class="s2">this</span><span class="s1">.updater = updater || ReactNoopUpdateQueue;</span>
  <span class="s1">}</span>

  <span class="s1">Component.prototype.isReactComponent = {};</span>
  <span class="s0">/** 
   * Sets a subset of the state. Always use this to mutate 
   * state. You should treat `this.state` as immutable. 
   * 
   * There is no guarantee that `this.state` will be immediately updated, so 
   * accessing `this.state` after calling this method may return the old value. 
   * 
   * There is no guarantee that calls to `setState` will run synchronously, 
   * as they may eventually be batched together.  You can provide an optional 
   * callback that will be executed when the call to setState is actually 
   * completed. 
   * 
   * When a function is provided to setState, it will be called at some point in 
   * the future (not synchronously). It will be called with the up to date 
   * component arguments (state, props, context). These values can be different 
   * from this.* because your function may be called after receiveProps but before 
   * shouldComponentUpdate, and this new state, props, and context will not yet be 
   * assigned to this. 
   * 
   * @param {object|function} partialState Next partial state or function to 
   *        produce next partial state to be merged with current state. 
   * @param {?function} callback Called after state is updated. 
   * @final 
   * @protected 
   */</span>

  <span class="s1">Component.prototype.setState = </span><span class="s2">function </span><span class="s1">(partialState, callback) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">partialState !== </span><span class="s3">'object' </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">partialState !== </span><span class="s3">'function' </span><span class="s1">&amp;&amp; partialState != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'setState(...): takes an object of state variables to update or a ' </span><span class="s1">+ </span><span class="s3">'function which returns an object of state variables.'</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s2">this</span><span class="s1">.updater.enqueueSetState(</span><span class="s2">this</span><span class="s1">, partialState, callback, </span><span class="s3">'setState'</span><span class="s1">);</span>
  <span class="s1">};</span>
  <span class="s0">/** 
   * Forces an update. This should only be invoked when it is known with 
   * certainty that we are **not** in a DOM transaction. 
   * 
   * You may want to call this when you know that some deeper aspect of the 
   * component's state has changed but `setState` was not called. 
   * 
   * This will not invoke `shouldComponentUpdate`, but it will invoke 
   * `componentWillUpdate` and `componentDidUpdate`. 
   * 
   * @param {?function} callback Called after update is complete. 
   * @final 
   * @protected 
   */</span>


  <span class="s1">Component.prototype.forceUpdate = </span><span class="s2">function </span><span class="s1">(callback) {</span>
    <span class="s2">this</span><span class="s1">.updater.enqueueForceUpdate(</span><span class="s2">this</span><span class="s1">, callback, </span><span class="s3">'forceUpdate'</span><span class="s1">);</span>
  <span class="s1">};</span>
  <span class="s0">/** 
   * Deprecated APIs. These APIs used to exist on classic React classes but since 
   * we would like to deprecate them, we're not going to move them over to this 
   * modern base class. Instead, we define a getter that warns if it's accessed. 
   */</span>


  <span class="s1">{</span>
    <span class="s2">var </span><span class="s1">deprecatedAPIs = {</span>
      <span class="s1">isMounted: [</span><span class="s3">'isMounted'</span><span class="s1">, </span><span class="s3">'Instead, make sure to clean up subscriptions and pending requests in ' </span><span class="s1">+ </span><span class="s3">'componentWillUnmount to prevent memory leaks.'</span><span class="s1">],</span>
      <span class="s1">replaceState: [</span><span class="s3">'replaceState'</span><span class="s1">, </span><span class="s3">'Refactor your code to use setState instead (see ' </span><span class="s1">+ </span><span class="s3">'https://github.com/facebook/react/issues/3236).'</span><span class="s1">]</span>
    <span class="s1">};</span>

    <span class="s2">var </span><span class="s1">defineDeprecationWarning = </span><span class="s2">function </span><span class="s1">(methodName, info) {</span>
      <span class="s1">Object.defineProperty(Component.prototype, methodName, {</span>
        <span class="s1">get: </span><span class="s2">function </span><span class="s1">() {</span>
          <span class="s1">warn(</span><span class="s3">'%s(...) is deprecated in plain JavaScript React classes. %s'</span><span class="s1">, info[</span><span class="s4">0</span><span class="s1">], info[</span><span class="s4">1</span><span class="s1">]);</span>

          <span class="s2">return </span><span class="s1">undefined;</span>
        <span class="s1">}</span>
      <span class="s1">});</span>
    <span class="s1">};</span>

    <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">fnName </span><span class="s2">in </span><span class="s1">deprecatedAPIs) {</span>
      <span class="s2">if </span><span class="s1">(deprecatedAPIs.hasOwnProperty(fnName)) {</span>
        <span class="s1">defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">ComponentDummy() {}</span>

  <span class="s1">ComponentDummy.prototype = Component.prototype;</span>
  <span class="s0">/** 
   * Convenience component with default shallow equality check for sCU. 
   */</span>

  <span class="s2">function </span><span class="s1">PureComponent(props, context, updater) {</span>
    <span class="s2">this</span><span class="s1">.props = props;</span>
    <span class="s2">this</span><span class="s1">.context = context; </span><span class="s0">// If a component has string refs, we will assign a different object later.</span>

    <span class="s2">this</span><span class="s1">.refs = emptyObject;</span>
    <span class="s2">this</span><span class="s1">.updater = updater || ReactNoopUpdateQueue;</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">pureComponentPrototype = PureComponent.prototype = </span><span class="s2">new </span><span class="s1">ComponentDummy();</span>
  <span class="s1">pureComponentPrototype.constructor = PureComponent; </span><span class="s0">// Avoid an extra prototype jump for these methods.</span>

  <span class="s1">assign(pureComponentPrototype, Component.prototype);</span>
  <span class="s1">pureComponentPrototype.isPureReactComponent = </span><span class="s2">true</span><span class="s1">;</span>

  <span class="s0">// an immutable object with a single mutable value</span>
  <span class="s2">function </span><span class="s1">createRef() {</span>
    <span class="s2">var </span><span class="s1">refObject = {</span>
      <span class="s1">current: </span><span class="s2">null</span>
    <span class="s1">};</span>

    <span class="s1">{</span>
      <span class="s1">Object.seal(refObject);</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">refObject;</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">isArrayImpl = Array.isArray; </span><span class="s0">// eslint-disable-next-line no-redeclare</span>

  <span class="s2">function </span><span class="s1">isArray(a) {</span>
    <span class="s2">return </span><span class="s1">isArrayImpl(a);</span>
  <span class="s1">}</span>

  <span class="s0">/* 
   * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol 
   * and Temporal.* types. See https://github.com/facebook/react/pull/22064. 
   * 
   * The functions in this module will throw an easier-to-understand, 
   * easier-to-debug exception with a clear errors message message explaining the 
   * problem. (Instead of a confusing exception thrown inside the implementation 
   * of the `value` object). 
   */</span>
  <span class="s0">// $FlowFixMe only called in DEV, so void return is not possible.</span>
  <span class="s2">function </span><span class="s1">typeName(value) {</span>
    <span class="s1">{</span>
      <span class="s0">// toStringTag is needed for namespaced types like Temporal.Instant</span>
      <span class="s2">var </span><span class="s1">hasToStringTag = </span><span class="s2">typeof </span><span class="s1">Symbol === </span><span class="s3">'function' </span><span class="s1">&amp;&amp; Symbol.toStringTag;</span>
      <span class="s2">var </span><span class="s1">type = hasToStringTag &amp;&amp; value[Symbol.toStringTag] || value.constructor.name || </span><span class="s3">'Object'</span><span class="s1">;</span>
      <span class="s2">return </span><span class="s1">type;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s0">// $FlowFixMe only called in DEV, so void return is not possible.</span>


  <span class="s2">function </span><span class="s1">willCoercionThrow(value) {</span>
    <span class="s1">{</span>
      <span class="s2">try </span><span class="s1">{</span>
        <span class="s1">testStringCoercion(value);</span>
        <span class="s2">return false</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s2">catch </span><span class="s1">(e) {</span>
        <span class="s2">return true</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">testStringCoercion(value) {</span>
    <span class="s0">// If you ended up here by following an exception call stack, here's what's</span>
    <span class="s0">// happened: you supplied an object or symbol value to React (as a prop, key,</span>
    <span class="s0">// DOM attribute, CSS property, string ref, etc.) and when React tried to</span>
    <span class="s0">// coerce it to a string using `'' + value`, an exception was thrown.</span>
    <span class="s0">//</span>
    <span class="s0">// The most common types that will cause this exception are `Symbol` instances</span>
    <span class="s0">// and Temporal objects like `Temporal.Instant`. But any object that has a</span>
    <span class="s0">// `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this</span>
    <span class="s0">// exception. (Library authors do this to prevent users from using built-in</span>
    <span class="s0">// numeric operators like `+` or comparison operators like `&gt;=` because custom</span>
    <span class="s0">// methods are needed to perform accurate arithmetic or comparison.)</span>
    <span class="s0">//</span>
    <span class="s0">// To fix the problem, coerce this object or symbol value to a string before</span>
    <span class="s0">// passing it to React. The most reliable way is usually `String(value)`.</span>
    <span class="s0">//</span>
    <span class="s0">// To find which value is throwing, check the browser or debugger console.</span>
    <span class="s0">// Before this exception was thrown, there should be `console.error` output</span>
    <span class="s0">// that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the</span>
    <span class="s0">// problem and how that type was used: key, atrribute, input value prop, etc.</span>
    <span class="s0">// In most cases, this console output also shows the component and its</span>
    <span class="s0">// ancestor components where the exception happened.</span>
    <span class="s0">//</span>
    <span class="s0">// eslint-disable-next-line react-internal/safe-string-coercion</span>
    <span class="s2">return </span><span class="s3">'' </span><span class="s1">+ value;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">checkKeyStringCoercion(value) {</span>
    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(willCoercionThrow(value)) {</span>
        <span class="s1">error(</span><span class="s3">'The provided key is an unsupported type %s.' </span><span class="s1">+ </span><span class="s3">' This value must be coerced to a string before before using it here.'</span><span class="s1">, typeName(value));</span>

        <span class="s2">return </span><span class="s1">testStringCoercion(value); </span><span class="s0">// throw (to help callers find troubleshooting comments)</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">getWrappedName(outerType, innerType, wrapperName) {</span>
    <span class="s2">var </span><span class="s1">displayName = outerType.displayName;</span>

    <span class="s2">if </span><span class="s1">(displayName) {</span>
      <span class="s2">return </span><span class="s1">displayName;</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">functionName = innerType.displayName || innerType.name || </span><span class="s3">''</span><span class="s1">;</span>
    <span class="s2">return </span><span class="s1">functionName !== </span><span class="s3">'' </span><span class="s1">? wrapperName + </span><span class="s3">&quot;(&quot; </span><span class="s1">+ functionName + </span><span class="s3">&quot;)&quot; </span><span class="s1">: wrapperName;</span>
  <span class="s1">} </span><span class="s0">// Keep in sync with react-reconciler/getComponentNameFromFiber</span>


  <span class="s2">function </span><span class="s1">getContextName(type) {</span>
    <span class="s2">return </span><span class="s1">type.displayName || </span><span class="s3">'Context'</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s0">// Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.</span>


  <span class="s2">function </span><span class="s1">getComponentNameFromType(type) {</span>
    <span class="s2">if </span><span class="s1">(type == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s0">// Host root, text node or just invalid type.</span>
      <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">type.tag === </span><span class="s3">'number'</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s3">'Received an unexpected object in getComponentNameFromType(). ' </span><span class="s1">+ </span><span class="s3">'This is likely a bug in React. Please file an issue.'</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">type === </span><span class="s3">'function'</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">type.displayName || type.name || </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">type === </span><span class="s3">'string'</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">type;</span>
    <span class="s1">}</span>

    <span class="s2">switch </span><span class="s1">(type) {</span>
      <span class="s2">case </span><span class="s1">REACT_FRAGMENT_TYPE:</span>
        <span class="s2">return </span><span class="s3">'Fragment'</span><span class="s1">;</span>

      <span class="s2">case </span><span class="s1">REACT_PORTAL_TYPE:</span>
        <span class="s2">return </span><span class="s3">'Portal'</span><span class="s1">;</span>

      <span class="s2">case </span><span class="s1">REACT_PROFILER_TYPE:</span>
        <span class="s2">return </span><span class="s3">'Profiler'</span><span class="s1">;</span>

      <span class="s2">case </span><span class="s1">REACT_STRICT_MODE_TYPE:</span>
        <span class="s2">return </span><span class="s3">'StrictMode'</span><span class="s1">;</span>

      <span class="s2">case </span><span class="s1">REACT_SUSPENSE_TYPE:</span>
        <span class="s2">return </span><span class="s3">'Suspense'</span><span class="s1">;</span>

      <span class="s2">case </span><span class="s1">REACT_SUSPENSE_LIST_TYPE:</span>
        <span class="s2">return </span><span class="s3">'SuspenseList'</span><span class="s1">;</span>

    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">type === </span><span class="s3">'object'</span><span class="s1">) {</span>
      <span class="s2">switch </span><span class="s1">(type.$$typeof) {</span>
        <span class="s2">case </span><span class="s1">REACT_CONTEXT_TYPE:</span>
          <span class="s2">var </span><span class="s1">context = type;</span>
          <span class="s2">return </span><span class="s1">getContextName(context) + </span><span class="s3">'.Consumer'</span><span class="s1">;</span>

        <span class="s2">case </span><span class="s1">REACT_PROVIDER_TYPE:</span>
          <span class="s2">var </span><span class="s1">provider = type;</span>
          <span class="s2">return </span><span class="s1">getContextName(provider._context) + </span><span class="s3">'.Provider'</span><span class="s1">;</span>

        <span class="s2">case </span><span class="s1">REACT_FORWARD_REF_TYPE:</span>
          <span class="s2">return </span><span class="s1">getWrappedName(type, type.render, </span><span class="s3">'ForwardRef'</span><span class="s1">);</span>

        <span class="s2">case </span><span class="s1">REACT_MEMO_TYPE:</span>
          <span class="s2">var </span><span class="s1">outerName = type.displayName || </span><span class="s2">null</span><span class="s1">;</span>

          <span class="s2">if </span><span class="s1">(outerName !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">outerName;</span>
          <span class="s1">}</span>

          <span class="s2">return </span><span class="s1">getComponentNameFromType(type.type) || </span><span class="s3">'Memo'</span><span class="s1">;</span>

        <span class="s2">case </span><span class="s1">REACT_LAZY_TYPE:</span>
          <span class="s1">{</span>
            <span class="s2">var </span><span class="s1">lazyComponent = type;</span>
            <span class="s2">var </span><span class="s1">payload = lazyComponent._payload;</span>
            <span class="s2">var </span><span class="s1">init = lazyComponent._init;</span>

            <span class="s2">try </span><span class="s1">{</span>
              <span class="s2">return </span><span class="s1">getComponentNameFromType(init(payload));</span>
            <span class="s1">} </span><span class="s2">catch </span><span class="s1">(x) {</span>
              <span class="s2">return null</span><span class="s1">;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

        <span class="s0">// eslint-disable-next-line no-fallthrough</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">hasOwnProperty = Object.prototype.hasOwnProperty;</span>

  <span class="s2">var </span><span class="s1">RESERVED_PROPS = {</span>
    <span class="s1">key: </span><span class="s2">true</span><span class="s1">,</span>
    <span class="s1">ref: </span><span class="s2">true</span><span class="s1">,</span>
    <span class="s1">__self: </span><span class="s2">true</span><span class="s1">,</span>
    <span class="s1">__source: </span><span class="s2">true</span>
  <span class="s1">};</span>
  <span class="s2">var </span><span class="s1">specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;</span>

  <span class="s1">{</span>
    <span class="s1">didWarnAboutStringRefs = {};</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">hasValidRef(config) {</span>
    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(hasOwnProperty.call(config, </span><span class="s3">'ref'</span><span class="s1">)) {</span>
        <span class="s2">var </span><span class="s1">getter = Object.getOwnPropertyDescriptor(config, </span><span class="s3">'ref'</span><span class="s1">).get;</span>

        <span class="s2">if </span><span class="s1">(getter &amp;&amp; getter.isReactWarning) {</span>
          <span class="s2">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">config.ref !== undefined;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">hasValidKey(config) {</span>
    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(hasOwnProperty.call(config, </span><span class="s3">'key'</span><span class="s1">)) {</span>
        <span class="s2">var </span><span class="s1">getter = Object.getOwnPropertyDescriptor(config, </span><span class="s3">'key'</span><span class="s1">).get;</span>

        <span class="s2">if </span><span class="s1">(getter &amp;&amp; getter.isReactWarning) {</span>
          <span class="s2">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">config.key !== undefined;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">defineKeyPropWarningGetter(props, displayName) {</span>
    <span class="s2">var </span><span class="s1">warnAboutAccessingKey = </span><span class="s2">function </span><span class="s1">() {</span>
      <span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(!specialPropKeyWarningShown) {</span>
          <span class="s1">specialPropKeyWarningShown = </span><span class="s2">true</span><span class="s1">;</span>

          <span class="s1">error(</span><span class="s3">'%s: `key` is not a prop. Trying to access it will result ' </span><span class="s1">+ </span><span class="s3">'in `undefined` being returned. If you need to access the same ' </span><span class="s1">+ </span><span class="s3">'value within the child component, you should pass it as a different ' </span><span class="s1">+ </span><span class="s3">'prop. (https://reactjs.org/link/special-props)'</span><span class="s1">, displayName);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">};</span>

    <span class="s1">warnAboutAccessingKey.isReactWarning = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">Object.defineProperty(props, </span><span class="s3">'key'</span><span class="s1">, {</span>
      <span class="s1">get: warnAboutAccessingKey,</span>
      <span class="s1">configurable: </span><span class="s2">true</span>
    <span class="s1">});</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">defineRefPropWarningGetter(props, displayName) {</span>
    <span class="s2">var </span><span class="s1">warnAboutAccessingRef = </span><span class="s2">function </span><span class="s1">() {</span>
      <span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(!specialPropRefWarningShown) {</span>
          <span class="s1">specialPropRefWarningShown = </span><span class="s2">true</span><span class="s1">;</span>

          <span class="s1">error(</span><span class="s3">'%s: `ref` is not a prop. Trying to access it will result ' </span><span class="s1">+ </span><span class="s3">'in `undefined` being returned. If you need to access the same ' </span><span class="s1">+ </span><span class="s3">'value within the child component, you should pass it as a different ' </span><span class="s1">+ </span><span class="s3">'prop. (https://reactjs.org/link/special-props)'</span><span class="s1">, displayName);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">};</span>

    <span class="s1">warnAboutAccessingRef.isReactWarning = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">Object.defineProperty(props, </span><span class="s3">'ref'</span><span class="s1">, {</span>
      <span class="s1">get: warnAboutAccessingRef,</span>
      <span class="s1">configurable: </span><span class="s2">true</span>
    <span class="s1">});</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">warnIfStringRefCannotBeAutoConverted(config) {</span>
    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">config.ref === </span><span class="s3">'string' </span><span class="s1">&amp;&amp; ReactCurrentOwner.current &amp;&amp; config.__self &amp;&amp; ReactCurrentOwner.current.stateNode !== config.__self) {</span>
        <span class="s2">var </span><span class="s1">componentName = getComponentNameFromType(ReactCurrentOwner.current.type);</span>

        <span class="s2">if </span><span class="s1">(!didWarnAboutStringRefs[componentName]) {</span>
          <span class="s1">error(</span><span class="s3">'Component &quot;%s&quot; contains the string ref &quot;%s&quot;. ' </span><span class="s1">+ </span><span class="s3">'Support for string refs will be removed in a future major release. ' </span><span class="s1">+ </span><span class="s3">'This case cannot be automatically converted to an arrow function. ' </span><span class="s1">+ </span><span class="s3">'We ask you to manually fix this case by using useRef() or createRef() instead. ' </span><span class="s1">+ </span><span class="s3">'Learn more about using refs safely here: ' </span><span class="s1">+ </span><span class="s3">'https://reactjs.org/link/strict-mode-string-ref'</span><span class="s1">, componentName, config.ref);</span>

          <span class="s1">didWarnAboutStringRefs[componentName] = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Factory method to create a new React element. This no longer adheres to 
   * the class pattern, so do not use new to call it. Also, instanceof check 
   * will not work. Instead test $$typeof field against Symbol.for('react.element') to check 
   * if something is a React Element. 
   * 
   * @param {*} type 
   * @param {*} props 
   * @param {*} key 
   * @param {string|object} ref 
   * @param {*} owner 
   * @param {*} self A *temporary* helper to detect places where `this` is 
   * different from the `owner` when React.createElement is called, so that we 
   * can warn. We want to get rid of owner and replace string `ref`s with arrow 
   * functions, and as long as `this` and owner are the same, there will be no 
   * change in behavior. 
   * @param {*} source An annotation object (added by a transpiler or otherwise) 
   * indicating filename, line number, and/or other information. 
   * @internal 
   */</span>


  <span class="s2">var </span><span class="s1">ReactElement = </span><span class="s2">function </span><span class="s1">(type, key, ref, self, source, owner, props) {</span>
    <span class="s2">var </span><span class="s1">element = {</span>
      <span class="s0">// This tag allows us to uniquely identify this as a React Element</span>
      <span class="s1">$$typeof: REACT_ELEMENT_TYPE,</span>
      <span class="s0">// Built-in properties that belong on the element</span>
      <span class="s1">type: type,</span>
      <span class="s1">key: key,</span>
      <span class="s1">ref: ref,</span>
      <span class="s1">props: props,</span>
      <span class="s0">// Record the component responsible for creating this element.</span>
      <span class="s1">_owner: owner</span>
    <span class="s1">};</span>

    <span class="s1">{</span>
      <span class="s0">// The validation flag is currently mutative. We put it on</span>
      <span class="s0">// an external backing store so that we can freeze the whole object.</span>
      <span class="s0">// This can be replaced with a WeakMap once they are implemented in</span>
      <span class="s0">// commonly used development environments.</span>
      <span class="s1">element._store = {}; </span><span class="s0">// To make comparing ReactElements easier for testing purposes, we make</span>
      <span class="s0">// the validation flag non-enumerable (where possible, which should</span>
      <span class="s0">// include every environment we run tests in), so the test framework</span>
      <span class="s0">// ignores it.</span>

      <span class="s1">Object.defineProperty(element._store, </span><span class="s3">'validated'</span><span class="s1">, {</span>
        <span class="s1">configurable: </span><span class="s2">false</span><span class="s1">,</span>
        <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
        <span class="s1">writable: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">value: </span><span class="s2">false</span>
      <span class="s1">}); </span><span class="s0">// self and source are DEV only properties.</span>

      <span class="s1">Object.defineProperty(element, </span><span class="s3">'_self'</span><span class="s1">, {</span>
        <span class="s1">configurable: </span><span class="s2">false</span><span class="s1">,</span>
        <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
        <span class="s1">writable: </span><span class="s2">false</span><span class="s1">,</span>
        <span class="s1">value: self</span>
      <span class="s1">}); </span><span class="s0">// Two elements created in two different places should be considered</span>
      <span class="s0">// equal for testing purposes and therefore we hide it from enumeration.</span>

      <span class="s1">Object.defineProperty(element, </span><span class="s3">'_source'</span><span class="s1">, {</span>
        <span class="s1">configurable: </span><span class="s2">false</span><span class="s1">,</span>
        <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
        <span class="s1">writable: </span><span class="s2">false</span><span class="s1">,</span>
        <span class="s1">value: source</span>
      <span class="s1">});</span>

      <span class="s2">if </span><span class="s1">(Object.freeze) {</span>
        <span class="s1">Object.freeze(element.props);</span>
        <span class="s1">Object.freeze(element);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">element;</span>
  <span class="s1">};</span>
  <span class="s0">/** 
   * Create and return a new ReactElement of the given type. 
   * See https://reactjs.org/docs/react-api.html#createelement 
   */</span>

  <span class="s2">function </span><span class="s1">createElement(type, config, children) {</span>
    <span class="s2">var </span><span class="s1">propName; </span><span class="s0">// Reserved names are extracted</span>

    <span class="s2">var </span><span class="s1">props = {};</span>
    <span class="s2">var </span><span class="s1">key = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">var </span><span class="s1">ref = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">var </span><span class="s1">self = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">var </span><span class="s1">source = </span><span class="s2">null</span><span class="s1">;</span>

    <span class="s2">if </span><span class="s1">(config != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(hasValidRef(config)) {</span>
        <span class="s1">ref = config.ref;</span>

        <span class="s1">{</span>
          <span class="s1">warnIfStringRefCannotBeAutoConverted(config);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(hasValidKey(config)) {</span>
        <span class="s1">{</span>
          <span class="s1">checkKeyStringCoercion(config.key);</span>
        <span class="s1">}</span>

        <span class="s1">key = </span><span class="s3">'' </span><span class="s1">+ config.key;</span>
      <span class="s1">}</span>

      <span class="s1">self = config.__self === undefined ? </span><span class="s2">null </span><span class="s1">: config.__self;</span>
      <span class="s1">source = config.__source === undefined ? </span><span class="s2">null </span><span class="s1">: config.__source; </span><span class="s0">// Remaining properties are added to a new props object</span>

      <span class="s2">for </span><span class="s1">(propName </span><span class="s2">in </span><span class="s1">config) {</span>
        <span class="s2">if </span><span class="s1">(hasOwnProperty.call(config, propName) &amp;&amp; !RESERVED_PROPS.hasOwnProperty(propName)) {</span>
          <span class="s1">props[propName] = config[propName];</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// Children can be more than one argument, and those are transferred onto</span>
    <span class="s0">// the newly allocated props object.</span>


    <span class="s2">var </span><span class="s1">childrenLength = arguments.length - </span><span class="s4">2</span><span class="s1">;</span>

    <span class="s2">if </span><span class="s1">(childrenLength === </span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s1">props.children = children;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(childrenLength &gt; </span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">childArray = Array(childrenLength);</span>

      <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; childrenLength; i++) {</span>
        <span class="s1">childArray[i] = arguments[i + </span><span class="s4">2</span><span class="s1">];</span>
      <span class="s1">}</span>

      <span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(Object.freeze) {</span>
          <span class="s1">Object.freeze(childArray);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">props.children = childArray;</span>
    <span class="s1">} </span><span class="s0">// Resolve default props</span>


    <span class="s2">if </span><span class="s1">(type &amp;&amp; type.defaultProps) {</span>
      <span class="s2">var </span><span class="s1">defaultProps = type.defaultProps;</span>

      <span class="s2">for </span><span class="s1">(propName </span><span class="s2">in </span><span class="s1">defaultProps) {</span>
        <span class="s2">if </span><span class="s1">(props[propName] === undefined) {</span>
          <span class="s1">props[propName] = defaultProps[propName];</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(key || ref) {</span>
        <span class="s2">var </span><span class="s1">displayName = </span><span class="s2">typeof </span><span class="s1">type === </span><span class="s3">'function' </span><span class="s1">? type.displayName || type.name || </span><span class="s3">'Unknown' </span><span class="s1">: type;</span>

        <span class="s2">if </span><span class="s1">(key) {</span>
          <span class="s1">defineKeyPropWarningGetter(props, displayName);</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(ref) {</span>
          <span class="s1">defineRefPropWarningGetter(props, displayName);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">cloneAndReplaceKey(oldElement, newKey) {</span>
    <span class="s2">var </span><span class="s1">newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);</span>
    <span class="s2">return </span><span class="s1">newElement;</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Clone and return a new ReactElement using element as the starting point. 
   * See https://reactjs.org/docs/react-api.html#cloneelement 
   */</span>

  <span class="s2">function </span><span class="s1">cloneElement(element, config, children) {</span>
    <span class="s2">if </span><span class="s1">(element === </span><span class="s2">null </span><span class="s1">|| element === undefined) {</span>
      <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">&quot;React.cloneElement(...): The argument must be a React element, but you passed &quot; </span><span class="s1">+ element + </span><span class="s3">&quot;.&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">propName; </span><span class="s0">// Original props are copied</span>

    <span class="s2">var </span><span class="s1">props = assign({}, element.props); </span><span class="s0">// Reserved names are extracted</span>

    <span class="s2">var </span><span class="s1">key = element.key;</span>
    <span class="s2">var </span><span class="s1">ref = element.ref; </span><span class="s0">// Self is preserved since the owner is preserved.</span>

    <span class="s2">var </span><span class="s1">self = element._self; </span><span class="s0">// Source is preserved since cloneElement is unlikely to be targeted by a</span>
    <span class="s0">// transpiler, and the original source is probably a better indicator of the</span>
    <span class="s0">// true owner.</span>

    <span class="s2">var </span><span class="s1">source = element._source; </span><span class="s0">// Owner will be preserved, unless ref is overridden</span>

    <span class="s2">var </span><span class="s1">owner = element._owner;</span>

    <span class="s2">if </span><span class="s1">(config != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(hasValidRef(config)) {</span>
        <span class="s0">// Silently steal the ref from the parent.</span>
        <span class="s1">ref = config.ref;</span>
        <span class="s1">owner = ReactCurrentOwner.current;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(hasValidKey(config)) {</span>
        <span class="s1">{</span>
          <span class="s1">checkKeyStringCoercion(config.key);</span>
        <span class="s1">}</span>

        <span class="s1">key = </span><span class="s3">'' </span><span class="s1">+ config.key;</span>
      <span class="s1">} </span><span class="s0">// Remaining properties override existing props</span>


      <span class="s2">var </span><span class="s1">defaultProps;</span>

      <span class="s2">if </span><span class="s1">(element.type &amp;&amp; element.type.defaultProps) {</span>
        <span class="s1">defaultProps = element.type.defaultProps;</span>
      <span class="s1">}</span>

      <span class="s2">for </span><span class="s1">(propName </span><span class="s2">in </span><span class="s1">config) {</span>
        <span class="s2">if </span><span class="s1">(hasOwnProperty.call(config, propName) &amp;&amp; !RESERVED_PROPS.hasOwnProperty(propName)) {</span>
          <span class="s2">if </span><span class="s1">(config[propName] === undefined &amp;&amp; defaultProps !== undefined) {</span>
            <span class="s0">// Resolve default props</span>
            <span class="s1">props[propName] = defaultProps[propName];</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">props[propName] = config[propName];</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// Children can be more than one argument, and those are transferred onto</span>
    <span class="s0">// the newly allocated props object.</span>


    <span class="s2">var </span><span class="s1">childrenLength = arguments.length - </span><span class="s4">2</span><span class="s1">;</span>

    <span class="s2">if </span><span class="s1">(childrenLength === </span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s1">props.children = children;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(childrenLength &gt; </span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">childArray = Array(childrenLength);</span>

      <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; childrenLength; i++) {</span>
        <span class="s1">childArray[i] = arguments[i + </span><span class="s4">2</span><span class="s1">];</span>
      <span class="s1">}</span>

      <span class="s1">props.children = childArray;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">ReactElement(element.type, key, ref, self, source, owner, props);</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Verifies the object is a ReactElement. 
   * See https://reactjs.org/docs/react-api.html#isvalidelement 
   * @param {?object} object 
   * @return {boolean} True if `object` is a ReactElement. 
   * @final 
   */</span>

  <span class="s2">function </span><span class="s1">isValidElement(object) {</span>
    <span class="s2">return typeof </span><span class="s1">object === </span><span class="s3">'object' </span><span class="s1">&amp;&amp; object !== </span><span class="s2">null </span><span class="s1">&amp;&amp; object.$$typeof === REACT_ELEMENT_TYPE;</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">SEPARATOR = </span><span class="s3">'.'</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">SUBSEPARATOR = </span><span class="s3">':'</span><span class="s1">;</span>
  <span class="s0">/** 
   * Escape and wrap key so it is safe to use as a reactid 
   * 
   * @param {string} key to be escaped. 
   * @return {string} the escaped key. 
   */</span>

  <span class="s2">function </span><span class="s1">escape(key) {</span>
    <span class="s2">var </span><span class="s1">escapeRegex = /[=:]/g;</span>
    <span class="s2">var </span><span class="s1">escaperLookup = {</span>
      <span class="s3">'='</span><span class="s1">: </span><span class="s3">'=0'</span><span class="s1">,</span>
      <span class="s3">':'</span><span class="s1">: </span><span class="s3">'=2'</span>
    <span class="s1">};</span>
    <span class="s2">var </span><span class="s1">escapedString = key.replace(escapeRegex, </span><span class="s2">function </span><span class="s1">(match) {</span>
      <span class="s2">return </span><span class="s1">escaperLookup[match];</span>
    <span class="s1">});</span>
    <span class="s2">return </span><span class="s3">'$' </span><span class="s1">+ escapedString;</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * TODO: Test that a single child and an array with one item have the same key 
   * pattern. 
   */</span>


  <span class="s2">var </span><span class="s1">didWarnAboutMaps = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">userProvidedKeyEscapeRegex = /\/+/g;</span>

  <span class="s2">function </span><span class="s1">escapeUserProvidedKey(text) {</span>
    <span class="s2">return </span><span class="s1">text.replace(userProvidedKeyEscapeRegex, </span><span class="s3">'$&amp;/'</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Generate a key string that identifies a element within a set. 
   * 
   * @param {*} element A element that could contain a manual key. 
   * @param {number} index Index that is used if a manual key is not provided. 
   * @return {string} 
   */</span>


  <span class="s2">function </span><span class="s1">getElementKey(element, index) {</span>
    <span class="s0">// Do some typechecking here since we call this blindly. We want to ensure</span>
    <span class="s0">// that we don't block potential future ES APIs.</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">element === </span><span class="s3">'object' </span><span class="s1">&amp;&amp; element !== </span><span class="s2">null </span><span class="s1">&amp;&amp; element.key != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s0">// Explicit key</span>
      <span class="s1">{</span>
        <span class="s1">checkKeyStringCoercion(element.key);</span>
      <span class="s1">}</span>

      <span class="s2">return </span><span class="s1">escape(</span><span class="s3">'' </span><span class="s1">+ element.key);</span>
    <span class="s1">} </span><span class="s0">// Implicit key determined by the index in the set</span>


    <span class="s2">return </span><span class="s1">index.toString(</span><span class="s4">36</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {</span>
    <span class="s2">var </span><span class="s1">type = </span><span class="s2">typeof </span><span class="s1">children;</span>

    <span class="s2">if </span><span class="s1">(type === </span><span class="s3">'undefined' </span><span class="s1">|| type === </span><span class="s3">'boolean'</span><span class="s1">) {</span>
      <span class="s0">// All of the above are perceived as null.</span>
      <span class="s1">children = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">invokeCallback = </span><span class="s2">false</span><span class="s1">;</span>

    <span class="s2">if </span><span class="s1">(children === </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">invokeCallback = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">switch </span><span class="s1">(type) {</span>
        <span class="s2">case </span><span class="s3">'string'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s3">'number'</span><span class="s1">:</span>
          <span class="s1">invokeCallback = </span><span class="s2">true</span><span class="s1">;</span>
          <span class="s2">break</span><span class="s1">;</span>

        <span class="s2">case </span><span class="s3">'object'</span><span class="s1">:</span>
          <span class="s2">switch </span><span class="s1">(children.$$typeof) {</span>
            <span class="s2">case </span><span class="s1">REACT_ELEMENT_TYPE:</span>
            <span class="s2">case </span><span class="s1">REACT_PORTAL_TYPE:</span>
              <span class="s1">invokeCallback = </span><span class="s2">true</span><span class="s1">;</span>
          <span class="s1">}</span>

      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(invokeCallback) {</span>
      <span class="s2">var </span><span class="s1">_child = children;</span>
      <span class="s2">var </span><span class="s1">mappedChild = callback(_child); </span><span class="s0">// If it's the only child, treat the name as if it was wrapped in an array</span>
      <span class="s0">// so that it's consistent if the number of children grows:</span>

      <span class="s2">var </span><span class="s1">childKey = nameSoFar === </span><span class="s3">'' </span><span class="s1">? SEPARATOR + getElementKey(_child, </span><span class="s4">0</span><span class="s1">) : nameSoFar;</span>

      <span class="s2">if </span><span class="s1">(isArray(mappedChild)) {</span>
        <span class="s2">var </span><span class="s1">escapedChildKey = </span><span class="s3">''</span><span class="s1">;</span>

        <span class="s2">if </span><span class="s1">(childKey != </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">escapedChildKey = escapeUserProvidedKey(childKey) + </span><span class="s3">'/'</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">mapIntoArray(mappedChild, array, escapedChildKey, </span><span class="s3">''</span><span class="s1">, </span><span class="s2">function </span><span class="s1">(c) {</span>
          <span class="s2">return </span><span class="s1">c;</span>
        <span class="s1">});</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(mappedChild != </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(isValidElement(mappedChild)) {</span>
          <span class="s1">{</span>
            <span class="s0">// The `if` statement here prevents auto-disabling of the safe</span>
            <span class="s0">// coercion ESLint rule, so we must manually disable it below.</span>
            <span class="s0">// $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key</span>
            <span class="s2">if </span><span class="s1">(mappedChild.key &amp;&amp; (!_child || _child.key !== mappedChild.key)) {</span>
              <span class="s1">checkKeyStringCoercion(mappedChild.key);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s1">mappedChild = cloneAndReplaceKey(mappedChild, </span><span class="s0">// Keep both the (mapped) and old keys if they differ, just as</span>
          <span class="s0">// traverseAllChildren used to do for objects as children</span>
          <span class="s1">escapedPrefix + ( </span><span class="s0">// $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key</span>
          <span class="s1">mappedChild.key &amp;&amp; (!_child || _child.key !== mappedChild.key) ? </span><span class="s0">// $FlowFixMe Flow incorrectly thinks existing element's key can be a number</span>
          <span class="s0">// eslint-disable-next-line react-internal/safe-string-coercion</span>
          <span class="s1">escapeUserProvidedKey(</span><span class="s3">'' </span><span class="s1">+ mappedChild.key) + </span><span class="s3">'/' </span><span class="s1">: </span><span class="s3">''</span><span class="s1">) + childKey);</span>
        <span class="s1">}</span>

        <span class="s1">array.push(mappedChild);</span>
      <span class="s1">}</span>

      <span class="s2">return </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">child;</span>
    <span class="s2">var </span><span class="s1">nextName;</span>
    <span class="s2">var </span><span class="s1">subtreeCount = </span><span class="s4">0</span><span class="s1">; </span><span class="s0">// Count of children found in the current subtree.</span>

    <span class="s2">var </span><span class="s1">nextNamePrefix = nameSoFar === </span><span class="s3">'' </span><span class="s1">? SEPARATOR : nameSoFar + SUBSEPARATOR;</span>

    <span class="s2">if </span><span class="s1">(isArray(children)) {</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; children.length; i++) {</span>
        <span class="s1">child = children[i];</span>
        <span class="s1">nextName = nextNamePrefix + getElementKey(child, i);</span>
        <span class="s1">subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">var </span><span class="s1">iteratorFn = getIteratorFn(children);</span>

      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">iteratorFn === </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s2">var </span><span class="s1">iterableChildren = children;</span>

        <span class="s1">{</span>
          <span class="s0">// Warn about using Maps as children</span>
          <span class="s2">if </span><span class="s1">(iteratorFn === iterableChildren.entries) {</span>
            <span class="s2">if </span><span class="s1">(!didWarnAboutMaps) {</span>
              <span class="s1">warn(</span><span class="s3">'Using Maps as children is not supported. ' </span><span class="s1">+ </span><span class="s3">'Use an array of keyed ReactElements instead.'</span><span class="s1">);</span>
            <span class="s1">}</span>

            <span class="s1">didWarnAboutMaps = </span><span class="s2">true</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s2">var </span><span class="s1">iterator = iteratorFn.call(iterableChildren);</span>
        <span class="s2">var </span><span class="s1">step;</span>
        <span class="s2">var </span><span class="s1">ii = </span><span class="s4">0</span><span class="s1">;</span>

        <span class="s2">while </span><span class="s1">(!(step = iterator.next()).done) {</span>
          <span class="s1">child = step.value;</span>
          <span class="s1">nextName = nextNamePrefix + getElementKey(child, ii++);</span>
          <span class="s1">subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(type === </span><span class="s3">'object'</span><span class="s1">) {</span>
        <span class="s0">// eslint-disable-next-line react-internal/safe-string-coercion</span>
        <span class="s2">var </span><span class="s1">childrenString = String(children);</span>
        <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">&quot;Objects are not valid as a React child (found: &quot; </span><span class="s1">+ (childrenString === </span><span class="s3">'[object Object]' </span><span class="s1">? </span><span class="s3">'object with keys {' </span><span class="s1">+ Object.keys(children).join(</span><span class="s3">', '</span><span class="s1">) + </span><span class="s3">'}' </span><span class="s1">: childrenString) + </span><span class="s3">&quot;). &quot; </span><span class="s1">+ </span><span class="s3">'If you meant to render a collection of children, use an array ' </span><span class="s1">+ </span><span class="s3">'instead.'</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">subtreeCount;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Maps children that are typically specified as `props.children`. 
   * 
   * See https://reactjs.org/docs/react-api.html#reactchildrenmap 
   * 
   * The provided mapFunction(child, index) will be called for each 
   * leaf child. 
   * 
   * @param {?*} children Children tree container. 
   * @param {function(*, int)} func The map function. 
   * @param {*} context Context for mapFunction. 
   * @return {object} Object containing the ordered map of results. 
   */</span>
  <span class="s2">function </span><span class="s1">mapChildren(children, func, context) {</span>
    <span class="s2">if </span><span class="s1">(children == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">children;</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">result = [];</span>
    <span class="s2">var </span><span class="s1">count = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">mapIntoArray(children, result, </span><span class="s3">''</span><span class="s1">, </span><span class="s3">''</span><span class="s1">, </span><span class="s2">function </span><span class="s1">(child) {</span>
      <span class="s2">return </span><span class="s1">func.call(context, child, count++);</span>
    <span class="s1">});</span>
    <span class="s2">return </span><span class="s1">result;</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Count the number of children that are typically specified as 
   * `props.children`. 
   * 
   * See https://reactjs.org/docs/react-api.html#reactchildrencount 
   * 
   * @param {?*} children Children tree container. 
   * @return {number} The number of children. 
   */</span>


  <span class="s2">function </span><span class="s1">countChildren(children) {</span>
    <span class="s2">var </span><span class="s1">n = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">mapChildren(children, </span><span class="s2">function </span><span class="s1">() {</span>
      <span class="s1">n++; </span><span class="s0">// Don't return anything</span>
    <span class="s1">});</span>
    <span class="s2">return </span><span class="s1">n;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Iterates through children that are typically specified as `props.children`. 
   * 
   * See https://reactjs.org/docs/react-api.html#reactchildrenforeach 
   * 
   * The provided forEachFunc(child, index) will be called for each 
   * leaf child. 
   * 
   * @param {?*} children Children tree container. 
   * @param {function(*, int)} forEachFunc 
   * @param {*} forEachContext Context for forEachContext. 
   */</span>
  <span class="s2">function </span><span class="s1">forEachChildren(children, forEachFunc, forEachContext) {</span>
    <span class="s1">mapChildren(children, </span><span class="s2">function </span><span class="s1">() {</span>
      <span class="s1">forEachFunc.apply(</span><span class="s2">this</span><span class="s1">, arguments); </span><span class="s0">// Don't return anything.</span>
    <span class="s1">}, forEachContext);</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Flatten a children object (typically specified as `props.children`) and 
   * return an array with appropriately re-keyed children. 
   * 
   * See https://reactjs.org/docs/react-api.html#reactchildrentoarray 
   */</span>


  <span class="s2">function </span><span class="s1">toArray(children) {</span>
    <span class="s2">return </span><span class="s1">mapChildren(children, </span><span class="s2">function </span><span class="s1">(child) {</span>
      <span class="s2">return </span><span class="s1">child;</span>
    <span class="s1">}) || [];</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Returns the first child in a collection of children and verifies that there 
   * is only one child in the collection. 
   * 
   * See https://reactjs.org/docs/react-api.html#reactchildrenonly 
   * 
   * The current implementation of this function assumes that a single child gets 
   * passed without a wrapper, but the purpose of this helper function is to 
   * abstract away the particular structure of children. 
   * 
   * @param {?object} children Child collection structure. 
   * @return {ReactElement} The first and only `ReactElement` contained in the 
   * structure. 
   */</span>


  <span class="s2">function </span><span class="s1">onlyChild(children) {</span>
    <span class="s2">if </span><span class="s1">(!isValidElement(children)) {</span>
      <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'React.Children.only expected to receive a single React element child.'</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">children;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">createContext(defaultValue) {</span>
    <span class="s0">// TODO: Second argument used to be an optional `calculateChangedBits`</span>
    <span class="s0">// function. Warn to reserve for future use?</span>
    <span class="s2">var </span><span class="s1">context = {</span>
      <span class="s1">$$typeof: REACT_CONTEXT_TYPE,</span>
      <span class="s0">// As a workaround to support multiple concurrent renderers, we categorize</span>
      <span class="s0">// some renderers as primary and others as secondary. We only expect</span>
      <span class="s0">// there to be two concurrent renderers at most: React Native (primary) and</span>
      <span class="s0">// Fabric (secondary); React DOM (primary) and React ART (secondary).</span>
      <span class="s0">// Secondary renderers store their context values on separate fields.</span>
      <span class="s1">_currentValue: defaultValue,</span>
      <span class="s1">_currentValue2: defaultValue,</span>
      <span class="s0">// Used to track how many concurrent renderers this context currently</span>
      <span class="s0">// supports within in a single renderer. Such as parallel server rendering.</span>
      <span class="s1">_threadCount: </span><span class="s4">0</span><span class="s1">,</span>
      <span class="s0">// These are circular</span>
      <span class="s1">Provider: </span><span class="s2">null</span><span class="s1">,</span>
      <span class="s1">Consumer: </span><span class="s2">null</span><span class="s1">,</span>
      <span class="s0">// Add these to use same hidden class in VM as ServerContext</span>
      <span class="s1">_defaultValue: </span><span class="s2">null</span><span class="s1">,</span>
      <span class="s1">_globalName: </span><span class="s2">null</span>
    <span class="s1">};</span>
    <span class="s1">context.Provider = {</span>
      <span class="s1">$$typeof: REACT_PROVIDER_TYPE,</span>
      <span class="s1">_context: context</span>
    <span class="s1">};</span>
    <span class="s2">var </span><span class="s1">hasWarnedAboutUsingNestedContextConsumers = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s2">var </span><span class="s1">hasWarnedAboutUsingConsumerProvider = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s2">var </span><span class="s1">hasWarnedAboutDisplayNameOnConsumer = </span><span class="s2">false</span><span class="s1">;</span>

    <span class="s1">{</span>
      <span class="s0">// A separate object, but proxies back to the original context object for</span>
      <span class="s0">// backwards compatibility. It has a different $$typeof, so we can properly</span>
      <span class="s0">// warn for the incorrect usage of Context as a Consumer.</span>
      <span class="s2">var </span><span class="s1">Consumer = {</span>
        <span class="s1">$$typeof: REACT_CONTEXT_TYPE,</span>
        <span class="s1">_context: context</span>
      <span class="s1">}; </span><span class="s0">// $FlowFixMe: Flow complains about not setting a value, which is intentional here</span>

      <span class="s1">Object.defineProperties(Consumer, {</span>
        <span class="s1">Provider: {</span>
          <span class="s1">get: </span><span class="s2">function </span><span class="s1">() {</span>
            <span class="s2">if </span><span class="s1">(!hasWarnedAboutUsingConsumerProvider) {</span>
              <span class="s1">hasWarnedAboutUsingConsumerProvider = </span><span class="s2">true</span><span class="s1">;</span>

              <span class="s1">error(</span><span class="s3">'Rendering &lt;Context.Consumer.Provider&gt; is not supported and will be removed in ' </span><span class="s1">+ </span><span class="s3">'a future major release. Did you mean to render &lt;Context.Provider&gt; instead?'</span><span class="s1">);</span>
            <span class="s1">}</span>

            <span class="s2">return </span><span class="s1">context.Provider;</span>
          <span class="s1">},</span>
          <span class="s1">set: </span><span class="s2">function </span><span class="s1">(_Provider) {</span>
            <span class="s1">context.Provider = _Provider;</span>
          <span class="s1">}</span>
        <span class="s1">},</span>
        <span class="s1">_currentValue: {</span>
          <span class="s1">get: </span><span class="s2">function </span><span class="s1">() {</span>
            <span class="s2">return </span><span class="s1">context._currentValue;</span>
          <span class="s1">},</span>
          <span class="s1">set: </span><span class="s2">function </span><span class="s1">(_currentValue) {</span>
            <span class="s1">context._currentValue = _currentValue;</span>
          <span class="s1">}</span>
        <span class="s1">},</span>
        <span class="s1">_currentValue2: {</span>
          <span class="s1">get: </span><span class="s2">function </span><span class="s1">() {</span>
            <span class="s2">return </span><span class="s1">context._currentValue2;</span>
          <span class="s1">},</span>
          <span class="s1">set: </span><span class="s2">function </span><span class="s1">(_currentValue2) {</span>
            <span class="s1">context._currentValue2 = _currentValue2;</span>
          <span class="s1">}</span>
        <span class="s1">},</span>
        <span class="s1">_threadCount: {</span>
          <span class="s1">get: </span><span class="s2">function </span><span class="s1">() {</span>
            <span class="s2">return </span><span class="s1">context._threadCount;</span>
          <span class="s1">},</span>
          <span class="s1">set: </span><span class="s2">function </span><span class="s1">(_threadCount) {</span>
            <span class="s1">context._threadCount = _threadCount;</span>
          <span class="s1">}</span>
        <span class="s1">},</span>
        <span class="s1">Consumer: {</span>
          <span class="s1">get: </span><span class="s2">function </span><span class="s1">() {</span>
            <span class="s2">if </span><span class="s1">(!hasWarnedAboutUsingNestedContextConsumers) {</span>
              <span class="s1">hasWarnedAboutUsingNestedContextConsumers = </span><span class="s2">true</span><span class="s1">;</span>

              <span class="s1">error(</span><span class="s3">'Rendering &lt;Context.Consumer.Consumer&gt; is not supported and will be removed in ' </span><span class="s1">+ </span><span class="s3">'a future major release. Did you mean to render &lt;Context.Consumer&gt; instead?'</span><span class="s1">);</span>
            <span class="s1">}</span>

            <span class="s2">return </span><span class="s1">context.Consumer;</span>
          <span class="s1">}</span>
        <span class="s1">},</span>
        <span class="s1">displayName: {</span>
          <span class="s1">get: </span><span class="s2">function </span><span class="s1">() {</span>
            <span class="s2">return </span><span class="s1">context.displayName;</span>
          <span class="s1">},</span>
          <span class="s1">set: </span><span class="s2">function </span><span class="s1">(displayName) {</span>
            <span class="s2">if </span><span class="s1">(!hasWarnedAboutDisplayNameOnConsumer) {</span>
              <span class="s1">warn(</span><span class="s3">'Setting `displayName` on Context.Consumer has no effect. ' </span><span class="s1">+ </span><span class="s3">&quot;You should set it directly on the context with Context.displayName = '%s'.&quot;</span><span class="s1">, displayName);</span>

              <span class="s1">hasWarnedAboutDisplayNameOnConsumer = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}); </span><span class="s0">// $FlowFixMe: Flow complains about missing properties because it doesn't understand defineProperty</span>

      <span class="s1">context.Consumer = Consumer;</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s1">context._currentRenderer = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">context._currentRenderer2 = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">context;</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">Uninitialized = -</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">Pending = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">Resolved = </span><span class="s4">1</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">Rejected = </span><span class="s4">2</span><span class="s1">;</span>

  <span class="s2">function </span><span class="s1">lazyInitializer(payload) {</span>
    <span class="s2">if </span><span class="s1">(payload._status === Uninitialized) {</span>
      <span class="s2">var </span><span class="s1">ctor = payload._result;</span>
      <span class="s2">var </span><span class="s1">thenable = ctor(); </span><span class="s0">// Transition to the next state.</span>
      <span class="s0">// This might throw either because it's missing or throws. If so, we treat it</span>
      <span class="s0">// as still uninitialized and try again next time. Which is the same as what</span>
      <span class="s0">// happens if the ctor or any wrappers processing the ctor throws. This might</span>
      <span class="s0">// end up fixing it if the resolution was a concurrency bug.</span>

      <span class="s1">thenable.then(</span><span class="s2">function </span><span class="s1">(moduleObject) {</span>
        <span class="s2">if </span><span class="s1">(payload._status === Pending || payload._status === Uninitialized) {</span>
          <span class="s0">// Transition to the next state.</span>
          <span class="s2">var </span><span class="s1">resolved = payload;</span>
          <span class="s1">resolved._status = Resolved;</span>
          <span class="s1">resolved._result = moduleObject;</span>
        <span class="s1">}</span>
      <span class="s1">}, </span><span class="s2">function </span><span class="s1">(error) {</span>
        <span class="s2">if </span><span class="s1">(payload._status === Pending || payload._status === Uninitialized) {</span>
          <span class="s0">// Transition to the next state.</span>
          <span class="s2">var </span><span class="s1">rejected = payload;</span>
          <span class="s1">rejected._status = Rejected;</span>
          <span class="s1">rejected._result = error;</span>
        <span class="s1">}</span>
      <span class="s1">});</span>

      <span class="s2">if </span><span class="s1">(payload._status === Uninitialized) {</span>
        <span class="s0">// In case, we're still uninitialized, then we're waiting for the thenable</span>
        <span class="s0">// to resolve. Set it as pending in the meantime.</span>
        <span class="s2">var </span><span class="s1">pending = payload;</span>
        <span class="s1">pending._status = Pending;</span>
        <span class="s1">pending._result = thenable;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(payload._status === Resolved) {</span>
      <span class="s2">var </span><span class="s1">moduleObject = payload._result;</span>

      <span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(moduleObject === undefined) {</span>
          <span class="s1">error(</span><span class="s3">'lazy: Expected the result of a dynamic imp' </span><span class="s1">+ </span><span class="s3">'ort() call. ' </span><span class="s1">+ </span><span class="s3">'Instead received: %s</span><span class="s5">\n\n</span><span class="s3">Your code should look like: </span><span class="s5">\n  </span><span class="s3">' </span><span class="s1">+ </span><span class="s0">// Break up imports to avoid accidentally parsing them as dependencies.</span>
          <span class="s3">'const MyComponent = lazy(() =&gt; imp' </span><span class="s1">+ </span><span class="s3">&quot;ort('./MyComponent'))</span><span class="s5">\n\n</span><span class="s3">&quot; </span><span class="s1">+ </span><span class="s3">'Did you accidentally put curly braces around the import?'</span><span class="s1">, moduleObject);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(!(</span><span class="s3">'default' </span><span class="s2">in </span><span class="s1">moduleObject)) {</span>
          <span class="s1">error(</span><span class="s3">'lazy: Expected the result of a dynamic imp' </span><span class="s1">+ </span><span class="s3">'ort() call. ' </span><span class="s1">+ </span><span class="s3">'Instead received: %s</span><span class="s5">\n\n</span><span class="s3">Your code should look like: </span><span class="s5">\n  </span><span class="s3">' </span><span class="s1">+ </span><span class="s0">// Break up imports to avoid accidentally parsing them as dependencies.</span>
          <span class="s3">'const MyComponent = lazy(() =&gt; imp' </span><span class="s1">+ </span><span class="s3">&quot;ort('./MyComponent'))&quot;</span><span class="s1">, moduleObject);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">return </span><span class="s1">moduleObject.</span><span class="s2">default</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">throw </span><span class="s1">payload._result;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">lazy(ctor) {</span>
    <span class="s2">var </span><span class="s1">payload = {</span>
      <span class="s0">// We use these fields to store the result.</span>
      <span class="s1">_status: Uninitialized,</span>
      <span class="s1">_result: ctor</span>
    <span class="s1">};</span>
    <span class="s2">var </span><span class="s1">lazyType = {</span>
      <span class="s1">$$typeof: REACT_LAZY_TYPE,</span>
      <span class="s1">_payload: payload,</span>
      <span class="s1">_init: lazyInitializer</span>
    <span class="s1">};</span>

    <span class="s1">{</span>
      <span class="s0">// In production, this would just set it on the object.</span>
      <span class="s2">var </span><span class="s1">defaultProps;</span>
      <span class="s2">var </span><span class="s1">propTypes; </span><span class="s0">// $FlowFixMe</span>

      <span class="s1">Object.defineProperties(lazyType, {</span>
        <span class="s1">defaultProps: {</span>
          <span class="s1">configurable: </span><span class="s2">true</span><span class="s1">,</span>
          <span class="s1">get: </span><span class="s2">function </span><span class="s1">() {</span>
            <span class="s2">return </span><span class="s1">defaultProps;</span>
          <span class="s1">},</span>
          <span class="s1">set: </span><span class="s2">function </span><span class="s1">(newDefaultProps) {</span>
            <span class="s1">error(</span><span class="s3">'React.lazy(...): It is not supported to assign `defaultProps` to ' </span><span class="s1">+ </span><span class="s3">'a lazy component import. Either specify them where the component ' </span><span class="s1">+ </span><span class="s3">'is defined, or create a wrapping component around it.'</span><span class="s1">);</span>

            <span class="s1">defaultProps = newDefaultProps; </span><span class="s0">// Match production behavior more closely:</span>
            <span class="s0">// $FlowFixMe</span>

            <span class="s1">Object.defineProperty(lazyType, </span><span class="s3">'defaultProps'</span><span class="s1">, {</span>
              <span class="s1">enumerable: </span><span class="s2">true</span>
            <span class="s1">});</span>
          <span class="s1">}</span>
        <span class="s1">},</span>
        <span class="s1">propTypes: {</span>
          <span class="s1">configurable: </span><span class="s2">true</span><span class="s1">,</span>
          <span class="s1">get: </span><span class="s2">function </span><span class="s1">() {</span>
            <span class="s2">return </span><span class="s1">propTypes;</span>
          <span class="s1">},</span>
          <span class="s1">set: </span><span class="s2">function </span><span class="s1">(newPropTypes) {</span>
            <span class="s1">error(</span><span class="s3">'React.lazy(...): It is not supported to assign `propTypes` to ' </span><span class="s1">+ </span><span class="s3">'a lazy component import. Either specify them where the component ' </span><span class="s1">+ </span><span class="s3">'is defined, or create a wrapping component around it.'</span><span class="s1">);</span>

            <span class="s1">propTypes = newPropTypes; </span><span class="s0">// Match production behavior more closely:</span>
            <span class="s0">// $FlowFixMe</span>

            <span class="s1">Object.defineProperty(lazyType, </span><span class="s3">'propTypes'</span><span class="s1">, {</span>
              <span class="s1">enumerable: </span><span class="s2">true</span>
            <span class="s1">});</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">lazyType;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">forwardRef(render) {</span>
    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(render != </span><span class="s2">null </span><span class="s1">&amp;&amp; render.$$typeof === REACT_MEMO_TYPE) {</span>
        <span class="s1">error(</span><span class="s3">'forwardRef requires a render function but received a `memo` ' </span><span class="s1">+ </span><span class="s3">'component. Instead of forwardRef(memo(...)), use ' </span><span class="s1">+ </span><span class="s3">'memo(forwardRef(...)).'</span><span class="s1">);</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">render !== </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s3">'forwardRef requires a render function but was given %s.'</span><span class="s1">, render === </span><span class="s2">null </span><span class="s1">? </span><span class="s3">'null' </span><span class="s1">: </span><span class="s2">typeof </span><span class="s1">render);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(render.length !== </span><span class="s4">0 </span><span class="s1">&amp;&amp; render.length !== </span><span class="s4">2</span><span class="s1">) {</span>
          <span class="s1">error(</span><span class="s3">'forwardRef render functions accept exactly two parameters: props and ref. %s'</span><span class="s1">, render.length === </span><span class="s4">1 </span><span class="s1">? </span><span class="s3">'Did you forget to use the ref parameter?' </span><span class="s1">: </span><span class="s3">'Any additional parameter will be undefined.'</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(render != </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(render.defaultProps != </span><span class="s2">null </span><span class="s1">|| render.propTypes != </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">error(</span><span class="s3">'forwardRef render functions do not support propTypes or defaultProps. ' </span><span class="s1">+ </span><span class="s3">'Did you accidentally pass a React component?'</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">elementType = {</span>
      <span class="s1">$$typeof: REACT_FORWARD_REF_TYPE,</span>
      <span class="s1">render: render</span>
    <span class="s1">};</span>

    <span class="s1">{</span>
      <span class="s2">var </span><span class="s1">ownName;</span>
      <span class="s1">Object.defineProperty(elementType, </span><span class="s3">'displayName'</span><span class="s1">, {</span>
        <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
        <span class="s1">configurable: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">get: </span><span class="s2">function </span><span class="s1">() {</span>
          <span class="s2">return </span><span class="s1">ownName;</span>
        <span class="s1">},</span>
        <span class="s1">set: </span><span class="s2">function </span><span class="s1">(name) {</span>
          <span class="s1">ownName = name; </span><span class="s0">// The inner component shouldn't inherit this display name in most cases,</span>
          <span class="s0">// because the component may be used elsewhere.</span>
          <span class="s0">// But it's nice for anonymous functions to inherit the name,</span>
          <span class="s0">// so that our component-stack generation logic will display their frames.</span>
          <span class="s0">// An anonymous function generally suggests a pattern like:</span>
          <span class="s0">//   React.forwardRef((props, ref) =&gt; {...});</span>
          <span class="s0">// This kind of inner function is not used elsewhere so the side effect is okay.</span>

          <span class="s2">if </span><span class="s1">(!render.name &amp;&amp; !render.displayName) {</span>
            <span class="s1">render.displayName = name;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">elementType;</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">REACT_MODULE_REFERENCE;</span>

  <span class="s1">{</span>
    <span class="s1">REACT_MODULE_REFERENCE = Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.module.reference'</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">isValidElementType(type) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">type === </span><span class="s3">'string' </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">type === </span><span class="s3">'function'</span><span class="s1">) {</span>
      <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s0">// Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).</span>


    <span class="s2">if </span><span class="s1">(type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {</span>
      <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">type === </span><span class="s3">'object' </span><span class="s1">&amp;&amp; type !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || </span><span class="s0">// This needs to include all possible module reference object</span>
      <span class="s0">// types supported by any Flight configuration anywhere since</span>
      <span class="s0">// we don't know which Flight build this will end up being used</span>
      <span class="s0">// with.</span>
      <span class="s1">type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {</span>
        <span class="s2">return true</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return false</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">memo(type, compare) {</span>
    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(!isValidElementType(type)) {</span>
        <span class="s1">error(</span><span class="s3">'memo: The first argument must be a component. Instead ' </span><span class="s1">+ </span><span class="s3">'received: %s'</span><span class="s1">, type === </span><span class="s2">null </span><span class="s1">? </span><span class="s3">'null' </span><span class="s1">: </span><span class="s2">typeof </span><span class="s1">type);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">elementType = {</span>
      <span class="s1">$$typeof: REACT_MEMO_TYPE,</span>
      <span class="s1">type: type,</span>
      <span class="s1">compare: compare === undefined ? </span><span class="s2">null </span><span class="s1">: compare</span>
    <span class="s1">};</span>

    <span class="s1">{</span>
      <span class="s2">var </span><span class="s1">ownName;</span>
      <span class="s1">Object.defineProperty(elementType, </span><span class="s3">'displayName'</span><span class="s1">, {</span>
        <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
        <span class="s1">configurable: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">get: </span><span class="s2">function </span><span class="s1">() {</span>
          <span class="s2">return </span><span class="s1">ownName;</span>
        <span class="s1">},</span>
        <span class="s1">set: </span><span class="s2">function </span><span class="s1">(name) {</span>
          <span class="s1">ownName = name; </span><span class="s0">// The inner component shouldn't inherit this display name in most cases,</span>
          <span class="s0">// because the component may be used elsewhere.</span>
          <span class="s0">// But it's nice for anonymous functions to inherit the name,</span>
          <span class="s0">// so that our component-stack generation logic will display their frames.</span>
          <span class="s0">// An anonymous function generally suggests a pattern like:</span>
          <span class="s0">//   React.memo((props) =&gt; {...});</span>
          <span class="s0">// This kind of inner function is not used elsewhere so the side effect is okay.</span>

          <span class="s2">if </span><span class="s1">(!type.name &amp;&amp; !type.displayName) {</span>
            <span class="s1">type.displayName = name;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">elementType;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">resolveDispatcher() {</span>
    <span class="s2">var </span><span class="s1">dispatcher = ReactCurrentDispatcher.current;</span>

    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(dispatcher === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s3">'Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' </span><span class="s1">+ </span><span class="s3">' one of the following reasons:</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">'1. You might have mismatching versions of React and the renderer (such as React DOM)</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">'2. You might be breaking the Rules of Hooks</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">'3. You might have more than one copy of React in the same app</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.'</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// Will result in a null access error if accessed outside render phase. We</span>
    <span class="s0">// intentionally don't throw our own error because this is in a hot path.</span>
    <span class="s0">// Also helps ensure this is inlined.</span>


    <span class="s2">return </span><span class="s1">dispatcher;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">useContext(Context) {</span>
    <span class="s2">var </span><span class="s1">dispatcher = resolveDispatcher();</span>

    <span class="s1">{</span>
      <span class="s0">// TODO: add a more generic warning for invalid values.</span>
      <span class="s2">if </span><span class="s1">(Context._context !== undefined) {</span>
        <span class="s2">var </span><span class="s1">realContext = Context._context; </span><span class="s0">// Don't deduplicate because this legitimately causes bugs</span>
        <span class="s0">// and nobody should be using this in existing code.</span>

        <span class="s2">if </span><span class="s1">(realContext.Consumer === Context) {</span>
          <span class="s1">error(</span><span class="s3">'Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' </span><span class="s1">+ </span><span class="s3">'removed in a future major release. Did you mean to call useContext(Context) instead?'</span><span class="s1">);</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(realContext.Provider === Context) {</span>
          <span class="s1">error(</span><span class="s3">'Calling useContext(Context.Provider) is not supported. ' </span><span class="s1">+ </span><span class="s3">'Did you mean to call useContext(Context) instead?'</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">dispatcher.useContext(Context);</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">useState(initialState) {</span>
    <span class="s2">var </span><span class="s1">dispatcher = resolveDispatcher();</span>
    <span class="s2">return </span><span class="s1">dispatcher.useState(initialState);</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">useReducer(reducer, initialArg, init) {</span>
    <span class="s2">var </span><span class="s1">dispatcher = resolveDispatcher();</span>
    <span class="s2">return </span><span class="s1">dispatcher.useReducer(reducer, initialArg, init);</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">useRef(initialValue) {</span>
    <span class="s2">var </span><span class="s1">dispatcher = resolveDispatcher();</span>
    <span class="s2">return </span><span class="s1">dispatcher.useRef(initialValue);</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">useEffect(create, deps) {</span>
    <span class="s2">var </span><span class="s1">dispatcher = resolveDispatcher();</span>
    <span class="s2">return </span><span class="s1">dispatcher.useEffect(create, deps);</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">useInsertionEffect(create, deps) {</span>
    <span class="s2">var </span><span class="s1">dispatcher = resolveDispatcher();</span>
    <span class="s2">return </span><span class="s1">dispatcher.useInsertionEffect(create, deps);</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">useLayoutEffect(create, deps) {</span>
    <span class="s2">var </span><span class="s1">dispatcher = resolveDispatcher();</span>
    <span class="s2">return </span><span class="s1">dispatcher.useLayoutEffect(create, deps);</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">useCallback(callback, deps) {</span>
    <span class="s2">var </span><span class="s1">dispatcher = resolveDispatcher();</span>
    <span class="s2">return </span><span class="s1">dispatcher.useCallback(callback, deps);</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">useMemo(create, deps) {</span>
    <span class="s2">var </span><span class="s1">dispatcher = resolveDispatcher();</span>
    <span class="s2">return </span><span class="s1">dispatcher.useMemo(create, deps);</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">useImperativeHandle(ref, create, deps) {</span>
    <span class="s2">var </span><span class="s1">dispatcher = resolveDispatcher();</span>
    <span class="s2">return </span><span class="s1">dispatcher.useImperativeHandle(ref, create, deps);</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">useDebugValue(value, formatterFn) {</span>
    <span class="s1">{</span>
      <span class="s2">var </span><span class="s1">dispatcher = resolveDispatcher();</span>
      <span class="s2">return </span><span class="s1">dispatcher.useDebugValue(value, formatterFn);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">useTransition() {</span>
    <span class="s2">var </span><span class="s1">dispatcher = resolveDispatcher();</span>
    <span class="s2">return </span><span class="s1">dispatcher.useTransition();</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">useDeferredValue(value) {</span>
    <span class="s2">var </span><span class="s1">dispatcher = resolveDispatcher();</span>
    <span class="s2">return </span><span class="s1">dispatcher.useDeferredValue(value);</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">useId() {</span>
    <span class="s2">var </span><span class="s1">dispatcher = resolveDispatcher();</span>
    <span class="s2">return </span><span class="s1">dispatcher.useId();</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {</span>
    <span class="s2">var </span><span class="s1">dispatcher = resolveDispatcher();</span>
    <span class="s2">return </span><span class="s1">dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);</span>
  <span class="s1">}</span>

  <span class="s0">// Helpers to patch console.logs to avoid logging during side-effect free</span>
  <span class="s0">// replaying on render function. This currently only patches the object</span>
  <span class="s0">// lazily which won't cover if the log function was extracted eagerly.</span>
  <span class="s0">// We could also eagerly patch the method.</span>
  <span class="s2">var </span><span class="s1">disabledDepth = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">prevLog;</span>
  <span class="s2">var </span><span class="s1">prevInfo;</span>
  <span class="s2">var </span><span class="s1">prevWarn;</span>
  <span class="s2">var </span><span class="s1">prevError;</span>
  <span class="s2">var </span><span class="s1">prevGroup;</span>
  <span class="s2">var </span><span class="s1">prevGroupCollapsed;</span>
  <span class="s2">var </span><span class="s1">prevGroupEnd;</span>

  <span class="s2">function </span><span class="s1">disabledLog() {}</span>

  <span class="s1">disabledLog.__reactDisabledLog = </span><span class="s2">true</span><span class="s1">;</span>
  <span class="s2">function </span><span class="s1">disableLogs() {</span>
    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(disabledDepth === </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s0">/* eslint-disable react-internal/no-production-logging */</span>
        <span class="s1">prevLog = console.log;</span>
        <span class="s1">prevInfo = console.info;</span>
        <span class="s1">prevWarn = console.warn;</span>
        <span class="s1">prevError = console.error;</span>
        <span class="s1">prevGroup = console.group;</span>
        <span class="s1">prevGroupCollapsed = console.groupCollapsed;</span>
        <span class="s1">prevGroupEnd = console.groupEnd; </span><span class="s0">// https://github.com/facebook/react/issues/19099</span>

        <span class="s2">var </span><span class="s1">props = {</span>
          <span class="s1">configurable: </span><span class="s2">true</span><span class="s1">,</span>
          <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
          <span class="s1">value: disabledLog,</span>
          <span class="s1">writable: </span><span class="s2">true</span>
        <span class="s1">}; </span><span class="s0">// $FlowFixMe Flow thinks console is immutable.</span>

        <span class="s1">Object.defineProperties(console, {</span>
          <span class="s1">info: props,</span>
          <span class="s1">log: props,</span>
          <span class="s1">warn: props,</span>
          <span class="s1">error: props,</span>
          <span class="s1">group: props,</span>
          <span class="s1">groupCollapsed: props,</span>
          <span class="s1">groupEnd: props</span>
        <span class="s1">});</span>
        <span class="s0">/* eslint-enable react-internal/no-production-logging */</span>
      <span class="s1">}</span>

      <span class="s1">disabledDepth++;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">reenableLogs() {</span>
    <span class="s1">{</span>
      <span class="s1">disabledDepth--;</span>

      <span class="s2">if </span><span class="s1">(disabledDepth === </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s0">/* eslint-disable react-internal/no-production-logging */</span>
        <span class="s2">var </span><span class="s1">props = {</span>
          <span class="s1">configurable: </span><span class="s2">true</span><span class="s1">,</span>
          <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
          <span class="s1">writable: </span><span class="s2">true</span>
        <span class="s1">}; </span><span class="s0">// $FlowFixMe Flow thinks console is immutable.</span>

        <span class="s1">Object.defineProperties(console, {</span>
          <span class="s1">log: assign({}, props, {</span>
            <span class="s1">value: prevLog</span>
          <span class="s1">}),</span>
          <span class="s1">info: assign({}, props, {</span>
            <span class="s1">value: prevInfo</span>
          <span class="s1">}),</span>
          <span class="s1">warn: assign({}, props, {</span>
            <span class="s1">value: prevWarn</span>
          <span class="s1">}),</span>
          <span class="s1">error: assign({}, props, {</span>
            <span class="s1">value: prevError</span>
          <span class="s1">}),</span>
          <span class="s1">group: assign({}, props, {</span>
            <span class="s1">value: prevGroup</span>
          <span class="s1">}),</span>
          <span class="s1">groupCollapsed: assign({}, props, {</span>
            <span class="s1">value: prevGroupCollapsed</span>
          <span class="s1">}),</span>
          <span class="s1">groupEnd: assign({}, props, {</span>
            <span class="s1">value: prevGroupEnd</span>
          <span class="s1">})</span>
        <span class="s1">});</span>
        <span class="s0">/* eslint-enable react-internal/no-production-logging */</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(disabledDepth &lt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s3">'disabledDepth fell below zero. ' </span><span class="s1">+ </span><span class="s3">'This is a bug in React. Please file an issue.'</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;</span>
  <span class="s2">var </span><span class="s1">prefix;</span>
  <span class="s2">function </span><span class="s1">describeBuiltInComponentFrame(name, source, ownerFn) {</span>
    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(prefix === undefined) {</span>
        <span class="s0">// Extract the VM specific prefix used by each line.</span>
        <span class="s2">try </span><span class="s1">{</span>
          <span class="s2">throw </span><span class="s1">Error();</span>
        <span class="s1">} </span><span class="s2">catch </span><span class="s1">(x) {</span>
          <span class="s2">var </span><span class="s1">match = x.stack.trim().match(/\n( *(at )?)/);</span>
          <span class="s1">prefix = match &amp;&amp; match[</span><span class="s4">1</span><span class="s1">] || </span><span class="s3">''</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s0">// We use the prefix to ensure our stacks line up with native stack frames.</span>


      <span class="s2">return </span><span class="s3">'</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">+ prefix + name;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">var </span><span class="s1">reentry = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">componentFrameCache;</span>

  <span class="s1">{</span>
    <span class="s2">var </span><span class="s1">PossiblyWeakMap = </span><span class="s2">typeof </span><span class="s1">WeakMap === </span><span class="s3">'function' </span><span class="s1">? WeakMap : Map;</span>
    <span class="s1">componentFrameCache = </span><span class="s2">new </span><span class="s1">PossiblyWeakMap();</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">describeNativeComponentFrame(fn, construct) {</span>
    <span class="s0">// If something asked for a stack inside a fake render, it should get ignored.</span>
    <span class="s2">if </span><span class="s1">( !fn || reentry) {</span>
      <span class="s2">return </span><span class="s3">''</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s2">var </span><span class="s1">frame = componentFrameCache.get(fn);</span>

      <span class="s2">if </span><span class="s1">(frame !== undefined) {</span>
        <span class="s2">return </span><span class="s1">frame;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">control;</span>
    <span class="s1">reentry = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s2">var </span><span class="s1">previousPrepareStackTrace = Error.prepareStackTrace; </span><span class="s0">// $FlowFixMe It does accept undefined.</span>

    <span class="s1">Error.prepareStackTrace = undefined;</span>
    <span class="s2">var </span><span class="s1">previousDispatcher;</span>

    <span class="s1">{</span>
      <span class="s1">previousDispatcher = ReactCurrentDispatcher$1.current; </span><span class="s0">// Set the dispatcher in DEV because this might be call in the render function</span>
      <span class="s0">// for warnings.</span>

      <span class="s1">ReactCurrentDispatcher$1.current = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">disableLogs();</span>
    <span class="s1">}</span>

    <span class="s2">try </span><span class="s1">{</span>
      <span class="s0">// This should throw.</span>
      <span class="s2">if </span><span class="s1">(construct) {</span>
        <span class="s0">// Something should be setting the props in the constructor.</span>
        <span class="s2">var </span><span class="s1">Fake = </span><span class="s2">function </span><span class="s1">() {</span>
          <span class="s2">throw </span><span class="s1">Error();</span>
        <span class="s1">}; </span><span class="s0">// $FlowFixMe</span>


        <span class="s1">Object.defineProperty(Fake.prototype, </span><span class="s3">'props'</span><span class="s1">, {</span>
          <span class="s1">set: </span><span class="s2">function </span><span class="s1">() {</span>
            <span class="s0">// We use a throwing setter instead of frozen or non-writable props</span>
            <span class="s0">// because that won't throw in a non-strict mode function.</span>
            <span class="s2">throw </span><span class="s1">Error();</span>
          <span class="s1">}</span>
        <span class="s1">});</span>

        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">Reflect === </span><span class="s3">'object' </span><span class="s1">&amp;&amp; Reflect.construct) {</span>
          <span class="s0">// We construct a different control for this case to include any extra</span>
          <span class="s0">// frames added by the construct call.</span>
          <span class="s2">try </span><span class="s1">{</span>
            <span class="s1">Reflect.construct(Fake, []);</span>
          <span class="s1">} </span><span class="s2">catch </span><span class="s1">(x) {</span>
            <span class="s1">control = x;</span>
          <span class="s1">}</span>

          <span class="s1">Reflect.construct(fn, [], Fake);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s2">try </span><span class="s1">{</span>
            <span class="s1">Fake.call();</span>
          <span class="s1">} </span><span class="s2">catch </span><span class="s1">(x) {</span>
            <span class="s1">control = x;</span>
          <span class="s1">}</span>

          <span class="s1">fn.call(Fake.prototype);</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">try </span><span class="s1">{</span>
          <span class="s2">throw </span><span class="s1">Error();</span>
        <span class="s1">} </span><span class="s2">catch </span><span class="s1">(x) {</span>
          <span class="s1">control = x;</span>
        <span class="s1">}</span>

        <span class="s1">fn();</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(sample) {</span>
      <span class="s0">// This is inlined manually because closure doesn't do it for us.</span>
      <span class="s2">if </span><span class="s1">(sample &amp;&amp; control &amp;&amp; </span><span class="s2">typeof </span><span class="s1">sample.stack === </span><span class="s3">'string'</span><span class="s1">) {</span>
        <span class="s0">// This extracts the first frame from the sample that isn't also in the control.</span>
        <span class="s0">// Skipping one frame that we assume is the frame that calls the two.</span>
        <span class="s2">var </span><span class="s1">sampleLines = sample.stack.split(</span><span class="s3">'</span><span class="s5">\n</span><span class="s3">'</span><span class="s1">);</span>
        <span class="s2">var </span><span class="s1">controlLines = control.stack.split(</span><span class="s3">'</span><span class="s5">\n</span><span class="s3">'</span><span class="s1">);</span>
        <span class="s2">var </span><span class="s1">s = sampleLines.length - </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s2">var </span><span class="s1">c = controlLines.length - </span><span class="s4">1</span><span class="s1">;</span>

        <span class="s2">while </span><span class="s1">(s &gt;= </span><span class="s4">1 </span><span class="s1">&amp;&amp; c &gt;= </span><span class="s4">0 </span><span class="s1">&amp;&amp; sampleLines[s] !== controlLines[c]) {</span>
          <span class="s0">// We expect at least one stack frame to be shared.</span>
          <span class="s0">// Typically this will be the root most one. However, stack frames may be</span>
          <span class="s0">// cut off due to maximum stack limits. In this case, one maybe cut off</span>
          <span class="s0">// earlier than the other. We assume that the sample is longer or the same</span>
          <span class="s0">// and there for cut off earlier. So we should find the root most frame in</span>
          <span class="s0">// the sample somewhere in the control.</span>
          <span class="s1">c--;</span>
        <span class="s1">}</span>

        <span class="s2">for </span><span class="s1">(; s &gt;= </span><span class="s4">1 </span><span class="s1">&amp;&amp; c &gt;= </span><span class="s4">0</span><span class="s1">; s--, c--) {</span>
          <span class="s0">// Next we find the first one that isn't the same which should be the</span>
          <span class="s0">// frame that called our sample function and the control.</span>
          <span class="s2">if </span><span class="s1">(sampleLines[s] !== controlLines[c]) {</span>
            <span class="s0">// In V8, the first line is describing the message but other VMs don't.</span>
            <span class="s0">// If we're about to return the first line, and the control is also on the same</span>
            <span class="s0">// line, that's a pretty good indicator that our sample threw at same line as</span>
            <span class="s0">// the control. I.e. before we entered the sample frame. So we ignore this result.</span>
            <span class="s0">// This can happen if you passed a class to function component, or non-function.</span>
            <span class="s2">if </span><span class="s1">(s !== </span><span class="s4">1 </span><span class="s1">|| c !== </span><span class="s4">1</span><span class="s1">) {</span>
              <span class="s2">do </span><span class="s1">{</span>
                <span class="s1">s--;</span>
                <span class="s1">c--; </span><span class="s0">// We may still have similar intermediate frames from the construct call.</span>
                <span class="s0">// The next one that isn't the same should be our match though.</span>

                <span class="s2">if </span><span class="s1">(c &lt; </span><span class="s4">0 </span><span class="s1">|| sampleLines[s] !== controlLines[c]) {</span>
                  <span class="s0">// V8 adds a &quot;new&quot; prefix for native classes. Let's remove it to make it prettier.</span>
                  <span class="s2">var </span><span class="s1">_frame = </span><span class="s3">'</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">+ sampleLines[s].replace(</span><span class="s3">' at new '</span><span class="s1">, </span><span class="s3">' at '</span><span class="s1">); </span><span class="s0">// If our component frame is labeled &quot;&lt;anonymous&gt;&quot;</span>
                  <span class="s0">// but we have a user-provided &quot;displayName&quot;</span>
                  <span class="s0">// splice it in to make the stack more readable.</span>


                  <span class="s2">if </span><span class="s1">(fn.displayName &amp;&amp; _frame.includes(</span><span class="s3">'&lt;anonymous&gt;'</span><span class="s1">)) {</span>
                    <span class="s1">_frame = _frame.replace(</span><span class="s3">'&lt;anonymous&gt;'</span><span class="s1">, fn.displayName);</span>
                  <span class="s1">}</span>

                  <span class="s1">{</span>
                    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">fn === </span><span class="s3">'function'</span><span class="s1">) {</span>
                      <span class="s1">componentFrameCache.set(fn, _frame);</span>
                    <span class="s1">}</span>
                  <span class="s1">} </span><span class="s0">// Return the line we found.</span>


                  <span class="s2">return </span><span class="s1">_frame;</span>
                <span class="s1">}</span>
              <span class="s1">} </span><span class="s2">while </span><span class="s1">(s &gt;= </span><span class="s4">1 </span><span class="s1">&amp;&amp; c &gt;= </span><span class="s4">0</span><span class="s1">);</span>
            <span class="s1">}</span>

            <span class="s2">break</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
      <span class="s1">reentry = </span><span class="s2">false</span><span class="s1">;</span>

      <span class="s1">{</span>
        <span class="s1">ReactCurrentDispatcher$1.current = previousDispatcher;</span>
        <span class="s1">reenableLogs();</span>
      <span class="s1">}</span>

      <span class="s1">Error.prepareStackTrace = previousPrepareStackTrace;</span>
    <span class="s1">} </span><span class="s0">// Fallback to just using the name if we couldn't make it throw.</span>


    <span class="s2">var </span><span class="s1">name = fn ? fn.displayName || fn.name : </span><span class="s3">''</span><span class="s1">;</span>
    <span class="s2">var </span><span class="s1">syntheticFrame = name ? describeBuiltInComponentFrame(name) : </span><span class="s3">''</span><span class="s1">;</span>

    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">fn === </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s1">componentFrameCache.set(fn, syntheticFrame);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">syntheticFrame;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">describeFunctionComponentFrame(fn, source, ownerFn) {</span>
    <span class="s1">{</span>
      <span class="s2">return </span><span class="s1">describeNativeComponentFrame(fn, </span><span class="s2">false</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">shouldConstruct(Component) {</span>
    <span class="s2">var </span><span class="s1">prototype = Component.prototype;</span>
    <span class="s2">return </span><span class="s1">!!(prototype &amp;&amp; prototype.isReactComponent);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {</span>

    <span class="s2">if </span><span class="s1">(type == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s3">''</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">type === </span><span class="s3">'function'</span><span class="s1">) {</span>
      <span class="s1">{</span>
        <span class="s2">return </span><span class="s1">describeNativeComponentFrame(type, shouldConstruct(type));</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">type === </span><span class="s3">'string'</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">describeBuiltInComponentFrame(type);</span>
    <span class="s1">}</span>

    <span class="s2">switch </span><span class="s1">(type) {</span>
      <span class="s2">case </span><span class="s1">REACT_SUSPENSE_TYPE:</span>
        <span class="s2">return </span><span class="s1">describeBuiltInComponentFrame(</span><span class="s3">'Suspense'</span><span class="s1">);</span>

      <span class="s2">case </span><span class="s1">REACT_SUSPENSE_LIST_TYPE:</span>
        <span class="s2">return </span><span class="s1">describeBuiltInComponentFrame(</span><span class="s3">'SuspenseList'</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">type === </span><span class="s3">'object'</span><span class="s1">) {</span>
      <span class="s2">switch </span><span class="s1">(type.$$typeof) {</span>
        <span class="s2">case </span><span class="s1">REACT_FORWARD_REF_TYPE:</span>
          <span class="s2">return </span><span class="s1">describeFunctionComponentFrame(type.render);</span>

        <span class="s2">case </span><span class="s1">REACT_MEMO_TYPE:</span>
          <span class="s0">// Memo may contain any component type so we recursively resolve it.</span>
          <span class="s2">return </span><span class="s1">describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);</span>

        <span class="s2">case </span><span class="s1">REACT_LAZY_TYPE:</span>
          <span class="s1">{</span>
            <span class="s2">var </span><span class="s1">lazyComponent = type;</span>
            <span class="s2">var </span><span class="s1">payload = lazyComponent._payload;</span>
            <span class="s2">var </span><span class="s1">init = lazyComponent._init;</span>

            <span class="s2">try </span><span class="s1">{</span>
              <span class="s0">// Lazy may contain any component type so we recursively resolve it.</span>
              <span class="s2">return </span><span class="s1">describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);</span>
            <span class="s1">} </span><span class="s2">catch </span><span class="s1">(x) {}</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s3">''</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">loggedTypeFailures = {};</span>
  <span class="s2">var </span><span class="s1">ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;</span>

  <span class="s2">function </span><span class="s1">setCurrentlyValidatingElement(element) {</span>
    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(element) {</span>
        <span class="s2">var </span><span class="s1">owner = element._owner;</span>
        <span class="s2">var </span><span class="s1">stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : </span><span class="s2">null</span><span class="s1">);</span>
        <span class="s1">ReactDebugCurrentFrame$1.setExtraStackFrame(stack);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">ReactDebugCurrentFrame$1.setExtraStackFrame(</span><span class="s2">null</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">checkPropTypes(typeSpecs, values, location, componentName, element) {</span>
    <span class="s1">{</span>
      <span class="s0">// $FlowFixMe This is okay but Flow doesn't know it.</span>
      <span class="s2">var </span><span class="s1">has = Function.call.bind(hasOwnProperty);</span>

      <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">typeSpecName </span><span class="s2">in </span><span class="s1">typeSpecs) {</span>
        <span class="s2">if </span><span class="s1">(has(typeSpecs, typeSpecName)) {</span>
          <span class="s2">var </span><span class="s1">error$1 = </span><span class="s2">void </span><span class="s4">0</span><span class="s1">; </span><span class="s0">// Prop type validation may throw. In case they do, we don't want to</span>
          <span class="s0">// fail the render phase where it didn't fail before. So we log it.</span>
          <span class="s0">// After these have been cleaned up, we'll let them throw.</span>

          <span class="s2">try </span><span class="s1">{</span>
            <span class="s0">// This is intentionally an invariant that gets caught. It's the same</span>
            <span class="s0">// behavior as without this statement except with a better message.</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">typeSpecs[typeSpecName] !== </span><span class="s3">'function'</span><span class="s1">) {</span>
              <span class="s0">// eslint-disable-next-line react-internal/prod-error-codes</span>
              <span class="s2">var </span><span class="s1">err = Error((componentName || </span><span class="s3">'React class'</span><span class="s1">) + </span><span class="s3">': ' </span><span class="s1">+ location + </span><span class="s3">' type `' </span><span class="s1">+ typeSpecName + </span><span class="s3">'` is invalid; ' </span><span class="s1">+ </span><span class="s3">'it must be a function, usually from the `prop-types` package, but received `' </span><span class="s1">+ </span><span class="s2">typeof </span><span class="s1">typeSpecs[typeSpecName] + </span><span class="s3">'`.' </span><span class="s1">+ </span><span class="s3">'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.'</span><span class="s1">);</span>
              <span class="s1">err.name = </span><span class="s3">'Invariant Violation'</span><span class="s1">;</span>
              <span class="s2">throw </span><span class="s1">err;</span>
            <span class="s1">}</span>

            <span class="s1">error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, </span><span class="s2">null</span><span class="s1">, </span><span class="s3">'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED'</span><span class="s1">);</span>
          <span class="s1">} </span><span class="s2">catch </span><span class="s1">(ex) {</span>
            <span class="s1">error$1 = ex;</span>
          <span class="s1">}</span>

          <span class="s2">if </span><span class="s1">(error$1 &amp;&amp; !(error$1 </span><span class="s2">instanceof </span><span class="s1">Error)) {</span>
            <span class="s1">setCurrentlyValidatingElement(element);</span>

            <span class="s1">error(</span><span class="s3">'%s: type specification of %s' </span><span class="s1">+ </span><span class="s3">' `%s` is invalid; the type checker ' </span><span class="s1">+ </span><span class="s3">'function must return `null` or an `Error` but returned a %s. ' </span><span class="s1">+ </span><span class="s3">'You may have forgotten to pass an argument to the type checker ' </span><span class="s1">+ </span><span class="s3">'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' </span><span class="s1">+ </span><span class="s3">'shape all require an argument).'</span><span class="s1">, componentName || </span><span class="s3">'React class'</span><span class="s1">, location, typeSpecName, </span><span class="s2">typeof </span><span class="s1">error$1);</span>

            <span class="s1">setCurrentlyValidatingElement(</span><span class="s2">null</span><span class="s1">);</span>
          <span class="s1">}</span>

          <span class="s2">if </span><span class="s1">(error$1 </span><span class="s2">instanceof </span><span class="s1">Error &amp;&amp; !(error$1.message </span><span class="s2">in </span><span class="s1">loggedTypeFailures)) {</span>
            <span class="s0">// Only monitor this failure once because there tends to be a lot of the</span>
            <span class="s0">// same error.</span>
            <span class="s1">loggedTypeFailures[error$1.message] = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">setCurrentlyValidatingElement(element);</span>

            <span class="s1">error(</span><span class="s3">'Failed %s type: %s'</span><span class="s1">, location, error$1.message);</span>

            <span class="s1">setCurrentlyValidatingElement(</span><span class="s2">null</span><span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">setCurrentlyValidatingElement$1(element) {</span>
    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(element) {</span>
        <span class="s2">var </span><span class="s1">owner = element._owner;</span>
        <span class="s2">var </span><span class="s1">stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : </span><span class="s2">null</span><span class="s1">);</span>
        <span class="s1">setExtraStackFrame(stack);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">setExtraStackFrame(</span><span class="s2">null</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">propTypesMisspellWarningShown;</span>

  <span class="s1">{</span>
    <span class="s1">propTypesMisspellWarningShown = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">getDeclarationErrorAddendum() {</span>
    <span class="s2">if </span><span class="s1">(ReactCurrentOwner.current) {</span>
      <span class="s2">var </span><span class="s1">name = getComponentNameFromType(ReactCurrentOwner.current.type);</span>

      <span class="s2">if </span><span class="s1">(name) {</span>
        <span class="s2">return </span><span class="s3">'</span><span class="s5">\n\n</span><span class="s3">Check the render method of `' </span><span class="s1">+ name + </span><span class="s3">'`.'</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s3">''</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">getSourceInfoErrorAddendum(source) {</span>
    <span class="s2">if </span><span class="s1">(source !== undefined) {</span>
      <span class="s2">var </span><span class="s1">fileName = source.fileName.replace(/^.*[\\\/]/, </span><span class="s3">''</span><span class="s1">);</span>
      <span class="s2">var </span><span class="s1">lineNumber = source.lineNumber;</span>
      <span class="s2">return </span><span class="s3">'</span><span class="s5">\n\n</span><span class="s3">Check your code at ' </span><span class="s1">+ fileName + </span><span class="s3">':' </span><span class="s1">+ lineNumber + </span><span class="s3">'.'</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s3">''</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">getSourceInfoErrorAddendumForProps(elementProps) {</span>
    <span class="s2">if </span><span class="s1">(elementProps !== </span><span class="s2">null </span><span class="s1">&amp;&amp; elementProps !== undefined) {</span>
      <span class="s2">return </span><span class="s1">getSourceInfoErrorAddendum(elementProps.__source);</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s3">''</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Warn if there's no key explicitly set on dynamic arrays of children or 
   * object keys are not valid. This allows us to keep track of children between 
   * updates. 
   */</span>


  <span class="s2">var </span><span class="s1">ownerHasKeyUseWarning = {};</span>

  <span class="s2">function </span><span class="s1">getCurrentComponentErrorInfo(parentType) {</span>
    <span class="s2">var </span><span class="s1">info = getDeclarationErrorAddendum();</span>

    <span class="s2">if </span><span class="s1">(!info) {</span>
      <span class="s2">var </span><span class="s1">parentName = </span><span class="s2">typeof </span><span class="s1">parentType === </span><span class="s3">'string' </span><span class="s1">? parentType : parentType.displayName || parentType.name;</span>

      <span class="s2">if </span><span class="s1">(parentName) {</span>
        <span class="s1">info = </span><span class="s3">&quot;</span><span class="s5">\n\n</span><span class="s3">Check the top-level render call using &lt;&quot; </span><span class="s1">+ parentName + </span><span class="s3">&quot;&gt;.&quot;</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">info;</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Warn if the element doesn't have an explicit key assigned to it. 
   * This element is in an array. The array could grow and shrink or be 
   * reordered. All children that haven't already been validated are required to 
   * have a &quot;key&quot; property assigned to it. Error statuses are cached so a warning 
   * will only be shown once. 
   * 
   * @internal 
   * @param {ReactElement} element Element that requires a key. 
   * @param {*} parentType element's parent's type. 
   */</span>


  <span class="s2">function </span><span class="s1">validateExplicitKey(element, parentType) {</span>
    <span class="s2">if </span><span class="s1">(!element._store || element._store.validated || element.key != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">element._store.validated = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s2">var </span><span class="s1">currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);</span>

    <span class="s2">if </span><span class="s1">(ownerHasKeyUseWarning[currentComponentErrorInfo]) {</span>
      <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">ownerHasKeyUseWarning[currentComponentErrorInfo] = </span><span class="s2">true</span><span class="s1">; </span><span class="s0">// Usually the current owner is the offender, but if it accepts children as a</span>
    <span class="s0">// property, it may be the creator of the child that's responsible for</span>
    <span class="s0">// assigning it a key.</span>

    <span class="s2">var </span><span class="s1">childOwner = </span><span class="s3">''</span><span class="s1">;</span>

    <span class="s2">if </span><span class="s1">(element &amp;&amp; element._owner &amp;&amp; element._owner !== ReactCurrentOwner.current) {</span>
      <span class="s0">// Give the component that originally created this child.</span>
      <span class="s1">childOwner = </span><span class="s3">&quot; It was passed a child from &quot; </span><span class="s1">+ getComponentNameFromType(element._owner.type) + </span><span class="s3">&quot;.&quot;</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s1">setCurrentlyValidatingElement$1(element);</span>

      <span class="s1">error(</span><span class="s3">'Each child in a list should have a unique &quot;key&quot; prop.' </span><span class="s1">+ </span><span class="s3">'%s%s See https://reactjs.org/link/warning-keys for more information.'</span><span class="s1">, currentComponentErrorInfo, childOwner);</span>

      <span class="s1">setCurrentlyValidatingElement$1(</span><span class="s2">null</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Ensure that every element either is passed in a static location, in an 
   * array with an explicit keys property defined, or in an object literal 
   * with valid key property. 
   * 
   * @internal 
   * @param {ReactNode} node Statically passed child of any type. 
   * @param {*} parentType node's parent's type. 
   */</span>


  <span class="s2">function </span><span class="s1">validateChildKeys(node, parentType) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">node !== </span><span class="s3">'object'</span><span class="s1">) {</span>
      <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(isArray(node)) {</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; node.length; i++) {</span>
        <span class="s2">var </span><span class="s1">child = node[i];</span>

        <span class="s2">if </span><span class="s1">(isValidElement(child)) {</span>
          <span class="s1">validateExplicitKey(child, parentType);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isValidElement(node)) {</span>
      <span class="s0">// This element was passed in a valid location.</span>
      <span class="s2">if </span><span class="s1">(node._store) {</span>
        <span class="s1">node._store.validated = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(node) {</span>
      <span class="s2">var </span><span class="s1">iteratorFn = getIteratorFn(node);</span>

      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">iteratorFn === </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s0">// Entry iterators used to provide implicit keys,</span>
        <span class="s0">// but now we print a separate warning for them later.</span>
        <span class="s2">if </span><span class="s1">(iteratorFn !== node.entries) {</span>
          <span class="s2">var </span><span class="s1">iterator = iteratorFn.call(node);</span>
          <span class="s2">var </span><span class="s1">step;</span>

          <span class="s2">while </span><span class="s1">(!(step = iterator.next()).done) {</span>
            <span class="s2">if </span><span class="s1">(isValidElement(step.value)) {</span>
              <span class="s1">validateExplicitKey(step.value, parentType);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Given an element, validate that its props follow the propTypes definition, 
   * provided by the type. 
   * 
   * @param {ReactElement} element 
   */</span>


  <span class="s2">function </span><span class="s1">validatePropTypes(element) {</span>
    <span class="s1">{</span>
      <span class="s2">var </span><span class="s1">type = element.type;</span>

      <span class="s2">if </span><span class="s1">(type === </span><span class="s2">null </span><span class="s1">|| type === undefined || </span><span class="s2">typeof </span><span class="s1">type === </span><span class="s3">'string'</span><span class="s1">) {</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">propTypes;</span>

      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">type === </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s1">propTypes = type.propTypes;</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">type === </span><span class="s3">'object' </span><span class="s1">&amp;&amp; (type.$$typeof === REACT_FORWARD_REF_TYPE || </span><span class="s0">// Note: Memo only checks outer props here.</span>
      <span class="s0">// Inner props are checked in the reconciler.</span>
      <span class="s1">type.$$typeof === REACT_MEMO_TYPE)) {</span>
        <span class="s1">propTypes = type.propTypes;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(propTypes) {</span>
        <span class="s0">// Intentionally inside to avoid triggering lazy initializers:</span>
        <span class="s2">var </span><span class="s1">name = getComponentNameFromType(type);</span>
        <span class="s1">checkPropTypes(propTypes, element.props, </span><span class="s3">'prop'</span><span class="s1">, name, element);</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(type.PropTypes !== undefined &amp;&amp; !propTypesMisspellWarningShown) {</span>
        <span class="s1">propTypesMisspellWarningShown = </span><span class="s2">true</span><span class="s1">; </span><span class="s0">// Intentionally inside to avoid triggering lazy initializers:</span>

        <span class="s2">var </span><span class="s1">_name = getComponentNameFromType(type);</span>

        <span class="s1">error(</span><span class="s3">'Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?'</span><span class="s1">, _name || </span><span class="s3">'Unknown'</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">type.getDefaultProps === </span><span class="s3">'function' </span><span class="s1">&amp;&amp; !type.getDefaultProps.isReactClassApproved) {</span>
        <span class="s1">error(</span><span class="s3">'getDefaultProps is only used on classic React.createClass ' </span><span class="s1">+ </span><span class="s3">'definitions. Use a static property named `defaultProps` instead.'</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Given a fragment, validate that it can only be provided with fragment props 
   * @param {ReactElement} fragment 
   */</span>


  <span class="s2">function </span><span class="s1">validateFragmentProps(fragment) {</span>
    <span class="s1">{</span>
      <span class="s2">var </span><span class="s1">keys = Object.keys(fragment.props);</span>

      <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; keys.length; i++) {</span>
        <span class="s2">var </span><span class="s1">key = keys[i];</span>

        <span class="s2">if </span><span class="s1">(key !== </span><span class="s3">'children' </span><span class="s1">&amp;&amp; key !== </span><span class="s3">'key'</span><span class="s1">) {</span>
          <span class="s1">setCurrentlyValidatingElement$1(fragment);</span>

          <span class="s1">error(</span><span class="s3">'Invalid prop `%s` supplied to `React.Fragment`. ' </span><span class="s1">+ </span><span class="s3">'React.Fragment can only have `key` and `children` props.'</span><span class="s1">, key);</span>

          <span class="s1">setCurrentlyValidatingElement$1(</span><span class="s2">null</span><span class="s1">);</span>
          <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(fragment.ref !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">setCurrentlyValidatingElement$1(fragment);</span>

        <span class="s1">error(</span><span class="s3">'Invalid attribute `ref` supplied to `React.Fragment`.'</span><span class="s1">);</span>

        <span class="s1">setCurrentlyValidatingElement$1(</span><span class="s2">null</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">createElementWithValidation(type, props, children) {</span>
    <span class="s2">var </span><span class="s1">validType = isValidElementType(type); </span><span class="s0">// We warn in this case but don't throw. We expect the element creation to</span>
    <span class="s0">// succeed and there will likely be errors in render.</span>

    <span class="s2">if </span><span class="s1">(!validType) {</span>
      <span class="s2">var </span><span class="s1">info = </span><span class="s3">''</span><span class="s1">;</span>

      <span class="s2">if </span><span class="s1">(type === undefined || </span><span class="s2">typeof </span><span class="s1">type === </span><span class="s3">'object' </span><span class="s1">&amp;&amp; type !== </span><span class="s2">null </span><span class="s1">&amp;&amp; Object.keys(type).length === </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">info += </span><span class="s3">' You likely forgot to export your component from the file ' </span><span class="s1">+ </span><span class="s3">&quot;it's defined in, or you might have mixed up default and named imports.&quot;</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">sourceInfo = getSourceInfoErrorAddendumForProps(props);</span>

      <span class="s2">if </span><span class="s1">(sourceInfo) {</span>
        <span class="s1">info += sourceInfo;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">info += getDeclarationErrorAddendum();</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">typeString;</span>

      <span class="s2">if </span><span class="s1">(type === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">typeString = </span><span class="s3">'null'</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isArray(type)) {</span>
        <span class="s1">typeString = </span><span class="s3">'array'</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(type !== undefined &amp;&amp; type.$$typeof === REACT_ELEMENT_TYPE) {</span>
        <span class="s1">typeString = </span><span class="s3">&quot;&lt;&quot; </span><span class="s1">+ (getComponentNameFromType(type.type) || </span><span class="s3">'Unknown'</span><span class="s1">) + </span><span class="s3">&quot; /&gt;&quot;</span><span class="s1">;</span>
        <span class="s1">info = </span><span class="s3">' Did you accidentally export a JSX literal instead of a component?'</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">typeString = </span><span class="s2">typeof </span><span class="s1">type;</span>
      <span class="s1">}</span>

      <span class="s1">{</span>
        <span class="s1">error(</span><span class="s3">'React.createElement: type is invalid -- expected a string (for ' </span><span class="s1">+ </span><span class="s3">'built-in components) or a class/function (for composite ' </span><span class="s1">+ </span><span class="s3">'components) but got: %s.%s'</span><span class="s1">, typeString, info);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">element = createElement.apply(</span><span class="s2">this</span><span class="s1">, arguments); </span><span class="s0">// The result can be nullish if a mock or a custom function is used.</span>
    <span class="s0">// TODO: Drop this when these are no longer allowed as the type argument.</span>

    <span class="s2">if </span><span class="s1">(element == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">element;</span>
    <span class="s1">} </span><span class="s0">// Skip key warning if the type isn't valid since our key validation logic</span>
    <span class="s0">// doesn't expect a non-string/function type and can throw confusing errors.</span>
    <span class="s0">// We don't want exception behavior to differ between dev and prod.</span>
    <span class="s0">// (Rendering will throw with a helpful message and as soon as the type is</span>
    <span class="s0">// fixed, the key warnings will appear.)</span>


    <span class="s2">if </span><span class="s1">(validType) {</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">2</span><span class="s1">; i &lt; arguments.length; i++) {</span>
        <span class="s1">validateChildKeys(arguments[i], type);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(type === REACT_FRAGMENT_TYPE) {</span>
      <span class="s1">validateFragmentProps(element);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">validatePropTypes(element);</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">element;</span>
  <span class="s1">}</span>
  <span class="s2">var </span><span class="s1">didWarnAboutDeprecatedCreateFactory = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s2">function </span><span class="s1">createFactoryWithValidation(type) {</span>
    <span class="s2">var </span><span class="s1">validatedFactory = createElementWithValidation.bind(</span><span class="s2">null</span><span class="s1">, type);</span>
    <span class="s1">validatedFactory.type = type;</span>

    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(!didWarnAboutDeprecatedCreateFactory) {</span>
        <span class="s1">didWarnAboutDeprecatedCreateFactory = </span><span class="s2">true</span><span class="s1">;</span>

        <span class="s1">warn(</span><span class="s3">'React.createFactory() is deprecated and will be removed in ' </span><span class="s1">+ </span><span class="s3">'a future major release. Consider using JSX ' </span><span class="s1">+ </span><span class="s3">'or use React.createElement() directly instead.'</span><span class="s1">);</span>
      <span class="s1">} </span><span class="s0">// Legacy hook: remove it</span>


      <span class="s1">Object.defineProperty(validatedFactory, </span><span class="s3">'type'</span><span class="s1">, {</span>
        <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
        <span class="s1">get: </span><span class="s2">function </span><span class="s1">() {</span>
          <span class="s1">warn(</span><span class="s3">'Factory.type is deprecated. Access the class directly ' </span><span class="s1">+ </span><span class="s3">'before passing it to createFactory.'</span><span class="s1">);</span>

          <span class="s1">Object.defineProperty(</span><span class="s2">this</span><span class="s1">, </span><span class="s3">'type'</span><span class="s1">, {</span>
            <span class="s1">value: type</span>
          <span class="s1">});</span>
          <span class="s2">return </span><span class="s1">type;</span>
        <span class="s1">}</span>
      <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">validatedFactory;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">cloneElementWithValidation(element, props, children) {</span>
    <span class="s2">var </span><span class="s1">newElement = cloneElement.apply(</span><span class="s2">this</span><span class="s1">, arguments);</span>

    <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">2</span><span class="s1">; i &lt; arguments.length; i++) {</span>
      <span class="s1">validateChildKeys(arguments[i], newElement.type);</span>
    <span class="s1">}</span>

    <span class="s1">validatePropTypes(newElement);</span>
    <span class="s2">return </span><span class="s1">newElement;</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">enableSchedulerDebugging = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">enableProfiling = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">frameYieldMs = </span><span class="s4">5</span><span class="s1">;</span>

  <span class="s2">function </span><span class="s1">push(heap, node) {</span>
    <span class="s2">var </span><span class="s1">index = heap.length;</span>
    <span class="s1">heap.push(node);</span>
    <span class="s1">siftUp(heap, node, index);</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">peek(heap) {</span>
    <span class="s2">return </span><span class="s1">heap.length === </span><span class="s4">0 </span><span class="s1">? </span><span class="s2">null </span><span class="s1">: heap[</span><span class="s4">0</span><span class="s1">];</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">pop(heap) {</span>
    <span class="s2">if </span><span class="s1">(heap.length === </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">first = heap[</span><span class="s4">0</span><span class="s1">];</span>
    <span class="s2">var </span><span class="s1">last = heap.pop();</span>

    <span class="s2">if </span><span class="s1">(last !== first) {</span>
      <span class="s1">heap[</span><span class="s4">0</span><span class="s1">] = last;</span>
      <span class="s1">siftDown(heap, last, </span><span class="s4">0</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">first;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">siftUp(heap, node, i) {</span>
    <span class="s2">var </span><span class="s1">index = i;</span>

    <span class="s2">while </span><span class="s1">(index &gt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">parentIndex = index - </span><span class="s4">1 </span><span class="s1">&gt;&gt;&gt; </span><span class="s4">1</span><span class="s1">;</span>
      <span class="s2">var </span><span class="s1">parent = heap[parentIndex];</span>

      <span class="s2">if </span><span class="s1">(compare(parent, node) &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s0">// The parent is larger. Swap positions.</span>
        <span class="s1">heap[parentIndex] = node;</span>
        <span class="s1">heap[index] = parent;</span>
        <span class="s1">index = parentIndex;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s0">// The parent is smaller. Exit.</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">siftDown(heap, node, i) {</span>
    <span class="s2">var </span><span class="s1">index = i;</span>
    <span class="s2">var </span><span class="s1">length = heap.length;</span>
    <span class="s2">var </span><span class="s1">halfLength = length &gt;&gt;&gt; </span><span class="s4">1</span><span class="s1">;</span>

    <span class="s2">while </span><span class="s1">(index &lt; halfLength) {</span>
      <span class="s2">var </span><span class="s1">leftIndex = (index + </span><span class="s4">1</span><span class="s1">) * </span><span class="s4">2 </span><span class="s1">- </span><span class="s4">1</span><span class="s1">;</span>
      <span class="s2">var </span><span class="s1">left = heap[leftIndex];</span>
      <span class="s2">var </span><span class="s1">rightIndex = leftIndex + </span><span class="s4">1</span><span class="s1">;</span>
      <span class="s2">var </span><span class="s1">right = heap[rightIndex]; </span><span class="s0">// If the left or right node is smaller, swap with the smaller of those.</span>

      <span class="s2">if </span><span class="s1">(compare(left, node) &lt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(rightIndex &lt; length &amp;&amp; compare(right, left) &lt; </span><span class="s4">0</span><span class="s1">) {</span>
          <span class="s1">heap[index] = right;</span>
          <span class="s1">heap[rightIndex] = node;</span>
          <span class="s1">index = rightIndex;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">heap[index] = left;</span>
          <span class="s1">heap[leftIndex] = node;</span>
          <span class="s1">index = leftIndex;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(rightIndex &lt; length &amp;&amp; compare(right, node) &lt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">heap[index] = right;</span>
        <span class="s1">heap[rightIndex] = node;</span>
        <span class="s1">index = rightIndex;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s0">// Neither child is smaller. Exit.</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">compare(a, b) {</span>
    <span class="s0">// Compare sort index first, then task id.</span>
    <span class="s2">var </span><span class="s1">diff = a.sortIndex - b.sortIndex;</span>
    <span class="s2">return </span><span class="s1">diff !== </span><span class="s4">0 </span><span class="s1">? diff : a.id - b.id;</span>
  <span class="s1">}</span>

  <span class="s0">// TODO: Use symbols?</span>
  <span class="s2">var </span><span class="s1">ImmediatePriority = </span><span class="s4">1</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">UserBlockingPriority = </span><span class="s4">2</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">NormalPriority = </span><span class="s4">3</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">LowPriority = </span><span class="s4">4</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">IdlePriority = </span><span class="s4">5</span><span class="s1">;</span>

  <span class="s2">function </span><span class="s1">markTaskErrored(task, ms) {</span>
  <span class="s1">}</span>

  <span class="s0">/* eslint-disable no-var */</span>
  <span class="s2">var </span><span class="s1">getCurrentTime;</span>
  <span class="s2">var </span><span class="s1">hasPerformanceNow = </span><span class="s2">typeof </span><span class="s1">performance === </span><span class="s3">'object' </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">performance.now === </span><span class="s3">'function'</span><span class="s1">;</span>

  <span class="s2">if </span><span class="s1">(hasPerformanceNow) {</span>
    <span class="s2">var </span><span class="s1">localPerformance = performance;</span>

    <span class="s1">getCurrentTime = </span><span class="s2">function </span><span class="s1">() {</span>
      <span class="s2">return </span><span class="s1">localPerformance.now();</span>
    <span class="s1">};</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s2">var </span><span class="s1">localDate = Date;</span>
    <span class="s2">var </span><span class="s1">initialTime = localDate.now();</span>

    <span class="s1">getCurrentTime = </span><span class="s2">function </span><span class="s1">() {</span>
      <span class="s2">return </span><span class="s1">localDate.now() - initialTime;</span>
    <span class="s1">};</span>
  <span class="s1">} </span><span class="s0">// Max 31 bit integer. The max integer size in V8 for 32-bit systems.</span>
  <span class="s0">// Math.pow(2, 30) - 1</span>
  <span class="s0">// 0b111111111111111111111111111111</span>


  <span class="s2">var </span><span class="s1">maxSigned31BitInt = </span><span class="s4">1073741823</span><span class="s1">; </span><span class="s0">// Times out immediately</span>

  <span class="s2">var </span><span class="s1">IMMEDIATE_PRIORITY_TIMEOUT = -</span><span class="s4">1</span><span class="s1">; </span><span class="s0">// Eventually times out</span>

  <span class="s2">var </span><span class="s1">USER_BLOCKING_PRIORITY_TIMEOUT = </span><span class="s4">250</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">NORMAL_PRIORITY_TIMEOUT = </span><span class="s4">5000</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">LOW_PRIORITY_TIMEOUT = </span><span class="s4">10000</span><span class="s1">; </span><span class="s0">// Never times out</span>

  <span class="s2">var </span><span class="s1">IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt; </span><span class="s0">// Tasks are stored on a min heap</span>

  <span class="s2">var </span><span class="s1">taskQueue = [];</span>
  <span class="s2">var </span><span class="s1">timerQueue = []; </span><span class="s0">// Incrementing id counter. Used to maintain insertion order.</span>

  <span class="s2">var </span><span class="s1">taskIdCounter = </span><span class="s4">1</span><span class="s1">; </span><span class="s0">// Pausing the scheduler is useful for debugging.</span>
  <span class="s2">var </span><span class="s1">currentTask = </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">currentPriorityLevel = NormalPriority; </span><span class="s0">// This is set while performing work, to prevent re-entrance.</span>

  <span class="s2">var </span><span class="s1">isPerformingWork = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">isHostCallbackScheduled = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">isHostTimeoutScheduled = </span><span class="s2">false</span><span class="s1">; </span><span class="s0">// Capture local references to native APIs, in case a polyfill overrides them.</span>

  <span class="s2">var </span><span class="s1">localSetTimeout = </span><span class="s2">typeof </span><span class="s1">setTimeout === </span><span class="s3">'function' </span><span class="s1">? setTimeout : </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">localClearTimeout = </span><span class="s2">typeof </span><span class="s1">clearTimeout === </span><span class="s3">'function' </span><span class="s1">? clearTimeout : </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">localSetImmediate = </span><span class="s2">typeof </span><span class="s1">setImmediate !== </span><span class="s3">'undefined' </span><span class="s1">? setImmediate : </span><span class="s2">null</span><span class="s1">; </span><span class="s0">// IE and Node.js + jsdom</span>

  <span class="s2">var </span><span class="s1">isInputPending = </span><span class="s2">typeof </span><span class="s1">navigator !== </span><span class="s3">'undefined' </span><span class="s1">&amp;&amp; navigator.scheduling !== undefined &amp;&amp; navigator.scheduling.isInputPending !== undefined ? navigator.scheduling.isInputPending.bind(navigator.scheduling) : </span><span class="s2">null</span><span class="s1">;</span>

  <span class="s2">function </span><span class="s1">advanceTimers(currentTime) {</span>
    <span class="s0">// Check for tasks that are no longer delayed and add them to the queue.</span>
    <span class="s2">var </span><span class="s1">timer = peek(timerQueue);</span>

    <span class="s2">while </span><span class="s1">(timer !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(timer.callback === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s0">// Timer was cancelled.</span>
        <span class="s1">pop(timerQueue);</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(timer.startTime &lt;= currentTime) {</span>
        <span class="s0">// Timer fired. Transfer to the task queue.</span>
        <span class="s1">pop(timerQueue);</span>
        <span class="s1">timer.sortIndex = timer.expirationTime;</span>
        <span class="s1">push(taskQueue, timer);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s0">// Remaining timers are pending.</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">timer = peek(timerQueue);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">handleTimeout(currentTime) {</span>
    <span class="s1">isHostTimeoutScheduled = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">advanceTimers(currentTime);</span>

    <span class="s2">if </span><span class="s1">(!isHostCallbackScheduled) {</span>
      <span class="s2">if </span><span class="s1">(peek(taskQueue) !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">isHostCallbackScheduled = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">requestHostCallback(flushWork);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">var </span><span class="s1">firstTimer = peek(timerQueue);</span>

        <span class="s2">if </span><span class="s1">(firstTimer !== </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">flushWork(hasTimeRemaining, initialTime) {</span>


    <span class="s1">isHostCallbackScheduled = </span><span class="s2">false</span><span class="s1">;</span>

    <span class="s2">if </span><span class="s1">(isHostTimeoutScheduled) {</span>
      <span class="s0">// We scheduled a timeout but it's no longer needed. Cancel it.</span>
      <span class="s1">isHostTimeoutScheduled = </span><span class="s2">false</span><span class="s1">;</span>
      <span class="s1">cancelHostTimeout();</span>
    <span class="s1">}</span>

    <span class="s1">isPerformingWork = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s2">var </span><span class="s1">previousPriorityLevel = currentPriorityLevel;</span>

    <span class="s2">try </span><span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(enableProfiling) {</span>
        <span class="s2">try </span><span class="s1">{</span>
          <span class="s2">return </span><span class="s1">workLoop(hasTimeRemaining, initialTime);</span>
        <span class="s1">} </span><span class="s2">catch </span><span class="s1">(error) {</span>
          <span class="s2">if </span><span class="s1">(currentTask !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">var </span><span class="s1">currentTime = getCurrentTime();</span>
            <span class="s1">markTaskErrored(currentTask, currentTime);</span>
            <span class="s1">currentTask.isQueued = </span><span class="s2">false</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s2">throw </span><span class="s1">error;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s0">// No catch in prod code path.</span>
        <span class="s2">return </span><span class="s1">workLoop(hasTimeRemaining, initialTime);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
      <span class="s1">currentTask = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">currentPriorityLevel = previousPriorityLevel;</span>
      <span class="s1">isPerformingWork = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">workLoop(hasTimeRemaining, initialTime) {</span>
    <span class="s2">var </span><span class="s1">currentTime = initialTime;</span>
    <span class="s1">advanceTimers(currentTime);</span>
    <span class="s1">currentTask = peek(taskQueue);</span>

    <span class="s2">while </span><span class="s1">(currentTask !== </span><span class="s2">null </span><span class="s1">&amp;&amp; !(enableSchedulerDebugging )) {</span>
      <span class="s2">if </span><span class="s1">(currentTask.expirationTime &gt; currentTime &amp;&amp; (!hasTimeRemaining || shouldYieldToHost())) {</span>
        <span class="s0">// This currentTask hasn't expired, and we've reached the deadline.</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">callback = currentTask.callback;</span>

      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">callback === </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s1">currentTask.callback = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s1">currentPriorityLevel = currentTask.priorityLevel;</span>
        <span class="s2">var </span><span class="s1">didUserCallbackTimeout = currentTask.expirationTime &lt;= currentTime;</span>

        <span class="s2">var </span><span class="s1">continuationCallback = callback(didUserCallbackTimeout);</span>
        <span class="s1">currentTime = getCurrentTime();</span>

        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">continuationCallback === </span><span class="s3">'function'</span><span class="s1">) {</span>
          <span class="s1">currentTask.callback = continuationCallback;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>

          <span class="s2">if </span><span class="s1">(currentTask === peek(taskQueue)) {</span>
            <span class="s1">pop(taskQueue);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s1">advanceTimers(currentTime);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">pop(taskQueue);</span>
      <span class="s1">}</span>

      <span class="s1">currentTask = peek(taskQueue);</span>
    <span class="s1">} </span><span class="s0">// Return whether there's additional work</span>


    <span class="s2">if </span><span class="s1">(currentTask !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">var </span><span class="s1">firstTimer = peek(timerQueue);</span>

      <span class="s2">if </span><span class="s1">(firstTimer !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);</span>
      <span class="s1">}</span>

      <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">unstable_runWithPriority(priorityLevel, eventHandler) {</span>
    <span class="s2">switch </span><span class="s1">(priorityLevel) {</span>
      <span class="s2">case </span><span class="s1">ImmediatePriority:</span>
      <span class="s2">case </span><span class="s1">UserBlockingPriority:</span>
      <span class="s2">case </span><span class="s1">NormalPriority:</span>
      <span class="s2">case </span><span class="s1">LowPriority:</span>
      <span class="s2">case </span><span class="s1">IdlePriority:</span>
        <span class="s2">break</span><span class="s1">;</span>

      <span class="s2">default</span><span class="s1">:</span>
        <span class="s1">priorityLevel = NormalPriority;</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">previousPriorityLevel = currentPriorityLevel;</span>
    <span class="s1">currentPriorityLevel = priorityLevel;</span>

    <span class="s2">try </span><span class="s1">{</span>
      <span class="s2">return </span><span class="s1">eventHandler();</span>
    <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
      <span class="s1">currentPriorityLevel = previousPriorityLevel;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">unstable_next(eventHandler) {</span>
    <span class="s2">var </span><span class="s1">priorityLevel;</span>

    <span class="s2">switch </span><span class="s1">(currentPriorityLevel) {</span>
      <span class="s2">case </span><span class="s1">ImmediatePriority:</span>
      <span class="s2">case </span><span class="s1">UserBlockingPriority:</span>
      <span class="s2">case </span><span class="s1">NormalPriority:</span>
        <span class="s0">// Shift down to normal priority</span>
        <span class="s1">priorityLevel = NormalPriority;</span>
        <span class="s2">break</span><span class="s1">;</span>

      <span class="s2">default</span><span class="s1">:</span>
        <span class="s0">// Anything lower than normal priority should remain at the current level.</span>
        <span class="s1">priorityLevel = currentPriorityLevel;</span>
        <span class="s2">break</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">previousPriorityLevel = currentPriorityLevel;</span>
    <span class="s1">currentPriorityLevel = priorityLevel;</span>

    <span class="s2">try </span><span class="s1">{</span>
      <span class="s2">return </span><span class="s1">eventHandler();</span>
    <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
      <span class="s1">currentPriorityLevel = previousPriorityLevel;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">unstable_wrapCallback(callback) {</span>
    <span class="s2">var </span><span class="s1">parentPriorityLevel = currentPriorityLevel;</span>
    <span class="s2">return function </span><span class="s1">() {</span>
      <span class="s0">// This is a fork of runWithPriority, inlined for performance.</span>
      <span class="s2">var </span><span class="s1">previousPriorityLevel = currentPriorityLevel;</span>
      <span class="s1">currentPriorityLevel = parentPriorityLevel;</span>

      <span class="s2">try </span><span class="s1">{</span>
        <span class="s2">return </span><span class="s1">callback.apply(</span><span class="s2">this</span><span class="s1">, arguments);</span>
      <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
        <span class="s1">currentPriorityLevel = previousPriorityLevel;</span>
      <span class="s1">}</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">unstable_scheduleCallback(priorityLevel, callback, options) {</span>
    <span class="s2">var </span><span class="s1">currentTime = getCurrentTime();</span>
    <span class="s2">var </span><span class="s1">startTime;</span>

    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">options === </span><span class="s3">'object' </span><span class="s1">&amp;&amp; options !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">delay = options.delay;</span>

      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">delay === </span><span class="s3">'number' </span><span class="s1">&amp;&amp; delay &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">startTime = currentTime + delay;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">startTime = currentTime;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">startTime = currentTime;</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">timeout;</span>

    <span class="s2">switch </span><span class="s1">(priorityLevel) {</span>
      <span class="s2">case </span><span class="s1">ImmediatePriority:</span>
        <span class="s1">timeout = IMMEDIATE_PRIORITY_TIMEOUT;</span>
        <span class="s2">break</span><span class="s1">;</span>

      <span class="s2">case </span><span class="s1">UserBlockingPriority:</span>
        <span class="s1">timeout = USER_BLOCKING_PRIORITY_TIMEOUT;</span>
        <span class="s2">break</span><span class="s1">;</span>

      <span class="s2">case </span><span class="s1">IdlePriority:</span>
        <span class="s1">timeout = IDLE_PRIORITY_TIMEOUT;</span>
        <span class="s2">break</span><span class="s1">;</span>

      <span class="s2">case </span><span class="s1">LowPriority:</span>
        <span class="s1">timeout = LOW_PRIORITY_TIMEOUT;</span>
        <span class="s2">break</span><span class="s1">;</span>

      <span class="s2">case </span><span class="s1">NormalPriority:</span>
      <span class="s2">default</span><span class="s1">:</span>
        <span class="s1">timeout = NORMAL_PRIORITY_TIMEOUT;</span>
        <span class="s2">break</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">expirationTime = startTime + timeout;</span>
    <span class="s2">var </span><span class="s1">newTask = {</span>
      <span class="s1">id: taskIdCounter++,</span>
      <span class="s1">callback: callback,</span>
      <span class="s1">priorityLevel: priorityLevel,</span>
      <span class="s1">startTime: startTime,</span>
      <span class="s1">expirationTime: expirationTime,</span>
      <span class="s1">sortIndex: -</span><span class="s4">1</span>
    <span class="s1">};</span>

    <span class="s2">if </span><span class="s1">(startTime &gt; currentTime) {</span>
      <span class="s0">// This is a delayed task.</span>
      <span class="s1">newTask.sortIndex = startTime;</span>
      <span class="s1">push(timerQueue, newTask);</span>

      <span class="s2">if </span><span class="s1">(peek(taskQueue) === </span><span class="s2">null </span><span class="s1">&amp;&amp; newTask === peek(timerQueue)) {</span>
        <span class="s0">// All tasks are delayed, and this is the task with the earliest delay.</span>
        <span class="s2">if </span><span class="s1">(isHostTimeoutScheduled) {</span>
          <span class="s0">// Cancel an existing timeout.</span>
          <span class="s1">cancelHostTimeout();</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">isHostTimeoutScheduled = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s0">// Schedule a timeout.</span>


        <span class="s1">requestHostTimeout(handleTimeout, startTime - currentTime);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">newTask.sortIndex = expirationTime;</span>
      <span class="s1">push(taskQueue, newTask);</span>
      <span class="s0">// wait until the next time we yield.</span>


      <span class="s2">if </span><span class="s1">(!isHostCallbackScheduled &amp;&amp; !isPerformingWork) {</span>
        <span class="s1">isHostCallbackScheduled = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">requestHostCallback(flushWork);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">newTask;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">unstable_pauseExecution() {</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">unstable_continueExecution() {</span>

    <span class="s2">if </span><span class="s1">(!isHostCallbackScheduled &amp;&amp; !isPerformingWork) {</span>
      <span class="s1">isHostCallbackScheduled = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s1">requestHostCallback(flushWork);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">unstable_getFirstCallbackNode() {</span>
    <span class="s2">return </span><span class="s1">peek(taskQueue);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">unstable_cancelCallback(task) {</span>
    <span class="s0">// remove from the queue because you can't remove arbitrary nodes from an</span>
    <span class="s0">// array based heap, only the first one.)</span>


    <span class="s1">task.callback = </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">unstable_getCurrentPriorityLevel() {</span>
    <span class="s2">return </span><span class="s1">currentPriorityLevel;</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">isMessageLoopRunning = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">scheduledHostCallback = </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">taskTimeoutID = -</span><span class="s4">1</span><span class="s1">; </span><span class="s0">// Scheduler periodically yields in case there is other work on the main</span>
  <span class="s0">// thread, like user events. By default, it yields multiple times per frame.</span>
  <span class="s0">// It does not attempt to align with frame boundaries, since most tasks don't</span>
  <span class="s0">// need to be frame aligned; for those that do, use requestAnimationFrame.</span>

  <span class="s2">var </span><span class="s1">frameInterval = frameYieldMs;</span>
  <span class="s2">var </span><span class="s1">startTime = -</span><span class="s4">1</span><span class="s1">;</span>

  <span class="s2">function </span><span class="s1">shouldYieldToHost() {</span>
    <span class="s2">var </span><span class="s1">timeElapsed = getCurrentTime() - startTime;</span>

    <span class="s2">if </span><span class="s1">(timeElapsed &lt; frameInterval) {</span>
      <span class="s0">// The main thread has only been blocked for a really short amount of time;</span>
      <span class="s0">// smaller than a single frame. Don't yield yet.</span>
      <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s0">// The main thread has been blocked for a non-negligible amount of time. We</span>


    <span class="s2">return true</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">requestPaint() {</span>

  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">forceFrameRate(fps) {</span>
    <span class="s2">if </span><span class="s1">(fps &lt; </span><span class="s4">0 </span><span class="s1">|| fps &gt; </span><span class="s4">125</span><span class="s1">) {</span>
      <span class="s0">// Using console['error'] to evade Babel and ESLint</span>
      <span class="s1">console[</span><span class="s3">'error'</span><span class="s1">](</span><span class="s3">'forceFrameRate takes a positive int between 0 and 125, ' </span><span class="s1">+ </span><span class="s3">'forcing frame rates higher than 125 fps is not supported'</span><span class="s1">);</span>
      <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(fps &gt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s1">frameInterval = Math.floor(</span><span class="s4">1000 </span><span class="s1">/ fps);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s0">// reset the framerate</span>
      <span class="s1">frameInterval = frameYieldMs;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">performWorkUntilDeadline = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">if </span><span class="s1">(scheduledHostCallback !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">currentTime = getCurrentTime(); </span><span class="s0">// Keep track of the start time so we can measure how long the main thread</span>
      <span class="s0">// has been blocked.</span>

      <span class="s1">startTime = currentTime;</span>
      <span class="s2">var </span><span class="s1">hasTimeRemaining = </span><span class="s2">true</span><span class="s1">; </span><span class="s0">// If a scheduler task throws, exit the current browser task so the</span>
      <span class="s0">// error can be observed.</span>
      <span class="s0">//</span>
      <span class="s0">// Intentionally not using a try-catch, since that makes some debugging</span>
      <span class="s0">// techniques harder. Instead, if `scheduledHostCallback` errors, then</span>
      <span class="s0">// `hasMoreWork` will remain true, and we'll continue the work loop.</span>

      <span class="s2">var </span><span class="s1">hasMoreWork = </span><span class="s2">true</span><span class="s1">;</span>

      <span class="s2">try </span><span class="s1">{</span>
        <span class="s1">hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);</span>
      <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(hasMoreWork) {</span>
          <span class="s0">// If there's more work, schedule the next message event at the end</span>
          <span class="s0">// of the preceding one.</span>
          <span class="s1">schedulePerformWorkUntilDeadline();</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">isMessageLoopRunning = </span><span class="s2">false</span><span class="s1">;</span>
          <span class="s1">scheduledHostCallback = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">isMessageLoopRunning = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s0">// Yielding to the browser will give it a chance to paint, so we can</span>
  <span class="s1">};</span>

  <span class="s2">var </span><span class="s1">schedulePerformWorkUntilDeadline;</span>

  <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">localSetImmediate === </span><span class="s3">'function'</span><span class="s1">) {</span>
    <span class="s0">// Node.js and old IE.</span>
    <span class="s0">// There's a few reasons for why we prefer setImmediate.</span>
    <span class="s0">//</span>
    <span class="s0">// Unlike MessageChannel, it doesn't prevent a Node.js process from exiting.</span>
    <span class="s0">// (Even though this is a DOM fork of the Scheduler, you could get here</span>
    <span class="s0">// with a mix of Node.js 15+, which has a MessageChannel, and jsdom.)</span>
    <span class="s0">// https://github.com/facebook/react/issues/20756</span>
    <span class="s0">//</span>
    <span class="s0">// But also, it runs earlier which is the semantic we want.</span>
    <span class="s0">// If other browsers ever implement it, it's better to use it.</span>
    <span class="s0">// Although both of these would be inferior to native scheduling.</span>
    <span class="s1">schedulePerformWorkUntilDeadline = </span><span class="s2">function </span><span class="s1">() {</span>
      <span class="s1">localSetImmediate(performWorkUntilDeadline);</span>
    <span class="s1">};</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">MessageChannel !== </span><span class="s3">'undefined'</span><span class="s1">) {</span>
    <span class="s0">// DOM and Worker environments.</span>
    <span class="s0">// We prefer MessageChannel because of the 4ms setTimeout clamping.</span>
    <span class="s2">var </span><span class="s1">channel = </span><span class="s2">new </span><span class="s1">MessageChannel();</span>
    <span class="s2">var </span><span class="s1">port = channel.port2;</span>
    <span class="s1">channel.port1.onmessage = performWorkUntilDeadline;</span>

    <span class="s1">schedulePerformWorkUntilDeadline = </span><span class="s2">function </span><span class="s1">() {</span>
      <span class="s1">port.postMessage(</span><span class="s2">null</span><span class="s1">);</span>
    <span class="s1">};</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s0">// We should only fallback here in non-browser environments.</span>
    <span class="s1">schedulePerformWorkUntilDeadline = </span><span class="s2">function </span><span class="s1">() {</span>
      <span class="s1">localSetTimeout(performWorkUntilDeadline, </span><span class="s4">0</span><span class="s1">);</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">requestHostCallback(callback) {</span>
    <span class="s1">scheduledHostCallback = callback;</span>

    <span class="s2">if </span><span class="s1">(!isMessageLoopRunning) {</span>
      <span class="s1">isMessageLoopRunning = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s1">schedulePerformWorkUntilDeadline();</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">requestHostTimeout(callback, ms) {</span>
    <span class="s1">taskTimeoutID = localSetTimeout(</span><span class="s2">function </span><span class="s1">() {</span>
      <span class="s1">callback(getCurrentTime());</span>
    <span class="s1">}, ms);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">cancelHostTimeout() {</span>
    <span class="s1">localClearTimeout(taskTimeoutID);</span>
    <span class="s1">taskTimeoutID = -</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">unstable_requestPaint = requestPaint;</span>
  <span class="s2">var </span><span class="s1">unstable_Profiling =  </span><span class="s2">null</span><span class="s1">;</span>



  <span class="s2">var </span><span class="s1">Scheduler = </span><span class="s0">/*#__PURE__*/</span><span class="s1">Object.freeze({</span>
    <span class="s1">__proto__: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">unstable_ImmediatePriority: ImmediatePriority,</span>
    <span class="s1">unstable_UserBlockingPriority: UserBlockingPriority,</span>
    <span class="s1">unstable_NormalPriority: NormalPriority,</span>
    <span class="s1">unstable_IdlePriority: IdlePriority,</span>
    <span class="s1">unstable_LowPriority: LowPriority,</span>
    <span class="s1">unstable_runWithPriority: unstable_runWithPriority,</span>
    <span class="s1">unstable_next: unstable_next,</span>
    <span class="s1">unstable_scheduleCallback: unstable_scheduleCallback,</span>
    <span class="s1">unstable_cancelCallback: unstable_cancelCallback,</span>
    <span class="s1">unstable_wrapCallback: unstable_wrapCallback,</span>
    <span class="s1">unstable_getCurrentPriorityLevel: unstable_getCurrentPriorityLevel,</span>
    <span class="s1">unstable_shouldYield: shouldYieldToHost,</span>
    <span class="s1">unstable_requestPaint: unstable_requestPaint,</span>
    <span class="s1">unstable_continueExecution: unstable_continueExecution,</span>
    <span class="s1">unstable_pauseExecution: unstable_pauseExecution,</span>
    <span class="s1">unstable_getFirstCallbackNode: unstable_getFirstCallbackNode,</span>
    <span class="s1">get unstable_now () { </span><span class="s2">return </span><span class="s1">getCurrentTime; },</span>
    <span class="s1">unstable_forceFrameRate: forceFrameRate,</span>
    <span class="s1">unstable_Profiling: unstable_Profiling</span>
  <span class="s1">});</span>

  <span class="s2">var </span><span class="s1">ReactSharedInternals$1 = {</span>
    <span class="s1">ReactCurrentDispatcher: ReactCurrentDispatcher,</span>
    <span class="s1">ReactCurrentOwner: ReactCurrentOwner,</span>
    <span class="s1">ReactCurrentBatchConfig: ReactCurrentBatchConfig,</span>
    <span class="s0">// Re-export the schedule API(s) for UMD bundles.</span>
    <span class="s0">// This avoids introducing a dependency on a new UMD global in a minor update,</span>
    <span class="s0">// Since that would be a breaking change (e.g. for all existing CodeSandboxes).</span>
    <span class="s0">// This re-export is only required for UMD bundles;</span>
    <span class="s0">// CJS bundles use the shared NPM package.</span>
    <span class="s1">Scheduler: Scheduler</span>
  <span class="s1">};</span>

  <span class="s1">{</span>
    <span class="s1">ReactSharedInternals$1.ReactCurrentActQueue = ReactCurrentActQueue;</span>
    <span class="s1">ReactSharedInternals$1.ReactDebugCurrentFrame = ReactDebugCurrentFrame;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">startTransition(scope, options) {</span>
    <span class="s2">var </span><span class="s1">prevTransition = ReactCurrentBatchConfig.transition;</span>
    <span class="s1">ReactCurrentBatchConfig.transition = {};</span>
    <span class="s2">var </span><span class="s1">currentTransition = ReactCurrentBatchConfig.transition;</span>

    <span class="s1">{</span>
      <span class="s1">ReactCurrentBatchConfig.transition._updatedFibers = </span><span class="s2">new </span><span class="s1">Set();</span>
    <span class="s1">}</span>

    <span class="s2">try </span><span class="s1">{</span>
      <span class="s1">scope();</span>
    <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
      <span class="s1">ReactCurrentBatchConfig.transition = prevTransition;</span>

      <span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(prevTransition === </span><span class="s2">null </span><span class="s1">&amp;&amp; currentTransition._updatedFibers) {</span>
          <span class="s2">var </span><span class="s1">updatedFibersCount = currentTransition._updatedFibers.size;</span>

          <span class="s2">if </span><span class="s1">(updatedFibersCount &gt; </span><span class="s4">10</span><span class="s1">) {</span>
            <span class="s1">warn(</span><span class="s3">'Detected a large number of updates inside startTransition. ' </span><span class="s1">+ </span><span class="s3">'If this is due to a subscription please re-write it to use React provided hooks. ' </span><span class="s1">+ </span><span class="s3">'Otherwise concurrent mode guarantees are off the table.'</span><span class="s1">);</span>
          <span class="s1">}</span>

          <span class="s1">currentTransition._updatedFibers.clear();</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">didWarnAboutMessageChannel = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">enqueueTaskImpl = </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s2">function </span><span class="s1">enqueueTask(task) {</span>
    <span class="s2">if </span><span class="s1">(enqueueTaskImpl === </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">try </span><span class="s1">{</span>
        <span class="s0">// read require off the module object to get around the bundlers.</span>
        <span class="s0">// we don't want them to detect a require and bundle a Node polyfill.</span>
        <span class="s2">var </span><span class="s1">requireString = (</span><span class="s3">'require' </span><span class="s1">+ Math.random()).slice(</span><span class="s4">0</span><span class="s1">, </span><span class="s4">7</span><span class="s1">);</span>
        <span class="s2">var </span><span class="s1">nodeRequire = module &amp;&amp; module[requireString]; </span><span class="s0">// assuming we're in node, let's try to get node's</span>
        <span class="s0">// version of setImmediate, bypassing fake timers if any.</span>

        <span class="s1">enqueueTaskImpl = nodeRequire.call(module, </span><span class="s3">'timers'</span><span class="s1">).setImmediate;</span>
      <span class="s1">} </span><span class="s2">catch </span><span class="s1">(_err) {</span>
        <span class="s0">// we're in a browser</span>
        <span class="s0">// we can't use regular timers because they may still be faked</span>
        <span class="s0">// so we try MessageChannel+postMessage instead</span>
        <span class="s1">enqueueTaskImpl = </span><span class="s2">function </span><span class="s1">(callback) {</span>
          <span class="s1">{</span>
            <span class="s2">if </span><span class="s1">(didWarnAboutMessageChannel === </span><span class="s2">false</span><span class="s1">) {</span>
              <span class="s1">didWarnAboutMessageChannel = </span><span class="s2">true</span><span class="s1">;</span>

              <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">MessageChannel === </span><span class="s3">'undefined'</span><span class="s1">) {</span>
                <span class="s1">error(</span><span class="s3">'This browser does not have a MessageChannel implementation, ' </span><span class="s1">+ </span><span class="s3">'so enqueuing tasks via await act(async () =&gt; ...) will fail. ' </span><span class="s1">+ </span><span class="s3">'Please file an issue at https://github.com/facebook/react/issues ' </span><span class="s1">+ </span><span class="s3">'if you encounter this warning.'</span><span class="s1">);</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s2">var </span><span class="s1">channel = </span><span class="s2">new </span><span class="s1">MessageChannel();</span>
          <span class="s1">channel.port1.onmessage = callback;</span>
          <span class="s1">channel.port2.postMessage(undefined);</span>
        <span class="s1">};</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">enqueueTaskImpl(task);</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">actScopeDepth = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">didWarnNoAwaitAct = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s2">function </span><span class="s1">act(callback) {</span>
    <span class="s1">{</span>
      <span class="s0">// `act` calls can be nested, so we track the depth. This represents the</span>
      <span class="s0">// number of `act` scopes on the stack.</span>
      <span class="s2">var </span><span class="s1">prevActScopeDepth = actScopeDepth;</span>
      <span class="s1">actScopeDepth++;</span>

      <span class="s2">if </span><span class="s1">(ReactCurrentActQueue.current === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s0">// This is the outermost `act` scope. Initialize the queue. The reconciler</span>
        <span class="s0">// will detect the queue and use it instead of Scheduler.</span>
        <span class="s1">ReactCurrentActQueue.current = [];</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;</span>
      <span class="s2">var </span><span class="s1">result;</span>

      <span class="s2">try </span><span class="s1">{</span>
        <span class="s0">// Used to reproduce behavior of `batchedUpdates` in legacy mode. Only</span>
        <span class="s0">// set to `true` while the given callback is executed, not for updates</span>
        <span class="s0">// triggered during an async event, because this is how the legacy</span>
        <span class="s0">// implementation of `act` behaved.</span>
        <span class="s1">ReactCurrentActQueue.isBatchingLegacy = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">result = callback(); </span><span class="s0">// Replicate behavior of original `act` implementation in legacy mode,</span>
        <span class="s0">// which flushed updates immediately after the scope function exits, even</span>
        <span class="s0">// if it's an async function.</span>

        <span class="s2">if </span><span class="s1">(!prevIsBatchingLegacy &amp;&amp; ReactCurrentActQueue.didScheduleLegacyUpdate) {</span>
          <span class="s2">var </span><span class="s1">queue = ReactCurrentActQueue.current;</span>

          <span class="s2">if </span><span class="s1">(queue !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">ReactCurrentActQueue.didScheduleLegacyUpdate = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s1">flushActQueue(queue);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">catch </span><span class="s1">(error) {</span>
        <span class="s1">popActScope(prevActScopeDepth);</span>
        <span class="s2">throw </span><span class="s1">error;</span>
      <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
        <span class="s1">ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(result !== </span><span class="s2">null </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">result === </span><span class="s3">'object' </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">result.then === </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s2">var </span><span class="s1">thenableResult = result; </span><span class="s0">// The callback is an async function (i.e. returned a promise). Wait</span>
        <span class="s0">// for it to resolve before exiting the current scope.</span>

        <span class="s2">var </span><span class="s1">wasAwaited = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s2">var </span><span class="s1">thenable = {</span>
          <span class="s1">then: </span><span class="s2">function </span><span class="s1">(resolve, reject) {</span>
            <span class="s1">wasAwaited = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">thenableResult.then(</span><span class="s2">function </span><span class="s1">(returnValue) {</span>
              <span class="s1">popActScope(prevActScopeDepth);</span>

              <span class="s2">if </span><span class="s1">(actScopeDepth === </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s0">// We've exited the outermost act scope. Recursively flush the</span>
                <span class="s0">// queue until there's no remaining work.</span>
                <span class="s1">recursivelyFlushAsyncActWork(returnValue, resolve, reject);</span>
              <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">resolve(returnValue);</span>
              <span class="s1">}</span>
            <span class="s1">}, </span><span class="s2">function </span><span class="s1">(error) {</span>
              <span class="s0">// The callback threw an error.</span>
              <span class="s1">popActScope(prevActScopeDepth);</span>
              <span class="s1">reject(error);</span>
            <span class="s1">});</span>
          <span class="s1">}</span>
        <span class="s1">};</span>

        <span class="s1">{</span>
          <span class="s2">if </span><span class="s1">(!didWarnNoAwaitAct &amp;&amp; </span><span class="s2">typeof </span><span class="s1">Promise !== </span><span class="s3">'undefined'</span><span class="s1">) {</span>
            <span class="s0">// eslint-disable-next-line no-undef</span>
            <span class="s1">Promise.resolve().then(</span><span class="s2">function </span><span class="s1">() {}).then(</span><span class="s2">function </span><span class="s1">() {</span>
              <span class="s2">if </span><span class="s1">(!wasAwaited) {</span>
                <span class="s1">didWarnNoAwaitAct = </span><span class="s2">true</span><span class="s1">;</span>

                <span class="s1">error(</span><span class="s3">'You called act(async () =&gt; ...) without await. ' </span><span class="s1">+ </span><span class="s3">'This could lead to unexpected testing behaviour, ' </span><span class="s1">+ </span><span class="s3">'interleaving multiple act calls and mixing their ' </span><span class="s1">+ </span><span class="s3">'scopes. ' </span><span class="s1">+ </span><span class="s3">'You should - await act(async () =&gt; ...);'</span><span class="s1">);</span>
              <span class="s1">}</span>
            <span class="s1">});</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s2">return </span><span class="s1">thenable;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">var </span><span class="s1">returnValue = result; </span><span class="s0">// The callback is not an async function. Exit the current scope</span>
        <span class="s0">// immediately, without awaiting.</span>

        <span class="s1">popActScope(prevActScopeDepth);</span>

        <span class="s2">if </span><span class="s1">(actScopeDepth === </span><span class="s4">0</span><span class="s1">) {</span>
          <span class="s0">// Exiting the outermost act scope. Flush the queue.</span>
          <span class="s2">var </span><span class="s1">_queue = ReactCurrentActQueue.current;</span>

          <span class="s2">if </span><span class="s1">(_queue !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">flushActQueue(_queue);</span>
            <span class="s1">ReactCurrentActQueue.current = </span><span class="s2">null</span><span class="s1">;</span>
          <span class="s1">} </span><span class="s0">// Return a thenable. If the user awaits it, we'll flush again in</span>
          <span class="s0">// case additional work was scheduled by a microtask.</span>


          <span class="s2">var </span><span class="s1">_thenable = {</span>
            <span class="s1">then: </span><span class="s2">function </span><span class="s1">(resolve, reject) {</span>
              <span class="s0">// Confirm we haven't re-entered another `act` scope, in case</span>
              <span class="s0">// the user does something weird like await the thenable</span>
              <span class="s0">// multiple times.</span>
              <span class="s2">if </span><span class="s1">(ReactCurrentActQueue.current === </span><span class="s2">null</span><span class="s1">) {</span>
                <span class="s0">// Recursively flush the queue until there's no remaining work.</span>
                <span class="s1">ReactCurrentActQueue.current = [];</span>
                <span class="s1">recursivelyFlushAsyncActWork(returnValue, resolve, reject);</span>
              <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">resolve(returnValue);</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s1">};</span>
          <span class="s2">return </span><span class="s1">_thenable;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s0">// Since we're inside a nested `act` scope, the returned thenable</span>
          <span class="s0">// immediately resolves. The outer scope will flush the queue.</span>
          <span class="s2">var </span><span class="s1">_thenable2 = {</span>
            <span class="s1">then: </span><span class="s2">function </span><span class="s1">(resolve, reject) {</span>
              <span class="s1">resolve(returnValue);</span>
            <span class="s1">}</span>
          <span class="s1">};</span>
          <span class="s2">return </span><span class="s1">_thenable2;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">popActScope(prevActScopeDepth) {</span>
    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(prevActScopeDepth !== actScopeDepth - </span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s3">'You seem to have overlapping act() calls, this is not supported. ' </span><span class="s1">+ </span><span class="s3">'Be sure to await previous act() calls before making a new one. '</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s1">actScopeDepth = prevActScopeDepth;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">recursivelyFlushAsyncActWork(returnValue, resolve, reject) {</span>
    <span class="s1">{</span>
      <span class="s2">var </span><span class="s1">queue = ReactCurrentActQueue.current;</span>

      <span class="s2">if </span><span class="s1">(queue !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">try </span><span class="s1">{</span>
          <span class="s1">flushActQueue(queue);</span>
          <span class="s1">enqueueTask(</span><span class="s2">function </span><span class="s1">() {</span>
            <span class="s2">if </span><span class="s1">(queue.length === </span><span class="s4">0</span><span class="s1">) {</span>
              <span class="s0">// No additional work was scheduled. Finish.</span>
              <span class="s1">ReactCurrentActQueue.current = </span><span class="s2">null</span><span class="s1">;</span>
              <span class="s1">resolve(returnValue);</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
              <span class="s0">// Keep flushing work until there's none left.</span>
              <span class="s1">recursivelyFlushAsyncActWork(returnValue, resolve, reject);</span>
            <span class="s1">}</span>
          <span class="s1">});</span>
        <span class="s1">} </span><span class="s2">catch </span><span class="s1">(error) {</span>
          <span class="s1">reject(error);</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">resolve(returnValue);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">isFlushing = </span><span class="s2">false</span><span class="s1">;</span>

  <span class="s2">function </span><span class="s1">flushActQueue(queue) {</span>
    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(!isFlushing) {</span>
        <span class="s0">// Prevent re-entrance.</span>
        <span class="s1">isFlushing = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">;</span>

        <span class="s2">try </span><span class="s1">{</span>
          <span class="s2">for </span><span class="s1">(; i &lt; queue.length; i++) {</span>
            <span class="s2">var </span><span class="s1">callback = queue[i];</span>

            <span class="s2">do </span><span class="s1">{</span>
              <span class="s1">callback = callback(</span><span class="s2">true</span><span class="s1">);</span>
            <span class="s1">} </span><span class="s2">while </span><span class="s1">(callback !== </span><span class="s2">null</span><span class="s1">);</span>
          <span class="s1">}</span>

          <span class="s1">queue.length = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">catch </span><span class="s1">(error) {</span>
          <span class="s0">// If something throws, leave the remaining callbacks on the queue.</span>
          <span class="s1">queue = queue.slice(i + </span><span class="s4">1</span><span class="s1">);</span>
          <span class="s2">throw </span><span class="s1">error;</span>
        <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
          <span class="s1">isFlushing = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">createElement$1 =  createElementWithValidation ;</span>
  <span class="s2">var </span><span class="s1">cloneElement$1 =  cloneElementWithValidation ;</span>
  <span class="s2">var </span><span class="s1">createFactory =  createFactoryWithValidation ;</span>
  <span class="s2">var </span><span class="s1">Children = {</span>
    <span class="s1">map: mapChildren,</span>
    <span class="s1">forEach: forEachChildren,</span>
    <span class="s1">count: countChildren,</span>
    <span class="s1">toArray: toArray,</span>
    <span class="s1">only: onlyChild</span>
  <span class="s1">};</span>

  <span class="s1">exports.Children = Children;</span>
  <span class="s1">exports.Component = Component;</span>
  <span class="s1">exports.Fragment = REACT_FRAGMENT_TYPE;</span>
  <span class="s1">exports.Profiler = REACT_PROFILER_TYPE;</span>
  <span class="s1">exports.PureComponent = PureComponent;</span>
  <span class="s1">exports.StrictMode = REACT_STRICT_MODE_TYPE;</span>
  <span class="s1">exports.Suspense = REACT_SUSPENSE_TYPE;</span>
  <span class="s1">exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals$1;</span>
  <span class="s1">exports.cloneElement = cloneElement$1;</span>
  <span class="s1">exports.createContext = createContext;</span>
  <span class="s1">exports.createElement = createElement$1;</span>
  <span class="s1">exports.createFactory = createFactory;</span>
  <span class="s1">exports.createRef = createRef;</span>
  <span class="s1">exports.forwardRef = forwardRef;</span>
  <span class="s1">exports.isValidElement = isValidElement;</span>
  <span class="s1">exports.lazy = lazy;</span>
  <span class="s1">exports.memo = memo;</span>
  <span class="s1">exports.startTransition = startTransition;</span>
  <span class="s1">exports.unstable_act = act;</span>
  <span class="s1">exports.useCallback = useCallback;</span>
  <span class="s1">exports.useContext = useContext;</span>
  <span class="s1">exports.useDebugValue = useDebugValue;</span>
  <span class="s1">exports.useDeferredValue = useDeferredValue;</span>
  <span class="s1">exports.useEffect = useEffect;</span>
  <span class="s1">exports.useId = useId;</span>
  <span class="s1">exports.useImperativeHandle = useImperativeHandle;</span>
  <span class="s1">exports.useInsertionEffect = useInsertionEffect;</span>
  <span class="s1">exports.useLayoutEffect = useLayoutEffect;</span>
  <span class="s1">exports.useMemo = useMemo;</span>
  <span class="s1">exports.useReducer = useReducer;</span>
  <span class="s1">exports.useRef = useRef;</span>
  <span class="s1">exports.useState = useState;</span>
  <span class="s1">exports.useSyncExternalStore = useSyncExternalStore;</span>
  <span class="s1">exports.useTransition = useTransition;</span>
  <span class="s1">exports.version = ReactVersion;</span>

<span class="s1">})));</span>
</pre>
</body>
</html>
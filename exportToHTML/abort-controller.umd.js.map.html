<html>
<head>
<title>abort-controller.umd.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
.s1 { color: #6a8759;}
.s2 { color: #6897bb; font-style: italic;}
.s3 { color: #cc7832; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
abort-controller.umd.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;abort-controller.umd.js&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../node_modules/event-target-shim/dist/event-target-shim.mjs&quot;</span><span class="s0">,</span><span class="s1">&quot;../src/abort-signal.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;../src/abort-controller.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* @author Toru Nagashima &lt;https://github.com/mysticatea&gt;</span><span class="s3">\n </span><span class="s1">* @copyright 2015 Toru Nagashima. All rights reserved.</span><span class="s3">\n </span><span class="s1">* See LICENSE file in root directory for full license.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @typedef {object} PrivateData</span><span class="s3">\n </span><span class="s1">* @property {EventTarget} eventTarget The event target.</span><span class="s3">\n </span><span class="s1">* @property {{type:string}} event The original event object.</span><span class="s3">\n </span><span class="s1">* @property {number} eventPhase The current event phase.</span><span class="s3">\n </span><span class="s1">* @property {EventTarget|null} currentTarget The current event target.</span><span class="s3">\n </span><span class="s1">* @property {boolean} canceled The flag to prevent default.</span><span class="s3">\n </span><span class="s1">* @property {boolean} stopped The flag to stop propagation.</span><span class="s3">\n </span><span class="s1">* @property {boolean} immediateStopped The flag to stop propagation immediately.</span><span class="s3">\n </span><span class="s1">* @property {Function|null} passiveListener The listener if the current listener is passive. Otherwise this is null.</span><span class="s3">\n </span><span class="s1">* @property {number} timeStamp The unix time.</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Private data for event wrappers.</span><span class="s3">\n </span><span class="s1">* @type {WeakMap&lt;Event, PrivateData&gt;}</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const privateData = new WeakMap();</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Cache for wrapper classes.</span><span class="s3">\n </span><span class="s1">* @type {WeakMap&lt;Object, Function&gt;}</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const wrappers = new WeakMap();</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Get private data.</span><span class="s3">\n </span><span class="s1">* @param {Event} event The event object to get private data.</span><span class="s3">\n </span><span class="s1">* @returns {PrivateData} The private data of the event.</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function pd(event) {</span><span class="s3">\n    </span><span class="s1">const retv = privateData.get(event);</span><span class="s3">\n    </span><span class="s1">console.assert(</span><span class="s3">\n        </span><span class="s1">retv != null,</span><span class="s3">\n        \&quot;</span><span class="s1">'this' is expected an Event object, but got</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">event</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">return retv</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* https://dom.spec.whatwg.org/#set-the-canceled-flag</span><span class="s3">\n </span><span class="s1">* @param data {PrivateData} private data.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function setCancelFlag(data) {</span><span class="s3">\n    </span><span class="s1">if (data.passiveListener != null) {</span><span class="s3">\n        </span><span class="s1">if (</span><span class="s3">\n            </span><span class="s1">typeof console !== </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n            </span><span class="s1">typeof console.error === </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;\n        </span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">console.error(</span><span class="s3">\n                \&quot;</span><span class="s1">Unable to preventDefault inside passive event listener invocation.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                </span><span class="s1">data.passiveListener</span><span class="s3">\n            </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!data.event.cancelable) {</span><span class="s3">\n        </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">data.canceled = true;</span><span class="s3">\n    </span><span class="s1">if (typeof data.event.preventDefault === </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">data.event.preventDefault();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @see https://dom.spec.whatwg.org/#interface-event</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The event wrapper.</span><span class="s3">\n </span><span class="s1">* @constructor</span><span class="s3">\n </span><span class="s1">* @param {EventTarget} eventTarget The event target of this dispatching.</span><span class="s3">\n </span><span class="s1">* @param {Event|{type:string}} event The original event to wrap.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function Event(eventTarget, event) {</span><span class="s3">\n    </span><span class="s1">privateData.set(this, {</span><span class="s3">\n        </span><span class="s1">eventTarget,</span><span class="s3">\n        </span><span class="s1">event,</span><span class="s3">\n        </span><span class="s1">eventPhase: 2,</span><span class="s3">\n        </span><span class="s1">currentTarget: eventTarget,</span><span class="s3">\n        </span><span class="s1">canceled: false,</span><span class="s3">\n        </span><span class="s1">stopped: false,</span><span class="s3">\n        </span><span class="s1">immediateStopped: false,</span><span class="s3">\n        </span><span class="s1">passiveListener: null,</span><span class="s3">\n        </span><span class="s1">timeStamp: event.timeStamp || Date.now(),</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">// https://heycam.github.io/webidl/#Unforgeable</span><span class="s3">\n    </span><span class="s1">Object.defineProperty(this, </span><span class="s3">\&quot;</span><span class="s1">isTrusted</span><span class="s3">\&quot;</span><span class="s1">, { value: false, enumerable: true });</span><span class="s3">\n\n    </span><span class="s1">// Define accessors</span><span class="s3">\n    </span><span class="s1">const keys = Object.keys(event);</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; keys.length; ++i) {</span><span class="s3">\n        </span><span class="s1">const key = keys[i];</span><span class="s3">\n        </span><span class="s1">if (!(key in this)) {</span><span class="s3">\n            </span><span class="s1">Object.defineProperty(this, key, defineRedirectDescriptor(key));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Should be enumerable, but class methods are not enumerable.</span><span class="s3">\n</span><span class="s1">Event.prototype = {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The type of this event.</span><span class="s3">\n     </span><span class="s1">* @type {string}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get type() {</span><span class="s3">\n        </span><span class="s1">return pd(this).event.type</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The target of this event.</span><span class="s3">\n     </span><span class="s1">* @type {EventTarget}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get target() {</span><span class="s3">\n        </span><span class="s1">return pd(this).eventTarget</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The target of this event.</span><span class="s3">\n     </span><span class="s1">* @type {EventTarget}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get currentTarget() {</span><span class="s3">\n        </span><span class="s1">return pd(this).currentTarget</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @returns {EventTarget[]} The composed path of this event.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">composedPath() {</span><span class="s3">\n        </span><span class="s1">const currentTarget = pd(this).currentTarget;</span><span class="s3">\n        </span><span class="s1">if (currentTarget == null) {</span><span class="s3">\n            </span><span class="s1">return []</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return [currentTarget]</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Constant of NONE.</span><span class="s3">\n     </span><span class="s1">* @type {number}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get NONE() {</span><span class="s3">\n        </span><span class="s1">return 0</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Constant of CAPTURING_PHASE.</span><span class="s3">\n     </span><span class="s1">* @type {number}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get CAPTURING_PHASE() {</span><span class="s3">\n        </span><span class="s1">return 1</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Constant of AT_TARGET.</span><span class="s3">\n     </span><span class="s1">* @type {number}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get AT_TARGET() {</span><span class="s3">\n        </span><span class="s1">return 2</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Constant of BUBBLING_PHASE.</span><span class="s3">\n     </span><span class="s1">* @type {number}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get BUBBLING_PHASE() {</span><span class="s3">\n        </span><span class="s1">return 3</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The target of this event.</span><span class="s3">\n     </span><span class="s1">* @type {number}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get eventPhase() {</span><span class="s3">\n        </span><span class="s1">return pd(this).eventPhase</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Stop event bubbling.</span><span class="s3">\n     </span><span class="s1">* @returns {void}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">stopPropagation() {</span><span class="s3">\n        </span><span class="s1">const data = pd(this);</span><span class="s3">\n\n        </span><span class="s1">data.stopped = true;</span><span class="s3">\n        </span><span class="s1">if (typeof data.event.stopPropagation === </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">data.event.stopPropagation();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Stop event bubbling.</span><span class="s3">\n     </span><span class="s1">* @returns {void}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">stopImmediatePropagation() {</span><span class="s3">\n        </span><span class="s1">const data = pd(this);</span><span class="s3">\n\n        </span><span class="s1">data.stopped = true;</span><span class="s3">\n        </span><span class="s1">data.immediateStopped = true;</span><span class="s3">\n        </span><span class="s1">if (typeof data.event.stopImmediatePropagation === </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">data.event.stopImmediatePropagation();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The flag to be bubbling.</span><span class="s3">\n     </span><span class="s1">* @type {boolean}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get bubbles() {</span><span class="s3">\n        </span><span class="s1">return Boolean(pd(this).event.bubbles)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The flag to be cancelable.</span><span class="s3">\n     </span><span class="s1">* @type {boolean}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get cancelable() {</span><span class="s3">\n        </span><span class="s1">return Boolean(pd(this).event.cancelable)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Cancel this event.</span><span class="s3">\n     </span><span class="s1">* @returns {void}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">preventDefault() {</span><span class="s3">\n        </span><span class="s1">setCancelFlag(pd(this));</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The flag to indicate cancellation state.</span><span class="s3">\n     </span><span class="s1">* @type {boolean}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get defaultPrevented() {</span><span class="s3">\n        </span><span class="s1">return pd(this).canceled</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The flag to be composed.</span><span class="s3">\n     </span><span class="s1">* @type {boolean}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get composed() {</span><span class="s3">\n        </span><span class="s1">return Boolean(pd(this).event.composed)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The unix time of this event.</span><span class="s3">\n     </span><span class="s1">* @type {number}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get timeStamp() {</span><span class="s3">\n        </span><span class="s1">return pd(this).timeStamp</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The target of this event.</span><span class="s3">\n     </span><span class="s1">* @type {EventTarget}</span><span class="s3">\n     </span><span class="s1">* @deprecated</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get srcElement() {</span><span class="s3">\n        </span><span class="s1">return pd(this).eventTarget</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The flag to stop event bubbling.</span><span class="s3">\n     </span><span class="s1">* @type {boolean}</span><span class="s3">\n     </span><span class="s1">* @deprecated</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get cancelBubble() {</span><span class="s3">\n        </span><span class="s1">return pd(this).stopped</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">set cancelBubble(value) {</span><span class="s3">\n        </span><span class="s1">if (!value) {</span><span class="s3">\n            </span><span class="s1">return</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const data = pd(this);</span><span class="s3">\n\n        </span><span class="s1">data.stopped = true;</span><span class="s3">\n        </span><span class="s1">if (typeof data.event.cancelBubble === </span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">data.event.cancelBubble = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The flag to indicate cancellation state.</span><span class="s3">\n     </span><span class="s1">* @type {boolean}</span><span class="s3">\n     </span><span class="s1">* @deprecated</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get returnValue() {</span><span class="s3">\n        </span><span class="s1">return !pd(this).canceled</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">set returnValue(value) {</span><span class="s3">\n        </span><span class="s1">if (!value) {</span><span class="s3">\n            </span><span class="s1">setCancelFlag(pd(this));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Initialize this event object. But do nothing under event dispatching.</span><span class="s3">\n     </span><span class="s1">* @param {string} type The event type.</span><span class="s3">\n     </span><span class="s1">* @param {boolean} [bubbles=false] The flag to be possible to bubble up.</span><span class="s3">\n     </span><span class="s1">* @param {boolean} [cancelable=false] The flag to be possible to cancel.</span><span class="s3">\n     </span><span class="s1">* @deprecated</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">initEvent() {</span><span class="s3">\n        </span><span class="s1">// Do nothing.</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// `constructor` is not enumerable.</span><span class="s3">\n</span><span class="s1">Object.defineProperty(Event.prototype, </span><span class="s3">\&quot;</span><span class="s1">constructor</span><span class="s3">\&quot;</span><span class="s1">, {</span><span class="s3">\n    </span><span class="s1">value: Event,</span><span class="s3">\n    </span><span class="s1">configurable: true,</span><span class="s3">\n    </span><span class="s1">writable: true,</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">// Ensure `event instanceof window.Event` is `true`.</span><span class="s3">\n</span><span class="s1">if (typeof window !== </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; typeof window.Event !== </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">Object.setPrototypeOf(Event.prototype, window.Event.prototype);</span><span class="s3">\n\n    </span><span class="s1">// Make association for wrappers.</span><span class="s3">\n    </span><span class="s1">wrappers.set(window.Event.prototype, Event);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Get the property descriptor to redirect a given property.</span><span class="s3">\n </span><span class="s1">* @param {string} key Property name to define property descriptor.</span><span class="s3">\n </span><span class="s1">* @returns {PropertyDescriptor} The property descriptor to redirect the property.</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function defineRedirectDescriptor(key) {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">get() {</span><span class="s3">\n            </span><span class="s1">return pd(this).event[key]</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">set(value) {</span><span class="s3">\n            </span><span class="s1">pd(this).event[key] = value;</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">configurable: true,</span><span class="s3">\n        </span><span class="s1">enumerable: true,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Get the property descriptor to call a given method property.</span><span class="s3">\n </span><span class="s1">* @param {string} key Property name to define property descriptor.</span><span class="s3">\n </span><span class="s1">* @returns {PropertyDescriptor} The property descriptor to call the method property.</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function defineCallDescriptor(key) {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">value() {</span><span class="s3">\n            </span><span class="s1">const event = pd(this).event;</span><span class="s3">\n            </span><span class="s1">return event[key].apply(event, arguments)</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">configurable: true,</span><span class="s3">\n        </span><span class="s1">enumerable: true,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Define new wrapper class.</span><span class="s3">\n </span><span class="s1">* @param {Function} BaseEvent The base wrapper class.</span><span class="s3">\n </span><span class="s1">* @param {Object} proto The prototype of the original event.</span><span class="s3">\n </span><span class="s1">* @returns {Function} The defined wrapper class.</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function defineWrapper(BaseEvent, proto) {</span><span class="s3">\n    </span><span class="s1">const keys = Object.keys(proto);</span><span class="s3">\n    </span><span class="s1">if (keys.length === 0) {</span><span class="s3">\n        </span><span class="s1">return BaseEvent</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">/** CustomEvent */</span><span class="s3">\n    </span><span class="s1">function CustomEvent(eventTarget, event) {</span><span class="s3">\n        </span><span class="s1">BaseEvent.call(this, eventTarget, event);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">CustomEvent.prototype = Object.create(BaseEvent.prototype, {</span><span class="s3">\n        </span><span class="s1">constructor: { value: CustomEvent, configurable: true, writable: true },</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">// Define accessors.</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; keys.length; ++i) {</span><span class="s3">\n        </span><span class="s1">const key = keys[i];</span><span class="s3">\n        </span><span class="s1">if (!(key in BaseEvent.prototype)) {</span><span class="s3">\n            </span><span class="s1">const descriptor = Object.getOwnPropertyDescriptor(proto, key);</span><span class="s3">\n            </span><span class="s1">const isFunc = typeof descriptor.value === </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">Object.defineProperty(</span><span class="s3">\n                </span><span class="s1">CustomEvent.prototype,</span><span class="s3">\n                </span><span class="s1">key,</span><span class="s3">\n                </span><span class="s1">isFunc</span><span class="s3">\n                    </span><span class="s1">? defineCallDescriptor(key)</span><span class="s3">\n                    </span><span class="s1">: defineRedirectDescriptor(key)</span><span class="s3">\n            </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return CustomEvent</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Get the wrapper class of a given prototype.</span><span class="s3">\n </span><span class="s1">* @param {Object} proto The prototype of the original event to get its wrapper.</span><span class="s3">\n </span><span class="s1">* @returns {Function} The wrapper class.</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function getWrapper(proto) {</span><span class="s3">\n    </span><span class="s1">if (proto == null || proto === Object.prototype) {</span><span class="s3">\n        </span><span class="s1">return Event</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let wrapper = wrappers.get(proto);</span><span class="s3">\n    </span><span class="s1">if (wrapper == null) {</span><span class="s3">\n        </span><span class="s1">wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);</span><span class="s3">\n        </span><span class="s1">wrappers.set(proto, wrapper);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return wrapper</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Wrap a given event to management a dispatching.</span><span class="s3">\n </span><span class="s1">* @param {EventTarget} eventTarget The event target of this dispatching.</span><span class="s3">\n </span><span class="s1">* @param {Object} event The event to wrap.</span><span class="s3">\n </span><span class="s1">* @returns {Event} The wrapper instance.</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function wrapEvent(eventTarget, event) {</span><span class="s3">\n    </span><span class="s1">const Wrapper = getWrapper(Object.getPrototypeOf(event));</span><span class="s3">\n    </span><span class="s1">return new Wrapper(eventTarget, event)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Get the immediateStopped flag of a given event.</span><span class="s3">\n </span><span class="s1">* @param {Event} event The event to get.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} The flag to stop propagation immediately.</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function isStopped(event) {</span><span class="s3">\n    </span><span class="s1">return pd(event).immediateStopped</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Set the current event phase of a given event.</span><span class="s3">\n </span><span class="s1">* @param {Event} event The event to set current target.</span><span class="s3">\n </span><span class="s1">* @param {number} eventPhase New event phase.</span><span class="s3">\n </span><span class="s1">* @returns {void}</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function setEventPhase(event, eventPhase) {</span><span class="s3">\n    </span><span class="s1">pd(event).eventPhase = eventPhase;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Set the current target of a given event.</span><span class="s3">\n </span><span class="s1">* @param {Event} event The event to set current target.</span><span class="s3">\n </span><span class="s1">* @param {EventTarget|null} currentTarget New current target.</span><span class="s3">\n </span><span class="s1">* @returns {void}</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function setCurrentTarget(event, currentTarget) {</span><span class="s3">\n    </span><span class="s1">pd(event).currentTarget = currentTarget;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Set a passive listener of a given event.</span><span class="s3">\n </span><span class="s1">* @param {Event} event The event to set current target.</span><span class="s3">\n </span><span class="s1">* @param {Function|null} passiveListener New passive listener.</span><span class="s3">\n </span><span class="s1">* @returns {void}</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function setPassiveListener(event, passiveListener) {</span><span class="s3">\n    </span><span class="s1">pd(event).passiveListener = passiveListener;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @typedef {object} ListenerNode</span><span class="s3">\n </span><span class="s1">* @property {Function} listener</span><span class="s3">\n </span><span class="s1">* @property {1|2|3} listenerType</span><span class="s3">\n </span><span class="s1">* @property {boolean} passive</span><span class="s3">\n </span><span class="s1">* @property {boolean} once</span><span class="s3">\n </span><span class="s1">* @property {ListenerNode|null} next</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @type {WeakMap&lt;object, Map&lt;string, ListenerNode&gt;&gt;}</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const listenersMap = new WeakMap();</span><span class="s3">\n\n</span><span class="s1">// Listener types</span><span class="s3">\n</span><span class="s1">const CAPTURE = 1;</span><span class="s3">\n</span><span class="s1">const BUBBLE = 2;</span><span class="s3">\n</span><span class="s1">const ATTRIBUTE = 3;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Check whether a given value is an object or not.</span><span class="s3">\n </span><span class="s1">* @param {any} x The value to check.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} `true` if the value is an object.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function isObject(x) {</span><span class="s3">\n    </span><span class="s1">return x !== null &amp;&amp; typeof x === </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">//eslint-disable-line no-restricted-syntax</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Get listeners.</span><span class="s3">\n </span><span class="s1">* @param {EventTarget} eventTarget The event target to get.</span><span class="s3">\n </span><span class="s1">* @returns {Map&lt;string, ListenerNode&gt;} The listeners.</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function getListeners(eventTarget) {</span><span class="s3">\n    </span><span class="s1">const listeners = listenersMap.get(eventTarget);</span><span class="s3">\n    </span><span class="s1">if (listeners == null) {</span><span class="s3">\n        </span><span class="s1">throw new TypeError(</span><span class="s3">\n            \&quot;</span><span class="s1">'this' is expected an EventTarget object, but got another value.</span><span class="s3">\&quot;\n        </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return listeners</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Get the property descriptor for the event attribute of a given event.</span><span class="s3">\n </span><span class="s1">* @param {string} eventName The event name to get property descriptor.</span><span class="s3">\n </span><span class="s1">* @returns {PropertyDescriptor} The property descriptor.</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function defineEventAttributeDescriptor(eventName) {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">get() {</span><span class="s3">\n            </span><span class="s1">const listeners = getListeners(this);</span><span class="s3">\n            </span><span class="s1">let node = listeners.get(eventName);</span><span class="s3">\n            </span><span class="s1">while (node != null) {</span><span class="s3">\n                </span><span class="s1">if (node.listenerType === ATTRIBUTE) {</span><span class="s3">\n                    </span><span class="s1">return node.listener</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">node = node.next;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return null</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n\n        </span><span class="s1">set(listener) {</span><span class="s3">\n            </span><span class="s1">if (typeof listener !== </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; !isObject(listener)) {</span><span class="s3">\n                </span><span class="s1">listener = null; // eslint-disable-line no-param-reassign</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">const listeners = getListeners(this);</span><span class="s3">\n\n            </span><span class="s1">// Traverse to the tail while removing old value.</span><span class="s3">\n            </span><span class="s1">let prev = null;</span><span class="s3">\n            </span><span class="s1">let node = listeners.get(eventName);</span><span class="s3">\n            </span><span class="s1">while (node != null) {</span><span class="s3">\n                </span><span class="s1">if (node.listenerType === ATTRIBUTE) {</span><span class="s3">\n                    </span><span class="s1">// Remove old value.</span><span class="s3">\n                    </span><span class="s1">if (prev !== null) {</span><span class="s3">\n                        </span><span class="s1">prev.next = node.next;</span><span class="s3">\n                    </span><span class="s1">} else if (node.next !== null) {</span><span class="s3">\n                        </span><span class="s1">listeners.set(eventName, node.next);</span><span class="s3">\n                    </span><span class="s1">} else {</span><span class="s3">\n                        </span><span class="s1">listeners.delete(eventName);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">} else {</span><span class="s3">\n                    </span><span class="s1">prev = node;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n\n                </span><span class="s1">node = node.next;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">// Add new value.</span><span class="s3">\n            </span><span class="s1">if (listener !== null) {</span><span class="s3">\n                </span><span class="s1">const newNode = {</span><span class="s3">\n                    </span><span class="s1">listener,</span><span class="s3">\n                    </span><span class="s1">listenerType: ATTRIBUTE,</span><span class="s3">\n                    </span><span class="s1">passive: false,</span><span class="s3">\n                    </span><span class="s1">once: false,</span><span class="s3">\n                    </span><span class="s1">next: null,</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n                </span><span class="s1">if (prev === null) {</span><span class="s3">\n                    </span><span class="s1">listeners.set(eventName, newNode);</span><span class="s3">\n                </span><span class="s1">} else {</span><span class="s3">\n                    </span><span class="s1">prev.next = newNode;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">configurable: true,</span><span class="s3">\n        </span><span class="s1">enumerable: true,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Define an event attribute (e.g. `eventTarget.onclick`).</span><span class="s3">\n </span><span class="s1">* @param {Object} eventTargetPrototype The event target prototype to define an event attrbite.</span><span class="s3">\n </span><span class="s1">* @param {string} eventName The event name to define.</span><span class="s3">\n </span><span class="s1">* @returns {void}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function defineEventAttribute(eventTargetPrototype, eventName) {</span><span class="s3">\n    </span><span class="s1">Object.defineProperty(</span><span class="s3">\n        </span><span class="s1">eventTargetPrototype,</span><span class="s3">\n        </span><span class="s1">`on${eventName}`,</span><span class="s3">\n        </span><span class="s1">defineEventAttributeDescriptor(eventName)</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Define a custom EventTarget with event attributes.</span><span class="s3">\n </span><span class="s1">* @param {string[]} eventNames Event names for event attributes.</span><span class="s3">\n </span><span class="s1">* @returns {EventTarget} The custom EventTarget.</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function defineCustomEventTarget(eventNames) {</span><span class="s3">\n    </span><span class="s1">/** CustomEventTarget */</span><span class="s3">\n    </span><span class="s1">function CustomEventTarget() {</span><span class="s3">\n        </span><span class="s1">EventTarget.call(this);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">CustomEventTarget.prototype = Object.create(EventTarget.prototype, {</span><span class="s3">\n        </span><span class="s1">constructor: {</span><span class="s3">\n            </span><span class="s1">value: CustomEventTarget,</span><span class="s3">\n            </span><span class="s1">configurable: true,</span><span class="s3">\n            </span><span class="s1">writable: true,</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">for (let i = 0; i &lt; eventNames.length; ++i) {</span><span class="s3">\n        </span><span class="s1">defineEventAttribute(CustomEventTarget.prototype, eventNames[i]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return CustomEventTarget</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* EventTarget.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* - This is constructor if no arguments.</span><span class="s3">\n </span><span class="s1">* - This is a function which returns a CustomEventTarget constructor if there are arguments.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* For example:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*     class A extends EventTarget {}</span><span class="s3">\n </span><span class="s1">*     class B extends EventTarget(</span><span class="s3">\&quot;</span><span class="s1">message</span><span class="s3">\&quot;</span><span class="s1">) {}</span><span class="s3">\n </span><span class="s1">*     class C extends EventTarget(</span><span class="s3">\&quot;</span><span class="s1">message</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">error</span><span class="s3">\&quot;</span><span class="s1">) {}</span><span class="s3">\n </span><span class="s1">*     class D extends EventTarget([</span><span class="s3">\&quot;</span><span class="s1">message</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">error</span><span class="s3">\&quot;</span><span class="s1">]) {}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function EventTarget() {</span><span class="s3">\n    </span><span class="s1">/*eslint-disable consistent-return */</span><span class="s3">\n    </span><span class="s1">if (this instanceof EventTarget) {</span><span class="s3">\n        </span><span class="s1">listenersMap.set(this, new Map());</span><span class="s3">\n        </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (arguments.length === 1 &amp;&amp; Array.isArray(arguments[0])) {</span><span class="s3">\n        </span><span class="s1">return defineCustomEventTarget(arguments[0])</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (arguments.length &gt; 0) {</span><span class="s3">\n        </span><span class="s1">const types = new Array(arguments.length);</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; arguments.length; ++i) {</span><span class="s3">\n            </span><span class="s1">types[i] = arguments[i];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return defineCustomEventTarget(types)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">Cannot call a class as a function</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">/*eslint-enable consistent-return */</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Should be enumerable, but class methods are not enumerable.</span><span class="s3">\n</span><span class="s1">EventTarget.prototype = {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Add a given listener to this event target.</span><span class="s3">\n     </span><span class="s1">* @param {string} eventName The event name to add.</span><span class="s3">\n     </span><span class="s1">* @param {Function} listener The listener to add.</span><span class="s3">\n     </span><span class="s1">* @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.</span><span class="s3">\n     </span><span class="s1">* @returns {void}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">addEventListener(eventName, listener, options) {</span><span class="s3">\n        </span><span class="s1">if (listener == null) {</span><span class="s3">\n            </span><span class="s1">return</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (typeof listener !== </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; !isObject(listener)) {</span><span class="s3">\n            </span><span class="s1">throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">'listener' should be a function or an object.</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const listeners = getListeners(this);</span><span class="s3">\n        </span><span class="s1">const optionsIsObj = isObject(options);</span><span class="s3">\n        </span><span class="s1">const capture = optionsIsObj</span><span class="s3">\n            </span><span class="s1">? Boolean(options.capture)</span><span class="s3">\n            </span><span class="s1">: Boolean(options);</span><span class="s3">\n        </span><span class="s1">const listenerType = capture ? CAPTURE : BUBBLE;</span><span class="s3">\n        </span><span class="s1">const newNode = {</span><span class="s3">\n            </span><span class="s1">listener,</span><span class="s3">\n            </span><span class="s1">listenerType,</span><span class="s3">\n            </span><span class="s1">passive: optionsIsObj &amp;&amp; Boolean(options.passive),</span><span class="s3">\n            </span><span class="s1">once: optionsIsObj &amp;&amp; Boolean(options.once),</span><span class="s3">\n            </span><span class="s1">next: null,</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n\n        </span><span class="s1">// Set it as the first node if the first node is null.</span><span class="s3">\n        </span><span class="s1">let node = listeners.get(eventName);</span><span class="s3">\n        </span><span class="s1">if (node === undefined) {</span><span class="s3">\n            </span><span class="s1">listeners.set(eventName, newNode);</span><span class="s3">\n            </span><span class="s1">return</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// Traverse to the tail while checking duplication..</span><span class="s3">\n        </span><span class="s1">let prev = null;</span><span class="s3">\n        </span><span class="s1">while (node != null) {</span><span class="s3">\n            </span><span class="s1">if (</span><span class="s3">\n                </span><span class="s1">node.listener === listener &amp;&amp;</span><span class="s3">\n                </span><span class="s1">node.listenerType === listenerType</span><span class="s3">\n            </span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">// Should ignore duplication.</span><span class="s3">\n                </span><span class="s1">return</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">prev = node;</span><span class="s3">\n            </span><span class="s1">node = node.next;\n        }\n\n        // Add it.\n        prev.next = newNode;\n    },\n\n    /**\n     * Remove a given listener from this event target.\n     * @param {string} eventName The event name to remove.\n     * @param {Function} listener The listener to remove.\n     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n     * @returns {void}\n     */\n    removeEventListener(eventName, listener, options) {\n        if (listener == null) {\n            return\n        }\n\n        const listeners = getListeners(this);\n        const capture = isObject(options)\n            ? Boolean(options.capture)\n            : Boolean(options);\n        const listenerType = capture ? CAPTURE : BUBBLE;\n\n        let prev = null;\n        let node = listeners.get(eventName);\n        while (node != null) {\n            if (\n                node.listener === listener &amp;&amp;\n                node.listenerType === listenerType\n            ) {\n                if (prev !== null) {\n                    prev.next = node.next;\n                } else if (node.next !== null) {\n                    listeners.set(eventName, node.next);\n                } else {\n                    listeners.delete(eventName);\n                }\n                return\n            }\n\n            prev = node;\n            node = node.next;\n        }\n    },\n\n    /**\n     * Dispatch a given event.\n     * @param {Event|{type:string}} event The event to dispatch.\n     * @returns {boolean} `false` if canceled.\n     */\n    dispatchEvent(event) {\n        if (event == null || typeof event.type !== \&quot;string\&quot;) {\n            throw new TypeError('\&quot;event.type\&quot; should be a string.')\n        }\n\n        // If listeners aren't registered, terminate.\n        const listeners = getListeners(this);\n        const eventName = event.type;\n        let node = listeners.get(eventName);\n        if (node == null) {\n            return true\n        }\n\n        // Since we cannot rewrite several properties, so wrap object.\n        const wrappedEvent = wrapEvent(this, event);\n\n        // This doesn't process capturing phase and bubbling phase.\n        // This isn't participating in a tree.\n        let prev = null;\n        while (node != null) {\n            // Remove this listener if it's once\n            if (node.once) {\n                if (prev !== null) {\n                    prev.next = node.next;\n                } else if (node.next !== null) {\n                    listeners.set(eventName, node.next);\n                } else {\n                    listeners.delete(eventName);\n                }\n            } else {\n                prev = node;\n            }\n\n            // Call this listener\n            setPassiveListener(\n                wrappedEvent,\n                node.passive ? node.listener : null\n            );\n            if (typeof node.listener === \&quot;function\&quot;) {\n                try {\n                    node.listener.call(this, wrappedEvent);\n                } catch (err) {\n                    if (\n                        typeof console !== \&quot;undefined\&quot; &amp;&amp;\n                        typeof console.error === \&quot;function\&quot;\n                    ) {\n                        console.error(err);\n                    }\n                }\n            } else if (\n                node.listenerType !== ATTRIBUTE &amp;&amp;\n                typeof node.listener.handleEvent === \&quot;function\&quot;\n            ) {\n                node.listener.handleEvent(wrappedEvent);\n            }\n\n            // Break if `event.stopImmediatePropagation` was called.\n            if (isStopped(wrappedEvent)) {\n                break\n            }\n\n            node = node.next;\n        }\n        setPassiveListener(wrappedEvent, null);\n        setEventPhase(wrappedEvent, 0);\n        setCurrentTarget(wrappedEvent, null);\n\n        return !wrappedEvent.defaultPrevented\n    },\n};\n\n// `constructor` is not enumerable.\nObject.defineProperty(EventTarget.prototype, \&quot;constructor\&quot;, {\n    value: EventTarget,\n    configurable: true,\n    writable: true,\n});\n\n// Ensure `eventTarget instanceof window.EventTarget` is `true`.\nif (\n    typeof window !== \&quot;undefined\&quot; &amp;&amp;\n    typeof window.EventTarget !== \&quot;undefined\&quot;\n) {\n    Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);\n}\n\nexport default EventTarget;\nexport { defineEventAttribute, EventTarget };\n//# sourceMappingURL=event-target-shim.mjs.map\n&quot;,&quot;import {\n    // Event,\n    EventTarget,\n    // Type,\n    defineEventAttribute,\n} from \&quot;event-target-shim\&quot;\n\n// Known Limitation\n//   Use `any` because the type of `AbortSignal` in `lib.dom.d.ts` is wrong and\n//   to make assignable our `AbortSignal` into that.\n//   https://github.com/Microsoft/TSJS-lib-generator/pull/623\ntype Events = {\n    abort: any // Event &amp; Type&lt;\&quot;abort\&quot;&gt;\n}\ntype EventAttributes = {\n    onabort: any // Event &amp; Type&lt;\&quot;abort\&quot;&gt;\n}\n\n/**\n * The signal class.\n * @see https://dom.spec.whatwg.org/#abortsignal\n */\nexport default class AbortSignal extends EventTarget&lt;Events, EventAttributes&gt; {\n    /**\n     * AbortSignal cannot be constructed directly.\n     */\n    public constructor() {\n        super()\n        throw new TypeError(\&quot;AbortSignal cannot be constructed directly\&quot;)\n    }\n\n    /**\n     * Returns `true` if this `AbortSignal`'s `AbortController` has signaled to abort, and `false` otherwise.\n     */\n    public get aborted(): boolean {\n        const aborted = abortedFlags.get(this)\n        if (typeof aborted !== \&quot;boolean\&quot;) {\n            throw new TypeError(\n                `Expected 'this' to be an 'AbortSignal' object, but got ${\n                    this === null ? \&quot;null\&quot; : typeof this\n                }`,\n            )\n        }\n        return aborted\n    }\n}\ndefineEventAttribute(AbortSignal.prototype, \&quot;abort\&quot;)\n\n/**\n * Create an AbortSignal object.\n */\nexport function createAbortSignal(): AbortSignal {\n    const signal = Object.create(AbortSignal.prototype)\n    EventTarget.call(signal)\n    abortedFlags.set(signal, false)\n    return signal\n}\n\n/**\n * Abort a given signal.\n */\nexport function abortSignal(signal: AbortSignal): void {\n    if (abortedFlags.get(signal) !== false) {\n        return\n    }\n\n    abortedFlags.set(signal, true)\n    signal.dispatchEvent&lt;\&quot;abort\&quot;&gt;({ type: \&quot;abort\&quot; })\n}\n\n/**\n * Aborted flag for each instances.\n */\nconst abortedFlags = new WeakMap&lt;AbortSignal, boolean&gt;()\n\n// Properties should be enumerable.\nObject.defineProperties(AbortSignal.prototype, {\n    aborted: { enumerable: true },\n})\n\n// `toString()` should return `\&quot;[object AbortSignal]\&quot;`\nif (typeof Symbol === \&quot;function\&quot; &amp;&amp; typeof Symbol.toStringTag === \&quot;symbol\&quot;) {\n    Object.defineProperty(AbortSignal.prototype, Symbol.toStringTag, {\n        configurable: true,\n        value: \&quot;AbortSignal\&quot;,\n    })\n}\n&quot;,&quot;import AbortSignal, { abortSignal, createAbortSignal } from \&quot;./abort-signal\&quot;\n\n/**\n * The AbortController.\n * @see https://dom.spec.whatwg.org/#abortcontroller\n */\nexport default class AbortController {\n    /**\n     * Initialize this controller.\n     */\n    public constructor() {\n        signals.set(this, createAbortSignal())\n    }\n\n    /**\n     * Returns the `AbortSignal` object associated with this object.\n     */\n    public get signal(): AbortSignal {\n        return getSignal(this)\n    }\n\n    /**\n     * Abort and signal to any observers that the associated activity is to be aborted.\n     */\n    public abort(): void {\n        abortSignal(getSignal(this))\n    }\n}\n\n/**\n * Associated signals.\n */\nconst signals = new WeakMap&lt;AbortController, AbortSignal&gt;()\n\n/**\n * Get the associated signal of a given controller.\n */\nfunction getSignal(controller: AbortController): AbortSignal {\n    const signal = signals.get(controller)\n    if (signal == null) {\n        throw new TypeError(\n            `Expected 'this' to be an 'AbortController' object, but got ${\n                controller === null ? \&quot;null\&quot; : typeof controller\n            }`,\n        )\n    }\n    return signal\n}\n\n// Properties should be enumerable.\nObject.defineProperties(AbortController.prototype, {\n    signal: { enumerable: true },\n    abort: { enumerable: true },\n})\n\nif (typeof Symbol === \&quot;function\&quot; &amp;&amp; typeof Symbol.toStringTag === \&quot;symbol\&quot;) {\n    Object.defineProperty(AbortController.prototype, Symbol.toStringTag, {\n        configurable: true,\n        value: \&quot;AbortController\&quot;,\n    })\n}\n\nexport { AbortController, AbortSignal }\n&quot;],&quot;names&quot;:[&quot;pd&quot;,&quot;event&quot;,&quot;retv&quot;,&quot;privateData&quot;,&quot;get&quot;,&quot;console&quot;,&quot;assert&quot;,&quot;setCancelFlag&quot;,&quot;data&quot;,&quot;passiveListener&quot;,&quot;cancelable&quot;,&quot;canceled&quot;,&quot;preventDefault&quot;,&quot;error&quot;,&quot;Event&quot;,&quot;eventTarget&quot;,&quot;set&quot;,&quot;eventPhase&quot;,&quot;currentTarget&quot;,&quot;stopped&quot;,&quot;immediateStopped&quot;,&quot;timeStamp&quot;,&quot;Date&quot;,&quot;now&quot;,&quot;Object&quot;,&quot;defineProperty&quot;,&quot;value&quot;,&quot;enumerable&quot;,&quot;key&quot;,&quot;keys&quot;,&quot;i&quot;,&quot;length&quot;,&quot;defineRedirectDescriptor&quot;,&quot;configurable&quot;,&quot;defineCallDescriptor&quot;,&quot;apply&quot;,&quot;arguments&quot;,&quot;defineWrapper&quot;,&quot;BaseEvent&quot;,&quot;proto&quot;,&quot;CustomEvent&quot;,&quot;call&quot;,&quot;prototype&quot;,&quot;create&quot;,&quot;constructor&quot;,&quot;writable&quot;,&quot;descriptor&quot;,&quot;getOwnPropertyDescriptor&quot;,&quot;isFunc&quot;,&quot;getWrapper&quot;,&quot;wrapper&quot;,&quot;wrappers&quot;,&quot;getPrototypeOf&quot;,&quot;wrapEvent&quot;,&quot;Wrapper&quot;,&quot;isStopped&quot;,&quot;setEventPhase&quot;,&quot;setCurrentTarget&quot;,&quot;setPassiveListener&quot;,&quot;createAbortSignal&quot;,&quot;signal&quot;,&quot;AbortSignal&quot;,&quot;EventTarget&quot;,&quot;abortedFlags&quot;,&quot;abortSignal&quot;,&quot;dispatchEvent&quot;,&quot;type&quot;,&quot;getSignal&quot;,&quot;controller&quot;,&quot;signals&quot;,&quot;TypeError&quot;,&quot;WeakMap&quot;,&quot;target&quot;,&quot;composedPath&quot;,&quot;NONE&quot;,&quot;CAPTURING_PHASE&quot;,&quot;AT_TARGET&quot;,&quot;BUBBLING_PHASE&quot;,&quot;stopPropagation&quot;,&quot;stopImmediatePropagation&quot;,&quot;bubbles&quot;,&quot;defaultPrevented&quot;,&quot;composed&quot;,&quot;srcElement&quot;,&quot;cancelBubble&quot;,&quot;returnValue&quot;,&quot;initEvent&quot;,&quot;window&quot;,&quot;setPrototypeOf&quot;,&quot;aborted&quot;,&quot;defineEventAttribute&quot;,&quot;defineProperties&quot;,&quot;Symbol&quot;,&quot;_typeof&quot;,&quot;toStringTag&quot;,&quot;AbortController&quot;,&quot;abort&quot;],&quot;mappings&quot;:&quot;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&quot;}</span></pre>
</body>
</html>
<html>
<head>
<title>ScrollView.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #cc7832;}
.s2 { color: #a9b7c6;}
.s3 { color: #9876aa; font-style: italic;}
.s4 { color: #a9b7c6;}
.s5 { color: #6a8759;}
.s6 { color: #ffc66d;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
ScrollView.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 * 
 * </span><span class="s1">@format</span>
 <span class="s0">*/</span>

<span class="s1">import type </span><span class="s3">* </span><span class="s1">as </span><span class="s4">React </span><span class="s1">from </span><span class="s5">'react'</span><span class="s2">;</span>
<span class="s1">import </span><span class="s2">{</span><span class="s4">Constructor</span><span class="s2">} </span><span class="s1">from </span><span class="s5">'../../../types/private/Utilities'</span><span class="s2">;</span>
<span class="s1">import </span><span class="s2">{</span><span class="s4">Insets</span><span class="s2">} </span><span class="s1">from </span><span class="s5">'../../../types/public/Insets'</span><span class="s2">;</span>
<span class="s1">import </span><span class="s2">{</span><span class="s4">ColorValue</span><span class="s2">, </span><span class="s4">StyleProp</span><span class="s2">} </span><span class="s1">from </span><span class="s5">'../../StyleSheet/StyleSheet'</span><span class="s2">;</span>
<span class="s1">import </span><span class="s2">{</span><span class="s4">ViewStyle</span><span class="s2">} </span><span class="s1">from </span><span class="s5">'../../StyleSheet/StyleSheetTypes'</span><span class="s2">;</span>
<span class="s1">import </span><span class="s2">{</span>
  <span class="s4">NativeSyntheticEvent</span><span class="s2">,</span>
  <span class="s4">NativeTouchEvent</span><span class="s2">,</span>
<span class="s2">} </span><span class="s1">from </span><span class="s5">'../../Types/CoreEventTypes'</span><span class="s2">;</span>
<span class="s1">import </span><span class="s2">{</span><span class="s4">RefreshControlProps</span><span class="s2">} </span><span class="s1">from </span><span class="s5">'../RefreshControl/RefreshControl'</span><span class="s2">;</span>
<span class="s1">import </span><span class="s2">{</span><span class="s4">Touchable</span><span class="s2">} </span><span class="s1">from </span><span class="s5">'../Touchable/Touchable'</span><span class="s2">;</span>
<span class="s1">import </span><span class="s2">{</span><span class="s4">ViewProps</span><span class="s2">} </span><span class="s1">from </span><span class="s5">'../View/ViewPropTypes'</span><span class="s2">;</span>

<span class="s0">// See https://reactnative.dev/docs/scrollview#contentoffset</span>
<span class="s1">export interface </span><span class="s4">PointProp </span><span class="s2">{</span>
  <span class="s2">x</span><span class="s1">: </span><span class="s4">number</span><span class="s2">;</span>
  <span class="s2">y</span><span class="s1">: </span><span class="s4">number</span><span class="s2">;</span>
<span class="s2">}</span>

<span class="s1">export interface </span><span class="s4">ScrollResponderEvent</span>
  <span class="s1">extends </span><span class="s4">NativeSyntheticEvent</span><span class="s2">&lt;</span><span class="s4">NativeTouchEvent</span><span class="s2">&gt; {}</span>

<span class="s1">interface </span><span class="s4">SubscribableMixin </span><span class="s2">{</span>
  <span class="s0">/**</span>
   <span class="s0">* Special form of calling `addListener` that *guarantees* that a 
   * subscription *must* be tied to a component instance, and therefore will 
   * be cleaned up when the component is unmounted. It is impossible to create 
   * the subscription and pass it in - this method must be the one to create 
   * the subscription and therefore can guarantee it is retained in a way that 
   * will be cleaned up. 
   * 
   * </span><span class="s1">@param </span><span class="s4">eventEmitter </span><span class="s0">emitter to subscribe to. 
   * </span><span class="s1">@param </span><span class="s4">eventType </span><span class="s0">Type of event to listen to. 
   * </span><span class="s1">@param </span><span class="s4">listener </span><span class="s0">Function to invoke when event occurs. 
   * </span><span class="s1">@param </span><span class="s4">context </span><span class="s0">Object to use as listener context. 
   */</span>
  <span class="s2">addListenerOn(</span>
    <span class="s4">eventEmitter</span><span class="s1">: </span><span class="s4">any</span><span class="s2">,</span>
    <span class="s4">eventType</span><span class="s1">: </span><span class="s4">string</span><span class="s2">,</span>
    <span class="s6">listener</span><span class="s1">: </span><span class="s2">() </span><span class="s1">=&gt; </span><span class="s4">any</span><span class="s2">,</span>
    <span class="s4">context</span><span class="s1">: </span><span class="s4">any</span><span class="s2">,</span>
  <span class="s2">)</span><span class="s1">: </span><span class="s4">void</span><span class="s2">;</span>
<span class="s2">}</span>

<span class="s1">interface </span><span class="s4">ScrollResponderMixin </span><span class="s1">extends </span><span class="s4">SubscribableMixin </span><span class="s2">{</span>
  <span class="s0">/**</span>
   <span class="s0">* Invoke this from an `onScroll` event. 
   */</span>
  <span class="s2">scrollResponderHandleScrollShouldSetResponder()</span><span class="s1">: </span><span class="s4">boolean</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* Merely touch starting is not sufficient for a scroll view to become the 
   * responder. Being the &quot;responder&quot; means that the very next touch move/end 
   * event will result in an action/movement. 
   * 
   * Invoke this from an `onStartShouldSetResponder` event. 
   * 
   * `onStartShouldSetResponder` is used when the next move/end will trigger 
   * some UI movement/action, but when you want to yield priority to views 
   * nested inside of the view. 
   * 
   * There may be some cases where scroll views actually should return `true` 
   * from `onStartShouldSetResponder`: Any time we are detecting a standard tap 
   * that gives priority to nested views. 
   * 
   * - If a single tap on the scroll view triggers an action such as 
   *   recentering a map style view yet wants to give priority to interaction 
   *   views inside (such as dropped pins or labels), then we would return true 
   *   from this method when there is a single touch. 
   * 
   * - Similar to the previous case, if a two finger &quot;tap&quot; should trigger a 
   *   zoom, we would check the `touches` count, and if `&gt;= 2`, we would return 
   *   true. 
   * 
   */</span>
  <span class="s2">scrollResponderHandleStartShouldSetResponder()</span><span class="s1">: </span><span class="s4">boolean</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* There are times when the scroll view wants to become the responder 
   * (meaning respond to the next immediate `touchStart/touchEnd`), in a way 
   * that *doesn't* give priority to nested views (hence the capture phase): 
   * 
   * - Currently animating. 
   * - Tapping anywhere that is not the focused input, while the keyboard is 
   *   up (which should dismiss the keyboard). 
   * 
   * Invoke this from an `onStartShouldSetResponderCapture` event. 
   */</span>
  <span class="s2">scrollResponderHandleStartShouldSetResponderCapture(</span>
    <span class="s4">e</span><span class="s1">: </span><span class="s4">ScrollResponderEvent</span><span class="s2">,</span>
  <span class="s2">)</span><span class="s1">: </span><span class="s4">boolean</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* Invoke this from an `onResponderReject` event. 
   * 
   * Some other element is not yielding its role as responder. Normally, we'd 
   * just disable the `UIScrollView`, but a touch has already began on it, the 
   * `UIScrollView` will not accept being disabled after that. The easiest 
   * solution for now is to accept the limitation of disallowing this 
   * altogether. To improve this, find a way to disable the `UIScrollView` after 
   * a touch has already started. 
   */</span>
  <span class="s2">scrollResponderHandleResponderReject()</span><span class="s1">: </span><span class="s4">any</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* We will allow the scroll view to give up its lock iff it acquired the lock 
   * during an animation. This is a very useful default that happens to satisfy 
   * many common user experiences. 
   * 
   * - Stop a scroll on the left edge, then turn that into an outer view's 
   *   backswipe. 
   * - Stop a scroll mid-bounce at the top, continue pulling to have the outer 
   *   view dismiss. 
   * - However, without catching the scroll view mid-bounce (while it is 
   *   motionless), if you drag far enough for the scroll view to become 
   *   responder (and therefore drag the scroll view a bit), any backswipe 
   *   navigation of a swipe gesture higher in the view hierarchy, should be 
   *   rejected. 
   */</span>
  <span class="s2">scrollResponderHandleTerminationRequest()</span><span class="s1">: </span><span class="s4">boolean</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* Invoke this from an `onTouchEnd` event. 
   * 
   * </span><span class="s1">@param </span><span class="s4">e </span><span class="s0">Event. 
   */</span>
  <span class="s2">scrollResponderHandleTouchEnd(</span><span class="s4">e</span><span class="s1">: </span><span class="s4">ScrollResponderEvent</span><span class="s2">)</span><span class="s1">: </span><span class="s4">void</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* Invoke this from an `onResponderRelease` event. 
   */</span>
  <span class="s2">scrollResponderHandleResponderRelease(</span><span class="s4">e</span><span class="s1">: </span><span class="s4">ScrollResponderEvent</span><span class="s2">)</span><span class="s1">: </span><span class="s4">void</span><span class="s2">;</span>

  <span class="s2">scrollResponderHandleScroll(</span><span class="s4">e</span><span class="s1">: </span><span class="s4">ScrollResponderEvent</span><span class="s2">)</span><span class="s1">: </span><span class="s4">void</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* Invoke this from an `onResponderGrant` event. 
   */</span>
  <span class="s2">scrollResponderHandleResponderGrant(</span><span class="s4">e</span><span class="s1">: </span><span class="s4">ScrollResponderEvent</span><span class="s2">)</span><span class="s1">: </span><span class="s4">void</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* Unfortunately, `onScrollBeginDrag` also fires when *stopping* the scroll 
   * animation, and there's not an easy way to distinguish a drag vs. stopping 
   * momentum. 
   * 
   * Invoke this from an `onScrollBeginDrag` event. 
   */</span>
  <span class="s2">scrollResponderHandleScrollBeginDrag(</span><span class="s4">e</span><span class="s1">: </span><span class="s4">ScrollResponderEvent</span><span class="s2">)</span><span class="s1">: </span><span class="s4">void</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* Invoke this from an `onScrollEndDrag` event. 
   */</span>
  <span class="s2">scrollResponderHandleScrollEndDrag(</span><span class="s4">e</span><span class="s1">: </span><span class="s4">ScrollResponderEvent</span><span class="s2">)</span><span class="s1">: </span><span class="s4">void</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* Invoke this from an `onMomentumScrollBegin` event. 
   */</span>
  <span class="s2">scrollResponderHandleMomentumScrollBegin(</span><span class="s4">e</span><span class="s1">: </span><span class="s4">ScrollResponderEvent</span><span class="s2">)</span><span class="s1">: </span><span class="s4">void</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* Invoke this from an `onMomentumScrollEnd` event. 
   */</span>
  <span class="s2">scrollResponderHandleMomentumScrollEnd(</span><span class="s4">e</span><span class="s1">: </span><span class="s4">ScrollResponderEvent</span><span class="s2">)</span><span class="s1">: </span><span class="s4">void</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* Invoke this from an `onTouchStart` event. 
   * 
   * Since we know that the `SimpleEventPlugin` occurs later in the plugin 
   * order, after `ResponderEventPlugin`, we can detect that we were *not* 
   * permitted to be the responder (presumably because a contained view became 
   * responder). The `onResponderReject` won't fire in that case - it only 
   * fires when a *current* responder rejects our request. 
   * 
   * </span><span class="s1">@param </span><span class="s4">e </span><span class="s0">Touch Start event. 
   */</span>
  <span class="s2">scrollResponderHandleTouchStart(</span><span class="s4">e</span><span class="s1">: </span><span class="s4">ScrollResponderEvent</span><span class="s2">)</span><span class="s1">: </span><span class="s4">void</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* Invoke this from an `onTouchMove` event. 
   * 
   * Since we know that the `SimpleEventPlugin` occurs later in the plugin 
   * order, after `ResponderEventPlugin`, we can detect that we were *not* 
   * permitted to be the responder (presumably because a contained view became 
   * responder). The `onResponderReject` won't fire in that case - it only 
   * fires when a *current* responder rejects our request. 
   * 
   * </span><span class="s1">@param </span><span class="s4">e </span><span class="s0">Touch Start event. 
   */</span>
  <span class="s2">scrollResponderHandleTouchMove(</span><span class="s4">e</span><span class="s1">: </span><span class="s4">ScrollResponderEvent</span><span class="s2">)</span><span class="s1">: </span><span class="s4">void</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* A helper function for this class that lets us quickly determine if the 
   * view is currently animating. This is particularly useful to know when 
   * a touch has just started or ended. 
   */</span>
  <span class="s2">scrollResponderIsAnimating()</span><span class="s1">: </span><span class="s4">boolean</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* Returns the node that represents native view that can be scrolled. 
   * Components can pass what node to use by defining a `getScrollableNode` 
   * function otherwise `this` is used. 
   */</span>
  <span class="s2">scrollResponderGetScrollableNode()</span><span class="s1">: </span><span class="s4">any</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* A helper function to scroll to a specific point  in the scrollview. 
   * This is currently used to help focus on child textviews, but can also 
   * be used to quickly scroll to any element we want to focus. Syntax: 
   * 
   * scrollResponderScrollTo(options: {x: number = 0; y: number = 0; animated: boolean = true}) 
   * 
   * Note: The weird argument signature is due to the fact that, for historical reasons, 
   * the function also accepts separate arguments as an alternative to the options object. 
   * This is deprecated due to ambiguity (y before x), and SHOULD NOT BE USED. 
   */</span>
  <span class="s2">scrollResponderScrollTo(</span>
    <span class="s4">x</span><span class="s1">?:</span>
      <span class="s1">| </span><span class="s4">number</span>
      <span class="s1">| </span><span class="s2">{</span>
          <span class="s2">x</span><span class="s1">?: </span><span class="s4">number </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">;</span>
          <span class="s2">y</span><span class="s1">?: </span><span class="s4">number </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">;</span>
          <span class="s2">animated</span><span class="s1">?: </span><span class="s4">boolean </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">;</span>
        <span class="s2">},</span>
    <span class="s4">y</span><span class="s1">?: </span><span class="s4">number</span><span class="s2">,</span>
    <span class="s4">animated</span><span class="s1">?: </span><span class="s4">boolean</span><span class="s2">,</span>
  <span class="s2">)</span><span class="s1">: </span><span class="s4">void</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* A helper function to zoom to a specific rect in the scrollview. The argument has the shape 
   * {x: number; y: number; width: number; height: number; animated: boolean = true} 
   * 
   * </span><span class="s1">@platform </span><span class="s0">ios 
   */</span>
  <span class="s2">scrollResponderZoomTo(</span>
    <span class="s4">rect</span><span class="s1">: </span><span class="s2">{</span>
      <span class="s2">x</span><span class="s1">: </span><span class="s4">number</span><span class="s2">;</span>
      <span class="s2">y</span><span class="s1">: </span><span class="s4">number</span><span class="s2">;</span>
      <span class="s2">width</span><span class="s1">: </span><span class="s4">number</span><span class="s2">;</span>
      <span class="s2">height</span><span class="s1">: </span><span class="s4">number</span><span class="s2">;</span>
      <span class="s2">animated</span><span class="s1">?: </span><span class="s4">boolean </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">;</span>
    <span class="s2">},</span>
    <span class="s4">animated</span><span class="s1">?: </span><span class="s4">boolean</span><span class="s2">, </span><span class="s0">// deprecated, put this inside the rect argument instead</span>
  <span class="s2">)</span><span class="s1">: </span><span class="s4">void</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* This method should be used as the callback to onFocus in a TextInputs' 
   * parent view. Note that any module using this mixin needs to return 
   * the parent view's ref in getScrollViewRef() in order to use this method. 
   * </span><span class="s1">@param </span><span class="s4">nodeHandle </span><span class="s0">The TextInput node handle 
   * </span><span class="s1">@param </span><span class="s4">additionalOffset </span><span class="s0">The scroll view's top &quot;contentInset&quot;. 
   *        Default is 0. 
   * </span><span class="s1">@param </span><span class="s4">preventNegativeScrolling </span><span class="s0">Whether to allow pulling the content 
   *        down to make it meet the keyboard's top. Default is false. 
   */</span>
  <span class="s2">scrollResponderScrollNativeHandleToKeyboard(</span>
    <span class="s4">nodeHandle</span><span class="s1">: </span><span class="s4">any</span><span class="s2">,</span>
    <span class="s4">additionalOffset</span><span class="s1">?: </span><span class="s4">number</span><span class="s2">,</span>
    <span class="s4">preventNegativeScrollOffset</span><span class="s1">?: </span><span class="s4">boolean</span><span class="s2">,</span>
  <span class="s2">)</span><span class="s1">: </span><span class="s4">void</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* The calculations performed here assume the scroll view takes up the entire 
   * screen - even if has some content inset. We then measure the offsets of the 
   * keyboard, and compensate both for the scroll view's &quot;contentInset&quot;. 
   * 
   * </span><span class="s1">@param </span><span class="s4">left </span><span class="s0">Position of input w.r.t. table view. 
   * </span><span class="s1">@param </span><span class="s4">top </span><span class="s0">Position of input w.r.t. table view. 
   * </span><span class="s1">@param </span><span class="s4">width </span><span class="s0">Width of the text input. 
   * </span><span class="s1">@param </span><span class="s4">height </span><span class="s0">Height of the text input. 
   */</span>
  <span class="s2">scrollResponderInputMeasureAndScrollToKeyboard(</span>
    <span class="s4">left</span><span class="s1">: </span><span class="s4">number</span><span class="s2">,</span>
    <span class="s4">top</span><span class="s1">: </span><span class="s4">number</span><span class="s2">,</span>
    <span class="s4">width</span><span class="s1">: </span><span class="s4">number</span><span class="s2">,</span>
    <span class="s4">height</span><span class="s1">: </span><span class="s4">number</span><span class="s2">,</span>
  <span class="s2">)</span><span class="s1">: </span><span class="s4">void</span><span class="s2">;</span>

  <span class="s2">scrollResponderTextInputFocusError(</span><span class="s4">e</span><span class="s1">: </span><span class="s4">ScrollResponderEvent</span><span class="s2">)</span><span class="s1">: </span><span class="s4">void</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* `componentWillMount` is the closest thing to a  standard &quot;constructor&quot; for 
   * React components. 
   * 
   * The `keyboardWillShow` is called before input focus. 
   */</span>
  <span class="s2">componentWillMount()</span><span class="s1">: </span><span class="s4">void</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* Warning, this may be called several times for a single keyboard opening. 
   * It's best to store the information in this method and then take any action 
   * at a later point (either in `keyboardDidShow` or other). 
   * 
   * Here's the order that events occur in: 
   * - focus 
   * - willShow {startCoordinates, endCoordinates} several times 
   * - didShow several times 
   * - blur 
   * - willHide {startCoordinates, endCoordinates} several times 
   * - didHide several times 
   * 
   * The `ScrollResponder` providesModule callbacks for each of these events. 
   * Even though any user could have easily listened to keyboard events 
   * themselves, using these `props` callbacks ensures that ordering of events 
   * is consistent - and not dependent on the order that the keyboard events are 
   * subscribed to. This matters when telling the scroll view to scroll to where 
   * the keyboard is headed - the scroll responder better have been notified of 
   * the keyboard destination before being instructed to scroll to where the 
   * keyboard will be. Stick to the `ScrollResponder` callbacks, and everything 
   * will work. 
   * 
   * WARNING: These callbacks will fire even if a keyboard is displayed in a 
   * different navigation pane. Filter out the events to determine if they are 
   * relevant to you. (For example, only if you receive these callbacks after 
   * you had explicitly focused a node etc). 
   */</span>
  <span class="s2">scrollResponderKeyboardWillShow(</span><span class="s4">e</span><span class="s1">: </span><span class="s4">ScrollResponderEvent</span><span class="s2">)</span><span class="s1">: </span><span class="s4">void</span><span class="s2">;</span>

  <span class="s2">scrollResponderKeyboardWillHide(</span><span class="s4">e</span><span class="s1">: </span><span class="s4">ScrollResponderEvent</span><span class="s2">)</span><span class="s1">: </span><span class="s4">void</span><span class="s2">;</span>

  <span class="s2">scrollResponderKeyboardDidShow(</span><span class="s4">e</span><span class="s1">: </span><span class="s4">ScrollResponderEvent</span><span class="s2">)</span><span class="s1">: </span><span class="s4">void</span><span class="s2">;</span>

  <span class="s2">scrollResponderKeyboardDidHide(</span><span class="s4">e</span><span class="s1">: </span><span class="s4">ScrollResponderEvent</span><span class="s2">)</span><span class="s1">: </span><span class="s4">void</span><span class="s2">;</span>
<span class="s2">}</span>

<span class="s1">export interface </span><span class="s4">ScrollViewPropsIOS </span><span class="s2">{</span>
  <span class="s0">/**</span>
   <span class="s0">* When true the scroll view bounces horizontally when it reaches the end 
   * even if the content is smaller than the scroll view itself. The default 
   * value is true when `horizontal={true}` and false otherwise. 
   */</span>
  <span class="s2">alwaysBounceHorizontal</span><span class="s1">?: </span><span class="s4">boolean </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">;</span>
  <span class="s0">/**</span>
   <span class="s0">* When true the scroll view bounces vertically when it reaches the end 
   * even if the content is smaller than the scroll view itself. The default 
   * value is false when `horizontal={true}` and true otherwise. 
   */</span>
  <span class="s2">alwaysBounceVertical</span><span class="s1">?: </span><span class="s4">boolean </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* Controls whether iOS should automatically adjust the content inset for scroll views that are placed behind a navigation bar or tab bar/ toolbar. 
   * The default value is true. 
   */</span>
  <span class="s2">automaticallyAdjustContentInsets</span><span class="s1">?: </span><span class="s4">boolean </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">; </span><span class="s0">// true</span>

  <span class="s0">/**</span>
   <span class="s0">* Controls whether the ScrollView should automatically adjust its contentInset and 
   * scrollViewInsets when the Keyboard changes its size. The default value is false. 
   */</span>
  <span class="s2">automaticallyAdjustKeyboardInsets</span><span class="s1">?: </span><span class="s4">boolean </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* Controls whether iOS should automatically adjust the scroll indicator 
   * insets. The default value is true. Available on iOS 13 and later. 
   */</span>
  <span class="s2">automaticallyAdjustsScrollIndicatorInsets</span><span class="s1">?: </span><span class="s4">boolean </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* When true the scroll view bounces when it reaches the end of the 
   * content if the content is larger then the scroll view along the axis of 
   * the scroll direction. When false it disables all bouncing even if 
   * the `alwaysBounce*` props are true. The default value is true. 
   */</span>
  <span class="s2">bounces</span><span class="s1">?: </span><span class="s4">boolean </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">;</span>
  <span class="s0">/**</span>
   <span class="s0">* When true gestures can drive zoom past min/max and the zoom will animate 
   * to the min/max value at gesture end otherwise the zoom will not exceed 
   * the limits. 
   */</span>
  <span class="s2">bouncesZoom</span><span class="s1">?: </span><span class="s4">boolean </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* When false once tracking starts won't try to drag if the touch moves. 
   * The default value is true. 
   */</span>
  <span class="s2">canCancelContentTouches</span><span class="s1">?: </span><span class="s4">boolean </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* When true the scroll view automatically centers the content when the 
   * content is smaller than the scroll view bounds; when the content is 
   * larger than the scroll view this property has no effect. The default 
   * value is false. 
   */</span>
  <span class="s2">centerContent</span><span class="s1">?: </span><span class="s4">boolean </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* The amount by which the scroll view content is inset from the edges of the scroll view. 
   * Defaults to {0, 0, 0, 0}. 
   */</span>
  <span class="s2">contentInset</span><span class="s1">?: </span><span class="s4">Insets </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">; </span><span class="s0">// zeros</span>

  <span class="s0">/**</span>
   <span class="s0">* Used to manually set the starting scroll offset. 
   * The default value is {x: 0, y: 0} 
   */</span>
  <span class="s2">contentOffset</span><span class="s1">?: </span><span class="s4">PointProp </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">; </span><span class="s0">// zeros</span>

  <span class="s0">/**</span>
   <span class="s0">* This property specifies how the safe area insets are used to modify the content area of the scroll view. 
   * The default value of this property must be 'automatic'. But the default value is 'never' until RN@0.51. 
   */</span>
  <span class="s2">contentInsetAdjustmentBehavior</span><span class="s1">?:</span>
    <span class="s1">| </span><span class="s5">'automatic'</span>
    <span class="s1">| </span><span class="s5">'scrollableAxes'</span>
    <span class="s1">| </span><span class="s5">'never'</span>
    <span class="s1">| </span><span class="s5">'always'</span>
    <span class="s1">| </span><span class="s2">undefined;</span>

  <span class="s0">/**</span>
   <span class="s0">* When true the ScrollView will try to lock to only vertical or horizontal 
   * scrolling while dragging.  The default value is false. 
   */</span>
  <span class="s2">directionalLockEnabled</span><span class="s1">?: </span><span class="s4">boolean </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* The style of the scroll indicators. 
   * - default (the default), same as black. 
   * - black, scroll indicator is black. This style is good against 
   *   a white content background. 
   * - white, scroll indicator is white. This style is good against 
   *   a black content background. 
   */</span>
  <span class="s2">indicatorStyle</span><span class="s1">?: </span><span class="s5">'default' </span><span class="s1">| </span><span class="s5">'black' </span><span class="s1">| </span><span class="s5">'white' </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* When set, the scroll view will adjust the scroll position so that the first child 
   * that is currently visible and at or beyond minIndexForVisible will not change position. 
   * This is useful for lists that are loading content in both directions, e.g. a chat thread, 
   * where new messages coming in might otherwise cause the scroll position to jump. A value 
   * of 0 is common, but other values such as 1 can be used to skip loading spinners or other 
   * content that should not maintain position. 
   * 
   * The optional autoscrollToTopThreshold can be used to make the content automatically scroll 
   * to the top after making the adjustment if the user was within the threshold of the top 
   * before the adjustment was made. This is also useful for chat-like applications where you 
   * want to see new messages scroll into place, but not if the user has scrolled up a ways and 
   * it would be disruptive to scroll a bunch. 
   * 
   * Caveat 1: Reordering elements in the scrollview with this enabled will probably cause 
   * jumpiness and jank. It can be fixed, but there are currently no plans to do so. For now, 
   * don't re-order the content of any ScrollViews or Lists that use this feature. 
   * 
   * Caveat 2: This uses contentOffset and frame.origin in native code to compute visibility. 
   * Occlusion, transforms, and other complexity won't be taken into account as to whether 
   * content is &quot;visible&quot; or not. 
   */</span>
  <span class="s2">maintainVisibleContentPosition</span><span class="s1">?:</span>
    <span class="s1">| </span><span class="s4">null</span>
    <span class="s1">| </span><span class="s2">{</span>
        <span class="s4">autoscrollToTopThreshold</span><span class="s1">?: </span><span class="s4">number </span><span class="s1">| </span><span class="s3">null </span><span class="s1">| </span><span class="s3">undefined</span><span class="s2">;</span>
        <span class="s4">minIndexForVisible</span><span class="s2">: </span><span class="s4">number</span><span class="s2">;</span>
      <span class="s2">}</span>
    <span class="s1">| </span><span class="s2">undefined;</span>
  <span class="s0">/**</span>
   <span class="s0">* The maximum allowed zoom scale. The default value is 1.0. 
   */</span>
  <span class="s2">maximumZoomScale</span><span class="s1">?: </span><span class="s4">number </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* The minimum allowed zoom scale. The default value is 1.0. 
   */</span>
  <span class="s2">minimumZoomScale</span><span class="s1">?: </span><span class="s4">number </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* Called when a scrolling animation ends. 
   */</span>
  <span class="s2">onScrollAnimationEnd</span><span class="s1">?: </span><span class="s2">(() </span><span class="s1">=&gt; </span><span class="s4">void</span><span class="s2">) </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* When true, ScrollView allows use of pinch gestures to zoom in and out. 
   * The default value is true. 
   */</span>
  <span class="s2">pinchGestureEnabled</span><span class="s1">?: </span><span class="s4">boolean </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* This controls how often the scroll event will be fired while scrolling (as a time interval in ms). 
   * A lower number yields better accuracy for code that is tracking the scroll position, 
   * but can lead to scroll performance problems due to the volume of information being sent over the bridge. 
   * The default value is zero, which means the scroll event will be sent only once each time the view is scrolled. 
   */</span>
  <span class="s2">scrollEventThrottle</span><span class="s1">?: </span><span class="s4">number </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">; </span><span class="s0">// null</span>

  <span class="s0">/**</span>
   <span class="s0">* The amount by which the scroll view indicators are inset from the edges of the scroll view. 
   * This should normally be set to the same value as the contentInset. 
   * Defaults to {0, 0, 0, 0}. 
   */</span>
  <span class="s2">scrollIndicatorInsets</span><span class="s1">?: </span><span class="s4">Insets </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">; </span><span class="s0">//zeroes</span>

  <span class="s0">/**</span>
   <span class="s0">* When true, the scroll view can be programmatically scrolled beyond its 
   * content size. The default value is false. 
   * </span><span class="s1">@platform </span><span class="s0">ios 
   */</span>
  <span class="s2">scrollToOverflowEnabled</span><span class="s1">?: </span><span class="s4">boolean </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* When true the scroll view scrolls to top when the status bar is tapped. 
   * The default value is true. 
   */</span>
  <span class="s2">scrollsToTop</span><span class="s1">?: </span><span class="s4">boolean </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* When `snapToInterval` is set, `snapToAlignment` will define the relationship of the snapping to the scroll view. 
   *      - `start` (the default) will align the snap at the left (horizontal) or top (vertical) 
   *      - `center` will align the snap in the center 
   *      - `end` will align the snap at the right (horizontal) or bottom (vertical) 
   */</span>
  <span class="s2">snapToAlignment</span><span class="s1">?: </span><span class="s5">'start' </span><span class="s1">| </span><span class="s5">'center' </span><span class="s1">| </span><span class="s5">'end' </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* Fires when the scroll view scrolls to top after the status bar has been tapped 
   * </span><span class="s1">@platform </span><span class="s0">ios 
   */</span>
  <span class="s2">onScrollToTop</span><span class="s1">?:</span>
    <span class="s1">| </span><span class="s2">((</span><span class="s4">event</span><span class="s1">: </span><span class="s4">NativeSyntheticEvent</span><span class="s2">&lt;</span><span class="s4">NativeScrollEvent</span><span class="s2">&gt;) </span><span class="s1">=&gt; </span><span class="s4">void</span><span class="s2">)</span>
    <span class="s1">| </span><span class="s2">undefined;</span>

  <span class="s0">/**</span>
   <span class="s0">* The current scale of the scroll view content. The default value is 1.0. 
   */</span>
  <span class="s2">zoomScale</span><span class="s1">?: </span><span class="s4">number </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">;</span>
<span class="s2">}</span>

<span class="s1">export interface </span><span class="s4">ScrollViewPropsAndroid </span><span class="s2">{</span>
  <span class="s0">/**</span>
   <span class="s0">* Sometimes a scrollview takes up more space than its content fills. 
   * When this is the case, this prop will fill the rest of the 
   * scrollview with a color to avoid setting a background and creating 
   * unnecessary overdraw. This is an advanced optimization that is not 
   * needed in the general case. 
   */</span>
  <span class="s2">endFillColor</span><span class="s1">?: </span><span class="s4">ColorValue </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* Tag used to log scroll performance on this scroll view. Will force 
   * momentum events to be turned on (see sendMomentumEvents). This doesn't do 
   * anything out of the box and you need to implement a custom native 
   * FpsListener for it to be useful. 
   * </span><span class="s1">@platform </span><span class="s0">android 
   */</span>
  <span class="s2">scrollPerfTag</span><span class="s1">?: </span><span class="s4">string </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">;</span>

  <span class="s0">/**</span>
     <span class="s0">* Used to override default value of overScroll mode. 
</span>
        <span class="s0">* Possible values: 
        *   - 'auto' - Default value, allow a user to over-scroll this view only if the content is large enough to meaningfully scroll. 
        *   - 'always' - Always allow a user to over-scroll this view. 
        *   - 'never' - Never allow a user to over-scroll this view. 
        */</span>
  <span class="s2">overScrollMode</span><span class="s1">?: </span><span class="s5">'auto' </span><span class="s1">| </span><span class="s5">'always' </span><span class="s1">| </span><span class="s5">'never' </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* Enables nested scrolling for Android API level 21+. Nested scrolling is supported by default on iOS. 
   */</span>
  <span class="s2">nestedScrollEnabled</span><span class="s1">?: </span><span class="s4">boolean </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* Fades out the edges of the scroll content. 
   * 
   * If the value is greater than 0, the fading edges will be set accordingly 
   * to the current scroll direction and position, 
   * indicating if there is more content to show. 
   * 
   * The default value is 0. 
   * </span><span class="s1">@platform </span><span class="s0">android 
   */</span>
  <span class="s2">fadingEdgeLength</span><span class="s1">?: </span><span class="s4">number </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* Causes the scrollbars not to turn transparent when they are not in use. The default value is false. 
   */</span>
  <span class="s2">persistentScrollbar</span><span class="s1">?: </span><span class="s4">boolean </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">;</span>
<span class="s2">}</span>

<span class="s1">export interface </span><span class="s4">ScrollViewProps</span>
  <span class="s1">extends </span><span class="s4">ViewProps</span><span class="s2">,</span>
    <span class="s4">ScrollViewPropsIOS</span><span class="s2">,</span>
    <span class="s4">ScrollViewPropsAndroid</span><span class="s2">,</span>
    <span class="s4">Touchable </span><span class="s2">{</span>
  <span class="s0">/**</span>
   <span class="s0">* These styles will be applied to the scroll view content container which 
   * wraps all of the child views. Example: 
   * 
   *   return ( 
   *     &lt;ScrollView contentContainerStyle={styles.contentContainer}&gt; 
   *     &lt;/ScrollView&gt; 
   *   ); 
   *   ... 
   *   const styles = StyleSheet.create({ 
   *     contentContainer: { 
   *       paddingVertical: 20 
   *     } 
   *   }); 
   */</span>
  <span class="s2">contentContainerStyle</span><span class="s1">?: </span><span class="s4">StyleProp</span><span class="s2">&lt;</span><span class="s4">ViewStyle</span><span class="s2">&gt; </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* A floating-point number that determines how quickly the scroll view 
   * decelerates after the user lifts their finger. You may also use string 
   * shortcuts `&quot;normal&quot;` and `&quot;fast&quot;` which match the underlying iOS settings 
   * for `UIScrollViewDecelerationRateNormal` and 
   * `UIScrollViewDecelerationRateFast` respectively. 
   * 
   *  - `'normal'`: 0.998 on iOS, 0.985 on Android (the default) 
   *  - `'fast'`: 0.99 on iOS, 0.9 on Android 
   */</span>
  <span class="s2">decelerationRate</span><span class="s1">?: </span><span class="s5">'fast' </span><span class="s1">| </span><span class="s5">'normal' </span><span class="s1">| </span><span class="s4">number </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* When true the scroll view's children are arranged horizontally in a row 
   * instead of vertically in a column. The default value is false. 
   */</span>
  <span class="s2">horizontal</span><span class="s1">?: </span><span class="s4">boolean </span><span class="s1">| </span><span class="s4">null </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* If sticky headers should stick at the bottom instead of the top of the 
   * ScrollView. This is usually used with inverted ScrollViews. 
   */</span>
  <span class="s2">invertStickyHeaders</span><span class="s1">?: </span><span class="s4">boolean </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* Determines whether the keyboard gets dismissed in response to a drag. 
   *   - 'none' (the default) drags do not dismiss the keyboard. 
   *   - 'onDrag' the keyboard is dismissed when a drag begins. 
   *   - 'interactive' the keyboard is dismissed interactively with the drag 
   *     and moves in synchrony with the touch; dragging upwards cancels the 
   *     dismissal. 
   */</span>
  <span class="s2">keyboardDismissMode</span><span class="s1">?: </span><span class="s5">'none' </span><span class="s1">| </span><span class="s5">'interactive' </span><span class="s1">| </span><span class="s5">'on-drag' </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* Determines when the keyboard should stay visible after a tap. 
   * - 'never' (the default), tapping outside of the focused text input when the keyboard is up dismisses the keyboard. When this happens, children won't receive the tap. 
   * - 'always', the keyboard will not dismiss automatically, and the scroll view will not catch taps, but children of the scroll view can catch taps. 
   * - 'handled', the keyboard will not dismiss automatically when the tap was handled by a children, (or captured by an ancestor). 
   * - false, deprecated, use 'never' instead 
   * - true, deprecated, use 'always' instead 
   */</span>
  <span class="s2">keyboardShouldPersistTaps</span><span class="s1">?:</span>
    <span class="s1">| </span><span class="s4">boolean</span>
    <span class="s1">| </span><span class="s5">'always'</span>
    <span class="s1">| </span><span class="s5">'never'</span>
    <span class="s1">| </span><span class="s5">'handled'</span>
    <span class="s1">| </span><span class="s2">undefined;</span>

  <span class="s0">/**</span>
   <span class="s0">* Called when scrollable content view of the ScrollView changes. 
   * Handler function is passed the content width and content height as parameters: (contentWidth, contentHeight) 
   * It's implemented using onLayout handler attached to the content container which this ScrollView renders. 
   * 
   */</span>
  <span class="s2">onContentSizeChange</span><span class="s1">?: </span><span class="s2">((</span><span class="s4">w</span><span class="s1">: </span><span class="s4">number</span><span class="s2">, </span><span class="s4">h</span><span class="s1">: </span><span class="s4">number</span><span class="s2">) </span><span class="s1">=&gt; </span><span class="s4">void</span><span class="s2">) </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* Fires at most once per frame during scrolling. 
   * The frequency of the events can be contolled using the scrollEventThrottle prop. 
   */</span>
  <span class="s2">onScroll</span><span class="s1">?:</span>
    <span class="s1">| </span><span class="s2">((</span><span class="s4">event</span><span class="s1">: </span><span class="s4">NativeSyntheticEvent</span><span class="s2">&lt;</span><span class="s4">NativeScrollEvent</span><span class="s2">&gt;) </span><span class="s1">=&gt; </span><span class="s4">void</span><span class="s2">)</span>
    <span class="s1">| </span><span class="s2">undefined;</span>

  <span class="s0">/**</span>
   <span class="s0">* Fires if a user initiates a scroll gesture. 
   */</span>
  <span class="s2">onScrollBeginDrag</span><span class="s1">?:</span>
    <span class="s1">| </span><span class="s2">((</span><span class="s4">event</span><span class="s1">: </span><span class="s4">NativeSyntheticEvent</span><span class="s2">&lt;</span><span class="s4">NativeScrollEvent</span><span class="s2">&gt;) </span><span class="s1">=&gt; </span><span class="s4">void</span><span class="s2">)</span>
    <span class="s1">| </span><span class="s2">undefined;</span>

  <span class="s0">/**</span>
   <span class="s0">* Fires when a user has finished scrolling. 
   */</span>
  <span class="s2">onScrollEndDrag</span><span class="s1">?:</span>
    <span class="s1">| </span><span class="s2">((</span><span class="s4">event</span><span class="s1">: </span><span class="s4">NativeSyntheticEvent</span><span class="s2">&lt;</span><span class="s4">NativeScrollEvent</span><span class="s2">&gt;) </span><span class="s1">=&gt; </span><span class="s4">void</span><span class="s2">)</span>
    <span class="s1">| </span><span class="s2">undefined;</span>

  <span class="s0">/**</span>
   <span class="s0">* Fires when scroll view has finished moving 
   */</span>
  <span class="s2">onMomentumScrollEnd</span><span class="s1">?:</span>
    <span class="s1">| </span><span class="s2">((</span><span class="s4">event</span><span class="s1">: </span><span class="s4">NativeSyntheticEvent</span><span class="s2">&lt;</span><span class="s4">NativeScrollEvent</span><span class="s2">&gt;) </span><span class="s1">=&gt; </span><span class="s4">void</span><span class="s2">)</span>
    <span class="s1">| </span><span class="s2">undefined;</span>

  <span class="s0">/**</span>
   <span class="s0">* Fires when scroll view has begun moving 
   */</span>
  <span class="s2">onMomentumScrollBegin</span><span class="s1">?:</span>
    <span class="s1">| </span><span class="s2">((</span><span class="s4">event</span><span class="s1">: </span><span class="s4">NativeSyntheticEvent</span><span class="s2">&lt;</span><span class="s4">NativeScrollEvent</span><span class="s2">&gt;) </span><span class="s1">=&gt; </span><span class="s4">void</span><span class="s2">)</span>
    <span class="s1">| </span><span class="s2">undefined;</span>

  <span class="s0">/**</span>
   <span class="s0">* When true the scroll view stops on multiples of the scroll view's size 
   * when scrolling. This can be used for horizontal pagination. The default 
   * value is false. 
   */</span>
  <span class="s2">pagingEnabled</span><span class="s1">?: </span><span class="s4">boolean </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* When false, the content does not scroll. The default value is true 
   */</span>
  <span class="s2">scrollEnabled</span><span class="s1">?: </span><span class="s4">boolean </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">; </span><span class="s0">// true</span>

  <span class="s0">/**</span>
   <span class="s0">* Experimental: When true offscreen child views (whose `overflow` value is 
   * `hidden`) are removed from their native backing superview when offscreen. 
   * This can improve scrolling performance on long lists. The default value is 
   * false. 
   */</span>
  <span class="s2">removeClippedSubviews</span><span class="s1">?: </span><span class="s4">boolean </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* When true, shows a horizontal scroll indicator. 
   */</span>
  <span class="s2">showsHorizontalScrollIndicator</span><span class="s1">?: </span><span class="s4">boolean </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* When true, shows a vertical scroll indicator. 
   */</span>
  <span class="s2">showsVerticalScrollIndicator</span><span class="s1">?: </span><span class="s4">boolean </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* When true, Sticky header is hidden when scrolling down, and dock at the top when scrolling up. 
   */</span>
  <span class="s2">stickyHeaderHiddenOnScroll</span><span class="s1">?: </span><span class="s4">boolean </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* Style 
   */</span>
  <span class="s2">style</span><span class="s1">?: </span><span class="s4">StyleProp</span><span class="s2">&lt;</span><span class="s4">ViewStyle</span><span class="s2">&gt; </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* A RefreshControl component, used to provide pull-to-refresh 
   * functionality for the ScrollView. 
   */</span>
  <span class="s2">refreshControl</span><span class="s1">?: </span><span class="s4">React</span><span class="s2">.</span><span class="s4">ReactElement</span><span class="s2">&lt;</span><span class="s4">RefreshControlProps</span><span class="s2">&gt; </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* When set, causes the scroll view to stop at multiples of the value of `snapToInterval`. 
   * This can be used for paginating through children that have lengths smaller than the scroll view. 
   * Used in combination with `snapToAlignment` and `decelerationRate=&quot;fast&quot;`. Overrides less 
   * configurable `pagingEnabled` prop. 
   */</span>
  <span class="s2">snapToInterval</span><span class="s1">?: </span><span class="s4">number </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* When set, causes the scroll view to stop at the defined offsets. This can be used for 
   * paginating through variously sized children that have lengths smaller than the scroll view. 
   * Typically used in combination with `decelerationRate=&quot;fast&quot;`. Overrides less configurable 
   * `pagingEnabled` and `snapToInterval` props. 
   */</span>
  <span class="s2">snapToOffsets</span><span class="s1">?: </span><span class="s4">number</span><span class="s2">[] </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* Use in conjunction with `snapToOffsets`. By default, the beginning of the list counts as a 
   * snap offset. Set `snapToStart` to false to disable this behavior and allow the list to scroll 
   * freely between its start and the first `snapToOffsets` offset. The default value is true. 
   */</span>
  <span class="s2">snapToStart</span><span class="s1">?: </span><span class="s4">boolean </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* Use in conjunction with `snapToOffsets`. By default, the end of the list counts as a snap 
   * offset. Set `snapToEnd` to false to disable this behavior and allow the list to scroll freely 
   * between its end and the last `snapToOffsets` offset. The default value is true. 
   */</span>
  <span class="s2">snapToEnd</span><span class="s1">?: </span><span class="s4">boolean </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* An array of child indices determining which children get docked to the 
   * top of the screen when scrolling. For example passing 
   * `stickyHeaderIndices={[0]}` will cause the first child to be fixed to the 
   * top of the scroll view. This property is not supported in conjunction 
   * with `horizontal={true}`. 
   */</span>
  <span class="s2">stickyHeaderIndices</span><span class="s1">?: </span><span class="s4">number</span><span class="s2">[] </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* When true, the scroll view stops on the next index (in relation to scroll position at release) 
   * regardless of how fast the gesture is. This can be used for horizontal pagination when the page 
   * is less than the width of the ScrollView. The default value is false. 
   */</span>
  <span class="s2">disableIntervalMomentum</span><span class="s1">?: </span><span class="s4">boolean </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* When true, the default JS pan responder on the ScrollView is disabled, and full control over 
   * touches inside the ScrollView is left to its child components. This is particularly useful 
   * if `snapToInterval` is enabled, since it does not follow typical touch patterns. Do not use 
   * this on regular ScrollView use cases without `snapToInterval` as it may cause unexpected 
   * touches to occur while scrolling. The default value is false. 
   */</span>
  <span class="s2">disableScrollViewPanResponder</span><span class="s1">?: </span><span class="s4">boolean </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* A React Component that will be used to render sticky headers, should be used together with 
   * stickyHeaderIndices. You may need to set this component if your sticky header uses custom 
   * transforms, for example, when you want your list to have an animated and hidable header. 
   * If component have not been provided, the default ScrollViewStickyHeader component will be used. 
   */</span>
  <span class="s2">StickyHeaderComponent</span><span class="s1">?: </span><span class="s4">React</span><span class="s2">.</span><span class="s4">ComponentType</span><span class="s2">&lt;</span><span class="s4">any</span><span class="s2">&gt; </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">;</span>
<span class="s2">}</span>

<span class="s1">declare class </span><span class="s4">ScrollViewComponent </span><span class="s1">extends </span><span class="s4">React</span><span class="s2">.</span><span class="s4">Component</span><span class="s2">&lt;</span><span class="s4">ScrollViewProps</span><span class="s2">&gt; {}</span>
<span class="s1">export declare const </span><span class="s2">ScrollViewBase</span><span class="s1">: </span><span class="s4">Constructor</span><span class="s2">&lt;</span><span class="s4">ScrollResponderMixin</span><span class="s2">&gt; </span><span class="s1">&amp;</span>
  <span class="s1">typeof </span><span class="s4">ScrollViewComponent</span><span class="s2">;</span>
<span class="s1">export class </span><span class="s4">ScrollView </span><span class="s1">extends </span><span class="s4">ScrollViewBase </span><span class="s2">{</span>
  <span class="s0">/**</span>
   <span class="s0">* Scrolls to a given x, y offset, either immediately or with a smooth animation. 
   * Syntax: 
   * 
   * scrollTo(options: {x: number = 0; y: number = 0; animated: boolean = true}) 
   * 
   * Note: The weird argument signature is due to the fact that, for historical reasons, 
   * the function also accepts separate arguments as an alternative to the options object. 
   * This is deprecated due to ambiguity (y before x), and SHOULD NOT BE USED. 
   */</span>
  <span class="s2">scrollTo(</span>
    <span class="s4">y</span><span class="s1">?:</span>
      <span class="s1">| </span><span class="s4">number</span>
      <span class="s1">| </span><span class="s2">{</span>
          <span class="s2">x</span><span class="s1">?: </span><span class="s4">number </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">;</span>
          <span class="s2">y</span><span class="s1">?: </span><span class="s4">number </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">;</span>
          <span class="s2">animated</span><span class="s1">?: </span><span class="s4">boolean </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">;</span>
        <span class="s2">},</span>
    <span class="s4">deprecatedX</span><span class="s1">?: </span><span class="s4">number</span><span class="s2">,</span>
    <span class="s4">deprecatedAnimated</span><span class="s1">?: </span><span class="s4">boolean</span><span class="s2">,</span>
  <span class="s2">)</span><span class="s1">: </span><span class="s4">void</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* A helper function that scrolls to the end of the scrollview; 
   * If this is a vertical ScrollView, it scrolls to the bottom. 
   * If this is a horizontal ScrollView scrolls to the right. 
   * 
   * The options object has an animated prop, that enables the scrolling animation or not. 
   * The animated prop defaults to true 
   */</span>
  <span class="s2">scrollToEnd(</span><span class="s4">options</span><span class="s1">?: </span><span class="s2">{animated</span><span class="s1">?: </span><span class="s4">boolean </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">})</span><span class="s1">: </span><span class="s4">void</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* Displays the scroll indicators momentarily. 
   */</span>
  <span class="s2">flashScrollIndicators()</span><span class="s1">: </span><span class="s4">void</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* Returns a reference to the underlying scroll responder, which supports 
   * operations like `scrollTo`. All ScrollView-like components should 
   * implement this method so that they can be composed while providing access 
   * to the underlying scroll responder's methods. 
   */</span>
  <span class="s2">getScrollResponder()</span><span class="s1">: </span><span class="s4">ScrollResponderMixin</span><span class="s2">;</span>

  <span class="s2">getScrollableNode()</span><span class="s1">: </span><span class="s4">any</span><span class="s2">;</span>

  <span class="s0">// Undocumented</span>
  <span class="s2">getInnerViewNode()</span><span class="s1">: </span><span class="s4">any</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* </span><span class="s1">@deprecated </span><span class="s0">Use scrollTo instead 
   */</span>
  <span class="s2">scrollWithoutAnimationTo</span><span class="s1">?: </span><span class="s2">((</span><span class="s4">y</span><span class="s1">: </span><span class="s4">number</span><span class="s2">, </span><span class="s4">x</span><span class="s1">: </span><span class="s4">number</span><span class="s2">) </span><span class="s1">=&gt; </span><span class="s4">void</span><span class="s2">) </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">;</span>

  <span class="s0">/**</span>
   <span class="s0">* This function sends props straight to native. They will not participate in 
   * future diff process - this means that if you do not include them in the 
   * next render, they will remain active (see [Direct 
   * Manipulation](https://reactnative.dev/docs/direct-manipulation)). 
   */</span>
  <span class="s2">setNativeProps(</span><span class="s4">nativeProps</span><span class="s1">: </span><span class="s4">object</span><span class="s2">)</span><span class="s1">: </span><span class="s4">void</span><span class="s2">;</span>
<span class="s2">}</span>

<span class="s1">export interface </span><span class="s4">NativeScrollRectangle </span><span class="s2">{</span>
  <span class="s2">left</span><span class="s1">: </span><span class="s4">number</span><span class="s2">;</span>
  <span class="s2">top</span><span class="s1">: </span><span class="s4">number</span><span class="s2">;</span>
  <span class="s2">bottom</span><span class="s1">: </span><span class="s4">number</span><span class="s2">;</span>
  <span class="s2">right</span><span class="s1">: </span><span class="s4">number</span><span class="s2">;</span>
<span class="s2">}</span>

<span class="s1">export interface </span><span class="s4">NativeScrollPoint </span><span class="s2">{</span>
  <span class="s2">x</span><span class="s1">: </span><span class="s4">number</span><span class="s2">;</span>
  <span class="s2">y</span><span class="s1">: </span><span class="s4">number</span><span class="s2">;</span>
<span class="s2">}</span>

<span class="s1">export interface </span><span class="s4">NativeScrollVelocity </span><span class="s2">{</span>
  <span class="s2">x</span><span class="s1">: </span><span class="s4">number</span><span class="s2">;</span>
  <span class="s2">y</span><span class="s1">: </span><span class="s4">number</span><span class="s2">;</span>
<span class="s2">}</span>

<span class="s1">export interface </span><span class="s4">NativeScrollSize </span><span class="s2">{</span>
  <span class="s2">height</span><span class="s1">: </span><span class="s4">number</span><span class="s2">;</span>
  <span class="s2">width</span><span class="s1">: </span><span class="s4">number</span><span class="s2">;</span>
<span class="s2">}</span>

<span class="s1">export interface </span><span class="s4">NativeScrollEvent </span><span class="s2">{</span>
  <span class="s2">contentInset</span><span class="s1">: </span><span class="s4">NativeScrollRectangle</span><span class="s2">;</span>
  <span class="s2">contentOffset</span><span class="s1">: </span><span class="s4">NativeScrollPoint</span><span class="s2">;</span>
  <span class="s2">contentSize</span><span class="s1">: </span><span class="s4">NativeScrollSize</span><span class="s2">;</span>
  <span class="s2">layoutMeasurement</span><span class="s1">: </span><span class="s4">NativeScrollSize</span><span class="s2">;</span>
  <span class="s2">velocity</span><span class="s1">?: </span><span class="s4">NativeScrollVelocity </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">;</span>
  <span class="s2">zoomScale</span><span class="s1">: </span><span class="s4">number</span><span class="s2">;</span>
  <span class="s0">/**</span>
   <span class="s0">* </span><span class="s1">@platform </span><span class="s0">ios 
   */</span>
  <span class="s2">targetContentOffset</span><span class="s1">?: </span><span class="s4">NativeScrollPoint </span><span class="s1">| </span><span class="s4">undefined</span><span class="s2">;</span>
<span class="s2">}</span>
</pre>
</body>
</html>
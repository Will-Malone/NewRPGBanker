<html>
<head>
<title>minimatch.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
.s1 { color: #cc7832;}
.s2 { color: #6a8759;}
.s3 { color: #808080;}
.s4 { color: #4646f1;}
.s5 { color: #6a8759;}
.s6 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
minimatch.js</font>
</center></td></tr></table>
<pre><span class="s0">module.exports = minimatch</span>
<span class="s0">minimatch.Minimatch = Minimatch</span>

<span class="s1">var </span><span class="s0">path = (</span><span class="s1">function </span><span class="s0">() { </span><span class="s1">try </span><span class="s0">{ </span><span class="s1">return </span><span class="s0">require(</span><span class="s2">'path'</span><span class="s0">) } </span><span class="s1">catch </span><span class="s0">(e) {}}()) || {</span>
  <span class="s0">sep: </span><span class="s2">'/'</span>
<span class="s0">}</span>
<span class="s0">minimatch.sep = path.sep</span>

<span class="s1">var </span><span class="s0">GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}</span>
<span class="s1">var </span><span class="s0">expand = require(</span><span class="s2">'brace-expansion'</span><span class="s0">)</span>

<span class="s1">var </span><span class="s0">plTypes = {</span>
  <span class="s2">'!'</span><span class="s0">: { open: </span><span class="s2">'(?:(?!(?:'</span><span class="s0">, close: </span><span class="s2">'))[^/]*?)'</span><span class="s0">},</span>
  <span class="s2">'?'</span><span class="s0">: { open: </span><span class="s2">'(?:'</span><span class="s0">, close: </span><span class="s2">')?' </span><span class="s0">},</span>
  <span class="s2">'+'</span><span class="s0">: { open: </span><span class="s2">'(?:'</span><span class="s0">, close: </span><span class="s2">')+' </span><span class="s0">},</span>
  <span class="s2">'*'</span><span class="s0">: { open: </span><span class="s2">'(?:'</span><span class="s0">, close: </span><span class="s2">')*' </span><span class="s0">},</span>
  <span class="s2">'@'</span><span class="s0">: { open: </span><span class="s2">'(?:'</span><span class="s0">, close: </span><span class="s2">')' </span><span class="s0">}</span>
<span class="s0">}</span>

<span class="s3">// any single thing other than /</span>
<span class="s3">// don't need to escape / when using new RegExp()</span>
<span class="s1">var </span><span class="s0">qmark = </span><span class="s2">'[^/]'</span>

<span class="s3">// * =&gt; any number of characters</span>
<span class="s1">var </span><span class="s0">star = qmark + </span><span class="s2">'*?'</span>

<span class="s3">// ** when dots are allowed.  Anything goes, except .. and .</span>
<span class="s3">// not (^ or / followed by one or two dots followed by $ or /),</span>
<span class="s3">// followed by anything, any number of times.</span>
<span class="s1">var </span><span class="s0">twoStarDot = </span><span class="s2">'(?:(?!(?:</span><span class="s4">\\</span><span class="s5">\/</span><span class="s2">|^)(?:</span><span class="s4">\\</span><span class="s2">.{1,2})($|</span><span class="s4">\\</span><span class="s5">\/</span><span class="s2">)).)*?'</span>

<span class="s3">// not a ^ or / followed by a dot,</span>
<span class="s3">// followed by anything, any number of times.</span>
<span class="s1">var </span><span class="s0">twoStarNoDot = </span><span class="s2">'(?:(?!(?:</span><span class="s4">\\</span><span class="s5">\/</span><span class="s2">|^)</span><span class="s4">\\</span><span class="s2">.).)*?'</span>

<span class="s3">// characters that need to be escaped in RegExp.</span>
<span class="s1">var </span><span class="s0">reSpecials = charSet(</span><span class="s2">'().*{}+?[]^$</span><span class="s4">\\</span><span class="s2">!'</span><span class="s0">)</span>

<span class="s3">// &quot;abc&quot; -&gt; { a:true, b:true, c:true }</span>
<span class="s1">function </span><span class="s0">charSet (s) {</span>
  <span class="s1">return </span><span class="s0">s.split(</span><span class="s2">''</span><span class="s0">).reduce(</span><span class="s1">function </span><span class="s0">(set, c) {</span>
    <span class="s0">set[c] = </span><span class="s1">true</span>
    <span class="s1">return </span><span class="s0">set</span>
  <span class="s0">}, {})</span>
<span class="s0">}</span>

<span class="s3">// normalizes slashes.</span>
<span class="s1">var </span><span class="s0">slashSplit = /\/+/</span>

<span class="s0">minimatch.filter = filter</span>
<span class="s1">function </span><span class="s0">filter (pattern, options) {</span>
  <span class="s0">options = options || {}</span>
  <span class="s1">return function </span><span class="s0">(p, i, list) {</span>
    <span class="s1">return </span><span class="s0">minimatch(p, pattern, options)</span>
  <span class="s0">}</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">ext (a, b) {</span>
  <span class="s0">b = b || {}</span>
  <span class="s1">var </span><span class="s0">t = {}</span>
  <span class="s0">Object.keys(a).forEach(</span><span class="s1">function </span><span class="s0">(k) {</span>
    <span class="s0">t[k] = a[k]</span>
  <span class="s0">})</span>
  <span class="s0">Object.keys(b).forEach(</span><span class="s1">function </span><span class="s0">(k) {</span>
    <span class="s0">t[k] = b[k]</span>
  <span class="s0">})</span>
  <span class="s1">return </span><span class="s0">t</span>
<span class="s0">}</span>

<span class="s0">minimatch.defaults = </span><span class="s1">function </span><span class="s0">(def) {</span>
  <span class="s1">if </span><span class="s0">(!def || </span><span class="s1">typeof </span><span class="s0">def !== </span><span class="s2">'object' </span><span class="s0">|| !Object.keys(def).length) {</span>
    <span class="s1">return </span><span class="s0">minimatch</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">orig = minimatch</span>

  <span class="s1">var </span><span class="s0">m = </span><span class="s1">function </span><span class="s0">minimatch (p, pattern, options) {</span>
    <span class="s1">return </span><span class="s0">orig(p, pattern, ext(def, options))</span>
  <span class="s0">}</span>

  <span class="s0">m.Minimatch = </span><span class="s1">function </span><span class="s0">Minimatch (pattern, options) {</span>
    <span class="s1">return new </span><span class="s0">orig.Minimatch(pattern, ext(def, options))</span>
  <span class="s0">}</span>
  <span class="s0">m.Minimatch.defaults = </span><span class="s1">function </span><span class="s0">defaults (options) {</span>
    <span class="s1">return </span><span class="s0">orig.defaults(ext(def, options)).Minimatch</span>
  <span class="s0">}</span>

  <span class="s0">m.filter = </span><span class="s1">function </span><span class="s0">filter (pattern, options) {</span>
    <span class="s1">return </span><span class="s0">orig.filter(pattern, ext(def, options))</span>
  <span class="s0">}</span>

  <span class="s0">m.defaults = </span><span class="s1">function </span><span class="s0">defaults (options) {</span>
    <span class="s1">return </span><span class="s0">orig.defaults(ext(def, options))</span>
  <span class="s0">}</span>

  <span class="s0">m.makeRe = </span><span class="s1">function </span><span class="s0">makeRe (pattern, options) {</span>
    <span class="s1">return </span><span class="s0">orig.makeRe(pattern, ext(def, options))</span>
  <span class="s0">}</span>

  <span class="s0">m.braceExpand = </span><span class="s1">function </span><span class="s0">braceExpand (pattern, options) {</span>
    <span class="s1">return </span><span class="s0">orig.braceExpand(pattern, ext(def, options))</span>
  <span class="s0">}</span>

  <span class="s0">m.match = </span><span class="s1">function </span><span class="s0">(list, pattern, options) {</span>
    <span class="s1">return </span><span class="s0">orig.match(list, pattern, ext(def, options))</span>
  <span class="s0">}</span>

  <span class="s1">return </span><span class="s0">m</span>
<span class="s0">}</span>

<span class="s0">Minimatch.defaults = </span><span class="s1">function </span><span class="s0">(def) {</span>
  <span class="s1">return </span><span class="s0">minimatch.defaults(def).Minimatch</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">minimatch (p, pattern, options) {</span>
  <span class="s0">assertValidPattern(pattern)</span>

  <span class="s1">if </span><span class="s0">(!options) options = {}</span>

  <span class="s3">// shortcut: comments match nothing.</span>
  <span class="s1">if </span><span class="s0">(!options.nocomment &amp;&amp; pattern.charAt(</span><span class="s6">0</span><span class="s0">) === </span><span class="s2">'#'</span><span class="s0">) {</span>
    <span class="s1">return false</span>
  <span class="s0">}</span>

  <span class="s1">return new </span><span class="s0">Minimatch(pattern, options).match(p)</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">Minimatch (pattern, options) {</span>
  <span class="s1">if </span><span class="s0">(!(</span><span class="s1">this instanceof </span><span class="s0">Minimatch)) {</span>
    <span class="s1">return new </span><span class="s0">Minimatch(pattern, options)</span>
  <span class="s0">}</span>

  <span class="s0">assertValidPattern(pattern)</span>

  <span class="s1">if </span><span class="s0">(!options) options = {}</span>

  <span class="s0">pattern = pattern.trim()</span>

  <span class="s3">// windows support: need to use /, not \</span>
  <span class="s1">if </span><span class="s0">(!options.allowWindowsEscape &amp;&amp; path.sep !== </span><span class="s2">'/'</span><span class="s0">) {</span>
    <span class="s0">pattern = pattern.split(path.sep).join(</span><span class="s2">'/'</span><span class="s0">)</span>
  <span class="s0">}</span>

  <span class="s1">this</span><span class="s0">.options = options</span>
  <span class="s1">this</span><span class="s0">.set = []</span>
  <span class="s1">this</span><span class="s0">.pattern = pattern</span>
  <span class="s1">this</span><span class="s0">.regexp = </span><span class="s1">null</span>
  <span class="s1">this</span><span class="s0">.negate = </span><span class="s1">false</span>
  <span class="s1">this</span><span class="s0">.comment = </span><span class="s1">false</span>
  <span class="s1">this</span><span class="s0">.empty = </span><span class="s1">false</span>
  <span class="s1">this</span><span class="s0">.partial = !!options.partial</span>

  <span class="s3">// make the set of regexps etc.</span>
  <span class="s1">this</span><span class="s0">.make()</span>
<span class="s0">}</span>

<span class="s0">Minimatch.prototype.debug = </span><span class="s1">function </span><span class="s0">() {}</span>

<span class="s0">Minimatch.prototype.make = make</span>
<span class="s1">function </span><span class="s0">make () {</span>
  <span class="s1">var </span><span class="s0">pattern = </span><span class="s1">this</span><span class="s0">.pattern</span>
  <span class="s1">var </span><span class="s0">options = </span><span class="s1">this</span><span class="s0">.options</span>

  <span class="s3">// empty patterns and comments match nothing.</span>
  <span class="s1">if </span><span class="s0">(!options.nocomment &amp;&amp; pattern.charAt(</span><span class="s6">0</span><span class="s0">) === </span><span class="s2">'#'</span><span class="s0">) {</span>
    <span class="s1">this</span><span class="s0">.comment = </span><span class="s1">true</span>
    <span class="s1">return</span>
  <span class="s0">}</span>
  <span class="s1">if </span><span class="s0">(!pattern) {</span>
    <span class="s1">this</span><span class="s0">.empty = </span><span class="s1">true</span>
    <span class="s1">return</span>
  <span class="s0">}</span>

  <span class="s3">// step 1: figure out negation, etc.</span>
  <span class="s1">this</span><span class="s0">.parseNegate()</span>

  <span class="s3">// step 2: expand braces</span>
  <span class="s1">var </span><span class="s0">set = </span><span class="s1">this</span><span class="s0">.globSet = </span><span class="s1">this</span><span class="s0">.braceExpand()</span>

  <span class="s1">if </span><span class="s0">(options.debug) </span><span class="s1">this</span><span class="s0">.debug = </span><span class="s1">function </span><span class="s0">debug() { console.error.apply(console, arguments) }</span>

  <span class="s1">this</span><span class="s0">.debug(</span><span class="s1">this</span><span class="s0">.pattern, set)</span>

  <span class="s3">// step 3: now we have a set, so turn each one into a series of path-portion</span>
  <span class="s3">// matching patterns.</span>
  <span class="s3">// These will be regexps, except in the case of &quot;**&quot;, which is</span>
  <span class="s3">// set to the GLOBSTAR object for globstar behavior,</span>
  <span class="s3">// and will not contain any / characters</span>
  <span class="s0">set = </span><span class="s1">this</span><span class="s0">.globParts = set.map(</span><span class="s1">function </span><span class="s0">(s) {</span>
    <span class="s1">return </span><span class="s0">s.split(slashSplit)</span>
  <span class="s0">})</span>

  <span class="s1">this</span><span class="s0">.debug(</span><span class="s1">this</span><span class="s0">.pattern, set)</span>

  <span class="s3">// glob --&gt; regexps</span>
  <span class="s0">set = set.map(</span><span class="s1">function </span><span class="s0">(s, si, set) {</span>
    <span class="s1">return </span><span class="s0">s.map(</span><span class="s1">this</span><span class="s0">.parse, </span><span class="s1">this</span><span class="s0">)</span>
  <span class="s0">}, </span><span class="s1">this</span><span class="s0">)</span>

  <span class="s1">this</span><span class="s0">.debug(</span><span class="s1">this</span><span class="s0">.pattern, set)</span>

  <span class="s3">// filter out everything that didn't compile properly.</span>
  <span class="s0">set = set.filter(</span><span class="s1">function </span><span class="s0">(s) {</span>
    <span class="s1">return </span><span class="s0">s.indexOf(</span><span class="s1">false</span><span class="s0">) === -</span><span class="s6">1</span>
  <span class="s0">})</span>

  <span class="s1">this</span><span class="s0">.debug(</span><span class="s1">this</span><span class="s0">.pattern, set)</span>

  <span class="s1">this</span><span class="s0">.set = set</span>
<span class="s0">}</span>

<span class="s0">Minimatch.prototype.parseNegate = parseNegate</span>
<span class="s1">function </span><span class="s0">parseNegate () {</span>
  <span class="s1">var </span><span class="s0">pattern = </span><span class="s1">this</span><span class="s0">.pattern</span>
  <span class="s1">var </span><span class="s0">negate = </span><span class="s1">false</span>
  <span class="s1">var </span><span class="s0">options = </span><span class="s1">this</span><span class="s0">.options</span>
  <span class="s1">var </span><span class="s0">negateOffset = </span><span class="s6">0</span>

  <span class="s1">if </span><span class="s0">(options.nonegate) </span><span class="s1">return</span>

  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s6">0</span><span class="s0">, l = pattern.length</span>
    <span class="s0">; i &lt; l &amp;&amp; pattern.charAt(i) === </span><span class="s2">'!'</span>
    <span class="s0">; i++) {</span>
    <span class="s0">negate = !negate</span>
    <span class="s0">negateOffset++</span>
  <span class="s0">}</span>

  <span class="s1">if </span><span class="s0">(negateOffset) </span><span class="s1">this</span><span class="s0">.pattern = pattern.substr(negateOffset)</span>
  <span class="s1">this</span><span class="s0">.negate = negate</span>
<span class="s0">}</span>

<span class="s3">// Brace expansion:</span>
<span class="s3">// a{b,c}d -&gt; abd acd</span>
<span class="s3">// a{b,}c -&gt; abc ac</span>
<span class="s3">// a{0..3}d -&gt; a0d a1d a2d a3d</span>
<span class="s3">// a{b,c{d,e}f}g -&gt; abg acdfg acefg</span>
<span class="s3">// a{b,c}d{e,f}g -&gt; abdeg acdeg abdeg abdfg</span>
<span class="s3">//</span>
<span class="s3">// Invalid sets are not expanded.</span>
<span class="s3">// a{2..}b -&gt; a{2..}b</span>
<span class="s3">// a{b}c -&gt; a{b}c</span>
<span class="s0">minimatch.braceExpand = </span><span class="s1">function </span><span class="s0">(pattern, options) {</span>
  <span class="s1">return </span><span class="s0">braceExpand(pattern, options)</span>
<span class="s0">}</span>

<span class="s0">Minimatch.prototype.braceExpand = braceExpand</span>

<span class="s1">function </span><span class="s0">braceExpand (pattern, options) {</span>
  <span class="s1">if </span><span class="s0">(!options) {</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">this instanceof </span><span class="s0">Minimatch) {</span>
      <span class="s0">options = </span><span class="s1">this</span><span class="s0">.options</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s0">options = {}</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s0">pattern = </span><span class="s1">typeof </span><span class="s0">pattern === </span><span class="s2">'undefined'</span>
    <span class="s0">? </span><span class="s1">this</span><span class="s0">.pattern : pattern</span>

  <span class="s0">assertValidPattern(pattern)</span>

  <span class="s3">// Thanks to Yeting Li &lt;https://github.com/yetingli&gt; for</span>
  <span class="s3">// improving this regexp to avoid a ReDOS vulnerability.</span>
  <span class="s1">if </span><span class="s0">(options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {</span>
    <span class="s3">// shortcut. no need to expand.</span>
    <span class="s1">return </span><span class="s0">[pattern]</span>
  <span class="s0">}</span>

  <span class="s1">return </span><span class="s0">expand(pattern)</span>
<span class="s0">}</span>

<span class="s1">var </span><span class="s0">MAX_PATTERN_LENGTH = </span><span class="s6">1024 </span><span class="s0">* </span><span class="s6">64</span>
<span class="s1">var </span><span class="s0">assertValidPattern = </span><span class="s1">function </span><span class="s0">(pattern) {</span>
  <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">pattern !== </span><span class="s2">'string'</span><span class="s0">) {</span>
    <span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">'invalid pattern'</span><span class="s0">)</span>
  <span class="s0">}</span>

  <span class="s1">if </span><span class="s0">(pattern.length &gt; MAX_PATTERN_LENGTH) {</span>
    <span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">'pattern is too long'</span><span class="s0">)</span>
  <span class="s0">}</span>
<span class="s0">}</span>

<span class="s3">// parse a component of the expanded set.</span>
<span class="s3">// At this point, no pattern may contain &quot;/&quot; in it</span>
<span class="s3">// so we're going to return a 2d array, where each entry is the full</span>
<span class="s3">// pattern, split on '/', and then turned into a regular expression.</span>
<span class="s3">// A regexp is made at the end which joins each array with an</span>
<span class="s3">// escaped /, and another full one which joins each regexp with |.</span>
<span class="s3">//</span>
<span class="s3">// Following the lead of Bash 4.1, note that &quot;**&quot; only has special meaning</span>
<span class="s3">// when it is the *only* thing in a path portion.  Otherwise, any series</span>
<span class="s3">// of * is equivalent to a single *.  Globstar behavior is enabled by</span>
<span class="s3">// default, and can be disabled by setting options.noglobstar.</span>
<span class="s0">Minimatch.prototype.parse = parse</span>
<span class="s1">var </span><span class="s0">SUBPARSE = {}</span>
<span class="s1">function </span><span class="s0">parse (pattern, isSub) {</span>
  <span class="s0">assertValidPattern(pattern)</span>

  <span class="s1">var </span><span class="s0">options = </span><span class="s1">this</span><span class="s0">.options</span>

  <span class="s3">// shortcuts</span>
  <span class="s1">if </span><span class="s0">(pattern === </span><span class="s2">'**'</span><span class="s0">) {</span>
    <span class="s1">if </span><span class="s0">(!options.noglobstar)</span>
      <span class="s1">return </span><span class="s0">GLOBSTAR</span>
    <span class="s1">else</span>
      <span class="s0">pattern = </span><span class="s2">'*'</span>
  <span class="s0">}</span>
  <span class="s1">if </span><span class="s0">(pattern === </span><span class="s2">''</span><span class="s0">) </span><span class="s1">return </span><span class="s2">''</span>

  <span class="s1">var </span><span class="s0">re = </span><span class="s2">''</span>
  <span class="s1">var </span><span class="s0">hasMagic = !!options.nocase</span>
  <span class="s1">var </span><span class="s0">escaping = </span><span class="s1">false</span>
  <span class="s3">// ? =&gt; one single character</span>
  <span class="s1">var </span><span class="s0">patternListStack = []</span>
  <span class="s1">var </span><span class="s0">negativeLists = []</span>
  <span class="s1">var </span><span class="s0">stateChar</span>
  <span class="s1">var </span><span class="s0">inClass = </span><span class="s1">false</span>
  <span class="s1">var </span><span class="s0">reClassStart = -</span><span class="s6">1</span>
  <span class="s1">var </span><span class="s0">classStart = -</span><span class="s6">1</span>
  <span class="s3">// . and .. never match anything that doesn't start with .,</span>
  <span class="s3">// even when options.dot is set.</span>
  <span class="s1">var </span><span class="s0">patternStart = pattern.charAt(</span><span class="s6">0</span><span class="s0">) === </span><span class="s2">'.' </span><span class="s0">? </span><span class="s2">'' </span><span class="s3">// anything</span>
  <span class="s3">// not (start or / followed by . or .. followed by / or end)</span>
  <span class="s0">: options.dot ? </span><span class="s2">'(?!(?:^|</span><span class="s4">\\</span><span class="s5">\/</span><span class="s2">)</span><span class="s4">\\</span><span class="s2">.{1,2}(?:$|</span><span class="s4">\\</span><span class="s5">\/</span><span class="s2">))'</span>
  <span class="s0">: </span><span class="s2">'(?!</span><span class="s4">\\</span><span class="s2">.)'</span>
  <span class="s1">var </span><span class="s0">self = </span><span class="s1">this</span>

  <span class="s1">function </span><span class="s0">clearStateChar () {</span>
    <span class="s1">if </span><span class="s0">(stateChar) {</span>
      <span class="s3">// we had some state-tracking character</span>
      <span class="s3">// that wasn't consumed by this pass.</span>
      <span class="s1">switch </span><span class="s0">(stateChar) {</span>
        <span class="s1">case </span><span class="s2">'*'</span><span class="s0">:</span>
          <span class="s0">re += star</span>
          <span class="s0">hasMagic = </span><span class="s1">true</span>
        <span class="s1">break</span>
        <span class="s1">case </span><span class="s2">'?'</span><span class="s0">:</span>
          <span class="s0">re += qmark</span>
          <span class="s0">hasMagic = </span><span class="s1">true</span>
        <span class="s1">break</span>
        <span class="s1">default</span><span class="s0">:</span>
          <span class="s0">re += </span><span class="s2">'</span><span class="s4">\\</span><span class="s2">' </span><span class="s0">+ stateChar</span>
        <span class="s1">break</span>
      <span class="s0">}</span>
      <span class="s0">self.debug(</span><span class="s2">'clearStateChar %j %j'</span><span class="s0">, stateChar, re)</span>
      <span class="s0">stateChar = </span><span class="s1">false</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s6">0</span><span class="s0">, len = pattern.length, c</span>
    <span class="s0">; (i &lt; len) &amp;&amp; (c = pattern.charAt(i))</span>
    <span class="s0">; i++) {</span>
    <span class="s1">this</span><span class="s0">.debug(</span><span class="s2">'%s</span><span class="s4">\t</span><span class="s2">%s %s %j'</span><span class="s0">, pattern, i, re, c)</span>

    <span class="s3">// skip over any that are escaped.</span>
    <span class="s1">if </span><span class="s0">(escaping &amp;&amp; reSpecials[c]) {</span>
      <span class="s0">re += </span><span class="s2">'</span><span class="s4">\\</span><span class="s2">' </span><span class="s0">+ c</span>
      <span class="s0">escaping = </span><span class="s1">false</span>
      <span class="s1">continue</span>
    <span class="s0">}</span>

    <span class="s1">switch </span><span class="s0">(c) {</span>
      <span class="s3">/* istanbul ignore next */</span>
      <span class="s1">case </span><span class="s2">'/'</span><span class="s0">: {</span>
        <span class="s3">// completely not allowed, even escaped.</span>
        <span class="s3">// Should already be path-split by now.</span>
        <span class="s1">return false</span>
      <span class="s0">}</span>

      <span class="s1">case </span><span class="s2">'</span><span class="s4">\\</span><span class="s2">'</span><span class="s0">:</span>
        <span class="s0">clearStateChar()</span>
        <span class="s0">escaping = </span><span class="s1">true</span>
      <span class="s1">continue</span>

      <span class="s3">// the various stateChar values</span>
      <span class="s3">// for the &quot;extglob&quot; stuff.</span>
      <span class="s1">case </span><span class="s2">'?'</span><span class="s0">:</span>
      <span class="s1">case </span><span class="s2">'*'</span><span class="s0">:</span>
      <span class="s1">case </span><span class="s2">'+'</span><span class="s0">:</span>
      <span class="s1">case </span><span class="s2">'@'</span><span class="s0">:</span>
      <span class="s1">case </span><span class="s2">'!'</span><span class="s0">:</span>
        <span class="s1">this</span><span class="s0">.debug(</span><span class="s2">'%s</span><span class="s4">\t</span><span class="s2">%s %s %j &lt;-- stateChar'</span><span class="s0">, pattern, i, re, c)</span>

        <span class="s3">// all of those are literals inside a class, except that</span>
        <span class="s3">// the glob [!a] means [^a] in regexp</span>
        <span class="s1">if </span><span class="s0">(inClass) {</span>
          <span class="s1">this</span><span class="s0">.debug(</span><span class="s2">'  in class'</span><span class="s0">)</span>
          <span class="s1">if </span><span class="s0">(c === </span><span class="s2">'!' </span><span class="s0">&amp;&amp; i === classStart + </span><span class="s6">1</span><span class="s0">) c = </span><span class="s2">'^'</span>
          <span class="s0">re += c</span>
          <span class="s1">continue</span>
        <span class="s0">}</span>

        <span class="s3">// if we already have a stateChar, then it means</span>
        <span class="s3">// that there was something like ** or +? in there.</span>
        <span class="s3">// Handle the stateChar, then proceed with this one.</span>
        <span class="s0">self.debug(</span><span class="s2">'call clearStateChar %j'</span><span class="s0">, stateChar)</span>
        <span class="s0">clearStateChar()</span>
        <span class="s0">stateChar = c</span>
        <span class="s3">// if extglob is disabled, then +(asdf|foo) isn't a thing.</span>
        <span class="s3">// just clear the statechar *now*, rather than even diving into</span>
        <span class="s3">// the patternList stuff.</span>
        <span class="s1">if </span><span class="s0">(options.noext) clearStateChar()</span>
      <span class="s1">continue</span>

      <span class="s1">case </span><span class="s2">'('</span><span class="s0">:</span>
        <span class="s1">if </span><span class="s0">(inClass) {</span>
          <span class="s0">re += </span><span class="s2">'('</span>
          <span class="s1">continue</span>
        <span class="s0">}</span>

        <span class="s1">if </span><span class="s0">(!stateChar) {</span>
          <span class="s0">re += </span><span class="s2">'</span><span class="s4">\\</span><span class="s2">('</span>
          <span class="s1">continue</span>
        <span class="s0">}</span>

        <span class="s0">patternListStack.push({</span>
          <span class="s0">type: stateChar,</span>
          <span class="s0">start: i - </span><span class="s6">1</span><span class="s0">,</span>
          <span class="s0">reStart: re.length,</span>
          <span class="s0">open: plTypes[stateChar].open,</span>
          <span class="s0">close: plTypes[stateChar].close</span>
        <span class="s0">})</span>
        <span class="s3">// negation is (?:(?!js)[^/]*)</span>
        <span class="s0">re += stateChar === </span><span class="s2">'!' </span><span class="s0">? </span><span class="s2">'(?:(?!(?:' </span><span class="s0">: </span><span class="s2">'(?:'</span>
        <span class="s1">this</span><span class="s0">.debug(</span><span class="s2">'plType %j %j'</span><span class="s0">, stateChar, re)</span>
        <span class="s0">stateChar = </span><span class="s1">false</span>
      <span class="s1">continue</span>

      <span class="s1">case </span><span class="s2">')'</span><span class="s0">:</span>
        <span class="s1">if </span><span class="s0">(inClass || !patternListStack.length) {</span>
          <span class="s0">re += </span><span class="s2">'</span><span class="s4">\\</span><span class="s2">)'</span>
          <span class="s1">continue</span>
        <span class="s0">}</span>

        <span class="s0">clearStateChar()</span>
        <span class="s0">hasMagic = </span><span class="s1">true</span>
        <span class="s1">var </span><span class="s0">pl = patternListStack.pop()</span>
        <span class="s3">// negation is (?:(?!js)[^/]*)</span>
        <span class="s3">// The others are (?:&lt;pattern&gt;)&lt;type&gt;</span>
        <span class="s0">re += pl.close</span>
        <span class="s1">if </span><span class="s0">(pl.type === </span><span class="s2">'!'</span><span class="s0">) {</span>
          <span class="s0">negativeLists.push(pl)</span>
        <span class="s0">}</span>
        <span class="s0">pl.reEnd = re.length</span>
      <span class="s1">continue</span>

      <span class="s1">case </span><span class="s2">'|'</span><span class="s0">:</span>
        <span class="s1">if </span><span class="s0">(inClass || !patternListStack.length || escaping) {</span>
          <span class="s0">re += </span><span class="s2">'</span><span class="s4">\\</span><span class="s2">|'</span>
          <span class="s0">escaping = </span><span class="s1">false</span>
          <span class="s1">continue</span>
        <span class="s0">}</span>

        <span class="s0">clearStateChar()</span>
        <span class="s0">re += </span><span class="s2">'|'</span>
      <span class="s1">continue</span>

      <span class="s3">// these are mostly the same in regexp and glob</span>
      <span class="s1">case </span><span class="s2">'['</span><span class="s0">:</span>
        <span class="s3">// swallow any state-tracking char before the [</span>
        <span class="s0">clearStateChar()</span>

        <span class="s1">if </span><span class="s0">(inClass) {</span>
          <span class="s0">re += </span><span class="s2">'</span><span class="s4">\\</span><span class="s2">' </span><span class="s0">+ c</span>
          <span class="s1">continue</span>
        <span class="s0">}</span>

        <span class="s0">inClass = </span><span class="s1">true</span>
        <span class="s0">classStart = i</span>
        <span class="s0">reClassStart = re.length</span>
        <span class="s0">re += c</span>
      <span class="s1">continue</span>

      <span class="s1">case </span><span class="s2">']'</span><span class="s0">:</span>
        <span class="s3">//  a right bracket shall lose its special</span>
        <span class="s3">//  meaning and represent itself in</span>
        <span class="s3">//  a bracket expression if it occurs</span>
        <span class="s3">//  first in the list.  -- POSIX.2 2.8.3.2</span>
        <span class="s1">if </span><span class="s0">(i === classStart + </span><span class="s6">1 </span><span class="s0">|| !inClass) {</span>
          <span class="s0">re += </span><span class="s2">'</span><span class="s4">\\</span><span class="s2">' </span><span class="s0">+ c</span>
          <span class="s0">escaping = </span><span class="s1">false</span>
          <span class="s1">continue</span>
        <span class="s0">}</span>

        <span class="s3">// handle the case where we left a class open.</span>
        <span class="s3">// &quot;[z-a]&quot; is valid, equivalent to &quot;\[z-a\]&quot;</span>
        <span class="s3">// split where the last [ was, make sure we don't have</span>
        <span class="s3">// an invalid re. if so, re-walk the contents of the</span>
        <span class="s3">// would-be class to re-translate any characters that</span>
        <span class="s3">// were passed through as-is</span>
        <span class="s3">// TODO: It would probably be faster to determine this</span>
        <span class="s3">// without a try/catch and a new RegExp, but it's tricky</span>
        <span class="s3">// to do safely.  For now, this is safe and works.</span>
        <span class="s1">var </span><span class="s0">cs = pattern.substring(classStart + </span><span class="s6">1</span><span class="s0">, i)</span>
        <span class="s1">try </span><span class="s0">{</span>
          <span class="s0">RegExp(</span><span class="s2">'[' </span><span class="s0">+ cs + </span><span class="s2">']'</span><span class="s0">)</span>
        <span class="s0">} </span><span class="s1">catch </span><span class="s0">(er) {</span>
          <span class="s3">// not a valid class!</span>
          <span class="s1">var </span><span class="s0">sp = </span><span class="s1">this</span><span class="s0">.parse(cs, SUBPARSE)</span>
          <span class="s0">re = re.substr(</span><span class="s6">0</span><span class="s0">, reClassStart) + </span><span class="s2">'</span><span class="s4">\\</span><span class="s2">[' </span><span class="s0">+ sp[</span><span class="s6">0</span><span class="s0">] + </span><span class="s2">'</span><span class="s4">\\</span><span class="s2">]'</span>
          <span class="s0">hasMagic = hasMagic || sp[</span><span class="s6">1</span><span class="s0">]</span>
          <span class="s0">inClass = </span><span class="s1">false</span>
          <span class="s1">continue</span>
        <span class="s0">}</span>

        <span class="s3">// finish up the class.</span>
        <span class="s0">hasMagic = </span><span class="s1">true</span>
        <span class="s0">inClass = </span><span class="s1">false</span>
        <span class="s0">re += c</span>
      <span class="s1">continue</span>

      <span class="s1">default</span><span class="s0">:</span>
        <span class="s3">// swallow any state char that wasn't consumed</span>
        <span class="s0">clearStateChar()</span>

        <span class="s1">if </span><span class="s0">(escaping) {</span>
          <span class="s3">// no need</span>
          <span class="s0">escaping = </span><span class="s1">false</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(reSpecials[c]</span>
          <span class="s0">&amp;&amp; !(c === </span><span class="s2">'^' </span><span class="s0">&amp;&amp; inClass)) {</span>
          <span class="s0">re += </span><span class="s2">'</span><span class="s4">\\</span><span class="s2">'</span>
        <span class="s0">}</span>

        <span class="s0">re += c</span>

    <span class="s0">} </span><span class="s3">// switch</span>
  <span class="s0">} </span><span class="s3">// for</span>

  <span class="s3">// handle the case where we left a class open.</span>
  <span class="s3">// &quot;[abc&quot; is valid, equivalent to &quot;\[abc&quot;</span>
  <span class="s1">if </span><span class="s0">(inClass) {</span>
    <span class="s3">// split where the last [ was, and escape it</span>
    <span class="s3">// this is a huge pita.  We now have to re-walk</span>
    <span class="s3">// the contents of the would-be class to re-translate</span>
    <span class="s3">// any characters that were passed through as-is</span>
    <span class="s0">cs = pattern.substr(classStart + </span><span class="s6">1</span><span class="s0">)</span>
    <span class="s0">sp = </span><span class="s1">this</span><span class="s0">.parse(cs, SUBPARSE)</span>
    <span class="s0">re = re.substr(</span><span class="s6">0</span><span class="s0">, reClassStart) + </span><span class="s2">'</span><span class="s4">\\</span><span class="s2">[' </span><span class="s0">+ sp[</span><span class="s6">0</span><span class="s0">]</span>
    <span class="s0">hasMagic = hasMagic || sp[</span><span class="s6">1</span><span class="s0">]</span>
  <span class="s0">}</span>

  <span class="s3">// handle the case where we had a +( thing at the *end*</span>
  <span class="s3">// of the pattern.</span>
  <span class="s3">// each pattern list stack adds 3 chars, and we need to go through</span>
  <span class="s3">// and escape any | chars that were passed through as-is for the regexp.</span>
  <span class="s3">// Go through and escape them, taking care not to double-escape any</span>
  <span class="s3">// | chars that were already escaped.</span>
  <span class="s1">for </span><span class="s0">(pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {</span>
    <span class="s1">var </span><span class="s0">tail = re.slice(pl.reStart + pl.open.length)</span>
    <span class="s1">this</span><span class="s0">.debug(</span><span class="s2">'setting tail'</span><span class="s0">, re, pl)</span>
    <span class="s3">// maybe some even number of \, then maybe 1 \, followed by a |</span>
    <span class="s0">tail = tail.replace(/((?:\\{</span><span class="s6">2</span><span class="s0">}){</span><span class="s6">0</span><span class="s0">,</span><span class="s6">64</span><span class="s0">})(\\?)\|/g, </span><span class="s1">function </span><span class="s0">(_, $1, $2) {</span>
      <span class="s1">if </span><span class="s0">(!$2) {</span>
        <span class="s3">// the | isn't already escaped, so escape it.</span>
        <span class="s0">$2 = </span><span class="s2">'</span><span class="s4">\\</span><span class="s2">'</span>
      <span class="s0">}</span>

      <span class="s3">// need to escape all those slashes *again*, without escaping the</span>
      <span class="s3">// one that we need for escaping the | character.  As it works out,</span>
      <span class="s3">// escaping an even number of slashes can be done by simply repeating</span>
      <span class="s3">// it exactly after itself.  That's why this trick works.</span>
      <span class="s3">//</span>
      <span class="s3">// I am sorry that you have to see this.</span>
      <span class="s1">return </span><span class="s0">$1 + $1 + $2 + </span><span class="s2">'|'</span>
    <span class="s0">})</span>

    <span class="s1">this</span><span class="s0">.debug(</span><span class="s2">'tail=%j</span><span class="s4">\n   </span><span class="s2">%s'</span><span class="s0">, tail, tail, pl, re)</span>
    <span class="s1">var </span><span class="s0">t = pl.type === </span><span class="s2">'*' </span><span class="s0">? star</span>
      <span class="s0">: pl.type === </span><span class="s2">'?' </span><span class="s0">? qmark</span>
      <span class="s0">: </span><span class="s2">'</span><span class="s4">\\</span><span class="s2">' </span><span class="s0">+ pl.type</span>

    <span class="s0">hasMagic = </span><span class="s1">true</span>
    <span class="s0">re = re.slice(</span><span class="s6">0</span><span class="s0">, pl.reStart) + t + </span><span class="s2">'</span><span class="s4">\\</span><span class="s2">(' </span><span class="s0">+ tail</span>
  <span class="s0">}</span>

  <span class="s3">// handle trailing things that only matter at the very end.</span>
  <span class="s0">clearStateChar()</span>
  <span class="s1">if </span><span class="s0">(escaping) {</span>
    <span class="s3">// trailing \\</span>
    <span class="s0">re += </span><span class="s2">'</span><span class="s4">\\\\</span><span class="s2">'</span>
  <span class="s0">}</span>

  <span class="s3">// only need to apply the nodot start if the re starts with</span>
  <span class="s3">// something that could conceivably capture a dot</span>
  <span class="s1">var </span><span class="s0">addPatternStart = </span><span class="s1">false</span>
  <span class="s1">switch </span><span class="s0">(re.charAt(</span><span class="s6">0</span><span class="s0">)) {</span>
    <span class="s1">case </span><span class="s2">'['</span><span class="s0">: </span><span class="s1">case </span><span class="s2">'.'</span><span class="s0">: </span><span class="s1">case </span><span class="s2">'('</span><span class="s0">: addPatternStart = </span><span class="s1">true</span>
  <span class="s0">}</span>

  <span class="s3">// Hack to work around lack of negative lookbehind in JS</span>
  <span class="s3">// A pattern like: *.!(x).!(y|z) needs to ensure that a name</span>
  <span class="s3">// like 'a.xyz.yz' doesn't match.  So, the first negative</span>
  <span class="s3">// lookahead, has to look ALL the way ahead, to the end of</span>
  <span class="s3">// the pattern.</span>
  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">n = negativeLists.length - </span><span class="s6">1</span><span class="s0">; n &gt; -</span><span class="s6">1</span><span class="s0">; n--) {</span>
    <span class="s1">var </span><span class="s0">nl = negativeLists[n]</span>

    <span class="s1">var </span><span class="s0">nlBefore = re.slice(</span><span class="s6">0</span><span class="s0">, nl.reStart)</span>
    <span class="s1">var </span><span class="s0">nlFirst = re.slice(nl.reStart, nl.reEnd - </span><span class="s6">8</span><span class="s0">)</span>
    <span class="s1">var </span><span class="s0">nlLast = re.slice(nl.reEnd - </span><span class="s6">8</span><span class="s0">, nl.reEnd)</span>
    <span class="s1">var </span><span class="s0">nlAfter = re.slice(nl.reEnd)</span>

    <span class="s0">nlLast += nlAfter</span>

    <span class="s3">// Handle nested stuff like *(*.js|!(*.json)), where open parens</span>
    <span class="s3">// mean that we should *not* include the ) in the bit that is considered</span>
    <span class="s3">// &quot;after&quot; the negated section.</span>
    <span class="s1">var </span><span class="s0">openParensBefore = nlBefore.split(</span><span class="s2">'('</span><span class="s0">).length - </span><span class="s6">1</span>
    <span class="s1">var </span><span class="s0">cleanAfter = nlAfter</span>
    <span class="s1">for </span><span class="s0">(i = </span><span class="s6">0</span><span class="s0">; i &lt; openParensBefore; i++) {</span>
      <span class="s0">cleanAfter = cleanAfter.replace(/\)[+*?]?/, </span><span class="s2">''</span><span class="s0">)</span>
    <span class="s0">}</span>
    <span class="s0">nlAfter = cleanAfter</span>

    <span class="s1">var </span><span class="s0">dollar = </span><span class="s2">''</span>
    <span class="s1">if </span><span class="s0">(nlAfter === </span><span class="s2">'' </span><span class="s0">&amp;&amp; isSub !== SUBPARSE) {</span>
      <span class="s0">dollar = </span><span class="s2">'$'</span>
    <span class="s0">}</span>
    <span class="s1">var </span><span class="s0">newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast</span>
    <span class="s0">re = newRe</span>
  <span class="s0">}</span>

  <span class="s3">// if the re is not &quot;&quot; at this point, then we need to make sure</span>
  <span class="s3">// it doesn't match against an empty path part.</span>
  <span class="s3">// Otherwise a/* will match a/, which it should not.</span>
  <span class="s1">if </span><span class="s0">(re !== </span><span class="s2">'' </span><span class="s0">&amp;&amp; hasMagic) {</span>
    <span class="s0">re = </span><span class="s2">'(?=.)' </span><span class="s0">+ re</span>
  <span class="s0">}</span>

  <span class="s1">if </span><span class="s0">(addPatternStart) {</span>
    <span class="s0">re = patternStart + re</span>
  <span class="s0">}</span>

  <span class="s3">// parsing just a piece of a larger pattern.</span>
  <span class="s1">if </span><span class="s0">(isSub === SUBPARSE) {</span>
    <span class="s1">return </span><span class="s0">[re, hasMagic]</span>
  <span class="s0">}</span>

  <span class="s3">// skip the regexp for non-magical patterns</span>
  <span class="s3">// unescape anything in it, though, so that it'll be</span>
  <span class="s3">// an exact match against a file etc.</span>
  <span class="s1">if </span><span class="s0">(!hasMagic) {</span>
    <span class="s1">return </span><span class="s0">globUnescape(pattern)</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">flags = options.nocase ? </span><span class="s2">'i' </span><span class="s0">: </span><span class="s2">''</span>
  <span class="s1">try </span><span class="s0">{</span>
    <span class="s1">var </span><span class="s0">regExp = </span><span class="s1">new </span><span class="s0">RegExp(</span><span class="s2">'^' </span><span class="s0">+ re + </span><span class="s2">'$'</span><span class="s0">, flags)</span>
  <span class="s0">} </span><span class="s1">catch </span><span class="s0">(er) </span><span class="s3">/* istanbul ignore next - should be impossible */ </span><span class="s0">{</span>
    <span class="s3">// If it was an invalid regular expression, then it can't match</span>
    <span class="s3">// anything.  This trick looks for a character after the end of</span>
    <span class="s3">// the string, which is of course impossible, except in multi-line</span>
    <span class="s3">// mode, but it's not a /m regex.</span>
    <span class="s1">return new </span><span class="s0">RegExp(</span><span class="s2">'$.'</span><span class="s0">)</span>
  <span class="s0">}</span>

  <span class="s0">regExp._glob = pattern</span>
  <span class="s0">regExp._src = re</span>

  <span class="s1">return </span><span class="s0">regExp</span>
<span class="s0">}</span>

<span class="s0">minimatch.makeRe = </span><span class="s1">function </span><span class="s0">(pattern, options) {</span>
  <span class="s1">return new </span><span class="s0">Minimatch(pattern, options || {}).makeRe()</span>
<span class="s0">}</span>

<span class="s0">Minimatch.prototype.makeRe = makeRe</span>
<span class="s1">function </span><span class="s0">makeRe () {</span>
  <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.regexp || </span><span class="s1">this</span><span class="s0">.regexp === </span><span class="s1">false</span><span class="s0">) </span><span class="s1">return this</span><span class="s0">.regexp</span>

  <span class="s3">// at this point, this.set is a 2d array of partial</span>
  <span class="s3">// pattern strings, or &quot;**&quot;.</span>
  <span class="s3">//</span>
  <span class="s3">// It's better to use .match().  This function shouldn't</span>
  <span class="s3">// be used, really, but it's pretty convenient sometimes,</span>
  <span class="s3">// when you just want to work with a regex.</span>
  <span class="s1">var </span><span class="s0">set = </span><span class="s1">this</span><span class="s0">.set</span>

  <span class="s1">if </span><span class="s0">(!set.length) {</span>
    <span class="s1">this</span><span class="s0">.regexp = </span><span class="s1">false</span>
    <span class="s1">return this</span><span class="s0">.regexp</span>
  <span class="s0">}</span>
  <span class="s1">var </span><span class="s0">options = </span><span class="s1">this</span><span class="s0">.options</span>

  <span class="s1">var </span><span class="s0">twoStar = options.noglobstar ? star</span>
    <span class="s0">: options.dot ? twoStarDot</span>
    <span class="s0">: twoStarNoDot</span>
  <span class="s1">var </span><span class="s0">flags = options.nocase ? </span><span class="s2">'i' </span><span class="s0">: </span><span class="s2">''</span>

  <span class="s1">var </span><span class="s0">re = set.map(</span><span class="s1">function </span><span class="s0">(pattern) {</span>
    <span class="s1">return </span><span class="s0">pattern.map(</span><span class="s1">function </span><span class="s0">(p) {</span>
      <span class="s1">return </span><span class="s0">(p === GLOBSTAR) ? twoStar</span>
      <span class="s0">: (</span><span class="s1">typeof </span><span class="s0">p === </span><span class="s2">'string'</span><span class="s0">) ? regExpEscape(p)</span>
      <span class="s0">: p._src</span>
    <span class="s0">}).join(</span><span class="s2">'</span><span class="s4">\\</span><span class="s5">\/</span><span class="s2">'</span><span class="s0">)</span>
  <span class="s0">}).join(</span><span class="s2">'|'</span><span class="s0">)</span>

  <span class="s3">// must match entire pattern</span>
  <span class="s3">// ending in a * or ** will make it less strict.</span>
  <span class="s0">re = </span><span class="s2">'^(?:' </span><span class="s0">+ re + </span><span class="s2">')$'</span>

  <span class="s3">// can match anything, as long as it's not this.</span>
  <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.negate) re = </span><span class="s2">'^(?!' </span><span class="s0">+ re + </span><span class="s2">').*$'</span>

  <span class="s1">try </span><span class="s0">{</span>
    <span class="s1">this</span><span class="s0">.regexp = </span><span class="s1">new </span><span class="s0">RegExp(re, flags)</span>
  <span class="s0">} </span><span class="s1">catch </span><span class="s0">(ex) </span><span class="s3">/* istanbul ignore next - should be impossible */ </span><span class="s0">{</span>
    <span class="s1">this</span><span class="s0">.regexp = </span><span class="s1">false</span>
  <span class="s0">}</span>
  <span class="s1">return this</span><span class="s0">.regexp</span>
<span class="s0">}</span>

<span class="s0">minimatch.match = </span><span class="s1">function </span><span class="s0">(list, pattern, options) {</span>
  <span class="s0">options = options || {}</span>
  <span class="s1">var </span><span class="s0">mm = </span><span class="s1">new </span><span class="s0">Minimatch(pattern, options)</span>
  <span class="s0">list = list.filter(</span><span class="s1">function </span><span class="s0">(f) {</span>
    <span class="s1">return </span><span class="s0">mm.match(f)</span>
  <span class="s0">})</span>
  <span class="s1">if </span><span class="s0">(mm.options.nonull &amp;&amp; !list.length) {</span>
    <span class="s0">list.push(pattern)</span>
  <span class="s0">}</span>
  <span class="s1">return </span><span class="s0">list</span>
<span class="s0">}</span>

<span class="s0">Minimatch.prototype.match = </span><span class="s1">function </span><span class="s0">match (f, partial) {</span>
  <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">partial === </span><span class="s2">'undefined'</span><span class="s0">) partial = </span><span class="s1">this</span><span class="s0">.partial</span>
  <span class="s1">this</span><span class="s0">.debug(</span><span class="s2">'match'</span><span class="s0">, f, </span><span class="s1">this</span><span class="s0">.pattern)</span>
  <span class="s3">// short-circuit in the case of busted things.</span>
  <span class="s3">// comments, etc.</span>
  <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.comment) </span><span class="s1">return false</span>
  <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.empty) </span><span class="s1">return </span><span class="s0">f === </span><span class="s2">''</span>

  <span class="s1">if </span><span class="s0">(f === </span><span class="s2">'/' </span><span class="s0">&amp;&amp; partial) </span><span class="s1">return true</span>

  <span class="s1">var </span><span class="s0">options = </span><span class="s1">this</span><span class="s0">.options</span>

  <span class="s3">// windows: need to use /, not \</span>
  <span class="s1">if </span><span class="s0">(path.sep !== </span><span class="s2">'/'</span><span class="s0">) {</span>
    <span class="s0">f = f.split(path.sep).join(</span><span class="s2">'/'</span><span class="s0">)</span>
  <span class="s0">}</span>

  <span class="s3">// treat the test path as a set of pathparts.</span>
  <span class="s0">f = f.split(slashSplit)</span>
  <span class="s1">this</span><span class="s0">.debug(</span><span class="s1">this</span><span class="s0">.pattern, </span><span class="s2">'split'</span><span class="s0">, f)</span>

  <span class="s3">// just ONE of the pattern sets in this.set needs to match</span>
  <span class="s3">// in order for it to be valid.  If negating, then just one</span>
  <span class="s3">// match means that we have failed.</span>
  <span class="s3">// Either way, return on the first hit.</span>

  <span class="s1">var </span><span class="s0">set = </span><span class="s1">this</span><span class="s0">.set</span>
  <span class="s1">this</span><span class="s0">.debug(</span><span class="s1">this</span><span class="s0">.pattern, </span><span class="s2">'set'</span><span class="s0">, set)</span>

  <span class="s3">// Find the basename of the path by looking for the last non-empty segment</span>
  <span class="s1">var </span><span class="s0">filename</span>
  <span class="s1">var </span><span class="s0">i</span>
  <span class="s1">for </span><span class="s0">(i = f.length - </span><span class="s6">1</span><span class="s0">; i &gt;= </span><span class="s6">0</span><span class="s0">; i--) {</span>
    <span class="s0">filename = f[i]</span>
    <span class="s1">if </span><span class="s0">(filename) </span><span class="s1">break</span>
  <span class="s0">}</span>

  <span class="s1">for </span><span class="s0">(i = </span><span class="s6">0</span><span class="s0">; i &lt; set.length; i++) {</span>
    <span class="s1">var </span><span class="s0">pattern = set[i]</span>
    <span class="s1">var </span><span class="s0">file = f</span>
    <span class="s1">if </span><span class="s0">(options.matchBase &amp;&amp; pattern.length === </span><span class="s6">1</span><span class="s0">) {</span>
      <span class="s0">file = [filename]</span>
    <span class="s0">}</span>
    <span class="s1">var </span><span class="s0">hit = </span><span class="s1">this</span><span class="s0">.matchOne(file, pattern, partial)</span>
    <span class="s1">if </span><span class="s0">(hit) {</span>
      <span class="s1">if </span><span class="s0">(options.flipNegate) </span><span class="s1">return true</span>
      <span class="s1">return </span><span class="s0">!</span><span class="s1">this</span><span class="s0">.negate</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s3">// didn't get any hits.  this is success if it's a negative</span>
  <span class="s3">// pattern, failure otherwise.</span>
  <span class="s1">if </span><span class="s0">(options.flipNegate) </span><span class="s1">return false</span>
  <span class="s1">return this</span><span class="s0">.negate</span>
<span class="s0">}</span>

<span class="s3">// set partial to true to test if, for example,</span>
<span class="s3">// &quot;/a/b&quot; matches the start of &quot;/*/b/*/d&quot;</span>
<span class="s3">// Partial means, if you run out of file before you run</span>
<span class="s3">// out of pattern, then that's fine, as long as all</span>
<span class="s3">// the parts match.</span>
<span class="s0">Minimatch.prototype.matchOne = </span><span class="s1">function </span><span class="s0">(file, pattern, partial) {</span>
  <span class="s1">var </span><span class="s0">options = </span><span class="s1">this</span><span class="s0">.options</span>

  <span class="s1">this</span><span class="s0">.debug(</span><span class="s2">'matchOne'</span><span class="s0">,</span>
    <span class="s0">{ </span><span class="s2">'this'</span><span class="s0">: </span><span class="s1">this</span><span class="s0">, file: file, pattern: pattern })</span>

  <span class="s1">this</span><span class="s0">.debug(</span><span class="s2">'matchOne'</span><span class="s0">, file.length, pattern.length)</span>

  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">fi = </span><span class="s6">0</span><span class="s0">,</span>
      <span class="s0">pi = </span><span class="s6">0</span><span class="s0">,</span>
      <span class="s0">fl = file.length,</span>
      <span class="s0">pl = pattern.length</span>
      <span class="s0">; (fi &lt; fl) &amp;&amp; (pi &lt; pl)</span>
      <span class="s0">; fi++, pi++) {</span>
    <span class="s1">this</span><span class="s0">.debug(</span><span class="s2">'matchOne loop'</span><span class="s0">)</span>
    <span class="s1">var </span><span class="s0">p = pattern[pi]</span>
    <span class="s1">var </span><span class="s0">f = file[fi]</span>

    <span class="s1">this</span><span class="s0">.debug(pattern, p, f)</span>

    <span class="s3">// should be impossible.</span>
    <span class="s3">// some invalid regexp stuff in the set.</span>
    <span class="s3">/* istanbul ignore if */</span>
    <span class="s1">if </span><span class="s0">(p === </span><span class="s1">false</span><span class="s0">) </span><span class="s1">return false</span>

    <span class="s1">if </span><span class="s0">(p === GLOBSTAR) {</span>
      <span class="s1">this</span><span class="s0">.debug(</span><span class="s2">'GLOBSTAR'</span><span class="s0">, [pattern, p, f])</span>

      <span class="s3">// &quot;**&quot;</span>
      <span class="s3">// a/**/b/**/c would match the following:</span>
      <span class="s3">// a/b/x/y/z/c</span>
      <span class="s3">// a/x/y/z/b/c</span>
      <span class="s3">// a/b/x/b/x/c</span>
      <span class="s3">// a/b/c</span>
      <span class="s3">// To do this, take the rest of the pattern after</span>
      <span class="s3">// the **, and see if it would match the file remainder.</span>
      <span class="s3">// If so, return success.</span>
      <span class="s3">// If not, the ** &quot;swallows&quot; a segment, and try again.</span>
      <span class="s3">// This is recursively awful.</span>
      <span class="s3">//</span>
      <span class="s3">// a/**/b/**/c matching a/b/x/y/z/c</span>
      <span class="s3">// - a matches a</span>
      <span class="s3">// - doublestar</span>
      <span class="s3">//   - matchOne(b/x/y/z/c, b/**/c)</span>
      <span class="s3">//     - b matches b</span>
      <span class="s3">//     - doublestar</span>
      <span class="s3">//       - matchOne(x/y/z/c, c) -&gt; no</span>
      <span class="s3">//       - matchOne(y/z/c, c) -&gt; no</span>
      <span class="s3">//       - matchOne(z/c, c) -&gt; no</span>
      <span class="s3">//       - matchOne(c, c) yes, hit</span>
      <span class="s1">var </span><span class="s0">fr = fi</span>
      <span class="s1">var </span><span class="s0">pr = pi + </span><span class="s6">1</span>
      <span class="s1">if </span><span class="s0">(pr === pl) {</span>
        <span class="s1">this</span><span class="s0">.debug(</span><span class="s2">'** at the end'</span><span class="s0">)</span>
        <span class="s3">// a ** at the end will just swallow the rest.</span>
        <span class="s3">// We have found a match.</span>
        <span class="s3">// however, it will not swallow /.x, unless</span>
        <span class="s3">// options.dot is set.</span>
        <span class="s3">// . and .. are *never* matched by **, for explosively</span>
        <span class="s3">// exponential reasons.</span>
        <span class="s1">for </span><span class="s0">(; fi &lt; fl; fi++) {</span>
          <span class="s1">if </span><span class="s0">(file[fi] === </span><span class="s2">'.' </span><span class="s0">|| file[fi] === </span><span class="s2">'..' </span><span class="s0">||</span>
            <span class="s0">(!options.dot &amp;&amp; file[fi].charAt(</span><span class="s6">0</span><span class="s0">) === </span><span class="s2">'.'</span><span class="s0">)) </span><span class="s1">return false</span>
        <span class="s0">}</span>
        <span class="s1">return true</span>
      <span class="s0">}</span>

      <span class="s3">// ok, let's see if we can swallow whatever we can.</span>
      <span class="s1">while </span><span class="s0">(fr &lt; fl) {</span>
        <span class="s1">var </span><span class="s0">swallowee = file[fr]</span>

        <span class="s1">this</span><span class="s0">.debug(</span><span class="s2">'</span><span class="s4">\n</span><span class="s2">globstar while'</span><span class="s0">, file, fr, pattern, pr, swallowee)</span>

        <span class="s3">// XXX remove this slice.  Just pass the start index.</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.matchOne(file.slice(fr), pattern.slice(pr), partial)) {</span>
          <span class="s1">this</span><span class="s0">.debug(</span><span class="s2">'globstar found match!'</span><span class="s0">, fr, fl, swallowee)</span>
          <span class="s3">// found a match.</span>
          <span class="s1">return true</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
          <span class="s3">// can't swallow &quot;.&quot; or &quot;..&quot; ever.</span>
          <span class="s3">// can only swallow &quot;.foo&quot; when explicitly asked.</span>
          <span class="s1">if </span><span class="s0">(swallowee === </span><span class="s2">'.' </span><span class="s0">|| swallowee === </span><span class="s2">'..' </span><span class="s0">||</span>
            <span class="s0">(!options.dot &amp;&amp; swallowee.charAt(</span><span class="s6">0</span><span class="s0">) === </span><span class="s2">'.'</span><span class="s0">)) {</span>
            <span class="s1">this</span><span class="s0">.debug(</span><span class="s2">'dot detected!'</span><span class="s0">, file, fr, pattern, pr)</span>
            <span class="s1">break</span>
          <span class="s0">}</span>

          <span class="s3">// ** swallows a segment, and continue.</span>
          <span class="s1">this</span><span class="s0">.debug(</span><span class="s2">'globstar swallow a segment, and continue'</span><span class="s0">)</span>
          <span class="s0">fr++</span>
        <span class="s0">}</span>
      <span class="s0">}</span>

      <span class="s3">// no match was found.</span>
      <span class="s3">// However, in partial mode, we can't say this is necessarily over.</span>
      <span class="s3">// If there's more *pattern* left, then</span>
      <span class="s3">/* istanbul ignore if */</span>
      <span class="s1">if </span><span class="s0">(partial) {</span>
        <span class="s3">// ran out of file</span>
        <span class="s1">this</span><span class="s0">.debug(</span><span class="s2">'</span><span class="s4">\n</span><span class="s2">&gt;&gt;&gt; no match, partial?'</span><span class="s0">, file, fr, pattern, pr)</span>
        <span class="s1">if </span><span class="s0">(fr === fl) </span><span class="s1">return true</span>
      <span class="s0">}</span>
      <span class="s1">return false</span>
    <span class="s0">}</span>

    <span class="s3">// something other than **</span>
    <span class="s3">// non-magic patterns just have to match exactly</span>
    <span class="s3">// patterns with magic have been turned into regexps.</span>
    <span class="s1">var </span><span class="s0">hit</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">p === </span><span class="s2">'string'</span><span class="s0">) {</span>
      <span class="s0">hit = f === p</span>
      <span class="s1">this</span><span class="s0">.debug(</span><span class="s2">'string match'</span><span class="s0">, p, f, hit)</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s0">hit = f.match(p)</span>
      <span class="s1">this</span><span class="s0">.debug(</span><span class="s2">'pattern match'</span><span class="s0">, p, f, hit)</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(!hit) </span><span class="s1">return false</span>
  <span class="s0">}</span>

  <span class="s3">// Note: ending in / means that we'll get a final &quot;&quot;</span>
  <span class="s3">// at the end of the pattern.  This can only match a</span>
  <span class="s3">// corresponding &quot;&quot; at the end of the file.</span>
  <span class="s3">// If the file ends in /, then it can only match a</span>
  <span class="s3">// a pattern that ends in /, unless the pattern just</span>
  <span class="s3">// doesn't have any more for it. But, a/b/ should *not*</span>
  <span class="s3">// match &quot;a/b/*&quot;, even though &quot;&quot; matches against the</span>
  <span class="s3">// [^/]*? pattern, except in partial mode, where it might</span>
  <span class="s3">// simply not be reached yet.</span>
  <span class="s3">// However, a/b/ should still satisfy a/*</span>

  <span class="s3">// now either we fell off the end of the pattern, or we're done.</span>
  <span class="s1">if </span><span class="s0">(fi === fl &amp;&amp; pi === pl) {</span>
    <span class="s3">// ran out of pattern and filename at the same time.</span>
    <span class="s3">// an exact hit!</span>
    <span class="s1">return true</span>
  <span class="s0">} </span><span class="s1">else if </span><span class="s0">(fi === fl) {</span>
    <span class="s3">// ran out of file, but still had pattern left.</span>
    <span class="s3">// this is ok if we're doing the match as part of</span>
    <span class="s3">// a glob fs traversal.</span>
    <span class="s1">return </span><span class="s0">partial</span>
  <span class="s0">} </span><span class="s1">else </span><span class="s3">/* istanbul ignore else */ </span><span class="s1">if </span><span class="s0">(pi === pl) {</span>
    <span class="s3">// ran out of pattern, still have file left.</span>
    <span class="s3">// this is only acceptable if we're on the very last</span>
    <span class="s3">// empty segment of a file with a trailing slash.</span>
    <span class="s3">// a/* should match a/b/</span>
    <span class="s1">return </span><span class="s0">(fi === fl - </span><span class="s6">1</span><span class="s0">) &amp;&amp; (file[fi] === </span><span class="s2">''</span><span class="s0">)</span>
  <span class="s0">}</span>

  <span class="s3">// should be unreachable.</span>
  <span class="s3">/* istanbul ignore next */</span>
  <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'wtf?'</span><span class="s0">)</span>
<span class="s0">}</span>

<span class="s3">// replace stuff like \* with *</span>
<span class="s1">function </span><span class="s0">globUnescape (s) {</span>
  <span class="s1">return </span><span class="s0">s.replace(/\\(.)/g, </span><span class="s2">'$1'</span><span class="s0">)</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">regExpEscape (s) {</span>
  <span class="s1">return </span><span class="s0">s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, </span><span class="s2">'</span><span class="s4">\\</span><span class="s2">$&amp;'</span><span class="s0">)</span>
<span class="s0">}</span>
</pre>
</body>
</html>
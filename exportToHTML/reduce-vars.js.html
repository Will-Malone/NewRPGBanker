<html>
<head>
<title>reduce-vars.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
reduce-vars.js</font>
</center></td></tr></table>
<pre><span class="s0">/*********************************************************************** 
 
  A JavaScript tokenizer / parser / beautifier / compressor. 
  https://github.com/mishoo/UglifyJS2 
 
  -------------------------------- (C) --------------------------------- 
 
                           Author: Mihai Bazon 
                         &lt;mihai.bazon@gmail.com&gt; 
                       http://mihai.bazon.net/blog 
 
  Distributed under the BSD license: 
 
    Copyright 2012 (c) Mihai Bazon &lt;mihai.bazon@gmail.com&gt; 
 
    Redistribution and use in source and binary forms, with or without 
    modification, are permitted provided that the following conditions 
    are met: 
 
        * Redistributions of source code must retain the above 
          copyright notice, this list of conditions and the following 
          disclaimer. 
 
        * Redistributions in binary form must reproduce the above 
          copyright notice, this list of conditions and the following 
          disclaimer in the documentation and/or other materials 
          provided with the distribution. 
 
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY 
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE 
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, 
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF 
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
    SUCH DAMAGE. 
 
 ***********************************************************************/</span>

<span class="s1">import {</span>
    <span class="s1">AST_Accessor,</span>
    <span class="s1">AST_Array,</span>
    <span class="s1">AST_Assign,</span>
    <span class="s1">AST_Await,</span>
    <span class="s1">AST_Binary,</span>
    <span class="s1">AST_Block,</span>
    <span class="s1">AST_Call,</span>
    <span class="s1">AST_Case,</span>
    <span class="s1">AST_Chain,</span>
    <span class="s1">AST_Class,</span>
    <span class="s1">AST_ClassStaticBlock,</span>
    <span class="s1">AST_ClassExpression,</span>
    <span class="s1">AST_Conditional,</span>
    <span class="s1">AST_Default,</span>
    <span class="s1">AST_Defun,</span>
    <span class="s1">AST_Destructuring,</span>
    <span class="s1">AST_Do,</span>
    <span class="s1">AST_Exit,</span>
    <span class="s1">AST_Expansion,</span>
    <span class="s1">AST_For,</span>
    <span class="s1">AST_ForIn,</span>
    <span class="s1">AST_If,</span>
    <span class="s1">AST_LabeledStatement,</span>
    <span class="s1">AST_Lambda,</span>
    <span class="s1">AST_New,</span>
    <span class="s1">AST_Node,</span>
    <span class="s1">AST_Number,</span>
    <span class="s1">AST_ObjectKeyVal,</span>
    <span class="s1">AST_PropAccess,</span>
    <span class="s1">AST_Scope,</span>
    <span class="s1">AST_Sequence,</span>
    <span class="s1">AST_SimpleStatement,</span>
    <span class="s1">AST_Symbol,</span>
    <span class="s1">AST_SymbolCatch,</span>
    <span class="s1">AST_SymbolConst,</span>
    <span class="s1">AST_SymbolDeclaration,</span>
    <span class="s1">AST_SymbolDefun,</span>
    <span class="s1">AST_SymbolFunarg,</span>
    <span class="s1">AST_SymbolLambda,</span>
    <span class="s1">AST_SymbolRef,</span>
    <span class="s1">AST_This,</span>
    <span class="s1">AST_Toplevel,</span>
    <span class="s1">AST_Try,</span>
    <span class="s1">AST_Unary,</span>
    <span class="s1">AST_UnaryPrefix,</span>
    <span class="s1">AST_Undefined,</span>
    <span class="s1">AST_VarDef,</span>
    <span class="s1">AST_While,</span>
    <span class="s1">AST_Yield,</span>

    <span class="s1">walk,</span>
    <span class="s1">walk_body,</span>

    <span class="s1">TreeWalker,</span>

    <span class="s1">_INLINE,</span>
    <span class="s1">_NOINLINE,</span>
    <span class="s1">_PURE</span>
<span class="s1">} from </span><span class="s2">&quot;../ast.js&quot;</span><span class="s1">;</span>
<span class="s1">import { HOP, make_node, noop } from </span><span class="s2">&quot;../utils/index.js&quot;</span><span class="s1">;</span>

<span class="s1">import { lazy_op, is_modified, is_lhs } from </span><span class="s2">&quot;./inference.js&quot;</span><span class="s1">;</span>
<span class="s1">import { INLINED, clear_flag } from </span><span class="s2">&quot;./compressor-flags.js&quot;</span><span class="s1">;</span>
<span class="s1">import { read_property, has_break_or_continue, is_recursive_ref } from </span><span class="s2">&quot;./common.js&quot;</span><span class="s1">;</span>

<span class="s0">/** 
 * Define the method AST_Node#reduce_vars, which goes through the AST in 
 * execution order to perform basic flow analysis 
 */</span>
<span class="s3">function </span><span class="s1">def_reduce_vars(node, func) {</span>
    <span class="s1">node.DEFMETHOD(</span><span class="s2">&quot;reduce_vars&quot;</span><span class="s1">, func);</span>
<span class="s1">}</span>

<span class="s1">def_reduce_vars(AST_Node, noop);</span>

<span class="s0">/** Clear definition properties */</span>
<span class="s3">function </span><span class="s1">reset_def(compressor, def) {</span>
    <span class="s1">def.assignments = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">def.chained = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">def.direct_access = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">def.escaped = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">def.recursive_refs = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">def.references = [];</span>
    <span class="s1">def.single_use = undefined;</span>
    <span class="s3">if </span><span class="s1">(</span>
        <span class="s1">def.scope.pinned()</span>
        <span class="s1">|| (def.orig[</span><span class="s4">0</span><span class="s1">] </span><span class="s3">instanceof </span><span class="s1">AST_SymbolFunarg &amp;&amp; def.scope.uses_arguments)</span>
    <span class="s1">) {</span>
        <span class="s1">def.fixed = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(def.orig[</span><span class="s4">0</span><span class="s1">] </span><span class="s3">instanceof </span><span class="s1">AST_SymbolConst || !compressor.exposed(def)) {</span>
        <span class="s1">def.fixed = def.init;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">def.fixed = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">reset_variables(tw, compressor, node) {</span>
    <span class="s1">node.variables.forEach(</span><span class="s3">function</span><span class="s1">(def) {</span>
        <span class="s1">reset_def(compressor, def);</span>
        <span class="s3">if </span><span class="s1">(def.fixed === </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s1">tw.defs_to_safe_ids.set(def.id, tw.safe_ids);</span>
            <span class="s1">mark(tw, def, </span><span class="s3">true</span><span class="s1">);</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(def.fixed) {</span>
            <span class="s1">tw.loop_ids.set(def.id, tw.in_loop);</span>
            <span class="s1">mark(tw, def, </span><span class="s3">true</span><span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">reset_block_variables(compressor, node) {</span>
    <span class="s3">if </span><span class="s1">(node.block_scope) node.block_scope.variables.forEach((def) =&gt; {</span>
        <span class="s1">reset_def(compressor, def);</span>
    <span class="s1">});</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">push(tw) {</span>
    <span class="s1">tw.safe_ids = Object.create(tw.safe_ids);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">pop(tw) {</span>
    <span class="s1">tw.safe_ids = Object.getPrototypeOf(tw.safe_ids);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">mark(tw, def, safe) {</span>
    <span class="s1">tw.safe_ids[def.id] = safe;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">safe_to_read(tw, def) {</span>
    <span class="s3">if </span><span class="s1">(def.single_use == </span><span class="s2">&quot;m&quot;</span><span class="s1">) </span><span class="s3">return false</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s1">(tw.safe_ids[def.id]) {</span>
        <span class="s3">if </span><span class="s1">(def.fixed == </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s3">var </span><span class="s1">orig = def.orig[</span><span class="s4">0</span><span class="s1">];</span>
            <span class="s3">if </span><span class="s1">(orig </span><span class="s3">instanceof </span><span class="s1">AST_SymbolFunarg || orig.name == </span><span class="s2">&quot;arguments&quot;</span><span class="s1">) </span><span class="s3">return false</span><span class="s1">;</span>
            <span class="s1">def.fixed = make_node(AST_Undefined, orig);</span>
        <span class="s1">}</span>
        <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s1">def.fixed </span><span class="s3">instanceof </span><span class="s1">AST_Defun;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">safe_to_assign(tw, def, scope, value) {</span>
    <span class="s3">if </span><span class="s1">(def.fixed === undefined) </span><span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">let def_safe_ids;</span>
    <span class="s3">if </span><span class="s1">(def.fixed === </span><span class="s3">null</span>
        <span class="s1">&amp;&amp; (def_safe_ids = tw.defs_to_safe_ids.get(def.id))</span>
    <span class="s1">) {</span>
        <span class="s1">def_safe_ids[def.id] = </span><span class="s3">false</span><span class="s1">;</span>
        <span class="s1">tw.defs_to_safe_ids.</span><span class="s3">delete</span><span class="s1">(def.id);</span>
        <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(!HOP(tw.safe_ids, def.id)) </span><span class="s3">return false</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s1">(!safe_to_read(tw, def)) </span><span class="s3">return false</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s1">(def.fixed === </span><span class="s3">false</span><span class="s1">) </span><span class="s3">return false</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s1">(def.fixed != </span><span class="s3">null </span><span class="s1">&amp;&amp; (!value || def.references.length &gt; def.assignments)) </span><span class="s3">return false</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s1">(def.fixed </span><span class="s3">instanceof </span><span class="s1">AST_Defun) {</span>
        <span class="s3">return </span><span class="s1">value </span><span class="s3">instanceof </span><span class="s1">AST_Node &amp;&amp; def.fixed.parent_scope === scope;</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s1">def.orig.every((sym) =&gt; {</span>
        <span class="s3">return </span><span class="s1">!(sym </span><span class="s3">instanceof </span><span class="s1">AST_SymbolConst</span>
            <span class="s1">|| sym </span><span class="s3">instanceof </span><span class="s1">AST_SymbolDefun</span>
            <span class="s1">|| sym </span><span class="s3">instanceof </span><span class="s1">AST_SymbolLambda);</span>
    <span class="s1">});</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">ref_once(tw, compressor, def) {</span>
    <span class="s3">return </span><span class="s1">compressor.option(</span><span class="s2">&quot;unused&quot;</span><span class="s1">)</span>
        <span class="s1">&amp;&amp; !def.scope.pinned()</span>
        <span class="s1">&amp;&amp; def.references.length - def.recursive_refs == </span><span class="s4">1</span>
        <span class="s1">&amp;&amp; tw.loop_ids.get(def.id) === tw.in_loop;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">is_immutable(value) {</span>
    <span class="s3">if </span><span class="s1">(!value) </span><span class="s3">return false</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s1">value.is_constant()</span>
        <span class="s1">|| value </span><span class="s3">instanceof </span><span class="s1">AST_Lambda</span>
        <span class="s1">|| value </span><span class="s3">instanceof </span><span class="s1">AST_This;</span>
<span class="s1">}</span>

<span class="s0">// A definition &quot;escapes&quot; when its value can leave the point of use.</span>
<span class="s0">// Example: `a = b || c`</span>
<span class="s0">// In this example, &quot;b&quot; and &quot;c&quot; are escaping, because they're going into &quot;a&quot;</span>
<span class="s0">//</span>
<span class="s0">// def.escaped is != 0 when it escapes.</span>
<span class="s0">//</span>
<span class="s0">// When greater than 1, it means that N chained properties will be read off</span>
<span class="s0">// of that def before an escape occurs. This is useful for evaluating</span>
<span class="s0">// property accesses, where you need to know when to stop.</span>
<span class="s3">function </span><span class="s1">mark_escaped(tw, d, scope, node, value, level = </span><span class="s4">0</span><span class="s1">, depth = </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">parent = tw.parent(level);</span>
    <span class="s3">if </span><span class="s1">(value) {</span>
        <span class="s3">if </span><span class="s1">(value.is_constant()) </span><span class="s3">return</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s1">(value </span><span class="s3">instanceof </span><span class="s1">AST_ClassExpression) </span><span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span>
        <span class="s1">parent </span><span class="s3">instanceof </span><span class="s1">AST_Assign &amp;&amp; (parent.operator === </span><span class="s2">&quot;=&quot; </span><span class="s1">|| parent.logical) &amp;&amp; node === parent.right</span>
        <span class="s1">|| parent </span><span class="s3">instanceof </span><span class="s1">AST_Call &amp;&amp; (node !== parent.expression || parent </span><span class="s3">instanceof </span><span class="s1">AST_New)</span>
        <span class="s1">|| parent </span><span class="s3">instanceof </span><span class="s1">AST_Exit &amp;&amp; node === parent.value &amp;&amp; node.scope !== d.scope</span>
        <span class="s1">|| parent </span><span class="s3">instanceof </span><span class="s1">AST_VarDef &amp;&amp; node === parent.value</span>
        <span class="s1">|| parent </span><span class="s3">instanceof </span><span class="s1">AST_Yield &amp;&amp; node === parent.value &amp;&amp; node.scope !== d.scope</span>
    <span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(depth &gt; </span><span class="s4">1 </span><span class="s1">&amp;&amp; !(value &amp;&amp; value.is_constant_expression(scope))) depth = </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s1">(!d.escaped || d.escaped &gt; depth) d.escaped = depth;</span>
        <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span>
        <span class="s1">parent </span><span class="s3">instanceof </span><span class="s1">AST_Array</span>
        <span class="s1">|| parent </span><span class="s3">instanceof </span><span class="s1">AST_Await</span>
        <span class="s1">|| parent </span><span class="s3">instanceof </span><span class="s1">AST_Binary &amp;&amp; lazy_op.has(parent.operator)</span>
        <span class="s1">|| parent </span><span class="s3">instanceof </span><span class="s1">AST_Conditional &amp;&amp; node !== parent.condition</span>
        <span class="s1">|| parent </span><span class="s3">instanceof </span><span class="s1">AST_Expansion</span>
        <span class="s1">|| parent </span><span class="s3">instanceof </span><span class="s1">AST_Sequence &amp;&amp; node === parent.tail_node()</span>
    <span class="s1">) {</span>
        <span class="s1">mark_escaped(tw, d, scope, parent, parent, level + </span><span class="s4">1</span><span class="s1">, depth);</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(parent </span><span class="s3">instanceof </span><span class="s1">AST_ObjectKeyVal &amp;&amp; node === parent.value) {</span>
        <span class="s3">var </span><span class="s1">obj = tw.parent(level + </span><span class="s4">1</span><span class="s1">);</span>

        <span class="s1">mark_escaped(tw, d, scope, obj, obj, level + </span><span class="s4">2</span><span class="s1">, depth);</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(parent </span><span class="s3">instanceof </span><span class="s1">AST_PropAccess &amp;&amp; node === parent.expression) {</span>
        <span class="s1">value = read_property(value, parent.property);</span>

        <span class="s1">mark_escaped(tw, d, scope, parent, value, level + </span><span class="s4">1</span><span class="s1">, depth + </span><span class="s4">1</span><span class="s1">);</span>
        <span class="s3">if </span><span class="s1">(value) </span><span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(level &gt; </span><span class="s4">0</span><span class="s1">) </span><span class="s3">return</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s1">(parent </span><span class="s3">instanceof </span><span class="s1">AST_Sequence &amp;&amp; node !== parent.tail_node()) </span><span class="s3">return</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s1">(parent </span><span class="s3">instanceof </span><span class="s1">AST_SimpleStatement) </span><span class="s3">return</span><span class="s1">;</span>

    <span class="s1">d.direct_access = </span><span class="s3">true</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s1">const suppress = node =&gt; walk(node, node =&gt; {</span>
    <span class="s3">if </span><span class="s1">(!(node </span><span class="s3">instanceof </span><span class="s1">AST_Symbol)) </span><span class="s3">return</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">d = node.definition();</span>
    <span class="s3">if </span><span class="s1">(!d) </span><span class="s3">return</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef) d.references.push(node);</span>
    <span class="s1">d.fixed = </span><span class="s3">false</span><span class="s1">;</span>
<span class="s1">});</span>

<span class="s1">def_reduce_vars(AST_Accessor, </span><span class="s3">function</span><span class="s1">(tw, descend, compressor) {</span>
    <span class="s1">push(tw);</span>
    <span class="s1">reset_variables(tw, compressor, </span><span class="s3">this</span><span class="s1">);</span>
    <span class="s1">descend();</span>
    <span class="s1">pop(tw);</span>
    <span class="s3">return true</span><span class="s1">;</span>
<span class="s1">});</span>

<span class="s1">def_reduce_vars(AST_Assign, </span><span class="s3">function</span><span class="s1">(tw, descend, compressor) {</span>
    <span class="s3">var </span><span class="s1">node = </span><span class="s3">this</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s1">(node.left </span><span class="s3">instanceof </span><span class="s1">AST_Destructuring) {</span>
        <span class="s1">suppress(node.left);</span>
        <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">const finish_walk = () =&gt; {</span>
        <span class="s3">if </span><span class="s1">(node.logical) {</span>
            <span class="s1">node.left.walk(tw);</span>

            <span class="s1">push(tw);</span>
            <span class="s1">node.right.walk(tw);</span>
            <span class="s1">pop(tw);</span>

            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">};</span>

    <span class="s3">var </span><span class="s1">sym = node.left;</span>
    <span class="s3">if </span><span class="s1">(!(sym </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef)) </span><span class="s3">return </span><span class="s1">finish_walk();</span>

    <span class="s3">var </span><span class="s1">def = sym.definition();</span>
    <span class="s3">var </span><span class="s1">safe = safe_to_assign(tw, def, sym.scope, node.right);</span>
    <span class="s1">def.assignments++;</span>
    <span class="s3">if </span><span class="s1">(!safe) </span><span class="s3">return </span><span class="s1">finish_walk();</span>

    <span class="s3">var </span><span class="s1">fixed = def.fixed;</span>
    <span class="s3">if </span><span class="s1">(!fixed &amp;&amp; node.operator != </span><span class="s2">&quot;=&quot; </span><span class="s1">&amp;&amp; !node.logical) </span><span class="s3">return </span><span class="s1">finish_walk();</span>

    <span class="s3">var </span><span class="s1">eq = node.operator == </span><span class="s2">&quot;=&quot;</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">value = eq ? node.right : node;</span>
    <span class="s3">if </span><span class="s1">(is_modified(compressor, tw, node, value, </span><span class="s4">0</span><span class="s1">)) </span><span class="s3">return </span><span class="s1">finish_walk();</span>

    <span class="s1">def.references.push(sym);</span>

    <span class="s3">if </span><span class="s1">(!node.logical) {</span>
        <span class="s3">if </span><span class="s1">(!eq) def.chained = </span><span class="s3">true</span><span class="s1">;</span>

        <span class="s1">def.fixed = eq ? </span><span class="s3">function</span><span class="s1">() {</span>
            <span class="s3">return </span><span class="s1">node.right;</span>
        <span class="s1">} : </span><span class="s3">function</span><span class="s1">() {</span>
            <span class="s3">return </span><span class="s1">make_node(AST_Binary, node, {</span>
                <span class="s1">operator: node.operator.slice(</span><span class="s4">0</span><span class="s1">, -</span><span class="s4">1</span><span class="s1">),</span>
                <span class="s1">left: fixed </span><span class="s3">instanceof </span><span class="s1">AST_Node ? fixed : fixed(),</span>
                <span class="s1">right: node.right</span>
            <span class="s1">});</span>
        <span class="s1">};</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(node.logical) {</span>
        <span class="s1">mark(tw, def, </span><span class="s3">false</span><span class="s1">);</span>
        <span class="s1">push(tw);</span>
        <span class="s1">node.right.walk(tw);</span>
        <span class="s1">pop(tw);</span>
        <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">mark(tw, def, </span><span class="s3">false</span><span class="s1">);</span>
    <span class="s1">node.right.walk(tw);</span>
    <span class="s1">mark(tw, def, </span><span class="s3">true</span><span class="s1">);</span>

    <span class="s1">mark_escaped(tw, def, sym.scope, node, value, </span><span class="s4">0</span><span class="s1">, </span><span class="s4">1</span><span class="s1">);</span>

    <span class="s3">return true</span><span class="s1">;</span>
<span class="s1">});</span>

<span class="s1">def_reduce_vars(AST_Binary, </span><span class="s3">function</span><span class="s1">(tw) {</span>
    <span class="s3">if </span><span class="s1">(!lazy_op.has(</span><span class="s3">this</span><span class="s1">.operator)) </span><span class="s3">return</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s1">.left.walk(tw);</span>
    <span class="s1">push(tw);</span>
    <span class="s3">this</span><span class="s1">.right.walk(tw);</span>
    <span class="s1">pop(tw);</span>
    <span class="s3">return true</span><span class="s1">;</span>
<span class="s1">});</span>

<span class="s1">def_reduce_vars(AST_Block, </span><span class="s3">function</span><span class="s1">(tw, descend, compressor) {</span>
    <span class="s1">reset_block_variables(compressor, </span><span class="s3">this</span><span class="s1">);</span>
<span class="s1">});</span>

<span class="s1">def_reduce_vars(AST_Case, </span><span class="s3">function</span><span class="s1">(tw) {</span>
    <span class="s1">push(tw);</span>
    <span class="s3">this</span><span class="s1">.expression.walk(tw);</span>
    <span class="s1">pop(tw);</span>
    <span class="s1">push(tw);</span>
    <span class="s1">walk_body(</span><span class="s3">this</span><span class="s1">, tw);</span>
    <span class="s1">pop(tw);</span>
    <span class="s3">return true</span><span class="s1">;</span>
<span class="s1">});</span>

<span class="s1">def_reduce_vars(AST_Class, </span><span class="s3">function</span><span class="s1">(tw, descend) {</span>
    <span class="s1">clear_flag(</span><span class="s3">this</span><span class="s1">, INLINED);</span>
    <span class="s1">push(tw);</span>
    <span class="s1">descend();</span>
    <span class="s1">pop(tw);</span>
    <span class="s3">return true</span><span class="s1">;</span>
<span class="s1">});</span>

<span class="s1">def_reduce_vars(AST_ClassStaticBlock, </span><span class="s3">function</span><span class="s1">(tw, descend, compressor) {</span>
    <span class="s1">reset_block_variables(compressor, </span><span class="s3">this</span><span class="s1">);</span>
<span class="s1">});</span>

<span class="s1">def_reduce_vars(AST_Conditional, </span><span class="s3">function</span><span class="s1">(tw) {</span>
    <span class="s3">this</span><span class="s1">.condition.walk(tw);</span>
    <span class="s1">push(tw);</span>
    <span class="s3">this</span><span class="s1">.consequent.walk(tw);</span>
    <span class="s1">pop(tw);</span>
    <span class="s1">push(tw);</span>
    <span class="s3">this</span><span class="s1">.alternative.walk(tw);</span>
    <span class="s1">pop(tw);</span>
    <span class="s3">return true</span><span class="s1">;</span>
<span class="s1">});</span>

<span class="s1">def_reduce_vars(AST_Chain, </span><span class="s3">function</span><span class="s1">(tw, descend) {</span>
    <span class="s0">// Chains' conditions apply left-to-right, cumulatively.</span>
    <span class="s0">// If we walk normally we don't go in that order because we would pop before pushing again</span>
    <span class="s0">// Solution: AST_PropAccess and AST_Call push when they are optional, and never pop.</span>
    <span class="s0">// Then we pop everything when they are done being walked.</span>
    <span class="s1">const safe_ids = tw.safe_ids;</span>

    <span class="s1">descend();</span>

    <span class="s0">// Unroll back to start</span>
    <span class="s1">tw.safe_ids = safe_ids;</span>
    <span class="s3">return true</span><span class="s1">;</span>
<span class="s1">});</span>

<span class="s1">def_reduce_vars(AST_Call, </span><span class="s3">function </span><span class="s1">(tw) {</span>
    <span class="s3">this</span><span class="s1">.expression.walk(tw);</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.optional) {</span>
        <span class="s0">// Never pop -- it's popped at AST_Chain above</span>
        <span class="s1">push(tw);</span>
    <span class="s1">}</span>

    <span class="s3">for </span><span class="s1">(const arg of </span><span class="s3">this</span><span class="s1">.args) arg.walk(tw);</span>

    <span class="s3">return true</span><span class="s1">;</span>
<span class="s1">});</span>

<span class="s1">def_reduce_vars(AST_PropAccess, </span><span class="s3">function </span><span class="s1">(tw) {</span>
    <span class="s3">if </span><span class="s1">(!</span><span class="s3">this</span><span class="s1">.optional) </span><span class="s3">return</span><span class="s1">;</span>

    <span class="s3">this</span><span class="s1">.expression.walk(tw);</span>

    <span class="s0">// Never pop -- it's popped at AST_Chain above</span>
    <span class="s1">push(tw);</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.property </span><span class="s3">instanceof </span><span class="s1">AST_Node) </span><span class="s3">this</span><span class="s1">.property.walk(tw);</span>

    <span class="s3">return true</span><span class="s1">;</span>
<span class="s1">});</span>

<span class="s1">def_reduce_vars(AST_Default, </span><span class="s3">function</span><span class="s1">(tw, descend) {</span>
    <span class="s1">push(tw);</span>
    <span class="s1">descend();</span>
    <span class="s1">pop(tw);</span>
    <span class="s3">return true</span><span class="s1">;</span>
<span class="s1">});</span>

<span class="s3">function </span><span class="s1">mark_lambda(tw, descend, compressor) {</span>
    <span class="s1">clear_flag(</span><span class="s3">this</span><span class="s1">, INLINED);</span>
    <span class="s1">push(tw);</span>
    <span class="s1">reset_variables(tw, compressor, </span><span class="s3">this</span><span class="s1">);</span>

    <span class="s3">var </span><span class="s1">iife;</span>
    <span class="s3">if </span><span class="s1">(!</span><span class="s3">this</span><span class="s1">.name</span>
        <span class="s1">&amp;&amp; !</span><span class="s3">this</span><span class="s1">.uses_arguments</span>
        <span class="s1">&amp;&amp; !</span><span class="s3">this</span><span class="s1">.pinned()</span>
        <span class="s1">&amp;&amp; (iife = tw.parent()) </span><span class="s3">instanceof </span><span class="s1">AST_Call</span>
        <span class="s1">&amp;&amp; iife.expression === </span><span class="s3">this</span>
        <span class="s1">&amp;&amp; !iife.args.some(arg =&gt; arg </span><span class="s3">instanceof </span><span class="s1">AST_Expansion)</span>
        <span class="s1">&amp;&amp; </span><span class="s3">this</span><span class="s1">.argnames.every(arg_name =&gt; arg_name </span><span class="s3">instanceof </span><span class="s1">AST_Symbol)</span>
    <span class="s1">) {</span>
        <span class="s0">// Virtually turn IIFE parameters into variable definitions:</span>
        <span class="s0">//   (function(a,b) {...})(c,d) =&gt; (function() {var a=c,b=d; ...})()</span>
        <span class="s0">// So existing transformation rules can work on them.</span>
        <span class="s3">this</span><span class="s1">.argnames.forEach((arg, i) =&gt; {</span>
            <span class="s3">if </span><span class="s1">(!arg.definition) </span><span class="s3">return</span><span class="s1">;</span>
            <span class="s3">var </span><span class="s1">d = arg.definition();</span>
            <span class="s0">// Avoid setting fixed when there's more than one origin for a variable value</span>
            <span class="s3">if </span><span class="s1">(d.orig.length &gt; </span><span class="s4">1</span><span class="s1">) </span><span class="s3">return</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(d.fixed === undefined &amp;&amp; (!</span><span class="s3">this</span><span class="s1">.uses_arguments || tw.has_directive(</span><span class="s2">&quot;use strict&quot;</span><span class="s1">))) {</span>
                <span class="s1">d.fixed = </span><span class="s3">function</span><span class="s1">() {</span>
                    <span class="s3">return </span><span class="s1">iife.args[i] || make_node(AST_Undefined, iife);</span>
                <span class="s1">};</span>
                <span class="s1">tw.loop_ids.set(d.id, tw.in_loop);</span>
                <span class="s1">mark(tw, d, </span><span class="s3">true</span><span class="s1">);</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s1">d.fixed = </span><span class="s3">false</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s1">descend();</span>
    <span class="s1">pop(tw);</span>

    <span class="s1">handle_defined_after_hoist(</span><span class="s3">this</span><span class="s1">);</span>

    <span class="s3">return true</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">/** 
 * It's possible for a hoisted function to use something that's not defined yet. Example: 
 * 
 * hoisted(); 
 * var defined_after = true; 
 * function hoisted() { 
 *   // use defined_after 
 * } 
 * 
 * This function is called on the parent to handle this issue. 
 */</span>
<span class="s3">function </span><span class="s1">handle_defined_after_hoist(parent) {</span>
    <span class="s1">const defuns = [];</span>
    <span class="s1">walk(parent, node =&gt; {</span>
        <span class="s3">if </span><span class="s1">(node === parent) </span><span class="s3">return</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Defun) defuns.push(node);</span>
        <span class="s3">if </span><span class="s1">(</span>
            <span class="s1">node </span><span class="s3">instanceof </span><span class="s1">AST_Scope</span>
            <span class="s1">|| node </span><span class="s3">instanceof </span><span class="s1">AST_SimpleStatement</span>
        <span class="s1">) </span><span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">});</span>

    <span class="s1">const symbols_of_interest = </span><span class="s3">new </span><span class="s1">Set();</span>
    <span class="s1">const defuns_of_interest = </span><span class="s3">new </span><span class="s1">Set();</span>
    <span class="s1">const potential_conflicts = [];</span>

    <span class="s3">for </span><span class="s1">(const defun of defuns) {</span>
        <span class="s1">const fname_def = defun.name.definition();</span>
        <span class="s1">const found_self_ref_in_other_defuns = defuns.some(</span>
            <span class="s1">d =&gt; d !== defun &amp;&amp; d.enclosed.indexOf(fname_def) !== -</span><span class="s4">1</span>
        <span class="s1">);</span>

        <span class="s3">for </span><span class="s1">(const def of defun.enclosed) {</span>
            <span class="s3">if </span><span class="s1">(</span>
                <span class="s1">def.fixed === </span><span class="s3">false</span>
                <span class="s1">|| def === fname_def</span>
                <span class="s1">|| def.scope.get_defun_scope() !== parent</span>
            <span class="s1">) {</span>
                <span class="s3">continue</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s0">// defun is hoisted, so always safe</span>
            <span class="s3">if </span><span class="s1">(</span>
                <span class="s1">def.assignments === </span><span class="s4">0</span>
                <span class="s1">&amp;&amp; def.orig.length === </span><span class="s4">1</span>
                <span class="s1">&amp;&amp; def.orig[</span><span class="s4">0</span><span class="s1">] </span><span class="s3">instanceof </span><span class="s1">AST_SymbolDefun</span>
            <span class="s1">) {</span>
                <span class="s3">continue</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s3">if </span><span class="s1">(found_self_ref_in_other_defuns) {</span>
                <span class="s1">def.fixed = </span><span class="s3">false</span><span class="s1">;</span>
                <span class="s3">continue</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s0">// for the slower checks below this loop</span>
            <span class="s1">potential_conflicts.push({ defun, def, fname_def });</span>
            <span class="s1">symbols_of_interest.add(def.id);</span>
            <span class="s1">symbols_of_interest.add(fname_def.id);</span>
            <span class="s1">defuns_of_interest.add(defun);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">// linearize all symbols, and locate defs that are read after the defun</span>
    <span class="s3">if </span><span class="s1">(potential_conflicts.length) {</span>
        <span class="s0">// All &quot;symbols of interest&quot;, that is, defuns or defs, that we found.</span>
        <span class="s0">// These are placed in order so we can check which is after which.</span>
        <span class="s1">const found_symbols = [];</span>
        <span class="s0">// Indices of `found_symbols` which are writes</span>
        <span class="s1">const found_symbol_writes = </span><span class="s3">new </span><span class="s1">Set();</span>
        <span class="s0">// Defun ranges are recorded because we don't care if a function uses the def internally</span>
        <span class="s1">const defun_ranges = </span><span class="s3">new </span><span class="s1">Map();</span>

        <span class="s1">let tw;</span>
        <span class="s1">parent.walk((tw = </span><span class="s3">new </span><span class="s1">TreeWalker((node, descend) =&gt; {</span>
            <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Defun &amp;&amp; defuns_of_interest.has(node)) {</span>
                <span class="s1">const start = found_symbols.length;</span>
                <span class="s1">descend();</span>
                <span class="s1">const end = found_symbols.length;</span>

                <span class="s1">defun_ranges.set(node, { start, end });</span>
                <span class="s3">return true</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">// if we found a defun on the list, mark IN_DEFUN=id and descend</span>

            <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Symbol &amp;&amp; node.thedef) {</span>
                <span class="s1">const id = node.definition().id;</span>
                <span class="s3">if </span><span class="s1">(symbols_of_interest.has(id)) {</span>
                    <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_SymbolDeclaration || is_lhs(node, tw)) {</span>
                        <span class="s1">found_symbol_writes.add(found_symbols.length);</span>
                    <span class="s1">}</span>
                    <span class="s1">found_symbols.push(id);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">})));</span>

        <span class="s3">for </span><span class="s1">(const { def, defun, fname_def } of potential_conflicts) {</span>
            <span class="s1">const defun_range = defun_ranges.get(defun);</span>

            <span class="s0">// find the index in `found_symbols`, with some special rules:</span>
            <span class="s1">const find = (sym_id, starting_at = </span><span class="s4">0</span><span class="s1">, must_be_write = </span><span class="s3">false</span><span class="s1">) =&gt; {</span>
                <span class="s1">let index = starting_at;</span>

                <span class="s3">for </span><span class="s1">(;;) {</span>
                    <span class="s1">index = found_symbols.indexOf(sym_id, index);</span>

                    <span class="s3">if </span><span class="s1">(index === -</span><span class="s4">1</span><span class="s1">) {</span>
                        <span class="s3">break</span><span class="s1">;</span>
                    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(index &gt;= defun_range.start &amp;&amp; index &lt; defun_range.end) {</span>
                        <span class="s1">index = defun_range.end;</span>
                        <span class="s3">continue</span><span class="s1">;</span>
                    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(must_be_write &amp;&amp; !found_symbol_writes.has(index)) {</span>
                        <span class="s1">index++;</span>
                        <span class="s3">continue</span><span class="s1">;</span>
                    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                        <span class="s3">break</span><span class="s1">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>

                <span class="s3">return </span><span class="s1">index;</span>
            <span class="s1">};</span>

            <span class="s1">const read_defun_at = find(fname_def.id);</span>
            <span class="s1">const wrote_def_at = find(def.id, read_defun_at + </span><span class="s4">1</span><span class="s1">, </span><span class="s3">true</span><span class="s1">);</span>

            <span class="s1">const wrote_def_after_reading_defun = read_defun_at != -</span><span class="s4">1 </span><span class="s1">&amp;&amp; wrote_def_at != -</span><span class="s4">1 </span><span class="s1">&amp;&amp; wrote_def_at &gt; read_defun_at;</span>

            <span class="s3">if </span><span class="s1">(wrote_def_after_reading_defun) {</span>
                <span class="s1">def.fixed = </span><span class="s3">false</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">def_reduce_vars(AST_Lambda, mark_lambda);</span>

<span class="s1">def_reduce_vars(AST_Do, </span><span class="s3">function</span><span class="s1">(tw, descend, compressor) {</span>
    <span class="s1">reset_block_variables(compressor, </span><span class="s3">this</span><span class="s1">);</span>
    <span class="s1">const saved_loop = tw.in_loop;</span>
    <span class="s1">tw.in_loop = </span><span class="s3">this</span><span class="s1">;</span>
    <span class="s1">push(tw);</span>
    <span class="s3">this</span><span class="s1">.body.walk(tw);</span>
    <span class="s3">if </span><span class="s1">(has_break_or_continue(</span><span class="s3">this</span><span class="s1">)) {</span>
        <span class="s1">pop(tw);</span>
        <span class="s1">push(tw);</span>
    <span class="s1">}</span>
    <span class="s3">this</span><span class="s1">.condition.walk(tw);</span>
    <span class="s1">pop(tw);</span>
    <span class="s1">tw.in_loop = saved_loop;</span>
    <span class="s3">return true</span><span class="s1">;</span>
<span class="s1">});</span>

<span class="s1">def_reduce_vars(AST_For, </span><span class="s3">function</span><span class="s1">(tw, descend, compressor) {</span>
    <span class="s1">reset_block_variables(compressor, </span><span class="s3">this</span><span class="s1">);</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.init) </span><span class="s3">this</span><span class="s1">.init.walk(tw);</span>
    <span class="s1">const saved_loop = tw.in_loop;</span>
    <span class="s1">tw.in_loop = </span><span class="s3">this</span><span class="s1">;</span>
    <span class="s1">push(tw);</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.condition) </span><span class="s3">this</span><span class="s1">.condition.walk(tw);</span>
    <span class="s3">this</span><span class="s1">.body.walk(tw);</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.step) {</span>
        <span class="s3">if </span><span class="s1">(has_break_or_continue(</span><span class="s3">this</span><span class="s1">)) {</span>
            <span class="s1">pop(tw);</span>
            <span class="s1">push(tw);</span>
        <span class="s1">}</span>
        <span class="s3">this</span><span class="s1">.step.walk(tw);</span>
    <span class="s1">}</span>
    <span class="s1">pop(tw);</span>
    <span class="s1">tw.in_loop = saved_loop;</span>
    <span class="s3">return true</span><span class="s1">;</span>
<span class="s1">});</span>

<span class="s1">def_reduce_vars(AST_ForIn, </span><span class="s3">function</span><span class="s1">(tw, descend, compressor) {</span>
    <span class="s1">reset_block_variables(compressor, </span><span class="s3">this</span><span class="s1">);</span>
    <span class="s1">suppress(</span><span class="s3">this</span><span class="s1">.init);</span>
    <span class="s3">this</span><span class="s1">.object.walk(tw);</span>
    <span class="s1">const saved_loop = tw.in_loop;</span>
    <span class="s1">tw.in_loop = </span><span class="s3">this</span><span class="s1">;</span>
    <span class="s1">push(tw);</span>
    <span class="s3">this</span><span class="s1">.body.walk(tw);</span>
    <span class="s1">pop(tw);</span>
    <span class="s1">tw.in_loop = saved_loop;</span>
    <span class="s3">return true</span><span class="s1">;</span>
<span class="s1">});</span>

<span class="s1">def_reduce_vars(AST_If, </span><span class="s3">function</span><span class="s1">(tw) {</span>
    <span class="s3">this</span><span class="s1">.condition.walk(tw);</span>
    <span class="s1">push(tw);</span>
    <span class="s3">this</span><span class="s1">.body.walk(tw);</span>
    <span class="s1">pop(tw);</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.alternative) {</span>
        <span class="s1">push(tw);</span>
        <span class="s3">this</span><span class="s1">.alternative.walk(tw);</span>
        <span class="s1">pop(tw);</span>
    <span class="s1">}</span>
    <span class="s3">return true</span><span class="s1">;</span>
<span class="s1">});</span>

<span class="s1">def_reduce_vars(AST_LabeledStatement, </span><span class="s3">function</span><span class="s1">(tw) {</span>
    <span class="s1">push(tw);</span>
    <span class="s3">this</span><span class="s1">.body.walk(tw);</span>
    <span class="s1">pop(tw);</span>
    <span class="s3">return true</span><span class="s1">;</span>
<span class="s1">});</span>

<span class="s1">def_reduce_vars(AST_SymbolCatch, </span><span class="s3">function</span><span class="s1">() {</span>
    <span class="s3">this</span><span class="s1">.definition().fixed = </span><span class="s3">false</span><span class="s1">;</span>
<span class="s1">});</span>

<span class="s1">def_reduce_vars(AST_SymbolRef, </span><span class="s3">function</span><span class="s1">(tw, descend, compressor) {</span>
    <span class="s3">var </span><span class="s1">d = </span><span class="s3">this</span><span class="s1">.definition();</span>
    <span class="s1">d.references.push(</span><span class="s3">this</span><span class="s1">);</span>
    <span class="s3">if </span><span class="s1">(d.references.length == </span><span class="s4">1</span>
        <span class="s1">&amp;&amp; !d.fixed</span>
        <span class="s1">&amp;&amp; d.orig[</span><span class="s4">0</span><span class="s1">] </span><span class="s3">instanceof </span><span class="s1">AST_SymbolDefun) {</span>
        <span class="s1">tw.loop_ids.set(d.id, tw.in_loop);</span>
    <span class="s1">}</span>
    <span class="s3">var </span><span class="s1">fixed_value;</span>
    <span class="s3">if </span><span class="s1">(d.fixed === undefined || !safe_to_read(tw, d)) {</span>
        <span class="s1">d.fixed = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(d.fixed) {</span>
        <span class="s1">fixed_value = </span><span class="s3">this</span><span class="s1">.fixed_value();</span>
        <span class="s3">if </span><span class="s1">(</span>
            <span class="s1">fixed_value </span><span class="s3">instanceof </span><span class="s1">AST_Lambda</span>
            <span class="s1">&amp;&amp; is_recursive_ref(tw, d)</span>
        <span class="s1">) {</span>
            <span class="s1">d.recursive_refs++;</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(fixed_value</span>
            <span class="s1">&amp;&amp; !compressor.exposed(d)</span>
            <span class="s1">&amp;&amp; ref_once(tw, compressor, d)</span>
        <span class="s1">) {</span>
            <span class="s1">d.single_use =</span>
                <span class="s1">fixed_value </span><span class="s3">instanceof </span><span class="s1">AST_Lambda &amp;&amp; !fixed_value.pinned()</span>
                <span class="s1">|| fixed_value </span><span class="s3">instanceof </span><span class="s1">AST_Class</span>
                <span class="s1">|| d.scope === </span><span class="s3">this</span><span class="s1">.scope &amp;&amp; fixed_value.is_constant_expression();</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">d.single_use = </span><span class="s3">false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(is_modified(compressor, tw, </span><span class="s3">this</span><span class="s1">, fixed_value, </span><span class="s4">0</span><span class="s1">, is_immutable(fixed_value))) {</span>
            <span class="s3">if </span><span class="s1">(d.single_use) {</span>
                <span class="s1">d.single_use = </span><span class="s2">&quot;m&quot;</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s1">d.fixed = </span><span class="s3">false</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">mark_escaped(tw, d, </span><span class="s3">this</span><span class="s1">.scope, </span><span class="s3">this</span><span class="s1">, fixed_value, </span><span class="s4">0</span><span class="s1">, </span><span class="s4">1</span><span class="s1">);</span>
<span class="s1">});</span>

<span class="s1">def_reduce_vars(AST_Toplevel, </span><span class="s3">function</span><span class="s1">(tw, descend, compressor) {</span>
    <span class="s3">this</span><span class="s1">.globals.forEach(</span><span class="s3">function</span><span class="s1">(def) {</span>
        <span class="s1">reset_def(compressor, def);</span>
    <span class="s1">});</span>
    <span class="s1">reset_variables(tw, compressor, </span><span class="s3">this</span><span class="s1">);</span>
    <span class="s1">descend();</span>
    <span class="s1">handle_defined_after_hoist(</span><span class="s3">this</span><span class="s1">);</span>
    <span class="s3">return true</span><span class="s1">;</span>
<span class="s1">});</span>

<span class="s1">def_reduce_vars(AST_Try, </span><span class="s3">function</span><span class="s1">(tw, descend, compressor) {</span>
    <span class="s1">reset_block_variables(compressor, </span><span class="s3">this</span><span class="s1">);</span>
    <span class="s1">push(tw);</span>
    <span class="s3">this</span><span class="s1">.body.walk(tw);</span>
    <span class="s1">pop(tw);</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.bcatch) {</span>
        <span class="s1">push(tw);</span>
        <span class="s3">this</span><span class="s1">.bcatch.walk(tw);</span>
        <span class="s1">pop(tw);</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.bfinally) </span><span class="s3">this</span><span class="s1">.bfinally.walk(tw);</span>
    <span class="s3">return true</span><span class="s1">;</span>
<span class="s1">});</span>

<span class="s1">def_reduce_vars(AST_Unary, </span><span class="s3">function</span><span class="s1">(tw) {</span>
    <span class="s3">var </span><span class="s1">node = </span><span class="s3">this</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s1">(node.operator !== </span><span class="s2">&quot;++&quot; </span><span class="s1">&amp;&amp; node.operator !== </span><span class="s2">&quot;--&quot;</span><span class="s1">) </span><span class="s3">return</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">exp = node.expression;</span>
    <span class="s3">if </span><span class="s1">(!(exp </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef)) </span><span class="s3">return</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">def = exp.definition();</span>
    <span class="s3">var </span><span class="s1">safe = safe_to_assign(tw, def, exp.scope, </span><span class="s3">true</span><span class="s1">);</span>
    <span class="s1">def.assignments++;</span>
    <span class="s3">if </span><span class="s1">(!safe) </span><span class="s3">return</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">fixed = def.fixed;</span>
    <span class="s3">if </span><span class="s1">(!fixed) </span><span class="s3">return</span><span class="s1">;</span>
    <span class="s1">def.references.push(exp);</span>
    <span class="s1">def.chained = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">def.fixed = </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">make_node(AST_Binary, node, {</span>
            <span class="s1">operator: node.operator.slice(</span><span class="s4">0</span><span class="s1">, -</span><span class="s4">1</span><span class="s1">),</span>
            <span class="s1">left: make_node(AST_UnaryPrefix, node, {</span>
                <span class="s1">operator: </span><span class="s2">&quot;+&quot;</span><span class="s1">,</span>
                <span class="s1">expression: fixed </span><span class="s3">instanceof </span><span class="s1">AST_Node ? fixed : fixed()</span>
            <span class="s1">}),</span>
            <span class="s1">right: make_node(AST_Number, node, {</span>
                <span class="s1">value: </span><span class="s4">1</span>
            <span class="s1">})</span>
        <span class="s1">});</span>
    <span class="s1">};</span>
    <span class="s1">mark(tw, def, </span><span class="s3">true</span><span class="s1">);</span>
    <span class="s3">return true</span><span class="s1">;</span>
<span class="s1">});</span>

<span class="s1">def_reduce_vars(AST_VarDef, </span><span class="s3">function</span><span class="s1">(tw, descend) {</span>
    <span class="s3">var </span><span class="s1">node = </span><span class="s3">this</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s1">(node.name </span><span class="s3">instanceof </span><span class="s1">AST_Destructuring) {</span>
        <span class="s1">suppress(node.name);</span>
        <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">var </span><span class="s1">d = node.name.definition();</span>
    <span class="s3">if </span><span class="s1">(node.value) {</span>
        <span class="s3">if </span><span class="s1">(safe_to_assign(tw, d, node.name.scope, node.value)) {</span>
            <span class="s1">d.fixed = </span><span class="s3">function</span><span class="s1">() {</span>
                <span class="s3">return </span><span class="s1">node.value;</span>
            <span class="s1">};</span>
            <span class="s1">tw.loop_ids.set(d.id, tw.in_loop);</span>
            <span class="s1">mark(tw, d, </span><span class="s3">false</span><span class="s1">);</span>
            <span class="s1">descend();</span>
            <span class="s1">mark(tw, d, </span><span class="s3">true</span><span class="s1">);</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">d.fixed = </span><span class="s3">false</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">});</span>

<span class="s1">def_reduce_vars(AST_While, </span><span class="s3">function</span><span class="s1">(tw, descend, compressor) {</span>
    <span class="s1">reset_block_variables(compressor, </span><span class="s3">this</span><span class="s1">);</span>
    <span class="s1">const saved_loop = tw.in_loop;</span>
    <span class="s1">tw.in_loop = </span><span class="s3">this</span><span class="s1">;</span>
    <span class="s1">push(tw);</span>
    <span class="s1">descend();</span>
    <span class="s1">pop(tw);</span>
    <span class="s1">tw.in_loop = saved_loop;</span>
    <span class="s3">return true</span><span class="s1">;</span>
<span class="s1">});</span>
</pre>
</body>
</html>
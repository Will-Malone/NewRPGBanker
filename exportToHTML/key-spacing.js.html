<html>
<head>
<title>key-spacing.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6a8759;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
key-spacing.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s2">var </span><span class="s1">__createBinding = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__createBinding) || (Object.create ? (</span><span class="s2">function</span><span class="s1">(o, m, k, k2) {</span>
    <span class="s2">if </span><span class="s1">(k2 === undefined) k2 = k;</span>
    <span class="s2">var </span><span class="s1">desc = Object.getOwnPropertyDescriptor(m, k);</span>
    <span class="s2">if </span><span class="s1">(!desc || (</span><span class="s0">&quot;get&quot; </span><span class="s2">in </span><span class="s1">desc ? !m.__esModule : desc.writable || desc.configurable)) {</span>
      <span class="s1">desc = { enumerable: </span><span class="s2">true</span><span class="s1">, get: </span><span class="s2">function</span><span class="s1">() { </span><span class="s2">return </span><span class="s1">m[k]; } };</span>
    <span class="s1">}</span>
    <span class="s1">Object.defineProperty(o, k2, desc);</span>
<span class="s1">}) : (</span><span class="s2">function</span><span class="s1">(o, m, k, k2) {</span>
    <span class="s2">if </span><span class="s1">(k2 === undefined) k2 = k;</span>
    <span class="s1">o[k2] = m[k];</span>
<span class="s1">}));</span>
<span class="s2">var </span><span class="s1">__setModuleDefault = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__setModuleDefault) || (Object.create ? (</span><span class="s2">function</span><span class="s1">(o, v) {</span>
    <span class="s1">Object.defineProperty(o, </span><span class="s0">&quot;default&quot;</span><span class="s1">, { enumerable: </span><span class="s2">true</span><span class="s1">, value: v });</span>
<span class="s1">}) : </span><span class="s2">function</span><span class="s1">(o, v) {</span>
    <span class="s1">o[</span><span class="s0">&quot;default&quot;</span><span class="s1">] = v;</span>
<span class="s1">});</span>
<span class="s2">var </span><span class="s1">__importStar = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__importStar) || </span><span class="s2">function </span><span class="s1">(mod) {</span>
    <span class="s2">if </span><span class="s1">(mod &amp;&amp; mod.__esModule) </span><span class="s2">return </span><span class="s1">mod;</span>
    <span class="s2">var </span><span class="s1">result = {};</span>
    <span class="s2">if </span><span class="s1">(mod != </span><span class="s2">null</span><span class="s1">) </span><span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">k </span><span class="s2">in </span><span class="s1">mod) </span><span class="s2">if </span><span class="s1">(k !== </span><span class="s0">&quot;default&quot; </span><span class="s1">&amp;&amp; Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);</span>
    <span class="s1">__setModuleDefault(result, mod);</span>
    <span class="s2">return </span><span class="s1">result;</span>
<span class="s1">};</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, { value: </span><span class="s2">true </span><span class="s1">});</span>
<span class="s1">const utils_1 = require(</span><span class="s0">&quot;@typescript-eslint/utils&quot;</span><span class="s1">);</span>
<span class="s1">const util = __importStar(require(</span><span class="s0">&quot;../util&quot;</span><span class="s1">));</span>
<span class="s1">const getESLintCoreRule_1 = require(</span><span class="s0">&quot;../util/getESLintCoreRule&quot;</span><span class="s1">);</span>
<span class="s1">const baseRule = (</span><span class="s3">0</span><span class="s1">, getESLintCoreRule_1.getESLintCoreRule)(</span><span class="s0">'key-spacing'</span><span class="s1">);</span>
<span class="s4">// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment</span>
<span class="s1">const baseSchema = Array.isArray(baseRule.meta.schema)</span>
    <span class="s1">? baseRule.meta.schema[</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s1">: baseRule.meta.schema;</span>
<span class="s4">/** 
 * TODO: replace with native .at() once Node 14 stops being supported 
 */</span>
<span class="s2">function </span><span class="s1">at(arr, position) {</span>
    <span class="s2">if </span><span class="s1">(position &lt; </span><span class="s3">0</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">arr[arr.length + position];</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">arr[position];</span>
<span class="s1">}</span>
<span class="s1">exports.</span><span class="s2">default </span><span class="s1">= util.createRule({</span>
    <span class="s1">name: </span><span class="s0">'key-spacing'</span><span class="s1">,</span>
    <span class="s1">meta: {</span>
        <span class="s1">type: </span><span class="s0">'layout'</span><span class="s1">,</span>
        <span class="s1">docs: {</span>
            <span class="s1">description: </span><span class="s0">'Enforce consistent spacing between property names and type annotations in types and interfaces'</span><span class="s1">,</span>
            <span class="s1">recommended: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">extendsBaseRule: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">},</span>
        <span class="s1">fixable: </span><span class="s0">'whitespace'</span><span class="s1">,</span>
        <span class="s1">hasSuggestions: baseRule.meta.hasSuggestions,</span>
        <span class="s1">schema: [baseSchema],</span>
        <span class="s1">messages: baseRule.meta.messages,</span>
    <span class="s1">},</span>
    <span class="s1">defaultOptions: [{}],</span>
    <span class="s1">create(context, [options]) {</span>
        <span class="s1">const sourceCode = context.getSourceCode();</span>
        <span class="s1">const baseRules = baseRule.create(context);</span>
        <span class="s4">/** 
         * @returns the column of the position after converting all unicode characters in the line to 1 char length 
         */</span>
        <span class="s2">function </span><span class="s1">adjustedColumn(position) {</span>
            <span class="s1">const line = position.line - </span><span class="s3">1</span><span class="s1">; </span><span class="s4">// position.line is 1-indexed</span>
            <span class="s2">return </span><span class="s1">util.getStringLength(at(sourceCode.lines, line).slice(</span><span class="s3">0</span><span class="s1">, position.column));</span>
        <span class="s1">}</span>
        <span class="s4">/** 
         * Starting from the given a node (a property.key node here) looks forward 
         * until it finds the last token before a colon punctuator and returns it. 
         */</span>
        <span class="s2">function </span><span class="s1">getLastTokenBeforeColon(node) {</span>
            <span class="s1">const colonToken = sourceCode.getTokenAfter(node, util.isColonToken);</span>
            <span class="s2">return </span><span class="s1">sourceCode.getTokenBefore(colonToken);</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">isKeyTypeNode(node) {</span>
            <span class="s2">return </span><span class="s1">((node.type === utils_1.AST_NODE_TYPES.TSPropertySignature ||</span>
                <span class="s1">node.type === utils_1.AST_NODE_TYPES.TSIndexSignature ||</span>
                <span class="s1">node.type === utils_1.AST_NODE_TYPES.PropertyDefinition) &amp;&amp;</span>
                <span class="s1">!!node.typeAnnotation);</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">isApplicable(node) {</span>
            <span class="s2">return </span><span class="s1">(isKeyTypeNode(node) &amp;&amp;</span>
                <span class="s1">node.typeAnnotation.loc.start.line === node.loc.end.line);</span>
        <span class="s1">}</span>
        <span class="s4">/** 
         * To handle index signatures, to get the whole text for the parameters 
         */</span>
        <span class="s2">function </span><span class="s1">getKeyText(node) {</span>
            <span class="s2">if </span><span class="s1">(node.type !== utils_1.AST_NODE_TYPES.TSIndexSignature) {</span>
                <span class="s2">return </span><span class="s1">sourceCode.getText(node.key);</span>
            <span class="s1">}</span>
            <span class="s1">const code = sourceCode.getText(node);</span>
            <span class="s2">return </span><span class="s1">code.slice(</span><span class="s3">0</span><span class="s1">, sourceCode.getTokenAfter(at(node.parameters, -</span><span class="s3">1</span><span class="s1">), util.isClosingBracketToken).range[</span><span class="s3">1</span><span class="s1">] - node.range[</span><span class="s3">0</span><span class="s1">]);</span>
        <span class="s1">}</span>
        <span class="s4">/** 
         * To handle index signatures, be able to get the end position of the parameters 
         */</span>
        <span class="s2">function </span><span class="s1">getKeyLocEnd(node) {</span>
            <span class="s2">return </span><span class="s1">getLastTokenBeforeColon(node.type !== utils_1.AST_NODE_TYPES.TSIndexSignature</span>
                <span class="s1">? node.key</span>
                <span class="s1">: at(node.parameters, -</span><span class="s3">1</span><span class="s1">)).loc.end;</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">checkBeforeColon(node, expectedWhitespaceBeforeColon, mode) {</span>
            <span class="s1">const { typeAnnotation } = node;</span>
            <span class="s1">const colon = typeAnnotation.loc.start.column;</span>
            <span class="s1">const keyEnd = getKeyLocEnd(node);</span>
            <span class="s1">const difference = colon - keyEnd.column - expectedWhitespaceBeforeColon;</span>
            <span class="s2">if </span><span class="s1">(mode === </span><span class="s0">'strict' </span><span class="s1">? difference : difference &lt; </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s1">context.report({</span>
                    <span class="s1">node,</span>
                    <span class="s1">messageId: difference &gt; </span><span class="s3">0 </span><span class="s1">? </span><span class="s0">'extraKey' </span><span class="s1">: </span><span class="s0">'missingKey'</span><span class="s1">,</span>
                    <span class="s1">fix: fixer =&gt; {</span>
                        <span class="s2">if </span><span class="s1">(difference &gt; </span><span class="s3">0</span><span class="s1">) {</span>
                            <span class="s2">return </span><span class="s1">fixer.removeRange([</span>
                                <span class="s1">typeAnnotation.range[</span><span class="s3">0</span><span class="s1">] - difference,</span>
                                <span class="s1">typeAnnotation.range[</span><span class="s3">0</span><span class="s1">],</span>
                            <span class="s1">]);</span>
                        <span class="s1">}</span>
                        <span class="s2">else </span><span class="s1">{</span>
                            <span class="s2">return </span><span class="s1">fixer.insertTextBefore(typeAnnotation, </span><span class="s0">' '</span><span class="s1">.repeat(-difference));</span>
                        <span class="s1">}</span>
                    <span class="s1">},</span>
                    <span class="s1">data: {</span>
                        <span class="s1">computed: </span><span class="s0">''</span><span class="s1">,</span>
                        <span class="s1">key: getKeyText(node),</span>
                    <span class="s1">},</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">checkAfterColon(node, expectedWhitespaceAfterColon, mode) {</span>
            <span class="s1">const { typeAnnotation } = node;</span>
            <span class="s1">const colon = typeAnnotation.loc.start.column;</span>
            <span class="s1">const typeStart = typeAnnotation.typeAnnotation.loc.start.column;</span>
            <span class="s1">const difference = typeStart - colon - </span><span class="s3">1 </span><span class="s1">- expectedWhitespaceAfterColon;</span>
            <span class="s2">if </span><span class="s1">(mode === </span><span class="s0">'strict' </span><span class="s1">? difference : difference &lt; </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s1">context.report({</span>
                    <span class="s1">node,</span>
                    <span class="s1">messageId: difference &gt; </span><span class="s3">0 </span><span class="s1">? </span><span class="s0">'extraValue' </span><span class="s1">: </span><span class="s0">'missingValue'</span><span class="s1">,</span>
                    <span class="s1">fix: fixer =&gt; {</span>
                        <span class="s2">if </span><span class="s1">(difference &gt; </span><span class="s3">0</span><span class="s1">) {</span>
                            <span class="s2">return </span><span class="s1">fixer.removeRange([</span>
                                <span class="s1">typeAnnotation.typeAnnotation.range[</span><span class="s3">0</span><span class="s1">] - difference,</span>
                                <span class="s1">typeAnnotation.typeAnnotation.range[</span><span class="s3">0</span><span class="s1">],</span>
                            <span class="s1">]);</span>
                        <span class="s1">}</span>
                        <span class="s2">else </span><span class="s1">{</span>
                            <span class="s2">return </span><span class="s1">fixer.insertTextBefore(typeAnnotation.typeAnnotation, </span><span class="s0">' '</span><span class="s1">.repeat(-difference));</span>
                        <span class="s1">}</span>
                    <span class="s1">},</span>
                    <span class="s1">data: {</span>
                        <span class="s1">computed: </span><span class="s0">''</span><span class="s1">,</span>
                        <span class="s1">key: getKeyText(node),</span>
                    <span class="s1">},</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s4">// adapted from  https://github.com/eslint/eslint/blob/ba74253e8bd63e9e163bbee0540031be77e39253/lib/rules/key-spacing.js#L356</span>
        <span class="s2">function </span><span class="s1">continuesAlignGroup(lastMember, candidate) {</span>
            <span class="s1">const groupEndLine = lastMember.loc.start.line;</span>
            <span class="s1">const candidateValueStartLine = (isKeyTypeNode(candidate) ? candidate.typeAnnotation : candidate).loc.start.line;</span>
            <span class="s2">if </span><span class="s1">(candidateValueStartLine === groupEndLine) {</span>
                <span class="s2">return false</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(candidateValueStartLine - groupEndLine === </span><span class="s3">1</span><span class="s1">) {</span>
                <span class="s2">return true</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s4">/* 
             * Check that the first comment is adjacent to the end of the group, the 
             * last comment is adjacent to the candidate property, and that successive 
             * comments are adjacent to each other. 
             */</span>
            <span class="s1">const leadingComments = sourceCode.getCommentsBefore(candidate);</span>
            <span class="s2">if </span><span class="s1">(leadingComments.length &amp;&amp;</span>
                <span class="s1">leadingComments[</span><span class="s3">0</span><span class="s1">].loc.start.line - groupEndLine &lt;= </span><span class="s3">1 </span><span class="s1">&amp;&amp;</span>
                <span class="s1">candidateValueStartLine - at(leadingComments, -</span><span class="s3">1</span><span class="s1">).loc.end.line &lt;= </span><span class="s3">1</span><span class="s1">) {</span>
                <span class="s2">for </span><span class="s1">(let i = </span><span class="s3">1</span><span class="s1">; i &lt; leadingComments.length; i++) {</span>
                    <span class="s2">if </span><span class="s1">(leadingComments[i].loc.start.line -</span>
                        <span class="s1">leadingComments[i - </span><span class="s3">1</span><span class="s1">].loc.end.line &gt;</span>
                        <span class="s3">1</span><span class="s1">) {</span>
                        <span class="s2">return false</span><span class="s1">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">return true</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">checkAlignGroup(group) {</span>
            <span class="s2">var </span><span class="s1">_a, _b, _c, _d, _e, _f, _g, _h;</span>
            <span class="s1">let alignColumn = </span><span class="s3">0</span><span class="s1">;</span>
            <span class="s1">const align = (_d = (</span><span class="s2">typeof </span><span class="s1">options.align === </span><span class="s0">'object'</span>
                <span class="s1">? options.align.on</span>
                <span class="s1">: </span><span class="s2">typeof </span><span class="s1">((_a = options.multiLine) === </span><span class="s2">null </span><span class="s1">|| _a === </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _a.align) === </span><span class="s0">'object'</span>
                    <span class="s1">? options.multiLine.align.on</span>
                    <span class="s1">: (_c = (_b = options.multiLine) === </span><span class="s2">null </span><span class="s1">|| _b === </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _b.align) !== </span><span class="s2">null </span><span class="s1">&amp;&amp; _c !== </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? _c : options.align)) !== </span><span class="s2">null </span><span class="s1">&amp;&amp; _d !== </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? _d : </span><span class="s0">'colon'</span><span class="s1">;</span>
            <span class="s1">const beforeColon = (_e = (</span><span class="s2">typeof </span><span class="s1">options.align === </span><span class="s0">'object'</span>
                <span class="s1">? options.align.beforeColon</span>
                <span class="s1">: options.multiLine</span>
                    <span class="s1">? </span><span class="s2">typeof </span><span class="s1">options.multiLine.align === </span><span class="s0">'object'</span>
                        <span class="s1">? options.multiLine.align.beforeColon</span>
                        <span class="s1">: options.multiLine.beforeColon</span>
                    <span class="s1">: options.beforeColon)) !== </span><span class="s2">null </span><span class="s1">&amp;&amp; _e !== </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? _e : </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s1">const expectedWhitespaceBeforeColon = beforeColon ? </span><span class="s3">1 </span><span class="s1">: </span><span class="s3">0</span><span class="s1">;</span>
            <span class="s1">const afterColon = (_f = (</span><span class="s2">typeof </span><span class="s1">options.align === </span><span class="s0">'object'</span>
                <span class="s1">? options.align.afterColon</span>
                <span class="s1">: options.multiLine</span>
                    <span class="s1">? </span><span class="s2">typeof </span><span class="s1">options.multiLine.align === </span><span class="s0">'object'</span>
                        <span class="s1">? options.multiLine.align.afterColon</span>
                        <span class="s1">: options.multiLine.afterColon</span>
                    <span class="s1">: options.afterColon)) !== </span><span class="s2">null </span><span class="s1">&amp;&amp; _f !== </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? _f : </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">const expectedWhitespaceAfterColon = afterColon ? </span><span class="s3">1 </span><span class="s1">: </span><span class="s3">0</span><span class="s1">;</span>
            <span class="s1">const mode = (_h = (</span><span class="s2">typeof </span><span class="s1">options.align === </span><span class="s0">'object'</span>
                <span class="s1">? options.align.mode</span>
                <span class="s1">: options.multiLine</span>
                    <span class="s1">? </span><span class="s2">typeof </span><span class="s1">options.multiLine.align === </span><span class="s0">'object'</span>
                        <span class="s1">? </span><span class="s4">// same behavior as in original rule</span>
                            <span class="s1">(_g = options.multiLine.align.mode) !== </span><span class="s2">null </span><span class="s1">&amp;&amp; _g !== </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? _g : options.multiLine.mode</span>
                        <span class="s1">: options.multiLine.mode</span>
                    <span class="s1">: options.mode)) !== </span><span class="s2">null </span><span class="s1">&amp;&amp; _h !== </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? _h : </span><span class="s0">'strict'</span><span class="s1">;</span>
            <span class="s2">for </span><span class="s1">(const node of group) {</span>
                <span class="s2">if </span><span class="s1">(isKeyTypeNode(node)) {</span>
                    <span class="s1">const keyEnd = adjustedColumn(getKeyLocEnd(node));</span>
                    <span class="s1">alignColumn = Math.max(alignColumn, align === </span><span class="s0">'colon'</span>
                        <span class="s1">? keyEnd + expectedWhitespaceBeforeColon</span>
                        <span class="s1">: keyEnd +</span>
                            <span class="s0">':'</span><span class="s1">.length +</span>
                            <span class="s1">expectedWhitespaceAfterColon +</span>
                            <span class="s1">expectedWhitespaceBeforeColon);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">for </span><span class="s1">(const node of group) {</span>
                <span class="s2">if </span><span class="s1">(!isApplicable(node)) {</span>
                    <span class="s2">continue</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s1">const { typeAnnotation } = node;</span>
                <span class="s1">const toCheck = align === </span><span class="s0">'colon' </span><span class="s1">? typeAnnotation : typeAnnotation.typeAnnotation;</span>
                <span class="s1">const difference = adjustedColumn(toCheck.loc.start) - alignColumn;</span>
                <span class="s2">if </span><span class="s1">(difference) {</span>
                    <span class="s1">context.report({</span>
                        <span class="s1">node,</span>
                        <span class="s1">messageId: difference &gt; </span><span class="s3">0</span>
                            <span class="s1">? align === </span><span class="s0">'colon'</span>
                                <span class="s1">? </span><span class="s0">'extraKey'</span>
                                <span class="s1">: </span><span class="s0">'extraValue'</span>
                            <span class="s1">: align === </span><span class="s0">'colon'</span>
                                <span class="s1">? </span><span class="s0">'missingKey'</span>
                                <span class="s1">: </span><span class="s0">'missingValue'</span><span class="s1">,</span>
                        <span class="s1">fix: fixer =&gt; {</span>
                            <span class="s2">if </span><span class="s1">(difference &gt; </span><span class="s3">0</span><span class="s1">) {</span>
                                <span class="s2">return </span><span class="s1">fixer.removeRange([</span>
                                    <span class="s1">toCheck.range[</span><span class="s3">0</span><span class="s1">] - difference,</span>
                                    <span class="s1">toCheck.range[</span><span class="s3">0</span><span class="s1">],</span>
                                <span class="s1">]);</span>
                            <span class="s1">}</span>
                            <span class="s2">else </span><span class="s1">{</span>
                                <span class="s2">return </span><span class="s1">fixer.insertTextBefore(toCheck, </span><span class="s0">' '</span><span class="s1">.repeat(-difference));</span>
                            <span class="s1">}</span>
                        <span class="s1">},</span>
                        <span class="s1">data: {</span>
                            <span class="s1">computed: </span><span class="s0">''</span><span class="s1">,</span>
                            <span class="s1">key: getKeyText(node),</span>
                        <span class="s1">},</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(align === </span><span class="s0">'colon'</span><span class="s1">) {</span>
                    <span class="s1">checkAfterColon(node, expectedWhitespaceAfterColon, mode);</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">checkBeforeColon(node, expectedWhitespaceBeforeColon, mode);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">checkIndividualNode(node, { singleLine }) {</span>
            <span class="s2">var </span><span class="s1">_a, _b, _c;</span>
            <span class="s1">const beforeColon = (_a = (singleLine</span>
                <span class="s1">? options.singleLine</span>
                    <span class="s1">? options.singleLine.beforeColon</span>
                    <span class="s1">: options.beforeColon</span>
                <span class="s1">: options.multiLine</span>
                    <span class="s1">? options.multiLine.beforeColon</span>
                    <span class="s1">: options.beforeColon)) !== </span><span class="s2">null </span><span class="s1">&amp;&amp; _a !== </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? _a : </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s1">const expectedWhitespaceBeforeColon = beforeColon ? </span><span class="s3">1 </span><span class="s1">: </span><span class="s3">0</span><span class="s1">;</span>
            <span class="s1">const afterColon = (_b = (singleLine</span>
                <span class="s1">? options.singleLine</span>
                    <span class="s1">? options.singleLine.afterColon</span>
                    <span class="s1">: options.afterColon</span>
                <span class="s1">: options.multiLine</span>
                    <span class="s1">? options.multiLine.afterColon</span>
                    <span class="s1">: options.afterColon)) !== </span><span class="s2">null </span><span class="s1">&amp;&amp; _b !== </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? _b : </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">const expectedWhitespaceAfterColon = afterColon ? </span><span class="s3">1 </span><span class="s1">: </span><span class="s3">0</span><span class="s1">;</span>
            <span class="s1">const mode = (_c = (singleLine</span>
                <span class="s1">? options.singleLine</span>
                    <span class="s1">? options.singleLine.mode</span>
                    <span class="s1">: options.mode</span>
                <span class="s1">: options.multiLine</span>
                    <span class="s1">? options.multiLine.mode</span>
                    <span class="s1">: options.mode)) !== </span><span class="s2">null </span><span class="s1">&amp;&amp; _c !== </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? _c : </span><span class="s0">'strict'</span><span class="s1">;</span>
            <span class="s2">if </span><span class="s1">(isApplicable(node)) {</span>
                <span class="s1">checkBeforeColon(node, expectedWhitespaceBeforeColon, mode);</span>
                <span class="s1">checkAfterColon(node, expectedWhitespaceAfterColon, mode);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">validateBody(body) {</span>
            <span class="s2">var </span><span class="s1">_a;</span>
            <span class="s1">const isSingleLine = body.loc.start.line === body.loc.end.line;</span>
            <span class="s1">const members = body.type === utils_1.AST_NODE_TYPES.TSTypeLiteral ? body.members : body.body;</span>
            <span class="s1">let alignGroups = [];</span>
            <span class="s1">let unalignedElements = [];</span>
            <span class="s2">if </span><span class="s1">(options.align || ((_a = options.multiLine) === </span><span class="s2">null </span><span class="s1">|| _a === </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _a.align)) {</span>
                <span class="s1">let currentAlignGroup = [];</span>
                <span class="s1">alignGroups.push(currentAlignGroup);</span>
                <span class="s1">let prevNode = undefined;</span>
                <span class="s2">for </span><span class="s1">(const node of members) {</span>
                    <span class="s1">let prevAlignedNode = at(currentAlignGroup, -</span><span class="s3">1</span><span class="s1">);</span>
                    <span class="s2">if </span><span class="s1">(prevAlignedNode !== prevNode) {</span>
                        <span class="s1">prevAlignedNode = undefined;</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">(prevAlignedNode &amp;&amp; continuesAlignGroup(prevAlignedNode, node)) {</span>
                        <span class="s1">currentAlignGroup.push(node);</span>
                    <span class="s1">}</span>
                    <span class="s2">else if </span><span class="s1">((prevNode === </span><span class="s2">null </span><span class="s1">|| prevNode === </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: prevNode.loc.start.line) === node.loc.start.line) {</span>
                        <span class="s2">if </span><span class="s1">(prevAlignedNode) {</span>
                            <span class="s4">// Here, prevNode === prevAlignedNode === currentAlignGroup.at(-1)</span>
                            <span class="s1">unalignedElements.push(prevAlignedNode);</span>
                            <span class="s1">currentAlignGroup.pop();</span>
                        <span class="s1">}</span>
                        <span class="s1">unalignedElements.push(node);</span>
                    <span class="s1">}</span>
                    <span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">currentAlignGroup = [node];</span>
                        <span class="s1">alignGroups.push(currentAlignGroup);</span>
                    <span class="s1">}</span>
                    <span class="s1">prevNode = node;</span>
                <span class="s1">}</span>
                <span class="s1">unalignedElements = unalignedElements.concat(...alignGroups.filter(group =&gt; group.length === </span><span class="s3">1</span><span class="s1">));</span>
                <span class="s1">alignGroups = alignGroups.filter(group =&gt; group.length &gt;= </span><span class="s3">2</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">unalignedElements = members;</span>
            <span class="s1">}</span>
            <span class="s2">for </span><span class="s1">(const group of alignGroups) {</span>
                <span class="s1">checkAlignGroup(group);</span>
            <span class="s1">}</span>
            <span class="s2">for </span><span class="s1">(const node of unalignedElements) {</span>
                <span class="s1">checkIndividualNode(node, { singleLine: isSingleLine });</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">Object.assign(Object.assign({}, baseRules), { TSTypeLiteral: validateBody, TSInterfaceBody: validateBody, ClassBody: validateBody });</span>
    <span class="s1">},</span>
<span class="s1">});</span>
<span class="s4">//# sourceMappingURL=key-spacing.js.map</span></pre>
</body>
</html>
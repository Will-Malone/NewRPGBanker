<html>
<head>
<title>convert.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6a8759;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
convert.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s2">var </span><span class="s1">__createBinding = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__createBinding) || (Object.create ? (</span><span class="s2">function</span><span class="s1">(o, m, k, k2) {</span>
    <span class="s2">if </span><span class="s1">(k2 === undefined) k2 = k;</span>
    <span class="s2">var </span><span class="s1">desc = Object.getOwnPropertyDescriptor(m, k);</span>
    <span class="s2">if </span><span class="s1">(!desc || (</span><span class="s0">&quot;get&quot; </span><span class="s2">in </span><span class="s1">desc ? !m.__esModule : desc.writable || desc.configurable)) {</span>
      <span class="s1">desc = { enumerable: </span><span class="s2">true</span><span class="s1">, get: </span><span class="s2">function</span><span class="s1">() { </span><span class="s2">return </span><span class="s1">m[k]; } };</span>
    <span class="s1">}</span>
    <span class="s1">Object.defineProperty(o, k2, desc);</span>
<span class="s1">}) : (</span><span class="s2">function</span><span class="s1">(o, m, k, k2) {</span>
    <span class="s2">if </span><span class="s1">(k2 === undefined) k2 = k;</span>
    <span class="s1">o[k2] = m[k];</span>
<span class="s1">}));</span>
<span class="s2">var </span><span class="s1">__setModuleDefault = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__setModuleDefault) || (Object.create ? (</span><span class="s2">function</span><span class="s1">(o, v) {</span>
    <span class="s1">Object.defineProperty(o, </span><span class="s0">&quot;default&quot;</span><span class="s1">, { enumerable: </span><span class="s2">true</span><span class="s1">, value: v });</span>
<span class="s1">}) : </span><span class="s2">function</span><span class="s1">(o, v) {</span>
    <span class="s1">o[</span><span class="s0">&quot;default&quot;</span><span class="s1">] = v;</span>
<span class="s1">});</span>
<span class="s2">var </span><span class="s1">__importStar = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__importStar) || </span><span class="s2">function </span><span class="s1">(mod) {</span>
    <span class="s2">if </span><span class="s1">(mod &amp;&amp; mod.__esModule) </span><span class="s2">return </span><span class="s1">mod;</span>
    <span class="s2">var </span><span class="s1">result = {};</span>
    <span class="s2">if </span><span class="s1">(mod != </span><span class="s2">null</span><span class="s1">) </span><span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">k </span><span class="s2">in </span><span class="s1">mod) </span><span class="s2">if </span><span class="s1">(k !== </span><span class="s0">&quot;default&quot; </span><span class="s1">&amp;&amp; Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);</span>
    <span class="s1">__setModuleDefault(result, mod);</span>
    <span class="s2">return </span><span class="s1">result;</span>
<span class="s1">};</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, { value: </span><span class="s2">true </span><span class="s1">});</span>
<span class="s1">exports.Converter = exports.convertError = </span><span class="s2">void </span><span class="s3">0</span><span class="s1">;</span>
<span class="s4">// There's lots of funny stuff due to the typing of ts.Node</span>
<span class="s4">/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-member-access */</span>
<span class="s1">const ts = __importStar(require(</span><span class="s0">&quot;typescript&quot;</span><span class="s1">));</span>
<span class="s1">const getModifiers_1 = require(</span><span class="s0">&quot;./getModifiers&quot;</span><span class="s1">);</span>
<span class="s1">const node_utils_1 = require(</span><span class="s0">&quot;./node-utils&quot;</span><span class="s1">);</span>
<span class="s1">const ts_estree_1 = require(</span><span class="s0">&quot;./ts-estree&quot;</span><span class="s1">);</span>
<span class="s1">const version_check_1 = require(</span><span class="s0">&quot;./version-check&quot;</span><span class="s1">);</span>
<span class="s1">const SyntaxKind = ts.SyntaxKind;</span>
<span class="s4">/** 
 * Extends and formats a given error object 
 * @param error the error object 
 * @returns converted error object 
 */</span>
<span class="s2">function </span><span class="s1">convertError(error) {</span>
    <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, node_utils_1.createError)(error.file, error.start, (</span><span class="s0">'message' </span><span class="s2">in </span><span class="s1">error &amp;&amp; error.message) || error.messageText);</span>
<span class="s1">}</span>
<span class="s1">exports.convertError = convertError;</span>
<span class="s1">class Converter {</span>
    <span class="s4">/** 
     * Converts a TypeScript node into an ESTree node 
     * @param ast the full TypeScript AST 
     * @param options additional options for the conversion 
     * @returns the converted ESTreeNode 
     */</span>
    <span class="s1">constructor(ast, options) {</span>
        <span class="s2">this</span><span class="s1">.esTreeNodeToTSNodeMap = </span><span class="s2">new </span><span class="s1">WeakMap();</span>
        <span class="s2">this</span><span class="s1">.tsNodeToESTreeNodeMap = </span><span class="s2">new </span><span class="s1">WeakMap();</span>
        <span class="s2">this</span><span class="s1">.allowPattern = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">.inTypeMode = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">.ast = ast;</span>
        <span class="s2">this</span><span class="s1">.options = Object.assign({}, options);</span>
    <span class="s1">}</span>
    <span class="s1">getASTMaps() {</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">esTreeNodeToTSNodeMap: </span><span class="s2">this</span><span class="s1">.esTreeNodeToTSNodeMap,</span>
            <span class="s1">tsNodeToESTreeNodeMap: </span><span class="s2">this</span><span class="s1">.tsNodeToESTreeNodeMap,</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s1">convertProgram() {</span>
        <span class="s2">return this</span><span class="s1">.converter(</span><span class="s2">this</span><span class="s1">.ast);</span>
    <span class="s1">}</span>
    <span class="s4">/** 
     * Converts a TypeScript node into an ESTree node. 
     * @param node the child ts.Node 
     * @param parent parentNode 
     * @param inTypeMode flag to determine if we are in typeMode 
     * @param allowPattern flag to determine if patterns are allowed 
     * @returns the converted ESTree node 
     */</span>
    <span class="s1">converter(node, parent, inTypeMode, allowPattern) {</span>
        <span class="s4">/** 
         * Exit early for null and undefined 
         */</span>
        <span class="s2">if </span><span class="s1">(!node) {</span>
            <span class="s2">return null</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">const typeMode = </span><span class="s2">this</span><span class="s1">.inTypeMode;</span>
        <span class="s1">const pattern = </span><span class="s2">this</span><span class="s1">.allowPattern;</span>
        <span class="s2">if </span><span class="s1">(inTypeMode !== undefined) {</span>
            <span class="s2">this</span><span class="s1">.inTypeMode = inTypeMode;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(allowPattern !== undefined) {</span>
            <span class="s2">this</span><span class="s1">.allowPattern = allowPattern;</span>
        <span class="s1">}</span>
        <span class="s1">const result = </span><span class="s2">this</span><span class="s1">.convertNode(node, (parent !== </span><span class="s2">null </span><span class="s1">&amp;&amp; parent !== </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? parent : node.parent));</span>
        <span class="s2">this</span><span class="s1">.registerTSNodeInNodeMap(node, result);</span>
        <span class="s2">this</span><span class="s1">.inTypeMode = typeMode;</span>
        <span class="s2">this</span><span class="s1">.allowPattern = pattern;</span>
        <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>
    <span class="s4">/** 
     * Fixes the exports of the given ts.Node 
     * @param node the ts.Node 
     * @param result result 
     * @returns the ESTreeNode with fixed exports 
     */</span>
    <span class="s1">fixExports(node, result) {</span>
        <span class="s4">// check for exports</span>
        <span class="s1">const modifiers = (</span><span class="s3">0</span><span class="s1">, getModifiers_1.getModifiers)(node);</span>
        <span class="s2">if </span><span class="s1">((modifiers === </span><span class="s2">null </span><span class="s1">|| modifiers === </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: modifiers[</span><span class="s3">0</span><span class="s1">].kind) === SyntaxKind.ExportKeyword) {</span>
            <span class="s4">/** 
             * Make sure that original node is registered instead of export 
             */</span>
            <span class="s2">this</span><span class="s1">.registerTSNodeInNodeMap(node, result);</span>
            <span class="s1">const exportKeyword = modifiers[</span><span class="s3">0</span><span class="s1">];</span>
            <span class="s1">const nextModifier = modifiers[</span><span class="s3">1</span><span class="s1">];</span>
            <span class="s1">const declarationIsDefault = nextModifier &amp;&amp; nextModifier.kind === SyntaxKind.DefaultKeyword;</span>
            <span class="s1">const varToken = declarationIsDefault</span>
                <span class="s1">? (</span><span class="s3">0</span><span class="s1">, node_utils_1.findNextToken)(nextModifier, </span><span class="s2">this</span><span class="s1">.ast, </span><span class="s2">this</span><span class="s1">.ast)</span>
                <span class="s1">: (</span><span class="s3">0</span><span class="s1">, node_utils_1.findNextToken)(exportKeyword, </span><span class="s2">this</span><span class="s1">.ast, </span><span class="s2">this</span><span class="s1">.ast);</span>
            <span class="s1">result.range[</span><span class="s3">0</span><span class="s1">] = varToken.getStart(</span><span class="s2">this</span><span class="s1">.ast);</span>
            <span class="s1">result.loc = (</span><span class="s3">0</span><span class="s1">, node_utils_1.getLocFor)(result.range[</span><span class="s3">0</span><span class="s1">], result.range[</span><span class="s3">1</span><span class="s1">], </span><span class="s2">this</span><span class="s1">.ast);</span>
            <span class="s2">if </span><span class="s1">(declarationIsDefault) {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ExportDefaultDeclaration,</span>
                    <span class="s1">declaration: result,</span>
                    <span class="s1">range: [exportKeyword.getStart(</span><span class="s2">this</span><span class="s1">.ast), result.range[</span><span class="s3">1</span><span class="s1">]],</span>
                    <span class="s1">exportKind: </span><span class="s0">'value'</span><span class="s1">,</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">const isType = result.type === ts_estree_1.AST_NODE_TYPES.TSInterfaceDeclaration ||</span>
                    <span class="s1">result.type === ts_estree_1.AST_NODE_TYPES.TSTypeAliasDeclaration;</span>
                <span class="s1">const isDeclare = </span><span class="s0">'declare' </span><span class="s2">in </span><span class="s1">result &amp;&amp; result.declare === </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ExportNamedDeclaration,</span>
                    <span class="s4">// @ts-expect-error - TODO, narrow the types here</span>
                    <span class="s1">declaration: result,</span>
                    <span class="s1">specifiers: [],</span>
                    <span class="s1">source: </span><span class="s2">null</span><span class="s1">,</span>
                    <span class="s1">exportKind: isType || isDeclare ? </span><span class="s0">'type' </span><span class="s1">: </span><span class="s0">'value'</span><span class="s1">,</span>
                    <span class="s1">range: [exportKeyword.getStart(</span><span class="s2">this</span><span class="s1">.ast), result.range[</span><span class="s3">1</span><span class="s1">]],</span>
                    <span class="s1">assertions: [],</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>
    <span class="s4">/** 
     * Register specific TypeScript node into map with first ESTree node provided 
     */</span>
    <span class="s1">registerTSNodeInNodeMap(node, result) {</span>
        <span class="s2">if </span><span class="s1">(result &amp;&amp; </span><span class="s2">this</span><span class="s1">.options.shouldPreserveNodeMaps) {</span>
            <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.tsNodeToESTreeNodeMap.has(node)) {</span>
                <span class="s2">this</span><span class="s1">.tsNodeToESTreeNodeMap.set(node, result);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s4">/** 
     * Converts a TypeScript node into an ESTree node. 
     * @param child the child ts.Node 
     * @param parent parentNode 
     * @returns the converted ESTree node 
     */</span>
    <span class="s1">convertPattern(child, parent) {</span>
        <span class="s2">return this</span><span class="s1">.converter(child, parent, </span><span class="s2">this</span><span class="s1">.inTypeMode, </span><span class="s2">true</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s4">/** 
     * Converts a TypeScript node into an ESTree node. 
     * @param child the child ts.Node 
     * @param parent parentNode 
     * @returns the converted ESTree node 
     */</span>
    <span class="s1">convertChild(child, parent) {</span>
        <span class="s2">return this</span><span class="s1">.converter(child, parent, </span><span class="s2">this</span><span class="s1">.inTypeMode, </span><span class="s2">false</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s4">/** 
     * Converts a TypeScript node into an ESTree node. 
     * @param child the child ts.Node 
     * @param parent parentNode 
     * @returns the converted ESTree node 
     */</span>
    <span class="s1">convertType(child, parent) {</span>
        <span class="s2">return this</span><span class="s1">.converter(child, parent, </span><span class="s2">true</span><span class="s1">, </span><span class="s2">false</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">createNode(node, data) {</span>
        <span class="s1">const result = data;</span>
        <span class="s2">if </span><span class="s1">(!result.range) {</span>
            <span class="s1">result.range = (</span><span class="s3">0</span><span class="s1">, node_utils_1.getRange)(</span>
            <span class="s4">// this is completely valid, but TS hates it</span>
            <span class="s1">node, </span><span class="s2">this</span><span class="s1">.ast);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(!result.loc) {</span>
            <span class="s1">result.loc = (</span><span class="s3">0</span><span class="s1">, node_utils_1.getLocFor)(result.range[</span><span class="s3">0</span><span class="s1">], result.range[</span><span class="s3">1</span><span class="s1">], </span><span class="s2">this</span><span class="s1">.ast);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(result &amp;&amp; </span><span class="s2">this</span><span class="s1">.options.shouldPreserveNodeMaps) {</span>
            <span class="s2">this</span><span class="s1">.esTreeNodeToTSNodeMap.set(result, node);</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>
    <span class="s1">convertBindingNameWithTypeAnnotation(name, tsType, parent) {</span>
        <span class="s1">const id = </span><span class="s2">this</span><span class="s1">.convertPattern(name);</span>
        <span class="s2">if </span><span class="s1">(tsType) {</span>
            <span class="s1">id.typeAnnotation = </span><span class="s2">this</span><span class="s1">.convertTypeAnnotation(tsType, parent);</span>
            <span class="s2">this</span><span class="s1">.fixParentLocation(id, id.typeAnnotation.range);</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">id;</span>
    <span class="s1">}</span>
    <span class="s4">/** 
     * Converts a child into a type annotation. This creates an intermediary 
     * TypeAnnotation node to match what Flow does. 
     * @param child The TypeScript AST node to convert. 
     * @param parent parentNode 
     * @returns The type annotation node. 
     */</span>
    <span class="s1">convertTypeAnnotation(child, parent) {</span>
        <span class="s4">// in FunctionType and ConstructorType typeAnnotation has 2 characters `=&gt;` and in other places is just colon</span>
        <span class="s1">const offset = (parent === </span><span class="s2">null </span><span class="s1">|| parent === </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: parent.kind) === SyntaxKind.FunctionType ||</span>
            <span class="s1">(parent === </span><span class="s2">null </span><span class="s1">|| parent === </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: parent.kind) === SyntaxKind.ConstructorType</span>
            <span class="s1">? </span><span class="s3">2</span>
            <span class="s1">: </span><span class="s3">1</span><span class="s1">;</span>
        <span class="s1">const annotationStartCol = child.getFullStart() - offset;</span>
        <span class="s1">const loc = (</span><span class="s3">0</span><span class="s1">, node_utils_1.getLocFor)(annotationStartCol, child.end, </span><span class="s2">this</span><span class="s1">.ast);</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSTypeAnnotation,</span>
            <span class="s1">loc,</span>
            <span class="s1">range: [annotationStartCol, child.end],</span>
            <span class="s1">typeAnnotation: </span><span class="s2">this</span><span class="s1">.convertType(child),</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s4">/** 
     * Coverts body Nodes and add a directive field to StringLiterals 
     * @param nodes of ts.Node 
     * @param parent parentNode 
     * @returns Array of body statements 
     */</span>
    <span class="s1">convertBodyExpressions(nodes, parent) {</span>
        <span class="s1">let allowDirectives = (</span><span class="s3">0</span><span class="s1">, node_utils_1.canContainDirective)(parent);</span>
        <span class="s2">return </span><span class="s1">(nodes</span>
            <span class="s1">.map(statement =&gt; {</span>
            <span class="s1">const child = </span><span class="s2">this</span><span class="s1">.convertChild(statement);</span>
            <span class="s2">if </span><span class="s1">(allowDirectives) {</span>
                <span class="s2">if </span><span class="s1">((child === </span><span class="s2">null </span><span class="s1">|| child === </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: child.expression) &amp;&amp;</span>
                    <span class="s1">ts.isExpressionStatement(statement) &amp;&amp;</span>
                    <span class="s1">ts.isStringLiteral(statement.expression)) {</span>
                    <span class="s1">const raw = child.expression.raw;</span>
                    <span class="s1">child.directive = raw.slice(</span><span class="s3">1</span><span class="s1">, -</span><span class="s3">1</span><span class="s1">);</span>
                    <span class="s2">return </span><span class="s1">child; </span><span class="s4">// child can be null, but it's filtered below</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">allowDirectives = </span><span class="s2">false</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">child; </span><span class="s4">// child can be null, but it's filtered below</span>
        <span class="s1">})</span>
            <span class="s4">// filter out unknown nodes for now</span>
            <span class="s1">.filter(statement =&gt; statement));</span>
    <span class="s1">}</span>
    <span class="s4">/** 
     * Converts a ts.Node's typeArguments to TSTypeParameterInstantiation node 
     * @param typeArguments ts.NodeArray typeArguments 
     * @param node parent used to create this node 
     * @returns TypeParameterInstantiation node 
     */</span>
    <span class="s1">convertTypeArgumentsToTypeParameters(typeArguments, node) {</span>
        <span class="s1">const greaterThanToken = (</span><span class="s3">0</span><span class="s1">, node_utils_1.findNextToken)(typeArguments, </span><span class="s2">this</span><span class="s1">.ast, </span><span class="s2">this</span><span class="s1">.ast);</span>
        <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
            <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSTypeParameterInstantiation,</span>
            <span class="s1">range: [typeArguments.pos - </span><span class="s3">1</span><span class="s1">, greaterThanToken.end],</span>
            <span class="s1">params: typeArguments.map(typeArgument =&gt; </span><span class="s2">this</span><span class="s1">.convertType(typeArgument)),</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s4">/** 
     * Converts a ts.Node's typeParameters to TSTypeParameterDeclaration node 
     * @param typeParameters ts.Node typeParameters 
     * @returns TypeParameterDeclaration node 
     */</span>
    <span class="s1">convertTSTypeParametersToTypeParametersDeclaration(typeParameters) {</span>
        <span class="s1">const greaterThanToken = (</span><span class="s3">0</span><span class="s1">, node_utils_1.findNextToken)(typeParameters, </span><span class="s2">this</span><span class="s1">.ast, </span><span class="s2">this</span><span class="s1">.ast);</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSTypeParameterDeclaration,</span>
            <span class="s1">range: [typeParameters.pos - </span><span class="s3">1</span><span class="s1">, greaterThanToken.end],</span>
            <span class="s1">loc: (</span><span class="s3">0</span><span class="s1">, node_utils_1.getLocFor)(typeParameters.pos - </span><span class="s3">1</span><span class="s1">, greaterThanToken.end, </span><span class="s2">this</span><span class="s1">.ast),</span>
            <span class="s1">params: typeParameters.map(typeParameter =&gt; </span><span class="s2">this</span><span class="s1">.convertType(typeParameter)),</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s4">/** 
     * Converts an array of ts.Node parameters into an array of ESTreeNode params 
     * @param parameters An array of ts.Node params to be converted 
     * @returns an array of converted ESTreeNode params 
     */</span>
    <span class="s1">convertParameters(parameters) {</span>
        <span class="s2">if </span><span class="s1">(!(parameters === </span><span class="s2">null </span><span class="s1">|| parameters === </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: parameters.length)) {</span>
            <span class="s2">return </span><span class="s1">[];</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">parameters.map(param =&gt; {</span>
            <span class="s1">const convertedParam = </span><span class="s2">this</span><span class="s1">.convertChild(param);</span>
            <span class="s1">const decorators = (</span><span class="s3">0</span><span class="s1">, getModifiers_1.getDecorators)(param);</span>
            <span class="s2">if </span><span class="s1">(decorators === </span><span class="s2">null </span><span class="s1">|| decorators === </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: decorators.length) {</span>
                <span class="s1">convertedParam.decorators = decorators.map(el =&gt; </span><span class="s2">this</span><span class="s1">.convertChild(el));</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">convertedParam;</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">convertChainExpression(node, tsNode) {</span>
        <span class="s1">const { child, isOptional } = (() =&gt; {</span>
            <span class="s2">if </span><span class="s1">(node.type === ts_estree_1.AST_NODE_TYPES.MemberExpression) {</span>
                <span class="s2">return </span><span class="s1">{ child: node.object, isOptional: node.optional };</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(node.type === ts_estree_1.AST_NODE_TYPES.CallExpression) {</span>
                <span class="s2">return </span><span class="s1">{ child: node.callee, isOptional: node.optional };</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">{ child: node.expression, isOptional: </span><span class="s2">false </span><span class="s1">};</span>
        <span class="s1">})();</span>
        <span class="s1">const isChildUnwrappable = (</span><span class="s3">0</span><span class="s1">, node_utils_1.isChildUnwrappableOptionalChain)(tsNode, child);</span>
        <span class="s2">if </span><span class="s1">(!isChildUnwrappable &amp;&amp; !isOptional) {</span>
            <span class="s2">return </span><span class="s1">node;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(isChildUnwrappable &amp;&amp; (</span><span class="s3">0</span><span class="s1">, node_utils_1.isChainExpression)(child)) {</span>
            <span class="s4">// unwrap the chain expression child</span>
            <span class="s1">const newChild = child.expression;</span>
            <span class="s2">if </span><span class="s1">(node.type === ts_estree_1.AST_NODE_TYPES.MemberExpression) {</span>
                <span class="s1">node.object = newChild;</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(node.type === ts_estree_1.AST_NODE_TYPES.CallExpression) {</span>
                <span class="s1">node.callee = newChild;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">node.expression = newChild;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return this</span><span class="s1">.createNode(tsNode, {</span>
            <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ChainExpression,</span>
            <span class="s1">expression: node,</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s4">/** 
     * For nodes that are copied directly from the TypeScript AST into 
     * ESTree mostly as-is. The only difference is the addition of a type 
     * property instead of a kind property. Recursively copies all children. 
     */</span>
    <span class="s1">deeplyCopy(node) {</span>
        <span class="s2">if </span><span class="s1">(node.kind === ts.SyntaxKind.JSDocFunctionType) {</span>
            <span class="s2">throw </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, node_utils_1.createError)(</span><span class="s2">this</span><span class="s1">.ast, node.pos, </span><span class="s0">'JSDoc types can only be used inside documentation comments.'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s1">const customType = `TS${SyntaxKind[node.kind]}`;</span>
        <span class="s4">/** 
         * If the &quot;errorOnUnknownASTType&quot; option is set to true, throw an error, 
         * otherwise fallback to just including the unknown type as-is. 
         */</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.errorOnUnknownASTType &amp;&amp; !ts_estree_1.AST_NODE_TYPES[customType]) {</span>
            <span class="s2">throw new </span><span class="s1">Error(`Unknown AST_NODE_TYPE: </span><span class="s0">&quot;${customType}&quot;</span><span class="s1">`);</span>
        <span class="s1">}</span>
        <span class="s1">const result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
            <span class="s1">type: customType,</span>
        <span class="s1">});</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s0">'type' </span><span class="s2">in </span><span class="s1">node) {</span>
            <span class="s1">result.typeAnnotation =</span>
                <span class="s1">node.type &amp;&amp; </span><span class="s0">'kind' </span><span class="s2">in </span><span class="s1">node.type &amp;&amp; ts.isTypeNode(node.type)</span>
                    <span class="s1">? </span><span class="s2">this</span><span class="s1">.convertTypeAnnotation(node.type, node)</span>
                    <span class="s1">: </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s0">'typeArguments' </span><span class="s2">in </span><span class="s1">node) {</span>
            <span class="s1">result.typeParameters =</span>
                <span class="s1">node.typeArguments &amp;&amp; </span><span class="s0">'pos' </span><span class="s2">in </span><span class="s1">node.typeArguments</span>
                    <span class="s1">? </span><span class="s2">this</span><span class="s1">.convertTypeArgumentsToTypeParameters(node.typeArguments, node)</span>
                    <span class="s1">: </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s0">'typeParameters' </span><span class="s2">in </span><span class="s1">node) {</span>
            <span class="s1">result.typeParameters =</span>
                <span class="s1">node.typeParameters &amp;&amp; </span><span class="s0">'pos' </span><span class="s2">in </span><span class="s1">node.typeParameters</span>
                    <span class="s1">? </span><span class="s2">this</span><span class="s1">.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters)</span>
                    <span class="s1">: </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">const decorators = (</span><span class="s3">0</span><span class="s1">, getModifiers_1.getDecorators)(node);</span>
        <span class="s2">if </span><span class="s1">(decorators === </span><span class="s2">null </span><span class="s1">|| decorators === </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: decorators.length) {</span>
            <span class="s1">result.decorators = decorators.map(el =&gt; </span><span class="s2">this</span><span class="s1">.convertChild(el));</span>
        <span class="s1">}</span>
        <span class="s4">// keys we never want to clone from the base typescript node as they</span>
        <span class="s4">// introduce garbage into our AST</span>
        <span class="s1">const KEYS_TO_NOT_COPY = </span><span class="s2">new </span><span class="s1">Set([</span>
            <span class="s0">'_children'</span><span class="s1">,</span>
            <span class="s0">'decorators'</span><span class="s1">,</span>
            <span class="s0">'end'</span><span class="s1">,</span>
            <span class="s0">'flags'</span><span class="s1">,</span>
            <span class="s0">'illegalDecorators'</span><span class="s1">,</span>
            <span class="s0">'heritageClauses'</span><span class="s1">,</span>
            <span class="s0">'locals'</span><span class="s1">,</span>
            <span class="s0">'localSymbol'</span><span class="s1">,</span>
            <span class="s0">'jsDoc'</span><span class="s1">,</span>
            <span class="s0">'kind'</span><span class="s1">,</span>
            <span class="s0">'modifierFlagsCache'</span><span class="s1">,</span>
            <span class="s0">'modifiers'</span><span class="s1">,</span>
            <span class="s0">'nextContainer'</span><span class="s1">,</span>
            <span class="s0">'parent'</span><span class="s1">,</span>
            <span class="s0">'pos'</span><span class="s1">,</span>
            <span class="s0">'symbol'</span><span class="s1">,</span>
            <span class="s0">'transformFlags'</span><span class="s1">,</span>
            <span class="s0">'type'</span><span class="s1">,</span>
            <span class="s0">'typeArguments'</span><span class="s1">,</span>
            <span class="s0">'typeParameters'</span><span class="s1">,</span>
        <span class="s1">]);</span>
        <span class="s1">Object.entries(node)</span>
            <span class="s1">.filter(([key]) =&gt; !KEYS_TO_NOT_COPY.has(key))</span>
            <span class="s1">.forEach(([key, value]) =&gt; {</span>
            <span class="s2">if </span><span class="s1">(Array.isArray(value)) {</span>
                <span class="s1">result[key] = value.map(el =&gt; </span><span class="s2">this</span><span class="s1">.convertChild(el));</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(value &amp;&amp; </span><span class="s2">typeof </span><span class="s1">value === </span><span class="s0">'object' </span><span class="s1">&amp;&amp; value.kind) {</span>
                <span class="s4">// need to check node[key].kind to ensure we don't try to convert a symbol</span>
                <span class="s1">result[key] = </span><span class="s2">this</span><span class="s1">.convertChild(value);</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">result[key] = value;</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
        <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>
    <span class="s1">convertJSXIdentifier(node) {</span>
        <span class="s1">const result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
            <span class="s1">type: ts_estree_1.AST_NODE_TYPES.JSXIdentifier,</span>
            <span class="s1">name: node.getText(),</span>
        <span class="s1">});</span>
        <span class="s2">this</span><span class="s1">.registerTSNodeInNodeMap(node, result);</span>
        <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>
    <span class="s1">convertJSXNamespaceOrIdentifier(node) {</span>
        <span class="s4">// TypeScript@5.1 added in ts.JsxNamespacedName directly</span>
        <span class="s4">// We prefer using that if it's relevant for this node type</span>
        <span class="s2">if </span><span class="s1">(node.kind === ts.SyntaxKind.JsxNamespacedName) {</span>
            <span class="s1">const result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                <span class="s1">type: ts_estree_1.AST_NODE_TYPES.JSXNamespacedName,</span>
                <span class="s1">namespace: </span><span class="s2">this</span><span class="s1">.createNode(node.namespace, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.JSXIdentifier,</span>
                    <span class="s1">name: node.namespace.text,</span>
                <span class="s1">}),</span>
                <span class="s1">name: </span><span class="s2">this</span><span class="s1">.createNode(node.name, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.JSXIdentifier,</span>
                    <span class="s1">name: node.name.text,</span>
                <span class="s1">}),</span>
            <span class="s1">});</span>
            <span class="s2">this</span><span class="s1">.registerTSNodeInNodeMap(node, result);</span>
            <span class="s2">return </span><span class="s1">result;</span>
        <span class="s1">}</span>
        <span class="s4">// TypeScript@&lt;5.1 has to manually parse the JSX attributes</span>
        <span class="s1">const text = node.getText();</span>
        <span class="s1">const colonIndex = text.indexOf(</span><span class="s0">':'</span><span class="s1">);</span>
        <span class="s4">// this is intentional we can ignore conversion if `:` is in first character</span>
        <span class="s2">if </span><span class="s1">(colonIndex &gt; </span><span class="s3">0</span><span class="s1">) {</span>
            <span class="s1">const range = (</span><span class="s3">0</span><span class="s1">, node_utils_1.getRange)(node, </span><span class="s2">this</span><span class="s1">.ast);</span>
            <span class="s4">// @ts-expect-error -- TypeScript@&lt;5.1 doesn't have ts.JsxNamespacedName</span>
            <span class="s1">const result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                <span class="s1">type: ts_estree_1.AST_NODE_TYPES.JSXNamespacedName,</span>
                <span class="s1">namespace: </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.JSXIdentifier,</span>
                    <span class="s1">name: text.slice(</span><span class="s3">0</span><span class="s1">, colonIndex),</span>
                    <span class="s1">range: [range[</span><span class="s3">0</span><span class="s1">], range[</span><span class="s3">0</span><span class="s1">] + colonIndex],</span>
                <span class="s1">}),</span>
                <span class="s1">name: </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.JSXIdentifier,</span>
                    <span class="s1">name: text.slice(colonIndex + </span><span class="s3">1</span><span class="s1">),</span>
                    <span class="s1">range: [range[</span><span class="s3">0</span><span class="s1">] + colonIndex + </span><span class="s3">1</span><span class="s1">, range[</span><span class="s3">1</span><span class="s1">]],</span>
                <span class="s1">}),</span>
                <span class="s1">range,</span>
            <span class="s1">});</span>
            <span class="s2">this</span><span class="s1">.registerTSNodeInNodeMap(node, result);</span>
            <span class="s2">return </span><span class="s1">result;</span>
        <span class="s1">}</span>
        <span class="s2">return this</span><span class="s1">.convertJSXIdentifier(node);</span>
    <span class="s1">}</span>
    <span class="s4">/** 
     * Converts a TypeScript JSX node.tagName into an ESTree node.name 
     * @param node the tagName object from a JSX ts.Node 
     * @param parent 
     * @returns the converted ESTree name object 
     */</span>
    <span class="s1">convertJSXTagName(node, parent) {</span>
        <span class="s1">let result;</span>
        <span class="s2">switch </span><span class="s1">(node.kind) {</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.PropertyAccessExpression:</span>
                <span class="s2">if </span><span class="s1">(node.name.kind === SyntaxKind.PrivateIdentifier) {</span>
                    <span class="s4">// This is one of the few times where TS explicitly errors, and doesn't even gracefully handle the syntax.</span>
                    <span class="s4">// So we shouldn't ever get into this state to begin with.</span>
                    <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">'Non-private identifier expected.'</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s1">result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.JSXMemberExpression,</span>
                    <span class="s1">object: </span><span class="s2">this</span><span class="s1">.convertJSXTagName(node.expression, parent),</span>
                    <span class="s1">property: </span><span class="s2">this</span><span class="s1">.convertJSXIdentifier(node.name),</span>
                <span class="s1">});</span>
                <span class="s2">break</span><span class="s1">;</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ThisKeyword:</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.Identifier:</span>
            <span class="s2">default</span><span class="s1">:</span>
                <span class="s2">return this</span><span class="s1">.convertJSXNamespaceOrIdentifier(node);</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.registerTSNodeInNodeMap(node, result);</span>
        <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>
    <span class="s1">convertMethodSignature(node) {</span>
        <span class="s1">const result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
            <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSMethodSignature,</span>
            <span class="s1">computed: (</span><span class="s3">0</span><span class="s1">, node_utils_1.isComputedProperty)(node.name),</span>
            <span class="s1">key: </span><span class="s2">this</span><span class="s1">.convertChild(node.name),</span>
            <span class="s1">params: </span><span class="s2">this</span><span class="s1">.convertParameters(node.parameters),</span>
            <span class="s1">kind: (() =&gt; {</span>
                <span class="s2">switch </span><span class="s1">(node.kind) {</span>
                    <span class="s2">case </span><span class="s1">SyntaxKind.GetAccessor:</span>
                        <span class="s2">return </span><span class="s0">'get'</span><span class="s1">;</span>
                    <span class="s2">case </span><span class="s1">SyntaxKind.SetAccessor:</span>
                        <span class="s2">return </span><span class="s0">'set'</span><span class="s1">;</span>
                    <span class="s2">case </span><span class="s1">SyntaxKind.MethodSignature:</span>
                        <span class="s2">return </span><span class="s0">'method'</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">})(),</span>
        <span class="s1">});</span>
        <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, node_utils_1.isOptional)(node)) {</span>
            <span class="s1">result.optional = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(node.type) {</span>
            <span class="s1">result.returnType = </span><span class="s2">this</span><span class="s1">.convertTypeAnnotation(node.type, node);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.ReadonlyKeyword, node)) {</span>
            <span class="s1">result.readonly = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(node.typeParameters) {</span>
            <span class="s1">result.typeParameters =</span>
                <span class="s2">this</span><span class="s1">.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);</span>
        <span class="s1">}</span>
        <span class="s1">const accessibility = (</span><span class="s3">0</span><span class="s1">, node_utils_1.getTSNodeAccessibility)(node);</span>
        <span class="s2">if </span><span class="s1">(accessibility) {</span>
            <span class="s1">result.accessibility = accessibility;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.ExportKeyword, node)) {</span>
            <span class="s1">result.export = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.StaticKeyword, node)) {</span>
            <span class="s1">result.static = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>
    <span class="s1">convertAssertClasue(node) {</span>
        <span class="s2">return </span><span class="s1">node === undefined</span>
            <span class="s1">? []</span>
            <span class="s1">: node.elements.map(element =&gt; </span><span class="s2">this</span><span class="s1">.convertChild(element));</span>
    <span class="s1">}</span>
    <span class="s4">/** 
     * Applies the given TS modifiers to the given result object. 
     * 
     * This method adds not standardized `modifiers` property in nodes 
     * 
     * @param result 
     * @param modifiers original ts.Nodes from the node.modifiers array 
     * @returns the current result object will be mutated 
     */</span>
    <span class="s1">applyModifiersToResult(result, modifiers) {</span>
        <span class="s2">if </span><span class="s1">(!modifiers) {</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">const remainingModifiers = [];</span>
        <span class="s4">/** 
         * Some modifiers are explicitly handled by applying them as 
         * boolean values on the result node. As well as adding them 
         * to the result, we remove them from the array, so that they 
         * are not handled twice. 
         */</span>
        <span class="s2">for </span><span class="s1">(const modifier of modifiers) {</span>
            <span class="s2">switch </span><span class="s1">(modifier.kind) {</span>
                <span class="s4">/** 
                 * Ignore ExportKeyword and DefaultKeyword, they are handled 
                 * via the fixExports utility function 
                 */</span>
                <span class="s2">case </span><span class="s1">SyntaxKind.ExportKeyword:</span>
                <span class="s2">case </span><span class="s1">SyntaxKind.DefaultKeyword:</span>
                    <span class="s2">break</span><span class="s1">;</span>
                <span class="s2">case </span><span class="s1">SyntaxKind.ConstKeyword:</span>
                    <span class="s1">result.const = </span><span class="s2">true</span><span class="s1">;</span>
                    <span class="s2">break</span><span class="s1">;</span>
                <span class="s2">case </span><span class="s1">SyntaxKind.DeclareKeyword:</span>
                    <span class="s1">result.declare = </span><span class="s2">true</span><span class="s1">;</span>
                    <span class="s2">break</span><span class="s1">;</span>
                <span class="s2">default</span><span class="s1">:</span>
                    <span class="s1">remainingModifiers.push(</span><span class="s2">this</span><span class="s1">.convertChild(modifier));</span>
                    <span class="s2">break</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s4">/** 
         * If there are still valid modifiers available which have 
         * not been explicitly handled above, we just convert and 
         * add the modifiers array to the result node. 
         */</span>
        <span class="s2">if </span><span class="s1">(remainingModifiers.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
            <span class="s1">result.modifiers = remainingModifiers;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s4">/** 
     * Uses the provided range location to adjust the location data of the given Node 
     * @param result The node that will have its location data mutated 
     * @param childRange The child node range used to expand location 
     */</span>
    <span class="s1">fixParentLocation(result, childRange) {</span>
        <span class="s2">if </span><span class="s1">(childRange[</span><span class="s3">0</span><span class="s1">] &lt; result.range[</span><span class="s3">0</span><span class="s1">]) {</span>
            <span class="s1">result.range[</span><span class="s3">0</span><span class="s1">] = childRange[</span><span class="s3">0</span><span class="s1">];</span>
            <span class="s1">result.loc.start = (</span><span class="s3">0</span><span class="s1">, node_utils_1.getLineAndCharacterFor)(result.range[</span><span class="s3">0</span><span class="s1">], </span><span class="s2">this</span><span class="s1">.ast);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(childRange[</span><span class="s3">1</span><span class="s1">] &gt; result.range[</span><span class="s3">1</span><span class="s1">]) {</span>
            <span class="s1">result.range[</span><span class="s3">1</span><span class="s1">] = childRange[</span><span class="s3">1</span><span class="s1">];</span>
            <span class="s1">result.loc.end = (</span><span class="s3">0</span><span class="s1">, node_utils_1.getLineAndCharacterFor)(result.range[</span><span class="s3">1</span><span class="s1">], </span><span class="s2">this</span><span class="s1">.ast);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">assertModuleSpecifier(node, allowNull) {</span>
        <span class="s2">var </span><span class="s1">_a;</span>
        <span class="s2">if </span><span class="s1">(!allowNull &amp;&amp; node.moduleSpecifier == </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">throw </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, node_utils_1.createError)(</span><span class="s2">this</span><span class="s1">.ast, node.pos, </span><span class="s0">'Module specifier must be a string literal.'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(node.moduleSpecifier &amp;&amp;</span>
            <span class="s1">((_a = node.moduleSpecifier) === </span><span class="s2">null </span><span class="s1">|| _a === </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _a.kind) !== SyntaxKind.StringLiteral) {</span>
            <span class="s2">throw </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, node_utils_1.createError)(</span><span class="s2">this</span><span class="s1">.ast, node.moduleSpecifier.pos, </span><span class="s0">'Module specifier must be a string literal.'</span><span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s4">/** 
     * Converts a TypeScript node into an ESTree node. 
     * The core of the conversion logic: 
     * Identify and convert each relevant TypeScript SyntaxKind 
     * @param node the child ts.Node 
     * @param parent parentNode 
     * @returns the converted ESTree node 
     */</span>
    <span class="s1">convertNode(node, parent) {</span>
        <span class="s2">var </span><span class="s1">_a, _b, _c, _d, _e, _f, _g, _h, _j, _k;</span>
        <span class="s2">switch </span><span class="s1">(node.kind) {</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.SourceFile: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.Program,</span>
                    <span class="s1">body: </span><span class="s2">this</span><span class="s1">.convertBodyExpressions(node.statements, node),</span>
                    <span class="s1">sourceType: node.externalModuleIndicator ? </span><span class="s0">'module' </span><span class="s1">: </span><span class="s0">'script'</span><span class="s1">,</span>
                    <span class="s1">range: [node.getStart(</span><span class="s2">this</span><span class="s1">.ast), node.endOfFileToken.end],</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.Block: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.BlockStatement,</span>
                    <span class="s1">body: </span><span class="s2">this</span><span class="s1">.convertBodyExpressions(node.statements, node),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.Identifier: {</span>
                <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, node_utils_1.isThisInTypeQuery)(node)) {</span>
                    <span class="s4">// special case for `typeof this.foo` - TS emits an Identifier for `this`</span>
                    <span class="s4">// but we want to treat it as a ThisExpression for consistency</span>
                    <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ThisExpression,</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.Identifier,</span>
                    <span class="s1">name: node.text,</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.PrivateIdentifier: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.PrivateIdentifier,</span>
                    <span class="s4">// typescript includes the `#` in the text</span>
                    <span class="s1">name: node.text.slice(</span><span class="s3">1</span><span class="s1">),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.WithStatement:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.WithStatement,</span>
                    <span class="s1">object: </span><span class="s2">this</span><span class="s1">.convertChild(node.expression),</span>
                    <span class="s1">body: </span><span class="s2">this</span><span class="s1">.convertChild(node.statement),</span>
                <span class="s1">});</span>
            <span class="s4">// Control Flow</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ReturnStatement:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ReturnStatement,</span>
                    <span class="s1">argument: </span><span class="s2">this</span><span class="s1">.convertChild(node.expression),</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.LabeledStatement:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.LabeledStatement,</span>
                    <span class="s1">label: </span><span class="s2">this</span><span class="s1">.convertChild(node.label),</span>
                    <span class="s1">body: </span><span class="s2">this</span><span class="s1">.convertChild(node.statement),</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ContinueStatement:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ContinueStatement,</span>
                    <span class="s1">label: </span><span class="s2">this</span><span class="s1">.convertChild(node.label),</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.BreakStatement:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.BreakStatement,</span>
                    <span class="s1">label: </span><span class="s2">this</span><span class="s1">.convertChild(node.label),</span>
                <span class="s1">});</span>
            <span class="s4">// Choice</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.IfStatement:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.IfStatement,</span>
                    <span class="s1">test: </span><span class="s2">this</span><span class="s1">.convertChild(node.expression),</span>
                    <span class="s1">consequent: </span><span class="s2">this</span><span class="s1">.convertChild(node.thenStatement),</span>
                    <span class="s1">alternate: </span><span class="s2">this</span><span class="s1">.convertChild(node.elseStatement),</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.SwitchStatement:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.SwitchStatement,</span>
                    <span class="s1">discriminant: </span><span class="s2">this</span><span class="s1">.convertChild(node.expression),</span>
                    <span class="s1">cases: node.caseBlock.clauses.map(el =&gt; </span><span class="s2">this</span><span class="s1">.convertChild(el)),</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.CaseClause:</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.DefaultClause:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.SwitchCase,</span>
                    <span class="s4">// expression is present in case only</span>
                    <span class="s1">test: node.kind === SyntaxKind.CaseClause</span>
                        <span class="s1">? </span><span class="s2">this</span><span class="s1">.convertChild(node.expression)</span>
                        <span class="s1">: </span><span class="s2">null</span><span class="s1">,</span>
                    <span class="s1">consequent: node.statements.map(el =&gt; </span><span class="s2">this</span><span class="s1">.convertChild(el)),</span>
                <span class="s1">});</span>
            <span class="s4">// Exceptions</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ThrowStatement:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ThrowStatement,</span>
                    <span class="s1">argument: </span><span class="s2">this</span><span class="s1">.convertChild(node.expression),</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.TryStatement:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TryStatement,</span>
                    <span class="s1">block: </span><span class="s2">this</span><span class="s1">.convertChild(node.tryBlock),</span>
                    <span class="s1">handler: </span><span class="s2">this</span><span class="s1">.convertChild(node.catchClause),</span>
                    <span class="s1">finalizer: </span><span class="s2">this</span><span class="s1">.convertChild(node.finallyBlock),</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.CatchClause:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.CatchClause,</span>
                    <span class="s1">param: node.variableDeclaration</span>
                        <span class="s1">? </span><span class="s2">this</span><span class="s1">.convertBindingNameWithTypeAnnotation(node.variableDeclaration.name, node.variableDeclaration.type)</span>
                        <span class="s1">: </span><span class="s2">null</span><span class="s1">,</span>
                    <span class="s1">body: </span><span class="s2">this</span><span class="s1">.convertChild(node.block),</span>
                <span class="s1">});</span>
            <span class="s4">// Loops</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.WhileStatement:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.WhileStatement,</span>
                    <span class="s1">test: </span><span class="s2">this</span><span class="s1">.convertChild(node.expression),</span>
                    <span class="s1">body: </span><span class="s2">this</span><span class="s1">.convertChild(node.statement),</span>
                <span class="s1">});</span>
            <span class="s4">/** 
             * Unlike other parsers, TypeScript calls a &quot;DoWhileStatement&quot; 
             * a &quot;DoStatement&quot; 
             */</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.DoStatement:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.DoWhileStatement,</span>
                    <span class="s1">test: </span><span class="s2">this</span><span class="s1">.convertChild(node.expression),</span>
                    <span class="s1">body: </span><span class="s2">this</span><span class="s1">.convertChild(node.statement),</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ForStatement:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ForStatement,</span>
                    <span class="s1">init: </span><span class="s2">this</span><span class="s1">.convertChild(node.initializer),</span>
                    <span class="s1">test: </span><span class="s2">this</span><span class="s1">.convertChild(node.condition),</span>
                    <span class="s1">update: </span><span class="s2">this</span><span class="s1">.convertChild(node.incrementor),</span>
                    <span class="s1">body: </span><span class="s2">this</span><span class="s1">.convertChild(node.statement),</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ForInStatement:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ForInStatement,</span>
                    <span class="s1">left: </span><span class="s2">this</span><span class="s1">.convertPattern(node.initializer),</span>
                    <span class="s1">right: </span><span class="s2">this</span><span class="s1">.convertChild(node.expression),</span>
                    <span class="s1">body: </span><span class="s2">this</span><span class="s1">.convertChild(node.statement),</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ForOfStatement:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ForOfStatement,</span>
                    <span class="s1">left: </span><span class="s2">this</span><span class="s1">.convertPattern(node.initializer),</span>
                    <span class="s1">right: </span><span class="s2">this</span><span class="s1">.convertChild(node.expression),</span>
                    <span class="s1">body: </span><span class="s2">this</span><span class="s1">.convertChild(node.statement),</span>
                    <span class="s1">await: Boolean(node.awaitModifier &amp;&amp;</span>
                        <span class="s1">node.awaitModifier.kind === SyntaxKind.AwaitKeyword),</span>
                <span class="s1">});</span>
            <span class="s4">// Declarations</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.FunctionDeclaration: {</span>
                <span class="s1">const isDeclare = (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.DeclareKeyword, node);</span>
                <span class="s1">const result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: isDeclare || !node.body</span>
                        <span class="s1">? ts_estree_1.AST_NODE_TYPES.TSDeclareFunction</span>
                        <span class="s1">: ts_estree_1.AST_NODE_TYPES.FunctionDeclaration,</span>
                    <span class="s1">id: </span><span class="s2">this</span><span class="s1">.convertChild(node.name),</span>
                    <span class="s1">generator: !!node.asteriskToken,</span>
                    <span class="s1">expression: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">async: (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.AsyncKeyword, node),</span>
                    <span class="s1">params: </span><span class="s2">this</span><span class="s1">.convertParameters(node.parameters),</span>
                    <span class="s1">body: </span><span class="s2">this</span><span class="s1">.convertChild(node.body) || undefined,</span>
                <span class="s1">});</span>
                <span class="s4">// Process returnType</span>
                <span class="s2">if </span><span class="s1">(node.type) {</span>
                    <span class="s1">result.returnType = </span><span class="s2">this</span><span class="s1">.convertTypeAnnotation(node.type, node);</span>
                <span class="s1">}</span>
                <span class="s4">// Process typeParameters</span>
                <span class="s2">if </span><span class="s1">(node.typeParameters) {</span>
                    <span class="s1">result.typeParameters =</span>
                        <span class="s2">this</span><span class="s1">.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(isDeclare) {</span>
                    <span class="s1">result.declare = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s4">// check for exports</span>
                <span class="s2">return this</span><span class="s1">.fixExports(node, result);</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.VariableDeclaration: {</span>
                <span class="s1">const result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.VariableDeclarator,</span>
                    <span class="s1">id: </span><span class="s2">this</span><span class="s1">.convertBindingNameWithTypeAnnotation(node.name, node.type, node),</span>
                    <span class="s1">init: </span><span class="s2">this</span><span class="s1">.convertChild(node.initializer),</span>
                <span class="s1">});</span>
                <span class="s2">if </span><span class="s1">(node.exclamationToken) {</span>
                    <span class="s1">result.definite = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">result;</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.VariableStatement: {</span>
                <span class="s1">const result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.VariableDeclaration,</span>
                    <span class="s1">declarations: node.declarationList.declarations.map(el =&gt; </span><span class="s2">this</span><span class="s1">.convertChild(el)),</span>
                    <span class="s1">kind: (</span><span class="s3">0</span><span class="s1">, node_utils_1.getDeclarationKind)(node.declarationList),</span>
                <span class="s1">});</span>
                <span class="s4">/** 
                 * Semantically, decorators are not allowed on variable declarations, 
                 * Pre 4.8 TS would include them in the AST, so we did as well. 
                 * However as of 4.8 TS no longer includes it (as it is, well, invalid). 
                 * 
                 * So for consistency across versions, we no longer include it either. 
                 */</span>
                <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.DeclareKeyword, node)) {</span>
                    <span class="s1">result.declare = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s4">// check for exports</span>
                <span class="s2">return this</span><span class="s1">.fixExports(node, result);</span>
            <span class="s1">}</span>
            <span class="s4">// mostly for for-of, for-in</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.VariableDeclarationList:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.VariableDeclaration,</span>
                    <span class="s1">declarations: node.declarations.map(el =&gt; </span><span class="s2">this</span><span class="s1">.convertChild(el)),</span>
                    <span class="s1">kind: (</span><span class="s3">0</span><span class="s1">, node_utils_1.getDeclarationKind)(node),</span>
                <span class="s1">});</span>
            <span class="s4">// Expressions</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ExpressionStatement:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ExpressionStatement,</span>
                    <span class="s1">expression: </span><span class="s2">this</span><span class="s1">.convertChild(node.expression),</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ThisKeyword:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ThisExpression,</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ArrayLiteralExpression: {</span>
                <span class="s4">// TypeScript uses ArrayLiteralExpression in destructuring assignment, too</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.allowPattern) {</span>
                    <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ArrayPattern,</span>
                        <span class="s1">elements: node.elements.map(el =&gt; </span><span class="s2">this</span><span class="s1">.convertPattern(el)),</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ArrayExpression,</span>
                        <span class="s1">elements: node.elements.map(el =&gt; </span><span class="s2">this</span><span class="s1">.convertChild(el)),</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ObjectLiteralExpression: {</span>
                <span class="s4">// TypeScript uses ObjectLiteralExpression in destructuring assignment, too</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.allowPattern) {</span>
                    <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ObjectPattern,</span>
                        <span class="s1">properties: node.properties.map(el =&gt; </span><span class="s2">this</span><span class="s1">.convertPattern(el)),</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ObjectExpression,</span>
                        <span class="s1">properties: node.properties.map(el =&gt; </span><span class="s2">this</span><span class="s1">.convertChild(el)),</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.PropertyAssignment:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.Property,</span>
                    <span class="s1">key: </span><span class="s2">this</span><span class="s1">.convertChild(node.name),</span>
                    <span class="s1">value: </span><span class="s2">this</span><span class="s1">.converter(node.initializer, node, </span><span class="s2">this</span><span class="s1">.inTypeMode, </span><span class="s2">this</span><span class="s1">.allowPattern),</span>
                    <span class="s1">computed: (</span><span class="s3">0</span><span class="s1">, node_utils_1.isComputedProperty)(node.name),</span>
                    <span class="s1">method: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">shorthand: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">kind: </span><span class="s0">'init'</span><span class="s1">,</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ShorthandPropertyAssignment: {</span>
                <span class="s2">if </span><span class="s1">(node.objectAssignmentInitializer) {</span>
                    <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.Property,</span>
                        <span class="s1">key: </span><span class="s2">this</span><span class="s1">.convertChild(node.name),</span>
                        <span class="s1">value: </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                            <span class="s1">type: ts_estree_1.AST_NODE_TYPES.AssignmentPattern,</span>
                            <span class="s1">left: </span><span class="s2">this</span><span class="s1">.convertPattern(node.name),</span>
                            <span class="s1">right: </span><span class="s2">this</span><span class="s1">.convertChild(node.objectAssignmentInitializer),</span>
                        <span class="s1">}),</span>
                        <span class="s1">computed: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">method: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">shorthand: </span><span class="s2">true</span><span class="s1">,</span>
                        <span class="s1">kind: </span><span class="s0">'init'</span><span class="s1">,</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.Property,</span>
                        <span class="s1">key: </span><span class="s2">this</span><span class="s1">.convertChild(node.name),</span>
                        <span class="s1">value: </span><span class="s2">this</span><span class="s1">.convertChild(node.name),</span>
                        <span class="s1">computed: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">method: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">shorthand: </span><span class="s2">true</span><span class="s1">,</span>
                        <span class="s1">kind: </span><span class="s0">'init'</span><span class="s1">,</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ComputedPropertyName:</span>
                <span class="s2">return this</span><span class="s1">.convertChild(node.expression);</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.PropertyDeclaration: {</span>
                <span class="s1">const isAbstract = (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.AbstractKeyword, node);</span>
                <span class="s1">const isAccessor = (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.AccessorKeyword, node);</span>
                <span class="s4">// eslint-disable-next-line @typescript-eslint/explicit-function-return-type -- TODO - add ignore IIFE option</span>
                <span class="s1">const type = (() =&gt; {</span>
                    <span class="s2">if </span><span class="s1">(isAccessor) {</span>
                        <span class="s2">if </span><span class="s1">(isAbstract) {</span>
                            <span class="s2">return </span><span class="s1">ts_estree_1.AST_NODE_TYPES.TSAbstractAccessorProperty;</span>
                        <span class="s1">}</span>
                        <span class="s2">return </span><span class="s1">ts_estree_1.AST_NODE_TYPES.AccessorProperty;</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">(isAbstract) {</span>
                        <span class="s2">return </span><span class="s1">ts_estree_1.AST_NODE_TYPES.TSAbstractPropertyDefinition;</span>
                    <span class="s1">}</span>
                    <span class="s2">return </span><span class="s1">ts_estree_1.AST_NODE_TYPES.PropertyDefinition;</span>
                <span class="s1">})();</span>
                <span class="s1">const result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type,</span>
                    <span class="s1">key: </span><span class="s2">this</span><span class="s1">.convertChild(node.name),</span>
                    <span class="s1">value: isAbstract ? </span><span class="s2">null </span><span class="s1">: </span><span class="s2">this</span><span class="s1">.convertChild(node.initializer),</span>
                    <span class="s1">computed: (</span><span class="s3">0</span><span class="s1">, node_utils_1.isComputedProperty)(node.name),</span>
                    <span class="s1">static: (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.StaticKeyword, node),</span>
                    <span class="s1">readonly: (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.ReadonlyKeyword, node) || undefined,</span>
                    <span class="s1">declare: (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.DeclareKeyword, node),</span>
                    <span class="s1">override: (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.OverrideKeyword, node),</span>
                <span class="s1">});</span>
                <span class="s2">if </span><span class="s1">(node.type) {</span>
                    <span class="s1">result.typeAnnotation = </span><span class="s2">this</span><span class="s1">.convertTypeAnnotation(node.type, node);</span>
                <span class="s1">}</span>
                <span class="s1">const decorators = (</span><span class="s3">0</span><span class="s1">, getModifiers_1.getDecorators)(node);</span>
                <span class="s2">if </span><span class="s1">(decorators) {</span>
                    <span class="s1">result.decorators = decorators.map(el =&gt; </span><span class="s2">this</span><span class="s1">.convertChild(el));</span>
                <span class="s1">}</span>
                <span class="s1">const accessibility = (</span><span class="s3">0</span><span class="s1">, node_utils_1.getTSNodeAccessibility)(node);</span>
                <span class="s2">if </span><span class="s1">(accessibility) {</span>
                    <span class="s1">result.accessibility = accessibility;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">((node.name.kind === SyntaxKind.Identifier ||</span>
                    <span class="s1">node.name.kind === SyntaxKind.ComputedPropertyName ||</span>
                    <span class="s1">node.name.kind === SyntaxKind.PrivateIdentifier) &amp;&amp;</span>
                    <span class="s1">node.questionToken) {</span>
                    <span class="s1">result.optional = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(node.exclamationToken) {</span>
                    <span class="s1">result.definite = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(result.key.type === ts_estree_1.AST_NODE_TYPES.Literal &amp;&amp; node.questionToken) {</span>
                    <span class="s1">result.optional = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">result;</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.GetAccessor:</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.SetAccessor: {</span>
                <span class="s2">if </span><span class="s1">(node.parent.kind === SyntaxKind.InterfaceDeclaration ||</span>
                    <span class="s1">node.parent.kind === SyntaxKind.TypeLiteral) {</span>
                    <span class="s2">return this</span><span class="s1">.convertMethodSignature(node);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s4">// otherwise, it is a non-type accessor - intentional fallthrough</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.MethodDeclaration: {</span>
                <span class="s1">const method = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: !node.body</span>
                        <span class="s1">? ts_estree_1.AST_NODE_TYPES.TSEmptyBodyFunctionExpression</span>
                        <span class="s1">: ts_estree_1.AST_NODE_TYPES.FunctionExpression,</span>
                    <span class="s1">id: </span><span class="s2">null</span><span class="s1">,</span>
                    <span class="s1">generator: !!node.asteriskToken,</span>
                    <span class="s1">expression: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">async: (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.AsyncKeyword, node),</span>
                    <span class="s1">body: </span><span class="s2">this</span><span class="s1">.convertChild(node.body),</span>
                    <span class="s1">range: [node.parameters.pos - </span><span class="s3">1</span><span class="s1">, node.end],</span>
                    <span class="s1">params: [],</span>
                <span class="s1">});</span>
                <span class="s2">if </span><span class="s1">(node.type) {</span>
                    <span class="s1">method.returnType = </span><span class="s2">this</span><span class="s1">.convertTypeAnnotation(node.type, node);</span>
                <span class="s1">}</span>
                <span class="s4">// Process typeParameters</span>
                <span class="s2">if </span><span class="s1">(node.typeParameters) {</span>
                    <span class="s1">method.typeParameters =</span>
                        <span class="s2">this</span><span class="s1">.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);</span>
                    <span class="s2">this</span><span class="s1">.fixParentLocation(method, method.typeParameters.range);</span>
                <span class="s1">}</span>
                <span class="s1">let result;</span>
                <span class="s2">if </span><span class="s1">(parent.kind === SyntaxKind.ObjectLiteralExpression) {</span>
                    <span class="s1">method.params = node.parameters.map(el =&gt; </span><span class="s2">this</span><span class="s1">.convertChild(el));</span>
                    <span class="s1">result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.Property,</span>
                        <span class="s1">key: </span><span class="s2">this</span><span class="s1">.convertChild(node.name),</span>
                        <span class="s1">value: method,</span>
                        <span class="s1">computed: (</span><span class="s3">0</span><span class="s1">, node_utils_1.isComputedProperty)(node.name),</span>
                        <span class="s1">method: node.kind === SyntaxKind.MethodDeclaration,</span>
                        <span class="s1">shorthand: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">kind: </span><span class="s0">'init'</span><span class="s1">,</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s4">// class</span>
                    <span class="s4">/** 
                     * Unlike in object literal methods, class method params can have decorators 
                     */</span>
                    <span class="s1">method.params = </span><span class="s2">this</span><span class="s1">.convertParameters(node.parameters);</span>
                    <span class="s4">/** 
                     * TypeScript class methods can be defined as &quot;abstract&quot; 
                     */</span>
                    <span class="s1">const methodDefinitionType = (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.AbstractKeyword, node)</span>
                        <span class="s1">? ts_estree_1.AST_NODE_TYPES.TSAbstractMethodDefinition</span>
                        <span class="s1">: ts_estree_1.AST_NODE_TYPES.MethodDefinition;</span>
                    <span class="s1">result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type: methodDefinitionType,</span>
                        <span class="s1">key: </span><span class="s2">this</span><span class="s1">.convertChild(node.name),</span>
                        <span class="s1">value: method,</span>
                        <span class="s1">computed: (</span><span class="s3">0</span><span class="s1">, node_utils_1.isComputedProperty)(node.name),</span>
                        <span class="s1">static: (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.StaticKeyword, node),</span>
                        <span class="s1">kind: </span><span class="s0">'method'</span><span class="s1">,</span>
                        <span class="s1">override: (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.OverrideKeyword, node),</span>
                    <span class="s1">});</span>
                    <span class="s1">const decorators = (</span><span class="s3">0</span><span class="s1">, getModifiers_1.getDecorators)(node);</span>
                    <span class="s2">if </span><span class="s1">(decorators) {</span>
                        <span class="s1">result.decorators = decorators.map(el =&gt; </span><span class="s2">this</span><span class="s1">.convertChild(el));</span>
                    <span class="s1">}</span>
                    <span class="s1">const accessibility = (</span><span class="s3">0</span><span class="s1">, node_utils_1.getTSNodeAccessibility)(node);</span>
                    <span class="s2">if </span><span class="s1">(accessibility) {</span>
                        <span class="s1">result.accessibility = accessibility;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(node.questionToken) {</span>
                    <span class="s1">result.optional = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(node.kind === SyntaxKind.GetAccessor) {</span>
                    <span class="s1">result.kind = </span><span class="s0">'get'</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(node.kind === SyntaxKind.SetAccessor) {</span>
                    <span class="s1">result.kind = </span><span class="s0">'set'</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(!result.static &amp;&amp;</span>
                    <span class="s1">node.name.kind === SyntaxKind.StringLiteral &amp;&amp;</span>
                    <span class="s1">node.name.text === </span><span class="s0">'constructor' </span><span class="s1">&amp;&amp;</span>
                    <span class="s1">result.type !== ts_estree_1.AST_NODE_TYPES.Property) {</span>
                    <span class="s1">result.kind = </span><span class="s0">'constructor'</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">result;</span>
            <span class="s1">}</span>
            <span class="s4">// TypeScript uses this even for static methods named &quot;constructor&quot;</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.Constructor: {</span>
                <span class="s1">const lastModifier = (</span><span class="s3">0</span><span class="s1">, node_utils_1.getLastModifier)(node);</span>
                <span class="s1">const constructorToken = (lastModifier &amp;&amp; (</span><span class="s3">0</span><span class="s1">, node_utils_1.findNextToken)(lastModifier, node, </span><span class="s2">this</span><span class="s1">.ast)) ||</span>
                    <span class="s1">node.getFirstToken();</span>
                <span class="s1">const constructor = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: !node.body</span>
                        <span class="s1">? ts_estree_1.AST_NODE_TYPES.TSEmptyBodyFunctionExpression</span>
                        <span class="s1">: ts_estree_1.AST_NODE_TYPES.FunctionExpression,</span>
                    <span class="s1">id: </span><span class="s2">null</span><span class="s1">,</span>
                    <span class="s1">params: </span><span class="s2">this</span><span class="s1">.convertParameters(node.parameters),</span>
                    <span class="s1">generator: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">expression: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">async: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">body: </span><span class="s2">this</span><span class="s1">.convertChild(node.body),</span>
                    <span class="s1">range: [node.parameters.pos - </span><span class="s3">1</span><span class="s1">, node.end],</span>
                <span class="s1">});</span>
                <span class="s4">// Process typeParameters</span>
                <span class="s2">if </span><span class="s1">(node.typeParameters) {</span>
                    <span class="s1">constructor.typeParameters =</span>
                        <span class="s2">this</span><span class="s1">.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);</span>
                    <span class="s2">this</span><span class="s1">.fixParentLocation(constructor, constructor.typeParameters.range);</span>
                <span class="s1">}</span>
                <span class="s4">// Process returnType</span>
                <span class="s2">if </span><span class="s1">(node.type) {</span>
                    <span class="s1">constructor.returnType = </span><span class="s2">this</span><span class="s1">.convertTypeAnnotation(node.type, node);</span>
                <span class="s1">}</span>
                <span class="s1">const constructorKey = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.Identifier,</span>
                    <span class="s1">name: </span><span class="s0">'constructor'</span><span class="s1">,</span>
                    <span class="s1">range: [constructorToken.getStart(</span><span class="s2">this</span><span class="s1">.ast), constructorToken.end],</span>
                <span class="s1">});</span>
                <span class="s1">const isStatic = (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.StaticKeyword, node);</span>
                <span class="s1">const result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.AbstractKeyword, node)</span>
                        <span class="s1">? ts_estree_1.AST_NODE_TYPES.TSAbstractMethodDefinition</span>
                        <span class="s1">: ts_estree_1.AST_NODE_TYPES.MethodDefinition,</span>
                    <span class="s1">key: constructorKey,</span>
                    <span class="s1">value: constructor,</span>
                    <span class="s1">computed: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">static: isStatic,</span>
                    <span class="s1">kind: isStatic ? </span><span class="s0">'method' </span><span class="s1">: </span><span class="s0">'constructor'</span><span class="s1">,</span>
                    <span class="s1">override: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">});</span>
                <span class="s1">const accessibility = (</span><span class="s3">0</span><span class="s1">, node_utils_1.getTSNodeAccessibility)(node);</span>
                <span class="s2">if </span><span class="s1">(accessibility) {</span>
                    <span class="s1">result.accessibility = accessibility;</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">result;</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.FunctionExpression: {</span>
                <span class="s1">const result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.FunctionExpression,</span>
                    <span class="s1">id: </span><span class="s2">this</span><span class="s1">.convertChild(node.name),</span>
                    <span class="s1">generator: !!node.asteriskToken,</span>
                    <span class="s1">params: </span><span class="s2">this</span><span class="s1">.convertParameters(node.parameters),</span>
                    <span class="s1">body: </span><span class="s2">this</span><span class="s1">.convertChild(node.body),</span>
                    <span class="s1">async: (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.AsyncKeyword, node),</span>
                    <span class="s1">expression: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">});</span>
                <span class="s4">// Process returnType</span>
                <span class="s2">if </span><span class="s1">(node.type) {</span>
                    <span class="s1">result.returnType = </span><span class="s2">this</span><span class="s1">.convertTypeAnnotation(node.type, node);</span>
                <span class="s1">}</span>
                <span class="s4">// Process typeParameters</span>
                <span class="s2">if </span><span class="s1">(node.typeParameters) {</span>
                    <span class="s1">result.typeParameters =</span>
                        <span class="s2">this</span><span class="s1">.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">result;</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.SuperKeyword:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.Super,</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ArrayBindingPattern:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ArrayPattern,</span>
                    <span class="s1">elements: node.elements.map(el =&gt; </span><span class="s2">this</span><span class="s1">.convertPattern(el)),</span>
                <span class="s1">});</span>
            <span class="s4">// occurs with missing array elements like [,]</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.OmittedExpression:</span>
                <span class="s2">return null</span><span class="s1">;</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ObjectBindingPattern:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ObjectPattern,</span>
                    <span class="s1">properties: node.elements.map(el =&gt; </span><span class="s2">this</span><span class="s1">.convertPattern(el)),</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.BindingElement: {</span>
                <span class="s2">if </span><span class="s1">(parent.kind === SyntaxKind.ArrayBindingPattern) {</span>
                    <span class="s1">const arrayItem = </span><span class="s2">this</span><span class="s1">.convertChild(node.name, parent);</span>
                    <span class="s2">if </span><span class="s1">(node.initializer) {</span>
                        <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                            <span class="s1">type: ts_estree_1.AST_NODE_TYPES.AssignmentPattern,</span>
                            <span class="s1">left: arrayItem,</span>
                            <span class="s1">right: </span><span class="s2">this</span><span class="s1">.convertChild(node.initializer),</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                    <span class="s2">else if </span><span class="s1">(node.dotDotDotToken) {</span>
                        <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                            <span class="s1">type: ts_estree_1.AST_NODE_TYPES.RestElement,</span>
                            <span class="s1">argument: arrayItem,</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                    <span class="s2">else </span><span class="s1">{</span>
                        <span class="s2">return </span><span class="s1">arrayItem;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">let result;</span>
                    <span class="s2">if </span><span class="s1">(node.dotDotDotToken) {</span>
                        <span class="s1">result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                            <span class="s1">type: ts_estree_1.AST_NODE_TYPES.RestElement,</span>
                            <span class="s1">argument: </span><span class="s2">this</span><span class="s1">.convertChild((_a = node.propertyName) !== </span><span class="s2">null </span><span class="s1">&amp;&amp; _a !== </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? _a : node.name),</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                    <span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                            <span class="s1">type: ts_estree_1.AST_NODE_TYPES.Property,</span>
                            <span class="s1">key: </span><span class="s2">this</span><span class="s1">.convertChild((_b = node.propertyName) !== </span><span class="s2">null </span><span class="s1">&amp;&amp; _b !== </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? _b : node.name),</span>
                            <span class="s1">value: </span><span class="s2">this</span><span class="s1">.convertChild(node.name),</span>
                            <span class="s1">computed: Boolean(node.propertyName &amp;&amp;</span>
                                <span class="s1">node.propertyName.kind === SyntaxKind.ComputedPropertyName),</span>
                            <span class="s1">method: </span><span class="s2">false</span><span class="s1">,</span>
                            <span class="s1">shorthand: !node.propertyName,</span>
                            <span class="s1">kind: </span><span class="s0">'init'</span><span class="s1">,</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">(node.initializer) {</span>
                        <span class="s1">result.value = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                            <span class="s1">type: ts_estree_1.AST_NODE_TYPES.AssignmentPattern,</span>
                            <span class="s1">left: </span><span class="s2">this</span><span class="s1">.convertChild(node.name),</span>
                            <span class="s1">right: </span><span class="s2">this</span><span class="s1">.convertChild(node.initializer),</span>
                            <span class="s1">range: [node.name.getStart(</span><span class="s2">this</span><span class="s1">.ast), node.initializer.end],</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                    <span class="s2">return </span><span class="s1">result;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ArrowFunction: {</span>
                <span class="s1">const result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ArrowFunctionExpression,</span>
                    <span class="s1">generator: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">id: </span><span class="s2">null</span><span class="s1">,</span>
                    <span class="s1">params: </span><span class="s2">this</span><span class="s1">.convertParameters(node.parameters),</span>
                    <span class="s1">body: </span><span class="s2">this</span><span class="s1">.convertChild(node.body),</span>
                    <span class="s1">async: (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.AsyncKeyword, node),</span>
                    <span class="s1">expression: node.body.kind !== SyntaxKind.Block,</span>
                <span class="s1">});</span>
                <span class="s4">// Process returnType</span>
                <span class="s2">if </span><span class="s1">(node.type) {</span>
                    <span class="s1">result.returnType = </span><span class="s2">this</span><span class="s1">.convertTypeAnnotation(node.type, node);</span>
                <span class="s1">}</span>
                <span class="s4">// Process typeParameters</span>
                <span class="s2">if </span><span class="s1">(node.typeParameters) {</span>
                    <span class="s1">result.typeParameters =</span>
                        <span class="s2">this</span><span class="s1">.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">result;</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.YieldExpression:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.YieldExpression,</span>
                    <span class="s1">delegate: !!node.asteriskToken,</span>
                    <span class="s1">argument: </span><span class="s2">this</span><span class="s1">.convertChild(node.expression),</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.AwaitExpression:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.AwaitExpression,</span>
                    <span class="s1">argument: </span><span class="s2">this</span><span class="s1">.convertChild(node.expression),</span>
                <span class="s1">});</span>
            <span class="s4">// Template Literals</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.NoSubstitutionTemplateLiteral:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TemplateLiteral,</span>
                    <span class="s1">quasis: [</span>
                        <span class="s2">this</span><span class="s1">.createNode(node, {</span>
                            <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TemplateElement,</span>
                            <span class="s1">value: {</span>
                                <span class="s1">raw: </span><span class="s2">this</span><span class="s1">.ast.text.slice(node.getStart(</span><span class="s2">this</span><span class="s1">.ast) + </span><span class="s3">1</span><span class="s1">, node.end - </span><span class="s3">1</span><span class="s1">),</span>
                                <span class="s1">cooked: node.text,</span>
                            <span class="s1">},</span>
                            <span class="s1">tail: </span><span class="s2">true</span><span class="s1">,</span>
                        <span class="s1">}),</span>
                    <span class="s1">],</span>
                    <span class="s1">expressions: [],</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.TemplateExpression: {</span>
                <span class="s1">const result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TemplateLiteral,</span>
                    <span class="s1">quasis: [</span><span class="s2">this</span><span class="s1">.convertChild(node.head)],</span>
                    <span class="s1">expressions: [],</span>
                <span class="s1">});</span>
                <span class="s1">node.templateSpans.forEach(templateSpan =&gt; {</span>
                    <span class="s1">result.expressions.push(</span><span class="s2">this</span><span class="s1">.convertChild(templateSpan.expression));</span>
                    <span class="s1">result.quasis.push(</span><span class="s2">this</span><span class="s1">.convertChild(templateSpan.literal));</span>
                <span class="s1">});</span>
                <span class="s2">return </span><span class="s1">result;</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.TaggedTemplateExpression:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TaggedTemplateExpression,</span>
                    <span class="s1">typeParameters: node.typeArguments</span>
                        <span class="s1">? </span><span class="s2">this</span><span class="s1">.convertTypeArgumentsToTypeParameters(node.typeArguments, node)</span>
                        <span class="s1">: undefined,</span>
                    <span class="s1">tag: </span><span class="s2">this</span><span class="s1">.convertChild(node.tag),</span>
                    <span class="s1">quasi: </span><span class="s2">this</span><span class="s1">.convertChild(node.template),</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.TemplateHead:</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.TemplateMiddle:</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.TemplateTail: {</span>
                <span class="s1">const tail = node.kind === SyntaxKind.TemplateTail;</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TemplateElement,</span>
                    <span class="s1">value: {</span>
                        <span class="s1">raw: </span><span class="s2">this</span><span class="s1">.ast.text.slice(node.getStart(</span><span class="s2">this</span><span class="s1">.ast) + </span><span class="s3">1</span><span class="s1">, node.end - (tail ? </span><span class="s3">1 </span><span class="s1">: </span><span class="s3">2</span><span class="s1">)),</span>
                        <span class="s1">cooked: node.text,</span>
                    <span class="s1">},</span>
                    <span class="s1">tail,</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s4">// Patterns</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.SpreadAssignment:</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.SpreadElement: {</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.allowPattern) {</span>
                    <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.RestElement,</span>
                        <span class="s1">argument: </span><span class="s2">this</span><span class="s1">.convertPattern(node.expression),</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.SpreadElement,</span>
                        <span class="s1">argument: </span><span class="s2">this</span><span class="s1">.convertChild(node.expression),</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.Parameter: {</span>
                <span class="s1">let parameter;</span>
                <span class="s1">let result;</span>
                <span class="s2">if </span><span class="s1">(node.dotDotDotToken) {</span>
                    <span class="s1">parameter = result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.RestElement,</span>
                        <span class="s1">argument: </span><span class="s2">this</span><span class="s1">.convertChild(node.name),</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(node.initializer) {</span>
                    <span class="s1">parameter = </span><span class="s2">this</span><span class="s1">.convertChild(node.name);</span>
                    <span class="s1">result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.AssignmentPattern,</span>
                        <span class="s1">left: parameter,</span>
                        <span class="s1">right: </span><span class="s2">this</span><span class="s1">.convertChild(node.initializer),</span>
                    <span class="s1">});</span>
                    <span class="s1">const modifiers = (</span><span class="s3">0</span><span class="s1">, getModifiers_1.getModifiers)(node);</span>
                    <span class="s2">if </span><span class="s1">(modifiers) {</span>
                        <span class="s4">// AssignmentPattern should not contain modifiers in range</span>
                        <span class="s1">result.range[</span><span class="s3">0</span><span class="s1">] = parameter.range[</span><span class="s3">0</span><span class="s1">];</span>
                        <span class="s1">result.loc = (</span><span class="s3">0</span><span class="s1">, node_utils_1.getLocFor)(result.range[</span><span class="s3">0</span><span class="s1">], result.range[</span><span class="s3">1</span><span class="s1">], </span><span class="s2">this</span><span class="s1">.ast);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">parameter = result = </span><span class="s2">this</span><span class="s1">.convertChild(node.name, parent);</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(node.type) {</span>
                    <span class="s1">parameter.typeAnnotation = </span><span class="s2">this</span><span class="s1">.convertTypeAnnotation(node.type, node);</span>
                    <span class="s2">this</span><span class="s1">.fixParentLocation(parameter, parameter.typeAnnotation.range);</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(node.questionToken) {</span>
                    <span class="s2">if </span><span class="s1">(node.questionToken.end &gt; parameter.range[</span><span class="s3">1</span><span class="s1">]) {</span>
                        <span class="s1">parameter.range[</span><span class="s3">1</span><span class="s1">] = node.questionToken.end;</span>
                        <span class="s1">parameter.loc.end = (</span><span class="s3">0</span><span class="s1">, node_utils_1.getLineAndCharacterFor)(parameter.range[</span><span class="s3">1</span><span class="s1">], </span><span class="s2">this</span><span class="s1">.ast);</span>
                    <span class="s1">}</span>
                    <span class="s1">parameter.optional = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s1">const modifiers = (</span><span class="s3">0</span><span class="s1">, getModifiers_1.getModifiers)(node);</span>
                <span class="s2">if </span><span class="s1">(modifiers) {</span>
                    <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSParameterProperty,</span>
                        <span class="s1">accessibility: (_c = (</span><span class="s3">0</span><span class="s1">, node_utils_1.getTSNodeAccessibility)(node)) !== </span><span class="s2">null </span><span class="s1">&amp;&amp; _c !== </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? _c : undefined,</span>
                        <span class="s1">readonly: (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.ReadonlyKeyword, node) || undefined,</span>
                        <span class="s1">static: (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.StaticKeyword, node) || undefined,</span>
                        <span class="s1">export: (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.ExportKeyword, node) || undefined,</span>
                        <span class="s1">override: (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.OverrideKeyword, node) || undefined,</span>
                        <span class="s1">parameter: result,</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">result;</span>
            <span class="s1">}</span>
            <span class="s4">// Classes</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ClassDeclaration:</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ClassExpression: {</span>
                <span class="s1">const heritageClauses = (_d = node.heritageClauses) !== </span><span class="s2">null </span><span class="s1">&amp;&amp; _d !== </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? _d : [];</span>
                <span class="s1">const classNodeType = node.kind === SyntaxKind.ClassDeclaration</span>
                    <span class="s1">? ts_estree_1.AST_NODE_TYPES.ClassDeclaration</span>
                    <span class="s1">: ts_estree_1.AST_NODE_TYPES.ClassExpression;</span>
                <span class="s1">const superClass = heritageClauses.find(clause =&gt; clause.token === SyntaxKind.ExtendsKeyword);</span>
                <span class="s1">const implementsClause = heritageClauses.find(clause =&gt; clause.token === SyntaxKind.ImplementsKeyword);</span>
                <span class="s1">const result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: classNodeType,</span>
                    <span class="s1">id: </span><span class="s2">this</span><span class="s1">.convertChild(node.name),</span>
                    <span class="s1">body: </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ClassBody,</span>
                        <span class="s1">body: [],</span>
                        <span class="s1">range: [node.members.pos - </span><span class="s3">1</span><span class="s1">, node.end],</span>
                    <span class="s1">}),</span>
                    <span class="s1">superClass: (superClass === </span><span class="s2">null </span><span class="s1">|| superClass === </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: superClass.types[</span><span class="s3">0</span><span class="s1">])</span>
                        <span class="s1">? </span><span class="s2">this</span><span class="s1">.convertChild(superClass.types[</span><span class="s3">0</span><span class="s1">].expression)</span>
                        <span class="s1">: </span><span class="s2">null</span><span class="s1">,</span>
                <span class="s1">});</span>
                <span class="s2">if </span><span class="s1">(superClass) {</span>
                    <span class="s2">if </span><span class="s1">(superClass.types.length &gt; </span><span class="s3">1</span><span class="s1">) {</span>
                        <span class="s2">throw </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, node_utils_1.createError)(</span><span class="s2">this</span><span class="s1">.ast, superClass.types[</span><span class="s3">1</span><span class="s1">].pos, </span><span class="s0">'Classes can only extend a single class.'</span><span class="s1">);</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">((_e = superClass.types[</span><span class="s3">0</span><span class="s1">]) === </span><span class="s2">null </span><span class="s1">|| _e === </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _e.typeArguments) {</span>
                        <span class="s1">result.superTypeParameters =</span>
                            <span class="s2">this</span><span class="s1">.convertTypeArgumentsToTypeParameters(superClass.types[</span><span class="s3">0</span><span class="s1">].typeArguments, superClass.types[</span><span class="s3">0</span><span class="s1">]);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(node.typeParameters) {</span>
                    <span class="s1">result.typeParameters =</span>
                        <span class="s2">this</span><span class="s1">.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(implementsClause) {</span>
                    <span class="s1">result.implements = implementsClause.types.map(el =&gt; </span><span class="s2">this</span><span class="s1">.convertChild(el));</span>
                <span class="s1">}</span>
                <span class="s4">/** 
                 * TypeScript class declarations can be defined as &quot;abstract&quot; 
                 */</span>
                <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.AbstractKeyword, node)) {</span>
                    <span class="s1">result.abstract = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.DeclareKeyword, node)) {</span>
                    <span class="s1">result.declare = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s1">const decorators = (</span><span class="s3">0</span><span class="s1">, getModifiers_1.getDecorators)(node);</span>
                <span class="s2">if </span><span class="s1">(decorators) {</span>
                    <span class="s1">result.decorators = decorators.map(el =&gt; </span><span class="s2">this</span><span class="s1">.convertChild(el));</span>
                <span class="s1">}</span>
                <span class="s1">const filteredMembers = node.members.filter(node_utils_1.isESTreeClassMember);</span>
                <span class="s2">if </span><span class="s1">(filteredMembers.length) {</span>
                    <span class="s1">result.body.body = filteredMembers.map(el =&gt; </span><span class="s2">this</span><span class="s1">.convertChild(el));</span>
                <span class="s1">}</span>
                <span class="s4">// check for exports</span>
                <span class="s2">return this</span><span class="s1">.fixExports(node, result);</span>
            <span class="s1">}</span>
            <span class="s4">// Modules</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ModuleBlock:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSModuleBlock,</span>
                    <span class="s1">body: </span><span class="s2">this</span><span class="s1">.convertBodyExpressions(node.statements, node),</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ImportDeclaration: {</span>
                <span class="s2">this</span><span class="s1">.assertModuleSpecifier(node, </span><span class="s2">false</span><span class="s1">);</span>
                <span class="s1">const result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ImportDeclaration,</span>
                    <span class="s1">source: </span><span class="s2">this</span><span class="s1">.convertChild(node.moduleSpecifier),</span>
                    <span class="s1">specifiers: [],</span>
                    <span class="s1">importKind: </span><span class="s0">'value'</span><span class="s1">,</span>
                    <span class="s1">assertions: </span><span class="s2">this</span><span class="s1">.convertAssertClasue(node.assertClause),</span>
                <span class="s1">});</span>
                <span class="s2">if </span><span class="s1">(node.importClause) {</span>
                    <span class="s2">if </span><span class="s1">(node.importClause.isTypeOnly) {</span>
                        <span class="s1">result.importKind = </span><span class="s0">'type'</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">(node.importClause.name) {</span>
                        <span class="s1">result.specifiers.push(</span><span class="s2">this</span><span class="s1">.convertChild(node.importClause));</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">(node.importClause.namedBindings) {</span>
                        <span class="s2">switch </span><span class="s1">(node.importClause.namedBindings.kind) {</span>
                            <span class="s2">case </span><span class="s1">SyntaxKind.NamespaceImport:</span>
                                <span class="s1">result.specifiers.push(</span><span class="s2">this</span><span class="s1">.convertChild(node.importClause.namedBindings));</span>
                                <span class="s2">break</span><span class="s1">;</span>
                            <span class="s2">case </span><span class="s1">SyntaxKind.NamedImports:</span>
                                <span class="s1">result.specifiers = result.specifiers.concat(node.importClause.namedBindings.elements.map(el =&gt; </span><span class="s2">this</span><span class="s1">.convertChild(el)));</span>
                                <span class="s2">break</span><span class="s1">;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">result;</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.NamespaceImport:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ImportNamespaceSpecifier,</span>
                    <span class="s1">local: </span><span class="s2">this</span><span class="s1">.convertChild(node.name),</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ImportSpecifier:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ImportSpecifier,</span>
                    <span class="s1">local: </span><span class="s2">this</span><span class="s1">.convertChild(node.name),</span>
                    <span class="s1">imported: </span><span class="s2">this</span><span class="s1">.convertChild((_f = node.propertyName) !== </span><span class="s2">null </span><span class="s1">&amp;&amp; _f !== </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? _f : node.name),</span>
                    <span class="s1">importKind: node.isTypeOnly ? </span><span class="s0">'type' </span><span class="s1">: </span><span class="s0">'value'</span><span class="s1">,</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ImportClause: {</span>
                <span class="s1">const local = </span><span class="s2">this</span><span class="s1">.convertChild(node.name);</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ImportDefaultSpecifier,</span>
                    <span class="s1">local,</span>
                    <span class="s1">range: local.range,</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ExportDeclaration: {</span>
                <span class="s2">if </span><span class="s1">(((_g = node.exportClause) === </span><span class="s2">null </span><span class="s1">|| _g === </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _g.kind) === SyntaxKind.NamedExports) {</span>
                    <span class="s2">this</span><span class="s1">.assertModuleSpecifier(node, </span><span class="s2">true</span><span class="s1">);</span>
                    <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ExportNamedDeclaration,</span>
                        <span class="s1">source: </span><span class="s2">this</span><span class="s1">.convertChild(node.moduleSpecifier),</span>
                        <span class="s1">specifiers: node.exportClause.elements.map(el =&gt; </span><span class="s2">this</span><span class="s1">.convertChild(el)),</span>
                        <span class="s1">exportKind: node.isTypeOnly ? </span><span class="s0">'type' </span><span class="s1">: </span><span class="s0">'value'</span><span class="s1">,</span>
                        <span class="s1">declaration: </span><span class="s2">null</span><span class="s1">,</span>
                        <span class="s1">assertions: </span><span class="s2">this</span><span class="s1">.convertAssertClasue(node.assertClause),</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s2">this</span><span class="s1">.assertModuleSpecifier(node, </span><span class="s2">false</span><span class="s1">);</span>
                    <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ExportAllDeclaration,</span>
                        <span class="s1">source: </span><span class="s2">this</span><span class="s1">.convertChild(node.moduleSpecifier),</span>
                        <span class="s1">exportKind: node.isTypeOnly ? </span><span class="s0">'type' </span><span class="s1">: </span><span class="s0">'value'</span><span class="s1">,</span>
                        <span class="s1">exported: </span>
                        <span class="s4">// note - for compat with 3.7.x, where node.exportClause is always undefined and</span>
                        <span class="s4">//        SyntaxKind.NamespaceExport does not exist yet (i.e. is undefined), this</span>
                        <span class="s4">//        cannot be shortened to an optional chain, or else you end up with</span>
                        <span class="s4">//        undefined === undefined, and the true path will hard error at runtime</span>
                        <span class="s1">node.exportClause &amp;&amp;</span>
                            <span class="s1">node.exportClause.kind === SyntaxKind.NamespaceExport</span>
                            <span class="s1">? </span><span class="s2">this</span><span class="s1">.convertChild(node.exportClause.name)</span>
                            <span class="s1">: </span><span class="s2">null</span><span class="s1">,</span>
                        <span class="s1">assertions: </span><span class="s2">this</span><span class="s1">.convertAssertClasue(node.assertClause),</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ExportSpecifier:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ExportSpecifier,</span>
                    <span class="s1">local: </span><span class="s2">this</span><span class="s1">.convertChild((_h = node.propertyName) !== </span><span class="s2">null </span><span class="s1">&amp;&amp; _h !== </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? _h : node.name),</span>
                    <span class="s1">exported: </span><span class="s2">this</span><span class="s1">.convertChild(node.name),</span>
                    <span class="s1">exportKind: node.isTypeOnly ? </span><span class="s0">'type' </span><span class="s1">: </span><span class="s0">'value'</span><span class="s1">,</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ExportAssignment:</span>
                <span class="s2">if </span><span class="s1">(node.isExportEquals) {</span>
                    <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSExportAssignment,</span>
                        <span class="s1">expression: </span><span class="s2">this</span><span class="s1">.convertChild(node.expression),</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ExportDefaultDeclaration,</span>
                        <span class="s1">declaration: </span><span class="s2">this</span><span class="s1">.convertChild(node.expression),</span>
                        <span class="s1">exportKind: </span><span class="s0">'value'</span><span class="s1">,</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
            <span class="s4">// Unary Operations</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.PrefixUnaryExpression:</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.PostfixUnaryExpression: {</span>
                <span class="s1">const operator = (</span><span class="s3">0</span><span class="s1">, node_utils_1.getTextForTokenKind)(node.operator);</span>
                <span class="s4">/** 
                 * ESTree uses UpdateExpression for ++/-- 
                 */</span>
                <span class="s2">if </span><span class="s1">(operator === </span><span class="s0">'++' </span><span class="s1">|| operator === </span><span class="s0">'--'</span><span class="s1">) {</span>
                    <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.UpdateExpression,</span>
                        <span class="s1">operator,</span>
                        <span class="s1">prefix: node.kind === SyntaxKind.PrefixUnaryExpression,</span>
                        <span class="s1">argument: </span><span class="s2">this</span><span class="s1">.convertChild(node.operand),</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.UnaryExpression,</span>
                        <span class="s1">operator,</span>
                        <span class="s1">prefix: node.kind === SyntaxKind.PrefixUnaryExpression,</span>
                        <span class="s1">argument: </span><span class="s2">this</span><span class="s1">.convertChild(node.operand),</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.DeleteExpression:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.UnaryExpression,</span>
                    <span class="s1">operator: </span><span class="s0">'delete'</span><span class="s1">,</span>
                    <span class="s1">prefix: </span><span class="s2">true</span><span class="s1">,</span>
                    <span class="s1">argument: </span><span class="s2">this</span><span class="s1">.convertChild(node.expression),</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.VoidExpression:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.UnaryExpression,</span>
                    <span class="s1">operator: </span><span class="s0">'void'</span><span class="s1">,</span>
                    <span class="s1">prefix: </span><span class="s2">true</span><span class="s1">,</span>
                    <span class="s1">argument: </span><span class="s2">this</span><span class="s1">.convertChild(node.expression),</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.TypeOfExpression:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.UnaryExpression,</span>
                    <span class="s1">operator: </span><span class="s0">'typeof'</span><span class="s1">,</span>
                    <span class="s1">prefix: </span><span class="s2">true</span><span class="s1">,</span>
                    <span class="s1">argument: </span><span class="s2">this</span><span class="s1">.convertChild(node.expression),</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.TypeOperator:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSTypeOperator,</span>
                    <span class="s1">operator: (</span><span class="s3">0</span><span class="s1">, node_utils_1.getTextForTokenKind)(node.operator),</span>
                    <span class="s1">typeAnnotation: </span><span class="s2">this</span><span class="s1">.convertChild(node.type),</span>
                <span class="s1">});</span>
            <span class="s4">// Binary Operations</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.BinaryExpression: {</span>
                <span class="s4">// TypeScript uses BinaryExpression for sequences as well</span>
                <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, node_utils_1.isComma)(node.operatorToken)) {</span>
                    <span class="s1">const result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.SequenceExpression,</span>
                        <span class="s1">expressions: [],</span>
                    <span class="s1">});</span>
                    <span class="s1">const left = </span><span class="s2">this</span><span class="s1">.convertChild(node.left);</span>
                    <span class="s2">if </span><span class="s1">(left.type === ts_estree_1.AST_NODE_TYPES.SequenceExpression &amp;&amp;</span>
                        <span class="s1">node.left.kind !== SyntaxKind.ParenthesizedExpression) {</span>
                        <span class="s1">result.expressions = result.expressions.concat(left.expressions);</span>
                    <span class="s1">}</span>
                    <span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">result.expressions.push(left);</span>
                    <span class="s1">}</span>
                    <span class="s1">result.expressions.push(</span><span class="s2">this</span><span class="s1">.convertChild(node.right));</span>
                    <span class="s2">return </span><span class="s1">result;</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">const type = (</span><span class="s3">0</span><span class="s1">, node_utils_1.getBinaryExpressionType)(node.operatorToken);</span>
                    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.allowPattern &amp;&amp;</span>
                        <span class="s1">type === ts_estree_1.AST_NODE_TYPES.AssignmentExpression) {</span>
                        <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                            <span class="s1">type: ts_estree_1.AST_NODE_TYPES.AssignmentPattern,</span>
                            <span class="s1">left: </span><span class="s2">this</span><span class="s1">.convertPattern(node.left, node),</span>
                            <span class="s1">right: </span><span class="s2">this</span><span class="s1">.convertChild(node.right),</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                    <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type,</span>
                        <span class="s1">operator: (</span><span class="s3">0</span><span class="s1">, node_utils_1.getTextForTokenKind)(node.operatorToken.kind),</span>
                        <span class="s1">left: </span><span class="s2">this</span><span class="s1">.converter(node.left, node, </span><span class="s2">this</span><span class="s1">.inTypeMode, type === ts_estree_1.AST_NODE_TYPES.AssignmentExpression),</span>
                        <span class="s1">right: </span><span class="s2">this</span><span class="s1">.convertChild(node.right),</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.PropertyAccessExpression: {</span>
                <span class="s1">const object = </span><span class="s2">this</span><span class="s1">.convertChild(node.expression);</span>
                <span class="s1">const property = </span><span class="s2">this</span><span class="s1">.convertChild(node.name);</span>
                <span class="s1">const computed = </span><span class="s2">false</span><span class="s1">;</span>
                <span class="s1">const result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.MemberExpression,</span>
                    <span class="s1">object,</span>
                    <span class="s1">property,</span>
                    <span class="s1">computed,</span>
                    <span class="s1">optional: node.questionDotToken !== undefined,</span>
                <span class="s1">});</span>
                <span class="s2">return this</span><span class="s1">.convertChainExpression(result, node);</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ElementAccessExpression: {</span>
                <span class="s1">const object = </span><span class="s2">this</span><span class="s1">.convertChild(node.expression);</span>
                <span class="s1">const property = </span><span class="s2">this</span><span class="s1">.convertChild(node.argumentExpression);</span>
                <span class="s1">const computed = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s1">const result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.MemberExpression,</span>
                    <span class="s1">object,</span>
                    <span class="s1">property,</span>
                    <span class="s1">computed,</span>
                    <span class="s1">optional: node.questionDotToken !== undefined,</span>
                <span class="s1">});</span>
                <span class="s2">return this</span><span class="s1">.convertChainExpression(result, node);</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.CallExpression: {</span>
                <span class="s2">if </span><span class="s1">(node.expression.kind === SyntaxKind.ImportKeyword) {</span>
                    <span class="s2">if </span><span class="s1">(node.arguments.length !== </span><span class="s3">1 </span><span class="s1">&amp;&amp; node.arguments.length !== </span><span class="s3">2</span><span class="s1">) {</span>
                        <span class="s2">throw </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, node_utils_1.createError)(</span><span class="s2">this</span><span class="s1">.ast, node.arguments.pos, </span><span class="s0">'Dynamic import requires exactly one or two arguments.'</span><span class="s1">);</span>
                    <span class="s1">}</span>
                    <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ImportExpression,</span>
                        <span class="s1">source: </span><span class="s2">this</span><span class="s1">.convertChild(node.arguments[</span><span class="s3">0</span><span class="s1">]),</span>
                        <span class="s1">attributes: node.arguments[</span><span class="s3">1</span><span class="s1">]</span>
                            <span class="s1">? </span><span class="s2">this</span><span class="s1">.convertChild(node.arguments[</span><span class="s3">1</span><span class="s1">])</span>
                            <span class="s1">: </span><span class="s2">null</span><span class="s1">,</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s1">const callee = </span><span class="s2">this</span><span class="s1">.convertChild(node.expression);</span>
                <span class="s1">const args = node.arguments.map(el =&gt; </span><span class="s2">this</span><span class="s1">.convertChild(el));</span>
                <span class="s1">const result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.CallExpression,</span>
                    <span class="s1">callee,</span>
                    <span class="s1">arguments: args,</span>
                    <span class="s1">optional: node.questionDotToken !== undefined,</span>
                <span class="s1">});</span>
                <span class="s2">if </span><span class="s1">(node.typeArguments) {</span>
                    <span class="s1">result.typeParameters = </span><span class="s2">this</span><span class="s1">.convertTypeArgumentsToTypeParameters(node.typeArguments, node);</span>
                <span class="s1">}</span>
                <span class="s2">return this</span><span class="s1">.convertChainExpression(result, node);</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.NewExpression: {</span>
                <span class="s4">// NOTE - NewExpression cannot have an optional chain in it</span>
                <span class="s1">const result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.NewExpression,</span>
                    <span class="s1">callee: </span><span class="s2">this</span><span class="s1">.convertChild(node.expression),</span>
                    <span class="s1">arguments: node.arguments</span>
                        <span class="s1">? node.arguments.map(el =&gt; </span><span class="s2">this</span><span class="s1">.convertChild(el))</span>
                        <span class="s1">: [],</span>
                <span class="s1">});</span>
                <span class="s2">if </span><span class="s1">(node.typeArguments) {</span>
                    <span class="s1">result.typeParameters = </span><span class="s2">this</span><span class="s1">.convertTypeArgumentsToTypeParameters(node.typeArguments, node);</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">result;</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ConditionalExpression:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ConditionalExpression,</span>
                    <span class="s1">test: </span><span class="s2">this</span><span class="s1">.convertChild(node.condition),</span>
                    <span class="s1">consequent: </span><span class="s2">this</span><span class="s1">.convertChild(node.whenTrue),</span>
                    <span class="s1">alternate: </span><span class="s2">this</span><span class="s1">.convertChild(node.whenFalse),</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.MetaProperty: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.MetaProperty,</span>
                    <span class="s1">meta: </span><span class="s2">this</span><span class="s1">.createNode(</span>
                    <span class="s4">// TODO: do we really want to convert it to Token?</span>
                    <span class="s1">node.getFirstToken(), {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.Identifier,</span>
                        <span class="s1">name: (</span><span class="s3">0</span><span class="s1">, node_utils_1.getTextForTokenKind)(node.keywordToken),</span>
                    <span class="s1">}),</span>
                    <span class="s1">property: </span><span class="s2">this</span><span class="s1">.convertChild(node.name),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.Decorator: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.Decorator,</span>
                    <span class="s1">expression: </span><span class="s2">this</span><span class="s1">.convertChild(node.expression),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s4">// Literals</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.StringLiteral: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.Literal,</span>
                    <span class="s1">value: parent.kind === SyntaxKind.JsxAttribute</span>
                        <span class="s1">? (</span><span class="s3">0</span><span class="s1">, node_utils_1.unescapeStringLiteralText)(node.text)</span>
                        <span class="s1">: node.text,</span>
                    <span class="s1">raw: node.getText(),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.NumericLiteral: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.Literal,</span>
                    <span class="s1">value: Number(node.text),</span>
                    <span class="s1">raw: node.getText(),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.BigIntLiteral: {</span>
                <span class="s1">const range = (</span><span class="s3">0</span><span class="s1">, node_utils_1.getRange)(node, </span><span class="s2">this</span><span class="s1">.ast);</span>
                <span class="s1">const rawValue = </span><span class="s2">this</span><span class="s1">.ast.text.slice(range[</span><span class="s3">0</span><span class="s1">], range[</span><span class="s3">1</span><span class="s1">]);</span>
                <span class="s1">const bigint = rawValue</span>
                    <span class="s4">// remove suffix `n`</span>
                    <span class="s1">.slice(</span><span class="s3">0</span><span class="s1">, -</span><span class="s3">1</span><span class="s1">)</span>
                    <span class="s4">// `BigInt` doesn't accept numeric separator</span>
                    <span class="s4">// and `bigint` property should not include numeric separator</span>
                    <span class="s1">.replace(/_/g, </span><span class="s0">''</span><span class="s1">);</span>
                <span class="s1">const value = </span><span class="s2">typeof </span><span class="s1">BigInt !== </span><span class="s0">'undefined' </span><span class="s1">? BigInt(bigint) : </span><span class="s2">null</span><span class="s1">;</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.Literal,</span>
                    <span class="s1">raw: rawValue,</span>
                    <span class="s1">value: value,</span>
                    <span class="s1">bigint: value == </span><span class="s2">null </span><span class="s1">? bigint : String(value),</span>
                    <span class="s1">range,</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.RegularExpressionLiteral: {</span>
                <span class="s1">const pattern = node.text.slice(</span><span class="s3">1</span><span class="s1">, node.text.lastIndexOf(</span><span class="s0">'/'</span><span class="s1">));</span>
                <span class="s1">const flags = node.text.slice(node.text.lastIndexOf(</span><span class="s0">'/'</span><span class="s1">) + </span><span class="s3">1</span><span class="s1">);</span>
                <span class="s1">let regex = </span><span class="s2">null</span><span class="s1">;</span>
                <span class="s2">try </span><span class="s1">{</span>
                    <span class="s1">regex = </span><span class="s2">new </span><span class="s1">RegExp(pattern, flags);</span>
                <span class="s1">}</span>
                <span class="s2">catch </span><span class="s1">(exception) {</span>
                    <span class="s1">regex = </span><span class="s2">null</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.Literal,</span>
                    <span class="s1">value: regex,</span>
                    <span class="s1">raw: node.text,</span>
                    <span class="s1">regex: {</span>
                        <span class="s1">pattern,</span>
                        <span class="s1">flags,</span>
                    <span class="s1">},</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.TrueKeyword:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.Literal,</span>
                    <span class="s1">value: </span><span class="s2">true</span><span class="s1">,</span>
                    <span class="s1">raw: </span><span class="s0">'true'</span><span class="s1">,</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.FalseKeyword:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.Literal,</span>
                    <span class="s1">value: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">raw: </span><span class="s0">'false'</span><span class="s1">,</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.NullKeyword: {</span>
                <span class="s2">if </span><span class="s1">(!version_check_1.typescriptVersionIsAtLeast[</span><span class="s0">'4.0'</span><span class="s1">] &amp;&amp; </span><span class="s2">this</span><span class="s1">.inTypeMode) {</span>
                    <span class="s4">// 4.0 started nesting null types inside a LiteralType node, but we still need to support pre-4.0</span>
                    <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSNullKeyword,</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.Literal,</span>
                    <span class="s1">value: </span><span class="s2">null</span><span class="s1">,</span>
                    <span class="s1">raw: </span><span class="s0">'null'</span><span class="s1">,</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.EmptyStatement:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.EmptyStatement,</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.DebuggerStatement:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.DebuggerStatement,</span>
                <span class="s1">});</span>
            <span class="s4">// JSX</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.JsxElement:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.JSXElement,</span>
                    <span class="s1">openingElement: </span><span class="s2">this</span><span class="s1">.convertChild(node.openingElement),</span>
                    <span class="s1">closingElement: </span><span class="s2">this</span><span class="s1">.convertChild(node.closingElement),</span>
                    <span class="s1">children: node.children.map(el =&gt; </span><span class="s2">this</span><span class="s1">.convertChild(el)),</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.JsxFragment:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.JSXFragment,</span>
                    <span class="s1">openingFragment: </span><span class="s2">this</span><span class="s1">.convertChild(node.openingFragment),</span>
                    <span class="s1">closingFragment: </span><span class="s2">this</span><span class="s1">.convertChild(node.closingFragment),</span>
                    <span class="s1">children: node.children.map(el =&gt; </span><span class="s2">this</span><span class="s1">.convertChild(el)),</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.JsxSelfClosingElement: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.JSXElement,</span>
                    <span class="s4">/** 
                     * Convert SyntaxKind.JsxSelfClosingElement to SyntaxKind.JsxOpeningElement, 
                     * TypeScript does not seem to have the idea of openingElement when tag is self-closing 
                     */</span>
                    <span class="s1">openingElement: </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.JSXOpeningElement,</span>
                        <span class="s1">typeParameters: node.typeArguments</span>
                            <span class="s1">? </span><span class="s2">this</span><span class="s1">.convertTypeArgumentsToTypeParameters(node.typeArguments, node)</span>
                            <span class="s1">: undefined,</span>
                        <span class="s1">selfClosing: </span><span class="s2">true</span><span class="s1">,</span>
                        <span class="s1">name: </span><span class="s2">this</span><span class="s1">.convertJSXTagName(node.tagName, node),</span>
                        <span class="s1">attributes: node.attributes.properties.map(el =&gt; </span><span class="s2">this</span><span class="s1">.convertChild(el)),</span>
                        <span class="s1">range: (</span><span class="s3">0</span><span class="s1">, node_utils_1.getRange)(node, </span><span class="s2">this</span><span class="s1">.ast),</span>
                    <span class="s1">}),</span>
                    <span class="s1">closingElement: </span><span class="s2">null</span><span class="s1">,</span>
                    <span class="s1">children: [],</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.JsxOpeningElement:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.JSXOpeningElement,</span>
                    <span class="s1">typeParameters: node.typeArguments</span>
                        <span class="s1">? </span><span class="s2">this</span><span class="s1">.convertTypeArgumentsToTypeParameters(node.typeArguments, node)</span>
                        <span class="s1">: undefined,</span>
                    <span class="s1">selfClosing: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">name: </span><span class="s2">this</span><span class="s1">.convertJSXTagName(node.tagName, node),</span>
                    <span class="s1">attributes: node.attributes.properties.map(el =&gt; </span><span class="s2">this</span><span class="s1">.convertChild(el)),</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.JsxClosingElement:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.JSXClosingElement,</span>
                    <span class="s1">name: </span><span class="s2">this</span><span class="s1">.convertJSXTagName(node.tagName, node),</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.JsxOpeningFragment:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.JSXOpeningFragment,</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.JsxClosingFragment:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.JSXClosingFragment,</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.JsxExpression: {</span>
                <span class="s1">const expression = node.expression</span>
                    <span class="s1">? </span><span class="s2">this</span><span class="s1">.convertChild(node.expression)</span>
                    <span class="s1">: </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.JSXEmptyExpression,</span>
                        <span class="s1">range: [node.getStart(</span><span class="s2">this</span><span class="s1">.ast) + </span><span class="s3">1</span><span class="s1">, node.getEnd() - </span><span class="s3">1</span><span class="s1">],</span>
                    <span class="s1">});</span>
                <span class="s2">if </span><span class="s1">(node.dotDotDotToken) {</span>
                    <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.JSXSpreadChild,</span>
                        <span class="s1">expression,</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.JSXExpressionContainer,</span>
                        <span class="s1">expression,</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.JsxAttribute: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.JSXAttribute,</span>
                    <span class="s1">name: </span><span class="s2">this</span><span class="s1">.convertJSXNamespaceOrIdentifier(node.name),</span>
                    <span class="s1">value: </span><span class="s2">this</span><span class="s1">.convertChild(node.initializer),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.JsxText: {</span>
                <span class="s1">const start = node.getFullStart();</span>
                <span class="s1">const end = node.getEnd();</span>
                <span class="s1">const text = </span><span class="s2">this</span><span class="s1">.ast.text.slice(start, end);</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.JSXText,</span>
                    <span class="s1">value: (</span><span class="s3">0</span><span class="s1">, node_utils_1.unescapeStringLiteralText)(text),</span>
                    <span class="s1">raw: text,</span>
                    <span class="s1">range: [start, end],</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.JsxSpreadAttribute:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.JSXSpreadAttribute,</span>
                    <span class="s1">argument: </span><span class="s2">this</span><span class="s1">.convertChild(node.expression),</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.QualifiedName: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSQualifiedName,</span>
                    <span class="s1">left: </span><span class="s2">this</span><span class="s1">.convertChild(node.left),</span>
                    <span class="s1">right: </span><span class="s2">this</span><span class="s1">.convertChild(node.right),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s4">// TypeScript specific</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.TypeReference: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSTypeReference,</span>
                    <span class="s1">typeName: </span><span class="s2">this</span><span class="s1">.convertType(node.typeName),</span>
                    <span class="s1">typeParameters: node.typeArguments</span>
                        <span class="s1">? </span><span class="s2">this</span><span class="s1">.convertTypeArgumentsToTypeParameters(node.typeArguments, node)</span>
                        <span class="s1">: undefined,</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.TypeParameter: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSTypeParameter,</span>
                    <span class="s1">name: </span><span class="s2">this</span><span class="s1">.convertType(node.name),</span>
                    <span class="s1">constraint: node.constraint</span>
                        <span class="s1">? </span><span class="s2">this</span><span class="s1">.convertType(node.constraint)</span>
                        <span class="s1">: undefined,</span>
                    <span class="s2">default</span><span class="s1">: node.</span><span class="s2">default </span><span class="s1">? </span><span class="s2">this</span><span class="s1">.convertType(node.</span><span class="s2">default</span><span class="s1">) : undefined,</span>
                    <span class="s2">in</span><span class="s1">: (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.InKeyword, node),</span>
                    <span class="s1">out: (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.OutKeyword, node),</span>
                    <span class="s1">const: (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.ConstKeyword, node),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ThisType:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSThisType,</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.AnyKeyword:</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.BigIntKeyword:</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.BooleanKeyword:</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.NeverKeyword:</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.NumberKeyword:</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ObjectKeyword:</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.StringKeyword:</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.SymbolKeyword:</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.UnknownKeyword:</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.VoidKeyword:</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.UndefinedKeyword:</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.IntrinsicKeyword: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES[`TS${SyntaxKind[node.kind]}`],</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.NonNullExpression: {</span>
                <span class="s1">const nnExpr = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSNonNullExpression,</span>
                    <span class="s1">expression: </span><span class="s2">this</span><span class="s1">.convertChild(node.expression),</span>
                <span class="s1">});</span>
                <span class="s2">return this</span><span class="s1">.convertChainExpression(nnExpr, node);</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.TypeLiteral: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSTypeLiteral,</span>
                    <span class="s1">members: node.members.map(el =&gt; </span><span class="s2">this</span><span class="s1">.convertChild(el)),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ArrayType: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSArrayType,</span>
                    <span class="s1">elementType: </span><span class="s2">this</span><span class="s1">.convertType(node.elementType),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.IndexedAccessType: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSIndexedAccessType,</span>
                    <span class="s1">objectType: </span><span class="s2">this</span><span class="s1">.convertType(node.objectType),</span>
                    <span class="s1">indexType: </span><span class="s2">this</span><span class="s1">.convertType(node.indexType),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ConditionalType: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSConditionalType,</span>
                    <span class="s1">checkType: </span><span class="s2">this</span><span class="s1">.convertType(node.checkType),</span>
                    <span class="s1">extendsType: </span><span class="s2">this</span><span class="s1">.convertType(node.extendsType),</span>
                    <span class="s1">trueType: </span><span class="s2">this</span><span class="s1">.convertType(node.trueType),</span>
                    <span class="s1">falseType: </span><span class="s2">this</span><span class="s1">.convertType(node.falseType),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.TypeQuery: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSTypeQuery,</span>
                    <span class="s1">exprName: </span><span class="s2">this</span><span class="s1">.convertType(node.exprName),</span>
                    <span class="s1">typeParameters: node.typeArguments &amp;&amp;</span>
                        <span class="s2">this</span><span class="s1">.convertTypeArgumentsToTypeParameters(node.typeArguments, node),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.MappedType: {</span>
                <span class="s1">const result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSMappedType,</span>
                    <span class="s1">typeParameter: </span><span class="s2">this</span><span class="s1">.convertType(node.typeParameter),</span>
                    <span class="s1">nameType: (_j = </span><span class="s2">this</span><span class="s1">.convertType(node.nameType)) !== </span><span class="s2">null </span><span class="s1">&amp;&amp; _j !== </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? _j : </span><span class="s2">null</span><span class="s1">,</span>
                <span class="s1">});</span>
                <span class="s2">if </span><span class="s1">(node.readonlyToken) {</span>
                    <span class="s2">if </span><span class="s1">(node.readonlyToken.kind === SyntaxKind.ReadonlyKeyword) {</span>
                        <span class="s1">result.readonly = </span><span class="s2">true</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">result.readonly = (</span><span class="s3">0</span><span class="s1">, node_utils_1.getTextForTokenKind)(node.readonlyToken.kind);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(node.questionToken) {</span>
                    <span class="s2">if </span><span class="s1">(node.questionToken.kind === SyntaxKind.QuestionToken) {</span>
                        <span class="s1">result.optional = </span><span class="s2">true</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">result.optional = (</span><span class="s3">0</span><span class="s1">, node_utils_1.getTextForTokenKind)(node.questionToken.kind);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(node.type) {</span>
                    <span class="s1">result.typeAnnotation = </span><span class="s2">this</span><span class="s1">.convertType(node.type);</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">result;</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ParenthesizedExpression:</span>
                <span class="s2">return this</span><span class="s1">.convertChild(node.expression, parent);</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.TypeAliasDeclaration: {</span>
                <span class="s1">const result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSTypeAliasDeclaration,</span>
                    <span class="s1">id: </span><span class="s2">this</span><span class="s1">.convertChild(node.name),</span>
                    <span class="s1">typeAnnotation: </span><span class="s2">this</span><span class="s1">.convertType(node.type),</span>
                <span class="s1">});</span>
                <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.DeclareKeyword, node)) {</span>
                    <span class="s1">result.declare = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s4">// Process typeParameters</span>
                <span class="s2">if </span><span class="s1">(node.typeParameters) {</span>
                    <span class="s1">result.typeParameters =</span>
                        <span class="s2">this</span><span class="s1">.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);</span>
                <span class="s1">}</span>
                <span class="s4">// check for exports</span>
                <span class="s2">return this</span><span class="s1">.fixExports(node, result);</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.MethodSignature: {</span>
                <span class="s2">return this</span><span class="s1">.convertMethodSignature(node);</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.PropertySignature: {</span>
                <span class="s1">const result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSPropertySignature,</span>
                    <span class="s1">optional: (</span><span class="s3">0</span><span class="s1">, node_utils_1.isOptional)(node) || undefined,</span>
                    <span class="s1">computed: (</span><span class="s3">0</span><span class="s1">, node_utils_1.isComputedProperty)(node.name),</span>
                    <span class="s1">key: </span><span class="s2">this</span><span class="s1">.convertChild(node.name),</span>
                    <span class="s1">typeAnnotation: node.type</span>
                        <span class="s1">? </span><span class="s2">this</span><span class="s1">.convertTypeAnnotation(node.type, node)</span>
                        <span class="s1">: undefined,</span>
                    <span class="s1">initializer: </span><span class="s2">this</span><span class="s1">.convertChild(</span>
                    <span class="s4">// @ts-expect-error TODO breaking change remove this from the AST</span>
                    <span class="s1">node.initializer) || undefined,</span>
                    <span class="s1">readonly: (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.ReadonlyKeyword, node) || undefined,</span>
                    <span class="s1">static: (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.StaticKeyword, node) || undefined,</span>
                    <span class="s1">export: (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.ExportKeyword, node) || undefined,</span>
                <span class="s1">});</span>
                <span class="s1">const accessibility = (</span><span class="s3">0</span><span class="s1">, node_utils_1.getTSNodeAccessibility)(node);</span>
                <span class="s2">if </span><span class="s1">(accessibility) {</span>
                    <span class="s1">result.accessibility = accessibility;</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">result;</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.IndexSignature: {</span>
                <span class="s1">const result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSIndexSignature,</span>
                    <span class="s1">parameters: node.parameters.map(el =&gt; </span><span class="s2">this</span><span class="s1">.convertChild(el)),</span>
                <span class="s1">});</span>
                <span class="s2">if </span><span class="s1">(node.type) {</span>
                    <span class="s1">result.typeAnnotation = </span><span class="s2">this</span><span class="s1">.convertTypeAnnotation(node.type, node);</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.ReadonlyKeyword, node)) {</span>
                    <span class="s1">result.readonly = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s1">const accessibility = (</span><span class="s3">0</span><span class="s1">, node_utils_1.getTSNodeAccessibility)(node);</span>
                <span class="s2">if </span><span class="s1">(accessibility) {</span>
                    <span class="s1">result.accessibility = accessibility;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.ExportKeyword, node)) {</span>
                    <span class="s1">result.export = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.StaticKeyword, node)) {</span>
                    <span class="s1">result.static = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">result;</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ConstructorType: {</span>
                <span class="s1">const result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSConstructorType,</span>
                    <span class="s1">params: </span><span class="s2">this</span><span class="s1">.convertParameters(node.parameters),</span>
                    <span class="s1">abstract: (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.AbstractKeyword, node),</span>
                <span class="s1">});</span>
                <span class="s2">if </span><span class="s1">(node.type) {</span>
                    <span class="s1">result.returnType = </span><span class="s2">this</span><span class="s1">.convertTypeAnnotation(node.type, node);</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(node.typeParameters) {</span>
                    <span class="s1">result.typeParameters =</span>
                        <span class="s2">this</span><span class="s1">.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">result;</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.FunctionType:</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ConstructSignature:</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.CallSignature: {</span>
                <span class="s1">const type = node.kind === SyntaxKind.ConstructSignature</span>
                    <span class="s1">? ts_estree_1.AST_NODE_TYPES.TSConstructSignatureDeclaration</span>
                    <span class="s1">: node.kind === SyntaxKind.CallSignature</span>
                        <span class="s1">? ts_estree_1.AST_NODE_TYPES.TSCallSignatureDeclaration</span>
                        <span class="s1">: ts_estree_1.AST_NODE_TYPES.TSFunctionType;</span>
                <span class="s1">const result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: type,</span>
                    <span class="s1">params: </span><span class="s2">this</span><span class="s1">.convertParameters(node.parameters),</span>
                <span class="s1">});</span>
                <span class="s2">if </span><span class="s1">(node.type) {</span>
                    <span class="s1">result.returnType = </span><span class="s2">this</span><span class="s1">.convertTypeAnnotation(node.type, node);</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(node.typeParameters) {</span>
                    <span class="s1">result.typeParameters =</span>
                        <span class="s2">this</span><span class="s1">.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">result;</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ExpressionWithTypeArguments: {</span>
                <span class="s1">const parentKind = parent.kind;</span>
                <span class="s1">const type = parentKind === SyntaxKind.InterfaceDeclaration</span>
                    <span class="s1">? ts_estree_1.AST_NODE_TYPES.TSInterfaceHeritage</span>
                    <span class="s1">: parentKind === SyntaxKind.HeritageClause</span>
                        <span class="s1">? ts_estree_1.AST_NODE_TYPES.TSClassImplements</span>
                        <span class="s1">: ts_estree_1.AST_NODE_TYPES.TSInstantiationExpression;</span>
                <span class="s1">const result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type,</span>
                    <span class="s1">expression: </span><span class="s2">this</span><span class="s1">.convertChild(node.expression),</span>
                <span class="s1">});</span>
                <span class="s2">if </span><span class="s1">(node.typeArguments) {</span>
                    <span class="s1">result.typeParameters = </span><span class="s2">this</span><span class="s1">.convertTypeArgumentsToTypeParameters(node.typeArguments, node);</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">result;</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.InterfaceDeclaration: {</span>
                <span class="s1">const interfaceHeritageClauses = (_k = node.heritageClauses) !== </span><span class="s2">null </span><span class="s1">&amp;&amp; _k !== </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? _k : [];</span>
                <span class="s1">const result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSInterfaceDeclaration,</span>
                    <span class="s1">body: </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSInterfaceBody,</span>
                        <span class="s1">body: node.members.map(member =&gt; </span><span class="s2">this</span><span class="s1">.convertChild(member)),</span>
                        <span class="s1">range: [node.members.pos - </span><span class="s3">1</span><span class="s1">, node.end],</span>
                    <span class="s1">}),</span>
                    <span class="s1">id: </span><span class="s2">this</span><span class="s1">.convertChild(node.name),</span>
                <span class="s1">});</span>
                <span class="s2">if </span><span class="s1">(node.typeParameters) {</span>
                    <span class="s1">result.typeParameters =</span>
                        <span class="s2">this</span><span class="s1">.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(interfaceHeritageClauses.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
                    <span class="s1">const interfaceExtends = [];</span>
                    <span class="s1">const interfaceImplements = [];</span>
                    <span class="s2">for </span><span class="s1">(const heritageClause of interfaceHeritageClauses) {</span>
                        <span class="s2">if </span><span class="s1">(heritageClause.token === SyntaxKind.ExtendsKeyword) {</span>
                            <span class="s2">for </span><span class="s1">(const n of heritageClause.types) {</span>
                                <span class="s1">interfaceExtends.push(</span><span class="s2">this</span><span class="s1">.convertChild(n, node));</span>
                            <span class="s1">}</span>
                        <span class="s1">}</span>
                        <span class="s2">else </span><span class="s1">{</span>
                            <span class="s2">for </span><span class="s1">(const n of heritageClause.types) {</span>
                                <span class="s1">interfaceImplements.push(</span><span class="s2">this</span><span class="s1">.convertChild(n, node));</span>
                            <span class="s1">}</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">(interfaceExtends.length) {</span>
                        <span class="s1">result.extends = interfaceExtends;</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">(interfaceImplements.length) {</span>
                        <span class="s1">result.implements = interfaceImplements;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.AbstractKeyword, node)) {</span>
                    <span class="s1">result.abstract = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.DeclareKeyword, node)) {</span>
                    <span class="s1">result.declare = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s4">// check for exports</span>
                <span class="s2">return this</span><span class="s1">.fixExports(node, result);</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.TypePredicate: {</span>
                <span class="s1">const result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSTypePredicate,</span>
                    <span class="s1">asserts: node.assertsModifier !== undefined,</span>
                    <span class="s1">parameterName: </span><span class="s2">this</span><span class="s1">.convertChild(node.parameterName),</span>
                    <span class="s1">typeAnnotation: </span><span class="s2">null</span><span class="s1">,</span>
                <span class="s1">});</span>
                <span class="s4">/** 
                 * Specific fix for type-guard location data 
                 */</span>
                <span class="s2">if </span><span class="s1">(node.type) {</span>
                    <span class="s1">result.typeAnnotation = </span><span class="s2">this</span><span class="s1">.convertTypeAnnotation(node.type, node);</span>
                    <span class="s1">result.typeAnnotation.loc = result.typeAnnotation.typeAnnotation.loc;</span>
                    <span class="s1">result.typeAnnotation.range =</span>
                        <span class="s1">result.typeAnnotation.typeAnnotation.range;</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">result;</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ImportType:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSImportType,</span>
                    <span class="s1">isTypeOf: !!node.isTypeOf,</span>
                    <span class="s1">parameter: </span><span class="s2">this</span><span class="s1">.convertChild(node.argument),</span>
                    <span class="s1">qualifier: </span><span class="s2">this</span><span class="s1">.convertChild(node.qualifier),</span>
                    <span class="s1">typeParameters: node.typeArguments</span>
                        <span class="s1">? </span><span class="s2">this</span><span class="s1">.convertTypeArgumentsToTypeParameters(node.typeArguments, node)</span>
                        <span class="s1">: </span><span class="s2">null</span><span class="s1">,</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.EnumDeclaration: {</span>
                <span class="s1">const result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSEnumDeclaration,</span>
                    <span class="s1">id: </span><span class="s2">this</span><span class="s1">.convertChild(node.name),</span>
                    <span class="s1">members: node.members.map(el =&gt; </span><span class="s2">this</span><span class="s1">.convertChild(el)),</span>
                <span class="s1">});</span>
                <span class="s4">// apply modifiers first...</span>
                <span class="s2">this</span><span class="s1">.applyModifiersToResult(result, (</span><span class="s3">0</span><span class="s1">, getModifiers_1.getModifiers)(node));</span>
                <span class="s4">// ...then check for exports</span>
                <span class="s2">return this</span><span class="s1">.fixExports(node, result);</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.EnumMember: {</span>
                <span class="s1">const result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSEnumMember,</span>
                    <span class="s1">id: </span><span class="s2">this</span><span class="s1">.convertChild(node.name),</span>
                <span class="s1">});</span>
                <span class="s2">if </span><span class="s1">(node.initializer) {</span>
                    <span class="s1">result.initializer = </span><span class="s2">this</span><span class="s1">.convertChild(node.initializer);</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(node.name.kind === ts.SyntaxKind.ComputedPropertyName) {</span>
                    <span class="s1">result.computed = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">result;</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ModuleDeclaration: {</span>
                <span class="s1">const result = </span><span class="s2">this</span><span class="s1">.createNode(node, Object.assign({ type: ts_estree_1.AST_NODE_TYPES.TSModuleDeclaration }, (() =&gt; {</span>
                    <span class="s1">const id = </span><span class="s2">this</span><span class="s1">.convertChild(node.name);</span>
                    <span class="s1">const body = </span><span class="s2">this</span><span class="s1">.convertChild(node.body);</span>
                    <span class="s4">// the constraints checked by this function are syntactically enforced by TS</span>
                    <span class="s4">// the checks mostly exist for type's sake</span>
                    <span class="s2">if </span><span class="s1">(node.flags &amp; ts.NodeFlags.GlobalAugmentation) {</span>
                        <span class="s2">if </span><span class="s1">(body == </span><span class="s2">null </span><span class="s1">||</span>
                            <span class="s1">body.type === ts_estree_1.AST_NODE_TYPES.TSModuleDeclaration) {</span>
                            <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">'Expected a valid module body'</span><span class="s1">);</span>
                        <span class="s1">}</span>
                        <span class="s2">if </span><span class="s1">(id.type !== ts_estree_1.AST_NODE_TYPES.Identifier) {</span>
                            <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">'global module augmentation must have an Identifier id'</span><span class="s1">);</span>
                        <span class="s1">}</span>
                        <span class="s2">return </span><span class="s1">{</span>
                            <span class="s1">kind: </span><span class="s0">'global'</span><span class="s1">,</span>
                            <span class="s1">id,</span>
                            <span class="s1">body,</span>
                            <span class="s1">global: </span><span class="s2">true</span><span class="s1">,</span>
                        <span class="s1">};</span>
                    <span class="s1">}</span>
                    <span class="s2">else if </span><span class="s1">(node.flags &amp; ts.NodeFlags.Namespace) {</span>
                        <span class="s2">if </span><span class="s1">(body == </span><span class="s2">null</span><span class="s1">) {</span>
                            <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">'Expected a module body'</span><span class="s1">);</span>
                        <span class="s1">}</span>
                        <span class="s2">if </span><span class="s1">(id.type !== ts_estree_1.AST_NODE_TYPES.Identifier) {</span>
                            <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">'`namespace`s must have an Identifier id'</span><span class="s1">);</span>
                        <span class="s1">}</span>
                        <span class="s2">return </span><span class="s1">{</span>
                            <span class="s1">kind: </span><span class="s0">'namespace'</span><span class="s1">,</span>
                            <span class="s1">id,</span>
                            <span class="s1">body,</span>
                        <span class="s1">};</span>
                    <span class="s1">}</span>
                    <span class="s2">else </span><span class="s1">{</span>
                        <span class="s2">return </span><span class="s1">Object.assign({ kind: </span><span class="s0">'module'</span><span class="s1">, id }, (body != </span><span class="s2">null </span><span class="s1">? { body } : {}));</span>
                    <span class="s1">}</span>
                <span class="s1">})()));</span>
                <span class="s2">this</span><span class="s1">.applyModifiersToResult(result, (</span><span class="s3">0</span><span class="s1">, getModifiers_1.getModifiers)(node));</span>
                <span class="s4">// ...then check for exports</span>
                <span class="s2">return this</span><span class="s1">.fixExports(node, result);</span>
            <span class="s1">}</span>
            <span class="s4">// TypeScript specific types</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ParenthesizedType: {</span>
                <span class="s2">return this</span><span class="s1">.convertType(node.type);</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.UnionType: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSUnionType,</span>
                    <span class="s1">types: node.types.map(el =&gt; </span><span class="s2">this</span><span class="s1">.convertType(el)),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.IntersectionType: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSIntersectionType,</span>
                    <span class="s1">types: node.types.map(el =&gt; </span><span class="s2">this</span><span class="s1">.convertType(el)),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.AsExpression: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSAsExpression,</span>
                    <span class="s1">expression: </span><span class="s2">this</span><span class="s1">.convertChild(node.expression),</span>
                    <span class="s1">typeAnnotation: </span><span class="s2">this</span><span class="s1">.convertType(node.type),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.InferType: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSInferType,</span>
                    <span class="s1">typeParameter: </span><span class="s2">this</span><span class="s1">.convertType(node.typeParameter),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.LiteralType: {</span>
                <span class="s2">if </span><span class="s1">(version_check_1.typescriptVersionIsAtLeast[</span><span class="s0">'4.0'</span><span class="s1">] &amp;&amp;</span>
                    <span class="s1">node.literal.kind === SyntaxKind.NullKeyword) {</span>
                    <span class="s4">// 4.0 started nesting null types inside a LiteralType node</span>
                    <span class="s4">// but our AST is designed around the old way of null being a keyword</span>
                    <span class="s2">return this</span><span class="s1">.createNode(node.literal, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSNullKeyword,</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSLiteralType,</span>
                        <span class="s1">literal: </span><span class="s2">this</span><span class="s1">.convertType(node.literal),</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.TypeAssertionExpression: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSTypeAssertion,</span>
                    <span class="s1">typeAnnotation: </span><span class="s2">this</span><span class="s1">.convertType(node.type),</span>
                    <span class="s1">expression: </span><span class="s2">this</span><span class="s1">.convertChild(node.expression),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ImportEqualsDeclaration: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSImportEqualsDeclaration,</span>
                    <span class="s1">id: </span><span class="s2">this</span><span class="s1">.convertChild(node.name),</span>
                    <span class="s1">moduleReference: </span><span class="s2">this</span><span class="s1">.convertChild(node.moduleReference),</span>
                    <span class="s1">importKind: node.isTypeOnly ? </span><span class="s0">'type' </span><span class="s1">: </span><span class="s0">'value'</span><span class="s1">,</span>
                    <span class="s1">isExport: (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.ExportKeyword, node),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ExternalModuleReference: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSExternalModuleReference,</span>
                    <span class="s1">expression: </span><span class="s2">this</span><span class="s1">.convertChild(node.expression),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.NamespaceExportDeclaration: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSNamespaceExportDeclaration,</span>
                    <span class="s1">id: </span><span class="s2">this</span><span class="s1">.convertChild(node.name),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.AbstractKeyword: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSAbstractKeyword,</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s4">// Tuple</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.TupleType: {</span>
                <span class="s4">// In TS 4.0, the `elementTypes` property was changed to `elements`.</span>
                <span class="s4">// To support both at compile time, we cast to access the newer version</span>
                <span class="s4">// if the former does not exist.</span>
                <span class="s1">const elementTypes = </span><span class="s0">'elementTypes' </span><span class="s2">in </span><span class="s1">node</span>
                    <span class="s1">? node.elementTypes.map((el) =&gt; </span><span class="s2">this</span><span class="s1">.convertType(el))</span>
                    <span class="s1">: node.elements.map(el =&gt; </span><span class="s2">this</span><span class="s1">.convertType(el));</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSTupleType,</span>
                    <span class="s1">elementTypes,</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.NamedTupleMember: {</span>
                <span class="s1">const member = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSNamedTupleMember,</span>
                    <span class="s1">elementType: </span><span class="s2">this</span><span class="s1">.convertType(node.type, node),</span>
                    <span class="s1">label: </span><span class="s2">this</span><span class="s1">.convertChild(node.name, node),</span>
                    <span class="s1">optional: node.questionToken != </span><span class="s2">null</span><span class="s1">,</span>
                <span class="s1">});</span>
                <span class="s2">if </span><span class="s1">(node.dotDotDotToken) {</span>
                    <span class="s4">// adjust the start to account for the &quot;...&quot;</span>
                    <span class="s1">member.range[</span><span class="s3">0</span><span class="s1">] = member.label.range[</span><span class="s3">0</span><span class="s1">];</span>
                    <span class="s1">member.loc.start = member.label.loc.start;</span>
                    <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSRestType,</span>
                        <span class="s1">typeAnnotation: member,</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">member;</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.OptionalType: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSOptionalType,</span>
                    <span class="s1">typeAnnotation: </span><span class="s2">this</span><span class="s1">.convertType(node.type),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.RestType: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSRestType,</span>
                    <span class="s1">typeAnnotation: </span><span class="s2">this</span><span class="s1">.convertType(node.type),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s4">// Template Literal Types</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.TemplateLiteralType: {</span>
                <span class="s1">const result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSTemplateLiteralType,</span>
                    <span class="s1">quasis: [</span><span class="s2">this</span><span class="s1">.convertChild(node.head)],</span>
                    <span class="s1">types: [],</span>
                <span class="s1">});</span>
                <span class="s1">node.templateSpans.forEach(templateSpan =&gt; {</span>
                    <span class="s1">result.types.push(</span><span class="s2">this</span><span class="s1">.convertChild(templateSpan.type));</span>
                    <span class="s1">result.quasis.push(</span><span class="s2">this</span><span class="s1">.convertChild(templateSpan.literal));</span>
                <span class="s1">});</span>
                <span class="s2">return </span><span class="s1">result;</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ClassStaticBlockDeclaration: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.StaticBlock,</span>
                    <span class="s1">body: </span><span class="s2">this</span><span class="s1">.convertBodyExpressions(node.body.statements, node),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.AssertEntry: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ImportAttribute,</span>
                    <span class="s1">key: </span><span class="s2">this</span><span class="s1">.convertChild(node.name),</span>
                    <span class="s1">value: </span><span class="s2">this</span><span class="s1">.convertChild(node.value),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.SatisfiesExpression: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSSatisfiesExpression,</span>
                    <span class="s1">expression: </span><span class="s2">this</span><span class="s1">.convertChild(node.expression),</span>
                    <span class="s1">typeAnnotation: </span><span class="s2">this</span><span class="s1">.convertChild(node.type),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">default</span><span class="s1">:</span>
                <span class="s2">return this</span><span class="s1">.deeplyCopy(node);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">exports.Converter = Converter;</span>
<span class="s4">//# sourceMappingURL=convert.js.map</span></pre>
</body>
</html>
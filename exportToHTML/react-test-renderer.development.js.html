<html>
<head>
<title>react-test-renderer.development.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #4646f1;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
react-test-renderer.development.js</font>
</center></td></tr></table>
<pre><span class="s0">/** 
 * @license React 
 * react-test-renderer.development.js 
 * 
 * Copyright (c) Facebook, Inc. and its affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>
<span class="s1">(</span><span class="s2">function </span><span class="s1">(global, factory) {</span>
  <span class="s2">typeof </span><span class="s1">exports === </span><span class="s3">'object' </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">module !== </span><span class="s3">'undefined' </span><span class="s1">? factory(exports, require(</span><span class="s3">'react'</span><span class="s1">), require(</span><span class="s3">'scheduler/unstable_mock'</span><span class="s1">), require(</span><span class="s3">'scheduler'</span><span class="s1">)) :</span>
  <span class="s2">typeof </span><span class="s1">define === </span><span class="s3">'function' </span><span class="s1">&amp;&amp; define.amd ? define([</span><span class="s3">'exports'</span><span class="s1">, </span><span class="s3">'react'</span><span class="s1">, </span><span class="s3">'scheduler/unstable_mock'</span><span class="s1">, </span><span class="s3">'scheduler'</span><span class="s1">], factory) :</span>
  <span class="s1">(global = global || self, factory(global.ReactTestRenderer = {}, global.React, global.SchedulerMock, global.Scheduler));</span>
<span class="s1">}(</span><span class="s2">this</span><span class="s1">, (</span><span class="s2">function </span><span class="s1">(exports, React, Scheduler, Scheduler$1) { </span><span class="s3">'use strict'</span><span class="s1">;</span>

  <span class="s2">var </span><span class="s1">ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;</span>

  <span class="s0">// by calls to these methods by a Babel plugin.</span>
  <span class="s0">//</span>
  <span class="s0">// In PROD (or in packages without access to React internals),</span>
  <span class="s0">// they are left as they are instead.</span>

  <span class="s2">function </span><span class="s1">warn(format) {</span>
    <span class="s1">{</span>
      <span class="s1">{</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">_len = arguments.length, args = </span><span class="s2">new </span><span class="s1">Array(_len &gt; </span><span class="s4">1 </span><span class="s1">? _len - </span><span class="s4">1 </span><span class="s1">: </span><span class="s4">0</span><span class="s1">), _key = </span><span class="s4">1</span><span class="s1">; _key &lt; _len; _key++) {</span>
          <span class="s1">args[_key - </span><span class="s4">1</span><span class="s1">] = arguments[_key];</span>
        <span class="s1">}</span>

        <span class="s1">printWarning(</span><span class="s3">'warn'</span><span class="s1">, format, args);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">error(format) {</span>
    <span class="s1">{</span>
      <span class="s1">{</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">_len2 = arguments.length, args = </span><span class="s2">new </span><span class="s1">Array(_len2 &gt; </span><span class="s4">1 </span><span class="s1">? _len2 - </span><span class="s4">1 </span><span class="s1">: </span><span class="s4">0</span><span class="s1">), _key2 = </span><span class="s4">1</span><span class="s1">; _key2 &lt; _len2; _key2++) {</span>
          <span class="s1">args[_key2 - </span><span class="s4">1</span><span class="s1">] = arguments[_key2];</span>
        <span class="s1">}</span>

        <span class="s1">printWarning(</span><span class="s3">'error'</span><span class="s1">, format, args);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">printWarning(level, format, args) {</span>
    <span class="s0">// When changing this logic, you might want to also</span>
    <span class="s0">// update consoleWithStackDev.www.js as well.</span>
    <span class="s1">{</span>
      <span class="s2">var </span><span class="s1">ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;</span>
      <span class="s2">var </span><span class="s1">stack = ReactDebugCurrentFrame.getStackAddendum();</span>

      <span class="s2">if </span><span class="s1">(stack !== </span><span class="s3">''</span><span class="s1">) {</span>
        <span class="s1">format += </span><span class="s3">'%s'</span><span class="s1">;</span>
        <span class="s1">args = args.concat([stack]);</span>
      <span class="s1">} </span><span class="s0">// eslint-disable-next-line react-internal/safe-string-coercion</span>


      <span class="s2">var </span><span class="s1">argsWithFormat = args.map(</span><span class="s2">function </span><span class="s1">(item) {</span>
        <span class="s2">return </span><span class="s1">String(item);</span>
      <span class="s1">}); </span><span class="s0">// Careful: RN currently depends on this prefix</span>

      <span class="s1">argsWithFormat.unshift(</span><span class="s3">'Warning: ' </span><span class="s1">+ format); </span><span class="s0">// We intentionally don't use spread (or .apply) directly because it</span>
      <span class="s0">// breaks IE9: https://github.com/facebook/react/issues/13610</span>
      <span class="s0">// eslint-disable-next-line react-internal/no-production-logging</span>

      <span class="s1">Function.prototype.apply.call(console[level], console, argsWithFormat);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">_defineProperties(target, props) {</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; props.length; i++) {</span>
      <span class="s2">var </span><span class="s1">descriptor = props[i];</span>
      <span class="s1">descriptor.enumerable = descriptor.enumerable || </span><span class="s2">false</span><span class="s1">;</span>
      <span class="s1">descriptor.configurable = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s3">&quot;value&quot; </span><span class="s2">in </span><span class="s1">descriptor) descriptor.writable = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s1">Object.defineProperty(target, descriptor.key, descriptor);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">_createClass(Constructor, protoProps, staticProps) {</span>
    <span class="s2">if </span><span class="s1">(protoProps) _defineProperties(Constructor.prototype, protoProps);</span>
    <span class="s2">if </span><span class="s1">(staticProps) _defineProperties(Constructor, staticProps);</span>
    <span class="s2">return </span><span class="s1">Constructor;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">_objectWithoutPropertiesLoose(source, excluded) {</span>
    <span class="s2">if </span><span class="s1">(source == </span><span class="s2">null</span><span class="s1">) </span><span class="s2">return </span><span class="s1">{};</span>
    <span class="s2">var </span><span class="s1">target = {};</span>
    <span class="s2">var </span><span class="s1">sourceKeys = Object.keys(source);</span>
    <span class="s2">var </span><span class="s1">key, i;</span>

    <span class="s2">for </span><span class="s1">(i = </span><span class="s4">0</span><span class="s1">; i &lt; sourceKeys.length; i++) {</span>
      <span class="s1">key = sourceKeys[i];</span>
      <span class="s2">if </span><span class="s1">(excluded.indexOf(key) &gt;= </span><span class="s4">0</span><span class="s1">) </span><span class="s2">continue</span><span class="s1">;</span>
      <span class="s1">target[key] = source[key];</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">target;</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">assign = Object.assign;</span>

  <span class="s0">/** 
   * `ReactInstanceMap` maintains a mapping from a public facing stateful 
   * instance (key) and the internal representation (value). This allows public 
   * methods to accept the user facing instance as an argument and map them back 
   * to internal methods. 
   * 
   * Note that this module is currently shared and assumed to be stateless. 
   * If this becomes an actual Map, that will break. 
   */</span>
  <span class="s2">function </span><span class="s1">get(key) {</span>
    <span class="s2">return </span><span class="s1">key._reactInternals;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">set(key, value) {</span>
    <span class="s1">key._reactInternals = value;</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">enableSchedulingProfiler = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">enableProfilerTimer = </span><span class="s2">true</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">enableProfilerCommitHooks = </span><span class="s2">true</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">warnAboutStringRefs = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">enableSuspenseAvoidThisFallback = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">enableNewReconciler = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">enableLazyContextPropagation = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">enableLegacyHidden = </span><span class="s2">false</span><span class="s1">;</span>

  <span class="s2">var </span><span class="s1">FunctionComponent = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">ClassComponent = </span><span class="s4">1</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">IndeterminateComponent = </span><span class="s4">2</span><span class="s1">; </span><span class="s0">// Before we know whether it is function or class</span>

  <span class="s2">var </span><span class="s1">HostRoot = </span><span class="s4">3</span><span class="s1">; </span><span class="s0">// Root of a host tree. Could be nested inside another node.</span>

  <span class="s2">var </span><span class="s1">HostPortal = </span><span class="s4">4</span><span class="s1">; </span><span class="s0">// A subtree. Could be an entry point to a different renderer.</span>

  <span class="s2">var </span><span class="s1">HostComponent = </span><span class="s4">5</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">HostText = </span><span class="s4">6</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">Fragment = </span><span class="s4">7</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">Mode = </span><span class="s4">8</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">ContextConsumer = </span><span class="s4">9</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">ContextProvider = </span><span class="s4">10</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">ForwardRef = </span><span class="s4">11</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">Profiler = </span><span class="s4">12</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">SuspenseComponent = </span><span class="s4">13</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">MemoComponent = </span><span class="s4">14</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">SimpleMemoComponent = </span><span class="s4">15</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">LazyComponent = </span><span class="s4">16</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">IncompleteClassComponent = </span><span class="s4">17</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">DehydratedFragment = </span><span class="s4">18</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">SuspenseListComponent = </span><span class="s4">19</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">ScopeComponent = </span><span class="s4">21</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">OffscreenComponent = </span><span class="s4">22</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">LegacyHiddenComponent = </span><span class="s4">23</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">CacheComponent = </span><span class="s4">24</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">TracingMarkerComponent = </span><span class="s4">25</span><span class="s1">;</span>

  <span class="s0">// ATTENTION</span>
  <span class="s0">// When adding new symbols to this file,</span>
  <span class="s0">// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'</span>
  <span class="s0">// The Symbol used to tag the ReactElement-like types.</span>
  <span class="s2">var </span><span class="s1">REACT_ELEMENT_TYPE = Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.element'</span><span class="s1">);</span>
  <span class="s2">var </span><span class="s1">REACT_PORTAL_TYPE = Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.portal'</span><span class="s1">);</span>
  <span class="s2">var </span><span class="s1">REACT_FRAGMENT_TYPE = Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.fragment'</span><span class="s1">);</span>
  <span class="s2">var </span><span class="s1">REACT_STRICT_MODE_TYPE = Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.strict_mode'</span><span class="s1">);</span>
  <span class="s2">var </span><span class="s1">REACT_PROFILER_TYPE = Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.profiler'</span><span class="s1">);</span>
  <span class="s2">var </span><span class="s1">REACT_PROVIDER_TYPE = Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.provider'</span><span class="s1">);</span>
  <span class="s2">var </span><span class="s1">REACT_CONTEXT_TYPE = Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.context'</span><span class="s1">);</span>
  <span class="s2">var </span><span class="s1">REACT_FORWARD_REF_TYPE = Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.forward_ref'</span><span class="s1">);</span>
  <span class="s2">var </span><span class="s1">REACT_SUSPENSE_TYPE = Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.suspense'</span><span class="s1">);</span>
  <span class="s2">var </span><span class="s1">REACT_SUSPENSE_LIST_TYPE = Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.suspense_list'</span><span class="s1">);</span>
  <span class="s2">var </span><span class="s1">REACT_MEMO_TYPE = Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.memo'</span><span class="s1">);</span>
  <span class="s2">var </span><span class="s1">REACT_LAZY_TYPE = Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.lazy'</span><span class="s1">);</span>
  <span class="s2">var </span><span class="s1">REACT_SCOPE_TYPE = Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.scope'</span><span class="s1">);</span>
  <span class="s2">var </span><span class="s1">REACT_DEBUG_TRACING_MODE_TYPE = Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.debug_trace_mode'</span><span class="s1">);</span>
  <span class="s2">var </span><span class="s1">REACT_OFFSCREEN_TYPE = Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.offscreen'</span><span class="s1">);</span>
  <span class="s2">var </span><span class="s1">REACT_LEGACY_HIDDEN_TYPE = Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.legacy_hidden'</span><span class="s1">);</span>
  <span class="s2">var </span><span class="s1">REACT_CACHE_TYPE = Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.cache'</span><span class="s1">);</span>
  <span class="s2">var </span><span class="s1">REACT_TRACING_MARKER_TYPE = Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.tracing_marker'</span><span class="s1">);</span>
  <span class="s2">var </span><span class="s1">MAYBE_ITERATOR_SYMBOL = Symbol.iterator;</span>
  <span class="s2">var </span><span class="s1">FAUX_ITERATOR_SYMBOL = </span><span class="s3">'@@iterator'</span><span class="s1">;</span>
  <span class="s2">function </span><span class="s1">getIteratorFn(maybeIterable) {</span>
    <span class="s2">if </span><span class="s1">(maybeIterable === </span><span class="s2">null </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">maybeIterable !== </span><span class="s3">'object'</span><span class="s1">) {</span>
      <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">maybeIterator = MAYBE_ITERATOR_SYMBOL &amp;&amp; maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];</span>

    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">maybeIterator === </span><span class="s3">'function'</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">maybeIterator;</span>
    <span class="s1">}</span>

    <span class="s2">return null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">getWrappedName(outerType, innerType, wrapperName) {</span>
    <span class="s2">var </span><span class="s1">displayName = outerType.displayName;</span>

    <span class="s2">if </span><span class="s1">(displayName) {</span>
      <span class="s2">return </span><span class="s1">displayName;</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">functionName = innerType.displayName || innerType.name || </span><span class="s3">''</span><span class="s1">;</span>
    <span class="s2">return </span><span class="s1">functionName !== </span><span class="s3">'' </span><span class="s1">? wrapperName + </span><span class="s3">&quot;(&quot; </span><span class="s1">+ functionName + </span><span class="s3">&quot;)&quot; </span><span class="s1">: wrapperName;</span>
  <span class="s1">} </span><span class="s0">// Keep in sync with react-reconciler/getComponentNameFromFiber</span>


  <span class="s2">function </span><span class="s1">getContextName(type) {</span>
    <span class="s2">return </span><span class="s1">type.displayName || </span><span class="s3">'Context'</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s0">// Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.</span>


  <span class="s2">function </span><span class="s1">getComponentNameFromType(type) {</span>
    <span class="s2">if </span><span class="s1">(type == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s0">// Host root, text node or just invalid type.</span>
      <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">type.tag === </span><span class="s3">'number'</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s3">'Received an unexpected object in getComponentNameFromType(). ' </span><span class="s1">+ </span><span class="s3">'This is likely a bug in React. Please file an issue.'</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">type === </span><span class="s3">'function'</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">type.displayName || type.name || </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">type === </span><span class="s3">'string'</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">type;</span>
    <span class="s1">}</span>

    <span class="s2">switch </span><span class="s1">(type) {</span>
      <span class="s2">case </span><span class="s1">REACT_FRAGMENT_TYPE:</span>
        <span class="s2">return </span><span class="s3">'Fragment'</span><span class="s1">;</span>

      <span class="s2">case </span><span class="s1">REACT_PORTAL_TYPE:</span>
        <span class="s2">return </span><span class="s3">'Portal'</span><span class="s1">;</span>

      <span class="s2">case </span><span class="s1">REACT_PROFILER_TYPE:</span>
        <span class="s2">return </span><span class="s3">'Profiler'</span><span class="s1">;</span>

      <span class="s2">case </span><span class="s1">REACT_STRICT_MODE_TYPE:</span>
        <span class="s2">return </span><span class="s3">'StrictMode'</span><span class="s1">;</span>

      <span class="s2">case </span><span class="s1">REACT_SUSPENSE_TYPE:</span>
        <span class="s2">return </span><span class="s3">'Suspense'</span><span class="s1">;</span>

      <span class="s2">case </span><span class="s1">REACT_SUSPENSE_LIST_TYPE:</span>
        <span class="s2">return </span><span class="s3">'SuspenseList'</span><span class="s1">;</span>

    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">type === </span><span class="s3">'object'</span><span class="s1">) {</span>
      <span class="s2">switch </span><span class="s1">(type.$$typeof) {</span>
        <span class="s2">case </span><span class="s1">REACT_CONTEXT_TYPE:</span>
          <span class="s2">var </span><span class="s1">context = type;</span>
          <span class="s2">return </span><span class="s1">getContextName(context) + </span><span class="s3">'.Consumer'</span><span class="s1">;</span>

        <span class="s2">case </span><span class="s1">REACT_PROVIDER_TYPE:</span>
          <span class="s2">var </span><span class="s1">provider = type;</span>
          <span class="s2">return </span><span class="s1">getContextName(provider._context) + </span><span class="s3">'.Provider'</span><span class="s1">;</span>

        <span class="s2">case </span><span class="s1">REACT_FORWARD_REF_TYPE:</span>
          <span class="s2">return </span><span class="s1">getWrappedName(type, type.render, </span><span class="s3">'ForwardRef'</span><span class="s1">);</span>

        <span class="s2">case </span><span class="s1">REACT_MEMO_TYPE:</span>
          <span class="s2">var </span><span class="s1">outerName = type.displayName || </span><span class="s2">null</span><span class="s1">;</span>

          <span class="s2">if </span><span class="s1">(outerName !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">outerName;</span>
          <span class="s1">}</span>

          <span class="s2">return </span><span class="s1">getComponentNameFromType(type.type) || </span><span class="s3">'Memo'</span><span class="s1">;</span>

        <span class="s2">case </span><span class="s1">REACT_LAZY_TYPE:</span>
          <span class="s1">{</span>
            <span class="s2">var </span><span class="s1">lazyComponent = type;</span>
            <span class="s2">var </span><span class="s1">payload = lazyComponent._payload;</span>
            <span class="s2">var </span><span class="s1">init = lazyComponent._init;</span>

            <span class="s2">try </span><span class="s1">{</span>
              <span class="s2">return </span><span class="s1">getComponentNameFromType(init(payload));</span>
            <span class="s1">} </span><span class="s2">catch </span><span class="s1">(x) {</span>
              <span class="s2">return null</span><span class="s1">;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

        <span class="s0">// eslint-disable-next-line no-fallthrough</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">getWrappedName$1(outerType, innerType, wrapperName) {</span>
    <span class="s2">var </span><span class="s1">functionName = innerType.displayName || innerType.name || </span><span class="s3">''</span><span class="s1">;</span>
    <span class="s2">return </span><span class="s1">outerType.displayName || (functionName !== </span><span class="s3">'' </span><span class="s1">? wrapperName + </span><span class="s3">&quot;(&quot; </span><span class="s1">+ functionName + </span><span class="s3">&quot;)&quot; </span><span class="s1">: wrapperName);</span>
  <span class="s1">} </span><span class="s0">// Keep in sync with shared/getComponentNameFromType</span>


  <span class="s2">function </span><span class="s1">getContextName$1(type) {</span>
    <span class="s2">return </span><span class="s1">type.displayName || </span><span class="s3">'Context'</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">getComponentNameFromFiber(fiber) {</span>
    <span class="s2">var </span><span class="s1">tag = fiber.tag,</span>
        <span class="s1">type = fiber.type;</span>

    <span class="s2">switch </span><span class="s1">(tag) {</span>
      <span class="s2">case </span><span class="s1">CacheComponent:</span>
        <span class="s2">return </span><span class="s3">'Cache'</span><span class="s1">;</span>

      <span class="s2">case </span><span class="s1">ContextConsumer:</span>
        <span class="s2">var </span><span class="s1">context = type;</span>
        <span class="s2">return </span><span class="s1">getContextName$1(context) + </span><span class="s3">'.Consumer'</span><span class="s1">;</span>

      <span class="s2">case </span><span class="s1">ContextProvider:</span>
        <span class="s2">var </span><span class="s1">provider = type;</span>
        <span class="s2">return </span><span class="s1">getContextName$1(provider._context) + </span><span class="s3">'.Provider'</span><span class="s1">;</span>

      <span class="s2">case </span><span class="s1">DehydratedFragment:</span>
        <span class="s2">return </span><span class="s3">'DehydratedFragment'</span><span class="s1">;</span>

      <span class="s2">case </span><span class="s1">ForwardRef:</span>
        <span class="s2">return </span><span class="s1">getWrappedName$1(type, type.render, </span><span class="s3">'ForwardRef'</span><span class="s1">);</span>

      <span class="s2">case </span><span class="s1">Fragment:</span>
        <span class="s2">return </span><span class="s3">'Fragment'</span><span class="s1">;</span>

      <span class="s2">case </span><span class="s1">HostComponent:</span>
        <span class="s0">// Host component type is the display name (e.g. &quot;div&quot;, &quot;View&quot;)</span>
        <span class="s2">return </span><span class="s1">type;</span>

      <span class="s2">case </span><span class="s1">HostPortal:</span>
        <span class="s2">return </span><span class="s3">'Portal'</span><span class="s1">;</span>

      <span class="s2">case </span><span class="s1">HostRoot:</span>
        <span class="s2">return </span><span class="s3">'Root'</span><span class="s1">;</span>

      <span class="s2">case </span><span class="s1">HostText:</span>
        <span class="s2">return </span><span class="s3">'Text'</span><span class="s1">;</span>

      <span class="s2">case </span><span class="s1">LazyComponent:</span>
        <span class="s0">// Name comes from the type in this case; we don't have a tag.</span>
        <span class="s2">return </span><span class="s1">getComponentNameFromType(type);</span>

      <span class="s2">case </span><span class="s1">Mode:</span>
        <span class="s2">if </span><span class="s1">(type === REACT_STRICT_MODE_TYPE) {</span>
          <span class="s0">// Don't be less specific than shared/getComponentNameFromType</span>
          <span class="s2">return </span><span class="s3">'StrictMode'</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s2">return </span><span class="s3">'Mode'</span><span class="s1">;</span>

      <span class="s2">case </span><span class="s1">OffscreenComponent:</span>
        <span class="s2">return </span><span class="s3">'Offscreen'</span><span class="s1">;</span>

      <span class="s2">case </span><span class="s1">Profiler:</span>
        <span class="s2">return </span><span class="s3">'Profiler'</span><span class="s1">;</span>

      <span class="s2">case </span><span class="s1">ScopeComponent:</span>
        <span class="s2">return </span><span class="s3">'Scope'</span><span class="s1">;</span>

      <span class="s2">case </span><span class="s1">SuspenseComponent:</span>
        <span class="s2">return </span><span class="s3">'Suspense'</span><span class="s1">;</span>

      <span class="s2">case </span><span class="s1">SuspenseListComponent:</span>
        <span class="s2">return </span><span class="s3">'SuspenseList'</span><span class="s1">;</span>

      <span class="s2">case </span><span class="s1">TracingMarkerComponent:</span>
        <span class="s2">return </span><span class="s3">'TracingMarker'</span><span class="s1">;</span>
      <span class="s0">// The display name for this tags come from the user-provided type:</span>

      <span class="s2">case </span><span class="s1">ClassComponent:</span>
      <span class="s2">case </span><span class="s1">FunctionComponent:</span>
      <span class="s2">case </span><span class="s1">IncompleteClassComponent:</span>
      <span class="s2">case </span><span class="s1">IndeterminateComponent:</span>
      <span class="s2">case </span><span class="s1">MemoComponent:</span>
      <span class="s2">case </span><span class="s1">SimpleMemoComponent:</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">type === </span><span class="s3">'function'</span><span class="s1">) {</span>
          <span class="s2">return </span><span class="s1">type.displayName || type.name || </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">type === </span><span class="s3">'string'</span><span class="s1">) {</span>
          <span class="s2">return </span><span class="s1">type;</span>
        <span class="s1">}</span>

        <span class="s2">break</span><span class="s1">;</span>

    <span class="s1">}</span>

    <span class="s2">return null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s0">// Don't change these two values. They're used by React Dev Tools.</span>
  <span class="s2">var </span><span class="s1">NoFlags =</span>
  <span class="s0">/*                      */</span>
  <span class="s4">0</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">PerformedWork =</span>
  <span class="s0">/*                */</span>
  <span class="s4">1</span><span class="s1">; </span><span class="s0">// You can change the rest (and add more).</span>

  <span class="s2">var </span><span class="s1">Placement =</span>
  <span class="s0">/*                    */</span>
  <span class="s4">2</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">Update =</span>
  <span class="s0">/*                       */</span>
  <span class="s4">4</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">ChildDeletion =</span>
  <span class="s0">/*                */</span>
  <span class="s4">16</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">ContentReset =</span>
  <span class="s0">/*                 */</span>
  <span class="s4">32</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">Callback =</span>
  <span class="s0">/*                     */</span>
  <span class="s4">64</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">DidCapture =</span>
  <span class="s0">/*                   */</span>
  <span class="s4">128</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">ForceClientRender =</span>
  <span class="s0">/*            */</span>
  <span class="s4">256</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">Ref =</span>
  <span class="s0">/*                          */</span>
  <span class="s4">512</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">Snapshot =</span>
  <span class="s0">/*                     */</span>
  <span class="s4">1024</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">Passive =</span>
  <span class="s0">/*                      */</span>
  <span class="s4">2048</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">Hydrating =</span>
  <span class="s0">/*                    */</span>
  <span class="s4">4096</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">Visibility =</span>
  <span class="s0">/*                   */</span>
  <span class="s4">8192</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">StoreConsistency =</span>
  <span class="s0">/*             */</span>
  <span class="s4">16384</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">LifecycleEffectMask = Passive | Update | Callback | Ref | Snapshot | StoreConsistency; </span><span class="s0">// Union of all commit flags (flags with the lifetime of a particular commit)</span>

  <span class="s2">var </span><span class="s1">HostEffectMask =</span>
  <span class="s0">/*               */</span>
  <span class="s4">32767</span><span class="s1">; </span><span class="s0">// These are not really side effects, but we still reuse this field.</span>

  <span class="s2">var </span><span class="s1">Incomplete =</span>
  <span class="s0">/*                   */</span>
  <span class="s4">32768</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">ShouldCapture =</span>
  <span class="s0">/*                */</span>
  <span class="s4">65536</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">ForceUpdateForLegacySuspense =</span>
  <span class="s0">/* */</span>
  <span class="s4">131072</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">Forked =</span>
  <span class="s0">/*                       */</span>
  <span class="s4">1048576</span><span class="s1">; </span><span class="s0">// Static tags describe aspects of a fiber that are not specific to a render,</span>
  <span class="s0">// e.g. a fiber uses a passive effect (even if there are no updates on this particular render).</span>
  <span class="s0">// This enables us to defer more work in the unmount case,</span>
  <span class="s0">// since we can defer traversing the tree during layout to look for Passive effects,</span>
  <span class="s0">// and instead rely on the static flag as a signal that there may be cleanup work.</span>

  <span class="s2">var </span><span class="s1">RefStatic =</span>
  <span class="s0">/*                    */</span>
  <span class="s4">2097152</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">LayoutStatic =</span>
  <span class="s0">/*                 */</span>
  <span class="s4">4194304</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">PassiveStatic =</span>
  <span class="s0">/*                */</span>
  <span class="s4">8388608</span><span class="s1">; </span><span class="s0">// These flags allow us to traverse to fibers that have effects on mount</span>
  <span class="s0">// don't contain effects, by checking subtreeFlags.</span>

  <span class="s2">var </span><span class="s1">BeforeMutationMask = </span><span class="s0">// TODO: Remove Update flag from before mutation phase by re-landing Visibility</span>
  <span class="s0">// flag logic (see #20043)</span>
  <span class="s1">Update | Snapshot | ( </span><span class="s4">0</span><span class="s1">);</span>
  <span class="s2">var </span><span class="s1">MutationMask = Placement | Update | ChildDeletion | ContentReset | Ref | Hydrating | Visibility;</span>
  <span class="s2">var </span><span class="s1">LayoutMask = Update | Callback | Ref | Visibility; </span><span class="s0">// TODO: Split into PassiveMountMask and PassiveUnmountMask</span>

  <span class="s2">var </span><span class="s1">PassiveMask = Passive | ChildDeletion; </span><span class="s0">// Union of tags that don't get reset on clones.</span>
  <span class="s0">// This allows certain concepts to persist without recalculating them,</span>
  <span class="s0">// e.g. whether a subtree contains passive effects or portals.</span>

  <span class="s2">var </span><span class="s1">StaticMask = LayoutStatic | PassiveStatic | RefStatic;</span>

  <span class="s2">var </span><span class="s1">ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;</span>
  <span class="s2">function </span><span class="s1">getNearestMountedFiber(fiber) {</span>
    <span class="s2">var </span><span class="s1">node = fiber;</span>
    <span class="s2">var </span><span class="s1">nearestMounted = fiber;</span>

    <span class="s2">if </span><span class="s1">(!fiber.alternate) {</span>
      <span class="s0">// If there is no alternate, this might be a new tree that isn't inserted</span>
      <span class="s0">// yet. If it is, then it will have a pending insertion effect on it.</span>
      <span class="s2">var </span><span class="s1">nextNode = node;</span>

      <span class="s2">do </span><span class="s1">{</span>
        <span class="s1">node = nextNode;</span>

        <span class="s2">if </span><span class="s1">((node.flags &amp; (Placement | Hydrating)) !== NoFlags) {</span>
          <span class="s0">// This is an insertion or in-progress hydration. The nearest possible</span>
          <span class="s0">// mounted fiber is the parent but we need to continue to figure out</span>
          <span class="s0">// if that one is still mounted.</span>
          <span class="s1">nearestMounted = node.</span><span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">nextNode = node.</span><span class="s2">return</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s2">while </span><span class="s1">(nextNode);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">while </span><span class="s1">(node.</span><span class="s2">return</span><span class="s1">) {</span>
        <span class="s1">node = node.</span><span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(node.tag === HostRoot) {</span>
      <span class="s0">// TODO: Check if this was a nested HostRoot when used with</span>
      <span class="s0">// renderContainerIntoSubtree.</span>
      <span class="s2">return </span><span class="s1">nearestMounted;</span>
    <span class="s1">} </span><span class="s0">// If we didn't hit the root, that means that we're in an disconnected tree</span>
    <span class="s0">// that has been unmounted.</span>


    <span class="s2">return null</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">isFiberMounted(fiber) {</span>
    <span class="s2">return </span><span class="s1">getNearestMountedFiber(fiber) === fiber;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">isMounted(component) {</span>
    <span class="s1">{</span>
      <span class="s2">var </span><span class="s1">owner = ReactCurrentOwner.current;</span>

      <span class="s2">if </span><span class="s1">(owner !== </span><span class="s2">null </span><span class="s1">&amp;&amp; owner.tag === ClassComponent) {</span>
        <span class="s2">var </span><span class="s1">ownerFiber = owner;</span>
        <span class="s2">var </span><span class="s1">instance = ownerFiber.stateNode;</span>

        <span class="s2">if </span><span class="s1">(!instance._warnedAboutRefsInRender) {</span>
          <span class="s1">error(</span><span class="s3">'%s is accessing isMounted inside its render() function. ' </span><span class="s1">+ </span><span class="s3">'render() should be a pure function of props and state. It should ' </span><span class="s1">+ </span><span class="s3">'never access something that requires stale data from the previous ' </span><span class="s1">+ </span><span class="s3">'render, such as refs. Move this logic to componentDidMount and ' </span><span class="s1">+ </span><span class="s3">'componentDidUpdate instead.'</span><span class="s1">, getComponentNameFromFiber(ownerFiber) || </span><span class="s3">'A component'</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s1">instance._warnedAboutRefsInRender = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">fiber = get(component);</span>

    <span class="s2">if </span><span class="s1">(!fiber) {</span>
      <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">getNearestMountedFiber(fiber) === fiber;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">assertIsMounted(fiber) {</span>
    <span class="s2">if </span><span class="s1">(getNearestMountedFiber(fiber) !== fiber) {</span>
      <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Unable to find node on an unmounted component.'</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">findCurrentFiberUsingSlowPath(fiber) {</span>
    <span class="s2">var </span><span class="s1">alternate = fiber.alternate;</span>

    <span class="s2">if </span><span class="s1">(!alternate) {</span>
      <span class="s0">// If there is no alternate, then we only need to check if it is mounted.</span>
      <span class="s2">var </span><span class="s1">nearestMounted = getNearestMountedFiber(fiber);</span>

      <span class="s2">if </span><span class="s1">(nearestMounted === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Unable to find node on an unmounted component.'</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(nearestMounted !== fiber) {</span>
        <span class="s2">return null</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">return </span><span class="s1">fiber;</span>
    <span class="s1">} </span><span class="s0">// If we have two possible branches, we'll walk backwards up to the root</span>
    <span class="s0">// to see what path the root points to. On the way we may hit one of the</span>
    <span class="s0">// special cases and we'll deal with them.</span>


    <span class="s2">var </span><span class="s1">a = fiber;</span>
    <span class="s2">var </span><span class="s1">b = alternate;</span>

    <span class="s2">while </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">parentA = a.</span><span class="s2">return</span><span class="s1">;</span>

      <span class="s2">if </span><span class="s1">(parentA === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s0">// We're at the root.</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">parentB = parentA.alternate;</span>

      <span class="s2">if </span><span class="s1">(parentB === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s0">// There is no alternate. This is an unusual case. Currently, it only</span>
        <span class="s0">// happens when a Suspense component is hidden. An extra fragment fiber</span>
        <span class="s0">// is inserted in between the Suspense fiber and its children. Skip</span>
        <span class="s0">// over this extra fragment fiber and proceed to the next parent.</span>
        <span class="s2">var </span><span class="s1">nextParent = parentA.</span><span class="s2">return</span><span class="s1">;</span>

        <span class="s2">if </span><span class="s1">(nextParent !== </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">a = b = nextParent;</span>
          <span class="s2">continue</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s0">// If there's no parent, we're at the root.</span>


        <span class="s2">break</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// If both copies of the parent fiber point to the same child, we can</span>
      <span class="s0">// assume that the child is current. This happens when we bailout on low</span>
      <span class="s0">// priority: the bailed out fiber's child reuses the current child.</span>


      <span class="s2">if </span><span class="s1">(parentA.child === parentB.child) {</span>
        <span class="s2">var </span><span class="s1">child = parentA.child;</span>

        <span class="s2">while </span><span class="s1">(child) {</span>
          <span class="s2">if </span><span class="s1">(child === a) {</span>
            <span class="s0">// We've determined that A is the current branch.</span>
            <span class="s1">assertIsMounted(parentA);</span>
            <span class="s2">return </span><span class="s1">fiber;</span>
          <span class="s1">}</span>

          <span class="s2">if </span><span class="s1">(child === b) {</span>
            <span class="s0">// We've determined that B is the current branch.</span>
            <span class="s1">assertIsMounted(parentA);</span>
            <span class="s2">return </span><span class="s1">alternate;</span>
          <span class="s1">}</span>

          <span class="s1">child = child.sibling;</span>
        <span class="s1">} </span><span class="s0">// We should never have an alternate for any mounting node. So the only</span>
        <span class="s0">// way this could possibly happen is if this was unmounted, if at all.</span>


        <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Unable to find node on an unmounted component.'</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(a.</span><span class="s2">return </span><span class="s1">!== b.</span><span class="s2">return</span><span class="s1">) {</span>
        <span class="s0">// The return pointer of A and the return pointer of B point to different</span>
        <span class="s0">// fibers. We assume that return pointers never criss-cross, so A must</span>
        <span class="s0">// belong to the child set of A.return, and B must belong to the child</span>
        <span class="s0">// set of B.return.</span>
        <span class="s1">a = parentA;</span>
        <span class="s1">b = parentB;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s0">// The return pointers point to the same fiber. We'll have to use the</span>
        <span class="s0">// default, slow path: scan the child sets of each parent alternate to see</span>
        <span class="s0">// which child belongs to which set.</span>
        <span class="s0">//</span>
        <span class="s0">// Search parent A's child set</span>
        <span class="s2">var </span><span class="s1">didFindChild = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s2">var </span><span class="s1">_child = parentA.child;</span>

        <span class="s2">while </span><span class="s1">(_child) {</span>
          <span class="s2">if </span><span class="s1">(_child === a) {</span>
            <span class="s1">didFindChild = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">a = parentA;</span>
            <span class="s1">b = parentB;</span>
            <span class="s2">break</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s2">if </span><span class="s1">(_child === b) {</span>
            <span class="s1">didFindChild = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">b = parentA;</span>
            <span class="s1">a = parentB;</span>
            <span class="s2">break</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s1">_child = _child.sibling;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(!didFindChild) {</span>
          <span class="s0">// Search parent B's child set</span>
          <span class="s1">_child = parentB.child;</span>

          <span class="s2">while </span><span class="s1">(_child) {</span>
            <span class="s2">if </span><span class="s1">(_child === a) {</span>
              <span class="s1">didFindChild = </span><span class="s2">true</span><span class="s1">;</span>
              <span class="s1">a = parentB;</span>
              <span class="s1">b = parentA;</span>
              <span class="s2">break</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s2">if </span><span class="s1">(_child === b) {</span>
              <span class="s1">didFindChild = </span><span class="s2">true</span><span class="s1">;</span>
              <span class="s1">b = parentB;</span>
              <span class="s1">a = parentA;</span>
              <span class="s2">break</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s1">_child = _child.sibling;</span>
          <span class="s1">}</span>

          <span class="s2">if </span><span class="s1">(!didFindChild) {</span>
            <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Child was not found in either parent set. This indicates a bug ' </span><span class="s1">+ </span><span class="s3">'in React related to the return pointer. Please file an issue.'</span><span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(a.alternate !== b) {</span>
        <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">&quot;Return fibers should always be each others' alternates. &quot; </span><span class="s1">+ </span><span class="s3">'This error is likely caused by a bug in React. Please file an issue.'</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// If the root is not a host container, we're in a disconnected tree. I.e.</span>
    <span class="s0">// unmounted.</span>


    <span class="s2">if </span><span class="s1">(a.tag !== HostRoot) {</span>
      <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Unable to find node on an unmounted component.'</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(a.stateNode.current === a) {</span>
      <span class="s0">// We've determined that A is the current branch.</span>
      <span class="s2">return </span><span class="s1">fiber;</span>
    <span class="s1">} </span><span class="s0">// Otherwise B has to be current branch.</span>


    <span class="s2">return </span><span class="s1">alternate;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">findCurrentHostFiber(parent) {</span>
    <span class="s2">var </span><span class="s1">currentParent = findCurrentFiberUsingSlowPath(parent);</span>
    <span class="s2">return </span><span class="s1">currentParent !== </span><span class="s2">null </span><span class="s1">? findCurrentHostFiberImpl(currentParent) : </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">findCurrentHostFiberImpl(node) {</span>
    <span class="s0">// Next we'll drill down this component to find the first HostComponent/Text.</span>
    <span class="s2">if </span><span class="s1">(node.tag === HostComponent || node.tag === HostText) {</span>
      <span class="s2">return </span><span class="s1">node;</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">child = node.child;</span>

    <span class="s2">while </span><span class="s1">(child !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">match = findCurrentHostFiberImpl(child);</span>

      <span class="s2">if </span><span class="s1">(match !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">match;</span>
      <span class="s1">}</span>

      <span class="s1">child = child.sibling;</span>
    <span class="s1">}</span>

    <span class="s2">return null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">isArrayImpl = Array.isArray; </span><span class="s0">// eslint-disable-next-line no-redeclare</span>

  <span class="s2">function </span><span class="s1">isArray(a) {</span>
    <span class="s2">return </span><span class="s1">isArrayImpl(a);</span>
  <span class="s1">}</span>

  <span class="s0">// This module only exists as an ESM wrapper around the external CommonJS</span>
  <span class="s2">var </span><span class="s1">scheduleCallback = Scheduler$1.unstable_scheduleCallback;</span>
  <span class="s2">var </span><span class="s1">cancelCallback = Scheduler$1.unstable_cancelCallback;</span>
  <span class="s2">var </span><span class="s1">shouldYield = Scheduler$1.unstable_shouldYield;</span>
  <span class="s2">var </span><span class="s1">requestPaint = Scheduler$1.unstable_requestPaint;</span>
  <span class="s2">var </span><span class="s1">now = Scheduler$1.unstable_now;</span>
  <span class="s2">var </span><span class="s1">ImmediatePriority = Scheduler$1.unstable_ImmediatePriority;</span>
  <span class="s2">var </span><span class="s1">UserBlockingPriority = Scheduler$1.unstable_UserBlockingPriority;</span>
  <span class="s2">var </span><span class="s1">NormalPriority = Scheduler$1.unstable_NormalPriority;</span>
  <span class="s2">var </span><span class="s1">IdlePriority = Scheduler$1.unstable_IdlePriority;</span>

  <span class="s0">// Helpers to patch console.logs to avoid logging during side-effect free</span>
  <span class="s0">// replaying on render function. This currently only patches the object</span>
  <span class="s0">// lazily which won't cover if the log function was extracted eagerly.</span>
  <span class="s0">// We could also eagerly patch the method.</span>
  <span class="s2">var </span><span class="s1">disabledDepth = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">prevLog;</span>
  <span class="s2">var </span><span class="s1">prevInfo;</span>
  <span class="s2">var </span><span class="s1">prevWarn;</span>
  <span class="s2">var </span><span class="s1">prevError;</span>
  <span class="s2">var </span><span class="s1">prevGroup;</span>
  <span class="s2">var </span><span class="s1">prevGroupCollapsed;</span>
  <span class="s2">var </span><span class="s1">prevGroupEnd;</span>

  <span class="s2">function </span><span class="s1">disabledLog() {}</span>

  <span class="s1">disabledLog.__reactDisabledLog = </span><span class="s2">true</span><span class="s1">;</span>
  <span class="s2">function </span><span class="s1">disableLogs() {</span>
    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(disabledDepth === </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s0">/* eslint-disable react-internal/no-production-logging */</span>
        <span class="s1">prevLog = console.log;</span>
        <span class="s1">prevInfo = console.info;</span>
        <span class="s1">prevWarn = console.warn;</span>
        <span class="s1">prevError = console.error;</span>
        <span class="s1">prevGroup = console.group;</span>
        <span class="s1">prevGroupCollapsed = console.groupCollapsed;</span>
        <span class="s1">prevGroupEnd = console.groupEnd; </span><span class="s0">// https://github.com/facebook/react/issues/19099</span>

        <span class="s2">var </span><span class="s1">props = {</span>
          <span class="s1">configurable: </span><span class="s2">true</span><span class="s1">,</span>
          <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
          <span class="s1">value: disabledLog,</span>
          <span class="s1">writable: </span><span class="s2">true</span>
        <span class="s1">}; </span><span class="s0">// $FlowFixMe Flow thinks console is immutable.</span>

        <span class="s1">Object.defineProperties(console, {</span>
          <span class="s1">info: props,</span>
          <span class="s1">log: props,</span>
          <span class="s1">warn: props,</span>
          <span class="s1">error: props,</span>
          <span class="s1">group: props,</span>
          <span class="s1">groupCollapsed: props,</span>
          <span class="s1">groupEnd: props</span>
        <span class="s1">});</span>
        <span class="s0">/* eslint-enable react-internal/no-production-logging */</span>
      <span class="s1">}</span>

      <span class="s1">disabledDepth++;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">reenableLogs() {</span>
    <span class="s1">{</span>
      <span class="s1">disabledDepth--;</span>

      <span class="s2">if </span><span class="s1">(disabledDepth === </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s0">/* eslint-disable react-internal/no-production-logging */</span>
        <span class="s2">var </span><span class="s1">props = {</span>
          <span class="s1">configurable: </span><span class="s2">true</span><span class="s1">,</span>
          <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
          <span class="s1">writable: </span><span class="s2">true</span>
        <span class="s1">}; </span><span class="s0">// $FlowFixMe Flow thinks console is immutable.</span>

        <span class="s1">Object.defineProperties(console, {</span>
          <span class="s1">log: assign({}, props, {</span>
            <span class="s1">value: prevLog</span>
          <span class="s1">}),</span>
          <span class="s1">info: assign({}, props, {</span>
            <span class="s1">value: prevInfo</span>
          <span class="s1">}),</span>
          <span class="s1">warn: assign({}, props, {</span>
            <span class="s1">value: prevWarn</span>
          <span class="s1">}),</span>
          <span class="s1">error: assign({}, props, {</span>
            <span class="s1">value: prevError</span>
          <span class="s1">}),</span>
          <span class="s1">group: assign({}, props, {</span>
            <span class="s1">value: prevGroup</span>
          <span class="s1">}),</span>
          <span class="s1">groupCollapsed: assign({}, props, {</span>
            <span class="s1">value: prevGroupCollapsed</span>
          <span class="s1">}),</span>
          <span class="s1">groupEnd: assign({}, props, {</span>
            <span class="s1">value: prevGroupEnd</span>
          <span class="s1">})</span>
        <span class="s1">});</span>
        <span class="s0">/* eslint-enable react-internal/no-production-logging */</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(disabledDepth &lt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s3">'disabledDepth fell below zero. ' </span><span class="s1">+ </span><span class="s3">'This is a bug in React. Please file an issue.'</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">rendererID = </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">injectedHook = </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">hasLoggedError = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">isDevToolsPresent = </span><span class="s2">typeof </span><span class="s1">__REACT_DEVTOOLS_GLOBAL_HOOK__ !== </span><span class="s3">'undefined'</span><span class="s1">;</span>
  <span class="s2">function </span><span class="s1">injectInternals(internals) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">__REACT_DEVTOOLS_GLOBAL_HOOK__ === </span><span class="s3">'undefined'</span><span class="s1">) {</span>
      <span class="s0">// No DevTools</span>
      <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;</span>

    <span class="s2">if </span><span class="s1">(hook.isDisabled) {</span>
      <span class="s0">// This isn't a real property on the hook, but it can be set to opt out</span>
      <span class="s0">// of DevTools integration and associated warnings and logs.</span>
      <span class="s0">// https://github.com/facebook/react/issues/3877</span>
      <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(!hook.supportsFiber) {</span>
      <span class="s1">{</span>
        <span class="s1">error(</span><span class="s3">'The installed version of React DevTools is too old and will not work ' </span><span class="s1">+ </span><span class="s3">'with the current version of React. Please update React DevTools. ' </span><span class="s1">+ </span><span class="s3">'https://reactjs.org/link/react-devtools'</span><span class="s1">);</span>
      <span class="s1">} </span><span class="s0">// DevTools exists, even though it doesn't support Fiber.</span>


      <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">try </span><span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(enableSchedulingProfiler) {</span>
        <span class="s0">// Conditionally inject these hooks only if Timeline profiler is supported by this build.</span>
        <span class="s0">// This gives DevTools a way to feature detect that isn't tied to version number</span>
        <span class="s0">// (since profiling and timeline are controlled by different feature flags).</span>
        <span class="s1">internals = assign({}, internals, {</span>
          <span class="s1">getLaneLabelMap: getLaneLabelMap,</span>
          <span class="s1">injectProfilingHooks: injectProfilingHooks</span>
        <span class="s1">});</span>
      <span class="s1">}</span>

      <span class="s1">rendererID = hook.inject(internals); </span><span class="s0">// We have successfully injected, so now it is safe to set up hooks.</span>

      <span class="s1">injectedHook = hook;</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
      <span class="s0">// Catch all errors because it is unsafe to throw during initialization.</span>
      <span class="s1">{</span>
        <span class="s1">error(</span><span class="s3">'React instrumentation encountered an error: %s.'</span><span class="s1">, err);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(hook.checkDCE) {</span>
      <span class="s0">// This is the real DevTools.</span>
      <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s0">// This is likely a hook installed by Fast Refresh runtime.</span>
      <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">onScheduleRoot(root, children) {</span>
    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(injectedHook &amp;&amp; </span><span class="s2">typeof </span><span class="s1">injectedHook.onScheduleFiberRoot === </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s2">try </span><span class="s1">{</span>
          <span class="s1">injectedHook.onScheduleFiberRoot(rendererID, root, children);</span>
        <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
          <span class="s2">if </span><span class="s1">( !hasLoggedError) {</span>
            <span class="s1">hasLoggedError = </span><span class="s2">true</span><span class="s1">;</span>

            <span class="s1">error(</span><span class="s3">'React instrumentation encountered an error: %s'</span><span class="s1">, err);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">onCommitRoot(root, eventPriority) {</span>
    <span class="s2">if </span><span class="s1">(injectedHook &amp;&amp; </span><span class="s2">typeof </span><span class="s1">injectedHook.onCommitFiberRoot === </span><span class="s3">'function'</span><span class="s1">) {</span>
      <span class="s2">try </span><span class="s1">{</span>
        <span class="s2">var </span><span class="s1">didError = (root.current.flags &amp; DidCapture) === DidCapture;</span>

        <span class="s2">if </span><span class="s1">(enableProfilerTimer) {</span>
          <span class="s2">var </span><span class="s1">schedulerPriority;</span>

          <span class="s2">switch </span><span class="s1">(eventPriority) {</span>
            <span class="s2">case </span><span class="s1">DiscreteEventPriority:</span>
              <span class="s1">schedulerPriority = ImmediatePriority;</span>
              <span class="s2">break</span><span class="s1">;</span>

            <span class="s2">case </span><span class="s1">ContinuousEventPriority:</span>
              <span class="s1">schedulerPriority = UserBlockingPriority;</span>
              <span class="s2">break</span><span class="s1">;</span>

            <span class="s2">case </span><span class="s1">DefaultEventPriority:</span>
              <span class="s1">schedulerPriority = NormalPriority;</span>
              <span class="s2">break</span><span class="s1">;</span>

            <span class="s2">case </span><span class="s1">IdleEventPriority:</span>
              <span class="s1">schedulerPriority = IdlePriority;</span>
              <span class="s2">break</span><span class="s1">;</span>

            <span class="s2">default</span><span class="s1">:</span>
              <span class="s1">schedulerPriority = NormalPriority;</span>
              <span class="s2">break</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s1">injectedHook.onCommitFiberRoot(rendererID, root, schedulerPriority, didError);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">injectedHook.onCommitFiberRoot(rendererID, root, undefined, didError);</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
        <span class="s1">{</span>
          <span class="s2">if </span><span class="s1">(!hasLoggedError) {</span>
            <span class="s1">hasLoggedError = </span><span class="s2">true</span><span class="s1">;</span>

            <span class="s1">error(</span><span class="s3">'React instrumentation encountered an error: %s'</span><span class="s1">, err);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">onPostCommitRoot(root) {</span>
    <span class="s2">if </span><span class="s1">(injectedHook &amp;&amp; </span><span class="s2">typeof </span><span class="s1">injectedHook.onPostCommitFiberRoot === </span><span class="s3">'function'</span><span class="s1">) {</span>
      <span class="s2">try </span><span class="s1">{</span>
        <span class="s1">injectedHook.onPostCommitFiberRoot(rendererID, root);</span>
      <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
        <span class="s1">{</span>
          <span class="s2">if </span><span class="s1">(!hasLoggedError) {</span>
            <span class="s1">hasLoggedError = </span><span class="s2">true</span><span class="s1">;</span>

            <span class="s1">error(</span><span class="s3">'React instrumentation encountered an error: %s'</span><span class="s1">, err);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">onCommitUnmount(fiber) {</span>
    <span class="s2">if </span><span class="s1">(injectedHook &amp;&amp; </span><span class="s2">typeof </span><span class="s1">injectedHook.onCommitFiberUnmount === </span><span class="s3">'function'</span><span class="s1">) {</span>
      <span class="s2">try </span><span class="s1">{</span>
        <span class="s1">injectedHook.onCommitFiberUnmount(rendererID, fiber);</span>
      <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
        <span class="s1">{</span>
          <span class="s2">if </span><span class="s1">(!hasLoggedError) {</span>
            <span class="s1">hasLoggedError = </span><span class="s2">true</span><span class="s1">;</span>

            <span class="s1">error(</span><span class="s3">'React instrumentation encountered an error: %s'</span><span class="s1">, err);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">injectProfilingHooks(profilingHooks) {</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">getLaneLabelMap() {</span>
    <span class="s1">{</span>
      <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">markComponentRenderStopped() {</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">markComponentErrored(fiber, thrownValue, lanes) {</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">markComponentSuspended(fiber, wakeable, lanes) {</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">NoMode =</span>
  <span class="s0">/*                         */</span>
  <span class="s4">0</span><span class="s1">; </span><span class="s0">// TODO: Remove ConcurrentMode by reading from the root tag instead</span>

  <span class="s2">var </span><span class="s1">ConcurrentMode =</span>
  <span class="s0">/*                 */</span>
  <span class="s4">1</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">ProfileMode =</span>
  <span class="s0">/*                    */</span>
  <span class="s4">2</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">StrictLegacyMode =</span>
  <span class="s0">/*               */</span>
  <span class="s4">8</span><span class="s1">;</span>

  <span class="s0">// TODO: This is pretty well supported by browsers. Maybe we can drop it.</span>
  <span class="s2">var </span><span class="s1">clz32 = Math.clz32 ? Math.clz32 : clz32Fallback; </span><span class="s0">// Count leading zeros.</span>
  <span class="s0">// Based on:</span>
  <span class="s0">// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32</span>

  <span class="s2">var </span><span class="s1">log = Math.log;</span>
  <span class="s2">var </span><span class="s1">LN2 = Math.LN2;</span>

  <span class="s2">function </span><span class="s1">clz32Fallback(x) {</span>
    <span class="s2">var </span><span class="s1">asUint = x &gt;&gt;&gt; </span><span class="s4">0</span><span class="s1">;</span>

    <span class="s2">if </span><span class="s1">(asUint === </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s4">32</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s4">31 </span><span class="s1">- (log(asUint) / LN2 | </span><span class="s4">0</span><span class="s1">) | </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s0">// If those values are changed that package should be rebuilt and redeployed.</span>

  <span class="s2">var </span><span class="s1">TotalLanes = </span><span class="s4">31</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">NoLanes =</span>
  <span class="s0">/*                        */</span>
  <span class="s4">0</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">NoLane =</span>
  <span class="s0">/*                          */</span>
  <span class="s4">0</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">SyncLane =</span>
  <span class="s0">/*                        */</span>
  <span class="s4">1</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">InputContinuousHydrationLane =</span>
  <span class="s0">/*    */</span>
  <span class="s4">2</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">InputContinuousLane =</span>
  <span class="s0">/*             */</span>
  <span class="s4">4</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">DefaultHydrationLane =</span>
  <span class="s0">/*            */</span>
  <span class="s4">8</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">DefaultLane =</span>
  <span class="s0">/*                     */</span>
  <span class="s4">16</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">TransitionHydrationLane =</span>
  <span class="s0">/*                */</span>
  <span class="s4">32</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">TransitionLanes =</span>
  <span class="s0">/*                       */</span>
  <span class="s4">4194240</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">TransitionLane1 =</span>
  <span class="s0">/*                        */</span>
  <span class="s4">64</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">TransitionLane2 =</span>
  <span class="s0">/*                        */</span>
  <span class="s4">128</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">TransitionLane3 =</span>
  <span class="s0">/*                        */</span>
  <span class="s4">256</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">TransitionLane4 =</span>
  <span class="s0">/*                        */</span>
  <span class="s4">512</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">TransitionLane5 =</span>
  <span class="s0">/*                        */</span>
  <span class="s4">1024</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">TransitionLane6 =</span>
  <span class="s0">/*                        */</span>
  <span class="s4">2048</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">TransitionLane7 =</span>
  <span class="s0">/*                        */</span>
  <span class="s4">4096</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">TransitionLane8 =</span>
  <span class="s0">/*                        */</span>
  <span class="s4">8192</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">TransitionLane9 =</span>
  <span class="s0">/*                        */</span>
  <span class="s4">16384</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">TransitionLane10 =</span>
  <span class="s0">/*                       */</span>
  <span class="s4">32768</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">TransitionLane11 =</span>
  <span class="s0">/*                       */</span>
  <span class="s4">65536</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">TransitionLane12 =</span>
  <span class="s0">/*                       */</span>
  <span class="s4">131072</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">TransitionLane13 =</span>
  <span class="s0">/*                       */</span>
  <span class="s4">262144</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">TransitionLane14 =</span>
  <span class="s0">/*                       */</span>
  <span class="s4">524288</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">TransitionLane15 =</span>
  <span class="s0">/*                       */</span>
  <span class="s4">1048576</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">TransitionLane16 =</span>
  <span class="s0">/*                       */</span>
  <span class="s4">2097152</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">RetryLanes =</span>
  <span class="s0">/*                            */</span>
  <span class="s4">130023424</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">RetryLane1 =</span>
  <span class="s0">/*                             */</span>
  <span class="s4">4194304</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">RetryLane2 =</span>
  <span class="s0">/*                             */</span>
  <span class="s4">8388608</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">RetryLane3 =</span>
  <span class="s0">/*                             */</span>
  <span class="s4">16777216</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">RetryLane4 =</span>
  <span class="s0">/*                             */</span>
  <span class="s4">33554432</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">RetryLane5 =</span>
  <span class="s0">/*                             */</span>
  <span class="s4">67108864</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">SomeRetryLane = RetryLane1;</span>
  <span class="s2">var </span><span class="s1">SelectiveHydrationLane =</span>
  <span class="s0">/*          */</span>
  <span class="s4">134217728</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">NonIdleLanes =</span>
  <span class="s0">/*                          */</span>
  <span class="s4">268435455</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">IdleHydrationLane =</span>
  <span class="s0">/*               */</span>
  <span class="s4">268435456</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">IdleLane =</span>
  <span class="s0">/*                        */</span>
  <span class="s4">536870912</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">OffscreenLane =</span>
  <span class="s0">/*                   */</span>
  <span class="s4">1073741824</span><span class="s1">; </span><span class="s0">// This function is used for the experimental timeline (react-devtools-timeline)</span>
  <span class="s2">var </span><span class="s1">NoTimestamp = -</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">nextTransitionLane = TransitionLane1;</span>
  <span class="s2">var </span><span class="s1">nextRetryLane = RetryLane1;</span>

  <span class="s2">function </span><span class="s1">getHighestPriorityLanes(lanes) {</span>
    <span class="s2">switch </span><span class="s1">(getHighestPriorityLane(lanes)) {</span>
      <span class="s2">case </span><span class="s1">SyncLane:</span>
        <span class="s2">return </span><span class="s1">SyncLane;</span>

      <span class="s2">case </span><span class="s1">InputContinuousHydrationLane:</span>
        <span class="s2">return </span><span class="s1">InputContinuousHydrationLane;</span>

      <span class="s2">case </span><span class="s1">InputContinuousLane:</span>
        <span class="s2">return </span><span class="s1">InputContinuousLane;</span>

      <span class="s2">case </span><span class="s1">DefaultHydrationLane:</span>
        <span class="s2">return </span><span class="s1">DefaultHydrationLane;</span>

      <span class="s2">case </span><span class="s1">DefaultLane:</span>
        <span class="s2">return </span><span class="s1">DefaultLane;</span>

      <span class="s2">case </span><span class="s1">TransitionHydrationLane:</span>
        <span class="s2">return </span><span class="s1">TransitionHydrationLane;</span>

      <span class="s2">case </span><span class="s1">TransitionLane1:</span>
      <span class="s2">case </span><span class="s1">TransitionLane2:</span>
      <span class="s2">case </span><span class="s1">TransitionLane3:</span>
      <span class="s2">case </span><span class="s1">TransitionLane4:</span>
      <span class="s2">case </span><span class="s1">TransitionLane5:</span>
      <span class="s2">case </span><span class="s1">TransitionLane6:</span>
      <span class="s2">case </span><span class="s1">TransitionLane7:</span>
      <span class="s2">case </span><span class="s1">TransitionLane8:</span>
      <span class="s2">case </span><span class="s1">TransitionLane9:</span>
      <span class="s2">case </span><span class="s1">TransitionLane10:</span>
      <span class="s2">case </span><span class="s1">TransitionLane11:</span>
      <span class="s2">case </span><span class="s1">TransitionLane12:</span>
      <span class="s2">case </span><span class="s1">TransitionLane13:</span>
      <span class="s2">case </span><span class="s1">TransitionLane14:</span>
      <span class="s2">case </span><span class="s1">TransitionLane15:</span>
      <span class="s2">case </span><span class="s1">TransitionLane16:</span>
        <span class="s2">return </span><span class="s1">lanes &amp; TransitionLanes;</span>

      <span class="s2">case </span><span class="s1">RetryLane1:</span>
      <span class="s2">case </span><span class="s1">RetryLane2:</span>
      <span class="s2">case </span><span class="s1">RetryLane3:</span>
      <span class="s2">case </span><span class="s1">RetryLane4:</span>
      <span class="s2">case </span><span class="s1">RetryLane5:</span>
        <span class="s2">return </span><span class="s1">lanes &amp; RetryLanes;</span>

      <span class="s2">case </span><span class="s1">SelectiveHydrationLane:</span>
        <span class="s2">return </span><span class="s1">SelectiveHydrationLane;</span>

      <span class="s2">case </span><span class="s1">IdleHydrationLane:</span>
        <span class="s2">return </span><span class="s1">IdleHydrationLane;</span>

      <span class="s2">case </span><span class="s1">IdleLane:</span>
        <span class="s2">return </span><span class="s1">IdleLane;</span>

      <span class="s2">case </span><span class="s1">OffscreenLane:</span>
        <span class="s2">return </span><span class="s1">OffscreenLane;</span>

      <span class="s2">default</span><span class="s1">:</span>
        <span class="s1">{</span>
          <span class="s1">error(</span><span class="s3">'Should have found matching lanes. This is a bug in React.'</span><span class="s1">);</span>
        <span class="s1">} </span><span class="s0">// This shouldn't be reachable, but as a fallback, return the entire bitmask.</span>


        <span class="s2">return </span><span class="s1">lanes;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">getNextLanes(root, wipLanes) {</span>
    <span class="s0">// Early bailout if there's no pending work left.</span>
    <span class="s2">var </span><span class="s1">pendingLanes = root.pendingLanes;</span>

    <span class="s2">if </span><span class="s1">(pendingLanes === NoLanes) {</span>
      <span class="s2">return </span><span class="s1">NoLanes;</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">nextLanes = NoLanes;</span>
    <span class="s2">var </span><span class="s1">suspendedLanes = root.suspendedLanes;</span>
    <span class="s2">var </span><span class="s1">pingedLanes = root.pingedLanes; </span><span class="s0">// Do not work on any idle work until all the non-idle work has finished,</span>
    <span class="s0">// even if the work is suspended.</span>

    <span class="s2">var </span><span class="s1">nonIdlePendingLanes = pendingLanes &amp; NonIdleLanes;</span>

    <span class="s2">if </span><span class="s1">(nonIdlePendingLanes !== NoLanes) {</span>
      <span class="s2">var </span><span class="s1">nonIdleUnblockedLanes = nonIdlePendingLanes &amp; ~suspendedLanes;</span>

      <span class="s2">if </span><span class="s1">(nonIdleUnblockedLanes !== NoLanes) {</span>
        <span class="s1">nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">var </span><span class="s1">nonIdlePingedLanes = nonIdlePendingLanes &amp; pingedLanes;</span>

        <span class="s2">if </span><span class="s1">(nonIdlePingedLanes !== NoLanes) {</span>
          <span class="s1">nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s0">// The only remaining work is Idle.</span>
      <span class="s2">var </span><span class="s1">unblockedLanes = pendingLanes &amp; ~suspendedLanes;</span>

      <span class="s2">if </span><span class="s1">(unblockedLanes !== NoLanes) {</span>
        <span class="s1">nextLanes = getHighestPriorityLanes(unblockedLanes);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(pingedLanes !== NoLanes) {</span>
          <span class="s1">nextLanes = getHighestPriorityLanes(pingedLanes);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(nextLanes === NoLanes) {</span>
      <span class="s0">// This should only be reachable if we're suspended</span>
      <span class="s0">// TODO: Consider warning in this path if a fallback timer is not scheduled.</span>
      <span class="s2">return </span><span class="s1">NoLanes;</span>
    <span class="s1">} </span><span class="s0">// If we're already in the middle of a render, switching lanes will interrupt</span>
    <span class="s0">// it and we'll lose our progress. We should only do this if the new lanes are</span>
    <span class="s0">// higher priority.</span>


    <span class="s2">if </span><span class="s1">(wipLanes !== NoLanes &amp;&amp; wipLanes !== nextLanes &amp;&amp; </span><span class="s0">// If we already suspended with a delay, then interrupting is fine. Don't</span>
    <span class="s0">// bother waiting until the root is complete.</span>
    <span class="s1">(wipLanes &amp; suspendedLanes) === NoLanes) {</span>
      <span class="s2">var </span><span class="s1">nextLane = getHighestPriorityLane(nextLanes);</span>
      <span class="s2">var </span><span class="s1">wipLane = getHighestPriorityLane(wipLanes);</span>

      <span class="s2">if </span><span class="s1">( </span><span class="s0">// Tests whether the next lane is equal or lower priority than the wip</span>
      <span class="s0">// one. This works because the bits decrease in priority as you go left.</span>
      <span class="s1">nextLane &gt;= wipLane || </span><span class="s0">// Default priority updates should not interrupt transition updates. The</span>
      <span class="s0">// only difference between default updates and transition updates is that</span>
      <span class="s0">// default updates do not support refresh transitions.</span>
      <span class="s1">nextLane === DefaultLane &amp;&amp; (wipLane &amp; TransitionLanes) !== NoLanes) {</span>
        <span class="s0">// Keep working on the existing in-progress tree. Do not interrupt.</span>
        <span class="s2">return </span><span class="s1">wipLanes;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">((nextLanes &amp; InputContinuousLane) !== NoLanes) {</span>
      <span class="s0">// When updates are sync by default, we entangle continuous priority updates</span>
      <span class="s0">// and default updates, so they render in the same batch. The only reason</span>
      <span class="s0">// they use separate lanes is because continuous updates should interrupt</span>
      <span class="s0">// transitions, but default updates should not.</span>
      <span class="s1">nextLanes |= pendingLanes &amp; DefaultLane;</span>
    <span class="s1">} </span><span class="s0">// Check for entangled lanes and add them to the batch.</span>
    <span class="s0">//</span>
    <span class="s0">// A lane is said to be entangled with another when it's not allowed to render</span>
    <span class="s0">// in a batch that does not also include the other lane. Typically we do this</span>
    <span class="s0">// when multiple updates have the same source, and we only want to respond to</span>
    <span class="s0">// the most recent event from that source.</span>
    <span class="s0">//</span>
    <span class="s0">// Note that we apply entanglements *after* checking for partial work above.</span>
    <span class="s0">// This means that if a lane is entangled during an interleaved event while</span>
    <span class="s0">// it's already rendering, we won't interrupt it. This is intentional, since</span>
    <span class="s0">// entanglement is usually &quot;best effort&quot;: we'll try our best to render the</span>
    <span class="s0">// lanes in the same batch, but it's not worth throwing out partially</span>
    <span class="s0">// completed work in order to do it.</span>
    <span class="s0">// TODO: Reconsider this. The counter-argument is that the partial work</span>
    <span class="s0">// represents an intermediate state, which we don't want to show to the user.</span>
    <span class="s0">// And by spending extra time finishing it, we're increasing the amount of</span>
    <span class="s0">// time it takes to show the final state, which is what they are actually</span>
    <span class="s0">// waiting for.</span>
    <span class="s0">//</span>
    <span class="s0">// For those exceptions where entanglement is semantically important, like</span>
    <span class="s0">// useMutableSource, we should ensure that there is no partial work at the</span>
    <span class="s0">// time we apply the entanglement.</span>


    <span class="s2">var </span><span class="s1">entangledLanes = root.entangledLanes;</span>

    <span class="s2">if </span><span class="s1">(entangledLanes !== NoLanes) {</span>
      <span class="s2">var </span><span class="s1">entanglements = root.entanglements;</span>
      <span class="s2">var </span><span class="s1">lanes = nextLanes &amp; entangledLanes;</span>

      <span class="s2">while </span><span class="s1">(lanes &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s2">var </span><span class="s1">index = pickArbitraryLaneIndex(lanes);</span>
        <span class="s2">var </span><span class="s1">lane = </span><span class="s4">1 </span><span class="s1">&lt;&lt; index;</span>
        <span class="s1">nextLanes |= entanglements[index];</span>
        <span class="s1">lanes &amp;= ~lane;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">nextLanes;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">getMostRecentEventTime(root, lanes) {</span>
    <span class="s2">var </span><span class="s1">eventTimes = root.eventTimes;</span>
    <span class="s2">var </span><span class="s1">mostRecentEventTime = NoTimestamp;</span>

    <span class="s2">while </span><span class="s1">(lanes &gt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">index = pickArbitraryLaneIndex(lanes);</span>
      <span class="s2">var </span><span class="s1">lane = </span><span class="s4">1 </span><span class="s1">&lt;&lt; index;</span>
      <span class="s2">var </span><span class="s1">eventTime = eventTimes[index];</span>

      <span class="s2">if </span><span class="s1">(eventTime &gt; mostRecentEventTime) {</span>
        <span class="s1">mostRecentEventTime = eventTime;</span>
      <span class="s1">}</span>

      <span class="s1">lanes &amp;= ~lane;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">mostRecentEventTime;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">computeExpirationTime(lane, currentTime) {</span>
    <span class="s2">switch </span><span class="s1">(lane) {</span>
      <span class="s2">case </span><span class="s1">SyncLane:</span>
      <span class="s2">case </span><span class="s1">InputContinuousHydrationLane:</span>
      <span class="s2">case </span><span class="s1">InputContinuousLane:</span>
        <span class="s0">// User interactions should expire slightly more quickly.</span>
        <span class="s0">//</span>
        <span class="s0">// NOTE: This is set to the corresponding constant as in Scheduler.js.</span>
        <span class="s0">// When we made it larger, a product metric in www regressed, suggesting</span>
        <span class="s0">// there's a user interaction that's being starved by a series of</span>
        <span class="s0">// synchronous updates. If that theory is correct, the proper solution is</span>
        <span class="s0">// to fix the starvation. However, this scenario supports the idea that</span>
        <span class="s0">// expiration times are an important safeguard when starvation</span>
        <span class="s0">// does happen.</span>
        <span class="s2">return </span><span class="s1">currentTime + </span><span class="s4">250</span><span class="s1">;</span>

      <span class="s2">case </span><span class="s1">DefaultHydrationLane:</span>
      <span class="s2">case </span><span class="s1">DefaultLane:</span>
      <span class="s2">case </span><span class="s1">TransitionHydrationLane:</span>
      <span class="s2">case </span><span class="s1">TransitionLane1:</span>
      <span class="s2">case </span><span class="s1">TransitionLane2:</span>
      <span class="s2">case </span><span class="s1">TransitionLane3:</span>
      <span class="s2">case </span><span class="s1">TransitionLane4:</span>
      <span class="s2">case </span><span class="s1">TransitionLane5:</span>
      <span class="s2">case </span><span class="s1">TransitionLane6:</span>
      <span class="s2">case </span><span class="s1">TransitionLane7:</span>
      <span class="s2">case </span><span class="s1">TransitionLane8:</span>
      <span class="s2">case </span><span class="s1">TransitionLane9:</span>
      <span class="s2">case </span><span class="s1">TransitionLane10:</span>
      <span class="s2">case </span><span class="s1">TransitionLane11:</span>
      <span class="s2">case </span><span class="s1">TransitionLane12:</span>
      <span class="s2">case </span><span class="s1">TransitionLane13:</span>
      <span class="s2">case </span><span class="s1">TransitionLane14:</span>
      <span class="s2">case </span><span class="s1">TransitionLane15:</span>
      <span class="s2">case </span><span class="s1">TransitionLane16:</span>
        <span class="s2">return </span><span class="s1">currentTime + </span><span class="s4">5000</span><span class="s1">;</span>

      <span class="s2">case </span><span class="s1">RetryLane1:</span>
      <span class="s2">case </span><span class="s1">RetryLane2:</span>
      <span class="s2">case </span><span class="s1">RetryLane3:</span>
      <span class="s2">case </span><span class="s1">RetryLane4:</span>
      <span class="s2">case </span><span class="s1">RetryLane5:</span>
        <span class="s0">// TODO: Retries should be allowed to expire if they are CPU bound for</span>
        <span class="s0">// too long, but when I made this change it caused a spike in browser</span>
        <span class="s0">// crashes. There must be some other underlying bug; not super urgent but</span>
        <span class="s0">// ideally should figure out why and fix it. Unfortunately we don't have</span>
        <span class="s0">// a repro for the crashes, only detected via production metrics.</span>
        <span class="s2">return </span><span class="s1">NoTimestamp;</span>

      <span class="s2">case </span><span class="s1">SelectiveHydrationLane:</span>
      <span class="s2">case </span><span class="s1">IdleHydrationLane:</span>
      <span class="s2">case </span><span class="s1">IdleLane:</span>
      <span class="s2">case </span><span class="s1">OffscreenLane:</span>
        <span class="s0">// Anything idle priority or lower should never expire.</span>
        <span class="s2">return </span><span class="s1">NoTimestamp;</span>

      <span class="s2">default</span><span class="s1">:</span>
        <span class="s1">{</span>
          <span class="s1">error(</span><span class="s3">'Should have found matching lanes. This is a bug in React.'</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s2">return </span><span class="s1">NoTimestamp;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">markStarvedLanesAsExpired(root, currentTime) {</span>
    <span class="s0">// TODO: This gets called every time we yield. We can optimize by storing</span>
    <span class="s0">// the earliest expiration time on the root. Then use that to quickly bail out</span>
    <span class="s0">// of this function.</span>
    <span class="s2">var </span><span class="s1">pendingLanes = root.pendingLanes;</span>
    <span class="s2">var </span><span class="s1">suspendedLanes = root.suspendedLanes;</span>
    <span class="s2">var </span><span class="s1">pingedLanes = root.pingedLanes;</span>
    <span class="s2">var </span><span class="s1">expirationTimes = root.expirationTimes; </span><span class="s0">// Iterate through the pending lanes and check if we've reached their</span>
    <span class="s0">// expiration time. If so, we'll assume the update is being starved and mark</span>
    <span class="s0">// it as expired to force it to finish.</span>

    <span class="s2">var </span><span class="s1">lanes = pendingLanes;</span>

    <span class="s2">while </span><span class="s1">(lanes &gt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">index = pickArbitraryLaneIndex(lanes);</span>
      <span class="s2">var </span><span class="s1">lane = </span><span class="s4">1 </span><span class="s1">&lt;&lt; index;</span>
      <span class="s2">var </span><span class="s1">expirationTime = expirationTimes[index];</span>

      <span class="s2">if </span><span class="s1">(expirationTime === NoTimestamp) {</span>
        <span class="s0">// Found a pending lane with no expiration time. If it's not suspended, or</span>
        <span class="s0">// if it's pinged, assume it's CPU-bound. Compute a new expiration time</span>
        <span class="s0">// using the current time.</span>
        <span class="s2">if </span><span class="s1">((lane &amp; suspendedLanes) === NoLanes || (lane &amp; pingedLanes) !== NoLanes) {</span>
          <span class="s0">// Assumes timestamps are monotonically increasing.</span>
          <span class="s1">expirationTimes[index] = computeExpirationTime(lane, currentTime);</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(expirationTime &lt;= currentTime) {</span>
        <span class="s0">// This lane expired</span>
        <span class="s1">root.expiredLanes |= lane;</span>
      <span class="s1">}</span>

      <span class="s1">lanes &amp;= ~lane;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s0">// This returns the highest priority pending lanes regardless of whether they</span>
  <span class="s2">function </span><span class="s1">getLanesToRetrySynchronouslyOnError(root) {</span>
    <span class="s2">var </span><span class="s1">everythingButOffscreen = root.pendingLanes &amp; ~OffscreenLane;</span>

    <span class="s2">if </span><span class="s1">(everythingButOffscreen !== NoLanes) {</span>
      <span class="s2">return </span><span class="s1">everythingButOffscreen;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(everythingButOffscreen &amp; OffscreenLane) {</span>
      <span class="s2">return </span><span class="s1">OffscreenLane;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">NoLanes;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">includesSyncLane(lanes) {</span>
    <span class="s2">return </span><span class="s1">(lanes &amp; SyncLane) !== NoLanes;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">includesNonIdleWork(lanes) {</span>
    <span class="s2">return </span><span class="s1">(lanes &amp; NonIdleLanes) !== NoLanes;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">includesOnlyRetries(lanes) {</span>
    <span class="s2">return </span><span class="s1">(lanes &amp; RetryLanes) === lanes;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">includesOnlyNonUrgentLanes(lanes) {</span>
    <span class="s2">var </span><span class="s1">UrgentLanes = SyncLane | InputContinuousLane | DefaultLane;</span>
    <span class="s2">return </span><span class="s1">(lanes &amp; UrgentLanes) === NoLanes;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">includesOnlyTransitions(lanes) {</span>
    <span class="s2">return </span><span class="s1">(lanes &amp; TransitionLanes) === lanes;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">includesBlockingLane(root, lanes) {</span>

    <span class="s2">var </span><span class="s1">SyncDefaultLanes = InputContinuousHydrationLane | InputContinuousLane | DefaultHydrationLane | DefaultLane;</span>
    <span class="s2">return </span><span class="s1">(lanes &amp; SyncDefaultLanes) !== NoLanes;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">includesExpiredLane(root, lanes) {</span>
    <span class="s0">// This is a separate check from includesBlockingLane because a lane can</span>
    <span class="s0">// expire after a render has already started.</span>
    <span class="s2">return </span><span class="s1">(lanes &amp; root.expiredLanes) !== NoLanes;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">isTransitionLane(lane) {</span>
    <span class="s2">return </span><span class="s1">(lane &amp; TransitionLanes) !== NoLanes;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">claimNextTransitionLane() {</span>
    <span class="s0">// Cycle through the lanes, assigning each new transition to the next lane.</span>
    <span class="s0">// In most cases, this means every transition gets its own lane, until we</span>
    <span class="s0">// run out of lanes and cycle back to the beginning.</span>
    <span class="s2">var </span><span class="s1">lane = nextTransitionLane;</span>
    <span class="s1">nextTransitionLane &lt;&lt;= </span><span class="s4">1</span><span class="s1">;</span>

    <span class="s2">if </span><span class="s1">((nextTransitionLane &amp; TransitionLanes) === NoLanes) {</span>
      <span class="s1">nextTransitionLane = TransitionLane1;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">lane;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">claimNextRetryLane() {</span>
    <span class="s2">var </span><span class="s1">lane = nextRetryLane;</span>
    <span class="s1">nextRetryLane &lt;&lt;= </span><span class="s4">1</span><span class="s1">;</span>

    <span class="s2">if </span><span class="s1">((nextRetryLane &amp; RetryLanes) === NoLanes) {</span>
      <span class="s1">nextRetryLane = RetryLane1;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">lane;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">getHighestPriorityLane(lanes) {</span>
    <span class="s2">return </span><span class="s1">lanes &amp; -lanes;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">pickArbitraryLane(lanes) {</span>
    <span class="s0">// This wrapper function gets inlined. Only exists so to communicate that it</span>
    <span class="s0">// doesn't matter which bit is selected; you can pick any bit without</span>
    <span class="s0">// affecting the algorithms where its used. Here I'm using</span>
    <span class="s0">// getHighestPriorityLane because it requires the fewest operations.</span>
    <span class="s2">return </span><span class="s1">getHighestPriorityLane(lanes);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">pickArbitraryLaneIndex(lanes) {</span>
    <span class="s2">return </span><span class="s4">31 </span><span class="s1">- clz32(lanes);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">laneToIndex(lane) {</span>
    <span class="s2">return </span><span class="s1">pickArbitraryLaneIndex(lane);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">includesSomeLane(a, b) {</span>
    <span class="s2">return </span><span class="s1">(a &amp; b) !== NoLanes;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">isSubsetOfLanes(set, subset) {</span>
    <span class="s2">return </span><span class="s1">(set &amp; subset) === subset;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">mergeLanes(a, b) {</span>
    <span class="s2">return </span><span class="s1">a | b;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">removeLanes(set, subset) {</span>
    <span class="s2">return </span><span class="s1">set &amp; ~subset;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">intersectLanes(a, b) {</span>
    <span class="s2">return </span><span class="s1">a &amp; b;</span>
  <span class="s1">} </span><span class="s0">// Seems redundant, but it changes the type from a single lane (used for</span>
  <span class="s0">// updates) to a group of lanes (used for flushing work).</span>

  <span class="s2">function </span><span class="s1">laneToLanes(lane) {</span>
    <span class="s2">return </span><span class="s1">lane;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">createLaneMap(initial) {</span>
    <span class="s0">// Intentionally pushing one by one.</span>
    <span class="s0">// https://v8.dev/blog/elements-kinds#avoid-creating-holes</span>
    <span class="s2">var </span><span class="s1">laneMap = [];</span>

    <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; TotalLanes; i++) {</span>
      <span class="s1">laneMap.push(initial);</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">laneMap;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">markRootUpdated(root, updateLane, eventTime) {</span>
    <span class="s1">root.pendingLanes |= updateLane; </span><span class="s0">// If there are any suspended transitions, it's possible this new update</span>
    <span class="s0">// could unblock them. Clear the suspended lanes so that we can try rendering</span>
    <span class="s0">// them again.</span>
    <span class="s0">//</span>
    <span class="s0">// TODO: We really only need to unsuspend only lanes that are in the</span>
    <span class="s0">// `subtreeLanes` of the updated fiber, or the update lanes of the return</span>
    <span class="s0">// path. This would exclude suspended updates in an unrelated sibling tree,</span>
    <span class="s0">// since there's no way for this update to unblock it.</span>
    <span class="s0">//</span>
    <span class="s0">// We don't do this if the incoming update is idle, because we never process</span>
    <span class="s0">// idle updates until after all the regular updates have finished; there's no</span>
    <span class="s0">// way it could unblock a transition.</span>

    <span class="s2">if </span><span class="s1">(updateLane !== IdleLane) {</span>
      <span class="s1">root.suspendedLanes = NoLanes;</span>
      <span class="s1">root.pingedLanes = NoLanes;</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">eventTimes = root.eventTimes;</span>
    <span class="s2">var </span><span class="s1">index = laneToIndex(updateLane); </span><span class="s0">// We can always overwrite an existing timestamp because we prefer the most</span>
    <span class="s0">// recent event, and we assume time is monotonically increasing.</span>

    <span class="s1">eventTimes[index] = eventTime;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">markRootSuspended(root, suspendedLanes) {</span>
    <span class="s1">root.suspendedLanes |= suspendedLanes;</span>
    <span class="s1">root.pingedLanes &amp;= ~suspendedLanes; </span><span class="s0">// The suspended lanes are no longer CPU-bound. Clear their expiration times.</span>

    <span class="s2">var </span><span class="s1">expirationTimes = root.expirationTimes;</span>
    <span class="s2">var </span><span class="s1">lanes = suspendedLanes;</span>

    <span class="s2">while </span><span class="s1">(lanes &gt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">index = pickArbitraryLaneIndex(lanes);</span>
      <span class="s2">var </span><span class="s1">lane = </span><span class="s4">1 </span><span class="s1">&lt;&lt; index;</span>
      <span class="s1">expirationTimes[index] = NoTimestamp;</span>
      <span class="s1">lanes &amp;= ~lane;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">markRootPinged(root, pingedLanes, eventTime) {</span>
    <span class="s1">root.pingedLanes |= root.suspendedLanes &amp; pingedLanes;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">markRootFinished(root, remainingLanes) {</span>
    <span class="s2">var </span><span class="s1">noLongerPendingLanes = root.pendingLanes &amp; ~remainingLanes;</span>
    <span class="s1">root.pendingLanes = remainingLanes; </span><span class="s0">// Let's try everything again</span>

    <span class="s1">root.suspendedLanes = NoLanes;</span>
    <span class="s1">root.pingedLanes = NoLanes;</span>
    <span class="s1">root.expiredLanes &amp;= remainingLanes;</span>
    <span class="s1">root.mutableReadLanes &amp;= remainingLanes;</span>
    <span class="s1">root.entangledLanes &amp;= remainingLanes;</span>
    <span class="s2">var </span><span class="s1">entanglements = root.entanglements;</span>
    <span class="s2">var </span><span class="s1">eventTimes = root.eventTimes;</span>
    <span class="s2">var </span><span class="s1">expirationTimes = root.expirationTimes; </span><span class="s0">// Clear the lanes that no longer have pending work</span>

    <span class="s2">var </span><span class="s1">lanes = noLongerPendingLanes;</span>

    <span class="s2">while </span><span class="s1">(lanes &gt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">index = pickArbitraryLaneIndex(lanes);</span>
      <span class="s2">var </span><span class="s1">lane = </span><span class="s4">1 </span><span class="s1">&lt;&lt; index;</span>
      <span class="s1">entanglements[index] = NoLanes;</span>
      <span class="s1">eventTimes[index] = NoTimestamp;</span>
      <span class="s1">expirationTimes[index] = NoTimestamp;</span>
      <span class="s1">lanes &amp;= ~lane;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">markRootEntangled(root, entangledLanes) {</span>
    <span class="s0">// In addition to entangling each of the given lanes with each other, we also</span>
    <span class="s0">// have to consider _transitive_ entanglements. For each lane that is already</span>
    <span class="s0">// entangled with *any* of the given lanes, that lane is now transitively</span>
    <span class="s0">// entangled with *all* the given lanes.</span>
    <span class="s0">//</span>
    <span class="s0">// Translated: If C is entangled with A, then entangling A with B also</span>
    <span class="s0">// entangles C with B.</span>
    <span class="s0">//</span>
    <span class="s0">// If this is hard to grasp, it might help to intentionally break this</span>
    <span class="s0">// function and look at the tests that fail in ReactTransition-test.js. Try</span>
    <span class="s0">// commenting out one of the conditions below.</span>
    <span class="s2">var </span><span class="s1">rootEntangledLanes = root.entangledLanes |= entangledLanes;</span>
    <span class="s2">var </span><span class="s1">entanglements = root.entanglements;</span>
    <span class="s2">var </span><span class="s1">lanes = rootEntangledLanes;</span>

    <span class="s2">while </span><span class="s1">(lanes) {</span>
      <span class="s2">var </span><span class="s1">index = pickArbitraryLaneIndex(lanes);</span>
      <span class="s2">var </span><span class="s1">lane = </span><span class="s4">1 </span><span class="s1">&lt;&lt; index;</span>

      <span class="s2">if </span><span class="s1">( </span><span class="s0">// Is this one of the newly entangled lanes?</span>
      <span class="s1">lane &amp; entangledLanes | </span><span class="s0">// Is this lane transitively entangled with the newly entangled lanes?</span>
      <span class="s1">entanglements[index] &amp; entangledLanes) {</span>
        <span class="s1">entanglements[index] |= entangledLanes;</span>
      <span class="s1">}</span>

      <span class="s1">lanes &amp;= ~lane;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">getBumpedLaneForHydration(root, renderLanes) {</span>
    <span class="s2">var </span><span class="s1">renderLane = getHighestPriorityLane(renderLanes);</span>
    <span class="s2">var </span><span class="s1">lane;</span>

    <span class="s2">switch </span><span class="s1">(renderLane) {</span>
      <span class="s2">case </span><span class="s1">InputContinuousLane:</span>
        <span class="s1">lane = InputContinuousHydrationLane;</span>
        <span class="s2">break</span><span class="s1">;</span>

      <span class="s2">case </span><span class="s1">DefaultLane:</span>
        <span class="s1">lane = DefaultHydrationLane;</span>
        <span class="s2">break</span><span class="s1">;</span>

      <span class="s2">case </span><span class="s1">TransitionLane1:</span>
      <span class="s2">case </span><span class="s1">TransitionLane2:</span>
      <span class="s2">case </span><span class="s1">TransitionLane3:</span>
      <span class="s2">case </span><span class="s1">TransitionLane4:</span>
      <span class="s2">case </span><span class="s1">TransitionLane5:</span>
      <span class="s2">case </span><span class="s1">TransitionLane6:</span>
      <span class="s2">case </span><span class="s1">TransitionLane7:</span>
      <span class="s2">case </span><span class="s1">TransitionLane8:</span>
      <span class="s2">case </span><span class="s1">TransitionLane9:</span>
      <span class="s2">case </span><span class="s1">TransitionLane10:</span>
      <span class="s2">case </span><span class="s1">TransitionLane11:</span>
      <span class="s2">case </span><span class="s1">TransitionLane12:</span>
      <span class="s2">case </span><span class="s1">TransitionLane13:</span>
      <span class="s2">case </span><span class="s1">TransitionLane14:</span>
      <span class="s2">case </span><span class="s1">TransitionLane15:</span>
      <span class="s2">case </span><span class="s1">TransitionLane16:</span>
      <span class="s2">case </span><span class="s1">RetryLane1:</span>
      <span class="s2">case </span><span class="s1">RetryLane2:</span>
      <span class="s2">case </span><span class="s1">RetryLane3:</span>
      <span class="s2">case </span><span class="s1">RetryLane4:</span>
      <span class="s2">case </span><span class="s1">RetryLane5:</span>
        <span class="s1">lane = TransitionHydrationLane;</span>
        <span class="s2">break</span><span class="s1">;</span>

      <span class="s2">case </span><span class="s1">IdleLane:</span>
        <span class="s1">lane = IdleHydrationLane;</span>
        <span class="s2">break</span><span class="s1">;</span>

      <span class="s2">default</span><span class="s1">:</span>
        <span class="s0">// Everything else is already either a hydration lane, or shouldn't</span>
        <span class="s0">// be retried at a hydration lane.</span>
        <span class="s1">lane = NoLane;</span>
        <span class="s2">break</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s0">// Check if the lane we chose is suspended. If so, that indicates that we</span>
    <span class="s0">// already attempted and failed to hydrate at that level. Also check if we're</span>
    <span class="s0">// already rendering that lane, which is rare but could happen.</span>


    <span class="s2">if </span><span class="s1">((lane &amp; (root.suspendedLanes | renderLanes)) !== NoLane) {</span>
      <span class="s0">// Give up trying to hydrate and fall back to client render.</span>
      <span class="s2">return </span><span class="s1">NoLane;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">lane;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">getTransitionsForLanes(root, lanes) {</span>
    <span class="s1">{</span>
      <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">DiscreteEventPriority = SyncLane;</span>
  <span class="s2">var </span><span class="s1">ContinuousEventPriority = InputContinuousLane;</span>
  <span class="s2">var </span><span class="s1">DefaultEventPriority = DefaultLane;</span>
  <span class="s2">var </span><span class="s1">IdleEventPriority = IdleLane;</span>
  <span class="s2">var </span><span class="s1">currentUpdatePriority = NoLane;</span>
  <span class="s2">function </span><span class="s1">getCurrentUpdatePriority() {</span>
    <span class="s2">return </span><span class="s1">currentUpdatePriority;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">setCurrentUpdatePriority(newPriority) {</span>
    <span class="s1">currentUpdatePriority = newPriority;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">higherEventPriority(a, b) {</span>
    <span class="s2">return </span><span class="s1">a !== </span><span class="s4">0 </span><span class="s1">&amp;&amp; a &lt; b ? a : b;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">lowerEventPriority(a, b) {</span>
    <span class="s2">return </span><span class="s1">a === </span><span class="s4">0 </span><span class="s1">|| a &gt; b ? a : b;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">isHigherEventPriority(a, b) {</span>
    <span class="s2">return </span><span class="s1">a !== </span><span class="s4">0 </span><span class="s1">&amp;&amp; a &lt; b;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">lanesToEventPriority(lanes) {</span>
    <span class="s2">var </span><span class="s1">lane = getHighestPriorityLane(lanes);</span>

    <span class="s2">if </span><span class="s1">(!isHigherEventPriority(DiscreteEventPriority, lane)) {</span>
      <span class="s2">return </span><span class="s1">DiscreteEventPriority;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(!isHigherEventPriority(ContinuousEventPriority, lane)) {</span>
      <span class="s2">return </span><span class="s1">ContinuousEventPriority;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(includesNonIdleWork(lane)) {</span>
      <span class="s2">return </span><span class="s1">DefaultEventPriority;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">IdleEventPriority;</span>
  <span class="s1">}</span>

  <span class="s0">// Renderers that don't support hydration</span>
  <span class="s0">// can re-export everything from this module.</span>
  <span class="s2">function </span><span class="s1">shim() {</span>
    <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'The current renderer does not support hydration. ' </span><span class="s1">+ </span><span class="s3">'This error is likely caused by a bug in React. ' </span><span class="s1">+ </span><span class="s3">'Please file an issue.'</span><span class="s1">);</span>
  <span class="s1">} </span><span class="s0">// Hydration (when unsupported)</span>
  <span class="s2">var </span><span class="s1">isSuspenseInstancePending = shim;</span>
  <span class="s2">var </span><span class="s1">isSuspenseInstanceFallback = shim;</span>
  <span class="s2">var </span><span class="s1">getSuspenseInstanceFallbackErrorDetails = shim;</span>
  <span class="s2">var </span><span class="s1">registerSuspenseInstanceRetry = shim;</span>
  <span class="s2">var </span><span class="s1">hydrateTextInstance = shim;</span>
  <span class="s2">var </span><span class="s1">clearSuspenseBoundary = shim;</span>
  <span class="s2">var </span><span class="s1">clearSuspenseBoundaryFromContainer = shim;</span>
  <span class="s2">var </span><span class="s1">errorHydratingContainer = shim;</span>

  <span class="s2">var </span><span class="s1">NO_CONTEXT = {};</span>
  <span class="s2">var </span><span class="s1">UPDATE_SIGNAL = {};</span>
  <span class="s2">var </span><span class="s1">nodeToInstanceMap = </span><span class="s2">new </span><span class="s1">WeakMap();</span>

  <span class="s1">{</span>
    <span class="s1">Object.freeze(NO_CONTEXT);</span>
    <span class="s1">Object.freeze(UPDATE_SIGNAL);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">getPublicInstance(inst) {</span>
    <span class="s2">switch </span><span class="s1">(inst.tag) {</span>
      <span class="s2">case </span><span class="s3">'INSTANCE'</span><span class="s1">:</span>
        <span class="s2">var </span><span class="s1">createNodeMock = inst.rootContainerInstance.createNodeMock;</span>
        <span class="s2">var </span><span class="s1">mockNode = createNodeMock({</span>
          <span class="s1">type: inst.type,</span>
          <span class="s1">props: inst.props</span>
        <span class="s1">});</span>

        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">mockNode === </span><span class="s3">'object' </span><span class="s1">&amp;&amp; mockNode !== </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">nodeToInstanceMap.set(mockNode, inst);</span>
        <span class="s1">}</span>

        <span class="s2">return </span><span class="s1">mockNode;</span>

      <span class="s2">default</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">inst;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">appendChild(parentInstance, child) {</span>
    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(!isArray(parentInstance.children)) {</span>
        <span class="s1">error(</span><span class="s3">'An invalid container has been provided. ' </span><span class="s1">+ </span><span class="s3">'This may indicate that another renderer is being used in addition to the test renderer. ' </span><span class="s1">+ </span><span class="s3">'(For example, ReactDOM.createPortal inside of a ReactTestRenderer tree.) ' </span><span class="s1">+ </span><span class="s3">'This is not supported.'</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">index = parentInstance.children.indexOf(child);</span>

    <span class="s2">if </span><span class="s1">(index !== -</span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s1">parentInstance.children.splice(index, </span><span class="s4">1</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s1">parentInstance.children.push(child);</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">insertBefore(parentInstance, child, beforeChild) {</span>
    <span class="s2">var </span><span class="s1">index = parentInstance.children.indexOf(child);</span>

    <span class="s2">if </span><span class="s1">(index !== -</span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s1">parentInstance.children.splice(index, </span><span class="s4">1</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">beforeIndex = parentInstance.children.indexOf(beforeChild);</span>
    <span class="s1">parentInstance.children.splice(beforeIndex, </span><span class="s4">0</span><span class="s1">, child);</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">removeChild(parentInstance, child) {</span>
    <span class="s2">var </span><span class="s1">index = parentInstance.children.indexOf(child);</span>
    <span class="s1">parentInstance.children.splice(index, </span><span class="s4">1</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">clearContainer(container) {</span>
    <span class="s1">container.children.splice(</span><span class="s4">0</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">getRootHostContext(rootContainerInstance) {</span>
    <span class="s2">return </span><span class="s1">NO_CONTEXT;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">getChildHostContext(parentHostContext, type, rootContainerInstance) {</span>
    <span class="s2">return </span><span class="s1">NO_CONTEXT;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">prepareForCommit(containerInfo) {</span>
    <span class="s0">// noop</span>
    <span class="s2">return null</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">resetAfterCommit(containerInfo) {</span><span class="s0">// noop</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {</span>
    <span class="s2">return </span><span class="s1">{</span>
      <span class="s1">type: type,</span>
      <span class="s1">props: props,</span>
      <span class="s1">isHidden: </span><span class="s2">false</span><span class="s1">,</span>
      <span class="s1">children: [],</span>
      <span class="s1">internalInstanceHandle: internalInstanceHandle,</span>
      <span class="s1">rootContainerInstance: rootContainerInstance,</span>
      <span class="s1">tag: </span><span class="s3">'INSTANCE'</span>
    <span class="s1">};</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">appendInitialChild(parentInstance, child) {</span>
    <span class="s2">var </span><span class="s1">index = parentInstance.children.indexOf(child);</span>

    <span class="s2">if </span><span class="s1">(index !== -</span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s1">parentInstance.children.splice(index, </span><span class="s4">1</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s1">parentInstance.children.push(child);</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">prepareUpdate(testElement, type, oldProps, newProps, rootContainerInstance, hostContext) {</span>
    <span class="s2">return </span><span class="s1">UPDATE_SIGNAL;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">shouldSetTextContent(type, props) {</span>
    <span class="s2">return false</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {</span>
    <span class="s2">return </span><span class="s1">{</span>
      <span class="s1">text: text,</span>
      <span class="s1">isHidden: </span><span class="s2">false</span><span class="s1">,</span>
      <span class="s1">tag: </span><span class="s3">'TEXT'</span>
    <span class="s1">};</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">getCurrentEventPriority() {</span>
    <span class="s2">return </span><span class="s1">DefaultEventPriority;</span>
  <span class="s1">}</span>
  <span class="s2">var </span><span class="s1">scheduleTimeout = setTimeout;</span>
  <span class="s2">var </span><span class="s1">cancelTimeout = clearTimeout;</span>
  <span class="s2">var </span><span class="s1">noTimeout = -</span><span class="s4">1</span><span class="s1">; </span><span class="s0">// -------------------</span>
  <span class="s2">function </span><span class="s1">commitUpdate(instance, updatePayload, type, oldProps, newProps, internalInstanceHandle) {</span>
    <span class="s1">instance.type = type;</span>
    <span class="s1">instance.props = newProps;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">commitTextUpdate(textInstance, oldText, newText) {</span>
    <span class="s1">textInstance.text = newText;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">resetTextContent(testElement) {</span><span class="s0">// noop</span>
  <span class="s1">}</span>
  <span class="s2">var </span><span class="s1">appendChildToContainer = appendChild;</span>
  <span class="s2">var </span><span class="s1">insertInContainerBefore = insertBefore;</span>
  <span class="s2">var </span><span class="s1">removeChildFromContainer = removeChild;</span>
  <span class="s2">function </span><span class="s1">hideInstance(instance) {</span>
    <span class="s1">instance.isHidden = </span><span class="s2">true</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">hideTextInstance(textInstance) {</span>
    <span class="s1">textInstance.isHidden = </span><span class="s2">true</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">unhideInstance(instance, props) {</span>
    <span class="s1">instance.isHidden = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">unhideTextInstance(textInstance, text) {</span>
    <span class="s1">textInstance.isHidden = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">preparePortalMount(portalInstance) {</span><span class="s0">// noop</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;</span>
  <span class="s2">var </span><span class="s1">prefix;</span>
  <span class="s2">function </span><span class="s1">describeBuiltInComponentFrame(name, source, ownerFn) {</span>
    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(prefix === undefined) {</span>
        <span class="s0">// Extract the VM specific prefix used by each line.</span>
        <span class="s2">try </span><span class="s1">{</span>
          <span class="s2">throw </span><span class="s1">Error();</span>
        <span class="s1">} </span><span class="s2">catch </span><span class="s1">(x) {</span>
          <span class="s2">var </span><span class="s1">match = x.stack.trim().match(/\n( *(at )?)/);</span>
          <span class="s1">prefix = match &amp;&amp; match[</span><span class="s4">1</span><span class="s1">] || </span><span class="s3">''</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s0">// We use the prefix to ensure our stacks line up with native stack frames.</span>


      <span class="s2">return </span><span class="s3">'</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">+ prefix + name;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">var </span><span class="s1">reentry = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">componentFrameCache;</span>

  <span class="s1">{</span>
    <span class="s2">var </span><span class="s1">PossiblyWeakMap = </span><span class="s2">typeof </span><span class="s1">WeakMap === </span><span class="s3">'function' </span><span class="s1">? WeakMap : Map;</span>
    <span class="s1">componentFrameCache = </span><span class="s2">new </span><span class="s1">PossiblyWeakMap();</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">describeNativeComponentFrame(fn, construct) {</span>
    <span class="s0">// If something asked for a stack inside a fake render, it should get ignored.</span>
    <span class="s2">if </span><span class="s1">( !fn || reentry) {</span>
      <span class="s2">return </span><span class="s3">''</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s2">var </span><span class="s1">frame = componentFrameCache.get(fn);</span>

      <span class="s2">if </span><span class="s1">(frame !== undefined) {</span>
        <span class="s2">return </span><span class="s1">frame;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">control;</span>
    <span class="s1">reentry = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s2">var </span><span class="s1">previousPrepareStackTrace = Error.prepareStackTrace; </span><span class="s0">// $FlowFixMe It does accept undefined.</span>

    <span class="s1">Error.prepareStackTrace = undefined;</span>
    <span class="s2">var </span><span class="s1">previousDispatcher;</span>

    <span class="s1">{</span>
      <span class="s1">previousDispatcher = ReactCurrentDispatcher.current; </span><span class="s0">// Set the dispatcher in DEV because this might be call in the render function</span>
      <span class="s0">// for warnings.</span>

      <span class="s1">ReactCurrentDispatcher.current = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">disableLogs();</span>
    <span class="s1">}</span>

    <span class="s2">try </span><span class="s1">{</span>
      <span class="s0">// This should throw.</span>
      <span class="s2">if </span><span class="s1">(construct) {</span>
        <span class="s0">// Something should be setting the props in the constructor.</span>
        <span class="s2">var </span><span class="s1">Fake = </span><span class="s2">function </span><span class="s1">() {</span>
          <span class="s2">throw </span><span class="s1">Error();</span>
        <span class="s1">}; </span><span class="s0">// $FlowFixMe</span>


        <span class="s1">Object.defineProperty(Fake.prototype, </span><span class="s3">'props'</span><span class="s1">, {</span>
          <span class="s1">set: </span><span class="s2">function </span><span class="s1">() {</span>
            <span class="s0">// We use a throwing setter instead of frozen or non-writable props</span>
            <span class="s0">// because that won't throw in a non-strict mode function.</span>
            <span class="s2">throw </span><span class="s1">Error();</span>
          <span class="s1">}</span>
        <span class="s1">});</span>

        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">Reflect === </span><span class="s3">'object' </span><span class="s1">&amp;&amp; Reflect.construct) {</span>
          <span class="s0">// We construct a different control for this case to include any extra</span>
          <span class="s0">// frames added by the construct call.</span>
          <span class="s2">try </span><span class="s1">{</span>
            <span class="s1">Reflect.construct(Fake, []);</span>
          <span class="s1">} </span><span class="s2">catch </span><span class="s1">(x) {</span>
            <span class="s1">control = x;</span>
          <span class="s1">}</span>

          <span class="s1">Reflect.construct(fn, [], Fake);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s2">try </span><span class="s1">{</span>
            <span class="s1">Fake.call();</span>
          <span class="s1">} </span><span class="s2">catch </span><span class="s1">(x) {</span>
            <span class="s1">control = x;</span>
          <span class="s1">}</span>

          <span class="s1">fn.call(Fake.prototype);</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">try </span><span class="s1">{</span>
          <span class="s2">throw </span><span class="s1">Error();</span>
        <span class="s1">} </span><span class="s2">catch </span><span class="s1">(x) {</span>
          <span class="s1">control = x;</span>
        <span class="s1">}</span>

        <span class="s1">fn();</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(sample) {</span>
      <span class="s0">// This is inlined manually because closure doesn't do it for us.</span>
      <span class="s2">if </span><span class="s1">(sample &amp;&amp; control &amp;&amp; </span><span class="s2">typeof </span><span class="s1">sample.stack === </span><span class="s3">'string'</span><span class="s1">) {</span>
        <span class="s0">// This extracts the first frame from the sample that isn't also in the control.</span>
        <span class="s0">// Skipping one frame that we assume is the frame that calls the two.</span>
        <span class="s2">var </span><span class="s1">sampleLines = sample.stack.split(</span><span class="s3">'</span><span class="s5">\n</span><span class="s3">'</span><span class="s1">);</span>
        <span class="s2">var </span><span class="s1">controlLines = control.stack.split(</span><span class="s3">'</span><span class="s5">\n</span><span class="s3">'</span><span class="s1">);</span>
        <span class="s2">var </span><span class="s1">s = sampleLines.length - </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s2">var </span><span class="s1">c = controlLines.length - </span><span class="s4">1</span><span class="s1">;</span>

        <span class="s2">while </span><span class="s1">(s &gt;= </span><span class="s4">1 </span><span class="s1">&amp;&amp; c &gt;= </span><span class="s4">0 </span><span class="s1">&amp;&amp; sampleLines[s] !== controlLines[c]) {</span>
          <span class="s0">// We expect at least one stack frame to be shared.</span>
          <span class="s0">// Typically this will be the root most one. However, stack frames may be</span>
          <span class="s0">// cut off due to maximum stack limits. In this case, one maybe cut off</span>
          <span class="s0">// earlier than the other. We assume that the sample is longer or the same</span>
          <span class="s0">// and there for cut off earlier. So we should find the root most frame in</span>
          <span class="s0">// the sample somewhere in the control.</span>
          <span class="s1">c--;</span>
        <span class="s1">}</span>

        <span class="s2">for </span><span class="s1">(; s &gt;= </span><span class="s4">1 </span><span class="s1">&amp;&amp; c &gt;= </span><span class="s4">0</span><span class="s1">; s--, c--) {</span>
          <span class="s0">// Next we find the first one that isn't the same which should be the</span>
          <span class="s0">// frame that called our sample function and the control.</span>
          <span class="s2">if </span><span class="s1">(sampleLines[s] !== controlLines[c]) {</span>
            <span class="s0">// In V8, the first line is describing the message but other VMs don't.</span>
            <span class="s0">// If we're about to return the first line, and the control is also on the same</span>
            <span class="s0">// line, that's a pretty good indicator that our sample threw at same line as</span>
            <span class="s0">// the control. I.e. before we entered the sample frame. So we ignore this result.</span>
            <span class="s0">// This can happen if you passed a class to function component, or non-function.</span>
            <span class="s2">if </span><span class="s1">(s !== </span><span class="s4">1 </span><span class="s1">|| c !== </span><span class="s4">1</span><span class="s1">) {</span>
              <span class="s2">do </span><span class="s1">{</span>
                <span class="s1">s--;</span>
                <span class="s1">c--; </span><span class="s0">// We may still have similar intermediate frames from the construct call.</span>
                <span class="s0">// The next one that isn't the same should be our match though.</span>

                <span class="s2">if </span><span class="s1">(c &lt; </span><span class="s4">0 </span><span class="s1">|| sampleLines[s] !== controlLines[c]) {</span>
                  <span class="s0">// V8 adds a &quot;new&quot; prefix for native classes. Let's remove it to make it prettier.</span>
                  <span class="s2">var </span><span class="s1">_frame = </span><span class="s3">'</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">+ sampleLines[s].replace(</span><span class="s3">' at new '</span><span class="s1">, </span><span class="s3">' at '</span><span class="s1">); </span><span class="s0">// If our component frame is labeled &quot;&lt;anonymous&gt;&quot;</span>
                  <span class="s0">// but we have a user-provided &quot;displayName&quot;</span>
                  <span class="s0">// splice it in to make the stack more readable.</span>


                  <span class="s2">if </span><span class="s1">(fn.displayName &amp;&amp; _frame.includes(</span><span class="s3">'&lt;anonymous&gt;'</span><span class="s1">)) {</span>
                    <span class="s1">_frame = _frame.replace(</span><span class="s3">'&lt;anonymous&gt;'</span><span class="s1">, fn.displayName);</span>
                  <span class="s1">}</span>

                  <span class="s1">{</span>
                    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">fn === </span><span class="s3">'function'</span><span class="s1">) {</span>
                      <span class="s1">componentFrameCache.set(fn, _frame);</span>
                    <span class="s1">}</span>
                  <span class="s1">} </span><span class="s0">// Return the line we found.</span>


                  <span class="s2">return </span><span class="s1">_frame;</span>
                <span class="s1">}</span>
              <span class="s1">} </span><span class="s2">while </span><span class="s1">(s &gt;= </span><span class="s4">1 </span><span class="s1">&amp;&amp; c &gt;= </span><span class="s4">0</span><span class="s1">);</span>
            <span class="s1">}</span>

            <span class="s2">break</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
      <span class="s1">reentry = </span><span class="s2">false</span><span class="s1">;</span>

      <span class="s1">{</span>
        <span class="s1">ReactCurrentDispatcher.current = previousDispatcher;</span>
        <span class="s1">reenableLogs();</span>
      <span class="s1">}</span>

      <span class="s1">Error.prepareStackTrace = previousPrepareStackTrace;</span>
    <span class="s1">} </span><span class="s0">// Fallback to just using the name if we couldn't make it throw.</span>


    <span class="s2">var </span><span class="s1">name = fn ? fn.displayName || fn.name : </span><span class="s3">''</span><span class="s1">;</span>
    <span class="s2">var </span><span class="s1">syntheticFrame = name ? describeBuiltInComponentFrame(name) : </span><span class="s3">''</span><span class="s1">;</span>

    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">fn === </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s1">componentFrameCache.set(fn, syntheticFrame);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">syntheticFrame;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">describeClassComponentFrame(ctor, source, ownerFn) {</span>
    <span class="s1">{</span>
      <span class="s2">return </span><span class="s1">describeNativeComponentFrame(ctor, </span><span class="s2">true</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">describeFunctionComponentFrame(fn, source, ownerFn) {</span>
    <span class="s1">{</span>
      <span class="s2">return </span><span class="s1">describeNativeComponentFrame(fn, </span><span class="s2">false</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">shouldConstruct(Component) {</span>
    <span class="s2">var </span><span class="s1">prototype = Component.prototype;</span>
    <span class="s2">return </span><span class="s1">!!(prototype &amp;&amp; prototype.isReactComponent);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {</span>

    <span class="s2">if </span><span class="s1">(type == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s3">''</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">type === </span><span class="s3">'function'</span><span class="s1">) {</span>
      <span class="s1">{</span>
        <span class="s2">return </span><span class="s1">describeNativeComponentFrame(type, shouldConstruct(type));</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">type === </span><span class="s3">'string'</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">describeBuiltInComponentFrame(type);</span>
    <span class="s1">}</span>

    <span class="s2">switch </span><span class="s1">(type) {</span>
      <span class="s2">case </span><span class="s1">REACT_SUSPENSE_TYPE:</span>
        <span class="s2">return </span><span class="s1">describeBuiltInComponentFrame(</span><span class="s3">'Suspense'</span><span class="s1">);</span>

      <span class="s2">case </span><span class="s1">REACT_SUSPENSE_LIST_TYPE:</span>
        <span class="s2">return </span><span class="s1">describeBuiltInComponentFrame(</span><span class="s3">'SuspenseList'</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">type === </span><span class="s3">'object'</span><span class="s1">) {</span>
      <span class="s2">switch </span><span class="s1">(type.$$typeof) {</span>
        <span class="s2">case </span><span class="s1">REACT_FORWARD_REF_TYPE:</span>
          <span class="s2">return </span><span class="s1">describeFunctionComponentFrame(type.render);</span>

        <span class="s2">case </span><span class="s1">REACT_MEMO_TYPE:</span>
          <span class="s0">// Memo may contain any component type so we recursively resolve it.</span>
          <span class="s2">return </span><span class="s1">describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);</span>

        <span class="s2">case </span><span class="s1">REACT_LAZY_TYPE:</span>
          <span class="s1">{</span>
            <span class="s2">var </span><span class="s1">lazyComponent = type;</span>
            <span class="s2">var </span><span class="s1">payload = lazyComponent._payload;</span>
            <span class="s2">var </span><span class="s1">init = lazyComponent._init;</span>

            <span class="s2">try </span><span class="s1">{</span>
              <span class="s0">// Lazy may contain any component type so we recursively resolve it.</span>
              <span class="s2">return </span><span class="s1">describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);</span>
            <span class="s1">} </span><span class="s2">catch </span><span class="s1">(x) {}</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s3">''</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">hasOwnProperty = Object.prototype.hasOwnProperty;</span>

  <span class="s2">var </span><span class="s1">loggedTypeFailures = {};</span>
  <span class="s2">var </span><span class="s1">ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;</span>

  <span class="s2">function </span><span class="s1">setCurrentlyValidatingElement(element) {</span>
    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(element) {</span>
        <span class="s2">var </span><span class="s1">owner = element._owner;</span>
        <span class="s2">var </span><span class="s1">stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : </span><span class="s2">null</span><span class="s1">);</span>
        <span class="s1">ReactDebugCurrentFrame.setExtraStackFrame(stack);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">ReactDebugCurrentFrame.setExtraStackFrame(</span><span class="s2">null</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">checkPropTypes(typeSpecs, values, location, componentName, element) {</span>
    <span class="s1">{</span>
      <span class="s0">// $FlowFixMe This is okay but Flow doesn't know it.</span>
      <span class="s2">var </span><span class="s1">has = Function.call.bind(hasOwnProperty);</span>

      <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">typeSpecName </span><span class="s2">in </span><span class="s1">typeSpecs) {</span>
        <span class="s2">if </span><span class="s1">(has(typeSpecs, typeSpecName)) {</span>
          <span class="s2">var </span><span class="s1">error$1 = </span><span class="s2">void </span><span class="s4">0</span><span class="s1">; </span><span class="s0">// Prop type validation may throw. In case they do, we don't want to</span>
          <span class="s0">// fail the render phase where it didn't fail before. So we log it.</span>
          <span class="s0">// After these have been cleaned up, we'll let them throw.</span>

          <span class="s2">try </span><span class="s1">{</span>
            <span class="s0">// This is intentionally an invariant that gets caught. It's the same</span>
            <span class="s0">// behavior as without this statement except with a better message.</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">typeSpecs[typeSpecName] !== </span><span class="s3">'function'</span><span class="s1">) {</span>
              <span class="s0">// eslint-disable-next-line react-internal/prod-error-codes</span>
              <span class="s2">var </span><span class="s1">err = Error((componentName || </span><span class="s3">'React class'</span><span class="s1">) + </span><span class="s3">': ' </span><span class="s1">+ location + </span><span class="s3">' type `' </span><span class="s1">+ typeSpecName + </span><span class="s3">'` is invalid; ' </span><span class="s1">+ </span><span class="s3">'it must be a function, usually from the `prop-types` package, but received `' </span><span class="s1">+ </span><span class="s2">typeof </span><span class="s1">typeSpecs[typeSpecName] + </span><span class="s3">'`.' </span><span class="s1">+ </span><span class="s3">'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.'</span><span class="s1">);</span>
              <span class="s1">err.name = </span><span class="s3">'Invariant Violation'</span><span class="s1">;</span>
              <span class="s2">throw </span><span class="s1">err;</span>
            <span class="s1">}</span>

            <span class="s1">error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, </span><span class="s2">null</span><span class="s1">, </span><span class="s3">'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED'</span><span class="s1">);</span>
          <span class="s1">} </span><span class="s2">catch </span><span class="s1">(ex) {</span>
            <span class="s1">error$1 = ex;</span>
          <span class="s1">}</span>

          <span class="s2">if </span><span class="s1">(error$1 &amp;&amp; !(error$1 </span><span class="s2">instanceof </span><span class="s1">Error)) {</span>
            <span class="s1">setCurrentlyValidatingElement(element);</span>

            <span class="s1">error(</span><span class="s3">'%s: type specification of %s' </span><span class="s1">+ </span><span class="s3">' `%s` is invalid; the type checker ' </span><span class="s1">+ </span><span class="s3">'function must return `null` or an `Error` but returned a %s. ' </span><span class="s1">+ </span><span class="s3">'You may have forgotten to pass an argument to the type checker ' </span><span class="s1">+ </span><span class="s3">'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' </span><span class="s1">+ </span><span class="s3">'shape all require an argument).'</span><span class="s1">, componentName || </span><span class="s3">'React class'</span><span class="s1">, location, typeSpecName, </span><span class="s2">typeof </span><span class="s1">error$1);</span>

            <span class="s1">setCurrentlyValidatingElement(</span><span class="s2">null</span><span class="s1">);</span>
          <span class="s1">}</span>

          <span class="s2">if </span><span class="s1">(error$1 </span><span class="s2">instanceof </span><span class="s1">Error &amp;&amp; !(error$1.message </span><span class="s2">in </span><span class="s1">loggedTypeFailures)) {</span>
            <span class="s0">// Only monitor this failure once because there tends to be a lot of the</span>
            <span class="s0">// same error.</span>
            <span class="s1">loggedTypeFailures[error$1.message] = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">setCurrentlyValidatingElement(element);</span>

            <span class="s1">error(</span><span class="s3">'Failed %s type: %s'</span><span class="s1">, location, error$1.message);</span>

            <span class="s1">setCurrentlyValidatingElement(</span><span class="s2">null</span><span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">valueStack = [];</span>
  <span class="s2">var </span><span class="s1">fiberStack;</span>

  <span class="s1">{</span>
    <span class="s1">fiberStack = [];</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">index = -</span><span class="s4">1</span><span class="s1">;</span>

  <span class="s2">function </span><span class="s1">createCursor(defaultValue) {</span>
    <span class="s2">return </span><span class="s1">{</span>
      <span class="s1">current: defaultValue</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">pop(cursor, fiber) {</span>
    <span class="s2">if </span><span class="s1">(index &lt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s1">{</span>
        <span class="s1">error(</span><span class="s3">'Unexpected pop.'</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(fiber !== fiberStack[index]) {</span>
        <span class="s1">error(</span><span class="s3">'Unexpected Fiber popped.'</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">cursor.current = valueStack[index];</span>
    <span class="s1">valueStack[index] = </span><span class="s2">null</span><span class="s1">;</span>

    <span class="s1">{</span>
      <span class="s1">fiberStack[index] = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">index--;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">push(cursor, value, fiber) {</span>
    <span class="s1">index++;</span>
    <span class="s1">valueStack[index] = cursor.current;</span>

    <span class="s1">{</span>
      <span class="s1">fiberStack[index] = fiber;</span>
    <span class="s1">}</span>

    <span class="s1">cursor.current = value;</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">warnedAboutMissingGetChildContext;</span>

  <span class="s1">{</span>
    <span class="s1">warnedAboutMissingGetChildContext = {};</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">emptyContextObject = {};</span>

  <span class="s1">{</span>
    <span class="s1">Object.freeze(emptyContextObject);</span>
  <span class="s1">} </span><span class="s0">// A cursor to the current merged context object on the stack.</span>


  <span class="s2">var </span><span class="s1">contextStackCursor = createCursor(emptyContextObject); </span><span class="s0">// A cursor to a boolean indicating whether the context has changed.</span>

  <span class="s2">var </span><span class="s1">didPerformWorkStackCursor = createCursor(</span><span class="s2">false</span><span class="s1">); </span><span class="s0">// Keep track of the previous context object that was on the stack.</span>
  <span class="s0">// We use this to get access to the parent context after we have already</span>
  <span class="s0">// pushed the next context provider, and now need to merge their contexts.</span>

  <span class="s2">var </span><span class="s1">previousContext = emptyContextObject;</span>

  <span class="s2">function </span><span class="s1">getUnmaskedContext(workInProgress, Component, didPushOwnContextIfProvider) {</span>
    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(didPushOwnContextIfProvider &amp;&amp; isContextProvider(Component)) {</span>
        <span class="s0">// If the fiber is a context provider itself, when we read its context</span>
        <span class="s0">// we may have already pushed its own child context on the stack. A context</span>
        <span class="s0">// provider should not &quot;see&quot; its own child context. Therefore we read the</span>
        <span class="s0">// previous (parent) context instead for a context provider.</span>
        <span class="s2">return </span><span class="s1">previousContext;</span>
      <span class="s1">}</span>

      <span class="s2">return </span><span class="s1">contextStackCursor.current;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">cacheContext(workInProgress, unmaskedContext, maskedContext) {</span>
    <span class="s1">{</span>
      <span class="s2">var </span><span class="s1">instance = workInProgress.stateNode;</span>
      <span class="s1">instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;</span>
      <span class="s1">instance.__reactInternalMemoizedMaskedChildContext = maskedContext;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">getMaskedContext(workInProgress, unmaskedContext) {</span>
    <span class="s1">{</span>
      <span class="s2">var </span><span class="s1">type = workInProgress.type;</span>
      <span class="s2">var </span><span class="s1">contextTypes = type.contextTypes;</span>

      <span class="s2">if </span><span class="s1">(!contextTypes) {</span>
        <span class="s2">return </span><span class="s1">emptyContextObject;</span>
      <span class="s1">} </span><span class="s0">// Avoid recreating masked context unless unmasked context has changed.</span>
      <span class="s0">// Failing to do this will result in unnecessary calls to componentWillReceiveProps.</span>
      <span class="s0">// This may trigger infinite loops if componentWillReceiveProps calls setState.</span>


      <span class="s2">var </span><span class="s1">instance = workInProgress.stateNode;</span>

      <span class="s2">if </span><span class="s1">(instance &amp;&amp; instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {</span>
        <span class="s2">return </span><span class="s1">instance.__reactInternalMemoizedMaskedChildContext;</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">context = {};</span>

      <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">key </span><span class="s2">in </span><span class="s1">contextTypes) {</span>
        <span class="s1">context[key] = unmaskedContext[key];</span>
      <span class="s1">}</span>

      <span class="s1">{</span>
        <span class="s2">var </span><span class="s1">name = getComponentNameFromFiber(workInProgress) || </span><span class="s3">'Unknown'</span><span class="s1">;</span>
        <span class="s1">checkPropTypes(contextTypes, context, </span><span class="s3">'context'</span><span class="s1">, name);</span>
      <span class="s1">} </span><span class="s0">// Cache unmasked context so we can avoid recreating masked context unless necessary.</span>
      <span class="s0">// Context is created before the class component is instantiated so check for instance.</span>


      <span class="s2">if </span><span class="s1">(instance) {</span>
        <span class="s1">cacheContext(workInProgress, unmaskedContext, context);</span>
      <span class="s1">}</span>

      <span class="s2">return </span><span class="s1">context;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">hasContextChanged() {</span>
    <span class="s1">{</span>
      <span class="s2">return </span><span class="s1">didPerformWorkStackCursor.current;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">isContextProvider(type) {</span>
    <span class="s1">{</span>
      <span class="s2">var </span><span class="s1">childContextTypes = type.childContextTypes;</span>
      <span class="s2">return </span><span class="s1">childContextTypes !== </span><span class="s2">null </span><span class="s1">&amp;&amp; childContextTypes !== undefined;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">popContext(fiber) {</span>
    <span class="s1">{</span>
      <span class="s1">pop(didPerformWorkStackCursor, fiber);</span>
      <span class="s1">pop(contextStackCursor, fiber);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">popTopLevelContextObject(fiber) {</span>
    <span class="s1">{</span>
      <span class="s1">pop(didPerformWorkStackCursor, fiber);</span>
      <span class="s1">pop(contextStackCursor, fiber);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">pushTopLevelContextObject(fiber, context, didChange) {</span>
    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(contextStackCursor.current !== emptyContextObject) {</span>
        <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Unexpected context found on stack. ' </span><span class="s1">+ </span><span class="s3">'This error is likely caused by a bug in React. Please file an issue.'</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s1">push(contextStackCursor, context, fiber);</span>
      <span class="s1">push(didPerformWorkStackCursor, didChange, fiber);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">processChildContext(fiber, type, parentContext) {</span>
    <span class="s1">{</span>
      <span class="s2">var </span><span class="s1">instance = fiber.stateNode;</span>
      <span class="s2">var </span><span class="s1">childContextTypes = type.childContextTypes; </span><span class="s0">// TODO (bvaughn) Replace this behavior with an invariant() in the future.</span>
      <span class="s0">// It has only been added in Fiber to match the (unintentional) behavior in Stack.</span>

      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">instance.getChildContext !== </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s1">{</span>
          <span class="s2">var </span><span class="s1">componentName = getComponentNameFromFiber(fiber) || </span><span class="s3">'Unknown'</span><span class="s1">;</span>

          <span class="s2">if </span><span class="s1">(!warnedAboutMissingGetChildContext[componentName]) {</span>
            <span class="s1">warnedAboutMissingGetChildContext[componentName] = </span><span class="s2">true</span><span class="s1">;</span>

            <span class="s1">error(</span><span class="s3">'%s.childContextTypes is specified but there is no getChildContext() method ' </span><span class="s1">+ </span><span class="s3">'on the instance. You can either define getChildContext() on %s or remove ' </span><span class="s1">+ </span><span class="s3">'childContextTypes from it.'</span><span class="s1">, componentName, componentName);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s2">return </span><span class="s1">parentContext;</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">childContext = instance.getChildContext();</span>

      <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">contextKey </span><span class="s2">in </span><span class="s1">childContext) {</span>
        <span class="s2">if </span><span class="s1">(!(contextKey </span><span class="s2">in </span><span class="s1">childContextTypes)) {</span>
          <span class="s2">throw new </span><span class="s1">Error((getComponentNameFromFiber(fiber) || </span><span class="s3">'Unknown'</span><span class="s1">) + </span><span class="s3">&quot;.getChildContext(): key </span><span class="s5">\&quot;</span><span class="s3">&quot; </span><span class="s1">+ contextKey + </span><span class="s3">&quot;</span><span class="s5">\&quot; </span><span class="s3">is not defined in childContextTypes.&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">{</span>
        <span class="s2">var </span><span class="s1">name = getComponentNameFromFiber(fiber) || </span><span class="s3">'Unknown'</span><span class="s1">;</span>
        <span class="s1">checkPropTypes(childContextTypes, childContext, </span><span class="s3">'child context'</span><span class="s1">, name);</span>
      <span class="s1">}</span>

      <span class="s2">return </span><span class="s1">assign({}, parentContext, childContext);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">pushContextProvider(workInProgress) {</span>
    <span class="s1">{</span>
      <span class="s2">var </span><span class="s1">instance = workInProgress.stateNode; </span><span class="s0">// We push the context as early as possible to ensure stack integrity.</span>
      <span class="s0">// If the instance does not exist yet, we will push null at first,</span>
      <span class="s0">// and replace it on the stack later when invalidating the context.</span>

      <span class="s2">var </span><span class="s1">memoizedMergedChildContext = instance &amp;&amp; instance.__reactInternalMemoizedMergedChildContext || emptyContextObject; </span><span class="s0">// Remember the parent context so we can merge with it later.</span>
      <span class="s0">// Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.</span>

      <span class="s1">previousContext = contextStackCursor.current;</span>
      <span class="s1">push(contextStackCursor, memoizedMergedChildContext, workInProgress);</span>
      <span class="s1">push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);</span>
      <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">invalidateContextProvider(workInProgress, type, didChange) {</span>
    <span class="s1">{</span>
      <span class="s2">var </span><span class="s1">instance = workInProgress.stateNode;</span>

      <span class="s2">if </span><span class="s1">(!instance) {</span>
        <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Expected to have an instance by this point. ' </span><span class="s1">+ </span><span class="s3">'This error is likely caused by a bug in React. Please file an issue.'</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(didChange) {</span>
        <span class="s0">// Merge parent and own context.</span>
        <span class="s0">// Skip this if we're not updating due to sCU.</span>
        <span class="s0">// This avoids unnecessarily recomputing memoized values.</span>
        <span class="s2">var </span><span class="s1">mergedContext = processChildContext(workInProgress, type, previousContext);</span>
        <span class="s1">instance.__reactInternalMemoizedMergedChildContext = mergedContext; </span><span class="s0">// Replace the old (or empty) context with the new one.</span>
        <span class="s0">// It is important to unwind the context in the reverse order.</span>

        <span class="s1">pop(didPerformWorkStackCursor, workInProgress);</span>
        <span class="s1">pop(contextStackCursor, workInProgress); </span><span class="s0">// Now push the new context and mark that it has changed.</span>

        <span class="s1">push(contextStackCursor, mergedContext, workInProgress);</span>
        <span class="s1">push(didPerformWorkStackCursor, didChange, workInProgress);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">pop(didPerformWorkStackCursor, workInProgress);</span>
        <span class="s1">push(didPerformWorkStackCursor, didChange, workInProgress);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">findCurrentUnmaskedContext(fiber) {</span>
    <span class="s1">{</span>
      <span class="s0">// Currently this is only used with renderSubtreeIntoContainer; not sure if it</span>
      <span class="s0">// makes sense elsewhere</span>
      <span class="s2">if </span><span class="s1">(!isFiberMounted(fiber) || fiber.tag !== ClassComponent) {</span>
        <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Expected subtree parent to be a mounted class component. ' </span><span class="s1">+ </span><span class="s3">'This error is likely caused by a bug in React. Please file an issue.'</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">node = fiber;</span>

      <span class="s2">do </span><span class="s1">{</span>
        <span class="s2">switch </span><span class="s1">(node.tag) {</span>
          <span class="s2">case </span><span class="s1">HostRoot:</span>
            <span class="s2">return </span><span class="s1">node.stateNode.context;</span>

          <span class="s2">case </span><span class="s1">ClassComponent:</span>
            <span class="s1">{</span>
              <span class="s2">var </span><span class="s1">Component = node.type;</span>

              <span class="s2">if </span><span class="s1">(isContextProvider(Component)) {</span>
                <span class="s2">return </span><span class="s1">node.stateNode.__reactInternalMemoizedMergedChildContext;</span>
              <span class="s1">}</span>

              <span class="s2">break</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s1">node = node.</span><span class="s2">return</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s2">while </span><span class="s1">(node !== </span><span class="s2">null</span><span class="s1">);</span>

      <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Found unexpected detached subtree parent. ' </span><span class="s1">+ </span><span class="s3">'This error is likely caused by a bug in React. Please file an issue.'</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">LegacyRoot = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">ConcurrentRoot = </span><span class="s4">1</span><span class="s1">;</span>

  <span class="s0">/** 
   * inlined Object.is polyfill to avoid requiring consumers ship their own 
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is 
   */</span>
  <span class="s2">function </span><span class="s1">is(x, y) {</span>
    <span class="s2">return </span><span class="s1">x === y &amp;&amp; (x !== </span><span class="s4">0 </span><span class="s1">|| </span><span class="s4">1 </span><span class="s1">/ x === </span><span class="s4">1 </span><span class="s1">/ y) || x !== x &amp;&amp; y !== y </span><span class="s0">// eslint-disable-line no-self-compare</span>
    <span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">objectIs = </span><span class="s2">typeof </span><span class="s1">Object.is === </span><span class="s3">'function' </span><span class="s1">? Object.is : is;</span>

  <span class="s2">var </span><span class="s1">syncQueue = </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">includesLegacySyncCallbacks = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">isFlushingSyncQueue = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s2">function </span><span class="s1">scheduleSyncCallback(callback) {</span>
    <span class="s0">// Push this callback into an internal queue. We'll flush these either in</span>
    <span class="s0">// the next tick, or earlier if something calls `flushSyncCallbackQueue`.</span>
    <span class="s2">if </span><span class="s1">(syncQueue === </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">syncQueue = [callback];</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s0">// Push onto existing queue. Don't need to schedule a callback because</span>
      <span class="s0">// we already scheduled one when we created the queue.</span>
      <span class="s1">syncQueue.push(callback);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">scheduleLegacySyncCallback(callback) {</span>
    <span class="s1">includesLegacySyncCallbacks = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">scheduleSyncCallback(callback);</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">flushSyncCallbacksOnlyInLegacyMode() {</span>
    <span class="s0">// Only flushes the queue if there's a legacy sync callback scheduled.</span>
    <span class="s0">// TODO: There's only a single type of callback: performSyncOnWorkOnRoot. So</span>
    <span class="s0">// it might make more sense for the queue to be a list of roots instead of a</span>
    <span class="s0">// list of generic callbacks. Then we can have two: one for legacy roots, one</span>
    <span class="s0">// for concurrent roots. And this method would only flush the legacy ones.</span>
    <span class="s2">if </span><span class="s1">(includesLegacySyncCallbacks) {</span>
      <span class="s1">flushSyncCallbacks();</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">flushSyncCallbacks() {</span>
    <span class="s2">if </span><span class="s1">(!isFlushingSyncQueue &amp;&amp; syncQueue !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s0">// Prevent re-entrance.</span>
      <span class="s1">isFlushingSyncQueue = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s2">var </span><span class="s1">previousUpdatePriority = getCurrentUpdatePriority();</span>

      <span class="s2">try </span><span class="s1">{</span>
        <span class="s2">var </span><span class="s1">isSync = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s2">var </span><span class="s1">queue = syncQueue; </span><span class="s0">// TODO: Is this necessary anymore? The only user code that runs in this</span>
        <span class="s0">// queue is in the render or commit phases.</span>

        <span class="s1">setCurrentUpdatePriority(DiscreteEventPriority);</span>

        <span class="s2">for </span><span class="s1">(; i &lt; queue.length; i++) {</span>
          <span class="s2">var </span><span class="s1">callback = queue[i];</span>

          <span class="s2">do </span><span class="s1">{</span>
            <span class="s1">callback = callback(isSync);</span>
          <span class="s1">} </span><span class="s2">while </span><span class="s1">(callback !== </span><span class="s2">null</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s1">syncQueue = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s1">includesLegacySyncCallbacks = </span><span class="s2">false</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s2">catch </span><span class="s1">(error) {</span>
        <span class="s0">// If something throws, leave the remaining callbacks on the queue.</span>
        <span class="s2">if </span><span class="s1">(syncQueue !== </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">syncQueue = syncQueue.slice(i + </span><span class="s4">1</span><span class="s1">);</span>
        <span class="s1">} </span><span class="s0">// Resume flushing in the next tick</span>


        <span class="s1">scheduleCallback(ImmediatePriority, flushSyncCallbacks);</span>
        <span class="s2">throw </span><span class="s1">error;</span>
      <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
        <span class="s1">setCurrentUpdatePriority(previousUpdatePriority);</span>
        <span class="s1">isFlushingSyncQueue = </span><span class="s2">false</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s0">// This is imported by the event replaying implementation in React DOM. It's</span>
  <span class="s0">// in a separate file to break a circular dependency between the renderer and</span>
  <span class="s0">// the reconciler.</span>
  <span class="s2">function </span><span class="s1">isRootDehydrated(root) {</span>
    <span class="s2">var </span><span class="s1">currentState = root.current.memoizedState;</span>
    <span class="s2">return </span><span class="s1">currentState.isDehydrated;</span>
  <span class="s1">}</span>

  <span class="s0">// TODO: Use the unified fiber stack module instead of this local one?</span>
  <span class="s0">// Intentionally not using it yet to derisk the initial implementation, because</span>
  <span class="s0">// the way we push/pop these values is a bit unusual. If there's a mistake, I'd</span>
  <span class="s0">// rather the ids be wrong than crash the whole reconciler.</span>
  <span class="s2">var </span><span class="s1">forkStack = [];</span>
  <span class="s2">var </span><span class="s1">forkStackIndex = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">treeForkProvider = </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">treeForkCount = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">idStack = [];</span>
  <span class="s2">var </span><span class="s1">idStackIndex = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">treeContextProvider = </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">treeContextId = </span><span class="s4">1</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">treeContextOverflow = </span><span class="s3">''</span><span class="s1">;</span>

  <span class="s2">function </span><span class="s1">popTreeContext(workInProgress) {</span>
    <span class="s0">// Restore the previous values.</span>
    <span class="s0">// This is a bit more complicated than other context-like modules in Fiber</span>
    <span class="s0">// because the same Fiber may appear on the stack multiple times and for</span>
    <span class="s0">// different reasons. We have to keep popping until the work-in-progress is</span>
    <span class="s0">// no longer at the top of the stack.</span>
    <span class="s2">while </span><span class="s1">(workInProgress === treeForkProvider) {</span>
      <span class="s1">treeForkProvider = forkStack[--forkStackIndex];</span>
      <span class="s1">forkStack[forkStackIndex] = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">treeForkCount = forkStack[--forkStackIndex];</span>
      <span class="s1">forkStack[forkStackIndex] = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">while </span><span class="s1">(workInProgress === treeContextProvider) {</span>
      <span class="s1">treeContextProvider = idStack[--idStackIndex];</span>
      <span class="s1">idStack[idStackIndex] = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">treeContextOverflow = idStack[--idStackIndex];</span>
      <span class="s1">idStack[idStackIndex] = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">treeContextId = idStack[--idStackIndex];</span>
      <span class="s1">idStack[idStackIndex] = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">isHydrating = </span><span class="s2">false</span><span class="s1">; </span><span class="s0">// This flag allows for warning supression when we expect there to be mismatches</span>

  <span class="s2">var </span><span class="s1">hydrationErrors = </span><span class="s2">null</span><span class="s1">;</span>

  <span class="s2">function </span><span class="s1">reenterHydrationStateFromDehydratedSuspenseInstance(fiber, suspenseInstance, treeContext) {</span>
    <span class="s1">{</span>
      <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {</span>
    <span class="s1">{</span>
      <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Expected prepareToHydrateHostInstance() to never be called. ' </span><span class="s1">+ </span><span class="s3">'This error is likely caused by a bug in React. Please file an issue.'</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">prepareToHydrateHostTextInstance(fiber) {</span>
    <span class="s1">{</span>
      <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Expected prepareToHydrateHostTextInstance() to never be called. ' </span><span class="s1">+ </span><span class="s3">'This error is likely caused by a bug in React. Please file an issue.'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">var </span><span class="s1">shouldUpdate = hydrateTextInstance();</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">prepareToHydrateHostSuspenseInstance(fiber) {</span>
    <span class="s1">{</span>
      <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Expected prepareToHydrateHostSuspenseInstance() to never be called. ' </span><span class="s1">+ </span><span class="s3">'This error is likely caused by a bug in React. Please file an issue.'</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">popHydrationState(fiber) {</span>
    <span class="s1">{</span>
      <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">upgradeHydrationErrorsToRecoverable() {</span>
    <span class="s2">if </span><span class="s1">(hydrationErrors !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s0">// Successfully completed a forced client render. The errors that occurred</span>
      <span class="s0">// during the hydration attempt are now recovered. We will log them in</span>
      <span class="s0">// commit phase, once the entire tree has finished.</span>
      <span class="s1">queueRecoverableErrors(hydrationErrors);</span>
      <span class="s1">hydrationErrors = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">getIsHydrating() {</span>
    <span class="s2">return </span><span class="s1">isHydrating;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">queueHydrationError(error) {</span>
    <span class="s2">if </span><span class="s1">(hydrationErrors === </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">hydrationErrors = [error];</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">hydrationErrors.push(error);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig;</span>
  <span class="s2">var </span><span class="s1">NoTransition = </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s2">function </span><span class="s1">requestCurrentTransition() {</span>
    <span class="s2">return </span><span class="s1">ReactCurrentBatchConfig.transition;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Performs equality by iterating through keys on an object and returning false 
   * when any key has values which are not strictly equal between the arguments. 
   * Returns true when the values of all keys are strictly equal. 
   */</span>

  <span class="s2">function </span><span class="s1">shallowEqual(objA, objB) {</span>
    <span class="s2">if </span><span class="s1">(objectIs(objA, objB)) {</span>
      <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">objA !== </span><span class="s3">'object' </span><span class="s1">|| objA === </span><span class="s2">null </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">objB !== </span><span class="s3">'object' </span><span class="s1">|| objB === </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">keysA = Object.keys(objA);</span>
    <span class="s2">var </span><span class="s1">keysB = Object.keys(objB);</span>

    <span class="s2">if </span><span class="s1">(keysA.length !== keysB.length) {</span>
      <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s0">// Test for A's keys different from B.</span>


    <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; keysA.length; i++) {</span>
      <span class="s2">var </span><span class="s1">currentKey = keysA[i];</span>

      <span class="s2">if </span><span class="s1">(!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey])) {</span>
        <span class="s2">return false</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return true</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">describeFiber(fiber) {</span>
    <span class="s2">var </span><span class="s1">owner =  fiber._debugOwner ? fiber._debugOwner.type : </span><span class="s2">null </span><span class="s1">;</span>
    <span class="s2">var </span><span class="s1">source =  fiber._debugSource ;</span>

    <span class="s2">switch </span><span class="s1">(fiber.tag) {</span>
      <span class="s2">case </span><span class="s1">HostComponent:</span>
        <span class="s2">return </span><span class="s1">describeBuiltInComponentFrame(fiber.type);</span>

      <span class="s2">case </span><span class="s1">LazyComponent:</span>
        <span class="s2">return </span><span class="s1">describeBuiltInComponentFrame(</span><span class="s3">'Lazy'</span><span class="s1">);</span>

      <span class="s2">case </span><span class="s1">SuspenseComponent:</span>
        <span class="s2">return </span><span class="s1">describeBuiltInComponentFrame(</span><span class="s3">'Suspense'</span><span class="s1">);</span>

      <span class="s2">case </span><span class="s1">SuspenseListComponent:</span>
        <span class="s2">return </span><span class="s1">describeBuiltInComponentFrame(</span><span class="s3">'SuspenseList'</span><span class="s1">);</span>

      <span class="s2">case </span><span class="s1">FunctionComponent:</span>
      <span class="s2">case </span><span class="s1">IndeterminateComponent:</span>
      <span class="s2">case </span><span class="s1">SimpleMemoComponent:</span>
        <span class="s2">return </span><span class="s1">describeFunctionComponentFrame(fiber.type);</span>

      <span class="s2">case </span><span class="s1">ForwardRef:</span>
        <span class="s2">return </span><span class="s1">describeFunctionComponentFrame(fiber.type.render);</span>

      <span class="s2">case </span><span class="s1">ClassComponent:</span>
        <span class="s2">return </span><span class="s1">describeClassComponentFrame(fiber.type);</span>

      <span class="s2">default</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s3">''</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">getStackByFiberInDevAndProd(workInProgress) {</span>
    <span class="s2">try </span><span class="s1">{</span>
      <span class="s2">var </span><span class="s1">info = </span><span class="s3">''</span><span class="s1">;</span>
      <span class="s2">var </span><span class="s1">node = workInProgress;</span>

      <span class="s2">do </span><span class="s1">{</span>
        <span class="s1">info += describeFiber(node);</span>
        <span class="s1">node = node.</span><span class="s2">return</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s2">while </span><span class="s1">(node);</span>

      <span class="s2">return </span><span class="s1">info;</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(x) {</span>
      <span class="s2">return </span><span class="s3">'</span><span class="s5">\n</span><span class="s3">Error generating stack: ' </span><span class="s1">+ x.message + </span><span class="s3">'</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">+ x.stack;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;</span>
  <span class="s2">var </span><span class="s1">current = </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">isRendering = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s2">function </span><span class="s1">getCurrentFiberOwnerNameInDevOrNull() {</span>
    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(current === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">return null</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">owner = current._debugOwner;</span>

      <span class="s2">if </span><span class="s1">(owner !== </span><span class="s2">null </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">owner !== </span><span class="s3">'undefined'</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">getComponentNameFromFiber(owner);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">getCurrentFiberStackInDev() {</span>
    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(current === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s3">''</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// Safe because if current fiber exists, we are reconciling,</span>
      <span class="s0">// and it is guaranteed to be the work-in-progress version.</span>


      <span class="s2">return </span><span class="s1">getStackByFiberInDevAndProd(current);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">resetCurrentFiber() {</span>
    <span class="s1">{</span>
      <span class="s1">ReactDebugCurrentFrame$1.getCurrentStack = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">current = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">isRendering = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">setCurrentFiber(fiber) {</span>
    <span class="s1">{</span>
      <span class="s1">ReactDebugCurrentFrame$1.getCurrentStack = fiber === </span><span class="s2">null </span><span class="s1">? </span><span class="s2">null </span><span class="s1">: getCurrentFiberStackInDev;</span>
      <span class="s1">current = fiber;</span>
      <span class="s1">isRendering = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">getCurrentFiber() {</span>
    <span class="s1">{</span>
      <span class="s2">return </span><span class="s1">current;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">setIsRendering(rendering) {</span>
    <span class="s1">{</span>
      <span class="s1">isRendering = rendering;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">ReactStrictModeWarnings = {</span>
    <span class="s1">recordUnsafeLifecycleWarnings: </span><span class="s2">function </span><span class="s1">(fiber, instance) {},</span>
    <span class="s1">flushPendingUnsafeLifecycleWarnings: </span><span class="s2">function </span><span class="s1">() {},</span>
    <span class="s1">recordLegacyContextWarning: </span><span class="s2">function </span><span class="s1">(fiber, instance) {},</span>
    <span class="s1">flushLegacyContextWarning: </span><span class="s2">function </span><span class="s1">() {},</span>
    <span class="s1">discardPendingWarnings: </span><span class="s2">function </span><span class="s1">() {}</span>
  <span class="s1">};</span>

  <span class="s1">{</span>
    <span class="s2">var </span><span class="s1">findStrictRoot = </span><span class="s2">function </span><span class="s1">(fiber) {</span>
      <span class="s2">var </span><span class="s1">maybeStrictRoot = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s2">var </span><span class="s1">node = fiber;</span>

      <span class="s2">while </span><span class="s1">(node !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(node.mode &amp; StrictLegacyMode) {</span>
          <span class="s1">maybeStrictRoot = node;</span>
        <span class="s1">}</span>

        <span class="s1">node = node.</span><span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">return </span><span class="s1">maybeStrictRoot;</span>
    <span class="s1">};</span>

    <span class="s2">var </span><span class="s1">setToSortedString = </span><span class="s2">function </span><span class="s1">(set) {</span>
      <span class="s2">var </span><span class="s1">array = [];</span>
      <span class="s1">set.forEach(</span><span class="s2">function </span><span class="s1">(value) {</span>
        <span class="s1">array.push(value);</span>
      <span class="s1">});</span>
      <span class="s2">return </span><span class="s1">array.sort().join(</span><span class="s3">', '</span><span class="s1">);</span>
    <span class="s1">};</span>

    <span class="s2">var </span><span class="s1">pendingComponentWillMountWarnings = [];</span>
    <span class="s2">var </span><span class="s1">pendingUNSAFE_ComponentWillMountWarnings = [];</span>
    <span class="s2">var </span><span class="s1">pendingComponentWillReceivePropsWarnings = [];</span>
    <span class="s2">var </span><span class="s1">pendingUNSAFE_ComponentWillReceivePropsWarnings = [];</span>
    <span class="s2">var </span><span class="s1">pendingComponentWillUpdateWarnings = [];</span>
    <span class="s2">var </span><span class="s1">pendingUNSAFE_ComponentWillUpdateWarnings = []; </span><span class="s0">// Tracks components we have already warned about.</span>

    <span class="s2">var </span><span class="s1">didWarnAboutUnsafeLifecycles = </span><span class="s2">new </span><span class="s1">Set();</span>

    <span class="s1">ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = </span><span class="s2">function </span><span class="s1">(fiber, instance) {</span>
      <span class="s0">// Dedupe strategy: Warn once per component.</span>
      <span class="s2">if </span><span class="s1">(didWarnAboutUnsafeLifecycles.has(fiber.type)) {</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">instance.componentWillMount === </span><span class="s3">'function' </span><span class="s1">&amp;&amp; </span><span class="s0">// Don't warn about react-lifecycles-compat polyfilled components.</span>
      <span class="s1">instance.componentWillMount.__suppressDeprecationWarning !== </span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s1">pendingComponentWillMountWarnings.push(fiber);</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(fiber.mode &amp; StrictLegacyMode &amp;&amp; </span><span class="s2">typeof </span><span class="s1">instance.UNSAFE_componentWillMount === </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s1">pendingUNSAFE_ComponentWillMountWarnings.push(fiber);</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">instance.componentWillReceiveProps === </span><span class="s3">'function' </span><span class="s1">&amp;&amp; instance.componentWillReceiveProps.__suppressDeprecationWarning !== </span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s1">pendingComponentWillReceivePropsWarnings.push(fiber);</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(fiber.mode &amp; StrictLegacyMode &amp;&amp; </span><span class="s2">typeof </span><span class="s1">instance.UNSAFE_componentWillReceiveProps === </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s1">pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">instance.componentWillUpdate === </span><span class="s3">'function' </span><span class="s1">&amp;&amp; instance.componentWillUpdate.__suppressDeprecationWarning !== </span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s1">pendingComponentWillUpdateWarnings.push(fiber);</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(fiber.mode &amp; StrictLegacyMode &amp;&amp; </span><span class="s2">typeof </span><span class="s1">instance.UNSAFE_componentWillUpdate === </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s1">pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);</span>
      <span class="s1">}</span>
    <span class="s1">};</span>

    <span class="s1">ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = </span><span class="s2">function </span><span class="s1">() {</span>
      <span class="s0">// We do an initial pass to gather component names</span>
      <span class="s2">var </span><span class="s1">componentWillMountUniqueNames = </span><span class="s2">new </span><span class="s1">Set();</span>

      <span class="s2">if </span><span class="s1">(pendingComponentWillMountWarnings.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">pendingComponentWillMountWarnings.forEach(</span><span class="s2">function </span><span class="s1">(fiber) {</span>
          <span class="s1">componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || </span><span class="s3">'Component'</span><span class="s1">);</span>
          <span class="s1">didWarnAboutUnsafeLifecycles.add(fiber.type);</span>
        <span class="s1">});</span>
        <span class="s1">pendingComponentWillMountWarnings = [];</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">UNSAFE_componentWillMountUniqueNames = </span><span class="s2">new </span><span class="s1">Set();</span>

      <span class="s2">if </span><span class="s1">(pendingUNSAFE_ComponentWillMountWarnings.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">pendingUNSAFE_ComponentWillMountWarnings.forEach(</span><span class="s2">function </span><span class="s1">(fiber) {</span>
          <span class="s1">UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || </span><span class="s3">'Component'</span><span class="s1">);</span>
          <span class="s1">didWarnAboutUnsafeLifecycles.add(fiber.type);</span>
        <span class="s1">});</span>
        <span class="s1">pendingUNSAFE_ComponentWillMountWarnings = [];</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">componentWillReceivePropsUniqueNames = </span><span class="s2">new </span><span class="s1">Set();</span>

      <span class="s2">if </span><span class="s1">(pendingComponentWillReceivePropsWarnings.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">pendingComponentWillReceivePropsWarnings.forEach(</span><span class="s2">function </span><span class="s1">(fiber) {</span>
          <span class="s1">componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || </span><span class="s3">'Component'</span><span class="s1">);</span>
          <span class="s1">didWarnAboutUnsafeLifecycles.add(fiber.type);</span>
        <span class="s1">});</span>
        <span class="s1">pendingComponentWillReceivePropsWarnings = [];</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">UNSAFE_componentWillReceivePropsUniqueNames = </span><span class="s2">new </span><span class="s1">Set();</span>

      <span class="s2">if </span><span class="s1">(pendingUNSAFE_ComponentWillReceivePropsWarnings.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(</span><span class="s2">function </span><span class="s1">(fiber) {</span>
          <span class="s1">UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || </span><span class="s3">'Component'</span><span class="s1">);</span>
          <span class="s1">didWarnAboutUnsafeLifecycles.add(fiber.type);</span>
        <span class="s1">});</span>
        <span class="s1">pendingUNSAFE_ComponentWillReceivePropsWarnings = [];</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">componentWillUpdateUniqueNames = </span><span class="s2">new </span><span class="s1">Set();</span>

      <span class="s2">if </span><span class="s1">(pendingComponentWillUpdateWarnings.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">pendingComponentWillUpdateWarnings.forEach(</span><span class="s2">function </span><span class="s1">(fiber) {</span>
          <span class="s1">componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || </span><span class="s3">'Component'</span><span class="s1">);</span>
          <span class="s1">didWarnAboutUnsafeLifecycles.add(fiber.type);</span>
        <span class="s1">});</span>
        <span class="s1">pendingComponentWillUpdateWarnings = [];</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">UNSAFE_componentWillUpdateUniqueNames = </span><span class="s2">new </span><span class="s1">Set();</span>

      <span class="s2">if </span><span class="s1">(pendingUNSAFE_ComponentWillUpdateWarnings.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">pendingUNSAFE_ComponentWillUpdateWarnings.forEach(</span><span class="s2">function </span><span class="s1">(fiber) {</span>
          <span class="s1">UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || </span><span class="s3">'Component'</span><span class="s1">);</span>
          <span class="s1">didWarnAboutUnsafeLifecycles.add(fiber.type);</span>
        <span class="s1">});</span>
        <span class="s1">pendingUNSAFE_ComponentWillUpdateWarnings = [];</span>
      <span class="s1">} </span><span class="s0">// Finally, we flush all the warnings</span>
      <span class="s0">// UNSAFE_ ones before the deprecated ones, since they'll be 'louder'</span>


      <span class="s2">if </span><span class="s1">(UNSAFE_componentWillMountUniqueNames.size &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s2">var </span><span class="s1">sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);</span>

        <span class="s1">error(</span><span class="s3">'Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. ' </span><span class="s1">+ </span><span class="s3">'See https://reactjs.org/link/unsafe-component-lifecycles for details.</span><span class="s5">\n\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">'* Move code with side effects to componentDidMount, and set initial state in the constructor.</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">'</span><span class="s5">\n</span><span class="s3">Please update the following components: %s'</span><span class="s1">, sortedNames);</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(UNSAFE_componentWillReceivePropsUniqueNames.size &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s2">var </span><span class="s1">_sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);</span>

        <span class="s1">error(</span><span class="s3">'Using UNSAFE_componentWillReceiveProps in strict mode is not recommended ' </span><span class="s1">+ </span><span class="s3">'and may indicate bugs in your code. ' </span><span class="s1">+ </span><span class="s3">'See https://reactjs.org/link/unsafe-component-lifecycles for details.</span><span class="s5">\n\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">'* Move data fetching code or side effects to componentDidUpdate.</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">&quot;* If you're updating state whenever props change, &quot; </span><span class="s1">+ </span><span class="s3">'refactor your code to use memoization techniques or move it to ' </span><span class="s1">+ </span><span class="s3">'static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">'</span><span class="s5">\n</span><span class="s3">Please update the following components: %s'</span><span class="s1">, _sortedNames);</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(UNSAFE_componentWillUpdateUniqueNames.size &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s2">var </span><span class="s1">_sortedNames2 = setToSortedString(UNSAFE_componentWillUpdateUniqueNames);</span>

        <span class="s1">error(</span><span class="s3">'Using UNSAFE_componentWillUpdate in strict mode is not recommended ' </span><span class="s1">+ </span><span class="s3">'and may indicate bugs in your code. ' </span><span class="s1">+ </span><span class="s3">'See https://reactjs.org/link/unsafe-component-lifecycles for details.</span><span class="s5">\n\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">'* Move data fetching code or side effects to componentDidUpdate.</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">'</span><span class="s5">\n</span><span class="s3">Please update the following components: %s'</span><span class="s1">, _sortedNames2);</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(componentWillMountUniqueNames.size &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s2">var </span><span class="s1">_sortedNames3 = setToSortedString(componentWillMountUniqueNames);</span>

        <span class="s1">warn(</span><span class="s3">'componentWillMount has been renamed, and is not recommended for use. ' </span><span class="s1">+ </span><span class="s3">'See https://reactjs.org/link/unsafe-component-lifecycles for details.</span><span class="s5">\n\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">'* Move code with side effects to componentDidMount, and set initial state in the constructor.</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">'* Rename componentWillMount to UNSAFE_componentWillMount to suppress ' </span><span class="s1">+ </span><span class="s3">'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. ' </span><span class="s1">+ </span><span class="s3">'To rename all deprecated lifecycles to their new names, you can run ' </span><span class="s1">+ </span><span class="s3">'`npx react-codemod rename-unsafe-lifecycles` in your project source folder.</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">'</span><span class="s5">\n</span><span class="s3">Please update the following components: %s'</span><span class="s1">, _sortedNames3);</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(componentWillReceivePropsUniqueNames.size &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s2">var </span><span class="s1">_sortedNames4 = setToSortedString(componentWillReceivePropsUniqueNames);</span>

        <span class="s1">warn(</span><span class="s3">'componentWillReceiveProps has been renamed, and is not recommended for use. ' </span><span class="s1">+ </span><span class="s3">'See https://reactjs.org/link/unsafe-component-lifecycles for details.</span><span class="s5">\n\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">'* Move data fetching code or side effects to componentDidUpdate.</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">&quot;* If you're updating state whenever props change, refactor your &quot; </span><span class="s1">+ </span><span class="s3">'code to use memoization techniques or move it to ' </span><span class="s1">+ </span><span class="s3">'static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">'* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress ' </span><span class="s1">+ </span><span class="s3">'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. ' </span><span class="s1">+ </span><span class="s3">'To rename all deprecated lifecycles to their new names, you can run ' </span><span class="s1">+ </span><span class="s3">'`npx react-codemod rename-unsafe-lifecycles` in your project source folder.</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">'</span><span class="s5">\n</span><span class="s3">Please update the following components: %s'</span><span class="s1">, _sortedNames4);</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(componentWillUpdateUniqueNames.size &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s2">var </span><span class="s1">_sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);</span>

        <span class="s1">warn(</span><span class="s3">'componentWillUpdate has been renamed, and is not recommended for use. ' </span><span class="s1">+ </span><span class="s3">'See https://reactjs.org/link/unsafe-component-lifecycles for details.</span><span class="s5">\n\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">'* Move data fetching code or side effects to componentDidUpdate.</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">'* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress ' </span><span class="s1">+ </span><span class="s3">'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. ' </span><span class="s1">+ </span><span class="s3">'To rename all deprecated lifecycles to their new names, you can run ' </span><span class="s1">+ </span><span class="s3">'`npx react-codemod rename-unsafe-lifecycles` in your project source folder.</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">'</span><span class="s5">\n</span><span class="s3">Please update the following components: %s'</span><span class="s1">, _sortedNames5);</span>
      <span class="s1">}</span>
    <span class="s1">};</span>

    <span class="s2">var </span><span class="s1">pendingLegacyContextWarning = </span><span class="s2">new </span><span class="s1">Map(); </span><span class="s0">// Tracks components we have already warned about.</span>

    <span class="s2">var </span><span class="s1">didWarnAboutLegacyContext = </span><span class="s2">new </span><span class="s1">Set();</span>

    <span class="s1">ReactStrictModeWarnings.recordLegacyContextWarning = </span><span class="s2">function </span><span class="s1">(fiber, instance) {</span>
      <span class="s2">var </span><span class="s1">strictRoot = findStrictRoot(fiber);</span>

      <span class="s2">if </span><span class="s1">(strictRoot === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s3">'Expected to find a StrictMode component in a strict mode tree. ' </span><span class="s1">+ </span><span class="s3">'This error is likely caused by a bug in React. Please file an issue.'</span><span class="s1">);</span>

        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// Dedup strategy: Warn once per component.</span>


      <span class="s2">if </span><span class="s1">(didWarnAboutLegacyContext.has(fiber.type)) {</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">warningsForRoot = pendingLegacyContextWarning.get(strictRoot);</span>

      <span class="s2">if </span><span class="s1">(fiber.type.contextTypes != </span><span class="s2">null </span><span class="s1">|| fiber.type.childContextTypes != </span><span class="s2">null </span><span class="s1">|| instance !== </span><span class="s2">null </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">instance.getChildContext === </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(warningsForRoot === undefined) {</span>
          <span class="s1">warningsForRoot = [];</span>
          <span class="s1">pendingLegacyContextWarning.set(strictRoot, warningsForRoot);</span>
        <span class="s1">}</span>

        <span class="s1">warningsForRoot.push(fiber);</span>
      <span class="s1">}</span>
    <span class="s1">};</span>

    <span class="s1">ReactStrictModeWarnings.flushLegacyContextWarning = </span><span class="s2">function </span><span class="s1">() {</span>
      <span class="s1">pendingLegacyContextWarning.forEach(</span><span class="s2">function </span><span class="s1">(fiberArray, strictRoot) {</span>
        <span class="s2">if </span><span class="s1">(fiberArray.length === </span><span class="s4">0</span><span class="s1">) {</span>
          <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s2">var </span><span class="s1">firstFiber = fiberArray[</span><span class="s4">0</span><span class="s1">];</span>
        <span class="s2">var </span><span class="s1">uniqueNames = </span><span class="s2">new </span><span class="s1">Set();</span>
        <span class="s1">fiberArray.forEach(</span><span class="s2">function </span><span class="s1">(fiber) {</span>
          <span class="s1">uniqueNames.add(getComponentNameFromFiber(fiber) || </span><span class="s3">'Component'</span><span class="s1">);</span>
          <span class="s1">didWarnAboutLegacyContext.add(fiber.type);</span>
        <span class="s1">});</span>
        <span class="s2">var </span><span class="s1">sortedNames = setToSortedString(uniqueNames);</span>

        <span class="s2">try </span><span class="s1">{</span>
          <span class="s1">setCurrentFiber(firstFiber);</span>

          <span class="s1">error(</span><span class="s3">'Legacy context API has been detected within a strict-mode tree.' </span><span class="s1">+ </span><span class="s3">'</span><span class="s5">\n\n</span><span class="s3">The old API will be supported in all 16.x releases, but applications ' </span><span class="s1">+ </span><span class="s3">'using it should migrate to the new version.' </span><span class="s1">+ </span><span class="s3">'</span><span class="s5">\n\n</span><span class="s3">Please update the following components: %s' </span><span class="s1">+ </span><span class="s3">'</span><span class="s5">\n\n</span><span class="s3">Learn more about this warning here: https://reactjs.org/link/legacy-context'</span><span class="s1">, sortedNames);</span>
        <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
          <span class="s1">resetCurrentFiber();</span>
        <span class="s1">}</span>
      <span class="s1">});</span>
    <span class="s1">};</span>

    <span class="s1">ReactStrictModeWarnings.discardPendingWarnings = </span><span class="s2">function </span><span class="s1">() {</span>
      <span class="s1">pendingComponentWillMountWarnings = [];</span>
      <span class="s1">pendingUNSAFE_ComponentWillMountWarnings = [];</span>
      <span class="s1">pendingComponentWillReceivePropsWarnings = [];</span>
      <span class="s1">pendingUNSAFE_ComponentWillReceivePropsWarnings = [];</span>
      <span class="s1">pendingComponentWillUpdateWarnings = [];</span>
      <span class="s1">pendingUNSAFE_ComponentWillUpdateWarnings = [];</span>
      <span class="s1">pendingLegacyContextWarning = </span><span class="s2">new </span><span class="s1">Map();</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s0">/* 
   * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol 
   * and Temporal.* types. See https://github.com/facebook/react/pull/22064. 
   * 
   * The functions in this module will throw an easier-to-understand, 
   * easier-to-debug exception with a clear errors message message explaining the 
   * problem. (Instead of a confusing exception thrown inside the implementation 
   * of the `value` object). 
   */</span>
  <span class="s0">// $FlowFixMe only called in DEV, so void return is not possible.</span>
  <span class="s2">function </span><span class="s1">typeName(value) {</span>
    <span class="s1">{</span>
      <span class="s0">// toStringTag is needed for namespaced types like Temporal.Instant</span>
      <span class="s2">var </span><span class="s1">hasToStringTag = </span><span class="s2">typeof </span><span class="s1">Symbol === </span><span class="s3">'function' </span><span class="s1">&amp;&amp; Symbol.toStringTag;</span>
      <span class="s2">var </span><span class="s1">type = hasToStringTag &amp;&amp; value[Symbol.toStringTag] || value.constructor.name || </span><span class="s3">'Object'</span><span class="s1">;</span>
      <span class="s2">return </span><span class="s1">type;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s0">// $FlowFixMe only called in DEV, so void return is not possible.</span>


  <span class="s2">function </span><span class="s1">willCoercionThrow(value) {</span>
    <span class="s1">{</span>
      <span class="s2">try </span><span class="s1">{</span>
        <span class="s1">testStringCoercion(value);</span>
        <span class="s2">return false</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s2">catch </span><span class="s1">(e) {</span>
        <span class="s2">return true</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">testStringCoercion(value) {</span>
    <span class="s0">// If you ended up here by following an exception call stack, here's what's</span>
    <span class="s0">// happened: you supplied an object or symbol value to React (as a prop, key,</span>
    <span class="s0">// DOM attribute, CSS property, string ref, etc.) and when React tried to</span>
    <span class="s0">// coerce it to a string using `'' + value`, an exception was thrown.</span>
    <span class="s0">//</span>
    <span class="s0">// The most common types that will cause this exception are `Symbol` instances</span>
    <span class="s0">// and Temporal objects like `Temporal.Instant`. But any object that has a</span>
    <span class="s0">// `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this</span>
    <span class="s0">// exception. (Library authors do this to prevent users from using built-in</span>
    <span class="s0">// numeric operators like `+` or comparison operators like `&gt;=` because custom</span>
    <span class="s0">// methods are needed to perform accurate arithmetic or comparison.)</span>
    <span class="s0">//</span>
    <span class="s0">// To fix the problem, coerce this object or symbol value to a string before</span>
    <span class="s0">// passing it to React. The most reliable way is usually `String(value)`.</span>
    <span class="s0">//</span>
    <span class="s0">// To find which value is throwing, check the browser or debugger console.</span>
    <span class="s0">// Before this exception was thrown, there should be `console.error` output</span>
    <span class="s0">// that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the</span>
    <span class="s0">// problem and how that type was used: key, atrribute, input value prop, etc.</span>
    <span class="s0">// In most cases, this console output also shows the component and its</span>
    <span class="s0">// ancestor components where the exception happened.</span>
    <span class="s0">//</span>
    <span class="s0">// eslint-disable-next-line react-internal/safe-string-coercion</span>
    <span class="s2">return </span><span class="s3">'' </span><span class="s1">+ value;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">checkPropStringCoercion(value, propName) {</span>
    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(willCoercionThrow(value)) {</span>
        <span class="s1">error(</span><span class="s3">'The provided `%s` prop is an unsupported type %s.' </span><span class="s1">+ </span><span class="s3">' This value must be coerced to a string before before using it here.'</span><span class="s1">, propName, typeName(value));</span>

        <span class="s2">return </span><span class="s1">testStringCoercion(value); </span><span class="s0">// throw (to help callers find troubleshooting comments)</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">resolveDefaultProps(Component, baseProps) {</span>
    <span class="s2">if </span><span class="s1">(Component &amp;&amp; Component.defaultProps) {</span>
      <span class="s0">// Resolve default props. Taken from ReactElement</span>
      <span class="s2">var </span><span class="s1">props = assign({}, baseProps);</span>
      <span class="s2">var </span><span class="s1">defaultProps = Component.defaultProps;</span>

      <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">propName </span><span class="s2">in </span><span class="s1">defaultProps) {</span>
        <span class="s2">if </span><span class="s1">(props[propName] === undefined) {</span>
          <span class="s1">props[propName] = defaultProps[propName];</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">return </span><span class="s1">props;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">baseProps;</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">valueCursor = createCursor(</span><span class="s2">null</span><span class="s1">);</span>
  <span class="s2">var </span><span class="s1">rendererSigil;</span>

  <span class="s1">{</span>
    <span class="s0">// Use this to detect multiple renderers using the same context</span>
    <span class="s1">rendererSigil = {};</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">currentlyRenderingFiber = </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">lastContextDependency = </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">lastFullyObservedContext = </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">isDisallowedContextReadInDEV = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s2">function </span><span class="s1">resetContextDependencies() {</span>
    <span class="s0">// This is called right before React yields execution, to ensure `readContext`</span>
    <span class="s0">// cannot be called outside the render phase.</span>
    <span class="s1">currentlyRenderingFiber = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">lastContextDependency = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">lastFullyObservedContext = </span><span class="s2">null</span><span class="s1">;</span>

    <span class="s1">{</span>
      <span class="s1">isDisallowedContextReadInDEV = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">enterDisallowedContextReadInDEV() {</span>
    <span class="s1">{</span>
      <span class="s1">isDisallowedContextReadInDEV = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">exitDisallowedContextReadInDEV() {</span>
    <span class="s1">{</span>
      <span class="s1">isDisallowedContextReadInDEV = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">pushProvider(providerFiber, context, nextValue) {</span>
    <span class="s1">{</span>
      <span class="s1">push(valueCursor, context._currentValue2, providerFiber);</span>
      <span class="s1">context._currentValue2 = nextValue;</span>

      <span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(context._currentRenderer2 !== undefined &amp;&amp; context._currentRenderer2 !== </span><span class="s2">null </span><span class="s1">&amp;&amp; context._currentRenderer2 !== rendererSigil) {</span>
          <span class="s1">error(</span><span class="s3">'Detected multiple renderers concurrently rendering the ' </span><span class="s1">+ </span><span class="s3">'same context provider. This is currently unsupported.'</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s1">context._currentRenderer2 = rendererSigil;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">popProvider(context, providerFiber) {</span>
    <span class="s2">var </span><span class="s1">currentValue = valueCursor.current;</span>
    <span class="s1">pop(valueCursor, providerFiber);</span>

    <span class="s1">{</span>
      <span class="s1">{</span>
        <span class="s1">context._currentValue2 = currentValue;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">scheduleContextWorkOnParentPath(parent, renderLanes, propagationRoot) {</span>
    <span class="s0">// Update the child lanes of all the ancestors, including the alternates.</span>
    <span class="s2">var </span><span class="s1">node = parent;</span>

    <span class="s2">while </span><span class="s1">(node !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">alternate = node.alternate;</span>

      <span class="s2">if </span><span class="s1">(!isSubsetOfLanes(node.childLanes, renderLanes)) {</span>
        <span class="s1">node.childLanes = mergeLanes(node.childLanes, renderLanes);</span>

        <span class="s2">if </span><span class="s1">(alternate !== </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes);</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(alternate !== </span><span class="s2">null </span><span class="s1">&amp;&amp; !isSubsetOfLanes(alternate.childLanes, renderLanes)) {</span>
        <span class="s1">alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes);</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(node === propagationRoot) {</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">node = node.</span><span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(node !== propagationRoot) {</span>
        <span class="s1">error(</span><span class="s3">'Expected to find the propagation root when scheduling context work. ' </span><span class="s1">+ </span><span class="s3">'This error is likely caused by a bug in React. Please file an issue.'</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">propagateContextChange(workInProgress, context, renderLanes) {</span>
    <span class="s1">{</span>
      <span class="s1">propagateContextChange_eager(workInProgress, context, renderLanes);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">propagateContextChange_eager(workInProgress, context, renderLanes) {</span>

    <span class="s2">var </span><span class="s1">fiber = workInProgress.child;</span>

    <span class="s2">if </span><span class="s1">(fiber !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s0">// Set the return pointer of the child to the work-in-progress fiber.</span>
      <span class="s1">fiber.</span><span class="s2">return </span><span class="s1">= workInProgress;</span>
    <span class="s1">}</span>

    <span class="s2">while </span><span class="s1">(fiber !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">nextFiber = </span><span class="s2">void </span><span class="s4">0</span><span class="s1">; </span><span class="s0">// Visit this fiber.</span>

      <span class="s2">var </span><span class="s1">list = fiber.dependencies;</span>

      <span class="s2">if </span><span class="s1">(list !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">nextFiber = fiber.child;</span>
        <span class="s2">var </span><span class="s1">dependency = list.firstContext;</span>

        <span class="s2">while </span><span class="s1">(dependency !== </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s0">// Check if the context matches.</span>
          <span class="s2">if </span><span class="s1">(dependency.context === context) {</span>
            <span class="s0">// Match! Schedule an update on this fiber.</span>
            <span class="s2">if </span><span class="s1">(fiber.tag === ClassComponent) {</span>
              <span class="s0">// Schedule a force update on the work-in-progress.</span>
              <span class="s2">var </span><span class="s1">lane = pickArbitraryLane(renderLanes);</span>
              <span class="s2">var </span><span class="s1">update = createUpdate(NoTimestamp, lane);</span>
              <span class="s1">update.tag = ForceUpdate; </span><span class="s0">// TODO: Because we don't have a work-in-progress, this will add the</span>
              <span class="s0">// update to the current fiber, too, which means it will persist even if</span>
              <span class="s0">// this render is thrown away. Since it's a race condition, not sure it's</span>
              <span class="s0">// worth fixing.</span>
              <span class="s0">// Inlined `enqueueUpdate` to remove interleaved update check</span>

              <span class="s2">var </span><span class="s1">updateQueue = fiber.updateQueue;</span>

              <span class="s2">if </span><span class="s1">(updateQueue === </span><span class="s2">null</span><span class="s1">) ; </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s2">var </span><span class="s1">sharedQueue = updateQueue.shared;</span>
                <span class="s2">var </span><span class="s1">pending = sharedQueue.pending;</span>

                <span class="s2">if </span><span class="s1">(pending === </span><span class="s2">null</span><span class="s1">) {</span>
                  <span class="s0">// This is the first update. Create a circular list.</span>
                  <span class="s1">update.next = update;</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                  <span class="s1">update.next = pending.next;</span>
                  <span class="s1">pending.next = update;</span>
                <span class="s1">}</span>

                <span class="s1">sharedQueue.pending = update;</span>
              <span class="s1">}</span>
            <span class="s1">}</span>

            <span class="s1">fiber.lanes = mergeLanes(fiber.lanes, renderLanes);</span>
            <span class="s2">var </span><span class="s1">alternate = fiber.alternate;</span>

            <span class="s2">if </span><span class="s1">(alternate !== </span><span class="s2">null</span><span class="s1">) {</span>
              <span class="s1">alternate.lanes = mergeLanes(alternate.lanes, renderLanes);</span>
            <span class="s1">}</span>

            <span class="s1">scheduleContextWorkOnParentPath(fiber.</span><span class="s2">return</span><span class="s1">, renderLanes, workInProgress); </span><span class="s0">// Mark the updated lanes on the list, too.</span>

            <span class="s1">list.lanes = mergeLanes(list.lanes, renderLanes); </span><span class="s0">// Since we already found a match, we can stop traversing the</span>
            <span class="s0">// dependency list.</span>

            <span class="s2">break</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s1">dependency = dependency.next;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(fiber.tag === ContextProvider) {</span>
        <span class="s0">// Don't scan deeper if this is a matching provider</span>
        <span class="s1">nextFiber = fiber.type === workInProgress.type ? </span><span class="s2">null </span><span class="s1">: fiber.child;</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(fiber.tag === DehydratedFragment) {</span>
        <span class="s0">// If a dehydrated suspense boundary is in this subtree, we don't know</span>
        <span class="s0">// if it will have any context consumers in it. The best we can do is</span>
        <span class="s0">// mark it as having updates.</span>
        <span class="s2">var </span><span class="s1">parentSuspense = fiber.</span><span class="s2">return</span><span class="s1">;</span>

        <span class="s2">if </span><span class="s1">(parentSuspense === </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'We just came from a parent so we must have had a parent. This is a bug in React.'</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s1">parentSuspense.lanes = mergeLanes(parentSuspense.lanes, renderLanes);</span>
        <span class="s2">var </span><span class="s1">_alternate = parentSuspense.alternate;</span>

        <span class="s2">if </span><span class="s1">(_alternate !== </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">_alternate.lanes = mergeLanes(_alternate.lanes, renderLanes);</span>
        <span class="s1">} </span><span class="s0">// This is intentionally passing this fiber as the parent</span>
        <span class="s0">// because we want to schedule this fiber as having work</span>
        <span class="s0">// on its children. We'll use the childLanes on</span>
        <span class="s0">// this fiber to indicate that a context has changed.</span>


        <span class="s1">scheduleContextWorkOnParentPath(parentSuspense, renderLanes, workInProgress);</span>
        <span class="s1">nextFiber = fiber.sibling;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s0">// Traverse down.</span>
        <span class="s1">nextFiber = fiber.child;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(nextFiber !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s0">// Set the return pointer of the child to the work-in-progress fiber.</span>
        <span class="s1">nextFiber.</span><span class="s2">return </span><span class="s1">= fiber;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s0">// No child. Traverse to next sibling.</span>
        <span class="s1">nextFiber = fiber;</span>

        <span class="s2">while </span><span class="s1">(nextFiber !== </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s2">if </span><span class="s1">(nextFiber === workInProgress) {</span>
            <span class="s0">// We're back to the root of this subtree. Exit.</span>
            <span class="s1">nextFiber = </span><span class="s2">null</span><span class="s1">;</span>
            <span class="s2">break</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s2">var </span><span class="s1">sibling = nextFiber.sibling;</span>

          <span class="s2">if </span><span class="s1">(sibling !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s0">// Set the return pointer of the sibling to the work-in-progress fiber.</span>
            <span class="s1">sibling.</span><span class="s2">return </span><span class="s1">= nextFiber.</span><span class="s2">return</span><span class="s1">;</span>
            <span class="s1">nextFiber = sibling;</span>
            <span class="s2">break</span><span class="s1">;</span>
          <span class="s1">} </span><span class="s0">// No more siblings. Traverse up.</span>


          <span class="s1">nextFiber = nextFiber.</span><span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">fiber = nextFiber;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">prepareToReadContext(workInProgress, renderLanes) {</span>
    <span class="s1">currentlyRenderingFiber = workInProgress;</span>
    <span class="s1">lastContextDependency = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">lastFullyObservedContext = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">var </span><span class="s1">dependencies = workInProgress.dependencies;</span>

    <span class="s2">if </span><span class="s1">(dependencies !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">{</span>
        <span class="s2">var </span><span class="s1">firstContext = dependencies.firstContext;</span>

        <span class="s2">if </span><span class="s1">(firstContext !== </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s2">if </span><span class="s1">(includesSomeLane(dependencies.lanes, renderLanes)) {</span>
            <span class="s0">// Context list has a pending update. Mark that this fiber performed work.</span>
            <span class="s1">markWorkInProgressReceivedUpdate();</span>
          <span class="s1">} </span><span class="s0">// Reset the work-in-progress list</span>


          <span class="s1">dependencies.firstContext = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">readContext(context) {</span>
    <span class="s1">{</span>
      <span class="s0">// This warning would fire if you read context inside a Hook like useMemo.</span>
      <span class="s0">// Unlike the class check below, it's not enforced in production for perf.</span>
      <span class="s2">if </span><span class="s1">(isDisallowedContextReadInDEV) {</span>
        <span class="s1">error(</span><span class="s3">'Context can only be read while React is rendering. ' </span><span class="s1">+ </span><span class="s3">'In classes, you can read it in the render method or getDerivedStateFromProps. ' </span><span class="s1">+ </span><span class="s3">'In function components, you can read it directly in the function body, but not ' </span><span class="s1">+ </span><span class="s3">'inside Hooks like useReducer() or useMemo().'</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">value =  context._currentValue2;</span>

    <span class="s2">if </span><span class="s1">(lastFullyObservedContext === context) ; </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">var </span><span class="s1">contextItem = {</span>
        <span class="s1">context: context,</span>
        <span class="s1">memoizedValue: value,</span>
        <span class="s1">next: </span><span class="s2">null</span>
      <span class="s1">};</span>

      <span class="s2">if </span><span class="s1">(lastContextDependency === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(currentlyRenderingFiber === </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Context can only be read while React is rendering. ' </span><span class="s1">+ </span><span class="s3">'In classes, you can read it in the render method or getDerivedStateFromProps. ' </span><span class="s1">+ </span><span class="s3">'In function components, you can read it directly in the function body, but not ' </span><span class="s1">+ </span><span class="s3">'inside Hooks like useReducer() or useMemo().'</span><span class="s1">);</span>
        <span class="s1">} </span><span class="s0">// This is the first dependency for this component. Create a new list.</span>


        <span class="s1">lastContextDependency = contextItem;</span>
        <span class="s1">currentlyRenderingFiber.dependencies = {</span>
          <span class="s1">lanes: NoLanes,</span>
          <span class="s1">firstContext: contextItem</span>
        <span class="s1">};</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s0">// Append a new context item.</span>
        <span class="s1">lastContextDependency = lastContextDependency.next = contextItem;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">value;</span>
  <span class="s1">}</span>

  <span class="s0">// render. When this render exits, either because it finishes or because it is</span>
  <span class="s0">// interrupted, the interleaved updates will be transferred onto the main part</span>
  <span class="s0">// of the queue.</span>

  <span class="s2">var </span><span class="s1">concurrentQueues = </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s2">function </span><span class="s1">pushConcurrentUpdateQueue(queue) {</span>
    <span class="s2">if </span><span class="s1">(concurrentQueues === </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">concurrentQueues = [queue];</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">concurrentQueues.push(queue);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">finishQueueingConcurrentUpdates() {</span>
    <span class="s0">// Transfer the interleaved updates onto the main queue. Each queue has a</span>
    <span class="s0">// `pending` field and an `interleaved` field. When they are not null, they</span>
    <span class="s0">// point to the last node in a circular linked list. We need to append the</span>
    <span class="s0">// interleaved list to the end of the pending list by joining them into a</span>
    <span class="s0">// single, circular list.</span>
    <span class="s2">if </span><span class="s1">(concurrentQueues !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; concurrentQueues.length; i++) {</span>
        <span class="s2">var </span><span class="s1">queue = concurrentQueues[i];</span>
        <span class="s2">var </span><span class="s1">lastInterleavedUpdate = queue.interleaved;</span>

        <span class="s2">if </span><span class="s1">(lastInterleavedUpdate !== </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">queue.interleaved = </span><span class="s2">null</span><span class="s1">;</span>
          <span class="s2">var </span><span class="s1">firstInterleavedUpdate = lastInterleavedUpdate.next;</span>
          <span class="s2">var </span><span class="s1">lastPendingUpdate = queue.pending;</span>

          <span class="s2">if </span><span class="s1">(lastPendingUpdate !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">var </span><span class="s1">firstPendingUpdate = lastPendingUpdate.next;</span>
            <span class="s1">lastPendingUpdate.next = firstInterleavedUpdate;</span>
            <span class="s1">lastInterleavedUpdate.next = firstPendingUpdate;</span>
          <span class="s1">}</span>

          <span class="s1">queue.pending = lastInterleavedUpdate;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">concurrentQueues = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">enqueueConcurrentHookUpdate(fiber, queue, update, lane) {</span>
    <span class="s2">var </span><span class="s1">interleaved = queue.interleaved;</span>

    <span class="s2">if </span><span class="s1">(interleaved === </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s0">// This is the first update. Create a circular list.</span>
      <span class="s1">update.next = update; </span><span class="s0">// At the end of the current render, this queue's interleaved updates will</span>
      <span class="s0">// be transferred to the pending queue.</span>

      <span class="s1">pushConcurrentUpdateQueue(queue);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">update.next = interleaved.next;</span>
      <span class="s1">interleaved.next = update;</span>
    <span class="s1">}</span>

    <span class="s1">queue.interleaved = update;</span>
    <span class="s2">return </span><span class="s1">markUpdateLaneFromFiberToRoot(fiber, lane);</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update, lane) {</span>
    <span class="s2">var </span><span class="s1">interleaved = queue.interleaved;</span>

    <span class="s2">if </span><span class="s1">(interleaved === </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s0">// This is the first update. Create a circular list.</span>
      <span class="s1">update.next = update; </span><span class="s0">// At the end of the current render, this queue's interleaved updates will</span>
      <span class="s0">// be transferred to the pending queue.</span>

      <span class="s1">pushConcurrentUpdateQueue(queue);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">update.next = interleaved.next;</span>
      <span class="s1">interleaved.next = update;</span>
    <span class="s1">}</span>

    <span class="s1">queue.interleaved = update;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">enqueueConcurrentClassUpdate(fiber, queue, update, lane) {</span>
    <span class="s2">var </span><span class="s1">interleaved = queue.interleaved;</span>

    <span class="s2">if </span><span class="s1">(interleaved === </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s0">// This is the first update. Create a circular list.</span>
      <span class="s1">update.next = update; </span><span class="s0">// At the end of the current render, this queue's interleaved updates will</span>
      <span class="s0">// be transferred to the pending queue.</span>

      <span class="s1">pushConcurrentUpdateQueue(queue);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">update.next = interleaved.next;</span>
      <span class="s1">interleaved.next = update;</span>
    <span class="s1">}</span>

    <span class="s1">queue.interleaved = update;</span>
    <span class="s2">return </span><span class="s1">markUpdateLaneFromFiberToRoot(fiber, lane);</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">enqueueConcurrentRenderForLane(fiber, lane) {</span>
    <span class="s2">return </span><span class="s1">markUpdateLaneFromFiberToRoot(fiber, lane);</span>
  <span class="s1">} </span><span class="s0">// Calling this function outside this module should only be done for backwards</span>
  <span class="s0">// compatibility and should always be accompanied by a warning.</span>

  <span class="s2">var </span><span class="s1">unsafe_markUpdateLaneFromFiberToRoot = markUpdateLaneFromFiberToRoot;</span>

  <span class="s2">function </span><span class="s1">markUpdateLaneFromFiberToRoot(sourceFiber, lane) {</span>
    <span class="s0">// Update the source fiber's lanes</span>
    <span class="s1">sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);</span>
    <span class="s2">var </span><span class="s1">alternate = sourceFiber.alternate;</span>

    <span class="s2">if </span><span class="s1">(alternate !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">alternate.lanes = mergeLanes(alternate.lanes, lane);</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(alternate === </span><span class="s2">null </span><span class="s1">&amp;&amp; (sourceFiber.flags &amp; (Placement | Hydrating)) !== NoFlags) {</span>
        <span class="s1">warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// Walk the parent path to the root and update the child lanes.</span>


    <span class="s2">var </span><span class="s1">node = sourceFiber;</span>
    <span class="s2">var </span><span class="s1">parent = sourceFiber.</span><span class="s2">return</span><span class="s1">;</span>

    <span class="s2">while </span><span class="s1">(parent !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">parent.childLanes = mergeLanes(parent.childLanes, lane);</span>
      <span class="s1">alternate = parent.alternate;</span>

      <span class="s2">if </span><span class="s1">(alternate !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">alternate.childLanes = mergeLanes(alternate.childLanes, lane);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">{</span>
          <span class="s2">if </span><span class="s1">((parent.flags &amp; (Placement | Hydrating)) !== NoFlags) {</span>
            <span class="s1">warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">node = parent;</span>
      <span class="s1">parent = parent.</span><span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(node.tag === HostRoot) {</span>
      <span class="s2">var </span><span class="s1">root = node.stateNode;</span>
      <span class="s2">return </span><span class="s1">root;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">UpdateState = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">ReplaceState = </span><span class="s4">1</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">ForceUpdate = </span><span class="s4">2</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">CaptureUpdate = </span><span class="s4">3</span><span class="s1">; </span><span class="s0">// Global state that is reset at the beginning of calling `processUpdateQueue`.</span>
  <span class="s0">// It should only be read right after calling `processUpdateQueue`, via</span>
  <span class="s0">// `checkHasForceUpdateAfterProcessing`.</span>

  <span class="s2">var </span><span class="s1">hasForceUpdate = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">didWarnUpdateInsideUpdate;</span>
  <span class="s2">var </span><span class="s1">currentlyProcessingQueue;</span>

  <span class="s1">{</span>
    <span class="s1">didWarnUpdateInsideUpdate = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">currentlyProcessingQueue = </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">initializeUpdateQueue(fiber) {</span>
    <span class="s2">var </span><span class="s1">queue = {</span>
      <span class="s1">baseState: fiber.memoizedState,</span>
      <span class="s1">firstBaseUpdate: </span><span class="s2">null</span><span class="s1">,</span>
      <span class="s1">lastBaseUpdate: </span><span class="s2">null</span><span class="s1">,</span>
      <span class="s1">shared: {</span>
        <span class="s1">pending: </span><span class="s2">null</span><span class="s1">,</span>
        <span class="s1">interleaved: </span><span class="s2">null</span><span class="s1">,</span>
        <span class="s1">lanes: NoLanes</span>
      <span class="s1">},</span>
      <span class="s1">effects: </span><span class="s2">null</span>
    <span class="s1">};</span>
    <span class="s1">fiber.updateQueue = queue;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">cloneUpdateQueue(current, workInProgress) {</span>
    <span class="s0">// Clone the update queue from current. Unless it's already a clone.</span>
    <span class="s2">var </span><span class="s1">queue = workInProgress.updateQueue;</span>
    <span class="s2">var </span><span class="s1">currentQueue = current.updateQueue;</span>

    <span class="s2">if </span><span class="s1">(queue === currentQueue) {</span>
      <span class="s2">var </span><span class="s1">clone = {</span>
        <span class="s1">baseState: currentQueue.baseState,</span>
        <span class="s1">firstBaseUpdate: currentQueue.firstBaseUpdate,</span>
        <span class="s1">lastBaseUpdate: currentQueue.lastBaseUpdate,</span>
        <span class="s1">shared: currentQueue.shared,</span>
        <span class="s1">effects: currentQueue.effects</span>
      <span class="s1">};</span>
      <span class="s1">workInProgress.updateQueue = clone;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">createUpdate(eventTime, lane) {</span>
    <span class="s2">var </span><span class="s1">update = {</span>
      <span class="s1">eventTime: eventTime,</span>
      <span class="s1">lane: lane,</span>
      <span class="s1">tag: UpdateState,</span>
      <span class="s1">payload: </span><span class="s2">null</span><span class="s1">,</span>
      <span class="s1">callback: </span><span class="s2">null</span><span class="s1">,</span>
      <span class="s1">next: </span><span class="s2">null</span>
    <span class="s1">};</span>
    <span class="s2">return </span><span class="s1">update;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">enqueueUpdate(fiber, update, lane) {</span>
    <span class="s2">var </span><span class="s1">updateQueue = fiber.updateQueue;</span>

    <span class="s2">if </span><span class="s1">(updateQueue === </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s0">// Only occurs if the fiber has been unmounted.</span>
      <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">sharedQueue = updateQueue.shared;</span>

    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(currentlyProcessingQueue === sharedQueue &amp;&amp; !didWarnUpdateInsideUpdate) {</span>
        <span class="s1">error(</span><span class="s3">'An update (setState, replaceState, or forceUpdate) was scheduled ' </span><span class="s1">+ </span><span class="s3">'from inside an update function. Update functions should be pure, ' </span><span class="s1">+ </span><span class="s3">'with zero side-effects. Consider using componentDidUpdate or a ' </span><span class="s1">+ </span><span class="s3">'callback.'</span><span class="s1">);</span>

        <span class="s1">didWarnUpdateInsideUpdate = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(isUnsafeClassRenderPhaseUpdate()) {</span>
      <span class="s0">// This is an unsafe render phase update. Add directly to the update</span>
      <span class="s0">// queue so we can process it immediately during the current render.</span>
      <span class="s2">var </span><span class="s1">pending = sharedQueue.pending;</span>

      <span class="s2">if </span><span class="s1">(pending === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s0">// This is the first update. Create a circular list.</span>
        <span class="s1">update.next = update;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">update.next = pending.next;</span>
        <span class="s1">pending.next = update;</span>
      <span class="s1">}</span>

      <span class="s1">sharedQueue.pending = update; </span><span class="s0">// Update the childLanes even though we're most likely already rendering</span>
      <span class="s0">// this fiber. This is for backwards compatibility in the case where you</span>
      <span class="s0">// update a different component during render phase than the one that is</span>
      <span class="s0">// currently renderings (a pattern that is accompanied by a warning).</span>

      <span class="s2">return </span><span class="s1">unsafe_markUpdateLaneFromFiberToRoot(fiber, lane);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">return </span><span class="s1">enqueueConcurrentClassUpdate(fiber, sharedQueue, update, lane);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">entangleTransitions(root, fiber, lane) {</span>
    <span class="s2">var </span><span class="s1">updateQueue = fiber.updateQueue;</span>

    <span class="s2">if </span><span class="s1">(updateQueue === </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s0">// Only occurs if the fiber has been unmounted.</span>
      <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">sharedQueue = updateQueue.shared;</span>

    <span class="s2">if </span><span class="s1">(isTransitionLane(lane)) {</span>
      <span class="s2">var </span><span class="s1">queueLanes = sharedQueue.lanes; </span><span class="s0">// If any entangled lanes are no longer pending on the root, then they must</span>
      <span class="s0">// have finished. We can remove them from the shared queue, which represents</span>
      <span class="s0">// a superset of the actually pending lanes. In some cases we may entangle</span>
      <span class="s0">// more than we need to, but that's OK. In fact it's worse if we *don't*</span>
      <span class="s0">// entangle when we should.</span>

      <span class="s1">queueLanes = intersectLanes(queueLanes, root.pendingLanes); </span><span class="s0">// Entangle the new transition lane with the other transition lanes.</span>

      <span class="s2">var </span><span class="s1">newQueueLanes = mergeLanes(queueLanes, lane);</span>
      <span class="s1">sharedQueue.lanes = newQueueLanes; </span><span class="s0">// Even if queue.lanes already include lane, we don't know for certain if</span>
      <span class="s0">// the lane finished since the last time we entangled it. So we need to</span>
      <span class="s0">// entangle it again, just to be sure.</span>

      <span class="s1">markRootEntangled(root, newQueueLanes);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">enqueueCapturedUpdate(workInProgress, capturedUpdate) {</span>
    <span class="s0">// Captured updates are updates that are thrown by a child during the render</span>
    <span class="s0">// phase. They should be discarded if the render is aborted. Therefore,</span>
    <span class="s0">// we should only put them on the work-in-progress queue, not the current one.</span>
    <span class="s2">var </span><span class="s1">queue = workInProgress.updateQueue; </span><span class="s0">// Check if the work-in-progress queue is a clone.</span>

    <span class="s2">var </span><span class="s1">current = workInProgress.alternate;</span>

    <span class="s2">if </span><span class="s1">(current !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">currentQueue = current.updateQueue;</span>

      <span class="s2">if </span><span class="s1">(queue === currentQueue) {</span>
        <span class="s0">// The work-in-progress queue is the same as current. This happens when</span>
        <span class="s0">// we bail out on a parent fiber that then captures an error thrown by</span>
        <span class="s0">// a child. Since we want to append the update only to the work-in</span>
        <span class="s0">// -progress queue, we need to clone the updates. We usually clone during</span>
        <span class="s0">// processUpdateQueue, but that didn't happen in this case because we</span>
        <span class="s0">// skipped over the parent when we bailed out.</span>
        <span class="s2">var </span><span class="s1">newFirst = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s2">var </span><span class="s1">newLast = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s2">var </span><span class="s1">firstBaseUpdate = queue.firstBaseUpdate;</span>

        <span class="s2">if </span><span class="s1">(firstBaseUpdate !== </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s0">// Loop through the updates and clone them.</span>
          <span class="s2">var </span><span class="s1">update = firstBaseUpdate;</span>

          <span class="s2">do </span><span class="s1">{</span>
            <span class="s2">var </span><span class="s1">clone = {</span>
              <span class="s1">eventTime: update.eventTime,</span>
              <span class="s1">lane: update.lane,</span>
              <span class="s1">tag: update.tag,</span>
              <span class="s1">payload: update.payload,</span>
              <span class="s1">callback: update.callback,</span>
              <span class="s1">next: </span><span class="s2">null</span>
            <span class="s1">};</span>

            <span class="s2">if </span><span class="s1">(newLast === </span><span class="s2">null</span><span class="s1">) {</span>
              <span class="s1">newFirst = newLast = clone;</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
              <span class="s1">newLast.next = clone;</span>
              <span class="s1">newLast = clone;</span>
            <span class="s1">}</span>

            <span class="s1">update = update.next;</span>
          <span class="s1">} </span><span class="s2">while </span><span class="s1">(update !== </span><span class="s2">null</span><span class="s1">); </span><span class="s0">// Append the captured update the end of the cloned list.</span>


          <span class="s2">if </span><span class="s1">(newLast === </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">newFirst = newLast = capturedUpdate;</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">newLast.next = capturedUpdate;</span>
            <span class="s1">newLast = capturedUpdate;</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s0">// There are no base updates.</span>
          <span class="s1">newFirst = newLast = capturedUpdate;</span>
        <span class="s1">}</span>

        <span class="s1">queue = {</span>
          <span class="s1">baseState: currentQueue.baseState,</span>
          <span class="s1">firstBaseUpdate: newFirst,</span>
          <span class="s1">lastBaseUpdate: newLast,</span>
          <span class="s1">shared: currentQueue.shared,</span>
          <span class="s1">effects: currentQueue.effects</span>
        <span class="s1">};</span>
        <span class="s1">workInProgress.updateQueue = queue;</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// Append the update to the end of the list.</span>


    <span class="s2">var </span><span class="s1">lastBaseUpdate = queue.lastBaseUpdate;</span>

    <span class="s2">if </span><span class="s1">(lastBaseUpdate === </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">queue.firstBaseUpdate = capturedUpdate;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">lastBaseUpdate.next = capturedUpdate;</span>
    <span class="s1">}</span>

    <span class="s1">queue.lastBaseUpdate = capturedUpdate;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">getStateFromUpdate(workInProgress, queue, update, prevState, nextProps, instance) {</span>
    <span class="s2">switch </span><span class="s1">(update.tag) {</span>
      <span class="s2">case </span><span class="s1">ReplaceState:</span>
        <span class="s1">{</span>
          <span class="s2">var </span><span class="s1">payload = update.payload;</span>

          <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">payload === </span><span class="s3">'function'</span><span class="s1">) {</span>
            <span class="s0">// Updater function</span>
            <span class="s1">{</span>
              <span class="s1">enterDisallowedContextReadInDEV();</span>
            <span class="s1">}</span>

            <span class="s2">var </span><span class="s1">nextState = payload.call(instance, prevState, nextProps);</span>

            <span class="s1">{</span>

              <span class="s1">exitDisallowedContextReadInDEV();</span>
            <span class="s1">}</span>

            <span class="s2">return </span><span class="s1">nextState;</span>
          <span class="s1">} </span><span class="s0">// State object</span>


          <span class="s2">return </span><span class="s1">payload;</span>
        <span class="s1">}</span>

      <span class="s2">case </span><span class="s1">CaptureUpdate:</span>
        <span class="s1">{</span>
          <span class="s1">workInProgress.flags = workInProgress.flags &amp; ~ShouldCapture | DidCapture;</span>
        <span class="s1">}</span>
      <span class="s0">// Intentional fallthrough</span>

      <span class="s2">case </span><span class="s1">UpdateState:</span>
        <span class="s1">{</span>
          <span class="s2">var </span><span class="s1">_payload = update.payload;</span>
          <span class="s2">var </span><span class="s1">partialState;</span>

          <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">_payload === </span><span class="s3">'function'</span><span class="s1">) {</span>
            <span class="s0">// Updater function</span>
            <span class="s1">{</span>
              <span class="s1">enterDisallowedContextReadInDEV();</span>
            <span class="s1">}</span>

            <span class="s1">partialState = _payload.call(instance, prevState, nextProps);</span>

            <span class="s1">{</span>

              <span class="s1">exitDisallowedContextReadInDEV();</span>
            <span class="s1">}</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s0">// Partial state object</span>
            <span class="s1">partialState = _payload;</span>
          <span class="s1">}</span>

          <span class="s2">if </span><span class="s1">(partialState === </span><span class="s2">null </span><span class="s1">|| partialState === undefined) {</span>
            <span class="s0">// Null and undefined are treated as no-ops.</span>
            <span class="s2">return </span><span class="s1">prevState;</span>
          <span class="s1">} </span><span class="s0">// Merge the partial state and the previous state.</span>


          <span class="s2">return </span><span class="s1">assign({}, prevState, partialState);</span>
        <span class="s1">}</span>

      <span class="s2">case </span><span class="s1">ForceUpdate:</span>
        <span class="s1">{</span>
          <span class="s1">hasForceUpdate = </span><span class="s2">true</span><span class="s1">;</span>
          <span class="s2">return </span><span class="s1">prevState;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">prevState;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">processUpdateQueue(workInProgress, props, instance, renderLanes) {</span>
    <span class="s0">// This is always non-null on a ClassComponent or HostRoot</span>
    <span class="s2">var </span><span class="s1">queue = workInProgress.updateQueue;</span>
    <span class="s1">hasForceUpdate = </span><span class="s2">false</span><span class="s1">;</span>

    <span class="s1">{</span>
      <span class="s1">currentlyProcessingQueue = queue.shared;</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">firstBaseUpdate = queue.firstBaseUpdate;</span>
    <span class="s2">var </span><span class="s1">lastBaseUpdate = queue.lastBaseUpdate; </span><span class="s0">// Check if there are pending updates. If so, transfer them to the base queue.</span>

    <span class="s2">var </span><span class="s1">pendingQueue = queue.shared.pending;</span>

    <span class="s2">if </span><span class="s1">(pendingQueue !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">queue.shared.pending = </span><span class="s2">null</span><span class="s1">; </span><span class="s0">// The pending queue is circular. Disconnect the pointer between first</span>
      <span class="s0">// and last so that it's non-circular.</span>

      <span class="s2">var </span><span class="s1">lastPendingUpdate = pendingQueue;</span>
      <span class="s2">var </span><span class="s1">firstPendingUpdate = lastPendingUpdate.next;</span>
      <span class="s1">lastPendingUpdate.next = </span><span class="s2">null</span><span class="s1">; </span><span class="s0">// Append pending updates to base queue</span>

      <span class="s2">if </span><span class="s1">(lastBaseUpdate === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">firstBaseUpdate = firstPendingUpdate;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">lastBaseUpdate.next = firstPendingUpdate;</span>
      <span class="s1">}</span>

      <span class="s1">lastBaseUpdate = lastPendingUpdate; </span><span class="s0">// If there's a current queue, and it's different from the base queue, then</span>
      <span class="s0">// we need to transfer the updates to that queue, too. Because the base</span>
      <span class="s0">// queue is a singly-linked list with no cycles, we can append to both</span>
      <span class="s0">// lists and take advantage of structural sharing.</span>
      <span class="s0">// TODO: Pass `current` as argument</span>

      <span class="s2">var </span><span class="s1">current = workInProgress.alternate;</span>

      <span class="s2">if </span><span class="s1">(current !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s0">// This is always non-null on a ClassComponent or HostRoot</span>
        <span class="s2">var </span><span class="s1">currentQueue = current.updateQueue;</span>
        <span class="s2">var </span><span class="s1">currentLastBaseUpdate = currentQueue.lastBaseUpdate;</span>

        <span class="s2">if </span><span class="s1">(currentLastBaseUpdate !== lastBaseUpdate) {</span>
          <span class="s2">if </span><span class="s1">(currentLastBaseUpdate === </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">currentQueue.firstBaseUpdate = firstPendingUpdate;</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">currentLastBaseUpdate.next = firstPendingUpdate;</span>
          <span class="s1">}</span>

          <span class="s1">currentQueue.lastBaseUpdate = lastPendingUpdate;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// These values may change as we process the queue.</span>


    <span class="s2">if </span><span class="s1">(firstBaseUpdate !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s0">// Iterate through the list of updates to compute the result.</span>
      <span class="s2">var </span><span class="s1">newState = queue.baseState; </span><span class="s0">// TODO: Don't need to accumulate this. Instead, we can remove renderLanes</span>
      <span class="s0">// from the original lanes.</span>

      <span class="s2">var </span><span class="s1">newLanes = NoLanes;</span>
      <span class="s2">var </span><span class="s1">newBaseState = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s2">var </span><span class="s1">newFirstBaseUpdate = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s2">var </span><span class="s1">newLastBaseUpdate = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s2">var </span><span class="s1">update = firstBaseUpdate;</span>

      <span class="s2">do </span><span class="s1">{</span>
        <span class="s2">var </span><span class="s1">updateLane = update.lane;</span>
        <span class="s2">var </span><span class="s1">updateEventTime = update.eventTime;</span>

        <span class="s2">if </span><span class="s1">(!isSubsetOfLanes(renderLanes, updateLane)) {</span>
          <span class="s0">// Priority is insufficient. Skip this update. If this is the first</span>
          <span class="s0">// skipped update, the previous update/state is the new base</span>
          <span class="s0">// update/state.</span>
          <span class="s2">var </span><span class="s1">clone = {</span>
            <span class="s1">eventTime: updateEventTime,</span>
            <span class="s1">lane: updateLane,</span>
            <span class="s1">tag: update.tag,</span>
            <span class="s1">payload: update.payload,</span>
            <span class="s1">callback: update.callback,</span>
            <span class="s1">next: </span><span class="s2">null</span>
          <span class="s1">};</span>

          <span class="s2">if </span><span class="s1">(newLastBaseUpdate === </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">newFirstBaseUpdate = newLastBaseUpdate = clone;</span>
            <span class="s1">newBaseState = newState;</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">newLastBaseUpdate = newLastBaseUpdate.next = clone;</span>
          <span class="s1">} </span><span class="s0">// Update the remaining priority in the queue.</span>


          <span class="s1">newLanes = mergeLanes(newLanes, updateLane);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s0">// This update does have sufficient priority.</span>
          <span class="s2">if </span><span class="s1">(newLastBaseUpdate !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">var </span><span class="s1">_clone = {</span>
              <span class="s1">eventTime: updateEventTime,</span>
              <span class="s0">// This update is going to be committed so we never want uncommit</span>
              <span class="s0">// it. Using NoLane works because 0 is a subset of all bitmasks, so</span>
              <span class="s0">// this will never be skipped by the check above.</span>
              <span class="s1">lane: NoLane,</span>
              <span class="s1">tag: update.tag,</span>
              <span class="s1">payload: update.payload,</span>
              <span class="s1">callback: update.callback,</span>
              <span class="s1">next: </span><span class="s2">null</span>
            <span class="s1">};</span>
            <span class="s1">newLastBaseUpdate = newLastBaseUpdate.next = _clone;</span>
          <span class="s1">} </span><span class="s0">// Process this update.</span>


          <span class="s1">newState = getStateFromUpdate(workInProgress, queue, update, newState, props, instance);</span>
          <span class="s2">var </span><span class="s1">callback = update.callback;</span>

          <span class="s2">if </span><span class="s1">(callback !== </span><span class="s2">null </span><span class="s1">&amp;&amp; </span><span class="s0">// If the update was already committed, we should not queue its</span>
          <span class="s0">// callback again.</span>
          <span class="s1">update.lane !== NoLane) {</span>
            <span class="s1">workInProgress.flags |= Callback;</span>
            <span class="s2">var </span><span class="s1">effects = queue.effects;</span>

            <span class="s2">if </span><span class="s1">(effects === </span><span class="s2">null</span><span class="s1">) {</span>
              <span class="s1">queue.effects = [update];</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
              <span class="s1">effects.push(update);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s1">update = update.next;</span>

        <span class="s2">if </span><span class="s1">(update === </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">pendingQueue = queue.shared.pending;</span>

          <span class="s2">if </span><span class="s1">(pendingQueue === </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">break</span><span class="s1">;</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s0">// An update was scheduled from inside a reducer. Add the new</span>
            <span class="s0">// pending updates to the end of the list and keep processing.</span>
            <span class="s2">var </span><span class="s1">_lastPendingUpdate = pendingQueue; </span><span class="s0">// Intentionally unsound. Pending updates form a circular list, but we</span>
            <span class="s0">// unravel them when transferring them to the base queue.</span>

            <span class="s2">var </span><span class="s1">_firstPendingUpdate = _lastPendingUpdate.next;</span>
            <span class="s1">_lastPendingUpdate.next = </span><span class="s2">null</span><span class="s1">;</span>
            <span class="s1">update = _firstPendingUpdate;</span>
            <span class="s1">queue.lastBaseUpdate = _lastPendingUpdate;</span>
            <span class="s1">queue.shared.pending = </span><span class="s2">null</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">while </span><span class="s1">(</span><span class="s2">true</span><span class="s1">);</span>

      <span class="s2">if </span><span class="s1">(newLastBaseUpdate === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">newBaseState = newState;</span>
      <span class="s1">}</span>

      <span class="s1">queue.baseState = newBaseState;</span>
      <span class="s1">queue.firstBaseUpdate = newFirstBaseUpdate;</span>
      <span class="s1">queue.lastBaseUpdate = newLastBaseUpdate; </span><span class="s0">// Interleaved updates are stored on a separate queue. We aren't going to</span>
      <span class="s0">// process them during this render, but we do need to track which lanes</span>
      <span class="s0">// are remaining.</span>

      <span class="s2">var </span><span class="s1">lastInterleaved = queue.shared.interleaved;</span>

      <span class="s2">if </span><span class="s1">(lastInterleaved !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">var </span><span class="s1">interleaved = lastInterleaved;</span>

        <span class="s2">do </span><span class="s1">{</span>
          <span class="s1">newLanes = mergeLanes(newLanes, interleaved.lane);</span>
          <span class="s1">interleaved = interleaved.next;</span>
        <span class="s1">} </span><span class="s2">while </span><span class="s1">(interleaved !== lastInterleaved);</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(firstBaseUpdate === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s0">// `queue.lanes` is used for entangling transitions. We can set it back to</span>
        <span class="s0">// zero once the queue is empty.</span>
        <span class="s1">queue.shared.lanes = NoLanes;</span>
      <span class="s1">} </span><span class="s0">// Set the remaining expiration time to be whatever is remaining in the queue.</span>
      <span class="s0">// This should be fine because the only two other things that contribute to</span>
      <span class="s0">// expiration time are props and context. We're already in the middle of the</span>
      <span class="s0">// begin phase by the time we start processing the queue, so we've already</span>
      <span class="s0">// dealt with the props. Context in components that specify</span>
      <span class="s0">// shouldComponentUpdate is tricky; but we'll have to account for</span>
      <span class="s0">// that regardless.</span>


      <span class="s1">markSkippedUpdateLanes(newLanes);</span>
      <span class="s1">workInProgress.lanes = newLanes;</span>
      <span class="s1">workInProgress.memoizedState = newState;</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s1">currentlyProcessingQueue = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">callCallback(callback, context) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">callback !== </span><span class="s3">'function'</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Invalid argument passed as callback. Expected a function. Instead ' </span><span class="s1">+ (</span><span class="s3">&quot;received: &quot; </span><span class="s1">+ callback));</span>
    <span class="s1">}</span>

    <span class="s1">callback.call(context);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">resetHasForceUpdateBeforeProcessing() {</span>
    <span class="s1">hasForceUpdate = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">checkHasForceUpdateAfterProcessing() {</span>
    <span class="s2">return </span><span class="s1">hasForceUpdate;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">commitUpdateQueue(finishedWork, finishedQueue, instance) {</span>
    <span class="s0">// Commit the effects</span>
    <span class="s2">var </span><span class="s1">effects = finishedQueue.effects;</span>
    <span class="s1">finishedQueue.effects = </span><span class="s2">null</span><span class="s1">;</span>

    <span class="s2">if </span><span class="s1">(effects !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; effects.length; i++) {</span>
        <span class="s2">var </span><span class="s1">effect = effects[i];</span>
        <span class="s2">var </span><span class="s1">callback = effect.callback;</span>

        <span class="s2">if </span><span class="s1">(callback !== </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">effect.callback = </span><span class="s2">null</span><span class="s1">;</span>
          <span class="s1">callCallback(callback, instance);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">fakeInternalInstance = {}; </span><span class="s0">// React.Component uses a shared frozen object by default.</span>
  <span class="s0">// We'll use it to determine whether we need to initialize legacy refs.</span>

  <span class="s2">var </span><span class="s1">emptyRefsObject = </span><span class="s2">new </span><span class="s1">React.Component().refs;</span>
  <span class="s2">var </span><span class="s1">didWarnAboutStateAssignmentForComponent;</span>
  <span class="s2">var </span><span class="s1">didWarnAboutUninitializedState;</span>
  <span class="s2">var </span><span class="s1">didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;</span>
  <span class="s2">var </span><span class="s1">didWarnAboutLegacyLifecyclesAndDerivedState;</span>
  <span class="s2">var </span><span class="s1">didWarnAboutUndefinedDerivedState;</span>
  <span class="s2">var </span><span class="s1">warnOnUndefinedDerivedState;</span>
  <span class="s2">var </span><span class="s1">warnOnInvalidCallback;</span>
  <span class="s2">var </span><span class="s1">didWarnAboutDirectlyAssigningPropsToState;</span>
  <span class="s2">var </span><span class="s1">didWarnAboutContextTypeAndContextTypes;</span>
  <span class="s2">var </span><span class="s1">didWarnAboutInvalidateContextType;</span>

  <span class="s1">{</span>
    <span class="s1">didWarnAboutStateAssignmentForComponent = </span><span class="s2">new </span><span class="s1">Set();</span>
    <span class="s1">didWarnAboutUninitializedState = </span><span class="s2">new </span><span class="s1">Set();</span>
    <span class="s1">didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = </span><span class="s2">new </span><span class="s1">Set();</span>
    <span class="s1">didWarnAboutLegacyLifecyclesAndDerivedState = </span><span class="s2">new </span><span class="s1">Set();</span>
    <span class="s1">didWarnAboutDirectlyAssigningPropsToState = </span><span class="s2">new </span><span class="s1">Set();</span>
    <span class="s1">didWarnAboutUndefinedDerivedState = </span><span class="s2">new </span><span class="s1">Set();</span>
    <span class="s1">didWarnAboutContextTypeAndContextTypes = </span><span class="s2">new </span><span class="s1">Set();</span>
    <span class="s1">didWarnAboutInvalidateContextType = </span><span class="s2">new </span><span class="s1">Set();</span>
    <span class="s2">var </span><span class="s1">didWarnOnInvalidCallback = </span><span class="s2">new </span><span class="s1">Set();</span>

    <span class="s1">warnOnInvalidCallback = </span><span class="s2">function </span><span class="s1">(callback, callerName) {</span>
      <span class="s2">if </span><span class="s1">(callback === </span><span class="s2">null </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">callback === </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">key = callerName + </span><span class="s3">'_' </span><span class="s1">+ callback;</span>

      <span class="s2">if </span><span class="s1">(!didWarnOnInvalidCallback.has(key)) {</span>
        <span class="s1">didWarnOnInvalidCallback.add(key);</span>

        <span class="s1">error(</span><span class="s3">'%s(...): Expected the last optional `callback` argument to be a ' </span><span class="s1">+ </span><span class="s3">'function. Instead received: %s.'</span><span class="s1">, callerName, callback);</span>
      <span class="s1">}</span>
    <span class="s1">};</span>

    <span class="s1">warnOnUndefinedDerivedState = </span><span class="s2">function </span><span class="s1">(type, partialState) {</span>
      <span class="s2">if </span><span class="s1">(partialState === undefined) {</span>
        <span class="s2">var </span><span class="s1">componentName = getComponentNameFromType(type) || </span><span class="s3">'Component'</span><span class="s1">;</span>

        <span class="s2">if </span><span class="s1">(!didWarnAboutUndefinedDerivedState.has(componentName)) {</span>
          <span class="s1">didWarnAboutUndefinedDerivedState.add(componentName);</span>

          <span class="s1">error(</span><span class="s3">'%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. ' </span><span class="s1">+ </span><span class="s3">'You have returned undefined.'</span><span class="s1">, componentName);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}; </span><span class="s0">// This is so gross but it's at least non-critical and can be removed if</span>
    <span class="s0">// it causes problems. This is meant to give a nicer error message for</span>
    <span class="s0">// ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,</span>
    <span class="s0">// ...)) which otherwise throws a &quot;_processChildContext is not a function&quot;</span>
    <span class="s0">// exception.</span>


    <span class="s1">Object.defineProperty(fakeInternalInstance, </span><span class="s3">'_processChildContext'</span><span class="s1">, {</span>
      <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
      <span class="s1">value: </span><span class="s2">function </span><span class="s1">() {</span>
        <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'_processChildContext is not available in React 16+. This likely ' </span><span class="s1">+ </span><span class="s3">'means you have multiple copies of React and are attempting to nest ' </span><span class="s1">+ </span><span class="s3">'a React 15 tree inside a React 16 tree using ' </span><span class="s1">+ </span><span class="s3">&quot;unstable_renderSubtreeIntoContainer, which isn't supported. Try &quot; </span><span class="s1">+ </span><span class="s3">'to make sure you have only one copy of React (and ideally, switch ' </span><span class="s1">+ </span><span class="s3">'to ReactDOM.createPortal).'</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s1">Object.freeze(fakeInternalInstance);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {</span>
    <span class="s2">var </span><span class="s1">prevState = workInProgress.memoizedState;</span>
    <span class="s2">var </span><span class="s1">partialState = getDerivedStateFromProps(nextProps, prevState);</span>

    <span class="s1">{</span>

      <span class="s1">warnOnUndefinedDerivedState(ctor, partialState);</span>
    <span class="s1">} </span><span class="s0">// Merge the partial state and the previous state.</span>


    <span class="s2">var </span><span class="s1">memoizedState = partialState === </span><span class="s2">null </span><span class="s1">|| partialState === undefined ? prevState : assign({}, prevState, partialState);</span>
    <span class="s1">workInProgress.memoizedState = memoizedState; </span><span class="s0">// Once the update queue is empty, persist the derived state onto the</span>
    <span class="s0">// base state.</span>

    <span class="s2">if </span><span class="s1">(workInProgress.lanes === NoLanes) {</span>
      <span class="s0">// Queue is always non-null for classes</span>
      <span class="s2">var </span><span class="s1">updateQueue = workInProgress.updateQueue;</span>
      <span class="s1">updateQueue.baseState = memoizedState;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">classComponentUpdater = {</span>
    <span class="s1">isMounted: isMounted,</span>
    <span class="s1">enqueueSetState: </span><span class="s2">function </span><span class="s1">(inst, payload, callback) {</span>
      <span class="s2">var </span><span class="s1">fiber = get(inst);</span>
      <span class="s2">var </span><span class="s1">eventTime = requestEventTime();</span>
      <span class="s2">var </span><span class="s1">lane = requestUpdateLane(fiber);</span>
      <span class="s2">var </span><span class="s1">update = createUpdate(eventTime, lane);</span>
      <span class="s1">update.payload = payload;</span>

      <span class="s2">if </span><span class="s1">(callback !== undefined &amp;&amp; callback !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">{</span>
          <span class="s1">warnOnInvalidCallback(callback, </span><span class="s3">'setState'</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s1">update.callback = callback;</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">root = enqueueUpdate(fiber, update, lane);</span>

      <span class="s2">if </span><span class="s1">(root !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">scheduleUpdateOnFiber(root, fiber, lane, eventTime);</span>
        <span class="s1">entangleTransitions(root, fiber, lane);</span>
      <span class="s1">}</span>
    <span class="s1">},</span>
    <span class="s1">enqueueReplaceState: </span><span class="s2">function </span><span class="s1">(inst, payload, callback) {</span>
      <span class="s2">var </span><span class="s1">fiber = get(inst);</span>
      <span class="s2">var </span><span class="s1">eventTime = requestEventTime();</span>
      <span class="s2">var </span><span class="s1">lane = requestUpdateLane(fiber);</span>
      <span class="s2">var </span><span class="s1">update = createUpdate(eventTime, lane);</span>
      <span class="s1">update.tag = ReplaceState;</span>
      <span class="s1">update.payload = payload;</span>

      <span class="s2">if </span><span class="s1">(callback !== undefined &amp;&amp; callback !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">{</span>
          <span class="s1">warnOnInvalidCallback(callback, </span><span class="s3">'replaceState'</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s1">update.callback = callback;</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">root = enqueueUpdate(fiber, update, lane);</span>

      <span class="s2">if </span><span class="s1">(root !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">scheduleUpdateOnFiber(root, fiber, lane, eventTime);</span>
        <span class="s1">entangleTransitions(root, fiber, lane);</span>
      <span class="s1">}</span>
    <span class="s1">},</span>
    <span class="s1">enqueueForceUpdate: </span><span class="s2">function </span><span class="s1">(inst, callback) {</span>
      <span class="s2">var </span><span class="s1">fiber = get(inst);</span>
      <span class="s2">var </span><span class="s1">eventTime = requestEventTime();</span>
      <span class="s2">var </span><span class="s1">lane = requestUpdateLane(fiber);</span>
      <span class="s2">var </span><span class="s1">update = createUpdate(eventTime, lane);</span>
      <span class="s1">update.tag = ForceUpdate;</span>

      <span class="s2">if </span><span class="s1">(callback !== undefined &amp;&amp; callback !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">{</span>
          <span class="s1">warnOnInvalidCallback(callback, </span><span class="s3">'forceUpdate'</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s1">update.callback = callback;</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">root = enqueueUpdate(fiber, update, lane);</span>

      <span class="s2">if </span><span class="s1">(root !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">scheduleUpdateOnFiber(root, fiber, lane, eventTime);</span>
        <span class="s1">entangleTransitions(root, fiber, lane);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s2">function </span><span class="s1">checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {</span>
    <span class="s2">var </span><span class="s1">instance = workInProgress.stateNode;</span>

    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">instance.shouldComponentUpdate === </span><span class="s3">'function'</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);</span>

      <span class="s1">{</span>

        <span class="s2">if </span><span class="s1">(shouldUpdate === undefined) {</span>
          <span class="s1">error(</span><span class="s3">'%s.shouldComponentUpdate(): Returned undefined instead of a ' </span><span class="s1">+ </span><span class="s3">'boolean value. Make sure to return true or false.'</span><span class="s1">, getComponentNameFromType(ctor) || </span><span class="s3">'Component'</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">return </span><span class="s1">shouldUpdate;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(ctor.prototype &amp;&amp; ctor.prototype.isPureReactComponent) {</span>
      <span class="s2">return </span><span class="s1">!shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);</span>
    <span class="s1">}</span>

    <span class="s2">return true</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">checkClassInstance(workInProgress, ctor, newProps) {</span>
    <span class="s2">var </span><span class="s1">instance = workInProgress.stateNode;</span>

    <span class="s1">{</span>
      <span class="s2">var </span><span class="s1">name = getComponentNameFromType(ctor) || </span><span class="s3">'Component'</span><span class="s1">;</span>
      <span class="s2">var </span><span class="s1">renderPresent = instance.render;</span>

      <span class="s2">if </span><span class="s1">(!renderPresent) {</span>
        <span class="s2">if </span><span class="s1">(ctor.prototype &amp;&amp; </span><span class="s2">typeof </span><span class="s1">ctor.prototype.render === </span><span class="s3">'function'</span><span class="s1">) {</span>
          <span class="s1">error(</span><span class="s3">'%s(...): No `render` method found on the returned component ' </span><span class="s1">+ </span><span class="s3">'instance: did you accidentally return an object from the constructor?'</span><span class="s1">, name);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">error(</span><span class="s3">'%s(...): No `render` method found on the returned component ' </span><span class="s1">+ </span><span class="s3">'instance: you may have forgotten to define `render`.'</span><span class="s1">, name);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(instance.getInitialState &amp;&amp; !instance.getInitialState.isReactClassApproved &amp;&amp; !instance.state) {</span>
        <span class="s1">error(</span><span class="s3">'getInitialState was defined on %s, a plain JavaScript class. ' </span><span class="s1">+ </span><span class="s3">'This is only supported for classes created using React.createClass. ' </span><span class="s1">+ </span><span class="s3">'Did you mean to define a state property instead?'</span><span class="s1">, name);</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(instance.getDefaultProps &amp;&amp; !instance.getDefaultProps.isReactClassApproved) {</span>
        <span class="s1">error(</span><span class="s3">'getDefaultProps was defined on %s, a plain JavaScript class. ' </span><span class="s1">+ </span><span class="s3">'This is only supported for classes created using React.createClass. ' </span><span class="s1">+ </span><span class="s3">'Use a static property to define defaultProps instead.'</span><span class="s1">, name);</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(instance.propTypes) {</span>
        <span class="s1">error(</span><span class="s3">'propTypes was defined as an instance property on %s. Use a static ' </span><span class="s1">+ </span><span class="s3">'property to define propTypes instead.'</span><span class="s1">, name);</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(instance.contextType) {</span>
        <span class="s1">error(</span><span class="s3">'contextType was defined as an instance property on %s. Use a static ' </span><span class="s1">+ </span><span class="s3">'property to define contextType instead.'</span><span class="s1">, name);</span>
      <span class="s1">}</span>

      <span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(instance.contextTypes) {</span>
          <span class="s1">error(</span><span class="s3">'contextTypes was defined as an instance property on %s. Use a static ' </span><span class="s1">+ </span><span class="s3">'property to define contextTypes instead.'</span><span class="s1">, name);</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(ctor.contextType &amp;&amp; ctor.contextTypes &amp;&amp; !didWarnAboutContextTypeAndContextTypes.has(ctor)) {</span>
          <span class="s1">didWarnAboutContextTypeAndContextTypes.add(ctor);</span>

          <span class="s1">error(</span><span class="s3">'%s declares both contextTypes and contextType static properties. ' </span><span class="s1">+ </span><span class="s3">'The legacy contextTypes property will be ignored.'</span><span class="s1">, name);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">instance.componentShouldUpdate === </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s3">'%s has a method called ' </span><span class="s1">+ </span><span class="s3">'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' </span><span class="s1">+ </span><span class="s3">'The name is phrased as a question because the function is ' </span><span class="s1">+ </span><span class="s3">'expected to return a value.'</span><span class="s1">, name);</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(ctor.prototype &amp;&amp; ctor.prototype.isPureReactComponent &amp;&amp; </span><span class="s2">typeof </span><span class="s1">instance.shouldComponentUpdate !== </span><span class="s3">'undefined'</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s3">'%s has a method called shouldComponentUpdate(). ' </span><span class="s1">+ </span><span class="s3">'shouldComponentUpdate should not be used when extending React.PureComponent. ' </span><span class="s1">+ </span><span class="s3">'Please extend React.Component if shouldComponentUpdate is used.'</span><span class="s1">, getComponentNameFromType(ctor) || </span><span class="s3">'A pure component'</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">instance.componentDidUnmount === </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s3">'%s has a method called ' </span><span class="s1">+ </span><span class="s3">'componentDidUnmount(). But there is no such lifecycle method. ' </span><span class="s1">+ </span><span class="s3">'Did you mean componentWillUnmount()?'</span><span class="s1">, name);</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">instance.componentDidReceiveProps === </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s3">'%s has a method called ' </span><span class="s1">+ </span><span class="s3">'componentDidReceiveProps(). But there is no such lifecycle method. ' </span><span class="s1">+ </span><span class="s3">'If you meant to update the state in response to changing props, ' </span><span class="s1">+ </span><span class="s3">'use componentWillReceiveProps(). If you meant to fetch data or ' </span><span class="s1">+ </span><span class="s3">'run side-effects or mutations after React has updated the UI, use componentDidUpdate().'</span><span class="s1">, name);</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">instance.componentWillRecieveProps === </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s3">'%s has a method called ' </span><span class="s1">+ </span><span class="s3">'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?'</span><span class="s1">, name);</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">instance.UNSAFE_componentWillRecieveProps === </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s3">'%s has a method called ' </span><span class="s1">+ </span><span class="s3">'UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?'</span><span class="s1">, name);</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">hasMutatedProps = instance.props !== newProps;</span>

      <span class="s2">if </span><span class="s1">(instance.props !== undefined &amp;&amp; hasMutatedProps) {</span>
        <span class="s1">error(</span><span class="s3">'%s(...): When calling super() in `%s`, make sure to pass ' </span><span class="s1">+ </span><span class="s3">&quot;up the same props that your component's constructor was passed.&quot;</span><span class="s1">, name, name);</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(instance.defaultProps) {</span>
        <span class="s1">error(</span><span class="s3">'Setting defaultProps as an instance property on %s is not supported and will be ignored.' </span><span class="s1">+ </span><span class="s3">' Instead, define defaultProps as a static property on %s.'</span><span class="s1">, name, name);</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">instance.getSnapshotBeforeUpdate === </span><span class="s3">'function' </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">instance.componentDidUpdate !== </span><span class="s3">'function' </span><span class="s1">&amp;&amp; !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {</span>
        <span class="s1">didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);</span>

        <span class="s1">error(</span><span class="s3">'%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). ' </span><span class="s1">+ </span><span class="s3">'This component defines getSnapshotBeforeUpdate() only.'</span><span class="s1">, getComponentNameFromType(ctor));</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">instance.getDerivedStateFromProps === </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s3">'%s: getDerivedStateFromProps() is defined as an instance method ' </span><span class="s1">+ </span><span class="s3">'and will be ignored. Instead, declare it as a static method.'</span><span class="s1">, name);</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">instance.getDerivedStateFromError === </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s3">'%s: getDerivedStateFromError() is defined as an instance method ' </span><span class="s1">+ </span><span class="s3">'and will be ignored. Instead, declare it as a static method.'</span><span class="s1">, name);</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">ctor.getSnapshotBeforeUpdate === </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s3">'%s: getSnapshotBeforeUpdate() is defined as a static method ' </span><span class="s1">+ </span><span class="s3">'and will be ignored. Instead, declare it as an instance method.'</span><span class="s1">, name);</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">_state = instance.state;</span>

      <span class="s2">if </span><span class="s1">(_state &amp;&amp; (</span><span class="s2">typeof </span><span class="s1">_state !== </span><span class="s3">'object' </span><span class="s1">|| isArray(_state))) {</span>
        <span class="s1">error(</span><span class="s3">'%s.state: must be set to an object or null'</span><span class="s1">, name);</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">instance.getChildContext === </span><span class="s3">'function' </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">ctor.childContextTypes !== </span><span class="s3">'object'</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s3">'%s.getChildContext(): childContextTypes must be defined in order to ' </span><span class="s1">+ </span><span class="s3">'use getChildContext().'</span><span class="s1">, name);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">adoptClassInstance(workInProgress, instance) {</span>
    <span class="s1">instance.updater = classComponentUpdater;</span>
    <span class="s1">workInProgress.stateNode = instance; </span><span class="s0">// The instance needs access to the fiber so that it can schedule updates</span>

    <span class="s1">set(instance, workInProgress);</span>

    <span class="s1">{</span>
      <span class="s1">instance._reactInternalInstance = fakeInternalInstance;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">constructClassInstance(workInProgress, ctor, props) {</span>
    <span class="s2">var </span><span class="s1">isLegacyContextConsumer = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s2">var </span><span class="s1">unmaskedContext = emptyContextObject;</span>
    <span class="s2">var </span><span class="s1">context = emptyContextObject;</span>
    <span class="s2">var </span><span class="s1">contextType = ctor.contextType;</span>

    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s3">'contextType' </span><span class="s2">in </span><span class="s1">ctor) {</span>
        <span class="s2">var </span><span class="s1">isValid = </span><span class="s0">// Allow null for conditional declaration</span>
        <span class="s1">contextType === </span><span class="s2">null </span><span class="s1">|| contextType !== undefined &amp;&amp; contextType.$$typeof === REACT_CONTEXT_TYPE &amp;&amp; contextType._context === undefined; </span><span class="s0">// Not a &lt;Context.Consumer&gt;</span>

        <span class="s2">if </span><span class="s1">(!isValid &amp;&amp; !didWarnAboutInvalidateContextType.has(ctor)) {</span>
          <span class="s1">didWarnAboutInvalidateContextType.add(ctor);</span>
          <span class="s2">var </span><span class="s1">addendum = </span><span class="s3">''</span><span class="s1">;</span>

          <span class="s2">if </span><span class="s1">(contextType === undefined) {</span>
            <span class="s1">addendum = </span><span class="s3">' However, it is set to undefined. ' </span><span class="s1">+ </span><span class="s3">'This can be caused by a typo or by mixing up named and default imports. ' </span><span class="s1">+ </span><span class="s3">'This can also happen due to a circular dependency, so ' </span><span class="s1">+ </span><span class="s3">'try moving the createContext() call to a separate file.'</span><span class="s1">;</span>
          <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">contextType !== </span><span class="s3">'object'</span><span class="s1">) {</span>
            <span class="s1">addendum = </span><span class="s3">' However, it is set to a ' </span><span class="s1">+ </span><span class="s2">typeof </span><span class="s1">contextType + </span><span class="s3">'.'</span><span class="s1">;</span>
          <span class="s1">} </span><span class="s2">else if </span><span class="s1">(contextType.$$typeof === REACT_PROVIDER_TYPE) {</span>
            <span class="s1">addendum = </span><span class="s3">' Did you accidentally pass the Context.Provider instead?'</span><span class="s1">;</span>
          <span class="s1">} </span><span class="s2">else if </span><span class="s1">(contextType._context !== undefined) {</span>
            <span class="s0">// &lt;Context.Consumer&gt;</span>
            <span class="s1">addendum = </span><span class="s3">' Did you accidentally pass the Context.Consumer instead?'</span><span class="s1">;</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">addendum = </span><span class="s3">' However, it is set to an object with keys {' </span><span class="s1">+ Object.keys(contextType).join(</span><span class="s3">', '</span><span class="s1">) + </span><span class="s3">'}.'</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s1">error(</span><span class="s3">'%s defines an invalid contextType. ' </span><span class="s1">+ </span><span class="s3">'contextType should point to the Context object returned by React.createContext().%s'</span><span class="s1">, getComponentNameFromType(ctor) || </span><span class="s3">'Component'</span><span class="s1">, addendum);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">contextType === </span><span class="s3">'object' </span><span class="s1">&amp;&amp; contextType !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">context = readContext(contextType);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">unmaskedContext = getUnmaskedContext(workInProgress, ctor, </span><span class="s2">true</span><span class="s1">);</span>
      <span class="s2">var </span><span class="s1">contextTypes = ctor.contextTypes;</span>
      <span class="s1">isLegacyContextConsumer = contextTypes !== </span><span class="s2">null </span><span class="s1">&amp;&amp; contextTypes !== undefined;</span>
      <span class="s1">context = isLegacyContextConsumer ? getMaskedContext(workInProgress, unmaskedContext) : emptyContextObject;</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">instance = </span><span class="s2">new </span><span class="s1">ctor(props, context); </span><span class="s0">// Instantiate twice to help detect side-effects.</span>

    <span class="s2">var </span><span class="s1">state = workInProgress.memoizedState = instance.state !== </span><span class="s2">null </span><span class="s1">&amp;&amp; instance.state !== undefined ? instance.state : </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">adoptClassInstance(workInProgress, instance);</span>

    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">ctor.getDerivedStateFromProps === </span><span class="s3">'function' </span><span class="s1">&amp;&amp; state === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">var </span><span class="s1">componentName = getComponentNameFromType(ctor) || </span><span class="s3">'Component'</span><span class="s1">;</span>

        <span class="s2">if </span><span class="s1">(!didWarnAboutUninitializedState.has(componentName)) {</span>
          <span class="s1">didWarnAboutUninitializedState.add(componentName);</span>

          <span class="s1">error(</span><span class="s3">'`%s` uses `getDerivedStateFromProps` but its initial state is ' </span><span class="s1">+ </span><span class="s3">'%s. This is not recommended. Instead, define the initial state by ' </span><span class="s1">+ </span><span class="s3">'assigning an object to `this.state` in the constructor of `%s`. ' </span><span class="s1">+ </span><span class="s3">'This ensures that `getDerivedStateFromProps` arguments have a consistent shape.'</span><span class="s1">, componentName, instance.state === </span><span class="s2">null </span><span class="s1">? </span><span class="s3">'null' </span><span class="s1">: </span><span class="s3">'undefined'</span><span class="s1">, componentName);</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s0">// If new component APIs are defined, &quot;unsafe&quot; lifecycles won't be called.</span>
      <span class="s0">// Warn about these lifecycles if they are present.</span>
      <span class="s0">// Don't warn about react-lifecycles-compat polyfilled methods though.</span>


      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">ctor.getDerivedStateFromProps === </span><span class="s3">'function' </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">instance.getSnapshotBeforeUpdate === </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s2">var </span><span class="s1">foundWillMountName = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s2">var </span><span class="s1">foundWillReceivePropsName = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s2">var </span><span class="s1">foundWillUpdateName = </span><span class="s2">null</span><span class="s1">;</span>

        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">instance.componentWillMount === </span><span class="s3">'function' </span><span class="s1">&amp;&amp; instance.componentWillMount.__suppressDeprecationWarning !== </span><span class="s2">true</span><span class="s1">) {</span>
          <span class="s1">foundWillMountName = </span><span class="s3">'componentWillMount'</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">instance.UNSAFE_componentWillMount === </span><span class="s3">'function'</span><span class="s1">) {</span>
          <span class="s1">foundWillMountName = </span><span class="s3">'UNSAFE_componentWillMount'</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">instance.componentWillReceiveProps === </span><span class="s3">'function' </span><span class="s1">&amp;&amp; instance.componentWillReceiveProps.__suppressDeprecationWarning !== </span><span class="s2">true</span><span class="s1">) {</span>
          <span class="s1">foundWillReceivePropsName = </span><span class="s3">'componentWillReceiveProps'</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">instance.UNSAFE_componentWillReceiveProps === </span><span class="s3">'function'</span><span class="s1">) {</span>
          <span class="s1">foundWillReceivePropsName = </span><span class="s3">'UNSAFE_componentWillReceiveProps'</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">instance.componentWillUpdate === </span><span class="s3">'function' </span><span class="s1">&amp;&amp; instance.componentWillUpdate.__suppressDeprecationWarning !== </span><span class="s2">true</span><span class="s1">) {</span>
          <span class="s1">foundWillUpdateName = </span><span class="s3">'componentWillUpdate'</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">instance.UNSAFE_componentWillUpdate === </span><span class="s3">'function'</span><span class="s1">) {</span>
          <span class="s1">foundWillUpdateName = </span><span class="s3">'UNSAFE_componentWillUpdate'</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(foundWillMountName !== </span><span class="s2">null </span><span class="s1">|| foundWillReceivePropsName !== </span><span class="s2">null </span><span class="s1">|| foundWillUpdateName !== </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s2">var </span><span class="s1">_componentName = getComponentNameFromType(ctor) || </span><span class="s3">'Component'</span><span class="s1">;</span>

          <span class="s2">var </span><span class="s1">newApiName = </span><span class="s2">typeof </span><span class="s1">ctor.getDerivedStateFromProps === </span><span class="s3">'function' </span><span class="s1">? </span><span class="s3">'getDerivedStateFromProps()' </span><span class="s1">: </span><span class="s3">'getSnapshotBeforeUpdate()'</span><span class="s1">;</span>

          <span class="s2">if </span><span class="s1">(!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {</span>
            <span class="s1">didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);</span>

            <span class="s1">error(</span><span class="s3">'Unsafe legacy lifecycles will not be called for components using new component APIs.</span><span class="s5">\n\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">'%s uses %s but also contains the following legacy lifecycles:%s%s%s</span><span class="s5">\n\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">'The above lifecycles should be removed. Learn more about this warning here:</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">'https://reactjs.org/link/unsafe-component-lifecycles'</span><span class="s1">, _componentName, newApiName, foundWillMountName !== </span><span class="s2">null </span><span class="s1">? </span><span class="s3">&quot;</span><span class="s5">\n  </span><span class="s3">&quot; </span><span class="s1">+ foundWillMountName : </span><span class="s3">''</span><span class="s1">, foundWillReceivePropsName !== </span><span class="s2">null </span><span class="s1">? </span><span class="s3">&quot;</span><span class="s5">\n  </span><span class="s3">&quot; </span><span class="s1">+ foundWillReceivePropsName : </span><span class="s3">''</span><span class="s1">, foundWillUpdateName !== </span><span class="s2">null </span><span class="s1">? </span><span class="s3">&quot;</span><span class="s5">\n  </span><span class="s3">&quot; </span><span class="s1">+ foundWillUpdateName : </span><span class="s3">''</span><span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// Cache unmasked context so we can avoid recreating masked context unless necessary.</span>
    <span class="s0">// ReactFiberContext usually updates this cache but can't for newly-created instances.</span>


    <span class="s2">if </span><span class="s1">(isLegacyContextConsumer) {</span>
      <span class="s1">cacheContext(workInProgress, unmaskedContext, context);</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">instance;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">callComponentWillMount(workInProgress, instance) {</span>
    <span class="s2">var </span><span class="s1">oldState = instance.state;</span>

    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">instance.componentWillMount === </span><span class="s3">'function'</span><span class="s1">) {</span>
      <span class="s1">instance.componentWillMount();</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">instance.UNSAFE_componentWillMount === </span><span class="s3">'function'</span><span class="s1">) {</span>
      <span class="s1">instance.UNSAFE_componentWillMount();</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(oldState !== instance.state) {</span>
      <span class="s1">{</span>
        <span class="s1">error(</span><span class="s3">'%s.componentWillMount(): Assigning directly to this.state is ' </span><span class="s1">+ </span><span class="s3">&quot;deprecated (except inside a component's &quot; </span><span class="s1">+ </span><span class="s3">'constructor). Use setState instead.'</span><span class="s1">, getComponentNameFromFiber(workInProgress) || </span><span class="s3">'Component'</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s1">classComponentUpdater.enqueueReplaceState(instance, instance.state, </span><span class="s2">null</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext) {</span>
    <span class="s2">var </span><span class="s1">oldState = instance.state;</span>

    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">instance.componentWillReceiveProps === </span><span class="s3">'function'</span><span class="s1">) {</span>
      <span class="s1">instance.componentWillReceiveProps(newProps, nextContext);</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">instance.UNSAFE_componentWillReceiveProps === </span><span class="s3">'function'</span><span class="s1">) {</span>
      <span class="s1">instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(instance.state !== oldState) {</span>
      <span class="s1">{</span>
        <span class="s2">var </span><span class="s1">componentName = getComponentNameFromFiber(workInProgress) || </span><span class="s3">'Component'</span><span class="s1">;</span>

        <span class="s2">if </span><span class="s1">(!didWarnAboutStateAssignmentForComponent.has(componentName)) {</span>
          <span class="s1">didWarnAboutStateAssignmentForComponent.add(componentName);</span>

          <span class="s1">error(</span><span class="s3">'%s.componentWillReceiveProps(): Assigning directly to ' </span><span class="s1">+ </span><span class="s3">&quot;this.state is deprecated (except inside a component's &quot; </span><span class="s1">+ </span><span class="s3">'constructor). Use setState instead.'</span><span class="s1">, componentName);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">classComponentUpdater.enqueueReplaceState(instance, instance.state, </span><span class="s2">null</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s0">// Invokes the mount life-cycles on a previously never rendered instance.</span>


  <span class="s2">function </span><span class="s1">mountClassInstance(workInProgress, ctor, newProps, renderLanes) {</span>
    <span class="s1">{</span>
      <span class="s1">checkClassInstance(workInProgress, ctor, newProps);</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">instance = workInProgress.stateNode;</span>
    <span class="s1">instance.props = newProps;</span>
    <span class="s1">instance.state = workInProgress.memoizedState;</span>
    <span class="s1">instance.refs = emptyRefsObject;</span>
    <span class="s1">initializeUpdateQueue(workInProgress);</span>
    <span class="s2">var </span><span class="s1">contextType = ctor.contextType;</span>

    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">contextType === </span><span class="s3">'object' </span><span class="s1">&amp;&amp; contextType !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">instance.context = readContext(contextType);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">var </span><span class="s1">unmaskedContext = getUnmaskedContext(workInProgress, ctor, </span><span class="s2">true</span><span class="s1">);</span>
      <span class="s1">instance.context = getMaskedContext(workInProgress, unmaskedContext);</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(instance.state === newProps) {</span>
        <span class="s2">var </span><span class="s1">componentName = getComponentNameFromType(ctor) || </span><span class="s3">'Component'</span><span class="s1">;</span>

        <span class="s2">if </span><span class="s1">(!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {</span>
          <span class="s1">didWarnAboutDirectlyAssigningPropsToState.add(componentName);</span>

          <span class="s1">error(</span><span class="s3">'%s: It is not recommended to assign props directly to state ' </span><span class="s1">+ </span><span class="s3">&quot;because updates to props won't be reflected in state. &quot; </span><span class="s1">+ </span><span class="s3">'In most cases, it is better to use props directly.'</span><span class="s1">, componentName);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(workInProgress.mode &amp; StrictLegacyMode) {</span>
        <span class="s1">ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, instance);</span>
      <span class="s1">}</span>

      <span class="s1">{</span>
        <span class="s1">ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress, instance);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">instance.state = workInProgress.memoizedState;</span>
    <span class="s2">var </span><span class="s1">getDerivedStateFromProps = ctor.getDerivedStateFromProps;</span>

    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">getDerivedStateFromProps === </span><span class="s3">'function'</span><span class="s1">) {</span>
      <span class="s1">applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);</span>
      <span class="s1">instance.state = workInProgress.memoizedState;</span>
    <span class="s1">} </span><span class="s0">// In order to support react-lifecycles-compat polyfilled components,</span>
    <span class="s0">// Unsafe lifecycles should not be invoked for components using the new APIs.</span>


    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">ctor.getDerivedStateFromProps !== </span><span class="s3">'function' </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">instance.getSnapshotBeforeUpdate !== </span><span class="s3">'function' </span><span class="s1">&amp;&amp; (</span><span class="s2">typeof </span><span class="s1">instance.UNSAFE_componentWillMount === </span><span class="s3">'function' </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">instance.componentWillMount === </span><span class="s3">'function'</span><span class="s1">)) {</span>
      <span class="s1">callComponentWillMount(workInProgress, instance); </span><span class="s0">// If we had additional state updates during this life-cycle, let's</span>
      <span class="s0">// process them now.</span>

      <span class="s1">processUpdateQueue(workInProgress, newProps, instance, renderLanes);</span>
      <span class="s1">instance.state = workInProgress.memoizedState;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">instance.componentDidMount === </span><span class="s3">'function'</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">fiberFlags = Update;</span>

      <span class="s1">workInProgress.flags |= fiberFlags;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">resumeMountClassInstance(workInProgress, ctor, newProps, renderLanes) {</span>
    <span class="s2">var </span><span class="s1">instance = workInProgress.stateNode;</span>
    <span class="s2">var </span><span class="s1">oldProps = workInProgress.memoizedProps;</span>
    <span class="s1">instance.props = oldProps;</span>
    <span class="s2">var </span><span class="s1">oldContext = instance.context;</span>
    <span class="s2">var </span><span class="s1">contextType = ctor.contextType;</span>
    <span class="s2">var </span><span class="s1">nextContext = emptyContextObject;</span>

    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">contextType === </span><span class="s3">'object' </span><span class="s1">&amp;&amp; contextType !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">nextContext = readContext(contextType);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">var </span><span class="s1">nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress, ctor, </span><span class="s2">true</span><span class="s1">);</span>
      <span class="s1">nextContext = getMaskedContext(workInProgress, nextLegacyUnmaskedContext);</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">getDerivedStateFromProps = ctor.getDerivedStateFromProps;</span>
    <span class="s2">var </span><span class="s1">hasNewLifecycles = </span><span class="s2">typeof </span><span class="s1">getDerivedStateFromProps === </span><span class="s3">'function' </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">instance.getSnapshotBeforeUpdate === </span><span class="s3">'function'</span><span class="s1">; </span><span class="s0">// Note: During these life-cycles, instance.props/instance.state are what</span>
    <span class="s0">// ever the previously attempted to render - not the &quot;current&quot;. However,</span>
    <span class="s0">// during componentDidUpdate we pass the &quot;current&quot; props.</span>
    <span class="s0">// In order to support react-lifecycles-compat polyfilled components,</span>
    <span class="s0">// Unsafe lifecycles should not be invoked for components using the new APIs.</span>

    <span class="s2">if </span><span class="s1">(!hasNewLifecycles &amp;&amp; (</span><span class="s2">typeof </span><span class="s1">instance.UNSAFE_componentWillReceiveProps === </span><span class="s3">'function' </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">instance.componentWillReceiveProps === </span><span class="s3">'function'</span><span class="s1">)) {</span>
      <span class="s2">if </span><span class="s1">(oldProps !== newProps || oldContext !== nextContext) {</span>
        <span class="s1">callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">resetHasForceUpdateBeforeProcessing();</span>
    <span class="s2">var </span><span class="s1">oldState = workInProgress.memoizedState;</span>
    <span class="s2">var </span><span class="s1">newState = instance.state = oldState;</span>
    <span class="s1">processUpdateQueue(workInProgress, newProps, instance, renderLanes);</span>
    <span class="s1">newState = workInProgress.memoizedState;</span>

    <span class="s2">if </span><span class="s1">(oldProps === newProps &amp;&amp; oldState === newState &amp;&amp; !hasContextChanged() &amp;&amp; !checkHasForceUpdateAfterProcessing()) {</span>
      <span class="s0">// If an update was already in progress, we should schedule an Update</span>
      <span class="s0">// effect even though we're bailing out, so that cWU/cDU are called.</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">instance.componentDidMount === </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s2">var </span><span class="s1">fiberFlags = Update;</span>

        <span class="s1">workInProgress.flags |= fiberFlags;</span>
      <span class="s1">}</span>

      <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">getDerivedStateFromProps === </span><span class="s3">'function'</span><span class="s1">) {</span>
      <span class="s1">applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);</span>
      <span class="s1">newState = workInProgress.memoizedState;</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext);</span>

    <span class="s2">if </span><span class="s1">(shouldUpdate) {</span>
      <span class="s0">// In order to support react-lifecycles-compat polyfilled components,</span>
      <span class="s0">// Unsafe lifecycles should not be invoked for components using the new APIs.</span>
      <span class="s2">if </span><span class="s1">(!hasNewLifecycles &amp;&amp; (</span><span class="s2">typeof </span><span class="s1">instance.UNSAFE_componentWillMount === </span><span class="s3">'function' </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">instance.componentWillMount === </span><span class="s3">'function'</span><span class="s1">)) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">instance.componentWillMount === </span><span class="s3">'function'</span><span class="s1">) {</span>
          <span class="s1">instance.componentWillMount();</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">instance.UNSAFE_componentWillMount === </span><span class="s3">'function'</span><span class="s1">) {</span>
          <span class="s1">instance.UNSAFE_componentWillMount();</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">instance.componentDidMount === </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s2">var </span><span class="s1">_fiberFlags = Update;</span>

        <span class="s1">workInProgress.flags |= _fiberFlags;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s0">// If an update was already in progress, we should schedule an Update</span>
      <span class="s0">// effect even though we're bailing out, so that cWU/cDU are called.</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">instance.componentDidMount === </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s2">var </span><span class="s1">_fiberFlags2 = Update;</span>

        <span class="s1">workInProgress.flags |= _fiberFlags2;</span>
      <span class="s1">} </span><span class="s0">// If shouldComponentUpdate returned false, we should still update the</span>
      <span class="s0">// memoized state to indicate that this work can be reused.</span>


      <span class="s1">workInProgress.memoizedProps = newProps;</span>
      <span class="s1">workInProgress.memoizedState = newState;</span>
    <span class="s1">} </span><span class="s0">// Update the existing instance's state, props, and context pointers even</span>
    <span class="s0">// if shouldComponentUpdate returns false.</span>


    <span class="s1">instance.props = newProps;</span>
    <span class="s1">instance.state = newState;</span>
    <span class="s1">instance.context = nextContext;</span>
    <span class="s2">return </span><span class="s1">shouldUpdate;</span>
  <span class="s1">} </span><span class="s0">// Invokes the update life-cycles and returns false if it shouldn't rerender.</span>


  <span class="s2">function </span><span class="s1">updateClassInstance(current, workInProgress, ctor, newProps, renderLanes) {</span>
    <span class="s2">var </span><span class="s1">instance = workInProgress.stateNode;</span>
    <span class="s1">cloneUpdateQueue(current, workInProgress);</span>
    <span class="s2">var </span><span class="s1">unresolvedOldProps = workInProgress.memoizedProps;</span>
    <span class="s2">var </span><span class="s1">oldProps = workInProgress.type === workInProgress.elementType ? unresolvedOldProps : resolveDefaultProps(workInProgress.type, unresolvedOldProps);</span>
    <span class="s1">instance.props = oldProps;</span>
    <span class="s2">var </span><span class="s1">unresolvedNewProps = workInProgress.pendingProps;</span>
    <span class="s2">var </span><span class="s1">oldContext = instance.context;</span>
    <span class="s2">var </span><span class="s1">contextType = ctor.contextType;</span>
    <span class="s2">var </span><span class="s1">nextContext = emptyContextObject;</span>

    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">contextType === </span><span class="s3">'object' </span><span class="s1">&amp;&amp; contextType !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">nextContext = readContext(contextType);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">var </span><span class="s1">nextUnmaskedContext = getUnmaskedContext(workInProgress, ctor, </span><span class="s2">true</span><span class="s1">);</span>
      <span class="s1">nextContext = getMaskedContext(workInProgress, nextUnmaskedContext);</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">getDerivedStateFromProps = ctor.getDerivedStateFromProps;</span>
    <span class="s2">var </span><span class="s1">hasNewLifecycles = </span><span class="s2">typeof </span><span class="s1">getDerivedStateFromProps === </span><span class="s3">'function' </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">instance.getSnapshotBeforeUpdate === </span><span class="s3">'function'</span><span class="s1">; </span><span class="s0">// Note: During these life-cycles, instance.props/instance.state are what</span>
    <span class="s0">// ever the previously attempted to render - not the &quot;current&quot;. However,</span>
    <span class="s0">// during componentDidUpdate we pass the &quot;current&quot; props.</span>
    <span class="s0">// In order to support react-lifecycles-compat polyfilled components,</span>
    <span class="s0">// Unsafe lifecycles should not be invoked for components using the new APIs.</span>

    <span class="s2">if </span><span class="s1">(!hasNewLifecycles &amp;&amp; (</span><span class="s2">typeof </span><span class="s1">instance.UNSAFE_componentWillReceiveProps === </span><span class="s3">'function' </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">instance.componentWillReceiveProps === </span><span class="s3">'function'</span><span class="s1">)) {</span>
      <span class="s2">if </span><span class="s1">(unresolvedOldProps !== unresolvedNewProps || oldContext !== nextContext) {</span>
        <span class="s1">callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">resetHasForceUpdateBeforeProcessing();</span>
    <span class="s2">var </span><span class="s1">oldState = workInProgress.memoizedState;</span>
    <span class="s2">var </span><span class="s1">newState = instance.state = oldState;</span>
    <span class="s1">processUpdateQueue(workInProgress, newProps, instance, renderLanes);</span>
    <span class="s1">newState = workInProgress.memoizedState;</span>

    <span class="s2">if </span><span class="s1">(unresolvedOldProps === unresolvedNewProps &amp;&amp; oldState === newState &amp;&amp; !hasContextChanged() &amp;&amp; !checkHasForceUpdateAfterProcessing() &amp;&amp; !(enableLazyContextPropagation   )) {</span>
      <span class="s0">// If an update was already in progress, we should schedule an Update</span>
      <span class="s0">// effect even though we're bailing out, so that cWU/cDU are called.</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">instance.componentDidUpdate === </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {</span>
          <span class="s1">workInProgress.flags |= Update;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">instance.getSnapshotBeforeUpdate === </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {</span>
          <span class="s1">workInProgress.flags |= Snapshot;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">getDerivedStateFromProps === </span><span class="s3">'function'</span><span class="s1">) {</span>
      <span class="s1">applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);</span>
      <span class="s1">newState = workInProgress.memoizedState;</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) || </span><span class="s0">// TODO: In some cases, we'll end up checking if context has changed twice,</span>
    <span class="s0">// both before and after `shouldComponentUpdate` has been called. Not ideal,</span>
    <span class="s0">// but I'm loath to refactor this function. This only happens for memoized</span>
    <span class="s0">// components so it's not that common.</span>
    <span class="s1">enableLazyContextPropagation   ;</span>

    <span class="s2">if </span><span class="s1">(shouldUpdate) {</span>
      <span class="s0">// In order to support react-lifecycles-compat polyfilled components,</span>
      <span class="s0">// Unsafe lifecycles should not be invoked for components using the new APIs.</span>
      <span class="s2">if </span><span class="s1">(!hasNewLifecycles &amp;&amp; (</span><span class="s2">typeof </span><span class="s1">instance.UNSAFE_componentWillUpdate === </span><span class="s3">'function' </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">instance.componentWillUpdate === </span><span class="s3">'function'</span><span class="s1">)) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">instance.componentWillUpdate === </span><span class="s3">'function'</span><span class="s1">) {</span>
          <span class="s1">instance.componentWillUpdate(newProps, newState, nextContext);</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">instance.UNSAFE_componentWillUpdate === </span><span class="s3">'function'</span><span class="s1">) {</span>
          <span class="s1">instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">instance.componentDidUpdate === </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s1">workInProgress.flags |= Update;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">instance.getSnapshotBeforeUpdate === </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s1">workInProgress.flags |= Snapshot;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s0">// If an update was already in progress, we should schedule an Update</span>
      <span class="s0">// effect even though we're bailing out, so that cWU/cDU are called.</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">instance.componentDidUpdate === </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {</span>
          <span class="s1">workInProgress.flags |= Update;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">instance.getSnapshotBeforeUpdate === </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {</span>
          <span class="s1">workInProgress.flags |= Snapshot;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s0">// If shouldComponentUpdate returned false, we should still update the</span>
      <span class="s0">// memoized props/state to indicate that this work can be reused.</span>


      <span class="s1">workInProgress.memoizedProps = newProps;</span>
      <span class="s1">workInProgress.memoizedState = newState;</span>
    <span class="s1">} </span><span class="s0">// Update the existing instance's state, props, and context pointers even</span>
    <span class="s0">// if shouldComponentUpdate returns false.</span>


    <span class="s1">instance.props = newProps;</span>
    <span class="s1">instance.state = newState;</span>
    <span class="s1">instance.context = nextContext;</span>
    <span class="s2">return </span><span class="s1">shouldUpdate;</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">didWarnAboutMaps;</span>
  <span class="s2">var </span><span class="s1">didWarnAboutGenerators;</span>
  <span class="s2">var </span><span class="s1">didWarnAboutStringRefs;</span>
  <span class="s2">var </span><span class="s1">ownerHasKeyUseWarning;</span>
  <span class="s2">var </span><span class="s1">ownerHasFunctionTypeWarning;</span>

  <span class="s2">var </span><span class="s1">warnForMissingKey = </span><span class="s2">function </span><span class="s1">(child, returnFiber) {};</span>

  <span class="s1">{</span>
    <span class="s1">didWarnAboutMaps = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">didWarnAboutGenerators = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">didWarnAboutStringRefs = {};</span>
    <span class="s0">/** 
     * Warn if there's no key explicitly set on dynamic arrays of children or 
     * object keys are not valid. This allows us to keep track of children between 
     * updates. 
     */</span>

    <span class="s1">ownerHasKeyUseWarning = {};</span>
    <span class="s1">ownerHasFunctionTypeWarning = {};</span>

    <span class="s1">warnForMissingKey = </span><span class="s2">function </span><span class="s1">(child, returnFiber) {</span>
      <span class="s2">if </span><span class="s1">(child === </span><span class="s2">null </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">child !== </span><span class="s3">'object'</span><span class="s1">) {</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(!child._store || child._store.validated || child.key != </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">child._store !== </span><span class="s3">'object'</span><span class="s1">) {</span>
        <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'React Component in warnForMissingKey should have a _store. ' </span><span class="s1">+ </span><span class="s3">'This error is likely caused by a bug in React. Please file an issue.'</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s1">child._store.validated = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s2">var </span><span class="s1">componentName = getComponentNameFromFiber(returnFiber) || </span><span class="s3">'Component'</span><span class="s1">;</span>

      <span class="s2">if </span><span class="s1">(ownerHasKeyUseWarning[componentName]) {</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">ownerHasKeyUseWarning[componentName] = </span><span class="s2">true</span><span class="s1">;</span>

      <span class="s1">error(</span><span class="s3">'Each child in a list should have a unique ' </span><span class="s1">+ </span><span class="s3">'&quot;key&quot; prop. See https://reactjs.org/link/warning-keys for ' </span><span class="s1">+ </span><span class="s3">'more information.'</span><span class="s1">);</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">coerceRef(returnFiber, current, element) {</span>
    <span class="s2">var </span><span class="s1">mixedRef = element.ref;</span>

    <span class="s2">if </span><span class="s1">(mixedRef !== </span><span class="s2">null </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">mixedRef !== </span><span class="s3">'function' </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">mixedRef !== </span><span class="s3">'object'</span><span class="s1">) {</span>
      <span class="s1">{</span>
        <span class="s0">// TODO: Clean this up once we turn on the string ref warning for</span>
        <span class="s0">// everyone, because the strict mode case will no longer be relevant</span>
        <span class="s2">if </span><span class="s1">((returnFiber.mode &amp; StrictLegacyMode || warnAboutStringRefs) &amp;&amp; </span><span class="s0">// We warn in ReactElement.js if owner and self are equal for string refs</span>
        <span class="s0">// because these cannot be automatically converted to an arrow function</span>
        <span class="s0">// using a codemod. Therefore, we don't have to warn about string refs again.</span>
        <span class="s1">!(element._owner &amp;&amp; element._self &amp;&amp; element._owner.stateNode !== element._self)) {</span>
          <span class="s2">var </span><span class="s1">componentName = getComponentNameFromFiber(returnFiber) || </span><span class="s3">'Component'</span><span class="s1">;</span>

          <span class="s2">if </span><span class="s1">(!didWarnAboutStringRefs[componentName]) {</span>
            <span class="s1">{</span>
              <span class="s1">error(</span><span class="s3">'A string ref, &quot;%s&quot;, has been found within a strict mode tree. ' </span><span class="s1">+ </span><span class="s3">'String refs are a source of potential bugs and should be avoided. ' </span><span class="s1">+ </span><span class="s3">'We recommend using useRef() or createRef() instead. ' </span><span class="s1">+ </span><span class="s3">'Learn more about using refs safely here: ' </span><span class="s1">+ </span><span class="s3">'https://reactjs.org/link/strict-mode-string-ref'</span><span class="s1">, mixedRef);</span>
            <span class="s1">}</span>

            <span class="s1">didWarnAboutStringRefs[componentName] = </span><span class="s2">true</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(element._owner) {</span>
        <span class="s2">var </span><span class="s1">owner = element._owner;</span>
        <span class="s2">var </span><span class="s1">inst;</span>

        <span class="s2">if </span><span class="s1">(owner) {</span>
          <span class="s2">var </span><span class="s1">ownerFiber = owner;</span>

          <span class="s2">if </span><span class="s1">(ownerFiber.tag !== ClassComponent) {</span>
            <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Function components cannot have string refs. ' </span><span class="s1">+ </span><span class="s3">'We recommend using useRef() instead. ' </span><span class="s1">+ </span><span class="s3">'Learn more about using refs safely here: ' </span><span class="s1">+ </span><span class="s3">'https://reactjs.org/link/strict-mode-string-ref'</span><span class="s1">);</span>
          <span class="s1">}</span>

          <span class="s1">inst = ownerFiber.stateNode;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(!inst) {</span>
          <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">&quot;Missing owner for string ref &quot; </span><span class="s1">+ mixedRef + </span><span class="s3">&quot;. This error is likely caused by a &quot; </span><span class="s1">+ </span><span class="s3">'bug in React. Please file an issue.'</span><span class="s1">);</span>
        <span class="s1">} </span><span class="s0">// Assigning this to a const so Flow knows it won't change in the closure</span>


        <span class="s2">var </span><span class="s1">resolvedInst = inst;</span>

        <span class="s1">{</span>
          <span class="s1">checkPropStringCoercion(mixedRef, </span><span class="s3">'ref'</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s2">var </span><span class="s1">stringRef = </span><span class="s3">'' </span><span class="s1">+ mixedRef; </span><span class="s0">// Check if previous string ref matches new string ref</span>

        <span class="s2">if </span><span class="s1">(current !== </span><span class="s2">null </span><span class="s1">&amp;&amp; current.ref !== </span><span class="s2">null </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">current.ref === </span><span class="s3">'function' </span><span class="s1">&amp;&amp; current.ref._stringRef === stringRef) {</span>
          <span class="s2">return </span><span class="s1">current.ref;</span>
        <span class="s1">}</span>

        <span class="s2">var </span><span class="s1">ref = </span><span class="s2">function </span><span class="s1">(value) {</span>
          <span class="s2">var </span><span class="s1">refs = resolvedInst.refs;</span>

          <span class="s2">if </span><span class="s1">(refs === emptyRefsObject) {</span>
            <span class="s0">// This is a lazy pooled frozen object, so we need to initialize.</span>
            <span class="s1">refs = resolvedInst.refs = {};</span>
          <span class="s1">}</span>

          <span class="s2">if </span><span class="s1">(value === </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">delete </span><span class="s1">refs[stringRef];</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">refs[stringRef] = value;</span>
          <span class="s1">}</span>
        <span class="s1">};</span>

        <span class="s1">ref._stringRef = stringRef;</span>
        <span class="s2">return </span><span class="s1">ref;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">mixedRef !== </span><span class="s3">'string'</span><span class="s1">) {</span>
          <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Expected ref to be a function, a string, an object returned by React.createRef(), or null.'</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(!element._owner) {</span>
          <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">&quot;Element ref was specified as a string (&quot; </span><span class="s1">+ mixedRef + </span><span class="s3">&quot;) but no owner was set. This could happen for one of&quot; </span><span class="s1">+ </span><span class="s3">' the following reasons:</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">'1. You may be adding a ref to a function component</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">&quot;2. You may be adding a ref to a component that was not created inside a component's render method</span><span class="s5">\n</span><span class="s3">&quot; </span><span class="s1">+ </span><span class="s3">'3. You have multiple copies of React loaded</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">'See https://reactjs.org/link/refs-must-have-owner for more information.'</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">mixedRef;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">throwOnInvalidObjectType(returnFiber, newChild) {</span>
    <span class="s2">var </span><span class="s1">childString = Object.prototype.toString.call(newChild);</span>
    <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">&quot;Objects are not valid as a React child (found: &quot; </span><span class="s1">+ (childString === </span><span class="s3">'[object Object]' </span><span class="s1">? </span><span class="s3">'object with keys {' </span><span class="s1">+ Object.keys(newChild).join(</span><span class="s3">', '</span><span class="s1">) + </span><span class="s3">'}' </span><span class="s1">: childString) + </span><span class="s3">&quot;). &quot; </span><span class="s1">+ </span><span class="s3">'If you meant to render a collection of children, use an array ' </span><span class="s1">+ </span><span class="s3">'instead.'</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">warnOnFunctionType(returnFiber) {</span>
    <span class="s1">{</span>
      <span class="s2">var </span><span class="s1">componentName = getComponentNameFromFiber(returnFiber) || </span><span class="s3">'Component'</span><span class="s1">;</span>

      <span class="s2">if </span><span class="s1">(ownerHasFunctionTypeWarning[componentName]) {</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">ownerHasFunctionTypeWarning[componentName] = </span><span class="s2">true</span><span class="s1">;</span>

      <span class="s1">error(</span><span class="s3">'Functions are not valid as a React child. This may happen if ' </span><span class="s1">+ </span><span class="s3">'you return a Component instead of &lt;Component /&gt; from render. ' </span><span class="s1">+ </span><span class="s3">'Or maybe you meant to call this function rather than return it.'</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">resolveLazy(lazyType) {</span>
    <span class="s2">var </span><span class="s1">payload = lazyType._payload;</span>
    <span class="s2">var </span><span class="s1">init = lazyType._init;</span>
    <span class="s2">return </span><span class="s1">init(payload);</span>
  <span class="s1">} </span><span class="s0">// This wrapper function exists because I expect to clone the code in each path</span>
  <span class="s0">// to be able to optimize each path individually by branching early. This needs</span>
  <span class="s0">// a compiler or we can do it manually. Helpers that don't need this branching</span>
  <span class="s0">// live outside of this function.</span>


  <span class="s2">function </span><span class="s1">ChildReconciler(shouldTrackSideEffects) {</span>
    <span class="s2">function </span><span class="s1">deleteChild(returnFiber, childToDelete) {</span>
      <span class="s2">if </span><span class="s1">(!shouldTrackSideEffects) {</span>
        <span class="s0">// Noop.</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">deletions = returnFiber.deletions;</span>

      <span class="s2">if </span><span class="s1">(deletions === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">returnFiber.deletions = [childToDelete];</span>
        <span class="s1">returnFiber.flags |= ChildDeletion;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">deletions.push(childToDelete);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">function </span><span class="s1">deleteRemainingChildren(returnFiber, currentFirstChild) {</span>
      <span class="s2">if </span><span class="s1">(!shouldTrackSideEffects) {</span>
        <span class="s0">// Noop.</span>
        <span class="s2">return null</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// TODO: For the shouldClone case, this could be micro-optimized a bit by</span>
      <span class="s0">// assuming that after the first child we've already added everything.</span>


      <span class="s2">var </span><span class="s1">childToDelete = currentFirstChild;</span>

      <span class="s2">while </span><span class="s1">(childToDelete !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">deleteChild(returnFiber, childToDelete);</span>
        <span class="s1">childToDelete = childToDelete.sibling;</span>
      <span class="s1">}</span>

      <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">function </span><span class="s1">mapRemainingChildren(returnFiber, currentFirstChild) {</span>
      <span class="s0">// Add the remaining children to a temporary map so that we can find them by</span>
      <span class="s0">// keys quickly. Implicit (null) keys get added to this set with their index</span>
      <span class="s0">// instead.</span>
      <span class="s2">var </span><span class="s1">existingChildren = </span><span class="s2">new </span><span class="s1">Map();</span>
      <span class="s2">var </span><span class="s1">existingChild = currentFirstChild;</span>

      <span class="s2">while </span><span class="s1">(existingChild !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(existingChild.key !== </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">existingChildren.set(existingChild.key, existingChild);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">existingChildren.set(existingChild.index, existingChild);</span>
        <span class="s1">}</span>

        <span class="s1">existingChild = existingChild.sibling;</span>
      <span class="s1">}</span>

      <span class="s2">return </span><span class="s1">existingChildren;</span>
    <span class="s1">}</span>

    <span class="s2">function </span><span class="s1">useFiber(fiber, pendingProps) {</span>
      <span class="s0">// We currently set sibling to null and index to 0 here because it is easy</span>
      <span class="s0">// to forget to do before returning it. E.g. for the single child case.</span>
      <span class="s2">var </span><span class="s1">clone = createWorkInProgress(fiber, pendingProps);</span>
      <span class="s1">clone.index = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s1">clone.sibling = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s2">return </span><span class="s1">clone;</span>
    <span class="s1">}</span>

    <span class="s2">function </span><span class="s1">placeChild(newFiber, lastPlacedIndex, newIndex) {</span>
      <span class="s1">newFiber.index = newIndex;</span>

      <span class="s2">if </span><span class="s1">(!shouldTrackSideEffects) {</span>
        <span class="s0">// During hydration, the useId algorithm needs to know which fibers are</span>
        <span class="s0">// part of a list of children (arrays, iterators).</span>
        <span class="s1">newFiber.flags |= Forked;</span>
        <span class="s2">return </span><span class="s1">lastPlacedIndex;</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">current = newFiber.alternate;</span>

      <span class="s2">if </span><span class="s1">(current !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">var </span><span class="s1">oldIndex = current.index;</span>

        <span class="s2">if </span><span class="s1">(oldIndex &lt; lastPlacedIndex) {</span>
          <span class="s0">// This is a move.</span>
          <span class="s1">newFiber.flags |= Placement;</span>
          <span class="s2">return </span><span class="s1">lastPlacedIndex;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s0">// This item can stay in place.</span>
          <span class="s2">return </span><span class="s1">oldIndex;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s0">// This is an insertion.</span>
        <span class="s1">newFiber.flags |= Placement;</span>
        <span class="s2">return </span><span class="s1">lastPlacedIndex;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">function </span><span class="s1">placeSingleChild(newFiber) {</span>
      <span class="s0">// This is simpler for the single child case. We only need to do a</span>
      <span class="s0">// placement for inserting new children.</span>
      <span class="s2">if </span><span class="s1">(shouldTrackSideEffects &amp;&amp; newFiber.alternate === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">newFiber.flags |= Placement;</span>
      <span class="s1">}</span>

      <span class="s2">return </span><span class="s1">newFiber;</span>
    <span class="s1">}</span>

    <span class="s2">function </span><span class="s1">updateTextNode(returnFiber, current, textContent, lanes) {</span>
      <span class="s2">if </span><span class="s1">(current === </span><span class="s2">null </span><span class="s1">|| current.tag !== HostText) {</span>
        <span class="s0">// Insert</span>
        <span class="s2">var </span><span class="s1">created = createFiberFromText(textContent, returnFiber.mode, lanes);</span>
        <span class="s1">created.</span><span class="s2">return </span><span class="s1">= returnFiber;</span>
        <span class="s2">return </span><span class="s1">created;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s0">// Update</span>
        <span class="s2">var </span><span class="s1">existing = useFiber(current, textContent);</span>
        <span class="s1">existing.</span><span class="s2">return </span><span class="s1">= returnFiber;</span>
        <span class="s2">return </span><span class="s1">existing;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">function </span><span class="s1">updateElement(returnFiber, current, element, lanes) {</span>
      <span class="s2">var </span><span class="s1">elementType = element.type;</span>

      <span class="s2">if </span><span class="s1">(elementType === REACT_FRAGMENT_TYPE) {</span>
        <span class="s2">return </span><span class="s1">updateFragment(returnFiber, current, element.props.children, lanes, element.key);</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(current !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(current.elementType === elementType || ( </span><span class="s0">// Keep this check inline so it only runs on the false path:</span>
         <span class="s1">isCompatibleFamilyForHotReloading(current, element) ) || </span><span class="s0">// Lazy types should reconcile their resolved type.</span>
        <span class="s0">// We need to do this after the Hot Reloading check above,</span>
        <span class="s0">// because hot reloading has different semantics than prod because</span>
        <span class="s0">// it doesn't resuspend. So we can't let the call below suspend.</span>
        <span class="s2">typeof </span><span class="s1">elementType === </span><span class="s3">'object' </span><span class="s1">&amp;&amp; elementType !== </span><span class="s2">null </span><span class="s1">&amp;&amp; elementType.$$typeof === REACT_LAZY_TYPE &amp;&amp; resolveLazy(elementType) === current.type) {</span>
          <span class="s0">// Move based on index</span>
          <span class="s2">var </span><span class="s1">existing = useFiber(current, element.props);</span>
          <span class="s1">existing.ref = coerceRef(returnFiber, current, element);</span>
          <span class="s1">existing.</span><span class="s2">return </span><span class="s1">= returnFiber;</span>

          <span class="s1">{</span>
            <span class="s1">existing._debugSource = element._source;</span>
            <span class="s1">existing._debugOwner = element._owner;</span>
          <span class="s1">}</span>

          <span class="s2">return </span><span class="s1">existing;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s0">// Insert</span>


      <span class="s2">var </span><span class="s1">created = createFiberFromElement(element, returnFiber.mode, lanes);</span>
      <span class="s1">created.ref = coerceRef(returnFiber, current, element);</span>
      <span class="s1">created.</span><span class="s2">return </span><span class="s1">= returnFiber;</span>
      <span class="s2">return </span><span class="s1">created;</span>
    <span class="s1">}</span>

    <span class="s2">function </span><span class="s1">updatePortal(returnFiber, current, portal, lanes) {</span>
      <span class="s2">if </span><span class="s1">(current === </span><span class="s2">null </span><span class="s1">|| current.tag !== HostPortal || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) {</span>
        <span class="s0">// Insert</span>
        <span class="s2">var </span><span class="s1">created = createFiberFromPortal(portal, returnFiber.mode, lanes);</span>
        <span class="s1">created.</span><span class="s2">return </span><span class="s1">= returnFiber;</span>
        <span class="s2">return </span><span class="s1">created;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s0">// Update</span>
        <span class="s2">var </span><span class="s1">existing = useFiber(current, portal.children || []);</span>
        <span class="s1">existing.</span><span class="s2">return </span><span class="s1">= returnFiber;</span>
        <span class="s2">return </span><span class="s1">existing;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">function </span><span class="s1">updateFragment(returnFiber, current, fragment, lanes, key) {</span>
      <span class="s2">if </span><span class="s1">(current === </span><span class="s2">null </span><span class="s1">|| current.tag !== Fragment) {</span>
        <span class="s0">// Insert</span>
        <span class="s2">var </span><span class="s1">created = createFiberFromFragment(fragment, returnFiber.mode, lanes, key);</span>
        <span class="s1">created.</span><span class="s2">return </span><span class="s1">= returnFiber;</span>
        <span class="s2">return </span><span class="s1">created;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s0">// Update</span>
        <span class="s2">var </span><span class="s1">existing = useFiber(current, fragment);</span>
        <span class="s1">existing.</span><span class="s2">return </span><span class="s1">= returnFiber;</span>
        <span class="s2">return </span><span class="s1">existing;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">function </span><span class="s1">createChild(returnFiber, newChild, lanes) {</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">newChild === </span><span class="s3">'string' </span><span class="s1">&amp;&amp; newChild !== </span><span class="s3">'' </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">newChild === </span><span class="s3">'number'</span><span class="s1">) {</span>
        <span class="s0">// Text nodes don't have keys. If the previous node is implicitly keyed</span>
        <span class="s0">// we can continue to replace it without aborting even if it is not a text</span>
        <span class="s0">// node.</span>
        <span class="s2">var </span><span class="s1">created = createFiberFromText(</span><span class="s3">'' </span><span class="s1">+ newChild, returnFiber.mode, lanes);</span>
        <span class="s1">created.</span><span class="s2">return </span><span class="s1">= returnFiber;</span>
        <span class="s2">return </span><span class="s1">created;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">newChild === </span><span class="s3">'object' </span><span class="s1">&amp;&amp; newChild !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">switch </span><span class="s1">(newChild.$$typeof) {</span>
          <span class="s2">case </span><span class="s1">REACT_ELEMENT_TYPE:</span>
            <span class="s1">{</span>
              <span class="s2">var </span><span class="s1">_created = createFiberFromElement(newChild, returnFiber.mode, lanes);</span>

              <span class="s1">_created.ref = coerceRef(returnFiber, </span><span class="s2">null</span><span class="s1">, newChild);</span>
              <span class="s1">_created.</span><span class="s2">return </span><span class="s1">= returnFiber;</span>
              <span class="s2">return </span><span class="s1">_created;</span>
            <span class="s1">}</span>

          <span class="s2">case </span><span class="s1">REACT_PORTAL_TYPE:</span>
            <span class="s1">{</span>
              <span class="s2">var </span><span class="s1">_created2 = createFiberFromPortal(newChild, returnFiber.mode, lanes);</span>

              <span class="s1">_created2.</span><span class="s2">return </span><span class="s1">= returnFiber;</span>
              <span class="s2">return </span><span class="s1">_created2;</span>
            <span class="s1">}</span>

          <span class="s2">case </span><span class="s1">REACT_LAZY_TYPE:</span>
            <span class="s1">{</span>
              <span class="s2">var </span><span class="s1">payload = newChild._payload;</span>
              <span class="s2">var </span><span class="s1">init = newChild._init;</span>
              <span class="s2">return </span><span class="s1">createChild(returnFiber, init(payload), lanes);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(isArray(newChild) || getIteratorFn(newChild)) {</span>
          <span class="s2">var </span><span class="s1">_created3 = createFiberFromFragment(newChild, returnFiber.mode, lanes, </span><span class="s2">null</span><span class="s1">);</span>

          <span class="s1">_created3.</span><span class="s2">return </span><span class="s1">= returnFiber;</span>
          <span class="s2">return </span><span class="s1">_created3;</span>
        <span class="s1">}</span>

        <span class="s1">throwOnInvalidObjectType(returnFiber, newChild);</span>
      <span class="s1">}</span>

      <span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">newChild === </span><span class="s3">'function'</span><span class="s1">) {</span>
          <span class="s1">warnOnFunctionType(returnFiber);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">function </span><span class="s1">updateSlot(returnFiber, oldFiber, newChild, lanes) {</span>
      <span class="s0">// Update the fiber if the keys match, otherwise return null.</span>
      <span class="s2">var </span><span class="s1">key = oldFiber !== </span><span class="s2">null </span><span class="s1">? oldFiber.key : </span><span class="s2">null</span><span class="s1">;</span>

      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">newChild === </span><span class="s3">'string' </span><span class="s1">&amp;&amp; newChild !== </span><span class="s3">'' </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">newChild === </span><span class="s3">'number'</span><span class="s1">) {</span>
        <span class="s0">// Text nodes don't have keys. If the previous node is implicitly keyed</span>
        <span class="s0">// we can continue to replace it without aborting even if it is not a text</span>
        <span class="s0">// node.</span>
        <span class="s2">if </span><span class="s1">(key !== </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s2">return null</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s2">return </span><span class="s1">updateTextNode(returnFiber, oldFiber, </span><span class="s3">'' </span><span class="s1">+ newChild, lanes);</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">newChild === </span><span class="s3">'object' </span><span class="s1">&amp;&amp; newChild !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">switch </span><span class="s1">(newChild.$$typeof) {</span>
          <span class="s2">case </span><span class="s1">REACT_ELEMENT_TYPE:</span>
            <span class="s1">{</span>
              <span class="s2">if </span><span class="s1">(newChild.key === key) {</span>
                <span class="s2">return </span><span class="s1">updateElement(returnFiber, oldFiber, newChild, lanes);</span>
              <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s2">return null</span><span class="s1">;</span>
              <span class="s1">}</span>
            <span class="s1">}</span>

          <span class="s2">case </span><span class="s1">REACT_PORTAL_TYPE:</span>
            <span class="s1">{</span>
              <span class="s2">if </span><span class="s1">(newChild.key === key) {</span>
                <span class="s2">return </span><span class="s1">updatePortal(returnFiber, oldFiber, newChild, lanes);</span>
              <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s2">return null</span><span class="s1">;</span>
              <span class="s1">}</span>
            <span class="s1">}</span>

          <span class="s2">case </span><span class="s1">REACT_LAZY_TYPE:</span>
            <span class="s1">{</span>
              <span class="s2">var </span><span class="s1">payload = newChild._payload;</span>
              <span class="s2">var </span><span class="s1">init = newChild._init;</span>
              <span class="s2">return </span><span class="s1">updateSlot(returnFiber, oldFiber, init(payload), lanes);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(isArray(newChild) || getIteratorFn(newChild)) {</span>
          <span class="s2">if </span><span class="s1">(key !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">return null</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s2">return </span><span class="s1">updateFragment(returnFiber, oldFiber, newChild, lanes, </span><span class="s2">null</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s1">throwOnInvalidObjectType(returnFiber, newChild);</span>
      <span class="s1">}</span>

      <span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">newChild === </span><span class="s3">'function'</span><span class="s1">) {</span>
          <span class="s1">warnOnFunctionType(returnFiber);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">function </span><span class="s1">updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">newChild === </span><span class="s3">'string' </span><span class="s1">&amp;&amp; newChild !== </span><span class="s3">'' </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">newChild === </span><span class="s3">'number'</span><span class="s1">) {</span>
        <span class="s0">// Text nodes don't have keys, so we neither have to check the old nor</span>
        <span class="s0">// new node for the key. If both are text nodes, they match.</span>
        <span class="s2">var </span><span class="s1">matchedFiber = existingChildren.get(newIdx) || </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s2">return </span><span class="s1">updateTextNode(returnFiber, matchedFiber, </span><span class="s3">'' </span><span class="s1">+ newChild, lanes);</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">newChild === </span><span class="s3">'object' </span><span class="s1">&amp;&amp; newChild !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">switch </span><span class="s1">(newChild.$$typeof) {</span>
          <span class="s2">case </span><span class="s1">REACT_ELEMENT_TYPE:</span>
            <span class="s1">{</span>
              <span class="s2">var </span><span class="s1">_matchedFiber = existingChildren.get(newChild.key === </span><span class="s2">null </span><span class="s1">? newIdx : newChild.key) || </span><span class="s2">null</span><span class="s1">;</span>

              <span class="s2">return </span><span class="s1">updateElement(returnFiber, _matchedFiber, newChild, lanes);</span>
            <span class="s1">}</span>

          <span class="s2">case </span><span class="s1">REACT_PORTAL_TYPE:</span>
            <span class="s1">{</span>
              <span class="s2">var </span><span class="s1">_matchedFiber2 = existingChildren.get(newChild.key === </span><span class="s2">null </span><span class="s1">? newIdx : newChild.key) || </span><span class="s2">null</span><span class="s1">;</span>

              <span class="s2">return </span><span class="s1">updatePortal(returnFiber, _matchedFiber2, newChild, lanes);</span>
            <span class="s1">}</span>

          <span class="s2">case </span><span class="s1">REACT_LAZY_TYPE:</span>
            <span class="s2">var </span><span class="s1">payload = newChild._payload;</span>
            <span class="s2">var </span><span class="s1">init = newChild._init;</span>
            <span class="s2">return </span><span class="s1">updateFromMap(existingChildren, returnFiber, newIdx, init(payload), lanes);</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(isArray(newChild) || getIteratorFn(newChild)) {</span>
          <span class="s2">var </span><span class="s1">_matchedFiber3 = existingChildren.get(newIdx) || </span><span class="s2">null</span><span class="s1">;</span>

          <span class="s2">return </span><span class="s1">updateFragment(returnFiber, _matchedFiber3, newChild, lanes, </span><span class="s2">null</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s1">throwOnInvalidObjectType(returnFiber, newChild);</span>
      <span class="s1">}</span>

      <span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">newChild === </span><span class="s3">'function'</span><span class="s1">) {</span>
          <span class="s1">warnOnFunctionType(returnFiber);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/** 
     * Warns if there is a duplicate or missing key 
     */</span>


    <span class="s2">function </span><span class="s1">warnOnInvalidKey(child, knownKeys, returnFiber) {</span>
      <span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">child !== </span><span class="s3">'object' </span><span class="s1">|| child === </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s2">return </span><span class="s1">knownKeys;</span>
        <span class="s1">}</span>

        <span class="s2">switch </span><span class="s1">(child.$$typeof) {</span>
          <span class="s2">case </span><span class="s1">REACT_ELEMENT_TYPE:</span>
          <span class="s2">case </span><span class="s1">REACT_PORTAL_TYPE:</span>
            <span class="s1">warnForMissingKey(child, returnFiber);</span>
            <span class="s2">var </span><span class="s1">key = child.key;</span>

            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">key !== </span><span class="s3">'string'</span><span class="s1">) {</span>
              <span class="s2">break</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s2">if </span><span class="s1">(knownKeys === </span><span class="s2">null</span><span class="s1">) {</span>
              <span class="s1">knownKeys = </span><span class="s2">new </span><span class="s1">Set();</span>
              <span class="s1">knownKeys.add(key);</span>
              <span class="s2">break</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s2">if </span><span class="s1">(!knownKeys.has(key)) {</span>
              <span class="s1">knownKeys.add(key);</span>
              <span class="s2">break</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s1">error(</span><span class="s3">'Encountered two children with the same key, `%s`. ' </span><span class="s1">+ </span><span class="s3">'Keys should be unique so that components maintain their identity ' </span><span class="s1">+ </span><span class="s3">'across updates. Non-unique keys may cause children to be ' </span><span class="s1">+ </span><span class="s3">'duplicated and/or omitted  the behavior is unsupported and ' </span><span class="s1">+ </span><span class="s3">'could change in a future version.'</span><span class="s1">, key);</span>

            <span class="s2">break</span><span class="s1">;</span>

          <span class="s2">case </span><span class="s1">REACT_LAZY_TYPE:</span>
            <span class="s2">var </span><span class="s1">payload = child._payload;</span>
            <span class="s2">var </span><span class="s1">init = child._init;</span>
            <span class="s1">warnOnInvalidKey(init(payload), knownKeys, returnFiber);</span>
            <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">return </span><span class="s1">knownKeys;</span>
    <span class="s1">}</span>

    <span class="s2">function </span><span class="s1">reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {</span>
      <span class="s0">// This algorithm can't optimize by searching from both ends since we</span>
      <span class="s0">// don't have backpointers on fibers. I'm trying to see how far we can get</span>
      <span class="s0">// with that model. If it ends up not being worth the tradeoffs, we can</span>
      <span class="s0">// add it later.</span>
      <span class="s0">// Even with a two ended optimization, we'd want to optimize for the case</span>
      <span class="s0">// where there are few changes and brute force the comparison instead of</span>
      <span class="s0">// going for the Map. It'd like to explore hitting that path first in</span>
      <span class="s0">// forward-only mode and only go for the Map once we notice that we need</span>
      <span class="s0">// lots of look ahead. This doesn't handle reversal as well as two ended</span>
      <span class="s0">// search but that's unusual. Besides, for the two ended optimization to</span>
      <span class="s0">// work on Iterables, we'd need to copy the whole set.</span>
      <span class="s0">// In this first iteration, we'll just live with hitting the bad case</span>
      <span class="s0">// (adding everything to a Map) in for every insert/move.</span>
      <span class="s0">// If you change this code, also update reconcileChildrenIterator() which</span>
      <span class="s0">// uses the same algorithm.</span>
      <span class="s1">{</span>
        <span class="s0">// First, validate keys.</span>
        <span class="s2">var </span><span class="s1">knownKeys = </span><span class="s2">null</span><span class="s1">;</span>

        <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; newChildren.length; i++) {</span>
          <span class="s2">var </span><span class="s1">child = newChildren[i];</span>
          <span class="s1">knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">resultingFirstChild = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s2">var </span><span class="s1">previousNewFiber = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s2">var </span><span class="s1">oldFiber = currentFirstChild;</span>
      <span class="s2">var </span><span class="s1">lastPlacedIndex = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s2">var </span><span class="s1">newIdx = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s2">var </span><span class="s1">nextOldFiber = </span><span class="s2">null</span><span class="s1">;</span>

      <span class="s2">for </span><span class="s1">(; oldFiber !== </span><span class="s2">null </span><span class="s1">&amp;&amp; newIdx &lt; newChildren.length; newIdx++) {</span>
        <span class="s2">if </span><span class="s1">(oldFiber.index &gt; newIdx) {</span>
          <span class="s1">nextOldFiber = oldFiber;</span>
          <span class="s1">oldFiber = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">nextOldFiber = oldFiber.sibling;</span>
        <span class="s1">}</span>

        <span class="s2">var </span><span class="s1">newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);</span>

        <span class="s2">if </span><span class="s1">(newFiber === </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s0">// TODO: This breaks on empty slots like null children. That's</span>
          <span class="s0">// unfortunate because it triggers the slow path all the time. We need</span>
          <span class="s0">// a better way to communicate whether this was a miss or null,</span>
          <span class="s0">// boolean, undefined, etc.</span>
          <span class="s2">if </span><span class="s1">(oldFiber === </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">oldFiber = nextOldFiber;</span>
          <span class="s1">}</span>

          <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(shouldTrackSideEffects) {</span>
          <span class="s2">if </span><span class="s1">(oldFiber &amp;&amp; newFiber.alternate === </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s0">// We matched the slot, but we didn't reuse the existing fiber, so we</span>
            <span class="s0">// need to delete the existing child.</span>
            <span class="s1">deleteChild(returnFiber, oldFiber);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s1">lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);</span>

        <span class="s2">if </span><span class="s1">(previousNewFiber === </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s0">// TODO: Move out of the loop. This only happens for the first run.</span>
          <span class="s1">resultingFirstChild = newFiber;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s0">// TODO: Defer siblings if we're not at the right index for this slot.</span>
          <span class="s0">// I.e. if we had null values before, then we want to defer this</span>
          <span class="s0">// for each null value. However, we also don't want to call updateSlot</span>
          <span class="s0">// with the previous one.</span>
          <span class="s1">previousNewFiber.sibling = newFiber;</span>
        <span class="s1">}</span>

        <span class="s1">previousNewFiber = newFiber;</span>
        <span class="s1">oldFiber = nextOldFiber;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(newIdx === newChildren.length) {</span>
        <span class="s0">// We've reached the end of the new children. We can delete the rest.</span>
        <span class="s1">deleteRemainingChildren(returnFiber, oldFiber);</span>

        <span class="s2">return </span><span class="s1">resultingFirstChild;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(oldFiber === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s0">// If we don't have any more existing children we can choose a fast path</span>
        <span class="s0">// since the rest will all be insertions.</span>
        <span class="s2">for </span><span class="s1">(; newIdx &lt; newChildren.length; newIdx++) {</span>
          <span class="s2">var </span><span class="s1">_newFiber = createChild(returnFiber, newChildren[newIdx], lanes);</span>

          <span class="s2">if </span><span class="s1">(_newFiber === </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">continue</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s1">lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);</span>

          <span class="s2">if </span><span class="s1">(previousNewFiber === </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s0">// TODO: Move out of the loop. This only happens for the first run.</span>
            <span class="s1">resultingFirstChild = _newFiber;</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">previousNewFiber.sibling = _newFiber;</span>
          <span class="s1">}</span>

          <span class="s1">previousNewFiber = _newFiber;</span>
        <span class="s1">}</span>

        <span class="s2">return </span><span class="s1">resultingFirstChild;</span>
      <span class="s1">} </span><span class="s0">// Add all children to a key map for quick lookups.</span>


      <span class="s2">var </span><span class="s1">existingChildren = mapRemainingChildren(returnFiber, oldFiber); </span><span class="s0">// Keep scanning and use the map to restore deleted items as moves.</span>

      <span class="s2">for </span><span class="s1">(; newIdx &lt; newChildren.length; newIdx++) {</span>
        <span class="s2">var </span><span class="s1">_newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes);</span>

        <span class="s2">if </span><span class="s1">(_newFiber2 !== </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s2">if </span><span class="s1">(shouldTrackSideEffects) {</span>
            <span class="s2">if </span><span class="s1">(_newFiber2.alternate !== </span><span class="s2">null</span><span class="s1">) {</span>
              <span class="s0">// The new fiber is a work in progress, but if there exists a</span>
              <span class="s0">// current, that means that we reused the fiber. We need to delete</span>
              <span class="s0">// it from the child list so that we don't add it to the deletion</span>
              <span class="s0">// list.</span>
              <span class="s1">existingChildren.</span><span class="s2">delete</span><span class="s1">(_newFiber2.key === </span><span class="s2">null </span><span class="s1">? newIdx : _newFiber2.key);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s1">lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);</span>

          <span class="s2">if </span><span class="s1">(previousNewFiber === </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">resultingFirstChild = _newFiber2;</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">previousNewFiber.sibling = _newFiber2;</span>
          <span class="s1">}</span>

          <span class="s1">previousNewFiber = _newFiber2;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(shouldTrackSideEffects) {</span>
        <span class="s0">// Any existing children that weren't consumed above were deleted. We need</span>
        <span class="s0">// to add them to the deletion list.</span>
        <span class="s1">existingChildren.forEach(</span><span class="s2">function </span><span class="s1">(child) {</span>
          <span class="s2">return </span><span class="s1">deleteChild(returnFiber, child);</span>
        <span class="s1">});</span>
      <span class="s1">}</span>

      <span class="s2">return </span><span class="s1">resultingFirstChild;</span>
    <span class="s1">}</span>

    <span class="s2">function </span><span class="s1">reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, lanes) {</span>
      <span class="s0">// This is the same implementation as reconcileChildrenArray(),</span>
      <span class="s0">// but using the iterator instead.</span>
      <span class="s2">var </span><span class="s1">iteratorFn = getIteratorFn(newChildrenIterable);</span>

      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">iteratorFn !== </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'An object is not an iterable. This error is likely caused by a bug in ' </span><span class="s1">+ </span><span class="s3">'React. Please file an issue.'</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s1">{</span>
        <span class="s0">// We don't support rendering Generators because it's a mutation.</span>
        <span class="s0">// See https://github.com/facebook/react/issues/12995</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">Symbol === </span><span class="s3">'function' </span><span class="s1">&amp;&amp; </span><span class="s0">// $FlowFixMe Flow doesn't know about toStringTag</span>
        <span class="s1">newChildrenIterable[Symbol.toStringTag] === </span><span class="s3">'Generator'</span><span class="s1">) {</span>
          <span class="s2">if </span><span class="s1">(!didWarnAboutGenerators) {</span>
            <span class="s1">error(</span><span class="s3">'Using Generators as children is unsupported and will likely yield ' </span><span class="s1">+ </span><span class="s3">'unexpected results because enumerating a generator mutates it. ' </span><span class="s1">+ </span><span class="s3">'You may convert it to an array with `Array.from()` or the ' </span><span class="s1">+ </span><span class="s3">'`[...spread]` operator before rendering. Keep in mind ' </span><span class="s1">+ </span><span class="s3">'you might need to polyfill these features for older browsers.'</span><span class="s1">);</span>
          <span class="s1">}</span>

          <span class="s1">didWarnAboutGenerators = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s0">// Warn about using Maps as children</span>


        <span class="s2">if </span><span class="s1">(newChildrenIterable.entries === iteratorFn) {</span>
          <span class="s2">if </span><span class="s1">(!didWarnAboutMaps) {</span>
            <span class="s1">error(</span><span class="s3">'Using Maps as children is not supported. ' </span><span class="s1">+ </span><span class="s3">'Use an array of keyed ReactElements instead.'</span><span class="s1">);</span>
          <span class="s1">}</span>

          <span class="s1">didWarnAboutMaps = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s0">// First, validate keys.</span>
        <span class="s0">// We'll get a different iterator later for the main pass.</span>


        <span class="s2">var </span><span class="s1">_newChildren = iteratorFn.call(newChildrenIterable);</span>

        <span class="s2">if </span><span class="s1">(_newChildren) {</span>
          <span class="s2">var </span><span class="s1">knownKeys = </span><span class="s2">null</span><span class="s1">;</span>

          <span class="s2">var </span><span class="s1">_step = _newChildren.next();</span>

          <span class="s2">for </span><span class="s1">(; !_step.done; _step = _newChildren.next()) {</span>
            <span class="s2">var </span><span class="s1">child = _step.value;</span>
            <span class="s1">knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">newChildren = iteratorFn.call(newChildrenIterable);</span>

      <span class="s2">if </span><span class="s1">(newChildren == </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'An iterable object provided no iterator.'</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">resultingFirstChild = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s2">var </span><span class="s1">previousNewFiber = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s2">var </span><span class="s1">oldFiber = currentFirstChild;</span>
      <span class="s2">var </span><span class="s1">lastPlacedIndex = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s2">var </span><span class="s1">newIdx = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s2">var </span><span class="s1">nextOldFiber = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s2">var </span><span class="s1">step = newChildren.next();</span>

      <span class="s2">for </span><span class="s1">(; oldFiber !== </span><span class="s2">null </span><span class="s1">&amp;&amp; !step.done; newIdx++, step = newChildren.next()) {</span>
        <span class="s2">if </span><span class="s1">(oldFiber.index &gt; newIdx) {</span>
          <span class="s1">nextOldFiber = oldFiber;</span>
          <span class="s1">oldFiber = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">nextOldFiber = oldFiber.sibling;</span>
        <span class="s1">}</span>

        <span class="s2">var </span><span class="s1">newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);</span>

        <span class="s2">if </span><span class="s1">(newFiber === </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s0">// TODO: This breaks on empty slots like null children. That's</span>
          <span class="s0">// unfortunate because it triggers the slow path all the time. We need</span>
          <span class="s0">// a better way to communicate whether this was a miss or null,</span>
          <span class="s0">// boolean, undefined, etc.</span>
          <span class="s2">if </span><span class="s1">(oldFiber === </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">oldFiber = nextOldFiber;</span>
          <span class="s1">}</span>

          <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(shouldTrackSideEffects) {</span>
          <span class="s2">if </span><span class="s1">(oldFiber &amp;&amp; newFiber.alternate === </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s0">// We matched the slot, but we didn't reuse the existing fiber, so we</span>
            <span class="s0">// need to delete the existing child.</span>
            <span class="s1">deleteChild(returnFiber, oldFiber);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s1">lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);</span>

        <span class="s2">if </span><span class="s1">(previousNewFiber === </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s0">// TODO: Move out of the loop. This only happens for the first run.</span>
          <span class="s1">resultingFirstChild = newFiber;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s0">// TODO: Defer siblings if we're not at the right index for this slot.</span>
          <span class="s0">// I.e. if we had null values before, then we want to defer this</span>
          <span class="s0">// for each null value. However, we also don't want to call updateSlot</span>
          <span class="s0">// with the previous one.</span>
          <span class="s1">previousNewFiber.sibling = newFiber;</span>
        <span class="s1">}</span>

        <span class="s1">previousNewFiber = newFiber;</span>
        <span class="s1">oldFiber = nextOldFiber;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(step.done) {</span>
        <span class="s0">// We've reached the end of the new children. We can delete the rest.</span>
        <span class="s1">deleteRemainingChildren(returnFiber, oldFiber);</span>

        <span class="s2">return </span><span class="s1">resultingFirstChild;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(oldFiber === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s0">// If we don't have any more existing children we can choose a fast path</span>
        <span class="s0">// since the rest will all be insertions.</span>
        <span class="s2">for </span><span class="s1">(; !step.done; newIdx++, step = newChildren.next()) {</span>
          <span class="s2">var </span><span class="s1">_newFiber3 = createChild(returnFiber, step.value, lanes);</span>

          <span class="s2">if </span><span class="s1">(_newFiber3 === </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">continue</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s1">lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);</span>

          <span class="s2">if </span><span class="s1">(previousNewFiber === </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s0">// TODO: Move out of the loop. This only happens for the first run.</span>
            <span class="s1">resultingFirstChild = _newFiber3;</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">previousNewFiber.sibling = _newFiber3;</span>
          <span class="s1">}</span>

          <span class="s1">previousNewFiber = _newFiber3;</span>
        <span class="s1">}</span>

        <span class="s2">return </span><span class="s1">resultingFirstChild;</span>
      <span class="s1">} </span><span class="s0">// Add all children to a key map for quick lookups.</span>


      <span class="s2">var </span><span class="s1">existingChildren = mapRemainingChildren(returnFiber, oldFiber); </span><span class="s0">// Keep scanning and use the map to restore deleted items as moves.</span>

      <span class="s2">for </span><span class="s1">(; !step.done; newIdx++, step = newChildren.next()) {</span>
        <span class="s2">var </span><span class="s1">_newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, lanes);</span>

        <span class="s2">if </span><span class="s1">(_newFiber4 !== </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s2">if </span><span class="s1">(shouldTrackSideEffects) {</span>
            <span class="s2">if </span><span class="s1">(_newFiber4.alternate !== </span><span class="s2">null</span><span class="s1">) {</span>
              <span class="s0">// The new fiber is a work in progress, but if there exists a</span>
              <span class="s0">// current, that means that we reused the fiber. We need to delete</span>
              <span class="s0">// it from the child list so that we don't add it to the deletion</span>
              <span class="s0">// list.</span>
              <span class="s1">existingChildren.</span><span class="s2">delete</span><span class="s1">(_newFiber4.key === </span><span class="s2">null </span><span class="s1">? newIdx : _newFiber4.key);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s1">lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);</span>

          <span class="s2">if </span><span class="s1">(previousNewFiber === </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">resultingFirstChild = _newFiber4;</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">previousNewFiber.sibling = _newFiber4;</span>
          <span class="s1">}</span>

          <span class="s1">previousNewFiber = _newFiber4;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(shouldTrackSideEffects) {</span>
        <span class="s0">// Any existing children that weren't consumed above were deleted. We need</span>
        <span class="s0">// to add them to the deletion list.</span>
        <span class="s1">existingChildren.forEach(</span><span class="s2">function </span><span class="s1">(child) {</span>
          <span class="s2">return </span><span class="s1">deleteChild(returnFiber, child);</span>
        <span class="s1">});</span>
      <span class="s1">}</span>

      <span class="s2">return </span><span class="s1">resultingFirstChild;</span>
    <span class="s1">}</span>

    <span class="s2">function </span><span class="s1">reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, lanes) {</span>
      <span class="s0">// There's no need to check for keys on text nodes since we don't have a</span>
      <span class="s0">// way to define them.</span>
      <span class="s2">if </span><span class="s1">(currentFirstChild !== </span><span class="s2">null </span><span class="s1">&amp;&amp; currentFirstChild.tag === HostText) {</span>
        <span class="s0">// We already have an existing node so let's just update it and delete</span>
        <span class="s0">// the rest.</span>
        <span class="s1">deleteRemainingChildren(returnFiber, currentFirstChild.sibling);</span>
        <span class="s2">var </span><span class="s1">existing = useFiber(currentFirstChild, textContent);</span>
        <span class="s1">existing.</span><span class="s2">return </span><span class="s1">= returnFiber;</span>
        <span class="s2">return </span><span class="s1">existing;</span>
      <span class="s1">} </span><span class="s0">// The existing first child is not a text node so we need to create one</span>
      <span class="s0">// and delete the existing ones.</span>


      <span class="s1">deleteRemainingChildren(returnFiber, currentFirstChild);</span>
      <span class="s2">var </span><span class="s1">created = createFiberFromText(textContent, returnFiber.mode, lanes);</span>
      <span class="s1">created.</span><span class="s2">return </span><span class="s1">= returnFiber;</span>
      <span class="s2">return </span><span class="s1">created;</span>
    <span class="s1">}</span>

    <span class="s2">function </span><span class="s1">reconcileSingleElement(returnFiber, currentFirstChild, element, lanes) {</span>
      <span class="s2">var </span><span class="s1">key = element.key;</span>
      <span class="s2">var </span><span class="s1">child = currentFirstChild;</span>

      <span class="s2">while </span><span class="s1">(child !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s0">// TODO: If key === null and child.key === null, then this only applies to</span>
        <span class="s0">// the first item in the list.</span>
        <span class="s2">if </span><span class="s1">(child.key === key) {</span>
          <span class="s2">var </span><span class="s1">elementType = element.type;</span>

          <span class="s2">if </span><span class="s1">(elementType === REACT_FRAGMENT_TYPE) {</span>
            <span class="s2">if </span><span class="s1">(child.tag === Fragment) {</span>
              <span class="s1">deleteRemainingChildren(returnFiber, child.sibling);</span>
              <span class="s2">var </span><span class="s1">existing = useFiber(child, element.props.children);</span>
              <span class="s1">existing.</span><span class="s2">return </span><span class="s1">= returnFiber;</span>

              <span class="s1">{</span>
                <span class="s1">existing._debugSource = element._source;</span>
                <span class="s1">existing._debugOwner = element._owner;</span>
              <span class="s1">}</span>

              <span class="s2">return </span><span class="s1">existing;</span>
            <span class="s1">}</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s2">if </span><span class="s1">(child.elementType === elementType || ( </span><span class="s0">// Keep this check inline so it only runs on the false path:</span>
             <span class="s1">isCompatibleFamilyForHotReloading(child, element) ) || </span><span class="s0">// Lazy types should reconcile their resolved type.</span>
            <span class="s0">// We need to do this after the Hot Reloading check above,</span>
            <span class="s0">// because hot reloading has different semantics than prod because</span>
            <span class="s0">// it doesn't resuspend. So we can't let the call below suspend.</span>
            <span class="s2">typeof </span><span class="s1">elementType === </span><span class="s3">'object' </span><span class="s1">&amp;&amp; elementType !== </span><span class="s2">null </span><span class="s1">&amp;&amp; elementType.$$typeof === REACT_LAZY_TYPE &amp;&amp; resolveLazy(elementType) === child.type) {</span>
              <span class="s1">deleteRemainingChildren(returnFiber, child.sibling);</span>

              <span class="s2">var </span><span class="s1">_existing = useFiber(child, element.props);</span>

              <span class="s1">_existing.ref = coerceRef(returnFiber, child, element);</span>
              <span class="s1">_existing.</span><span class="s2">return </span><span class="s1">= returnFiber;</span>

              <span class="s1">{</span>
                <span class="s1">_existing._debugSource = element._source;</span>
                <span class="s1">_existing._debugOwner = element._owner;</span>
              <span class="s1">}</span>

              <span class="s2">return </span><span class="s1">_existing;</span>
            <span class="s1">}</span>
          <span class="s1">} </span><span class="s0">// Didn't match.</span>


          <span class="s1">deleteRemainingChildren(returnFiber, child);</span>
          <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">deleteChild(returnFiber, child);</span>
        <span class="s1">}</span>

        <span class="s1">child = child.sibling;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(element.type === REACT_FRAGMENT_TYPE) {</span>
        <span class="s2">var </span><span class="s1">created = createFiberFromFragment(element.props.children, returnFiber.mode, lanes, element.key);</span>
        <span class="s1">created.</span><span class="s2">return </span><span class="s1">= returnFiber;</span>
        <span class="s2">return </span><span class="s1">created;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">var </span><span class="s1">_created4 = createFiberFromElement(element, returnFiber.mode, lanes);</span>

        <span class="s1">_created4.ref = coerceRef(returnFiber, currentFirstChild, element);</span>
        <span class="s1">_created4.</span><span class="s2">return </span><span class="s1">= returnFiber;</span>
        <span class="s2">return </span><span class="s1">_created4;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">function </span><span class="s1">reconcileSinglePortal(returnFiber, currentFirstChild, portal, lanes) {</span>
      <span class="s2">var </span><span class="s1">key = portal.key;</span>
      <span class="s2">var </span><span class="s1">child = currentFirstChild;</span>

      <span class="s2">while </span><span class="s1">(child !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s0">// TODO: If key === null and child.key === null, then this only applies to</span>
        <span class="s0">// the first item in the list.</span>
        <span class="s2">if </span><span class="s1">(child.key === key) {</span>
          <span class="s2">if </span><span class="s1">(child.tag === HostPortal &amp;&amp; child.stateNode.containerInfo === portal.containerInfo &amp;&amp; child.stateNode.implementation === portal.implementation) {</span>
            <span class="s1">deleteRemainingChildren(returnFiber, child.sibling);</span>
            <span class="s2">var </span><span class="s1">existing = useFiber(child, portal.children || []);</span>
            <span class="s1">existing.</span><span class="s2">return </span><span class="s1">= returnFiber;</span>
            <span class="s2">return </span><span class="s1">existing;</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">deleteRemainingChildren(returnFiber, child);</span>
            <span class="s2">break</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">deleteChild(returnFiber, child);</span>
        <span class="s1">}</span>

        <span class="s1">child = child.sibling;</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">created = createFiberFromPortal(portal, returnFiber.mode, lanes);</span>
      <span class="s1">created.</span><span class="s2">return </span><span class="s1">= returnFiber;</span>
      <span class="s2">return </span><span class="s1">created;</span>
    <span class="s1">} </span><span class="s0">// This API will tag the children with the side-effect of the reconciliation</span>
    <span class="s0">// itself. They will be added to the side-effect list as we pass through the</span>
    <span class="s0">// children and the parent.</span>


    <span class="s2">function </span><span class="s1">reconcileChildFibers(returnFiber, currentFirstChild, newChild, lanes) {</span>
      <span class="s0">// This function is not recursive.</span>
      <span class="s0">// If the top level item is an array, we treat it as a set of children,</span>
      <span class="s0">// not as a fragment. Nested arrays on the other hand will be treated as</span>
      <span class="s0">// fragment nodes. Recursion happens at the normal flow.</span>
      <span class="s0">// Handle top level unkeyed fragments as if they were arrays.</span>
      <span class="s0">// This leads to an ambiguity between &lt;&gt;{[...]}&lt;/&gt; and &lt;&gt;...&lt;/&gt;.</span>
      <span class="s0">// We treat the ambiguous cases above the same.</span>
      <span class="s2">var </span><span class="s1">isUnkeyedTopLevelFragment = </span><span class="s2">typeof </span><span class="s1">newChild === </span><span class="s3">'object' </span><span class="s1">&amp;&amp; newChild !== </span><span class="s2">null </span><span class="s1">&amp;&amp; newChild.type === REACT_FRAGMENT_TYPE &amp;&amp; newChild.key === </span><span class="s2">null</span><span class="s1">;</span>

      <span class="s2">if </span><span class="s1">(isUnkeyedTopLevelFragment) {</span>
        <span class="s1">newChild = newChild.props.children;</span>
      <span class="s1">} </span><span class="s0">// Handle object types</span>


      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">newChild === </span><span class="s3">'object' </span><span class="s1">&amp;&amp; newChild !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">switch </span><span class="s1">(newChild.$$typeof) {</span>
          <span class="s2">case </span><span class="s1">REACT_ELEMENT_TYPE:</span>
            <span class="s2">return </span><span class="s1">placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes));</span>

          <span class="s2">case </span><span class="s1">REACT_PORTAL_TYPE:</span>
            <span class="s2">return </span><span class="s1">placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));</span>

          <span class="s2">case </span><span class="s1">REACT_LAZY_TYPE:</span>
            <span class="s2">var </span><span class="s1">payload = newChild._payload;</span>
            <span class="s2">var </span><span class="s1">init = newChild._init; </span><span class="s0">// TODO: This function is supposed to be non-recursive.</span>

            <span class="s2">return </span><span class="s1">reconcileChildFibers(returnFiber, currentFirstChild, init(payload), lanes);</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(isArray(newChild)) {</span>
          <span class="s2">return </span><span class="s1">reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(getIteratorFn(newChild)) {</span>
          <span class="s2">return </span><span class="s1">reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);</span>
        <span class="s1">}</span>

        <span class="s1">throwOnInvalidObjectType(returnFiber, newChild);</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">newChild === </span><span class="s3">'string' </span><span class="s1">&amp;&amp; newChild !== </span><span class="s3">'' </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">newChild === </span><span class="s3">'number'</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, </span><span class="s3">'' </span><span class="s1">+ newChild, lanes));</span>
      <span class="s1">}</span>

      <span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">newChild === </span><span class="s3">'function'</span><span class="s1">) {</span>
          <span class="s1">warnOnFunctionType(returnFiber);</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s0">// Remaining cases are all treated as empty.</span>


      <span class="s2">return </span><span class="s1">deleteRemainingChildren(returnFiber, currentFirstChild);</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">reconcileChildFibers;</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">reconcileChildFibers = ChildReconciler(</span><span class="s2">true</span><span class="s1">);</span>
  <span class="s2">var </span><span class="s1">mountChildFibers = ChildReconciler(</span><span class="s2">false</span><span class="s1">);</span>
  <span class="s2">function </span><span class="s1">cloneChildFibers(current, workInProgress) {</span>
    <span class="s2">if </span><span class="s1">(current !== </span><span class="s2">null </span><span class="s1">&amp;&amp; workInProgress.child !== current.child) {</span>
      <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Resuming work not yet implemented.'</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(workInProgress.child === </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">currentChild = workInProgress.child;</span>
    <span class="s2">var </span><span class="s1">newChild = createWorkInProgress(currentChild, currentChild.pendingProps);</span>
    <span class="s1">workInProgress.child = newChild;</span>
    <span class="s1">newChild.</span><span class="s2">return </span><span class="s1">= workInProgress;</span>

    <span class="s2">while </span><span class="s1">(currentChild.sibling !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">currentChild = currentChild.sibling;</span>
      <span class="s1">newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps);</span>
      <span class="s1">newChild.</span><span class="s2">return </span><span class="s1">= workInProgress;</span>
    <span class="s1">}</span>

    <span class="s1">newChild.sibling = </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s0">// Reset a workInProgress child set to prepare it for a second pass.</span>

  <span class="s2">function </span><span class="s1">resetChildFibers(workInProgress, lanes) {</span>
    <span class="s2">var </span><span class="s1">child = workInProgress.child;</span>

    <span class="s2">while </span><span class="s1">(child !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">resetWorkInProgress(child, lanes);</span>
      <span class="s1">child = child.sibling;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">NO_CONTEXT$1 = {};</span>
  <span class="s2">var </span><span class="s1">contextStackCursor$1 = createCursor(NO_CONTEXT$1);</span>
  <span class="s2">var </span><span class="s1">contextFiberStackCursor = createCursor(NO_CONTEXT$1);</span>
  <span class="s2">var </span><span class="s1">rootInstanceStackCursor = createCursor(NO_CONTEXT$1);</span>

  <span class="s2">function </span><span class="s1">requiredContext(c) {</span>
    <span class="s2">if </span><span class="s1">(c === NO_CONTEXT$1) {</span>
      <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Expected host context to exist. This error is likely caused by a bug ' </span><span class="s1">+ </span><span class="s3">'in React. Please file an issue.'</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">c;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">getRootHostContainer() {</span>
    <span class="s2">var </span><span class="s1">rootInstance = requiredContext(rootInstanceStackCursor.current);</span>
    <span class="s2">return </span><span class="s1">rootInstance;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">pushHostContainer(fiber, nextRootInstance) {</span>
    <span class="s0">// Push current root instance onto the stack;</span>
    <span class="s0">// This allows us to reset root when portals are popped.</span>
    <span class="s1">push(rootInstanceStackCursor, nextRootInstance, fiber); </span><span class="s0">// Track the context and the Fiber that provided it.</span>
    <span class="s0">// This enables us to pop only Fibers that provide unique contexts.</span>

    <span class="s1">push(contextFiberStackCursor, fiber, fiber); </span><span class="s0">// Finally, we need to push the host context to the stack.</span>
    <span class="s0">// However, we can't just call getRootHostContext() and push it because</span>
    <span class="s0">// we'd have a different number of entries on the stack depending on</span>
    <span class="s0">// whether getRootHostContext() throws somewhere in renderer code or not.</span>
    <span class="s0">// So we push an empty value first. This lets us safely unwind on errors.</span>

    <span class="s1">push(contextStackCursor$1, NO_CONTEXT$1, fiber);</span>
    <span class="s2">var </span><span class="s1">nextRootContext = getRootHostContext(); </span><span class="s0">// Now that we know this function doesn't throw, replace it.</span>

    <span class="s1">pop(contextStackCursor$1, fiber);</span>
    <span class="s1">push(contextStackCursor$1, nextRootContext, fiber);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">popHostContainer(fiber) {</span>
    <span class="s1">pop(contextStackCursor$1, fiber);</span>
    <span class="s1">pop(contextFiberStackCursor, fiber);</span>
    <span class="s1">pop(rootInstanceStackCursor, fiber);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">getHostContext() {</span>
    <span class="s2">var </span><span class="s1">context = requiredContext(contextStackCursor$1.current);</span>
    <span class="s2">return </span><span class="s1">context;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">pushHostContext(fiber) {</span>
    <span class="s2">var </span><span class="s1">rootInstance = requiredContext(rootInstanceStackCursor.current);</span>
    <span class="s2">var </span><span class="s1">context = requiredContext(contextStackCursor$1.current);</span>
    <span class="s2">var </span><span class="s1">nextContext = getChildHostContext(context, fiber.type); </span><span class="s0">// Don't push this Fiber's context unless it's unique.</span>

    <span class="s2">if </span><span class="s1">(context === nextContext) {</span>
      <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s0">// Track the context and the Fiber that provided it.</span>
    <span class="s0">// This enables us to pop only Fibers that provide unique contexts.</span>


    <span class="s1">push(contextFiberStackCursor, fiber, fiber);</span>
    <span class="s1">push(contextStackCursor$1, nextContext, fiber);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">popHostContext(fiber) {</span>
    <span class="s0">// Do not pop unless this Fiber provided the current context.</span>
    <span class="s0">// pushHostContext() only pushes Fibers that provide unique contexts.</span>
    <span class="s2">if </span><span class="s1">(contextFiberStackCursor.current !== fiber) {</span>
      <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">pop(contextStackCursor$1, fiber);</span>
    <span class="s1">pop(contextFiberStackCursor, fiber);</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">DefaultSuspenseContext = </span><span class="s4">0</span><span class="s1">; </span><span class="s0">// The Suspense Context is split into two parts. The lower bits is</span>
  <span class="s0">// inherited deeply down the subtree. The upper bits only affect</span>
  <span class="s0">// this immediate suspense boundary and gets reset each new</span>
  <span class="s0">// boundary or suspense list.</span>

  <span class="s2">var </span><span class="s1">SubtreeSuspenseContextMask = </span><span class="s4">1</span><span class="s1">; </span><span class="s0">// Subtree Flags:</span>
  <span class="s0">// InvisibleParentSuspenseContext indicates that one of our parent Suspense</span>
  <span class="s0">// boundaries is not currently showing visible main content.</span>
  <span class="s0">// Either because it is already showing a fallback or is not mounted at all.</span>
  <span class="s0">// We can use this to determine if it is desirable to trigger a fallback at</span>
  <span class="s0">// the parent. If not, then we might need to trigger undesirable boundaries</span>
  <span class="s0">// and/or suspend the commit to avoid hiding the parent content.</span>

  <span class="s2">var </span><span class="s1">InvisibleParentSuspenseContext = </span><span class="s4">1</span><span class="s1">; </span><span class="s0">// Shallow Flags:</span>
  <span class="s0">// ForceSuspenseFallback can be used by SuspenseList to force newly added</span>
  <span class="s0">// items into their fallback state during one of the render passes.</span>

  <span class="s2">var </span><span class="s1">ForceSuspenseFallback = </span><span class="s4">2</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">suspenseStackCursor = createCursor(DefaultSuspenseContext);</span>
  <span class="s2">function </span><span class="s1">hasSuspenseContext(parentContext, flag) {</span>
    <span class="s2">return </span><span class="s1">(parentContext &amp; flag) !== </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">setDefaultShallowSuspenseContext(parentContext) {</span>
    <span class="s2">return </span><span class="s1">parentContext &amp; SubtreeSuspenseContextMask;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">setShallowSuspenseContext(parentContext, shallowContext) {</span>
    <span class="s2">return </span><span class="s1">parentContext &amp; SubtreeSuspenseContextMask | shallowContext;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">addSubtreeSuspenseContext(parentContext, subtreeContext) {</span>
    <span class="s2">return </span><span class="s1">parentContext | subtreeContext;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">pushSuspenseContext(fiber, newContext) {</span>
    <span class="s1">push(suspenseStackCursor, newContext, fiber);</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">popSuspenseContext(fiber) {</span>
    <span class="s1">pop(suspenseStackCursor, fiber);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">shouldCaptureSuspense(workInProgress, hasInvisibleParent) {</span>
    <span class="s0">// If it was the primary children that just suspended, capture and render the</span>
    <span class="s0">// fallback. Otherwise, don't capture and bubble to the next boundary.</span>
    <span class="s2">var </span><span class="s1">nextState = workInProgress.memoizedState;</span>

    <span class="s2">if </span><span class="s1">(nextState !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(nextState.dehydrated !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s0">// A dehydrated boundary always captures.</span>
        <span class="s2">return true</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">props = workInProgress.memoizedProps; </span><span class="s0">// Regular boundaries always capture.</span>

    <span class="s1">{</span>
      <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s0">// If it's a boundary we should avoid, then we prefer to bubble up to the</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">findFirstSuspended(row) {</span>
    <span class="s2">var </span><span class="s1">node = row;</span>

    <span class="s2">while </span><span class="s1">(node !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(node.tag === SuspenseComponent) {</span>
        <span class="s2">var </span><span class="s1">state = node.memoizedState;</span>

        <span class="s2">if </span><span class="s1">(state !== </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s2">var </span><span class="s1">dehydrated = state.dehydrated;</span>

          <span class="s2">if </span><span class="s1">(dehydrated === </span><span class="s2">null </span><span class="s1">|| isSuspenseInstancePending() || isSuspenseInstanceFallback()) {</span>
            <span class="s2">return </span><span class="s1">node;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(node.tag === SuspenseListComponent &amp;&amp; </span><span class="s0">// revealOrder undefined can't be trusted because it don't</span>
      <span class="s0">// keep track of whether it suspended or not.</span>
      <span class="s1">node.memoizedProps.revealOrder !== undefined) {</span>
        <span class="s2">var </span><span class="s1">didSuspend = (node.flags &amp; DidCapture) !== NoFlags;</span>

        <span class="s2">if </span><span class="s1">(didSuspend) {</span>
          <span class="s2">return </span><span class="s1">node;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(node.child !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">node.child.</span><span class="s2">return </span><span class="s1">= node;</span>
        <span class="s1">node = node.child;</span>
        <span class="s2">continue</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(node === row) {</span>
        <span class="s2">return null</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">while </span><span class="s1">(node.sibling === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(node.</span><span class="s2">return </span><span class="s1">=== </span><span class="s2">null </span><span class="s1">|| node.</span><span class="s2">return </span><span class="s1">=== row) {</span>
          <span class="s2">return null</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">node = node.</span><span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">node.sibling.</span><span class="s2">return </span><span class="s1">= node.</span><span class="s2">return</span><span class="s1">;</span>
      <span class="s1">node = node.sibling;</span>
    <span class="s1">}</span>

    <span class="s2">return null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">NoFlags$1 =</span>
  <span class="s0">/*   */</span>
  <span class="s4">0</span><span class="s1">; </span><span class="s0">// Represents whether effect should fire.</span>

  <span class="s2">var </span><span class="s1">HasEffect =</span>
  <span class="s0">/* */</span>
  <span class="s4">1</span><span class="s1">; </span><span class="s0">// Represents the phase in which the effect (not the clean-up) fires.</span>

  <span class="s2">var </span><span class="s1">Insertion =</span>
  <span class="s0">/*  */</span>
  <span class="s4">2</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">Layout =</span>
  <span class="s0">/*    */</span>
  <span class="s4">4</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">Passive$1 =</span>
  <span class="s0">/*   */</span>
  <span class="s4">8</span><span class="s1">;</span>

  <span class="s0">// and should be reset before starting a new render.</span>
  <span class="s0">// This tracks which mutable sources need to be reset after a render.</span>

  <span class="s2">var </span><span class="s1">workInProgressSources = [];</span>
  <span class="s2">function </span><span class="s1">resetWorkInProgressVersions() {</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; workInProgressSources.length; i++) {</span>
      <span class="s2">var </span><span class="s1">mutableSource = workInProgressSources[i];</span>

      <span class="s1">{</span>
        <span class="s1">mutableSource._workInProgressVersionSecondary = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">workInProgressSources.length = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher,</span>
      <span class="s1">ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig;</span>
  <span class="s2">var </span><span class="s1">didWarnAboutMismatchedHooksForComponent;</span>
  <span class="s2">var </span><span class="s1">didWarnUncachedGetSnapshot;</span>

  <span class="s1">{</span>
    <span class="s1">didWarnAboutMismatchedHooksForComponent = </span><span class="s2">new </span><span class="s1">Set();</span>
  <span class="s1">}</span>

  <span class="s0">// These are set right before calling the component.</span>
  <span class="s2">var </span><span class="s1">renderLanes = NoLanes; </span><span class="s0">// The work-in-progress fiber. I've named it differently to distinguish it from</span>
  <span class="s0">// the work-in-progress hook.</span>

  <span class="s2">var </span><span class="s1">currentlyRenderingFiber$1 = </span><span class="s2">null</span><span class="s1">; </span><span class="s0">// Hooks are stored as a linked list on the fiber's memoizedState field. The</span>
  <span class="s0">// current hook list is the list that belongs to the current fiber. The</span>
  <span class="s0">// work-in-progress hook list is a new list that will be added to the</span>
  <span class="s0">// work-in-progress fiber.</span>

  <span class="s2">var </span><span class="s1">currentHook = </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">workInProgressHook = </span><span class="s2">null</span><span class="s1">; </span><span class="s0">// Whether an update was scheduled at any point during the render phase. This</span>
  <span class="s0">// does not get reset if we do another render pass; only when we're completely</span>
  <span class="s0">// finished evaluating this component. This is an optimization so we know</span>
  <span class="s0">// whether we need to clear render phase updates after a throw.</span>

  <span class="s2">var </span><span class="s1">didScheduleRenderPhaseUpdate = </span><span class="s2">false</span><span class="s1">; </span><span class="s0">// Where an update was scheduled only during the current render pass. This</span>
  <span class="s0">// gets reset after each attempt.</span>
  <span class="s0">// TODO: Maybe there's some way to consolidate this with</span>
  <span class="s0">// `didScheduleRenderPhaseUpdate`. Or with `numberOfReRenders`.</span>

  <span class="s2">var </span><span class="s1">didScheduleRenderPhaseUpdateDuringThisPass = </span><span class="s2">false</span><span class="s1">; </span><span class="s0">// Counts the number of useId hooks in this component.</span>
  <span class="s0">// hydration). This counter is global, so client ids are not stable across</span>
  <span class="s0">// render attempts.</span>

  <span class="s2">var </span><span class="s1">globalClientIdCounter = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">RE_RENDER_LIMIT = </span><span class="s4">25</span><span class="s1">; </span><span class="s0">// In DEV, this is the name of the currently executing primitive hook</span>

  <span class="s2">var </span><span class="s1">currentHookNameInDev = </span><span class="s2">null</span><span class="s1">; </span><span class="s0">// In DEV, this list ensures that hooks are called in the same order between renders.</span>
  <span class="s0">// The list stores the order of hooks used during the initial render (mount).</span>
  <span class="s0">// Subsequent renders (updates) reference this list.</span>

  <span class="s2">var </span><span class="s1">hookTypesDev = </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">hookTypesUpdateIndexDev = -</span><span class="s4">1</span><span class="s1">; </span><span class="s0">// In DEV, this tracks whether currently rendering component needs to ignore</span>
  <span class="s0">// the dependencies for Hooks that need them (e.g. useEffect or useMemo).</span>
  <span class="s0">// When true, such Hooks will always be &quot;remounted&quot;. Only used during hot reload.</span>

  <span class="s2">var </span><span class="s1">ignorePreviousDependencies = </span><span class="s2">false</span><span class="s1">;</span>

  <span class="s2">function </span><span class="s1">mountHookTypesDev() {</span>
    <span class="s1">{</span>
      <span class="s2">var </span><span class="s1">hookName = currentHookNameInDev;</span>

      <span class="s2">if </span><span class="s1">(hookTypesDev === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">hookTypesDev = [hookName];</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">hookTypesDev.push(hookName);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">updateHookTypesDev() {</span>
    <span class="s1">{</span>
      <span class="s2">var </span><span class="s1">hookName = currentHookNameInDev;</span>

      <span class="s2">if </span><span class="s1">(hookTypesDev !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">hookTypesUpdateIndexDev++;</span>

        <span class="s2">if </span><span class="s1">(hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {</span>
          <span class="s1">warnOnHookMismatchInDev(hookName);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">checkDepsAreArrayDev(deps) {</span>
    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(deps !== undefined &amp;&amp; deps !== </span><span class="s2">null </span><span class="s1">&amp;&amp; !isArray(deps)) {</span>
        <span class="s0">// Verify deps, but only on mount to avoid extra checks.</span>
        <span class="s0">// It's unlikely their type would change as usually you define them inline.</span>
        <span class="s1">error(</span><span class="s3">'%s received a final argument that is not an array (instead, received `%s`). When ' </span><span class="s1">+ </span><span class="s3">'specified, the final argument must be an array.'</span><span class="s1">, currentHookNameInDev, </span><span class="s2">typeof </span><span class="s1">deps);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">warnOnHookMismatchInDev(currentHookName) {</span>
    <span class="s1">{</span>
      <span class="s2">var </span><span class="s1">componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);</span>

      <span class="s2">if </span><span class="s1">(!didWarnAboutMismatchedHooksForComponent.has(componentName)) {</span>
        <span class="s1">didWarnAboutMismatchedHooksForComponent.add(componentName);</span>

        <span class="s2">if </span><span class="s1">(hookTypesDev !== </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s2">var </span><span class="s1">table = </span><span class="s3">''</span><span class="s1">;</span>
          <span class="s2">var </span><span class="s1">secondColumnStart = </span><span class="s4">30</span><span class="s1">;</span>

          <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt;= hookTypesUpdateIndexDev; i++) {</span>
            <span class="s2">var </span><span class="s1">oldHookName = hookTypesDev[i];</span>
            <span class="s2">var </span><span class="s1">newHookName = i === hookTypesUpdateIndexDev ? currentHookName : oldHookName;</span>
            <span class="s2">var </span><span class="s1">row = i + </span><span class="s4">1 </span><span class="s1">+ </span><span class="s3">&quot;. &quot; </span><span class="s1">+ oldHookName; </span><span class="s0">// Extra space so second column lines up</span>
            <span class="s0">// lol @ IE not supporting String#repeat</span>

            <span class="s2">while </span><span class="s1">(row.length &lt; secondColumnStart) {</span>
              <span class="s1">row += </span><span class="s3">' '</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s1">row += newHookName + </span><span class="s3">'</span><span class="s5">\n</span><span class="s3">'</span><span class="s1">;</span>
            <span class="s1">table += row;</span>
          <span class="s1">}</span>

          <span class="s1">error(</span><span class="s3">'React has detected a change in the order of Hooks called by %s. ' </span><span class="s1">+ </span><span class="s3">'This will lead to bugs and errors if not fixed. ' </span><span class="s1">+ </span><span class="s3">'For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks</span><span class="s5">\n\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">'   Previous render            Next render</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">'   ------------------------------------------------------</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">'%s' </span><span class="s1">+ </span><span class="s3">'   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span><span class="s5">\n</span><span class="s3">'</span><span class="s1">, componentName, table);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">throwInvalidHookError() {</span>
    <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' </span><span class="s1">+ </span><span class="s3">' one of the following reasons:</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">'1. You might have mismatching versions of React and the renderer (such as React DOM)</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">'2. You might be breaking the Rules of Hooks</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">'3. You might have more than one copy of React in the same app</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.'</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">areHookInputsEqual(nextDeps, prevDeps) {</span>
    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(ignorePreviousDependencies) {</span>
        <span class="s0">// Only true when this component is being hot reloaded.</span>
        <span class="s2">return false</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(prevDeps === </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">{</span>
        <span class="s1">error(</span><span class="s3">'%s received a final argument during this render, but not during ' </span><span class="s1">+ </span><span class="s3">'the previous render. Even though the final argument is optional, ' </span><span class="s1">+ </span><span class="s3">'its type cannot change between renders.'</span><span class="s1">, currentHookNameInDev);</span>
      <span class="s1">}</span>

      <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s0">// Don't bother comparing lengths in prod because these arrays should be</span>
      <span class="s0">// passed inline.</span>
      <span class="s2">if </span><span class="s1">(nextDeps.length !== prevDeps.length) {</span>
        <span class="s1">error(</span><span class="s3">'The final argument passed to %s changed size between renders. The ' </span><span class="s1">+ </span><span class="s3">'order and size of this array must remain constant.</span><span class="s5">\n\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">'Previous: %s</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">'Incoming: %s'</span><span class="s1">, currentHookNameInDev, </span><span class="s3">&quot;[&quot; </span><span class="s1">+ prevDeps.join(</span><span class="s3">', '</span><span class="s1">) + </span><span class="s3">&quot;]&quot;</span><span class="s1">, </span><span class="s3">&quot;[&quot; </span><span class="s1">+ nextDeps.join(</span><span class="s3">', '</span><span class="s1">) + </span><span class="s3">&quot;]&quot;</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; prevDeps.length &amp;&amp; i &lt; nextDeps.length; i++) {</span>
      <span class="s2">if </span><span class="s1">(objectIs(nextDeps[i], prevDeps[i])) {</span>
        <span class="s2">continue</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">return true</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">renderWithHooks(current, workInProgress, Component, props, secondArg, nextRenderLanes) {</span>
    <span class="s1">renderLanes = nextRenderLanes;</span>
    <span class="s1">currentlyRenderingFiber$1 = workInProgress;</span>

    <span class="s1">{</span>
      <span class="s1">hookTypesDev = current !== </span><span class="s2">null </span><span class="s1">? current._debugHookTypes : </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">hookTypesUpdateIndexDev = -</span><span class="s4">1</span><span class="s1">; </span><span class="s0">// Used for hot reloading:</span>

      <span class="s1">ignorePreviousDependencies = current !== </span><span class="s2">null </span><span class="s1">&amp;&amp; current.type !== workInProgress.type;</span>
    <span class="s1">}</span>

    <span class="s1">workInProgress.memoizedState = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">workInProgress.updateQueue = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">workInProgress.lanes = NoLanes; </span><span class="s0">// The following should have already been reset</span>
    <span class="s0">// currentHook = null;</span>
    <span class="s0">// workInProgressHook = null;</span>
    <span class="s0">// didScheduleRenderPhaseUpdate = false;</span>
    <span class="s0">// localIdCounter = 0;</span>
    <span class="s0">// TODO Warn if no hooks are used at all during mount, then some are used during update.</span>
    <span class="s0">// Currently we will identify the update render as a mount because memoizedState === null.</span>
    <span class="s0">// This is tricky because it's valid for certain types of components (e.g. React.lazy)</span>
    <span class="s0">// Using memoizedState to differentiate between mount/update only works if at least one stateful hook is used.</span>
    <span class="s0">// Non-stateful hooks (e.g. context) don't get added to memoizedState,</span>
    <span class="s0">// so memoizedState would be null during updates and mounts.</span>

    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(current !== </span><span class="s2">null </span><span class="s1">&amp;&amp; current.memoizedState !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">ReactCurrentDispatcher$1.current = HooksDispatcherOnUpdateInDEV;</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(hookTypesDev !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s0">// This dispatcher handles an edge case where a component is updating,</span>
        <span class="s0">// but no stateful hooks have been used.</span>
        <span class="s0">// We want to match the production code behavior (which will use HooksDispatcherOnMount),</span>
        <span class="s0">// but with the extra DEV validation to ensure hooks ordering hasn't changed.</span>
        <span class="s0">// This dispatcher does that.</span>
        <span class="s1">ReactCurrentDispatcher$1.current = HooksDispatcherOnMountWithHookTypesInDEV;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">ReactCurrentDispatcher$1.current = HooksDispatcherOnMountInDEV;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">children = Component(props, secondArg); </span><span class="s0">// Check if there was a render phase update</span>

    <span class="s2">if </span><span class="s1">(didScheduleRenderPhaseUpdateDuringThisPass) {</span>
      <span class="s0">// Keep rendering in a loop for as long as render phase updates continue to</span>
      <span class="s0">// be scheduled. Use a counter to prevent infinite loops.</span>
      <span class="s2">var </span><span class="s1">numberOfReRenders = </span><span class="s4">0</span><span class="s1">;</span>

      <span class="s2">do </span><span class="s1">{</span>
        <span class="s1">didScheduleRenderPhaseUpdateDuringThisPass = </span><span class="s2">false</span><span class="s1">;</span>

        <span class="s2">if </span><span class="s1">(numberOfReRenders &gt;= RE_RENDER_LIMIT) {</span>
          <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Too many re-renders. React limits the number of renders to prevent ' </span><span class="s1">+ </span><span class="s3">'an infinite loop.'</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s1">numberOfReRenders += </span><span class="s4">1</span><span class="s1">;</span>

        <span class="s1">{</span>
          <span class="s0">// Even when hot reloading, allow dependencies to stabilize</span>
          <span class="s0">// after first render to prevent infinite render phase updates.</span>
          <span class="s1">ignorePreviousDependencies = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s0">// Start over from the beginning of the list</span>


        <span class="s1">currentHook = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s1">workInProgressHook = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s1">workInProgress.updateQueue = </span><span class="s2">null</span><span class="s1">;</span>

        <span class="s1">{</span>
          <span class="s0">// Also validate hook order for cascading updates.</span>
          <span class="s1">hookTypesUpdateIndexDev = -</span><span class="s4">1</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">ReactCurrentDispatcher$1.current =  HooksDispatcherOnRerenderInDEV ;</span>
        <span class="s1">children = Component(props, secondArg);</span>
      <span class="s1">} </span><span class="s2">while </span><span class="s1">(didScheduleRenderPhaseUpdateDuringThisPass);</span>
    <span class="s1">} </span><span class="s0">// We can assume the previous dispatcher is always this one, since we set it</span>
    <span class="s0">// at the beginning of the render phase and there's no re-entrance.</span>


    <span class="s1">ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;</span>

    <span class="s1">{</span>
      <span class="s1">workInProgress._debugHookTypes = hookTypesDev;</span>
    <span class="s1">} </span><span class="s0">// This check uses currentHook so that it works the same in DEV and prod bundles.</span>
    <span class="s0">// hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.</span>


    <span class="s2">var </span><span class="s1">didRenderTooFewHooks = currentHook !== </span><span class="s2">null </span><span class="s1">&amp;&amp; currentHook.next !== </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">renderLanes = NoLanes;</span>
    <span class="s1">currentlyRenderingFiber$1 = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">currentHook = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">workInProgressHook = </span><span class="s2">null</span><span class="s1">;</span>

    <span class="s1">{</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">hookTypesDev = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">hookTypesUpdateIndexDev = -</span><span class="s4">1</span><span class="s1">; </span><span class="s0">// Confirm that a static flag was not added or removed since the last</span>
      <span class="s0">// render. If this fires, it suggests that we incorrectly reset the static</span>
      <span class="s0">// flags in some other part of the codebase. This has happened before, for</span>
      <span class="s0">// example, in the SuspenseList implementation.</span>

      <span class="s2">if </span><span class="s1">(current !== </span><span class="s2">null </span><span class="s1">&amp;&amp; (current.flags &amp; StaticMask) !== (workInProgress.flags &amp; StaticMask) &amp;&amp; </span><span class="s0">// Disable this warning in legacy mode, because legacy Suspense is weird</span>
      <span class="s0">// and creates false positives. To make this work in legacy mode, we'd</span>
      <span class="s0">// need to mark fibers that commit in an incomplete state, somehow. For</span>
      <span class="s0">// now I'll disable the warning that most of the bugs that would trigger</span>
      <span class="s0">// it are either exclusive to concurrent mode or exist in both.</span>
      <span class="s1">(current.mode &amp; ConcurrentMode) !== NoMode) {</span>
        <span class="s1">error(</span><span class="s3">'Internal React error: Expected static flag was missing. Please ' </span><span class="s1">+ </span><span class="s3">'notify the React team.'</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">didScheduleRenderPhaseUpdate = </span><span class="s2">false</span><span class="s1">; </span><span class="s0">// This is reset by checkDidRenderIdHook</span>
    <span class="s0">// localIdCounter = 0;</span>

    <span class="s2">if </span><span class="s1">(didRenderTooFewHooks) {</span>
      <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Rendered fewer hooks than expected. This may be caused by an accidental ' </span><span class="s1">+ </span><span class="s3">'early return statement.'</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">children;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">bailoutHooks(current, workInProgress, lanes) {</span>
    <span class="s1">workInProgress.updateQueue = current.updateQueue; </span><span class="s0">// TODO: Don't need to reset the flags here, because they're reset in the</span>
    <span class="s0">// complete phase (bubbleProperties).</span>

    <span class="s1">{</span>
      <span class="s1">workInProgress.flags &amp;= ~(Passive | Update);</span>
    <span class="s1">}</span>

    <span class="s1">current.lanes = removeLanes(current.lanes, lanes);</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">resetHooksAfterThrow() {</span>
    <span class="s0">// We can assume the previous dispatcher is always this one, since we set it</span>
    <span class="s0">// at the beginning of the render phase and there's no re-entrance.</span>
    <span class="s1">ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;</span>

    <span class="s2">if </span><span class="s1">(didScheduleRenderPhaseUpdate) {</span>
      <span class="s0">// There were render phase updates. These are only valid for this render</span>
      <span class="s0">// phase, which we are now aborting. Remove the updates from the queues so</span>
      <span class="s0">// they do not persist to the next render. Do not remove updates from hooks</span>
      <span class="s0">// that weren't processed.</span>
      <span class="s0">//</span>
      <span class="s0">// Only reset the updates from the queue if it has a clone. If it does</span>
      <span class="s0">// not have a clone, that means it wasn't processed, and the updates were</span>
      <span class="s0">// scheduled before we entered the render phase.</span>
      <span class="s2">var </span><span class="s1">hook = currentlyRenderingFiber$1.memoizedState;</span>

      <span class="s2">while </span><span class="s1">(hook !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">var </span><span class="s1">queue = hook.queue;</span>

        <span class="s2">if </span><span class="s1">(queue !== </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">queue.pending = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">hook = hook.next;</span>
      <span class="s1">}</span>

      <span class="s1">didScheduleRenderPhaseUpdate = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">renderLanes = NoLanes;</span>
    <span class="s1">currentlyRenderingFiber$1 = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">currentHook = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">workInProgressHook = </span><span class="s2">null</span><span class="s1">;</span>

    <span class="s1">{</span>
      <span class="s1">hookTypesDev = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">hookTypesUpdateIndexDev = -</span><span class="s4">1</span><span class="s1">;</span>
      <span class="s1">currentHookNameInDev = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">isUpdatingOpaqueValueInRenderPhase = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">didScheduleRenderPhaseUpdateDuringThisPass = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">mountWorkInProgressHook() {</span>
    <span class="s2">var </span><span class="s1">hook = {</span>
      <span class="s1">memoizedState: </span><span class="s2">null</span><span class="s1">,</span>
      <span class="s1">baseState: </span><span class="s2">null</span><span class="s1">,</span>
      <span class="s1">baseQueue: </span><span class="s2">null</span><span class="s1">,</span>
      <span class="s1">queue: </span><span class="s2">null</span><span class="s1">,</span>
      <span class="s1">next: </span><span class="s2">null</span>
    <span class="s1">};</span>

    <span class="s2">if </span><span class="s1">(workInProgressHook === </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s0">// This is the first hook in the list</span>
      <span class="s1">currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s0">// Append to the end of the list</span>
      <span class="s1">workInProgressHook = workInProgressHook.next = hook;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">workInProgressHook;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">updateWorkInProgressHook() {</span>
    <span class="s0">// This function is used both for updates and for re-renders triggered by a</span>
    <span class="s0">// render phase update. It assumes there is either a current hook we can</span>
    <span class="s0">// clone, or a work-in-progress hook from a previous render pass that we can</span>
    <span class="s0">// use as a base. When we reach the end of the base list, we must switch to</span>
    <span class="s0">// the dispatcher used for mounts.</span>
    <span class="s2">var </span><span class="s1">nextCurrentHook;</span>

    <span class="s2">if </span><span class="s1">(currentHook === </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">current = currentlyRenderingFiber$1.alternate;</span>

      <span class="s2">if </span><span class="s1">(current !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">nextCurrentHook = current.memoizedState;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">nextCurrentHook = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">nextCurrentHook = currentHook.next;</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">nextWorkInProgressHook;</span>

    <span class="s2">if </span><span class="s1">(workInProgressHook === </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">nextWorkInProgressHook = currentlyRenderingFiber$1.memoizedState;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">nextWorkInProgressHook = workInProgressHook.next;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(nextWorkInProgressHook !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s0">// There's already a work-in-progress. Reuse it.</span>
      <span class="s1">workInProgressHook = nextWorkInProgressHook;</span>
      <span class="s1">nextWorkInProgressHook = workInProgressHook.next;</span>
      <span class="s1">currentHook = nextCurrentHook;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s0">// Clone from the current hook.</span>
      <span class="s2">if </span><span class="s1">(nextCurrentHook === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Rendered more hooks than during the previous render.'</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s1">currentHook = nextCurrentHook;</span>
      <span class="s2">var </span><span class="s1">newHook = {</span>
        <span class="s1">memoizedState: currentHook.memoizedState,</span>
        <span class="s1">baseState: currentHook.baseState,</span>
        <span class="s1">baseQueue: currentHook.baseQueue,</span>
        <span class="s1">queue: currentHook.queue,</span>
        <span class="s1">next: </span><span class="s2">null</span>
      <span class="s1">};</span>

      <span class="s2">if </span><span class="s1">(workInProgressHook === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s0">// This is the first hook in the list.</span>
        <span class="s1">currentlyRenderingFiber$1.memoizedState = workInProgressHook = newHook;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s0">// Append to the end of the list.</span>
        <span class="s1">workInProgressHook = workInProgressHook.next = newHook;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">workInProgressHook;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">createFunctionComponentUpdateQueue() {</span>
    <span class="s2">return </span><span class="s1">{</span>
      <span class="s1">lastEffect: </span><span class="s2">null</span><span class="s1">,</span>
      <span class="s1">stores: </span><span class="s2">null</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">basicStateReducer(state, action) {</span>
    <span class="s0">// $FlowFixMe: Flow doesn't like mixed types</span>
    <span class="s2">return typeof </span><span class="s1">action === </span><span class="s3">'function' </span><span class="s1">? action(state) : action;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">mountReducer(reducer, initialArg, init) {</span>
    <span class="s2">var </span><span class="s1">hook = mountWorkInProgressHook();</span>
    <span class="s2">var </span><span class="s1">initialState;</span>

    <span class="s2">if </span><span class="s1">(init !== undefined) {</span>
      <span class="s1">initialState = init(initialArg);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">initialState = initialArg;</span>
    <span class="s1">}</span>

    <span class="s1">hook.memoizedState = hook.baseState = initialState;</span>
    <span class="s2">var </span><span class="s1">queue = {</span>
      <span class="s1">pending: </span><span class="s2">null</span><span class="s1">,</span>
      <span class="s1">interleaved: </span><span class="s2">null</span><span class="s1">,</span>
      <span class="s1">lanes: NoLanes,</span>
      <span class="s1">dispatch: </span><span class="s2">null</span><span class="s1">,</span>
      <span class="s1">lastRenderedReducer: reducer,</span>
      <span class="s1">lastRenderedState: initialState</span>
    <span class="s1">};</span>
    <span class="s1">hook.queue = queue;</span>
    <span class="s2">var </span><span class="s1">dispatch = queue.dispatch = dispatchReducerAction.bind(</span><span class="s2">null</span><span class="s1">, currentlyRenderingFiber$1, queue);</span>
    <span class="s2">return </span><span class="s1">[hook.memoizedState, dispatch];</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">updateReducer(reducer, initialArg, init) {</span>
    <span class="s2">var </span><span class="s1">hook = updateWorkInProgressHook();</span>
    <span class="s2">var </span><span class="s1">queue = hook.queue;</span>

    <span class="s2">if </span><span class="s1">(queue === </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Should have a queue. This is likely a bug in React. Please file an issue.'</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s1">queue.lastRenderedReducer = reducer;</span>
    <span class="s2">var </span><span class="s1">current = currentHook; </span><span class="s0">// The last rebase update that is NOT part of the base state.</span>

    <span class="s2">var </span><span class="s1">baseQueue = current.baseQueue; </span><span class="s0">// The last pending update that hasn't been processed yet.</span>

    <span class="s2">var </span><span class="s1">pendingQueue = queue.pending;</span>

    <span class="s2">if </span><span class="s1">(pendingQueue !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s0">// We have new updates that haven't been processed yet.</span>
      <span class="s0">// We'll add them to the base queue.</span>
      <span class="s2">if </span><span class="s1">(baseQueue !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s0">// Merge the pending queue and the base queue.</span>
        <span class="s2">var </span><span class="s1">baseFirst = baseQueue.next;</span>
        <span class="s2">var </span><span class="s1">pendingFirst = pendingQueue.next;</span>
        <span class="s1">baseQueue.next = pendingFirst;</span>
        <span class="s1">pendingQueue.next = baseFirst;</span>
      <span class="s1">}</span>

      <span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(current.baseQueue !== baseQueue) {</span>
          <span class="s0">// Internal invariant that should never happen, but feasibly could in</span>
          <span class="s0">// the future if we implement resuming, or some form of that.</span>
          <span class="s1">error(</span><span class="s3">'Internal error: Expected work-in-progress queue to be a clone. ' </span><span class="s1">+ </span><span class="s3">'This is a bug in React.'</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">current.baseQueue = baseQueue = pendingQueue;</span>
      <span class="s1">queue.pending = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(baseQueue !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s0">// We have a queue to process.</span>
      <span class="s2">var </span><span class="s1">first = baseQueue.next;</span>
      <span class="s2">var </span><span class="s1">newState = current.baseState;</span>
      <span class="s2">var </span><span class="s1">newBaseState = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s2">var </span><span class="s1">newBaseQueueFirst = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s2">var </span><span class="s1">newBaseQueueLast = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s2">var </span><span class="s1">update = first;</span>

      <span class="s2">do </span><span class="s1">{</span>
        <span class="s2">var </span><span class="s1">updateLane = update.lane;</span>

        <span class="s2">if </span><span class="s1">(!isSubsetOfLanes(renderLanes, updateLane)) {</span>
          <span class="s0">// Priority is insufficient. Skip this update. If this is the first</span>
          <span class="s0">// skipped update, the previous update/state is the new base</span>
          <span class="s0">// update/state.</span>
          <span class="s2">var </span><span class="s1">clone = {</span>
            <span class="s1">lane: updateLane,</span>
            <span class="s1">action: update.action,</span>
            <span class="s1">hasEagerState: update.hasEagerState,</span>
            <span class="s1">eagerState: update.eagerState,</span>
            <span class="s1">next: </span><span class="s2">null</span>
          <span class="s1">};</span>

          <span class="s2">if </span><span class="s1">(newBaseQueueLast === </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">newBaseQueueFirst = newBaseQueueLast = clone;</span>
            <span class="s1">newBaseState = newState;</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">newBaseQueueLast = newBaseQueueLast.next = clone;</span>
          <span class="s1">} </span><span class="s0">// Update the remaining priority in the queue.</span>
          <span class="s0">// TODO: Don't need to accumulate this. Instead, we can remove</span>
          <span class="s0">// renderLanes from the original lanes.</span>


          <span class="s1">currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, updateLane);</span>
          <span class="s1">markSkippedUpdateLanes(updateLane);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s0">// This update does have sufficient priority.</span>
          <span class="s2">if </span><span class="s1">(newBaseQueueLast !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">var </span><span class="s1">_clone = {</span>
              <span class="s0">// This update is going to be committed so we never want uncommit</span>
              <span class="s0">// it. Using NoLane works because 0 is a subset of all bitmasks, so</span>
              <span class="s0">// this will never be skipped by the check above.</span>
              <span class="s1">lane: NoLane,</span>
              <span class="s1">action: update.action,</span>
              <span class="s1">hasEagerState: update.hasEagerState,</span>
              <span class="s1">eagerState: update.eagerState,</span>
              <span class="s1">next: </span><span class="s2">null</span>
            <span class="s1">};</span>
            <span class="s1">newBaseQueueLast = newBaseQueueLast.next = _clone;</span>
          <span class="s1">} </span><span class="s0">// Process this update.</span>


          <span class="s2">if </span><span class="s1">(update.hasEagerState) {</span>
            <span class="s0">// If this update is a state update (not a reducer) and was processed eagerly,</span>
            <span class="s0">// we can use the eagerly computed state</span>
            <span class="s1">newState = update.eagerState;</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s2">var </span><span class="s1">action = update.action;</span>
            <span class="s1">newState = reducer(newState, action);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s1">update = update.next;</span>
      <span class="s1">} </span><span class="s2">while </span><span class="s1">(update !== </span><span class="s2">null </span><span class="s1">&amp;&amp; update !== first);</span>

      <span class="s2">if </span><span class="s1">(newBaseQueueLast === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">newBaseState = newState;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">newBaseQueueLast.next = newBaseQueueFirst;</span>
      <span class="s1">} </span><span class="s0">// Mark that the fiber performed work, but only if the new state is</span>
      <span class="s0">// different from the current state.</span>


      <span class="s2">if </span><span class="s1">(!objectIs(newState, hook.memoizedState)) {</span>
        <span class="s1">markWorkInProgressReceivedUpdate();</span>
      <span class="s1">}</span>

      <span class="s1">hook.memoizedState = newState;</span>
      <span class="s1">hook.baseState = newBaseState;</span>
      <span class="s1">hook.baseQueue = newBaseQueueLast;</span>
      <span class="s1">queue.lastRenderedState = newState;</span>
    <span class="s1">} </span><span class="s0">// Interleaved updates are stored on a separate queue. We aren't going to</span>
    <span class="s0">// process them during this render, but we do need to track which lanes</span>
    <span class="s0">// are remaining.</span>


    <span class="s2">var </span><span class="s1">lastInterleaved = queue.interleaved;</span>

    <span class="s2">if </span><span class="s1">(lastInterleaved !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">interleaved = lastInterleaved;</span>

      <span class="s2">do </span><span class="s1">{</span>
        <span class="s2">var </span><span class="s1">interleavedLane = interleaved.lane;</span>
        <span class="s1">currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, interleavedLane);</span>
        <span class="s1">markSkippedUpdateLanes(interleavedLane);</span>
        <span class="s1">interleaved = interleaved.next;</span>
      <span class="s1">} </span><span class="s2">while </span><span class="s1">(interleaved !== lastInterleaved);</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(baseQueue === </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s0">// `queue.lanes` is used for entangling transitions. We can set it back to</span>
      <span class="s0">// zero once the queue is empty.</span>
      <span class="s1">queue.lanes = NoLanes;</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">dispatch = queue.dispatch;</span>
    <span class="s2">return </span><span class="s1">[hook.memoizedState, dispatch];</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">rerenderReducer(reducer, initialArg, init) {</span>
    <span class="s2">var </span><span class="s1">hook = updateWorkInProgressHook();</span>
    <span class="s2">var </span><span class="s1">queue = hook.queue;</span>

    <span class="s2">if </span><span class="s1">(queue === </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Should have a queue. This is likely a bug in React. Please file an issue.'</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s1">queue.lastRenderedReducer = reducer; </span><span class="s0">// This is a re-render. Apply the new render phase updates to the previous</span>
    <span class="s0">// work-in-progress hook.</span>

    <span class="s2">var </span><span class="s1">dispatch = queue.dispatch;</span>
    <span class="s2">var </span><span class="s1">lastRenderPhaseUpdate = queue.pending;</span>
    <span class="s2">var </span><span class="s1">newState = hook.memoizedState;</span>

    <span class="s2">if </span><span class="s1">(lastRenderPhaseUpdate !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s0">// The queue doesn't persist past this render pass.</span>
      <span class="s1">queue.pending = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s2">var </span><span class="s1">firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;</span>
      <span class="s2">var </span><span class="s1">update = firstRenderPhaseUpdate;</span>

      <span class="s2">do </span><span class="s1">{</span>
        <span class="s0">// Process this render phase update. We don't have to check the</span>
        <span class="s0">// priority because it will always be the same as the current</span>
        <span class="s0">// render's.</span>
        <span class="s2">var </span><span class="s1">action = update.action;</span>
        <span class="s1">newState = reducer(newState, action);</span>
        <span class="s1">update = update.next;</span>
      <span class="s1">} </span><span class="s2">while </span><span class="s1">(update !== firstRenderPhaseUpdate); </span><span class="s0">// Mark that the fiber performed work, but only if the new state is</span>
      <span class="s0">// different from the current state.</span>


      <span class="s2">if </span><span class="s1">(!objectIs(newState, hook.memoizedState)) {</span>
        <span class="s1">markWorkInProgressReceivedUpdate();</span>
      <span class="s1">}</span>

      <span class="s1">hook.memoizedState = newState; </span><span class="s0">// Don't persist the state accumulated from the render phase updates to</span>
      <span class="s0">// the base state unless the queue is empty.</span>
      <span class="s0">// TODO: Not sure if this is the desired semantics, but it's what we</span>
      <span class="s0">// do for gDSFP. I can't remember why.</span>

      <span class="s2">if </span><span class="s1">(hook.baseQueue === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">hook.baseState = newState;</span>
      <span class="s1">}</span>

      <span class="s1">queue.lastRenderedState = newState;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">[newState, dispatch];</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">mountMutableSource(source, getSnapshot, subscribe) {</span>
    <span class="s1">{</span>
      <span class="s2">return </span><span class="s1">undefined;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">updateMutableSource(source, getSnapshot, subscribe) {</span>
    <span class="s1">{</span>
      <span class="s2">return </span><span class="s1">undefined;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {</span>
    <span class="s2">var </span><span class="s1">fiber = currentlyRenderingFiber$1;</span>
    <span class="s2">var </span><span class="s1">hook = mountWorkInProgressHook();</span>
    <span class="s2">var </span><span class="s1">nextSnapshot;</span>

    <span class="s1">{</span>
      <span class="s1">nextSnapshot = getSnapshot();</span>

      <span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(!didWarnUncachedGetSnapshot) {</span>
          <span class="s2">var </span><span class="s1">cachedSnapshot = getSnapshot();</span>

          <span class="s2">if </span><span class="s1">(!objectIs(nextSnapshot, cachedSnapshot)) {</span>
            <span class="s1">error(</span><span class="s3">'The result of getSnapshot should be cached to avoid an infinite loop'</span><span class="s1">);</span>

            <span class="s1">didWarnUncachedGetSnapshot = </span><span class="s2">true</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s0">// Unless we're rendering a blocking lane, schedule a consistency check.</span>
      <span class="s0">// Right before committing, we will walk the tree and check if any of the</span>
      <span class="s0">// stores were mutated.</span>
      <span class="s0">//</span>
      <span class="s0">// We won't do this if we're hydrating server-rendered content, because if</span>
      <span class="s0">// the content is stale, it's already visible anyway. Instead we'll patch</span>
      <span class="s0">// it up in a passive effect.</span>


      <span class="s2">var </span><span class="s1">root = getWorkInProgressRoot();</span>

      <span class="s2">if </span><span class="s1">(root === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Expected a work-in-progress root. This is a bug in React. Please file an issue.'</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(!includesBlockingLane(root, renderLanes)) {</span>
        <span class="s1">pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// Read the current snapshot from the store on every render. This breaks the</span>
    <span class="s0">// normal rules of React, and only works because store updates are</span>
    <span class="s0">// always synchronous.</span>


    <span class="s1">hook.memoizedState = nextSnapshot;</span>
    <span class="s2">var </span><span class="s1">inst = {</span>
      <span class="s1">value: nextSnapshot,</span>
      <span class="s1">getSnapshot: getSnapshot</span>
    <span class="s1">};</span>
    <span class="s1">hook.queue = inst; </span><span class="s0">// Schedule an effect to subscribe to the store.</span>

    <span class="s1">mountEffect(subscribeToStore.bind(</span><span class="s2">null</span><span class="s1">, fiber, inst, subscribe), [subscribe]); </span><span class="s0">// Schedule an effect to update the mutable instance fields. We will update</span>
    <span class="s0">// this whenever subscribe, getSnapshot, or value changes. Because there's no</span>
    <span class="s0">// clean-up function, and we track the deps correctly, we can call pushEffect</span>
    <span class="s0">// directly, without storing any additional state. For the same reason, we</span>
    <span class="s0">// don't need to set a static flag, either.</span>
    <span class="s0">// TODO: We can move this to the passive phase once we add a pre-commit</span>
    <span class="s0">// consistency check. See the next comment.</span>

    <span class="s1">fiber.flags |= Passive;</span>
    <span class="s1">pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(</span><span class="s2">null</span><span class="s1">, fiber, inst, nextSnapshot, getSnapshot), undefined, </span><span class="s2">null</span><span class="s1">);</span>
    <span class="s2">return </span><span class="s1">nextSnapshot;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {</span>
    <span class="s2">var </span><span class="s1">fiber = currentlyRenderingFiber$1;</span>
    <span class="s2">var </span><span class="s1">hook = updateWorkInProgressHook(); </span><span class="s0">// Read the current snapshot from the store on every render. This breaks the</span>
    <span class="s0">// normal rules of React, and only works because store updates are</span>
    <span class="s0">// always synchronous.</span>

    <span class="s2">var </span><span class="s1">nextSnapshot = getSnapshot();</span>

    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(!didWarnUncachedGetSnapshot) {</span>
        <span class="s2">var </span><span class="s1">cachedSnapshot = getSnapshot();</span>

        <span class="s2">if </span><span class="s1">(!objectIs(nextSnapshot, cachedSnapshot)) {</span>
          <span class="s1">error(</span><span class="s3">'The result of getSnapshot should be cached to avoid an infinite loop'</span><span class="s1">);</span>

          <span class="s1">didWarnUncachedGetSnapshot = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">prevSnapshot = hook.memoizedState;</span>
    <span class="s2">var </span><span class="s1">snapshotChanged = !objectIs(prevSnapshot, nextSnapshot);</span>

    <span class="s2">if </span><span class="s1">(snapshotChanged) {</span>
      <span class="s1">hook.memoizedState = nextSnapshot;</span>
      <span class="s1">markWorkInProgressReceivedUpdate();</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">inst = hook.queue;</span>
    <span class="s1">updateEffect(subscribeToStore.bind(</span><span class="s2">null</span><span class="s1">, fiber, inst, subscribe), [subscribe]); </span><span class="s0">// Whenever getSnapshot or subscribe changes, we need to check in the</span>
    <span class="s0">// commit phase if there was an interleaved mutation. In concurrent mode</span>
    <span class="s0">// this can happen all the time, but even in synchronous mode, an earlier</span>
    <span class="s0">// effect may have mutated the store.</span>

    <span class="s2">if </span><span class="s1">(inst.getSnapshot !== getSnapshot || snapshotChanged || </span><span class="s0">// Check if the susbcribe function changed. We can save some memory by</span>
    <span class="s0">// checking whether we scheduled a subscription effect above.</span>
    <span class="s1">workInProgressHook !== </span><span class="s2">null </span><span class="s1">&amp;&amp; workInProgressHook.memoizedState.tag &amp; HasEffect) {</span>
      <span class="s1">fiber.flags |= Passive;</span>
      <span class="s1">pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(</span><span class="s2">null</span><span class="s1">, fiber, inst, nextSnapshot, getSnapshot), undefined, </span><span class="s2">null</span><span class="s1">); </span><span class="s0">// Unless we're rendering a blocking lane, schedule a consistency check.</span>
      <span class="s0">// Right before committing, we will walk the tree and check if any of the</span>
      <span class="s0">// stores were mutated.</span>

      <span class="s2">var </span><span class="s1">root = getWorkInProgressRoot();</span>

      <span class="s2">if </span><span class="s1">(root === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Expected a work-in-progress root. This is a bug in React. Please file an issue.'</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(!includesBlockingLane(root, renderLanes)) {</span>
        <span class="s1">pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">nextSnapshot;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {</span>
    <span class="s1">fiber.flags |= StoreConsistency;</span>
    <span class="s2">var </span><span class="s1">check = {</span>
      <span class="s1">getSnapshot: getSnapshot,</span>
      <span class="s1">value: renderedSnapshot</span>
    <span class="s1">};</span>
    <span class="s2">var </span><span class="s1">componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;</span>

    <span class="s2">if </span><span class="s1">(componentUpdateQueue === </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">componentUpdateQueue = createFunctionComponentUpdateQueue();</span>
      <span class="s1">currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;</span>
      <span class="s1">componentUpdateQueue.stores = [check];</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">var </span><span class="s1">stores = componentUpdateQueue.stores;</span>

      <span class="s2">if </span><span class="s1">(stores === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">componentUpdateQueue.stores = [check];</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">stores.push(check);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {</span>
    <span class="s0">// These are updated in the passive phase</span>
    <span class="s1">inst.value = nextSnapshot;</span>
    <span class="s1">inst.getSnapshot = getSnapshot; </span><span class="s0">// Something may have been mutated in between render and commit. This could</span>
    <span class="s0">// have been in an event that fired before the passive effects, or it could</span>
    <span class="s0">// have been in a layout effect. In that case, we would have used the old</span>
    <span class="s0">// snapsho and getSnapshot values to bail out. We need to check one more time.</span>

    <span class="s2">if </span><span class="s1">(checkIfSnapshotChanged(inst)) {</span>
      <span class="s0">// Force a re-render.</span>
      <span class="s1">forceStoreRerender(fiber);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">subscribeToStore(fiber, inst, subscribe) {</span>
    <span class="s2">var </span><span class="s1">handleStoreChange = </span><span class="s2">function </span><span class="s1">() {</span>
      <span class="s0">// The store changed. Check if the snapshot changed since the last time we</span>
      <span class="s0">// read from the store.</span>
      <span class="s2">if </span><span class="s1">(checkIfSnapshotChanged(inst)) {</span>
        <span class="s0">// Force a re-render.</span>
        <span class="s1">forceStoreRerender(fiber);</span>
      <span class="s1">}</span>
    <span class="s1">}; </span><span class="s0">// Subscribe to the store and return a clean-up function.</span>


    <span class="s2">return </span><span class="s1">subscribe(handleStoreChange);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">checkIfSnapshotChanged(inst) {</span>
    <span class="s2">var </span><span class="s1">latestGetSnapshot = inst.getSnapshot;</span>
    <span class="s2">var </span><span class="s1">prevValue = inst.value;</span>

    <span class="s2">try </span><span class="s1">{</span>
      <span class="s2">var </span><span class="s1">nextValue = latestGetSnapshot();</span>
      <span class="s2">return </span><span class="s1">!objectIs(prevValue, nextValue);</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(error) {</span>
      <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">forceStoreRerender(fiber) {</span>
    <span class="s2">var </span><span class="s1">root = enqueueConcurrentRenderForLane(fiber, SyncLane);</span>

    <span class="s2">if </span><span class="s1">(root !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">mountState(initialState) {</span>
    <span class="s2">var </span><span class="s1">hook = mountWorkInProgressHook();</span>

    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">initialState === </span><span class="s3">'function'</span><span class="s1">) {</span>
      <span class="s0">// $FlowFixMe: Flow doesn't like mixed types</span>
      <span class="s1">initialState = initialState();</span>
    <span class="s1">}</span>

    <span class="s1">hook.memoizedState = hook.baseState = initialState;</span>
    <span class="s2">var </span><span class="s1">queue = {</span>
      <span class="s1">pending: </span><span class="s2">null</span><span class="s1">,</span>
      <span class="s1">interleaved: </span><span class="s2">null</span><span class="s1">,</span>
      <span class="s1">lanes: NoLanes,</span>
      <span class="s1">dispatch: </span><span class="s2">null</span><span class="s1">,</span>
      <span class="s1">lastRenderedReducer: basicStateReducer,</span>
      <span class="s1">lastRenderedState: initialState</span>
    <span class="s1">};</span>
    <span class="s1">hook.queue = queue;</span>
    <span class="s2">var </span><span class="s1">dispatch = queue.dispatch = dispatchSetState.bind(</span><span class="s2">null</span><span class="s1">, currentlyRenderingFiber$1, queue);</span>
    <span class="s2">return </span><span class="s1">[hook.memoizedState, dispatch];</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">updateState(initialState) {</span>
    <span class="s2">return </span><span class="s1">updateReducer(basicStateReducer);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">rerenderState(initialState) {</span>
    <span class="s2">return </span><span class="s1">rerenderReducer(basicStateReducer);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">pushEffect(tag, create, destroy, deps) {</span>
    <span class="s2">var </span><span class="s1">effect = {</span>
      <span class="s1">tag: tag,</span>
      <span class="s1">create: create,</span>
      <span class="s1">destroy: destroy,</span>
      <span class="s1">deps: deps,</span>
      <span class="s0">// Circular</span>
      <span class="s1">next: </span><span class="s2">null</span>
    <span class="s1">};</span>
    <span class="s2">var </span><span class="s1">componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;</span>

    <span class="s2">if </span><span class="s1">(componentUpdateQueue === </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">componentUpdateQueue = createFunctionComponentUpdateQueue();</span>
      <span class="s1">currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;</span>
      <span class="s1">componentUpdateQueue.lastEffect = effect.next = effect;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">var </span><span class="s1">lastEffect = componentUpdateQueue.lastEffect;</span>

      <span class="s2">if </span><span class="s1">(lastEffect === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">componentUpdateQueue.lastEffect = effect.next = effect;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">var </span><span class="s1">firstEffect = lastEffect.next;</span>
        <span class="s1">lastEffect.next = effect;</span>
        <span class="s1">effect.next = firstEffect;</span>
        <span class="s1">componentUpdateQueue.lastEffect = effect;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">effect;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">mountRef(initialValue) {</span>
    <span class="s2">var </span><span class="s1">hook = mountWorkInProgressHook();</span>

    <span class="s1">{</span>
      <span class="s2">var </span><span class="s1">_ref2 = {</span>
        <span class="s1">current: initialValue</span>
      <span class="s1">};</span>
      <span class="s1">hook.memoizedState = _ref2;</span>
      <span class="s2">return </span><span class="s1">_ref2;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">updateRef(initialValue) {</span>
    <span class="s2">var </span><span class="s1">hook = updateWorkInProgressHook();</span>
    <span class="s2">return </span><span class="s1">hook.memoizedState;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">mountEffectImpl(fiberFlags, hookFlags, create, deps) {</span>
    <span class="s2">var </span><span class="s1">hook = mountWorkInProgressHook();</span>
    <span class="s2">var </span><span class="s1">nextDeps = deps === undefined ? </span><span class="s2">null </span><span class="s1">: deps;</span>
    <span class="s1">currentlyRenderingFiber$1.flags |= fiberFlags;</span>
    <span class="s1">hook.memoizedState = pushEffect(HasEffect | hookFlags, create, undefined, nextDeps);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">updateEffectImpl(fiberFlags, hookFlags, create, deps) {</span>
    <span class="s2">var </span><span class="s1">hook = updateWorkInProgressHook();</span>
    <span class="s2">var </span><span class="s1">nextDeps = deps === undefined ? </span><span class="s2">null </span><span class="s1">: deps;</span>
    <span class="s2">var </span><span class="s1">destroy = undefined;</span>

    <span class="s2">if </span><span class="s1">(currentHook !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">prevEffect = currentHook.memoizedState;</span>
      <span class="s1">destroy = prevEffect.destroy;</span>

      <span class="s2">if </span><span class="s1">(nextDeps !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">var </span><span class="s1">prevDeps = prevEffect.deps;</span>

        <span class="s2">if </span><span class="s1">(areHookInputsEqual(nextDeps, prevDeps)) {</span>
          <span class="s1">hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);</span>
          <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">currentlyRenderingFiber$1.flags |= fiberFlags;</span>
    <span class="s1">hook.memoizedState = pushEffect(HasEffect | hookFlags, create, destroy, nextDeps);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">mountEffect(create, deps) {</span>
    <span class="s1">{</span>
      <span class="s2">return </span><span class="s1">mountEffectImpl(Passive | PassiveStatic, Passive$1, create, deps);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">updateEffect(create, deps) {</span>
    <span class="s2">return </span><span class="s1">updateEffectImpl(Passive, Passive$1, create, deps);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">mountInsertionEffect(create, deps) {</span>
    <span class="s2">return </span><span class="s1">mountEffectImpl(Update, Insertion, create, deps);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">updateInsertionEffect(create, deps) {</span>
    <span class="s2">return </span><span class="s1">updateEffectImpl(Update, Insertion, create, deps);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">mountLayoutEffect(create, deps) {</span>
    <span class="s2">var </span><span class="s1">fiberFlags = Update;</span>

    <span class="s2">return </span><span class="s1">mountEffectImpl(fiberFlags, Layout, create, deps);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">updateLayoutEffect(create, deps) {</span>
    <span class="s2">return </span><span class="s1">updateEffectImpl(Update, Layout, create, deps);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">imperativeHandleEffect(create, ref) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">ref === </span><span class="s3">'function'</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">refCallback = ref;</span>

      <span class="s2">var </span><span class="s1">_inst = create();</span>

      <span class="s1">refCallback(_inst);</span>
      <span class="s2">return function </span><span class="s1">() {</span>
        <span class="s1">refCallback(</span><span class="s2">null</span><span class="s1">);</span>
      <span class="s1">};</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(ref !== </span><span class="s2">null </span><span class="s1">&amp;&amp; ref !== undefined) {</span>
      <span class="s2">var </span><span class="s1">refObject = ref;</span>

      <span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(!refObject.hasOwnProperty(</span><span class="s3">'current'</span><span class="s1">)) {</span>
          <span class="s1">error(</span><span class="s3">'Expected useImperativeHandle() first argument to either be a ' </span><span class="s1">+ </span><span class="s3">'ref callback or React.createRef() object. Instead received: %s.'</span><span class="s1">, </span><span class="s3">'an object with keys {' </span><span class="s1">+ Object.keys(refObject).join(</span><span class="s3">', '</span><span class="s1">) + </span><span class="s3">'}'</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">_inst2 = create();</span>

      <span class="s1">refObject.current = _inst2;</span>
      <span class="s2">return function </span><span class="s1">() {</span>
        <span class="s1">refObject.current = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">};</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">mountImperativeHandle(ref, create, deps) {</span>
    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">create !== </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s3">'Expected useImperativeHandle() second argument to be a function ' </span><span class="s1">+ </span><span class="s3">'that creates a handle. Instead received: %s.'</span><span class="s1">, create !== </span><span class="s2">null </span><span class="s1">? </span><span class="s2">typeof </span><span class="s1">create : </span><span class="s3">'null'</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// TODO: If deps are provided, should we skip comparing the ref itself?</span>


    <span class="s2">var </span><span class="s1">effectDeps = deps !== </span><span class="s2">null </span><span class="s1">&amp;&amp; deps !== undefined ? deps.concat([ref]) : </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">var </span><span class="s1">fiberFlags = Update;</span>

    <span class="s2">return </span><span class="s1">mountEffectImpl(fiberFlags, Layout, imperativeHandleEffect.bind(</span><span class="s2">null</span><span class="s1">, create, ref), effectDeps);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">updateImperativeHandle(ref, create, deps) {</span>
    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">create !== </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s3">'Expected useImperativeHandle() second argument to be a function ' </span><span class="s1">+ </span><span class="s3">'that creates a handle. Instead received: %s.'</span><span class="s1">, create !== </span><span class="s2">null </span><span class="s1">? </span><span class="s2">typeof </span><span class="s1">create : </span><span class="s3">'null'</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// TODO: If deps are provided, should we skip comparing the ref itself?</span>


    <span class="s2">var </span><span class="s1">effectDeps = deps !== </span><span class="s2">null </span><span class="s1">&amp;&amp; deps !== undefined ? deps.concat([ref]) : </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">return </span><span class="s1">updateEffectImpl(Update, Layout, imperativeHandleEffect.bind(</span><span class="s2">null</span><span class="s1">, create, ref), effectDeps);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">mountDebugValue(value, formatterFn) {</span><span class="s0">// This hook is normally a no-op.</span>
    <span class="s0">// The react-debug-hooks package injects its own implementation</span>
    <span class="s0">// so that e.g. DevTools can display custom hook values.</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">updateDebugValue = mountDebugValue;</span>

  <span class="s2">function </span><span class="s1">mountCallback(callback, deps) {</span>
    <span class="s2">var </span><span class="s1">hook = mountWorkInProgressHook();</span>
    <span class="s2">var </span><span class="s1">nextDeps = deps === undefined ? </span><span class="s2">null </span><span class="s1">: deps;</span>
    <span class="s1">hook.memoizedState = [callback, nextDeps];</span>
    <span class="s2">return </span><span class="s1">callback;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">updateCallback(callback, deps) {</span>
    <span class="s2">var </span><span class="s1">hook = updateWorkInProgressHook();</span>
    <span class="s2">var </span><span class="s1">nextDeps = deps === undefined ? </span><span class="s2">null </span><span class="s1">: deps;</span>
    <span class="s2">var </span><span class="s1">prevState = hook.memoizedState;</span>

    <span class="s2">if </span><span class="s1">(prevState !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(nextDeps !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">var </span><span class="s1">prevDeps = prevState[</span><span class="s4">1</span><span class="s1">];</span>

        <span class="s2">if </span><span class="s1">(areHookInputsEqual(nextDeps, prevDeps)) {</span>
          <span class="s2">return </span><span class="s1">prevState[</span><span class="s4">0</span><span class="s1">];</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">hook.memoizedState = [callback, nextDeps];</span>
    <span class="s2">return </span><span class="s1">callback;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">mountMemo(nextCreate, deps) {</span>
    <span class="s2">var </span><span class="s1">hook = mountWorkInProgressHook();</span>
    <span class="s2">var </span><span class="s1">nextDeps = deps === undefined ? </span><span class="s2">null </span><span class="s1">: deps;</span>
    <span class="s2">var </span><span class="s1">nextValue = nextCreate();</span>
    <span class="s1">hook.memoizedState = [nextValue, nextDeps];</span>
    <span class="s2">return </span><span class="s1">nextValue;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">updateMemo(nextCreate, deps) {</span>
    <span class="s2">var </span><span class="s1">hook = updateWorkInProgressHook();</span>
    <span class="s2">var </span><span class="s1">nextDeps = deps === undefined ? </span><span class="s2">null </span><span class="s1">: deps;</span>
    <span class="s2">var </span><span class="s1">prevState = hook.memoizedState;</span>

    <span class="s2">if </span><span class="s1">(prevState !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s0">// Assume these are defined. If they're not, areHookInputsEqual will warn.</span>
      <span class="s2">if </span><span class="s1">(nextDeps !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">var </span><span class="s1">prevDeps = prevState[</span><span class="s4">1</span><span class="s1">];</span>

        <span class="s2">if </span><span class="s1">(areHookInputsEqual(nextDeps, prevDeps)) {</span>
          <span class="s2">return </span><span class="s1">prevState[</span><span class="s4">0</span><span class="s1">];</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">nextValue = nextCreate();</span>
    <span class="s1">hook.memoizedState = [nextValue, nextDeps];</span>
    <span class="s2">return </span><span class="s1">nextValue;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">mountDeferredValue(value) {</span>
    <span class="s2">var </span><span class="s1">hook = mountWorkInProgressHook();</span>
    <span class="s1">hook.memoizedState = value;</span>
    <span class="s2">return </span><span class="s1">value;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">updateDeferredValue(value) {</span>
    <span class="s2">var </span><span class="s1">hook = updateWorkInProgressHook();</span>
    <span class="s2">var </span><span class="s1">resolvedCurrentHook = currentHook;</span>
    <span class="s2">var </span><span class="s1">prevValue = resolvedCurrentHook.memoizedState;</span>
    <span class="s2">return </span><span class="s1">updateDeferredValueImpl(hook, prevValue, value);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">rerenderDeferredValue(value) {</span>
    <span class="s2">var </span><span class="s1">hook = updateWorkInProgressHook();</span>

    <span class="s2">if </span><span class="s1">(currentHook === </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s0">// This is a rerender during a mount.</span>
      <span class="s1">hook.memoizedState = value;</span>
      <span class="s2">return </span><span class="s1">value;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s0">// This is a rerender during an update.</span>
      <span class="s2">var </span><span class="s1">prevValue = currentHook.memoizedState;</span>
      <span class="s2">return </span><span class="s1">updateDeferredValueImpl(hook, prevValue, value);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">updateDeferredValueImpl(hook, prevValue, value) {</span>
    <span class="s2">var </span><span class="s1">shouldDeferValue = !includesOnlyNonUrgentLanes(renderLanes);</span>

    <span class="s2">if </span><span class="s1">(shouldDeferValue) {</span>
      <span class="s0">// This is an urgent update. If the value has changed, keep using the</span>
      <span class="s0">// previous value and spawn a deferred render to update it later.</span>
      <span class="s2">if </span><span class="s1">(!objectIs(value, prevValue)) {</span>
        <span class="s0">// Schedule a deferred render</span>
        <span class="s2">var </span><span class="s1">deferredLane = claimNextTransitionLane();</span>
        <span class="s1">currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, deferredLane);</span>
        <span class="s1">markSkippedUpdateLanes(deferredLane); </span><span class="s0">// Set this to true to indicate that the rendered value is inconsistent</span>
        <span class="s0">// from the latest value. The name &quot;baseState&quot; doesn't really match how we</span>
        <span class="s0">// use it because we're reusing a state hook field instead of creating a</span>
        <span class="s0">// new one.</span>

        <span class="s1">hook.baseState = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// Reuse the previous value</span>


      <span class="s2">return </span><span class="s1">prevValue;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s0">// This is not an urgent update, so we can use the latest value regardless</span>
      <span class="s0">// of what it is. No need to defer it.</span>
      <span class="s0">// However, if we're currently inside a spawned render, then we need to mark</span>
      <span class="s0">// this as an update to prevent the fiber from bailing out.</span>
      <span class="s0">//</span>
      <span class="s0">// `baseState` is true when the current value is different from the rendered</span>
      <span class="s0">// value. The name doesn't really match how we use it because we're reusing</span>
      <span class="s0">// a state hook field instead of creating a new one.</span>
      <span class="s2">if </span><span class="s1">(hook.baseState) {</span>
        <span class="s0">// Flip this back to false.</span>
        <span class="s1">hook.baseState = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s1">markWorkInProgressReceivedUpdate();</span>
      <span class="s1">}</span>

      <span class="s1">hook.memoizedState = value;</span>
      <span class="s2">return </span><span class="s1">value;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">startTransition(setPending, callback, options) {</span>
    <span class="s2">var </span><span class="s1">previousPriority = getCurrentUpdatePriority();</span>
    <span class="s1">setCurrentUpdatePriority(higherEventPriority(previousPriority, ContinuousEventPriority));</span>
    <span class="s1">setPending(</span><span class="s2">true</span><span class="s1">);</span>
    <span class="s2">var </span><span class="s1">prevTransition = ReactCurrentBatchConfig$1.transition;</span>
    <span class="s1">ReactCurrentBatchConfig$1.transition = {};</span>
    <span class="s2">var </span><span class="s1">currentTransition = ReactCurrentBatchConfig$1.transition;</span>

    <span class="s1">{</span>
      <span class="s1">ReactCurrentBatchConfig$1.transition._updatedFibers = </span><span class="s2">new </span><span class="s1">Set();</span>
    <span class="s1">}</span>

    <span class="s2">try </span><span class="s1">{</span>
      <span class="s1">setPending(</span><span class="s2">false</span><span class="s1">);</span>
      <span class="s1">callback();</span>
    <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
      <span class="s1">setCurrentUpdatePriority(previousPriority);</span>
      <span class="s1">ReactCurrentBatchConfig$1.transition = prevTransition;</span>

      <span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(prevTransition === </span><span class="s2">null </span><span class="s1">&amp;&amp; currentTransition._updatedFibers) {</span>
          <span class="s2">var </span><span class="s1">updatedFibersCount = currentTransition._updatedFibers.size;</span>

          <span class="s2">if </span><span class="s1">(updatedFibersCount &gt; </span><span class="s4">10</span><span class="s1">) {</span>
            <span class="s1">warn(</span><span class="s3">'Detected a large number of updates inside startTransition. ' </span><span class="s1">+ </span><span class="s3">'If this is due to a subscription please re-write it to use React provided hooks. ' </span><span class="s1">+ </span><span class="s3">'Otherwise concurrent mode guarantees are off the table.'</span><span class="s1">);</span>
          <span class="s1">}</span>

          <span class="s1">currentTransition._updatedFibers.clear();</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">mountTransition() {</span>
    <span class="s2">var </span><span class="s1">_mountState = mountState(</span><span class="s2">false</span><span class="s1">),</span>
        <span class="s1">isPending = _mountState[</span><span class="s4">0</span><span class="s1">],</span>
        <span class="s1">setPending = _mountState[</span><span class="s4">1</span><span class="s1">]; </span><span class="s0">// The `start` method never changes.</span>


    <span class="s2">var </span><span class="s1">start = startTransition.bind(</span><span class="s2">null</span><span class="s1">, setPending);</span>
    <span class="s2">var </span><span class="s1">hook = mountWorkInProgressHook();</span>
    <span class="s1">hook.memoizedState = start;</span>
    <span class="s2">return </span><span class="s1">[isPending, start];</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">updateTransition() {</span>
    <span class="s2">var </span><span class="s1">_updateState = updateState(),</span>
        <span class="s1">isPending = _updateState[</span><span class="s4">0</span><span class="s1">];</span>

    <span class="s2">var </span><span class="s1">hook = updateWorkInProgressHook();</span>
    <span class="s2">var </span><span class="s1">start = hook.memoizedState;</span>
    <span class="s2">return </span><span class="s1">[isPending, start];</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">rerenderTransition() {</span>
    <span class="s2">var </span><span class="s1">_rerenderState = rerenderState(),</span>
        <span class="s1">isPending = _rerenderState[</span><span class="s4">0</span><span class="s1">];</span>

    <span class="s2">var </span><span class="s1">hook = updateWorkInProgressHook();</span>
    <span class="s2">var </span><span class="s1">start = hook.memoizedState;</span>
    <span class="s2">return </span><span class="s1">[isPending, start];</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">isUpdatingOpaqueValueInRenderPhase = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s2">function </span><span class="s1">getIsUpdatingOpaqueValueInRenderPhaseInDEV() {</span>
    <span class="s1">{</span>
      <span class="s2">return </span><span class="s1">isUpdatingOpaqueValueInRenderPhase;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">mountId() {</span>
    <span class="s2">var </span><span class="s1">hook = mountWorkInProgressHook();</span>
    <span class="s2">var </span><span class="s1">root = getWorkInProgressRoot(); </span><span class="s0">// TODO: In Fizz, id generation is specific to each server config. Maybe we</span>
    <span class="s0">// should do this in Fiber, too? Deferring this decision for now because</span>
    <span class="s0">// there's no other place to store the prefix except for an internal field on</span>
    <span class="s0">// the public createRoot object, which the fiber tree does not currently have</span>
    <span class="s0">// a reference to.</span>

    <span class="s2">var </span><span class="s1">identifierPrefix = root.identifierPrefix;</span>
    <span class="s2">var </span><span class="s1">id;</span>

    <span class="s1">{</span>
      <span class="s0">// Use a lowercase r prefix for client-generated ids.</span>
      <span class="s2">var </span><span class="s1">globalClientId = globalClientIdCounter++;</span>
      <span class="s1">id = </span><span class="s3">':' </span><span class="s1">+ identifierPrefix + </span><span class="s3">'r' </span><span class="s1">+ globalClientId.toString(</span><span class="s4">32</span><span class="s1">) + </span><span class="s3">':'</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">hook.memoizedState = id;</span>
    <span class="s2">return </span><span class="s1">id;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">updateId() {</span>
    <span class="s2">var </span><span class="s1">hook = updateWorkInProgressHook();</span>
    <span class="s2">var </span><span class="s1">id = hook.memoizedState;</span>
    <span class="s2">return </span><span class="s1">id;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">dispatchReducerAction(fiber, queue, action) {</span>
    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">arguments[</span><span class="s4">3</span><span class="s1">] === </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s3">&quot;State updates from the useState() and useReducer() Hooks don't support the &quot; </span><span class="s1">+ </span><span class="s3">'second callback argument. To execute a side effect after ' </span><span class="s1">+ </span><span class="s3">'rendering, declare it in the component body with useEffect().'</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">lane = requestUpdateLane(fiber);</span>
    <span class="s2">var </span><span class="s1">update = {</span>
      <span class="s1">lane: lane,</span>
      <span class="s1">action: action,</span>
      <span class="s1">hasEagerState: </span><span class="s2">false</span><span class="s1">,</span>
      <span class="s1">eagerState: </span><span class="s2">null</span><span class="s1">,</span>
      <span class="s1">next: </span><span class="s2">null</span>
    <span class="s1">};</span>

    <span class="s2">if </span><span class="s1">(isRenderPhaseUpdate(fiber)) {</span>
      <span class="s1">enqueueRenderPhaseUpdate(queue, update);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">var </span><span class="s1">root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);</span>

      <span class="s2">if </span><span class="s1">(root !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">var </span><span class="s1">eventTime = requestEventTime();</span>
        <span class="s1">scheduleUpdateOnFiber(root, fiber, lane, eventTime);</span>
        <span class="s1">entangleTransitionUpdate(root, queue, lane);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">dispatchSetState(fiber, queue, action) {</span>
    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">arguments[</span><span class="s4">3</span><span class="s1">] === </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s3">&quot;State updates from the useState() and useReducer() Hooks don't support the &quot; </span><span class="s1">+ </span><span class="s3">'second callback argument. To execute a side effect after ' </span><span class="s1">+ </span><span class="s3">'rendering, declare it in the component body with useEffect().'</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">lane = requestUpdateLane(fiber);</span>
    <span class="s2">var </span><span class="s1">update = {</span>
      <span class="s1">lane: lane,</span>
      <span class="s1">action: action,</span>
      <span class="s1">hasEagerState: </span><span class="s2">false</span><span class="s1">,</span>
      <span class="s1">eagerState: </span><span class="s2">null</span><span class="s1">,</span>
      <span class="s1">next: </span><span class="s2">null</span>
    <span class="s1">};</span>

    <span class="s2">if </span><span class="s1">(isRenderPhaseUpdate(fiber)) {</span>
      <span class="s1">enqueueRenderPhaseUpdate(queue, update);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">var </span><span class="s1">alternate = fiber.alternate;</span>

      <span class="s2">if </span><span class="s1">(fiber.lanes === NoLanes &amp;&amp; (alternate === </span><span class="s2">null </span><span class="s1">|| alternate.lanes === NoLanes)) {</span>
        <span class="s0">// The queue is currently empty, which means we can eagerly compute the</span>
        <span class="s0">// next state before entering the render phase. If the new state is the</span>
        <span class="s0">// same as the current state, we may be able to bail out entirely.</span>
        <span class="s2">var </span><span class="s1">lastRenderedReducer = queue.lastRenderedReducer;</span>

        <span class="s2">if </span><span class="s1">(lastRenderedReducer !== </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s2">var </span><span class="s1">prevDispatcher;</span>

          <span class="s1">{</span>
            <span class="s1">prevDispatcher = ReactCurrentDispatcher$1.current;</span>
            <span class="s1">ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;</span>
          <span class="s1">}</span>

          <span class="s2">try </span><span class="s1">{</span>
            <span class="s2">var </span><span class="s1">currentState = queue.lastRenderedState;</span>
            <span class="s2">var </span><span class="s1">eagerState = lastRenderedReducer(currentState, action); </span><span class="s0">// Stash the eagerly computed state, and the reducer used to compute</span>
            <span class="s0">// it, on the update object. If the reducer hasn't changed by the</span>
            <span class="s0">// time we enter the render phase, then the eager state can be used</span>
            <span class="s0">// without calling the reducer again.</span>

            <span class="s1">update.hasEagerState = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">update.eagerState = eagerState;</span>

            <span class="s2">if </span><span class="s1">(objectIs(eagerState, currentState)) {</span>
              <span class="s0">// Fast path. We can bail out without scheduling React to re-render.</span>
              <span class="s0">// It's still possible that we'll need to rebase this update later,</span>
              <span class="s0">// if the component re-renders for a different reason and by that</span>
              <span class="s0">// time the reducer has changed.</span>
              <span class="s0">// TODO: Do we still need to entangle transitions in this case?</span>
              <span class="s1">enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update, lane);</span>
              <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
          <span class="s1">} </span><span class="s2">catch </span><span class="s1">(error) {</span><span class="s0">// Suppress the error. It will throw again in the render phase.</span>
          <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
            <span class="s1">{</span>
              <span class="s1">ReactCurrentDispatcher$1.current = prevDispatcher;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);</span>

      <span class="s2">if </span><span class="s1">(root !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">var </span><span class="s1">eventTime = requestEventTime();</span>
        <span class="s1">scheduleUpdateOnFiber(root, fiber, lane, eventTime);</span>
        <span class="s1">entangleTransitionUpdate(root, queue, lane);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">isRenderPhaseUpdate(fiber) {</span>
    <span class="s2">var </span><span class="s1">alternate = fiber.alternate;</span>
    <span class="s2">return </span><span class="s1">fiber === currentlyRenderingFiber$1 || alternate !== </span><span class="s2">null </span><span class="s1">&amp;&amp; alternate === currentlyRenderingFiber$1;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">enqueueRenderPhaseUpdate(queue, update) {</span>
    <span class="s0">// This is a render phase update. Stash it in a lazily-created map of</span>
    <span class="s0">// queue -&gt; linked list of updates. After this render pass, we'll restart</span>
    <span class="s0">// and apply the stashed updates on top of the work-in-progress hook.</span>
    <span class="s1">didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s2">var </span><span class="s1">pending = queue.pending;</span>

    <span class="s2">if </span><span class="s1">(pending === </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s0">// This is the first update. Create a circular list.</span>
      <span class="s1">update.next = update;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">update.next = pending.next;</span>
      <span class="s1">pending.next = update;</span>
    <span class="s1">}</span>

    <span class="s1">queue.pending = update;</span>
  <span class="s1">} </span><span class="s0">// TODO: Move to ReactFiberConcurrentUpdates?</span>


  <span class="s2">function </span><span class="s1">entangleTransitionUpdate(root, queue, lane) {</span>
    <span class="s2">if </span><span class="s1">(isTransitionLane(lane)) {</span>
      <span class="s2">var </span><span class="s1">queueLanes = queue.lanes; </span><span class="s0">// If any entangled lanes are no longer pending on the root, then they</span>
      <span class="s0">// must have finished. We can remove them from the shared queue, which</span>
      <span class="s0">// represents a superset of the actually pending lanes. In some cases we</span>
      <span class="s0">// may entangle more than we need to, but that's OK. In fact it's worse if</span>
      <span class="s0">// we *don't* entangle when we should.</span>

      <span class="s1">queueLanes = intersectLanes(queueLanes, root.pendingLanes); </span><span class="s0">// Entangle the new transition lane with the other transition lanes.</span>

      <span class="s2">var </span><span class="s1">newQueueLanes = mergeLanes(queueLanes, lane);</span>
      <span class="s1">queue.lanes = newQueueLanes; </span><span class="s0">// Even if queue.lanes already include lane, we don't know for certain if</span>
      <span class="s0">// the lane finished since the last time we entangled it. So we need to</span>
      <span class="s0">// entangle it again, just to be sure.</span>

      <span class="s1">markRootEntangled(root, newQueueLanes);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">ContextOnlyDispatcher = {</span>
    <span class="s1">readContext: readContext,</span>
    <span class="s1">useCallback: throwInvalidHookError,</span>
    <span class="s1">useContext: throwInvalidHookError,</span>
    <span class="s1">useEffect: throwInvalidHookError,</span>
    <span class="s1">useImperativeHandle: throwInvalidHookError,</span>
    <span class="s1">useInsertionEffect: throwInvalidHookError,</span>
    <span class="s1">useLayoutEffect: throwInvalidHookError,</span>
    <span class="s1">useMemo: throwInvalidHookError,</span>
    <span class="s1">useReducer: throwInvalidHookError,</span>
    <span class="s1">useRef: throwInvalidHookError,</span>
    <span class="s1">useState: throwInvalidHookError,</span>
    <span class="s1">useDebugValue: throwInvalidHookError,</span>
    <span class="s1">useDeferredValue: throwInvalidHookError,</span>
    <span class="s1">useTransition: throwInvalidHookError,</span>
    <span class="s1">useMutableSource: throwInvalidHookError,</span>
    <span class="s1">useSyncExternalStore: throwInvalidHookError,</span>
    <span class="s1">useId: throwInvalidHookError,</span>
    <span class="s1">unstable_isNewReconciler: enableNewReconciler</span>
  <span class="s1">};</span>

  <span class="s2">var </span><span class="s1">HooksDispatcherOnMountInDEV = </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">HooksDispatcherOnMountWithHookTypesInDEV = </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">HooksDispatcherOnUpdateInDEV = </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">HooksDispatcherOnRerenderInDEV = </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">InvalidNestedHooksDispatcherOnMountInDEV = </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">InvalidNestedHooksDispatcherOnUpdateInDEV = </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">InvalidNestedHooksDispatcherOnRerenderInDEV = </span><span class="s2">null</span><span class="s1">;</span>

  <span class="s1">{</span>
    <span class="s2">var </span><span class="s1">warnInvalidContextAccess = </span><span class="s2">function </span><span class="s1">() {</span>
      <span class="s1">error(</span><span class="s3">'Context can only be read while React is rendering. ' </span><span class="s1">+ </span><span class="s3">'In classes, you can read it in the render method or getDerivedStateFromProps. ' </span><span class="s1">+ </span><span class="s3">'In function components, you can read it directly in the function body, but not ' </span><span class="s1">+ </span><span class="s3">'inside Hooks like useReducer() or useMemo().'</span><span class="s1">);</span>
    <span class="s1">};</span>

    <span class="s2">var </span><span class="s1">warnInvalidHookAccess = </span><span class="s2">function </span><span class="s1">() {</span>
      <span class="s1">error(</span><span class="s3">'Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. ' </span><span class="s1">+ </span><span class="s3">'You can only call Hooks at the top level of your React function. ' </span><span class="s1">+ </span><span class="s3">'For more information, see ' </span><span class="s1">+ </span><span class="s3">'https://reactjs.org/link/rules-of-hooks'</span><span class="s1">);</span>
    <span class="s1">};</span>

    <span class="s1">HooksDispatcherOnMountInDEV = {</span>
      <span class="s1">readContext: </span><span class="s2">function </span><span class="s1">(context) {</span>
        <span class="s2">return </span><span class="s1">readContext(context);</span>
      <span class="s1">},</span>
      <span class="s1">useCallback: </span><span class="s2">function </span><span class="s1">(callback, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useCallback'</span><span class="s1">;</span>
        <span class="s1">mountHookTypesDev();</span>
        <span class="s1">checkDepsAreArrayDev(deps);</span>
        <span class="s2">return </span><span class="s1">mountCallback(callback, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useContext: </span><span class="s2">function </span><span class="s1">(context) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useContext'</span><span class="s1">;</span>
        <span class="s1">mountHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">readContext(context);</span>
      <span class="s1">},</span>
      <span class="s1">useEffect: </span><span class="s2">function </span><span class="s1">(create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useEffect'</span><span class="s1">;</span>
        <span class="s1">mountHookTypesDev();</span>
        <span class="s1">checkDepsAreArrayDev(deps);</span>
        <span class="s2">return </span><span class="s1">mountEffect(create, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useImperativeHandle: </span><span class="s2">function </span><span class="s1">(ref, create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useImperativeHandle'</span><span class="s1">;</span>
        <span class="s1">mountHookTypesDev();</span>
        <span class="s1">checkDepsAreArrayDev(deps);</span>
        <span class="s2">return </span><span class="s1">mountImperativeHandle(ref, create, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useInsertionEffect: </span><span class="s2">function </span><span class="s1">(create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useInsertionEffect'</span><span class="s1">;</span>
        <span class="s1">mountHookTypesDev();</span>
        <span class="s1">checkDepsAreArrayDev(deps);</span>
        <span class="s2">return </span><span class="s1">mountInsertionEffect(create, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useLayoutEffect: </span><span class="s2">function </span><span class="s1">(create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useLayoutEffect'</span><span class="s1">;</span>
        <span class="s1">mountHookTypesDev();</span>
        <span class="s1">checkDepsAreArrayDev(deps);</span>
        <span class="s2">return </span><span class="s1">mountLayoutEffect(create, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useMemo: </span><span class="s2">function </span><span class="s1">(create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useMemo'</span><span class="s1">;</span>
        <span class="s1">mountHookTypesDev();</span>
        <span class="s1">checkDepsAreArrayDev(deps);</span>
        <span class="s2">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher$1.current;</span>
        <span class="s1">ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;</span>

        <span class="s2">try </span><span class="s1">{</span>
          <span class="s2">return </span><span class="s1">mountMemo(create, deps);</span>
        <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
          <span class="s1">ReactCurrentDispatcher$1.current = prevDispatcher;</span>
        <span class="s1">}</span>
      <span class="s1">},</span>
      <span class="s1">useReducer: </span><span class="s2">function </span><span class="s1">(reducer, initialArg, init) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useReducer'</span><span class="s1">;</span>
        <span class="s1">mountHookTypesDev();</span>
        <span class="s2">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher$1.current;</span>
        <span class="s1">ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;</span>

        <span class="s2">try </span><span class="s1">{</span>
          <span class="s2">return </span><span class="s1">mountReducer(reducer, initialArg, init);</span>
        <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
          <span class="s1">ReactCurrentDispatcher$1.current = prevDispatcher;</span>
        <span class="s1">}</span>
      <span class="s1">},</span>
      <span class="s1">useRef: </span><span class="s2">function </span><span class="s1">(initialValue) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useRef'</span><span class="s1">;</span>
        <span class="s1">mountHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">mountRef(initialValue);</span>
      <span class="s1">},</span>
      <span class="s1">useState: </span><span class="s2">function </span><span class="s1">(initialState) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useState'</span><span class="s1">;</span>
        <span class="s1">mountHookTypesDev();</span>
        <span class="s2">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher$1.current;</span>
        <span class="s1">ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;</span>

        <span class="s2">try </span><span class="s1">{</span>
          <span class="s2">return </span><span class="s1">mountState(initialState);</span>
        <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
          <span class="s1">ReactCurrentDispatcher$1.current = prevDispatcher;</span>
        <span class="s1">}</span>
      <span class="s1">},</span>
      <span class="s1">useDebugValue: </span><span class="s2">function </span><span class="s1">(value, formatterFn) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useDebugValue'</span><span class="s1">;</span>
        <span class="s1">mountHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">mountDebugValue();</span>
      <span class="s1">},</span>
      <span class="s1">useDeferredValue: </span><span class="s2">function </span><span class="s1">(value) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useDeferredValue'</span><span class="s1">;</span>
        <span class="s1">mountHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">mountDeferredValue(value);</span>
      <span class="s1">},</span>
      <span class="s1">useTransition: </span><span class="s2">function </span><span class="s1">() {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useTransition'</span><span class="s1">;</span>
        <span class="s1">mountHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">mountTransition();</span>
      <span class="s1">},</span>
      <span class="s1">useMutableSource: </span><span class="s2">function </span><span class="s1">(source, getSnapshot, subscribe) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useMutableSource'</span><span class="s1">;</span>
        <span class="s1">mountHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">mountMutableSource();</span>
      <span class="s1">},</span>
      <span class="s1">useSyncExternalStore: </span><span class="s2">function </span><span class="s1">(subscribe, getSnapshot, getServerSnapshot) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useSyncExternalStore'</span><span class="s1">;</span>
        <span class="s1">mountHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">mountSyncExternalStore(subscribe, getSnapshot);</span>
      <span class="s1">},</span>
      <span class="s1">useId: </span><span class="s2">function </span><span class="s1">() {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useId'</span><span class="s1">;</span>
        <span class="s1">mountHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">mountId();</span>
      <span class="s1">},</span>
      <span class="s1">unstable_isNewReconciler: enableNewReconciler</span>
    <span class="s1">};</span>

    <span class="s1">HooksDispatcherOnMountWithHookTypesInDEV = {</span>
      <span class="s1">readContext: </span><span class="s2">function </span><span class="s1">(context) {</span>
        <span class="s2">return </span><span class="s1">readContext(context);</span>
      <span class="s1">},</span>
      <span class="s1">useCallback: </span><span class="s2">function </span><span class="s1">(callback, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useCallback'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">mountCallback(callback, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useContext: </span><span class="s2">function </span><span class="s1">(context) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useContext'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">readContext(context);</span>
      <span class="s1">},</span>
      <span class="s1">useEffect: </span><span class="s2">function </span><span class="s1">(create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useEffect'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">mountEffect(create, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useImperativeHandle: </span><span class="s2">function </span><span class="s1">(ref, create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useImperativeHandle'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">mountImperativeHandle(ref, create, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useInsertionEffect: </span><span class="s2">function </span><span class="s1">(create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useInsertionEffect'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">mountInsertionEffect(create, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useLayoutEffect: </span><span class="s2">function </span><span class="s1">(create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useLayoutEffect'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">mountLayoutEffect(create, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useMemo: </span><span class="s2">function </span><span class="s1">(create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useMemo'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher$1.current;</span>
        <span class="s1">ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;</span>

        <span class="s2">try </span><span class="s1">{</span>
          <span class="s2">return </span><span class="s1">mountMemo(create, deps);</span>
        <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
          <span class="s1">ReactCurrentDispatcher$1.current = prevDispatcher;</span>
        <span class="s1">}</span>
      <span class="s1">},</span>
      <span class="s1">useReducer: </span><span class="s2">function </span><span class="s1">(reducer, initialArg, init) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useReducer'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher$1.current;</span>
        <span class="s1">ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;</span>

        <span class="s2">try </span><span class="s1">{</span>
          <span class="s2">return </span><span class="s1">mountReducer(reducer, initialArg, init);</span>
        <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
          <span class="s1">ReactCurrentDispatcher$1.current = prevDispatcher;</span>
        <span class="s1">}</span>
      <span class="s1">},</span>
      <span class="s1">useRef: </span><span class="s2">function </span><span class="s1">(initialValue) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useRef'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">mountRef(initialValue);</span>
      <span class="s1">},</span>
      <span class="s1">useState: </span><span class="s2">function </span><span class="s1">(initialState) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useState'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher$1.current;</span>
        <span class="s1">ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;</span>

        <span class="s2">try </span><span class="s1">{</span>
          <span class="s2">return </span><span class="s1">mountState(initialState);</span>
        <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
          <span class="s1">ReactCurrentDispatcher$1.current = prevDispatcher;</span>
        <span class="s1">}</span>
      <span class="s1">},</span>
      <span class="s1">useDebugValue: </span><span class="s2">function </span><span class="s1">(value, formatterFn) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useDebugValue'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">mountDebugValue();</span>
      <span class="s1">},</span>
      <span class="s1">useDeferredValue: </span><span class="s2">function </span><span class="s1">(value) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useDeferredValue'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">mountDeferredValue(value);</span>
      <span class="s1">},</span>
      <span class="s1">useTransition: </span><span class="s2">function </span><span class="s1">() {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useTransition'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">mountTransition();</span>
      <span class="s1">},</span>
      <span class="s1">useMutableSource: </span><span class="s2">function </span><span class="s1">(source, getSnapshot, subscribe) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useMutableSource'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">mountMutableSource();</span>
      <span class="s1">},</span>
      <span class="s1">useSyncExternalStore: </span><span class="s2">function </span><span class="s1">(subscribe, getSnapshot, getServerSnapshot) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useSyncExternalStore'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">mountSyncExternalStore(subscribe, getSnapshot);</span>
      <span class="s1">},</span>
      <span class="s1">useId: </span><span class="s2">function </span><span class="s1">() {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useId'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">mountId();</span>
      <span class="s1">},</span>
      <span class="s1">unstable_isNewReconciler: enableNewReconciler</span>
    <span class="s1">};</span>

    <span class="s1">HooksDispatcherOnUpdateInDEV = {</span>
      <span class="s1">readContext: </span><span class="s2">function </span><span class="s1">(context) {</span>
        <span class="s2">return </span><span class="s1">readContext(context);</span>
      <span class="s1">},</span>
      <span class="s1">useCallback: </span><span class="s2">function </span><span class="s1">(callback, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useCallback'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">updateCallback(callback, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useContext: </span><span class="s2">function </span><span class="s1">(context) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useContext'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">readContext(context);</span>
      <span class="s1">},</span>
      <span class="s1">useEffect: </span><span class="s2">function </span><span class="s1">(create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useEffect'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">updateEffect(create, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useImperativeHandle: </span><span class="s2">function </span><span class="s1">(ref, create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useImperativeHandle'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">updateImperativeHandle(ref, create, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useInsertionEffect: </span><span class="s2">function </span><span class="s1">(create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useInsertionEffect'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">updateInsertionEffect(create, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useLayoutEffect: </span><span class="s2">function </span><span class="s1">(create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useLayoutEffect'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">updateLayoutEffect(create, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useMemo: </span><span class="s2">function </span><span class="s1">(create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useMemo'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher$1.current;</span>
        <span class="s1">ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;</span>

        <span class="s2">try </span><span class="s1">{</span>
          <span class="s2">return </span><span class="s1">updateMemo(create, deps);</span>
        <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
          <span class="s1">ReactCurrentDispatcher$1.current = prevDispatcher;</span>
        <span class="s1">}</span>
      <span class="s1">},</span>
      <span class="s1">useReducer: </span><span class="s2">function </span><span class="s1">(reducer, initialArg, init) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useReducer'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher$1.current;</span>
        <span class="s1">ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;</span>

        <span class="s2">try </span><span class="s1">{</span>
          <span class="s2">return </span><span class="s1">updateReducer(reducer, initialArg, init);</span>
        <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
          <span class="s1">ReactCurrentDispatcher$1.current = prevDispatcher;</span>
        <span class="s1">}</span>
      <span class="s1">},</span>
      <span class="s1">useRef: </span><span class="s2">function </span><span class="s1">(initialValue) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useRef'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">updateRef();</span>
      <span class="s1">},</span>
      <span class="s1">useState: </span><span class="s2">function </span><span class="s1">(initialState) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useState'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher$1.current;</span>
        <span class="s1">ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;</span>

        <span class="s2">try </span><span class="s1">{</span>
          <span class="s2">return </span><span class="s1">updateState(initialState);</span>
        <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
          <span class="s1">ReactCurrentDispatcher$1.current = prevDispatcher;</span>
        <span class="s1">}</span>
      <span class="s1">},</span>
      <span class="s1">useDebugValue: </span><span class="s2">function </span><span class="s1">(value, formatterFn) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useDebugValue'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">updateDebugValue();</span>
      <span class="s1">},</span>
      <span class="s1">useDeferredValue: </span><span class="s2">function </span><span class="s1">(value) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useDeferredValue'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">updateDeferredValue(value);</span>
      <span class="s1">},</span>
      <span class="s1">useTransition: </span><span class="s2">function </span><span class="s1">() {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useTransition'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">updateTransition();</span>
      <span class="s1">},</span>
      <span class="s1">useMutableSource: </span><span class="s2">function </span><span class="s1">(source, getSnapshot, subscribe) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useMutableSource'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">updateMutableSource();</span>
      <span class="s1">},</span>
      <span class="s1">useSyncExternalStore: </span><span class="s2">function </span><span class="s1">(subscribe, getSnapshot, getServerSnapshot) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useSyncExternalStore'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">updateSyncExternalStore(subscribe, getSnapshot);</span>
      <span class="s1">},</span>
      <span class="s1">useId: </span><span class="s2">function </span><span class="s1">() {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useId'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">updateId();</span>
      <span class="s1">},</span>
      <span class="s1">unstable_isNewReconciler: enableNewReconciler</span>
    <span class="s1">};</span>

    <span class="s1">HooksDispatcherOnRerenderInDEV = {</span>
      <span class="s1">readContext: </span><span class="s2">function </span><span class="s1">(context) {</span>
        <span class="s2">return </span><span class="s1">readContext(context);</span>
      <span class="s1">},</span>
      <span class="s1">useCallback: </span><span class="s2">function </span><span class="s1">(callback, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useCallback'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">updateCallback(callback, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useContext: </span><span class="s2">function </span><span class="s1">(context) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useContext'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">readContext(context);</span>
      <span class="s1">},</span>
      <span class="s1">useEffect: </span><span class="s2">function </span><span class="s1">(create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useEffect'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">updateEffect(create, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useImperativeHandle: </span><span class="s2">function </span><span class="s1">(ref, create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useImperativeHandle'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">updateImperativeHandle(ref, create, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useInsertionEffect: </span><span class="s2">function </span><span class="s1">(create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useInsertionEffect'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">updateInsertionEffect(create, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useLayoutEffect: </span><span class="s2">function </span><span class="s1">(create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useLayoutEffect'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">updateLayoutEffect(create, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useMemo: </span><span class="s2">function </span><span class="s1">(create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useMemo'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher$1.current;</span>
        <span class="s1">ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;</span>

        <span class="s2">try </span><span class="s1">{</span>
          <span class="s2">return </span><span class="s1">updateMemo(create, deps);</span>
        <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
          <span class="s1">ReactCurrentDispatcher$1.current = prevDispatcher;</span>
        <span class="s1">}</span>
      <span class="s1">},</span>
      <span class="s1">useReducer: </span><span class="s2">function </span><span class="s1">(reducer, initialArg, init) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useReducer'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher$1.current;</span>
        <span class="s1">ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;</span>

        <span class="s2">try </span><span class="s1">{</span>
          <span class="s2">return </span><span class="s1">rerenderReducer(reducer, initialArg, init);</span>
        <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
          <span class="s1">ReactCurrentDispatcher$1.current = prevDispatcher;</span>
        <span class="s1">}</span>
      <span class="s1">},</span>
      <span class="s1">useRef: </span><span class="s2">function </span><span class="s1">(initialValue) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useRef'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">updateRef();</span>
      <span class="s1">},</span>
      <span class="s1">useState: </span><span class="s2">function </span><span class="s1">(initialState) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useState'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher$1.current;</span>
        <span class="s1">ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;</span>

        <span class="s2">try </span><span class="s1">{</span>
          <span class="s2">return </span><span class="s1">rerenderState(initialState);</span>
        <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
          <span class="s1">ReactCurrentDispatcher$1.current = prevDispatcher;</span>
        <span class="s1">}</span>
      <span class="s1">},</span>
      <span class="s1">useDebugValue: </span><span class="s2">function </span><span class="s1">(value, formatterFn) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useDebugValue'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">updateDebugValue();</span>
      <span class="s1">},</span>
      <span class="s1">useDeferredValue: </span><span class="s2">function </span><span class="s1">(value) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useDeferredValue'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">rerenderDeferredValue(value);</span>
      <span class="s1">},</span>
      <span class="s1">useTransition: </span><span class="s2">function </span><span class="s1">() {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useTransition'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">rerenderTransition();</span>
      <span class="s1">},</span>
      <span class="s1">useMutableSource: </span><span class="s2">function </span><span class="s1">(source, getSnapshot, subscribe) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useMutableSource'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">updateMutableSource();</span>
      <span class="s1">},</span>
      <span class="s1">useSyncExternalStore: </span><span class="s2">function </span><span class="s1">(subscribe, getSnapshot, getServerSnapshot) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useSyncExternalStore'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">updateSyncExternalStore(subscribe, getSnapshot);</span>
      <span class="s1">},</span>
      <span class="s1">useId: </span><span class="s2">function </span><span class="s1">() {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useId'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">updateId();</span>
      <span class="s1">},</span>
      <span class="s1">unstable_isNewReconciler: enableNewReconciler</span>
    <span class="s1">};</span>

    <span class="s1">InvalidNestedHooksDispatcherOnMountInDEV = {</span>
      <span class="s1">readContext: </span><span class="s2">function </span><span class="s1">(context) {</span>
        <span class="s1">warnInvalidContextAccess();</span>
        <span class="s2">return </span><span class="s1">readContext(context);</span>
      <span class="s1">},</span>
      <span class="s1">useCallback: </span><span class="s2">function </span><span class="s1">(callback, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useCallback'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">mountHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">mountCallback(callback, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useContext: </span><span class="s2">function </span><span class="s1">(context) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useContext'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">mountHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">readContext(context);</span>
      <span class="s1">},</span>
      <span class="s1">useEffect: </span><span class="s2">function </span><span class="s1">(create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useEffect'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">mountHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">mountEffect(create, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useImperativeHandle: </span><span class="s2">function </span><span class="s1">(ref, create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useImperativeHandle'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">mountHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">mountImperativeHandle(ref, create, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useInsertionEffect: </span><span class="s2">function </span><span class="s1">(create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useInsertionEffect'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">mountHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">mountInsertionEffect(create, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useLayoutEffect: </span><span class="s2">function </span><span class="s1">(create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useLayoutEffect'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">mountHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">mountLayoutEffect(create, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useMemo: </span><span class="s2">function </span><span class="s1">(create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useMemo'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">mountHookTypesDev();</span>
        <span class="s2">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher$1.current;</span>
        <span class="s1">ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;</span>

        <span class="s2">try </span><span class="s1">{</span>
          <span class="s2">return </span><span class="s1">mountMemo(create, deps);</span>
        <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
          <span class="s1">ReactCurrentDispatcher$1.current = prevDispatcher;</span>
        <span class="s1">}</span>
      <span class="s1">},</span>
      <span class="s1">useReducer: </span><span class="s2">function </span><span class="s1">(reducer, initialArg, init) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useReducer'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">mountHookTypesDev();</span>
        <span class="s2">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher$1.current;</span>
        <span class="s1">ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;</span>

        <span class="s2">try </span><span class="s1">{</span>
          <span class="s2">return </span><span class="s1">mountReducer(reducer, initialArg, init);</span>
        <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
          <span class="s1">ReactCurrentDispatcher$1.current = prevDispatcher;</span>
        <span class="s1">}</span>
      <span class="s1">},</span>
      <span class="s1">useRef: </span><span class="s2">function </span><span class="s1">(initialValue) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useRef'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">mountHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">mountRef(initialValue);</span>
      <span class="s1">},</span>
      <span class="s1">useState: </span><span class="s2">function </span><span class="s1">(initialState) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useState'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">mountHookTypesDev();</span>
        <span class="s2">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher$1.current;</span>
        <span class="s1">ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;</span>

        <span class="s2">try </span><span class="s1">{</span>
          <span class="s2">return </span><span class="s1">mountState(initialState);</span>
        <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
          <span class="s1">ReactCurrentDispatcher$1.current = prevDispatcher;</span>
        <span class="s1">}</span>
      <span class="s1">},</span>
      <span class="s1">useDebugValue: </span><span class="s2">function </span><span class="s1">(value, formatterFn) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useDebugValue'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">mountHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">mountDebugValue();</span>
      <span class="s1">},</span>
      <span class="s1">useDeferredValue: </span><span class="s2">function </span><span class="s1">(value) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useDeferredValue'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">mountHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">mountDeferredValue(value);</span>
      <span class="s1">},</span>
      <span class="s1">useTransition: </span><span class="s2">function </span><span class="s1">() {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useTransition'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">mountHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">mountTransition();</span>
      <span class="s1">},</span>
      <span class="s1">useMutableSource: </span><span class="s2">function </span><span class="s1">(source, getSnapshot, subscribe) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useMutableSource'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">mountHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">mountMutableSource();</span>
      <span class="s1">},</span>
      <span class="s1">useSyncExternalStore: </span><span class="s2">function </span><span class="s1">(subscribe, getSnapshot, getServerSnapshot) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useSyncExternalStore'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">mountHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">mountSyncExternalStore(subscribe, getSnapshot);</span>
      <span class="s1">},</span>
      <span class="s1">useId: </span><span class="s2">function </span><span class="s1">() {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useId'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">mountHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">mountId();</span>
      <span class="s1">},</span>
      <span class="s1">unstable_isNewReconciler: enableNewReconciler</span>
    <span class="s1">};</span>

    <span class="s1">InvalidNestedHooksDispatcherOnUpdateInDEV = {</span>
      <span class="s1">readContext: </span><span class="s2">function </span><span class="s1">(context) {</span>
        <span class="s1">warnInvalidContextAccess();</span>
        <span class="s2">return </span><span class="s1">readContext(context);</span>
      <span class="s1">},</span>
      <span class="s1">useCallback: </span><span class="s2">function </span><span class="s1">(callback, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useCallback'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">updateCallback(callback, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useContext: </span><span class="s2">function </span><span class="s1">(context) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useContext'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">readContext(context);</span>
      <span class="s1">},</span>
      <span class="s1">useEffect: </span><span class="s2">function </span><span class="s1">(create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useEffect'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">updateEffect(create, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useImperativeHandle: </span><span class="s2">function </span><span class="s1">(ref, create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useImperativeHandle'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">updateImperativeHandle(ref, create, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useInsertionEffect: </span><span class="s2">function </span><span class="s1">(create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useInsertionEffect'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">updateInsertionEffect(create, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useLayoutEffect: </span><span class="s2">function </span><span class="s1">(create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useLayoutEffect'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">updateLayoutEffect(create, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useMemo: </span><span class="s2">function </span><span class="s1">(create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useMemo'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher$1.current;</span>
        <span class="s1">ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;</span>

        <span class="s2">try </span><span class="s1">{</span>
          <span class="s2">return </span><span class="s1">updateMemo(create, deps);</span>
        <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
          <span class="s1">ReactCurrentDispatcher$1.current = prevDispatcher;</span>
        <span class="s1">}</span>
      <span class="s1">},</span>
      <span class="s1">useReducer: </span><span class="s2">function </span><span class="s1">(reducer, initialArg, init) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useReducer'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher$1.current;</span>
        <span class="s1">ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;</span>

        <span class="s2">try </span><span class="s1">{</span>
          <span class="s2">return </span><span class="s1">updateReducer(reducer, initialArg, init);</span>
        <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
          <span class="s1">ReactCurrentDispatcher$1.current = prevDispatcher;</span>
        <span class="s1">}</span>
      <span class="s1">},</span>
      <span class="s1">useRef: </span><span class="s2">function </span><span class="s1">(initialValue) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useRef'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">updateRef();</span>
      <span class="s1">},</span>
      <span class="s1">useState: </span><span class="s2">function </span><span class="s1">(initialState) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useState'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher$1.current;</span>
        <span class="s1">ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;</span>

        <span class="s2">try </span><span class="s1">{</span>
          <span class="s2">return </span><span class="s1">updateState(initialState);</span>
        <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
          <span class="s1">ReactCurrentDispatcher$1.current = prevDispatcher;</span>
        <span class="s1">}</span>
      <span class="s1">},</span>
      <span class="s1">useDebugValue: </span><span class="s2">function </span><span class="s1">(value, formatterFn) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useDebugValue'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">updateDebugValue();</span>
      <span class="s1">},</span>
      <span class="s1">useDeferredValue: </span><span class="s2">function </span><span class="s1">(value) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useDeferredValue'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">updateDeferredValue(value);</span>
      <span class="s1">},</span>
      <span class="s1">useTransition: </span><span class="s2">function </span><span class="s1">() {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useTransition'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">updateTransition();</span>
      <span class="s1">},</span>
      <span class="s1">useMutableSource: </span><span class="s2">function </span><span class="s1">(source, getSnapshot, subscribe) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useMutableSource'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">updateMutableSource();</span>
      <span class="s1">},</span>
      <span class="s1">useSyncExternalStore: </span><span class="s2">function </span><span class="s1">(subscribe, getSnapshot, getServerSnapshot) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useSyncExternalStore'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">updateSyncExternalStore(subscribe, getSnapshot);</span>
      <span class="s1">},</span>
      <span class="s1">useId: </span><span class="s2">function </span><span class="s1">() {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useId'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">updateId();</span>
      <span class="s1">},</span>
      <span class="s1">unstable_isNewReconciler: enableNewReconciler</span>
    <span class="s1">};</span>

    <span class="s1">InvalidNestedHooksDispatcherOnRerenderInDEV = {</span>
      <span class="s1">readContext: </span><span class="s2">function </span><span class="s1">(context) {</span>
        <span class="s1">warnInvalidContextAccess();</span>
        <span class="s2">return </span><span class="s1">readContext(context);</span>
      <span class="s1">},</span>
      <span class="s1">useCallback: </span><span class="s2">function </span><span class="s1">(callback, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useCallback'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">updateCallback(callback, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useContext: </span><span class="s2">function </span><span class="s1">(context) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useContext'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">readContext(context);</span>
      <span class="s1">},</span>
      <span class="s1">useEffect: </span><span class="s2">function </span><span class="s1">(create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useEffect'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">updateEffect(create, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useImperativeHandle: </span><span class="s2">function </span><span class="s1">(ref, create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useImperativeHandle'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">updateImperativeHandle(ref, create, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useInsertionEffect: </span><span class="s2">function </span><span class="s1">(create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useInsertionEffect'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">updateInsertionEffect(create, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useLayoutEffect: </span><span class="s2">function </span><span class="s1">(create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useLayoutEffect'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">updateLayoutEffect(create, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useMemo: </span><span class="s2">function </span><span class="s1">(create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useMemo'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher$1.current;</span>
        <span class="s1">ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;</span>

        <span class="s2">try </span><span class="s1">{</span>
          <span class="s2">return </span><span class="s1">updateMemo(create, deps);</span>
        <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
          <span class="s1">ReactCurrentDispatcher$1.current = prevDispatcher;</span>
        <span class="s1">}</span>
      <span class="s1">},</span>
      <span class="s1">useReducer: </span><span class="s2">function </span><span class="s1">(reducer, initialArg, init) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useReducer'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher$1.current;</span>
        <span class="s1">ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;</span>

        <span class="s2">try </span><span class="s1">{</span>
          <span class="s2">return </span><span class="s1">rerenderReducer(reducer, initialArg, init);</span>
        <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
          <span class="s1">ReactCurrentDispatcher$1.current = prevDispatcher;</span>
        <span class="s1">}</span>
      <span class="s1">},</span>
      <span class="s1">useRef: </span><span class="s2">function </span><span class="s1">(initialValue) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useRef'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">updateRef();</span>
      <span class="s1">},</span>
      <span class="s1">useState: </span><span class="s2">function </span><span class="s1">(initialState) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useState'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher$1.current;</span>
        <span class="s1">ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;</span>

        <span class="s2">try </span><span class="s1">{</span>
          <span class="s2">return </span><span class="s1">rerenderState(initialState);</span>
        <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
          <span class="s1">ReactCurrentDispatcher$1.current = prevDispatcher;</span>
        <span class="s1">}</span>
      <span class="s1">},</span>
      <span class="s1">useDebugValue: </span><span class="s2">function </span><span class="s1">(value, formatterFn) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useDebugValue'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">updateDebugValue();</span>
      <span class="s1">},</span>
      <span class="s1">useDeferredValue: </span><span class="s2">function </span><span class="s1">(value) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useDeferredValue'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">rerenderDeferredValue(value);</span>
      <span class="s1">},</span>
      <span class="s1">useTransition: </span><span class="s2">function </span><span class="s1">() {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useTransition'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">rerenderTransition();</span>
      <span class="s1">},</span>
      <span class="s1">useMutableSource: </span><span class="s2">function </span><span class="s1">(source, getSnapshot, subscribe) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useMutableSource'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">updateMutableSource();</span>
      <span class="s1">},</span>
      <span class="s1">useSyncExternalStore: </span><span class="s2">function </span><span class="s1">(subscribe, getSnapshot, getServerSnapshot) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useSyncExternalStore'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">updateSyncExternalStore(subscribe, getSnapshot);</span>
      <span class="s1">},</span>
      <span class="s1">useId: </span><span class="s2">function </span><span class="s1">() {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s3">'useId'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s2">return </span><span class="s1">updateId();</span>
      <span class="s1">},</span>
      <span class="s1">unstable_isNewReconciler: enableNewReconciler</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">now$1 = Scheduler$1.unstable_now;</span>
  <span class="s2">var </span><span class="s1">commitTime = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">layoutEffectStartTime = -</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">profilerStartTime = -</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">passiveEffectStartTime = -</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s0">/** 
   * Tracks whether the current update was a nested/cascading update (scheduled from a layout effect). 
   * 
   * The overall sequence is: 
   *   1. render 
   *   2. commit (and call `onRender`, `onCommit`) 
   *   3. check for nested updates 
   *   4. flush passive effects (and call `onPostCommit`) 
   * 
   * Nested updates are identified in step 3 above, 
   * but step 4 still applies to the work that was just committed. 
   * We use two flags to track nested updates then: 
   * one tracks whether the upcoming update is a nested update, 
   * and the other tracks whether the current update was a nested update. 
   * The first value gets synced to the second at the start of the render phase. 
   */</span>

  <span class="s2">var </span><span class="s1">currentUpdateIsNested = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">nestedUpdateScheduled = </span><span class="s2">false</span><span class="s1">;</span>

  <span class="s2">function </span><span class="s1">isCurrentUpdateNested() {</span>
    <span class="s2">return </span><span class="s1">currentUpdateIsNested;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">markNestedUpdateScheduled() {</span>
    <span class="s1">{</span>
      <span class="s1">nestedUpdateScheduled = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">resetNestedUpdateFlag() {</span>
    <span class="s1">{</span>
      <span class="s1">currentUpdateIsNested = </span><span class="s2">false</span><span class="s1">;</span>
      <span class="s1">nestedUpdateScheduled = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">syncNestedUpdateFlag() {</span>
    <span class="s1">{</span>
      <span class="s1">currentUpdateIsNested = nestedUpdateScheduled;</span>
      <span class="s1">nestedUpdateScheduled = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">getCommitTime() {</span>
    <span class="s2">return </span><span class="s1">commitTime;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">recordCommitTime() {</span>

    <span class="s1">commitTime = now$1();</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">startProfilerTimer(fiber) {</span>

    <span class="s1">profilerStartTime = now$1();</span>

    <span class="s2">if </span><span class="s1">(fiber.actualStartTime &lt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s1">fiber.actualStartTime = now$1();</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">stopProfilerTimerIfRunning(fiber) {</span>

    <span class="s1">profilerStartTime = -</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {</span>

    <span class="s2">if </span><span class="s1">(profilerStartTime &gt;= </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">elapsedTime = now$1() - profilerStartTime;</span>
      <span class="s1">fiber.actualDuration += elapsedTime;</span>

      <span class="s2">if </span><span class="s1">(overrideBaseTime) {</span>
        <span class="s1">fiber.selfBaseDuration = elapsedTime;</span>
      <span class="s1">}</span>

      <span class="s1">profilerStartTime = -</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">recordLayoutEffectDuration(fiber) {</span>

    <span class="s2">if </span><span class="s1">(layoutEffectStartTime &gt;= </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">elapsedTime = now$1() - layoutEffectStartTime;</span>
      <span class="s1">layoutEffectStartTime = -</span><span class="s4">1</span><span class="s1">; </span><span class="s0">// Store duration on the next nearest Profiler ancestor</span>
      <span class="s0">// Or the root (for the DevTools Profiler to read)</span>

      <span class="s2">var </span><span class="s1">parentFiber = fiber.</span><span class="s2">return</span><span class="s1">;</span>

      <span class="s2">while </span><span class="s1">(parentFiber !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">switch </span><span class="s1">(parentFiber.tag) {</span>
          <span class="s2">case </span><span class="s1">HostRoot:</span>
            <span class="s2">var </span><span class="s1">root = parentFiber.stateNode;</span>
            <span class="s1">root.effectDuration += elapsedTime;</span>
            <span class="s2">return</span><span class="s1">;</span>

          <span class="s2">case </span><span class="s1">Profiler:</span>
            <span class="s2">var </span><span class="s1">parentStateNode = parentFiber.stateNode;</span>
            <span class="s1">parentStateNode.effectDuration += elapsedTime;</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">parentFiber = parentFiber.</span><span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">recordPassiveEffectDuration(fiber) {</span>

    <span class="s2">if </span><span class="s1">(passiveEffectStartTime &gt;= </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">elapsedTime = now$1() - passiveEffectStartTime;</span>
      <span class="s1">passiveEffectStartTime = -</span><span class="s4">1</span><span class="s1">; </span><span class="s0">// Store duration on the next nearest Profiler ancestor</span>
      <span class="s0">// Or the root (for the DevTools Profiler to read)</span>

      <span class="s2">var </span><span class="s1">parentFiber = fiber.</span><span class="s2">return</span><span class="s1">;</span>

      <span class="s2">while </span><span class="s1">(parentFiber !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">switch </span><span class="s1">(parentFiber.tag) {</span>
          <span class="s2">case </span><span class="s1">HostRoot:</span>
            <span class="s2">var </span><span class="s1">root = parentFiber.stateNode;</span>

            <span class="s2">if </span><span class="s1">(root !== </span><span class="s2">null</span><span class="s1">) {</span>
              <span class="s1">root.passiveEffectDuration += elapsedTime;</span>
            <span class="s1">}</span>

            <span class="s2">return</span><span class="s1">;</span>

          <span class="s2">case </span><span class="s1">Profiler:</span>
            <span class="s2">var </span><span class="s1">parentStateNode = parentFiber.stateNode;</span>

            <span class="s2">if </span><span class="s1">(parentStateNode !== </span><span class="s2">null</span><span class="s1">) {</span>
              <span class="s0">// Detached fibers have their state node cleared out.</span>
              <span class="s0">// In this case, the return pointer is also cleared out,</span>
              <span class="s0">// so we won't be able to report the time spent in this Profiler's subtree.</span>
              <span class="s1">parentStateNode.passiveEffectDuration += elapsedTime;</span>
            <span class="s1">}</span>

            <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">parentFiber = parentFiber.</span><span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">startLayoutEffectTimer() {</span>

    <span class="s1">layoutEffectStartTime = now$1();</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">startPassiveEffectTimer() {</span>

    <span class="s1">passiveEffectStartTime = now$1();</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">transferActualDuration(fiber) {</span>
    <span class="s0">// Transfer time spent rendering these children so we don't lose it</span>
    <span class="s0">// after we rerender. This is used as a helper in special cases</span>
    <span class="s0">// where we should count the work of multiple passes.</span>
    <span class="s2">var </span><span class="s1">child = fiber.child;</span>

    <span class="s2">while </span><span class="s1">(child) {</span>
      <span class="s1">fiber.actualDuration += child.actualDuration;</span>
      <span class="s1">child = child.sibling;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">createCapturedValueAtFiber(value, source) {</span>
    <span class="s0">// If the value is an error, call this function immediately after it is thrown</span>
    <span class="s0">// so the stack is accurate.</span>
    <span class="s2">return </span><span class="s1">{</span>
      <span class="s1">value: value,</span>
      <span class="s1">source: source,</span>
      <span class="s1">stack: getStackByFiberInDevAndProd(source),</span>
      <span class="s1">digest: </span><span class="s2">null</span>
    <span class="s1">};</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">createCapturedValue(value, digest, stack) {</span>
    <span class="s2">return </span><span class="s1">{</span>
      <span class="s1">value: value,</span>
      <span class="s1">source: </span><span class="s2">null</span><span class="s1">,</span>
      <span class="s1">stack: stack != </span><span class="s2">null </span><span class="s1">? stack : </span><span class="s2">null</span><span class="s1">,</span>
      <span class="s1">digest: digest != </span><span class="s2">null </span><span class="s1">? digest : </span><span class="s2">null</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s0">// This module is forked in different environments.</span>
  <span class="s0">// By default, return `true` to log errors to the console.</span>
  <span class="s0">// Forks can return `false` if this isn't desirable.</span>
  <span class="s2">function </span><span class="s1">showErrorDialog(boundary, errorInfo) {</span>
    <span class="s2">return true</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">logCapturedError(boundary, errorInfo) {</span>
    <span class="s2">try </span><span class="s1">{</span>
      <span class="s2">var </span><span class="s1">logError = showErrorDialog(boundary, errorInfo); </span><span class="s0">// Allow injected showErrorDialog() to prevent default console.error logging.</span>
      <span class="s0">// This enables renderers like ReactNative to better manage redbox behavior.</span>

      <span class="s2">if </span><span class="s1">(logError === </span><span class="s2">false</span><span class="s1">) {</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">error = errorInfo.value;</span>

      <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s2">var </span><span class="s1">source = errorInfo.source;</span>
        <span class="s2">var </span><span class="s1">stack = errorInfo.stack;</span>
        <span class="s2">var </span><span class="s1">componentStack = stack !== </span><span class="s2">null </span><span class="s1">? stack : </span><span class="s3">''</span><span class="s1">; </span><span class="s0">// Browsers support silencing uncaught errors by calling</span>
        <span class="s0">// `preventDefault()` in window `error` handler.</span>
        <span class="s0">// We record this information as an expando on the error.</span>

        <span class="s2">if </span><span class="s1">(error != </span><span class="s2">null </span><span class="s1">&amp;&amp; error._suppressLogging) {</span>
          <span class="s2">if </span><span class="s1">(boundary.tag === ClassComponent) {</span>
            <span class="s0">// The error is recoverable and was silenced.</span>
            <span class="s0">// Ignore it and don't print the stack addendum.</span>
            <span class="s0">// This is handy for testing error boundaries without noise.</span>
            <span class="s2">return</span><span class="s1">;</span>
          <span class="s1">} </span><span class="s0">// The error is fatal. Since the silencing might have</span>
          <span class="s0">// been accidental, we'll surface it anyway.</span>
          <span class="s0">// However, the browser would have silenced the original error</span>
          <span class="s0">// so we'll print it first, and then print the stack addendum.</span>


          <span class="s1">console[</span><span class="s3">'error'</span><span class="s1">](error); </span><span class="s0">// Don't transform to our wrapper</span>
          <span class="s0">// For a more detailed description of this block, see:</span>
          <span class="s0">// https://github.com/facebook/react/pull/13384</span>
        <span class="s1">}</span>

        <span class="s2">var </span><span class="s1">componentName = source ? getComponentNameFromFiber(source) : </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s2">var </span><span class="s1">componentNameMessage = componentName ? </span><span class="s3">&quot;The above error occurred in the &lt;&quot; </span><span class="s1">+ componentName + </span><span class="s3">&quot;&gt; component:&quot; </span><span class="s1">: </span><span class="s3">'The above error occurred in one of your React components:'</span><span class="s1">;</span>
        <span class="s2">var </span><span class="s1">errorBoundaryMessage;</span>

        <span class="s2">if </span><span class="s1">(boundary.tag === HostRoot) {</span>
          <span class="s1">errorBoundaryMessage = </span><span class="s3">'Consider adding an error boundary to your tree to customize error handling behavior.</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">'Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.'</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s2">var </span><span class="s1">errorBoundaryName = getComponentNameFromFiber(boundary) || </span><span class="s3">'Anonymous'</span><span class="s1">;</span>
          <span class="s1">errorBoundaryMessage = </span><span class="s3">&quot;React will try to recreate this component tree from scratch &quot; </span><span class="s1">+ (</span><span class="s3">&quot;using the error boundary you provided, &quot; </span><span class="s1">+ errorBoundaryName + </span><span class="s3">&quot;.&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s2">var </span><span class="s1">combinedMessage = componentNameMessage + </span><span class="s3">&quot;</span><span class="s5">\n</span><span class="s3">&quot; </span><span class="s1">+ componentStack + </span><span class="s3">&quot;</span><span class="s5">\n\n</span><span class="s3">&quot; </span><span class="s1">+ (</span><span class="s3">&quot;&quot; </span><span class="s1">+ errorBoundaryMessage); </span><span class="s0">// In development, we provide our own message with just the component stack.</span>
        <span class="s0">// We don't include the original error message and JS stack because the browser</span>
        <span class="s0">// has already printed it. Even if the application swallows the error, it is still</span>
        <span class="s0">// displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.</span>

        <span class="s1">console[</span><span class="s3">'error'</span><span class="s1">](combinedMessage); </span><span class="s0">// Don't transform to our wrapper</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s0">// In production, we print the error directly.</span>
        <span class="s0">// This will include the message, the JS stack, and anything the browser wants to show.</span>
        <span class="s0">// We pass the error object instead of custom message so that the browser displays the error natively.</span>
        <span class="s1">console[</span><span class="s3">'error'</span><span class="s1">](error); </span><span class="s0">// Don't transform to our wrapper</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(e) {</span>
      <span class="s0">// This method must not throw, or React internal state will get messed up.</span>
      <span class="s0">// If console.error is overridden, or logCapturedError() shows a dialog that throws,</span>
      <span class="s0">// we want to report this error outside of the normal stack as a last resort.</span>
      <span class="s0">// https://github.com/facebook/react/issues/13188</span>
      <span class="s1">setTimeout(</span><span class="s2">function </span><span class="s1">() {</span>
        <span class="s2">throw </span><span class="s1">e;</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">PossiblyWeakMap$1 = </span><span class="s2">typeof </span><span class="s1">WeakMap === </span><span class="s3">'function' </span><span class="s1">? WeakMap : Map;</span>

  <span class="s2">function </span><span class="s1">createRootErrorUpdate(fiber, errorInfo, lane) {</span>
    <span class="s2">var </span><span class="s1">update = createUpdate(NoTimestamp, lane); </span><span class="s0">// Unmount the root by rendering null.</span>

    <span class="s1">update.tag = CaptureUpdate; </span><span class="s0">// Caution: React DevTools currently depends on this property</span>
    <span class="s0">// being called &quot;element&quot;.</span>

    <span class="s1">update.payload = {</span>
      <span class="s1">element: </span><span class="s2">null</span>
    <span class="s1">};</span>
    <span class="s2">var </span><span class="s1">error = errorInfo.value;</span>

    <span class="s1">update.callback = </span><span class="s2">function </span><span class="s1">() {</span>
      <span class="s1">onUncaughtError(error);</span>
      <span class="s1">logCapturedError(fiber, errorInfo);</span>
    <span class="s1">};</span>

    <span class="s2">return </span><span class="s1">update;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">createClassErrorUpdate(fiber, errorInfo, lane) {</span>
    <span class="s2">var </span><span class="s1">update = createUpdate(NoTimestamp, lane);</span>
    <span class="s1">update.tag = CaptureUpdate;</span>
    <span class="s2">var </span><span class="s1">getDerivedStateFromError = fiber.type.getDerivedStateFromError;</span>

    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">getDerivedStateFromError === </span><span class="s3">'function'</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">error$1 = errorInfo.value;</span>

      <span class="s1">update.payload = </span><span class="s2">function </span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">getDerivedStateFromError(error$1);</span>
      <span class="s1">};</span>

      <span class="s1">update.callback = </span><span class="s2">function </span><span class="s1">() {</span>
        <span class="s1">{</span>
          <span class="s1">markFailedErrorBoundaryForHotReloading(fiber);</span>
        <span class="s1">}</span>

        <span class="s1">logCapturedError(fiber, errorInfo);</span>
      <span class="s1">};</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">inst = fiber.stateNode;</span>

    <span class="s2">if </span><span class="s1">(inst !== </span><span class="s2">null </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">inst.componentDidCatch === </span><span class="s3">'function'</span><span class="s1">) {</span>
      <span class="s1">update.callback = </span><span class="s2">function </span><span class="s1">callback() {</span>
        <span class="s1">{</span>
          <span class="s1">markFailedErrorBoundaryForHotReloading(fiber);</span>
        <span class="s1">}</span>

        <span class="s1">logCapturedError(fiber, errorInfo);</span>

        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">getDerivedStateFromError !== </span><span class="s3">'function'</span><span class="s1">) {</span>
          <span class="s0">// To preserve the preexisting retry behavior of error boundaries,</span>
          <span class="s0">// we keep track of which ones already failed during this batch.</span>
          <span class="s0">// This gets reset before we yield back to the browser.</span>
          <span class="s0">// TODO: Warn in strict mode if getDerivedStateFromError is</span>
          <span class="s0">// not defined.</span>
          <span class="s1">markLegacyErrorBoundaryAsFailed(</span><span class="s2">this</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s2">var </span><span class="s1">error$1 = errorInfo.value;</span>
        <span class="s2">var </span><span class="s1">stack = errorInfo.stack;</span>
        <span class="s2">this</span><span class="s1">.componentDidCatch(error$1, {</span>
          <span class="s1">componentStack: stack !== </span><span class="s2">null </span><span class="s1">? stack : </span><span class="s3">''</span>
        <span class="s1">});</span>

        <span class="s1">{</span>
          <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">getDerivedStateFromError !== </span><span class="s3">'function'</span><span class="s1">) {</span>
            <span class="s0">// If componentDidCatch is the only error boundary method defined,</span>
            <span class="s0">// then it needs to call setState to recover from errors.</span>
            <span class="s0">// If no state update is scheduled then the boundary will swallow the error.</span>
            <span class="s2">if </span><span class="s1">(!includesSomeLane(fiber.lanes, SyncLane)) {</span>
              <span class="s1">error(</span><span class="s3">'%s: Error boundaries should implement getDerivedStateFromError(). ' </span><span class="s1">+ </span><span class="s3">'In that method, return a state update to display an error message or fallback UI.'</span><span class="s1">, getComponentNameFromFiber(fiber) || </span><span class="s3">'Unknown'</span><span class="s1">);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">};</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">update;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">attachPingListener(root, wakeable, lanes) {</span>
    <span class="s0">// Attach a ping listener</span>
    <span class="s0">//</span>
    <span class="s0">// The data might resolve before we have a chance to commit the fallback. Or,</span>
    <span class="s0">// in the case of a refresh, we'll never commit a fallback. So we need to</span>
    <span class="s0">// attach a listener now. When it resolves (&quot;pings&quot;), we can decide whether to</span>
    <span class="s0">// try rendering the tree again.</span>
    <span class="s0">//</span>
    <span class="s0">// Only attach a listener if one does not already exist for the lanes</span>
    <span class="s0">// we're currently rendering (which acts like a &quot;thread ID&quot; here).</span>
    <span class="s0">//</span>
    <span class="s0">// We only need to do this in concurrent mode. Legacy Suspense always</span>
    <span class="s0">// commits fallbacks synchronously, so there are no pings.</span>
    <span class="s2">var </span><span class="s1">pingCache = root.pingCache;</span>
    <span class="s2">var </span><span class="s1">threadIDs;</span>

    <span class="s2">if </span><span class="s1">(pingCache === </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">pingCache = root.pingCache = </span><span class="s2">new </span><span class="s1">PossiblyWeakMap$1();</span>
      <span class="s1">threadIDs = </span><span class="s2">new </span><span class="s1">Set();</span>
      <span class="s1">pingCache.set(wakeable, threadIDs);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">threadIDs = pingCache.get(wakeable);</span>

      <span class="s2">if </span><span class="s1">(threadIDs === undefined) {</span>
        <span class="s1">threadIDs = </span><span class="s2">new </span><span class="s1">Set();</span>
        <span class="s1">pingCache.set(wakeable, threadIDs);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(!threadIDs.has(lanes)) {</span>
      <span class="s0">// Memoize using the thread ID to prevent redundant listeners.</span>
      <span class="s1">threadIDs.add(lanes);</span>
      <span class="s2">var </span><span class="s1">ping = pingSuspendedRoot.bind(</span><span class="s2">null</span><span class="s1">, root, wakeable, lanes);</span>

      <span class="s1">wakeable.then(ping, ping);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">attachRetryListener(suspenseBoundary, root, wakeable, lanes) {</span>
    <span class="s0">// Retry listener</span>
    <span class="s0">//</span>
    <span class="s0">// If the fallback does commit, we need to attach a different type of</span>
    <span class="s0">// listener. This one schedules an update on the Suspense boundary to turn</span>
    <span class="s0">// the fallback state off.</span>
    <span class="s0">//</span>
    <span class="s0">// Stash the wakeable on the boundary fiber so we can access it in the</span>
    <span class="s0">// commit phase.</span>
    <span class="s0">//</span>
    <span class="s0">// When the wakeable resolves, we'll attempt to render the boundary</span>
    <span class="s0">// again (&quot;retry&quot;).</span>
    <span class="s2">var </span><span class="s1">wakeables = suspenseBoundary.updateQueue;</span>

    <span class="s2">if </span><span class="s1">(wakeables === </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">updateQueue = </span><span class="s2">new </span><span class="s1">Set();</span>
      <span class="s1">updateQueue.add(wakeable);</span>
      <span class="s1">suspenseBoundary.updateQueue = updateQueue;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">wakeables.add(wakeable);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">resetSuspendedComponent(sourceFiber, rootRenderLanes) {</span>
    <span class="s0">// A legacy mode Suspense quirk, only relevant to hook components.</span>


    <span class="s2">var </span><span class="s1">tag = sourceFiber.tag;</span>

    <span class="s2">if </span><span class="s1">((sourceFiber.mode &amp; ConcurrentMode) === NoMode &amp;&amp; (tag === FunctionComponent || tag === ForwardRef || tag === SimpleMemoComponent)) {</span>
      <span class="s2">var </span><span class="s1">currentSource = sourceFiber.alternate;</span>

      <span class="s2">if </span><span class="s1">(currentSource) {</span>
        <span class="s1">sourceFiber.updateQueue = currentSource.updateQueue;</span>
        <span class="s1">sourceFiber.memoizedState = currentSource.memoizedState;</span>
        <span class="s1">sourceFiber.lanes = currentSource.lanes;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">sourceFiber.updateQueue = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s1">sourceFiber.memoizedState = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">getNearestSuspenseBoundaryToCapture(returnFiber) {</span>
    <span class="s2">var </span><span class="s1">node = returnFiber;</span>

    <span class="s2">do </span><span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(node.tag === SuspenseComponent &amp;&amp; shouldCaptureSuspense(node)) {</span>
        <span class="s2">return </span><span class="s1">node;</span>
      <span class="s1">} </span><span class="s0">// This boundary already captured during this render. Continue to the next</span>
      <span class="s0">// boundary.</span>


      <span class="s1">node = node.</span><span class="s2">return</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">while </span><span class="s1">(node !== </span><span class="s2">null</span><span class="s1">);</span>

    <span class="s2">return null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root, rootRenderLanes) {</span>
    <span class="s0">// This marks a Suspense boundary so that when we're unwinding the stack,</span>
    <span class="s0">// it captures the suspended &quot;exception&quot; and does a second (fallback) pass.</span>
    <span class="s2">if </span><span class="s1">((suspenseBoundary.mode &amp; ConcurrentMode) === NoMode) {</span>
      <span class="s0">// Legacy Mode Suspense</span>
      <span class="s0">//</span>
      <span class="s0">// If the boundary is in legacy mode, we should *not*</span>
      <span class="s0">// suspend the commit. Pretend as if the suspended component rendered</span>
      <span class="s0">// null and keep rendering. When the Suspense boundary completes,</span>
      <span class="s0">// we'll do a second pass to render the fallback.</span>
      <span class="s2">if </span><span class="s1">(suspenseBoundary === returnFiber) {</span>
        <span class="s0">// Special case where we suspended while reconciling the children of</span>
        <span class="s0">// a Suspense boundary's inner Offscreen wrapper fiber. This happens</span>
        <span class="s0">// when a React.lazy component is a direct child of a</span>
        <span class="s0">// Suspense boundary.</span>
        <span class="s0">//</span>
        <span class="s0">// Suspense boundaries are implemented as multiple fibers, but they</span>
        <span class="s0">// are a single conceptual unit. The legacy mode behavior where we</span>
        <span class="s0">// pretend the suspended fiber committed as `null` won't work,</span>
        <span class="s0">// because in this case the &quot;suspended&quot; fiber is the inner</span>
        <span class="s0">// Offscreen wrapper.</span>
        <span class="s0">//</span>
        <span class="s0">// Because the contents of the boundary haven't started rendering</span>
        <span class="s0">// yet (i.e. nothing in the tree has partially rendered) we can</span>
        <span class="s0">// switch to the regular, concurrent mode behavior: mark the</span>
        <span class="s0">// boundary with ShouldCapture and enter the unwind phase.</span>
        <span class="s1">suspenseBoundary.flags |= ShouldCapture;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">suspenseBoundary.flags |= DidCapture;</span>
        <span class="s1">sourceFiber.flags |= ForceUpdateForLegacySuspense; </span><span class="s0">// We're going to commit this fiber even though it didn't complete.</span>
        <span class="s0">// But we shouldn't call any lifecycle methods or callbacks. Remove</span>
        <span class="s0">// all lifecycle effect tags.</span>

        <span class="s1">sourceFiber.flags &amp;= ~(LifecycleEffectMask | Incomplete);</span>

        <span class="s2">if </span><span class="s1">(sourceFiber.tag === ClassComponent) {</span>
          <span class="s2">var </span><span class="s1">currentSourceFiber = sourceFiber.alternate;</span>

          <span class="s2">if </span><span class="s1">(currentSourceFiber === </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s0">// This is a new mount. Change the tag so it's not mistaken for a</span>
            <span class="s0">// completed class component. For example, we should not call</span>
            <span class="s0">// componentWillUnmount if it is deleted.</span>
            <span class="s1">sourceFiber.tag = IncompleteClassComponent;</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s0">// When we try rendering again, we should not reuse the current fiber,</span>
            <span class="s0">// since it's known to be in an inconsistent state. Use a force update to</span>
            <span class="s0">// prevent a bail out.</span>
            <span class="s2">var </span><span class="s1">update = createUpdate(NoTimestamp, SyncLane);</span>
            <span class="s1">update.tag = ForceUpdate;</span>
            <span class="s1">enqueueUpdate(sourceFiber, update, SyncLane);</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s0">// The source fiber did not complete. Mark it with Sync priority to</span>
        <span class="s0">// indicate that it still has pending work.</span>


        <span class="s1">sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane);</span>
      <span class="s1">}</span>

      <span class="s2">return </span><span class="s1">suspenseBoundary;</span>
    <span class="s1">} </span><span class="s0">// Confirmed that the boundary is in a concurrent mode tree. Continue</span>
    <span class="s0">// with the normal suspend path.</span>
    <span class="s0">//</span>
    <span class="s0">// After this we'll use a set of heuristics to determine whether this</span>
    <span class="s0">// render pass will run to completion or restart or &quot;suspend&quot; the commit.</span>
    <span class="s0">// The actual logic for this is spread out in different places.</span>
    <span class="s0">//</span>
    <span class="s0">// This first principle is that if we're going to suspend when we complete</span>
    <span class="s0">// a root, then we should also restart if we get an update or ping that</span>
    <span class="s0">// might unsuspend it, and vice versa. The only reason to suspend is</span>
    <span class="s0">// because you think you might want to restart before committing. However,</span>
    <span class="s0">// it doesn't make sense to restart only while in the period we're suspended.</span>
    <span class="s0">//</span>
    <span class="s0">// Restarting too aggressively is also not good because it starves out any</span>
    <span class="s0">// intermediate loading state. So we use heuristics to determine when.</span>
    <span class="s0">// Suspense Heuristics</span>
    <span class="s0">//</span>
    <span class="s0">// If nothing threw a Promise or all the same fallbacks are already showing,</span>
    <span class="s0">// then don't suspend/restart.</span>
    <span class="s0">//</span>
    <span class="s0">// If this is an initial render of a new tree of Suspense boundaries and</span>
    <span class="s0">// those trigger a fallback, then don't suspend/restart. We want to ensure</span>
    <span class="s0">// that we can show the initial loading state as quickly as possible.</span>
    <span class="s0">//</span>
    <span class="s0">// If we hit a &quot;Delayed&quot; case, such as when we'd switch from content back into</span>
    <span class="s0">// a fallback, then we should always suspend/restart. Transitions apply</span>
    <span class="s0">// to this case. If none is defined, JND is used instead.</span>
    <span class="s0">//</span>
    <span class="s0">// If we're already showing a fallback and it gets &quot;retried&quot;, allowing us to show</span>
    <span class="s0">// another level, but there's still an inner boundary that would show a fallback,</span>
    <span class="s0">// then we suspend/restart for 500ms since the last time we showed a fallback</span>
    <span class="s0">// anywhere in the tree. This effectively throttles progressive loading into a</span>
    <span class="s0">// consistent train of commits. This also gives us an opportunity to restart to</span>
    <span class="s0">// get to the completed state slightly earlier.</span>
    <span class="s0">//</span>
    <span class="s0">// If there's ambiguity due to batching it's resolved in preference of:</span>
    <span class="s0">// 1) &quot;delayed&quot;, 2) &quot;initial render&quot;, 3) &quot;retry&quot;.</span>
    <span class="s0">//</span>
    <span class="s0">// We want to ensure that a &quot;busy&quot; state doesn't get force committed. We want to</span>
    <span class="s0">// ensure that new initial loading states can commit as soon as possible.</span>


    <span class="s1">suspenseBoundary.flags |= ShouldCapture; </span><span class="s0">// TODO: I think we can remove this, since we now use `DidCapture` in</span>
    <span class="s0">// the begin phase to prevent an early bailout.</span>

    <span class="s1">suspenseBoundary.lanes = rootRenderLanes;</span>
    <span class="s2">return </span><span class="s1">suspenseBoundary;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">throwException(root, returnFiber, sourceFiber, value, rootRenderLanes) {</span>
    <span class="s0">// The source fiber did not complete.</span>
    <span class="s1">sourceFiber.flags |= Incomplete;</span>

    <span class="s2">if </span><span class="s1">(value !== </span><span class="s2">null </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">value === </span><span class="s3">'object' </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">value.then === </span><span class="s3">'function'</span><span class="s1">) {</span>
      <span class="s0">// This is a wakeable. The component suspended.</span>
      <span class="s2">var </span><span class="s1">wakeable = value;</span>
      <span class="s1">resetSuspendedComponent(sourceFiber);</span>


      <span class="s2">var </span><span class="s1">suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);</span>

      <span class="s2">if </span><span class="s1">(suspenseBoundary !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">suspenseBoundary.flags &amp;= ~ForceClientRender;</span>
        <span class="s1">markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root, rootRenderLanes); </span><span class="s0">// We only attach ping listeners in concurrent mode. Legacy Suspense always</span>
        <span class="s0">// commits fallbacks synchronously, so there are no pings.</span>

        <span class="s2">if </span><span class="s1">(suspenseBoundary.mode &amp; ConcurrentMode) {</span>
          <span class="s1">attachPingListener(root, wakeable, rootRenderLanes);</span>
        <span class="s1">}</span>

        <span class="s1">attachRetryListener(suspenseBoundary, root, wakeable);</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s0">// No boundary was found. Unless this is a sync update, this is OK.</span>
        <span class="s0">// We can suspend and wait for more data to arrive.</span>
        <span class="s2">if </span><span class="s1">(!includesSyncLane(rootRenderLanes)) {</span>
          <span class="s0">// This is not a sync update. Suspend. Since we're not activating a</span>
          <span class="s0">// Suspense boundary, this will unwind all the way to the root without</span>
          <span class="s0">// performing a second pass to render a fallback. (This is arguably how</span>
          <span class="s0">// refresh transitions should work, too, since we're not going to commit</span>
          <span class="s0">// the fallbacks anyway.)</span>
          <span class="s0">//</span>
          <span class="s0">// This case also applies to initial hydration.</span>
          <span class="s1">attachPingListener(root, wakeable, rootRenderLanes);</span>
          <span class="s1">renderDidSuspendDelayIfPossible();</span>
          <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s0">// This is a sync/discrete update. We treat this case like an error</span>
        <span class="s0">// because discrete renders are expected to produce a complete tree</span>
        <span class="s0">// synchronously to maintain consistency with external state.</span>


        <span class="s2">var </span><span class="s1">uncaughtSuspenseError = </span><span class="s2">new </span><span class="s1">Error(</span><span class="s3">'A component suspended while responding to synchronous input. This ' </span><span class="s1">+ </span><span class="s3">'will cause the UI to be replaced with a loading indicator. To ' </span><span class="s1">+ </span><span class="s3">'fix, updates that suspend should be wrapped ' </span><span class="s1">+ </span><span class="s3">'with startTransition.'</span><span class="s1">); </span><span class="s0">// If we're outside a transition, fall through to the regular error path.</span>
        <span class="s0">// The error will be caught by the nearest suspense boundary.</span>

        <span class="s1">value = uncaughtSuspenseError;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">value = createCapturedValueAtFiber(value, sourceFiber);</span>
    <span class="s1">renderDidError(value); </span><span class="s0">// We didn't find a boundary that could handle this type of exception. Start</span>
    <span class="s0">// over and traverse parent path again, this time treating the exception</span>
    <span class="s0">// as an error.</span>

    <span class="s2">var </span><span class="s1">workInProgress = returnFiber;</span>

    <span class="s2">do </span><span class="s1">{</span>
      <span class="s2">switch </span><span class="s1">(workInProgress.tag) {</span>
        <span class="s2">case </span><span class="s1">HostRoot:</span>
          <span class="s1">{</span>
            <span class="s2">var </span><span class="s1">_errorInfo = value;</span>
            <span class="s1">workInProgress.flags |= ShouldCapture;</span>
            <span class="s2">var </span><span class="s1">lane = pickArbitraryLane(rootRenderLanes);</span>
            <span class="s1">workInProgress.lanes = mergeLanes(workInProgress.lanes, lane);</span>
            <span class="s2">var </span><span class="s1">update = createRootErrorUpdate(workInProgress, _errorInfo, lane);</span>
            <span class="s1">enqueueCapturedUpdate(workInProgress, update);</span>
            <span class="s2">return</span><span class="s1">;</span>
          <span class="s1">}</span>

        <span class="s2">case </span><span class="s1">ClassComponent:</span>
          <span class="s0">// Capture and retry</span>
          <span class="s2">var </span><span class="s1">errorInfo = value;</span>
          <span class="s2">var </span><span class="s1">ctor = workInProgress.type;</span>
          <span class="s2">var </span><span class="s1">instance = workInProgress.stateNode;</span>

          <span class="s2">if </span><span class="s1">((workInProgress.flags &amp; DidCapture) === NoFlags &amp;&amp; (</span><span class="s2">typeof </span><span class="s1">ctor.getDerivedStateFromError === </span><span class="s3">'function' </span><span class="s1">|| instance !== </span><span class="s2">null </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">instance.componentDidCatch === </span><span class="s3">'function' </span><span class="s1">&amp;&amp; !isAlreadyFailedLegacyErrorBoundary(instance))) {</span>
            <span class="s1">workInProgress.flags |= ShouldCapture;</span>

            <span class="s2">var </span><span class="s1">_lane = pickArbitraryLane(rootRenderLanes);</span>

            <span class="s1">workInProgress.lanes = mergeLanes(workInProgress.lanes, _lane); </span><span class="s0">// Schedule the error boundary to re-render using updated state</span>

            <span class="s2">var </span><span class="s1">_update = createClassErrorUpdate(workInProgress, errorInfo, _lane);</span>

            <span class="s1">enqueueCapturedUpdate(workInProgress, _update);</span>
            <span class="s2">return</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s2">break</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">workInProgress = workInProgress.</span><span class="s2">return</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">while </span><span class="s1">(workInProgress !== </span><span class="s2">null</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">getSuspendedCache() {</span>
    <span class="s1">{</span>
      <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s0">// This function is called when a Suspense boundary suspends. It returns the</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;</span>
  <span class="s2">var </span><span class="s1">didReceiveUpdate = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">didWarnAboutBadClass;</span>
  <span class="s2">var </span><span class="s1">didWarnAboutModulePatternComponent;</span>
  <span class="s2">var </span><span class="s1">didWarnAboutContextTypeOnFunctionComponent;</span>
  <span class="s2">var </span><span class="s1">didWarnAboutGetDerivedStateOnFunctionComponent;</span>
  <span class="s2">var </span><span class="s1">didWarnAboutFunctionRefs;</span>
  <span class="s2">var </span><span class="s1">didWarnAboutReassigningProps;</span>
  <span class="s2">var </span><span class="s1">didWarnAboutRevealOrder;</span>
  <span class="s2">var </span><span class="s1">didWarnAboutTailOptions;</span>

  <span class="s1">{</span>
    <span class="s1">didWarnAboutBadClass = {};</span>
    <span class="s1">didWarnAboutModulePatternComponent = {};</span>
    <span class="s1">didWarnAboutContextTypeOnFunctionComponent = {};</span>
    <span class="s1">didWarnAboutGetDerivedStateOnFunctionComponent = {};</span>
    <span class="s1">didWarnAboutFunctionRefs = {};</span>
    <span class="s1">didWarnAboutReassigningProps = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">didWarnAboutRevealOrder = {};</span>
    <span class="s1">didWarnAboutTailOptions = {};</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">reconcileChildren(current, workInProgress, nextChildren, renderLanes) {</span>
    <span class="s2">if </span><span class="s1">(current === </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s0">// If this is a fresh new component that hasn't been rendered yet, we</span>
      <span class="s0">// won't update its child set by applying minimal side-effects. Instead,</span>
      <span class="s0">// we will add them all to the child before it gets rendered. That means</span>
      <span class="s0">// we can optimize this reconciliation pass by not tracking side-effects.</span>
      <span class="s1">workInProgress.child = mountChildFibers(workInProgress, </span><span class="s2">null</span><span class="s1">, nextChildren, renderLanes);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s0">// If the current child is the same as the work in progress, it means that</span>
      <span class="s0">// we haven't yet started any work on these children. Therefore, we use</span>
      <span class="s0">// the clone algorithm to create a copy of all the current children.</span>
      <span class="s0">// If we had any progressed work already, that is invalid at this point so</span>
      <span class="s0">// let's throw it out.</span>
      <span class="s1">workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren, renderLanes);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">forceUnmountCurrentAndReconcile(current, workInProgress, nextChildren, renderLanes) {</span>
    <span class="s0">// This function is fork of reconcileChildren. It's used in cases where we</span>
    <span class="s0">// want to reconcile without matching against the existing set. This has the</span>
    <span class="s0">// effect of all current children being unmounted; even if the type and key</span>
    <span class="s0">// are the same, the old child is unmounted and a new child is created.</span>
    <span class="s0">//</span>
    <span class="s0">// To do this, we're going to go through the reconcile algorithm twice. In</span>
    <span class="s0">// the first pass, we schedule a deletion for all the current children by</span>
    <span class="s0">// passing null.</span>
    <span class="s1">workInProgress.child = reconcileChildFibers(workInProgress, current.child, </span><span class="s2">null</span><span class="s1">, renderLanes); </span><span class="s0">// In the second pass, we mount the new children. The trick here is that we</span>
    <span class="s0">// pass null in place of where we usually pass the current child set. This has</span>
    <span class="s0">// the effect of remounting all children regardless of whether their</span>
    <span class="s0">// identities match.</span>

    <span class="s1">workInProgress.child = reconcileChildFibers(workInProgress, </span><span class="s2">null</span><span class="s1">, nextChildren, renderLanes);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">updateForwardRef(current, workInProgress, Component, nextProps, renderLanes) {</span>
    <span class="s0">// TODO: current can be non-null here even if the component</span>
    <span class="s0">// hasn't yet mounted. This happens after the first render suspends.</span>
    <span class="s0">// We'll need to figure out if this is fine or can cause issues.</span>
    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(workInProgress.type !== workInProgress.elementType) {</span>
        <span class="s0">// Lazy component props can't be validated in createElement</span>
        <span class="s0">// because they're only guaranteed to be resolved here.</span>
        <span class="s2">var </span><span class="s1">innerPropTypes = Component.propTypes;</span>

        <span class="s2">if </span><span class="s1">(innerPropTypes) {</span>
          <span class="s1">checkPropTypes(innerPropTypes, nextProps, </span><span class="s0">// Resolved props</span>
          <span class="s3">'prop'</span><span class="s1">, getComponentNameFromType(Component));</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">render = Component.render;</span>
    <span class="s2">var </span><span class="s1">ref = workInProgress.ref; </span><span class="s0">// The rest is a fork of updateFunctionComponent</span>

    <span class="s2">var </span><span class="s1">nextChildren;</span>
    <span class="s1">prepareToReadContext(workInProgress, renderLanes);</span>

    <span class="s1">{</span>
      <span class="s1">ReactCurrentOwner$1.current = workInProgress;</span>
      <span class="s1">setIsRendering(</span><span class="s2">true</span><span class="s1">);</span>
      <span class="s1">nextChildren = renderWithHooks(current, workInProgress, render, nextProps, ref, renderLanes);</span>

      <span class="s1">setIsRendering(</span><span class="s2">false</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(current !== </span><span class="s2">null </span><span class="s1">&amp;&amp; !didReceiveUpdate) {</span>
      <span class="s1">bailoutHooks(current, workInProgress, renderLanes);</span>
      <span class="s2">return </span><span class="s1">bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);</span>
    <span class="s1">}</span>


    <span class="s1">workInProgress.flags |= PerformedWork;</span>
    <span class="s1">reconcileChildren(current, workInProgress, nextChildren, renderLanes);</span>
    <span class="s2">return </span><span class="s1">workInProgress.child;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">updateMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {</span>
    <span class="s2">if </span><span class="s1">(current === </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">type = Component.type;</span>

      <span class="s2">if </span><span class="s1">(isSimpleFunctionComponent(type) &amp;&amp; Component.compare === </span><span class="s2">null </span><span class="s1">&amp;&amp; </span><span class="s0">// SimpleMemoComponent codepath doesn't resolve outer props either.</span>
      <span class="s1">Component.defaultProps === undefined) {</span>
        <span class="s2">var </span><span class="s1">resolvedType = type;</span>

        <span class="s1">{</span>
          <span class="s1">resolvedType = resolveFunctionForHotReloading(type);</span>
        <span class="s1">} </span><span class="s0">// If this is a plain function component without default props,</span>
        <span class="s0">// and with only the default shallow comparison, we upgrade it</span>
        <span class="s0">// to a SimpleMemoComponent to allow fast path updates.</span>


        <span class="s1">workInProgress.tag = SimpleMemoComponent;</span>
        <span class="s1">workInProgress.type = resolvedType;</span>

        <span class="s1">{</span>
          <span class="s1">validateFunctionComponentInDev(workInProgress, type);</span>
        <span class="s1">}</span>

        <span class="s2">return </span><span class="s1">updateSimpleMemoComponent(current, workInProgress, resolvedType, nextProps, renderLanes);</span>
      <span class="s1">}</span>

      <span class="s1">{</span>
        <span class="s2">var </span><span class="s1">innerPropTypes = type.propTypes;</span>

        <span class="s2">if </span><span class="s1">(innerPropTypes) {</span>
          <span class="s0">// Inner memo component props aren't currently validated in createElement.</span>
          <span class="s0">// We could move it there, but we'd still need this for lazy code path.</span>
          <span class="s1">checkPropTypes(innerPropTypes, nextProps, </span><span class="s0">// Resolved props</span>
          <span class="s3">'prop'</span><span class="s1">, getComponentNameFromType(type));</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">child = createFiberFromTypeAndProps(Component.type, </span><span class="s2">null</span><span class="s1">, nextProps, workInProgress, workInProgress.mode, renderLanes);</span>
      <span class="s1">child.ref = workInProgress.ref;</span>
      <span class="s1">child.</span><span class="s2">return </span><span class="s1">= workInProgress;</span>
      <span class="s1">workInProgress.child = child;</span>
      <span class="s2">return </span><span class="s1">child;</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s2">var </span><span class="s1">_type = Component.type;</span>
      <span class="s2">var </span><span class="s1">_innerPropTypes = _type.propTypes;</span>

      <span class="s2">if </span><span class="s1">(_innerPropTypes) {</span>
        <span class="s0">// Inner memo component props aren't currently validated in createElement.</span>
        <span class="s0">// We could move it there, but we'd still need this for lazy code path.</span>
        <span class="s1">checkPropTypes(_innerPropTypes, nextProps, </span><span class="s0">// Resolved props</span>
        <span class="s3">'prop'</span><span class="s1">, getComponentNameFromType(_type));</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">currentChild = current.child; </span><span class="s0">// This is always exactly one child</span>

    <span class="s2">var </span><span class="s1">hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current, renderLanes);</span>

    <span class="s2">if </span><span class="s1">(!hasScheduledUpdateOrContext) {</span>
      <span class="s0">// This will be the props with resolved defaultProps,</span>
      <span class="s0">// unlike current.memoizedProps which will be the unresolved ones.</span>
      <span class="s2">var </span><span class="s1">prevProps = currentChild.memoizedProps; </span><span class="s0">// Default to shallow comparison</span>

      <span class="s2">var </span><span class="s1">compare = Component.compare;</span>
      <span class="s1">compare = compare !== </span><span class="s2">null </span><span class="s1">? compare : shallowEqual;</span>

      <span class="s2">if </span><span class="s1">(compare(prevProps, nextProps) &amp;&amp; current.ref === workInProgress.ref) {</span>
        <span class="s2">return </span><span class="s1">bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// React DevTools reads this flag.</span>


    <span class="s1">workInProgress.flags |= PerformedWork;</span>
    <span class="s2">var </span><span class="s1">newChild = createWorkInProgress(currentChild, nextProps);</span>
    <span class="s1">newChild.ref = workInProgress.ref;</span>
    <span class="s1">newChild.</span><span class="s2">return </span><span class="s1">= workInProgress;</span>
    <span class="s1">workInProgress.child = newChild;</span>
    <span class="s2">return </span><span class="s1">newChild;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">updateSimpleMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {</span>
    <span class="s0">// TODO: current can be non-null here even if the component</span>
    <span class="s0">// hasn't yet mounted. This happens when the inner render suspends.</span>
    <span class="s0">// We'll need to figure out if this is fine or can cause issues.</span>
    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(workInProgress.type !== workInProgress.elementType) {</span>
        <span class="s0">// Lazy component props can't be validated in createElement</span>
        <span class="s0">// because they're only guaranteed to be resolved here.</span>
        <span class="s2">var </span><span class="s1">outerMemoType = workInProgress.elementType;</span>

        <span class="s2">if </span><span class="s1">(outerMemoType.$$typeof === REACT_LAZY_TYPE) {</span>
          <span class="s0">// We warn when you define propTypes on lazy()</span>
          <span class="s0">// so let's just skip over it to find memo() outer wrapper.</span>
          <span class="s0">// Inner props for memo are validated later.</span>
          <span class="s2">var </span><span class="s1">lazyComponent = outerMemoType;</span>
          <span class="s2">var </span><span class="s1">payload = lazyComponent._payload;</span>
          <span class="s2">var </span><span class="s1">init = lazyComponent._init;</span>

          <span class="s2">try </span><span class="s1">{</span>
            <span class="s1">outerMemoType = init(payload);</span>
          <span class="s1">} </span><span class="s2">catch </span><span class="s1">(x) {</span>
            <span class="s1">outerMemoType = </span><span class="s2">null</span><span class="s1">;</span>
          <span class="s1">} </span><span class="s0">// Inner propTypes will be validated in the function component path.</span>


          <span class="s2">var </span><span class="s1">outerPropTypes = outerMemoType &amp;&amp; outerMemoType.propTypes;</span>

          <span class="s2">if </span><span class="s1">(outerPropTypes) {</span>
            <span class="s1">checkPropTypes(outerPropTypes, nextProps, </span><span class="s0">// Resolved (SimpleMemoComponent has no defaultProps)</span>
            <span class="s3">'prop'</span><span class="s1">, getComponentNameFromType(outerMemoType));</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(current !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">prevProps = current.memoizedProps;</span>

      <span class="s2">if </span><span class="s1">(shallowEqual(prevProps, nextProps) &amp;&amp; current.ref === workInProgress.ref &amp;&amp; ( </span><span class="s0">// Prevent bailout if the implementation changed due to hot reload.</span>
       <span class="s1">workInProgress.type === current.type )) {</span>
        <span class="s1">didReceiveUpdate = </span><span class="s2">false</span><span class="s1">; </span><span class="s0">// The props are shallowly equal. Reuse the previous props object, like we</span>
        <span class="s0">// would during a normal fiber bailout.</span>
        <span class="s0">//</span>
        <span class="s0">// We don't have strong guarantees that the props object is referentially</span>
        <span class="s0">// equal during updates where we can't bail out anyway  like if the props</span>
        <span class="s0">// are shallowly equal, but there's a local state or context update in the</span>
        <span class="s0">// same batch.</span>
        <span class="s0">//</span>
        <span class="s0">// However, as a principle, we should aim to make the behavior consistent</span>
        <span class="s0">// across different ways of memoizing a component. For example, React.memo</span>
        <span class="s0">// has a different internal Fiber layout if you pass a normal function</span>
        <span class="s0">// component (SimpleMemoComponent) versus if you pass a different type</span>
        <span class="s0">// like forwardRef (MemoComponent). But this is an implementation detail.</span>
        <span class="s0">// Wrapping a component in forwardRef (or React.lazy, etc) shouldn't</span>
        <span class="s0">// affect whether the props object is reused during a bailout.</span>

        <span class="s1">workInProgress.pendingProps = nextProps = prevProps;</span>

        <span class="s2">if </span><span class="s1">(!checkScheduledUpdateOrContext(current, renderLanes)) {</span>
          <span class="s0">// The pending lanes were cleared at the beginning of beginWork. We're</span>
          <span class="s0">// about to bail out, but there might be other lanes that weren't</span>
          <span class="s0">// included in the current render. Usually, the priority level of the</span>
          <span class="s0">// remaining updates is accumulated during the evaluation of the</span>
          <span class="s0">// component (i.e. when processing the update queue). But since since</span>
          <span class="s0">// we're bailing out early *without* evaluating the component, we need</span>
          <span class="s0">// to account for it here, too. Reset to the value of the current fiber.</span>
          <span class="s0">// NOTE: This only applies to SimpleMemoComponent, not MemoComponent,</span>
          <span class="s0">// because a MemoComponent fiber does not have hooks or an update queue;</span>
          <span class="s0">// rather, it wraps around an inner component, which may or may not</span>
          <span class="s0">// contains hooks.</span>
          <span class="s0">// TODO: Move the reset at in beginWork out of the common path so that</span>
          <span class="s0">// this is no longer necessary.</span>
          <span class="s1">workInProgress.lanes = current.lanes;</span>
          <span class="s2">return </span><span class="s1">bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">((current.flags &amp; ForceUpdateForLegacySuspense) !== NoFlags) {</span>
          <span class="s0">// This is a special case that only exists for legacy mode.</span>
          <span class="s0">// See https://github.com/facebook/react/pull/19216.</span>
          <span class="s1">didReceiveUpdate = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">updateOffscreenComponent(current, workInProgress, renderLanes) {</span>
    <span class="s2">var </span><span class="s1">nextProps = workInProgress.pendingProps;</span>
    <span class="s2">var </span><span class="s1">nextChildren = nextProps.children;</span>
    <span class="s2">var </span><span class="s1">prevState = current !== </span><span class="s2">null </span><span class="s1">? current.memoizedState : </span><span class="s2">null</span><span class="s1">;</span>

    <span class="s2">if </span><span class="s1">(nextProps.mode === </span><span class="s3">'hidden' </span><span class="s1">|| enableLegacyHidden ) {</span>
      <span class="s0">// Rendering a hidden tree.</span>
      <span class="s2">if </span><span class="s1">((workInProgress.mode &amp; ConcurrentMode) === NoMode) {</span>
        <span class="s0">// In legacy sync mode, don't defer the subtree. Render it now.</span>
        <span class="s0">// TODO: Consider how Offscreen should work with transitions in the future</span>
        <span class="s2">var </span><span class="s1">nextState = {</span>
          <span class="s1">baseLanes: NoLanes,</span>
          <span class="s1">cachePool: </span><span class="s2">null</span><span class="s1">,</span>
          <span class="s1">transitions: </span><span class="s2">null</span>
        <span class="s1">};</span>
        <span class="s1">workInProgress.memoizedState = nextState;</span>

        <span class="s1">pushRenderLanes(workInProgress, renderLanes);</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!includesSomeLane(renderLanes, OffscreenLane)) {</span>
        <span class="s2">var </span><span class="s1">spawnedCachePool = </span><span class="s2">null</span><span class="s1">; </span><span class="s0">// We're hidden, and we're not rendering at Offscreen. We will bail out</span>
        <span class="s0">// and resume this tree later.</span>

        <span class="s2">var </span><span class="s1">nextBaseLanes;</span>

        <span class="s2">if </span><span class="s1">(prevState !== </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s2">var </span><span class="s1">prevBaseLanes = prevState.baseLanes;</span>
          <span class="s1">nextBaseLanes = mergeLanes(prevBaseLanes, renderLanes);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">nextBaseLanes = renderLanes;</span>
        <span class="s1">} </span><span class="s0">// Schedule this fiber to re-render at offscreen priority. Then bailout.</span>


        <span class="s1">workInProgress.lanes = workInProgress.childLanes = laneToLanes(OffscreenLane);</span>
        <span class="s2">var </span><span class="s1">_nextState = {</span>
          <span class="s1">baseLanes: nextBaseLanes,</span>
          <span class="s1">cachePool: spawnedCachePool,</span>
          <span class="s1">transitions: </span><span class="s2">null</span>
        <span class="s1">};</span>
        <span class="s1">workInProgress.memoizedState = _nextState;</span>
        <span class="s1">workInProgress.updateQueue = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s0">// to avoid a push/pop misalignment.</span>


        <span class="s1">pushRenderLanes(workInProgress, nextBaseLanes);</span>

        <span class="s2">return null</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s0">// This is the second render. The surrounding visible content has already</span>
        <span class="s0">// committed. Now we resume rendering the hidden tree.</span>
        <span class="s0">// Rendering at offscreen, so we can clear the base lanes.</span>
        <span class="s2">var </span><span class="s1">_nextState2 = {</span>
          <span class="s1">baseLanes: NoLanes,</span>
          <span class="s1">cachePool: </span><span class="s2">null</span><span class="s1">,</span>
          <span class="s1">transitions: </span><span class="s2">null</span>
        <span class="s1">};</span>
        <span class="s1">workInProgress.memoizedState = _nextState2; </span><span class="s0">// Push the lanes that were skipped when we bailed out.</span>

        <span class="s2">var </span><span class="s1">subtreeRenderLanes = prevState !== </span><span class="s2">null </span><span class="s1">? prevState.baseLanes : renderLanes;</span>

        <span class="s1">pushRenderLanes(workInProgress, subtreeRenderLanes);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s0">// Rendering a visible tree.</span>
      <span class="s2">var </span><span class="s1">_subtreeRenderLanes;</span>

      <span class="s2">if </span><span class="s1">(prevState !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s0">// We're going from hidden -&gt; visible.</span>
        <span class="s1">_subtreeRenderLanes = mergeLanes(prevState.baseLanes, renderLanes);</span>

        <span class="s1">workInProgress.memoizedState = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s0">// We weren't previously hidden, and we still aren't, so there's nothing</span>
        <span class="s0">// special to do. Need to push to the stack regardless, though, to avoid</span>
        <span class="s0">// a push/pop misalignment.</span>
        <span class="s1">_subtreeRenderLanes = renderLanes;</span>
      <span class="s1">}</span>

      <span class="s1">pushRenderLanes(workInProgress, _subtreeRenderLanes);</span>
    <span class="s1">}</span>

    <span class="s1">reconcileChildren(current, workInProgress, nextChildren, renderLanes);</span>
    <span class="s2">return </span><span class="s1">workInProgress.child;</span>
  <span class="s1">} </span><span class="s0">// Note: These happen to have identical begin phases, for now. We shouldn't hold</span>

  <span class="s2">function </span><span class="s1">updateFragment(current, workInProgress, renderLanes) {</span>
    <span class="s2">var </span><span class="s1">nextChildren = workInProgress.pendingProps;</span>
    <span class="s1">reconcileChildren(current, workInProgress, nextChildren, renderLanes);</span>
    <span class="s2">return </span><span class="s1">workInProgress.child;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">updateMode(current, workInProgress, renderLanes) {</span>
    <span class="s2">var </span><span class="s1">nextChildren = workInProgress.pendingProps.children;</span>
    <span class="s1">reconcileChildren(current, workInProgress, nextChildren, renderLanes);</span>
    <span class="s2">return </span><span class="s1">workInProgress.child;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">updateProfiler(current, workInProgress, renderLanes) {</span>
    <span class="s1">{</span>
      <span class="s1">workInProgress.flags |= Update;</span>

      <span class="s1">{</span>
        <span class="s0">// Reset effect durations for the next eventual effect phase.</span>
        <span class="s0">// These are reset during render to allow the DevTools commit hook a chance to read them,</span>
        <span class="s2">var </span><span class="s1">stateNode = workInProgress.stateNode;</span>
        <span class="s1">stateNode.effectDuration = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">stateNode.passiveEffectDuration = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">nextProps = workInProgress.pendingProps;</span>
    <span class="s2">var </span><span class="s1">nextChildren = nextProps.children;</span>
    <span class="s1">reconcileChildren(current, workInProgress, nextChildren, renderLanes);</span>
    <span class="s2">return </span><span class="s1">workInProgress.child;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">markRef(current, workInProgress) {</span>
    <span class="s2">var </span><span class="s1">ref = workInProgress.ref;</span>

    <span class="s2">if </span><span class="s1">(current === </span><span class="s2">null </span><span class="s1">&amp;&amp; ref !== </span><span class="s2">null </span><span class="s1">|| current !== </span><span class="s2">null </span><span class="s1">&amp;&amp; current.ref !== ref) {</span>
      <span class="s0">// Schedule a Ref effect</span>
      <span class="s1">workInProgress.flags |= Ref;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes) {</span>
    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(workInProgress.type !== workInProgress.elementType) {</span>
        <span class="s0">// Lazy component props can't be validated in createElement</span>
        <span class="s0">// because they're only guaranteed to be resolved here.</span>
        <span class="s2">var </span><span class="s1">innerPropTypes = Component.propTypes;</span>

        <span class="s2">if </span><span class="s1">(innerPropTypes) {</span>
          <span class="s1">checkPropTypes(innerPropTypes, nextProps, </span><span class="s0">// Resolved props</span>
          <span class="s3">'prop'</span><span class="s1">, getComponentNameFromType(Component));</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">context;</span>

    <span class="s1">{</span>
      <span class="s2">var </span><span class="s1">unmaskedContext = getUnmaskedContext(workInProgress, Component, </span><span class="s2">true</span><span class="s1">);</span>
      <span class="s1">context = getMaskedContext(workInProgress, unmaskedContext);</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">nextChildren;</span>
    <span class="s1">prepareToReadContext(workInProgress, renderLanes);</span>

    <span class="s1">{</span>
      <span class="s1">ReactCurrentOwner$1.current = workInProgress;</span>
      <span class="s1">setIsRendering(</span><span class="s2">true</span><span class="s1">);</span>
      <span class="s1">nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, context, renderLanes);</span>

      <span class="s1">setIsRendering(</span><span class="s2">false</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(current !== </span><span class="s2">null </span><span class="s1">&amp;&amp; !didReceiveUpdate) {</span>
      <span class="s1">bailoutHooks(current, workInProgress, renderLanes);</span>
      <span class="s2">return </span><span class="s1">bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);</span>
    <span class="s1">}</span>


    <span class="s1">workInProgress.flags |= PerformedWork;</span>
    <span class="s1">reconcileChildren(current, workInProgress, nextChildren, renderLanes);</span>
    <span class="s2">return </span><span class="s1">workInProgress.child;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">updateClassComponent(current, workInProgress, Component, nextProps, renderLanes) {</span>
    <span class="s1">{</span>
      <span class="s0">// This is used by DevTools to force a boundary to error.</span>
      <span class="s2">switch </span><span class="s1">(shouldError(workInProgress)) {</span>
        <span class="s2">case false</span><span class="s1">:</span>
          <span class="s1">{</span>
            <span class="s2">var </span><span class="s1">_instance = workInProgress.stateNode;</span>
            <span class="s2">var </span><span class="s1">ctor = workInProgress.type; </span><span class="s0">// TODO This way of resetting the error boundary state is a hack.</span>
            <span class="s0">// Is there a better way to do this?</span>

            <span class="s2">var </span><span class="s1">tempInstance = </span><span class="s2">new </span><span class="s1">ctor(workInProgress.memoizedProps, _instance.context);</span>
            <span class="s2">var </span><span class="s1">state = tempInstance.state;</span>

            <span class="s1">_instance.updater.enqueueSetState(_instance, state, </span><span class="s2">null</span><span class="s1">);</span>

            <span class="s2">break</span><span class="s1">;</span>
          <span class="s1">}</span>

        <span class="s2">case true</span><span class="s1">:</span>
          <span class="s1">{</span>
            <span class="s1">workInProgress.flags |= DidCapture;</span>
            <span class="s1">workInProgress.flags |= ShouldCapture; </span><span class="s0">// eslint-disable-next-line react-internal/prod-error-codes</span>

            <span class="s2">var </span><span class="s1">error$1 = </span><span class="s2">new </span><span class="s1">Error(</span><span class="s3">'Simulated error coming from DevTools'</span><span class="s1">);</span>
            <span class="s2">var </span><span class="s1">lane = pickArbitraryLane(renderLanes);</span>
            <span class="s1">workInProgress.lanes = mergeLanes(workInProgress.lanes, lane); </span><span class="s0">// Schedule the error boundary to re-render using updated state</span>

            <span class="s2">var </span><span class="s1">update = createClassErrorUpdate(workInProgress, createCapturedValueAtFiber(error$1, workInProgress), lane);</span>
            <span class="s1">enqueueCapturedUpdate(workInProgress, update);</span>
            <span class="s2">break</span><span class="s1">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(workInProgress.type !== workInProgress.elementType) {</span>
        <span class="s0">// Lazy component props can't be validated in createElement</span>
        <span class="s0">// because they're only guaranteed to be resolved here.</span>
        <span class="s2">var </span><span class="s1">innerPropTypes = Component.propTypes;</span>

        <span class="s2">if </span><span class="s1">(innerPropTypes) {</span>
          <span class="s1">checkPropTypes(innerPropTypes, nextProps, </span><span class="s0">// Resolved props</span>
          <span class="s3">'prop'</span><span class="s1">, getComponentNameFromType(Component));</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// Push context providers early to prevent context stack mismatches.</span>
    <span class="s0">// During mounting we don't know the child context yet as the instance doesn't exist.</span>
    <span class="s0">// We will invalidate the child context in finishClassComponent() right after rendering.</span>


    <span class="s2">var </span><span class="s1">hasContext;</span>

    <span class="s2">if </span><span class="s1">(isContextProvider(Component)) {</span>
      <span class="s1">hasContext = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s1">pushContextProvider(workInProgress);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">hasContext = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">prepareToReadContext(workInProgress, renderLanes);</span>
    <span class="s2">var </span><span class="s1">instance = workInProgress.stateNode;</span>
    <span class="s2">var </span><span class="s1">shouldUpdate;</span>

    <span class="s2">if </span><span class="s1">(instance === </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">resetSuspendedCurrentOnMountInLegacyMode(current, workInProgress); </span><span class="s0">// In the initial pass we might need to construct the instance.</span>

      <span class="s1">constructClassInstance(workInProgress, Component, nextProps);</span>
      <span class="s1">mountClassInstance(workInProgress, Component, nextProps, renderLanes);</span>
      <span class="s1">shouldUpdate = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(current === </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s0">// In a resume, we'll already have an instance we can reuse.</span>
      <span class="s1">shouldUpdate = resumeMountClassInstance(workInProgress, Component, nextProps, renderLanes);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">shouldUpdate = updateClassInstance(current, workInProgress, Component, nextProps, renderLanes);</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">nextUnitOfWork = finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderLanes);</span>

    <span class="s1">{</span>
      <span class="s2">var </span><span class="s1">inst = workInProgress.stateNode;</span>

      <span class="s2">if </span><span class="s1">(shouldUpdate &amp;&amp; inst.props !== nextProps) {</span>
        <span class="s2">if </span><span class="s1">(!didWarnAboutReassigningProps) {</span>
          <span class="s1">error(</span><span class="s3">'It looks like %s is reassigning its own `this.props` while rendering. ' </span><span class="s1">+ </span><span class="s3">'This is not supported and can lead to confusing bugs.'</span><span class="s1">, getComponentNameFromFiber(workInProgress) || </span><span class="s3">'a component'</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s1">didWarnAboutReassigningProps = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">nextUnitOfWork;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderLanes) {</span>
    <span class="s0">// Refs should update even if shouldComponentUpdate returns false</span>
    <span class="s1">markRef(current, workInProgress);</span>
    <span class="s2">var </span><span class="s1">didCaptureError = (workInProgress.flags &amp; DidCapture) !== NoFlags;</span>

    <span class="s2">if </span><span class="s1">(!shouldUpdate &amp;&amp; !didCaptureError) {</span>
      <span class="s0">// Context providers should defer to sCU for rendering</span>
      <span class="s2">if </span><span class="s1">(hasContext) {</span>
        <span class="s1">invalidateContextProvider(workInProgress, Component, </span><span class="s2">false</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s2">return </span><span class="s1">bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">instance = workInProgress.stateNode; </span><span class="s0">// Rerender</span>

    <span class="s1">ReactCurrentOwner$1.current = workInProgress;</span>
    <span class="s2">var </span><span class="s1">nextChildren;</span>

    <span class="s2">if </span><span class="s1">(didCaptureError &amp;&amp; </span><span class="s2">typeof </span><span class="s1">Component.getDerivedStateFromError !== </span><span class="s3">'function'</span><span class="s1">) {</span>
      <span class="s0">// If we captured an error, but getDerivedStateFromError is not defined,</span>
      <span class="s0">// unmount all the children. componentDidCatch will schedule an update to</span>
      <span class="s0">// re-render a fallback. This is temporary until we migrate everyone to</span>
      <span class="s0">// the new API.</span>
      <span class="s0">// TODO: Warn in a future release.</span>
      <span class="s1">nextChildren = </span><span class="s2">null</span><span class="s1">;</span>

      <span class="s1">{</span>
        <span class="s1">stopProfilerTimerIfRunning();</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>

      <span class="s1">{</span>
        <span class="s1">setIsRendering(</span><span class="s2">true</span><span class="s1">);</span>
        <span class="s1">nextChildren = instance.render();</span>

        <span class="s1">setIsRendering(</span><span class="s2">false</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// React DevTools reads this flag.</span>


    <span class="s1">workInProgress.flags |= PerformedWork;</span>

    <span class="s2">if </span><span class="s1">(current !== </span><span class="s2">null </span><span class="s1">&amp;&amp; didCaptureError) {</span>
      <span class="s0">// If we're recovering from an error, reconcile without reusing any of</span>
      <span class="s0">// the existing children. Conceptually, the normal children and the children</span>
      <span class="s0">// that are shown on error are two different sets, so we shouldn't reuse</span>
      <span class="s0">// normal children even if their identities match.</span>
      <span class="s1">forceUnmountCurrentAndReconcile(current, workInProgress, nextChildren, renderLanes);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">reconcileChildren(current, workInProgress, nextChildren, renderLanes);</span>
    <span class="s1">} </span><span class="s0">// Memoize state using the values we just used to render.</span>
    <span class="s0">// TODO: Restructure so we never read values from the instance.</span>


    <span class="s1">workInProgress.memoizedState = instance.state; </span><span class="s0">// The context might have changed so we need to recalculate it.</span>

    <span class="s2">if </span><span class="s1">(hasContext) {</span>
      <span class="s1">invalidateContextProvider(workInProgress, Component, </span><span class="s2">true</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">workInProgress.child;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">pushHostRootContext(workInProgress) {</span>
    <span class="s2">var </span><span class="s1">root = workInProgress.stateNode;</span>

    <span class="s2">if </span><span class="s1">(root.pendingContext) {</span>
      <span class="s1">pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context);</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(root.context) {</span>
      <span class="s0">// Should always be set</span>
      <span class="s1">pushTopLevelContextObject(workInProgress, root.context, </span><span class="s2">false</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s1">pushHostContainer(workInProgress, root.containerInfo);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">updateHostRoot(current, workInProgress, renderLanes) {</span>
    <span class="s1">pushHostRootContext(workInProgress);</span>

    <span class="s2">if </span><span class="s1">(current === </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Should have a current fiber. This is a bug in React.'</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">nextProps = workInProgress.pendingProps;</span>
    <span class="s2">var </span><span class="s1">prevState = workInProgress.memoizedState;</span>
    <span class="s2">var </span><span class="s1">prevChildren = prevState.element;</span>
    <span class="s1">cloneUpdateQueue(current, workInProgress);</span>
    <span class="s1">processUpdateQueue(workInProgress, nextProps, </span><span class="s2">null</span><span class="s1">, renderLanes);</span>
    <span class="s2">var </span><span class="s1">nextState = workInProgress.memoizedState;</span>
    <span class="s2">var </span><span class="s1">root = workInProgress.stateNode;</span>
    <span class="s0">// being called &quot;element&quot;.</span>


    <span class="s2">var </span><span class="s1">nextChildren = nextState.element;</span>

    <span class="s1">{</span>

      <span class="s2">if </span><span class="s1">(nextChildren === prevChildren) {</span>
        <span class="s2">return </span><span class="s1">bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);</span>
      <span class="s1">}</span>

      <span class="s1">reconcileChildren(current, workInProgress, nextChildren, renderLanes);</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">workInProgress.child;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">updateHostComponent(current, workInProgress, renderLanes) {</span>
    <span class="s1">pushHostContext(workInProgress);</span>

    <span class="s2">var </span><span class="s1">type = workInProgress.type;</span>
    <span class="s2">var </span><span class="s1">nextProps = workInProgress.pendingProps;</span>
    <span class="s2">var </span><span class="s1">prevProps = current !== </span><span class="s2">null </span><span class="s1">? current.memoizedProps : </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">var </span><span class="s1">nextChildren = nextProps.children;</span>

    <span class="s2">if </span><span class="s1">(prevProps !== </span><span class="s2">null </span><span class="s1">&amp;&amp; shouldSetTextContent()) {</span>
      <span class="s0">// If we're switching from a direct text child to a normal child, or to</span>
      <span class="s0">// empty, we need to schedule the text content to be reset.</span>
      <span class="s1">workInProgress.flags |= ContentReset;</span>
    <span class="s1">}</span>

    <span class="s1">markRef(current, workInProgress);</span>
    <span class="s1">reconcileChildren(current, workInProgress, nextChildren, renderLanes);</span>
    <span class="s2">return </span><span class="s1">workInProgress.child;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">updateHostText(current, workInProgress) {</span>
    <span class="s0">// immediately after.</span>


    <span class="s2">return null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">mountLazyComponent(_current, workInProgress, elementType, renderLanes) {</span>
    <span class="s1">resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress);</span>
    <span class="s2">var </span><span class="s1">props = workInProgress.pendingProps;</span>
    <span class="s2">var </span><span class="s1">lazyComponent = elementType;</span>
    <span class="s2">var </span><span class="s1">payload = lazyComponent._payload;</span>
    <span class="s2">var </span><span class="s1">init = lazyComponent._init;</span>
    <span class="s2">var </span><span class="s1">Component = init(payload); </span><span class="s0">// Store the unwrapped component in the type.</span>

    <span class="s1">workInProgress.type = Component;</span>
    <span class="s2">var </span><span class="s1">resolvedTag = workInProgress.tag = resolveLazyComponentTag(Component);</span>
    <span class="s2">var </span><span class="s1">resolvedProps = resolveDefaultProps(Component, props);</span>
    <span class="s2">var </span><span class="s1">child;</span>

    <span class="s2">switch </span><span class="s1">(resolvedTag) {</span>
      <span class="s2">case </span><span class="s1">FunctionComponent:</span>
        <span class="s1">{</span>
          <span class="s1">{</span>
            <span class="s1">validateFunctionComponentInDev(workInProgress, Component);</span>
            <span class="s1">workInProgress.type = Component = resolveFunctionForHotReloading(Component);</span>
          <span class="s1">}</span>

          <span class="s1">child = updateFunctionComponent(</span><span class="s2">null</span><span class="s1">, workInProgress, Component, resolvedProps, renderLanes);</span>
          <span class="s2">return </span><span class="s1">child;</span>
        <span class="s1">}</span>

      <span class="s2">case </span><span class="s1">ClassComponent:</span>
        <span class="s1">{</span>
          <span class="s1">{</span>
            <span class="s1">workInProgress.type = Component = resolveClassForHotReloading(Component);</span>
          <span class="s1">}</span>

          <span class="s1">child = updateClassComponent(</span><span class="s2">null</span><span class="s1">, workInProgress, Component, resolvedProps, renderLanes);</span>
          <span class="s2">return </span><span class="s1">child;</span>
        <span class="s1">}</span>

      <span class="s2">case </span><span class="s1">ForwardRef:</span>
        <span class="s1">{</span>
          <span class="s1">{</span>
            <span class="s1">workInProgress.type = Component = resolveForwardRefForHotReloading(Component);</span>
          <span class="s1">}</span>

          <span class="s1">child = updateForwardRef(</span><span class="s2">null</span><span class="s1">, workInProgress, Component, resolvedProps, renderLanes);</span>
          <span class="s2">return </span><span class="s1">child;</span>
        <span class="s1">}</span>

      <span class="s2">case </span><span class="s1">MemoComponent:</span>
        <span class="s1">{</span>
          <span class="s1">{</span>
            <span class="s2">if </span><span class="s1">(workInProgress.type !== workInProgress.elementType) {</span>
              <span class="s2">var </span><span class="s1">outerPropTypes = Component.propTypes;</span>

              <span class="s2">if </span><span class="s1">(outerPropTypes) {</span>
                <span class="s1">checkPropTypes(outerPropTypes, resolvedProps, </span><span class="s0">// Resolved for outer only</span>
                <span class="s3">'prop'</span><span class="s1">, getComponentNameFromType(Component));</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s1">child = updateMemoComponent(</span><span class="s2">null</span><span class="s1">, workInProgress, Component, resolveDefaultProps(Component.type, resolvedProps), </span><span class="s0">// The inner type can have defaults too</span>
          <span class="s1">renderLanes);</span>
          <span class="s2">return </span><span class="s1">child;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">hint = </span><span class="s3">''</span><span class="s1">;</span>

    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(Component !== </span><span class="s2">null </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">Component === </span><span class="s3">'object' </span><span class="s1">&amp;&amp; Component.$$typeof === REACT_LAZY_TYPE) {</span>
        <span class="s1">hint = </span><span class="s3">' Did you wrap a component in React.lazy() more than once?'</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// This message intentionally doesn't mention ForwardRef or MemoComponent</span>
    <span class="s0">// because the fact that it's a separate type of work is an</span>
    <span class="s0">// implementation detail.</span>


    <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">&quot;Element type is invalid. Received a promise that resolves to: &quot; </span><span class="s1">+ Component + </span><span class="s3">&quot;. &quot; </span><span class="s1">+ (</span><span class="s3">&quot;Lazy element type must resolve to a class or function.&quot; </span><span class="s1">+ hint));</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">mountIncompleteClassComponent(_current, workInProgress, Component, nextProps, renderLanes) {</span>
    <span class="s1">resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress); </span><span class="s0">// Promote the fiber to a class and try rendering again.</span>

    <span class="s1">workInProgress.tag = ClassComponent; </span><span class="s0">// The rest of this function is a fork of `updateClassComponent`</span>
    <span class="s0">// Push context providers early to prevent context stack mismatches.</span>
    <span class="s0">// During mounting we don't know the child context yet as the instance doesn't exist.</span>
    <span class="s0">// We will invalidate the child context in finishClassComponent() right after rendering.</span>

    <span class="s2">var </span><span class="s1">hasContext;</span>

    <span class="s2">if </span><span class="s1">(isContextProvider(Component)) {</span>
      <span class="s1">hasContext = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s1">pushContextProvider(workInProgress);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">hasContext = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">prepareToReadContext(workInProgress, renderLanes);</span>
    <span class="s1">constructClassInstance(workInProgress, Component, nextProps);</span>
    <span class="s1">mountClassInstance(workInProgress, Component, nextProps, renderLanes);</span>
    <span class="s2">return </span><span class="s1">finishClassComponent(</span><span class="s2">null</span><span class="s1">, workInProgress, Component, </span><span class="s2">true</span><span class="s1">, hasContext, renderLanes);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">mountIndeterminateComponent(_current, workInProgress, Component, renderLanes) {</span>
    <span class="s1">resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress);</span>
    <span class="s2">var </span><span class="s1">props = workInProgress.pendingProps;</span>
    <span class="s2">var </span><span class="s1">context;</span>

    <span class="s1">{</span>
      <span class="s2">var </span><span class="s1">unmaskedContext = getUnmaskedContext(workInProgress, Component, </span><span class="s2">false</span><span class="s1">);</span>
      <span class="s1">context = getMaskedContext(workInProgress, unmaskedContext);</span>
    <span class="s1">}</span>

    <span class="s1">prepareToReadContext(workInProgress, renderLanes);</span>
    <span class="s2">var </span><span class="s1">value;</span>

    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(Component.prototype &amp;&amp; </span><span class="s2">typeof </span><span class="s1">Component.prototype.render === </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s2">var </span><span class="s1">componentName = getComponentNameFromType(Component) || </span><span class="s3">'Unknown'</span><span class="s1">;</span>

        <span class="s2">if </span><span class="s1">(!didWarnAboutBadClass[componentName]) {</span>
          <span class="s1">error(</span><span class="s3">&quot;The &lt;%s /&gt; component appears to have a render method, but doesn't extend React.Component. &quot; </span><span class="s1">+ </span><span class="s3">'This is likely to cause errors. Change %s to extend React.Component instead.'</span><span class="s1">, componentName, componentName);</span>

          <span class="s1">didWarnAboutBadClass[componentName] = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(workInProgress.mode &amp; StrictLegacyMode) {</span>
        <span class="s1">ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, </span><span class="s2">null</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s1">setIsRendering(</span><span class="s2">true</span><span class="s1">);</span>
      <span class="s1">ReactCurrentOwner$1.current = workInProgress;</span>
      <span class="s1">value = renderWithHooks(</span><span class="s2">null</span><span class="s1">, workInProgress, Component, props, context, renderLanes);</span>
      <span class="s1">setIsRendering(</span><span class="s2">false</span><span class="s1">);</span>
    <span class="s1">}</span>


    <span class="s1">workInProgress.flags |= PerformedWork;</span>

    <span class="s1">{</span>
      <span class="s0">// Support for module components is deprecated and is removed behind a flag.</span>
      <span class="s0">// Whether or not it would crash later, we want to show a good message in DEV first.</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">value === </span><span class="s3">'object' </span><span class="s1">&amp;&amp; value !== </span><span class="s2">null </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">value.render === </span><span class="s3">'function' </span><span class="s1">&amp;&amp; value.$$typeof === undefined) {</span>
        <span class="s2">var </span><span class="s1">_componentName = getComponentNameFromType(Component) || </span><span class="s3">'Unknown'</span><span class="s1">;</span>

        <span class="s2">if </span><span class="s1">(!didWarnAboutModulePatternComponent[_componentName]) {</span>
          <span class="s1">error(</span><span class="s3">'The &lt;%s /&gt; component appears to be a function component that returns a class instance. ' </span><span class="s1">+ </span><span class="s3">'Change %s to a class that extends React.Component instead. ' </span><span class="s1">+ </span><span class="s3">&quot;If you can't use a class try assigning the prototype on the function as a workaround. &quot; </span><span class="s1">+ </span><span class="s3">&quot;`%s.prototype = React.Component.prototype`. Don't use an arrow function since it &quot; </span><span class="s1">+ </span><span class="s3">'cannot be called with `new` by React.'</span><span class="s1">, _componentName, _componentName, _componentName);</span>

          <span class="s1">didWarnAboutModulePatternComponent[_componentName] = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">( </span><span class="s0">// Run these checks in production only if the flag is off.</span>
    <span class="s0">// Eventually we'll delete this branch altogether.</span>
     <span class="s2">typeof </span><span class="s1">value === </span><span class="s3">'object' </span><span class="s1">&amp;&amp; value !== </span><span class="s2">null </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">value.render === </span><span class="s3">'function' </span><span class="s1">&amp;&amp; value.$$typeof === undefined) {</span>
      <span class="s1">{</span>
        <span class="s2">var </span><span class="s1">_componentName2 = getComponentNameFromType(Component) || </span><span class="s3">'Unknown'</span><span class="s1">;</span>

        <span class="s2">if </span><span class="s1">(!didWarnAboutModulePatternComponent[_componentName2]) {</span>
          <span class="s1">error(</span><span class="s3">'The &lt;%s /&gt; component appears to be a function component that returns a class instance. ' </span><span class="s1">+ </span><span class="s3">'Change %s to a class that extends React.Component instead. ' </span><span class="s1">+ </span><span class="s3">&quot;If you can't use a class try assigning the prototype on the function as a workaround. &quot; </span><span class="s1">+ </span><span class="s3">&quot;`%s.prototype = React.Component.prototype`. Don't use an arrow function since it &quot; </span><span class="s1">+ </span><span class="s3">'cannot be called with `new` by React.'</span><span class="s1">, _componentName2, _componentName2, _componentName2);</span>

          <span class="s1">didWarnAboutModulePatternComponent[_componentName2] = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s0">// Proceed under the assumption that this is a class instance</span>


      <span class="s1">workInProgress.tag = ClassComponent; </span><span class="s0">// Throw out any hooks that were used.</span>

      <span class="s1">workInProgress.memoizedState = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">workInProgress.updateQueue = </span><span class="s2">null</span><span class="s1">; </span><span class="s0">// Push context providers early to prevent context stack mismatches.</span>
      <span class="s0">// During mounting we don't know the child context yet as the instance doesn't exist.</span>
      <span class="s0">// We will invalidate the child context in finishClassComponent() right after rendering.</span>

      <span class="s2">var </span><span class="s1">hasContext = </span><span class="s2">false</span><span class="s1">;</span>

      <span class="s2">if </span><span class="s1">(isContextProvider(Component)) {</span>
        <span class="s1">hasContext = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">pushContextProvider(workInProgress);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">hasContext = </span><span class="s2">false</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">workInProgress.memoizedState = value.state !== </span><span class="s2">null </span><span class="s1">&amp;&amp; value.state !== undefined ? value.state : </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">initializeUpdateQueue(workInProgress);</span>
      <span class="s1">adoptClassInstance(workInProgress, value);</span>
      <span class="s1">mountClassInstance(workInProgress, Component, props, renderLanes);</span>
      <span class="s2">return </span><span class="s1">finishClassComponent(</span><span class="s2">null</span><span class="s1">, workInProgress, Component, </span><span class="s2">true</span><span class="s1">, hasContext, renderLanes);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s0">// Proceed under the assumption that this is a function component</span>
      <span class="s1">workInProgress.tag = FunctionComponent;</span>

      <span class="s1">reconcileChildren(</span><span class="s2">null</span><span class="s1">, workInProgress, value, renderLanes);</span>

      <span class="s1">{</span>
        <span class="s1">validateFunctionComponentInDev(workInProgress, Component);</span>
      <span class="s1">}</span>

      <span class="s2">return </span><span class="s1">workInProgress.child;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">validateFunctionComponentInDev(workInProgress, Component) {</span>
    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(Component) {</span>
        <span class="s2">if </span><span class="s1">(Component.childContextTypes) {</span>
          <span class="s1">error(</span><span class="s3">'%s(...): childContextTypes cannot be defined on a function component.'</span><span class="s1">, Component.displayName || Component.name || </span><span class="s3">'Component'</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(workInProgress.ref !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">var </span><span class="s1">info = </span><span class="s3">''</span><span class="s1">;</span>
        <span class="s2">var </span><span class="s1">ownerName = getCurrentFiberOwnerNameInDevOrNull();</span>

        <span class="s2">if </span><span class="s1">(ownerName) {</span>
          <span class="s1">info += </span><span class="s3">'</span><span class="s5">\n\n</span><span class="s3">Check the render method of `' </span><span class="s1">+ ownerName + </span><span class="s3">'`.'</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s2">var </span><span class="s1">warningKey = ownerName || </span><span class="s3">''</span><span class="s1">;</span>
        <span class="s2">var </span><span class="s1">debugSource = workInProgress._debugSource;</span>

        <span class="s2">if </span><span class="s1">(debugSource) {</span>
          <span class="s1">warningKey = debugSource.fileName + </span><span class="s3">':' </span><span class="s1">+ debugSource.lineNumber;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(!didWarnAboutFunctionRefs[warningKey]) {</span>
          <span class="s1">didWarnAboutFunctionRefs[warningKey] = </span><span class="s2">true</span><span class="s1">;</span>

          <span class="s1">error(</span><span class="s3">'Function components cannot be given refs. ' </span><span class="s1">+ </span><span class="s3">'Attempts to access this ref will fail. ' </span><span class="s1">+ </span><span class="s3">'Did you mean to use React.forwardRef()?%s'</span><span class="s1">, info);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">Component.getDerivedStateFromProps === </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s2">var </span><span class="s1">_componentName3 = getComponentNameFromType(Component) || </span><span class="s3">'Unknown'</span><span class="s1">;</span>

        <span class="s2">if </span><span class="s1">(!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {</span>
          <span class="s1">error(</span><span class="s3">'%s: Function components do not support getDerivedStateFromProps.'</span><span class="s1">, _componentName3);</span>

          <span class="s1">didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">Component.contextType === </span><span class="s3">'object' </span><span class="s1">&amp;&amp; Component.contextType !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">var </span><span class="s1">_componentName4 = getComponentNameFromType(Component) || </span><span class="s3">'Unknown'</span><span class="s1">;</span>

        <span class="s2">if </span><span class="s1">(!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {</span>
          <span class="s1">error(</span><span class="s3">'%s: Function components do not support contextType.'</span><span class="s1">, _componentName4);</span>

          <span class="s1">didWarnAboutContextTypeOnFunctionComponent[_componentName4] = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">SUSPENDED_MARKER = {</span>
    <span class="s1">dehydrated: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">treeContext: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">retryLane: NoLane</span>
  <span class="s1">};</span>

  <span class="s2">function </span><span class="s1">mountSuspenseOffscreenState(renderLanes) {</span>
    <span class="s2">return </span><span class="s1">{</span>
      <span class="s1">baseLanes: renderLanes,</span>
      <span class="s1">cachePool: getSuspendedCache(),</span>
      <span class="s1">transitions: </span><span class="s2">null</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">updateSuspenseOffscreenState(prevOffscreenState, renderLanes) {</span>
    <span class="s2">var </span><span class="s1">cachePool = </span><span class="s2">null</span><span class="s1">;</span>

    <span class="s2">return </span><span class="s1">{</span>
      <span class="s1">baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes),</span>
      <span class="s1">cachePool: cachePool,</span>
      <span class="s1">transitions: prevOffscreenState.transitions</span>
    <span class="s1">};</span>
  <span class="s1">} </span><span class="s0">// TODO: Probably should inline this back</span>


  <span class="s2">function </span><span class="s1">shouldRemainOnFallback(suspenseContext, current, workInProgress, renderLanes) {</span>
    <span class="s0">// If we're already showing a fallback, there are cases where we need to</span>
    <span class="s0">// remain on that fallback regardless of whether the content has resolved.</span>
    <span class="s0">// For example, SuspenseList coordinates when nested content appears.</span>
    <span class="s2">if </span><span class="s1">(current !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">suspenseState = current.memoizedState;</span>

      <span class="s2">if </span><span class="s1">(suspenseState === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s0">// Currently showing content. Don't hide it, even if ForceSuspenseFallback</span>
        <span class="s0">// is true. More precise name might be &quot;ForceRemainSuspenseFallback&quot;.</span>
        <span class="s0">// Note: This is a factoring smell. Can't remain on a fallback if there's</span>
        <span class="s0">// no fallback to remain on.</span>
        <span class="s2">return false</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// Not currently showing content. Consult the Suspense context.</span>


    <span class="s2">return </span><span class="s1">hasSuspenseContext(suspenseContext, ForceSuspenseFallback);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">getRemainingWorkInPrimaryTree(current, renderLanes) {</span>
    <span class="s0">// TODO: Should not remove render lanes that were pinged during this render</span>
    <span class="s2">return </span><span class="s1">removeLanes(current.childLanes, renderLanes);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">updateSuspenseComponent(current, workInProgress, renderLanes) {</span>
    <span class="s2">var </span><span class="s1">nextProps = workInProgress.pendingProps; </span><span class="s0">// This is used by DevTools to force a boundary to suspend.</span>

    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(shouldSuspend(workInProgress)) {</span>
        <span class="s1">workInProgress.flags |= DidCapture;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">suspenseContext = suspenseStackCursor.current;</span>
    <span class="s2">var </span><span class="s1">showFallback = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s2">var </span><span class="s1">didSuspend = (workInProgress.flags &amp; DidCapture) !== NoFlags;</span>

    <span class="s2">if </span><span class="s1">(didSuspend || shouldRemainOnFallback(suspenseContext, current)) {</span>
      <span class="s0">// Something in this boundary's subtree already suspended. Switch to</span>
      <span class="s0">// rendering the fallback children.</span>
      <span class="s1">showFallback = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s1">workInProgress.flags &amp;= ~DidCapture;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s0">// Attempting the main content</span>
      <span class="s2">if </span><span class="s1">(current === </span><span class="s2">null </span><span class="s1">|| current.memoizedState !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s0">// This is a new mount or this boundary is already showing a fallback state.</span>
        <span class="s0">// Mark this subtree context as having at least one invisible parent that could</span>
        <span class="s0">// handle the fallback state.</span>
        <span class="s0">// Avoided boundaries are not considered since they cannot handle preferred fallback states.</span>
        <span class="s1">{</span>
          <span class="s1">suspenseContext = addSubtreeSuspenseContext(suspenseContext, InvisibleParentSuspenseContext);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);</span>
    <span class="s1">pushSuspenseContext(workInProgress, suspenseContext); </span><span class="s0">// OK, the next part is confusing. We're about to reconcile the Suspense</span>
    <span class="s0">// boundary's children. This involves some custom reconciliation logic. Two</span>
    <span class="s0">// main reasons this is so complicated.</span>
    <span class="s0">//</span>
    <span class="s0">// First, Legacy Mode has different semantics for backwards compatibility. The</span>
    <span class="s0">// primary tree will commit in an inconsistent state, so when we do the</span>
    <span class="s0">// second pass to render the fallback, we do some exceedingly, uh, clever</span>
    <span class="s0">// hacks to make that not totally break. Like transferring effects and</span>
    <span class="s0">// deletions from hidden tree. In Concurrent Mode, it's much simpler,</span>
    <span class="s0">// because we bailout on the primary tree completely and leave it in its old</span>
    <span class="s0">// state, no effects. Same as what we do for Offscreen (except that</span>
    <span class="s0">// Offscreen doesn't have the first render pass).</span>
    <span class="s0">//</span>
    <span class="s0">// Second is hydration. During hydration, the Suspense fiber has a slightly</span>
    <span class="s0">// different layout, where the child points to a dehydrated fragment, which</span>
    <span class="s0">// contains the DOM rendered by the server.</span>
    <span class="s0">//</span>
    <span class="s0">// Third, even if you set all that aside, Suspense is like error boundaries in</span>
    <span class="s0">// that we first we try to render one tree, and if that fails, we render again</span>
    <span class="s0">// and switch to a different tree. Like a try/catch block. So we have to track</span>
    <span class="s0">// which branch we're currently rendering. Ideally we would model this using</span>
    <span class="s0">// a stack.</span>

    <span class="s2">if </span><span class="s1">(current === </span><span class="s2">null</span><span class="s1">) {</span>

      <span class="s2">var </span><span class="s1">suspenseState = workInProgress.memoizedState;</span>

      <span class="s2">if </span><span class="s1">(suspenseState !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">var </span><span class="s1">dehydrated = suspenseState.dehydrated;</span>

        <span class="s2">if </span><span class="s1">(dehydrated !== </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s2">return </span><span class="s1">mountDehydratedSuspenseComponent(workInProgress);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">nextPrimaryChildren = nextProps.children;</span>
      <span class="s2">var </span><span class="s1">nextFallbackChildren = nextProps.fallback;</span>

      <span class="s2">if </span><span class="s1">(showFallback) {</span>
        <span class="s2">var </span><span class="s1">fallbackFragment = mountSuspenseFallbackChildren(workInProgress, nextPrimaryChildren, nextFallbackChildren, renderLanes);</span>
        <span class="s2">var </span><span class="s1">primaryChildFragment = workInProgress.child;</span>
        <span class="s1">primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes);</span>
        <span class="s1">workInProgress.memoizedState = SUSPENDED_MARKER;</span>

        <span class="s2">return </span><span class="s1">fallbackFragment;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">return </span><span class="s1">mountSuspensePrimaryChildren(workInProgress, nextPrimaryChildren);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s0">// This is an update.</span>
      <span class="s0">// Special path for hydration</span>
      <span class="s2">var </span><span class="s1">prevState = current.memoizedState;</span>

      <span class="s2">if </span><span class="s1">(prevState !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">var </span><span class="s1">_dehydrated = prevState.dehydrated;</span>

        <span class="s2">if </span><span class="s1">(_dehydrated !== </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s2">return </span><span class="s1">updateDehydratedSuspenseComponent(current, workInProgress, didSuspend, nextProps, _dehydrated, prevState, renderLanes);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(showFallback) {</span>
        <span class="s2">var </span><span class="s1">_nextFallbackChildren = nextProps.fallback;</span>
        <span class="s2">var </span><span class="s1">_nextPrimaryChildren = nextProps.children;</span>
        <span class="s2">var </span><span class="s1">fallbackChildFragment = updateSuspenseFallbackChildren(current, workInProgress, _nextPrimaryChildren, _nextFallbackChildren, renderLanes);</span>
        <span class="s2">var </span><span class="s1">_primaryChildFragment2 = workInProgress.child;</span>
        <span class="s2">var </span><span class="s1">prevOffscreenState = current.child.memoizedState;</span>
        <span class="s1">_primaryChildFragment2.memoizedState = prevOffscreenState === </span><span class="s2">null </span><span class="s1">? mountSuspenseOffscreenState(renderLanes) : updateSuspenseOffscreenState(prevOffscreenState, renderLanes);</span>

        <span class="s1">_primaryChildFragment2.childLanes = getRemainingWorkInPrimaryTree(current, renderLanes);</span>
        <span class="s1">workInProgress.memoizedState = SUSPENDED_MARKER;</span>
        <span class="s2">return </span><span class="s1">fallbackChildFragment;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">var </span><span class="s1">_nextPrimaryChildren2 = nextProps.children;</span>

        <span class="s2">var </span><span class="s1">_primaryChildFragment3 = updateSuspensePrimaryChildren(current, workInProgress, _nextPrimaryChildren2, renderLanes);</span>

        <span class="s1">workInProgress.memoizedState = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s2">return </span><span class="s1">_primaryChildFragment3;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">mountSuspensePrimaryChildren(workInProgress, primaryChildren, renderLanes) {</span>
    <span class="s2">var </span><span class="s1">mode = workInProgress.mode;</span>
    <span class="s2">var </span><span class="s1">primaryChildProps = {</span>
      <span class="s1">mode: </span><span class="s3">'visible'</span><span class="s1">,</span>
      <span class="s1">children: primaryChildren</span>
    <span class="s1">};</span>
    <span class="s2">var </span><span class="s1">primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);</span>
    <span class="s1">primaryChildFragment.</span><span class="s2">return </span><span class="s1">= workInProgress;</span>
    <span class="s1">workInProgress.child = primaryChildFragment;</span>
    <span class="s2">return </span><span class="s1">primaryChildFragment;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">mountSuspenseFallbackChildren(workInProgress, primaryChildren, fallbackChildren, renderLanes) {</span>
    <span class="s2">var </span><span class="s1">mode = workInProgress.mode;</span>
    <span class="s2">var </span><span class="s1">progressedPrimaryFragment = workInProgress.child;</span>
    <span class="s2">var </span><span class="s1">primaryChildProps = {</span>
      <span class="s1">mode: </span><span class="s3">'hidden'</span><span class="s1">,</span>
      <span class="s1">children: primaryChildren</span>
    <span class="s1">};</span>
    <span class="s2">var </span><span class="s1">primaryChildFragment;</span>
    <span class="s2">var </span><span class="s1">fallbackChildFragment;</span>

    <span class="s2">if </span><span class="s1">((mode &amp; ConcurrentMode) === NoMode &amp;&amp; progressedPrimaryFragment !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s0">// In legacy mode, we commit the primary tree as if it successfully</span>
      <span class="s0">// completed, even though it's in an inconsistent state.</span>
      <span class="s1">primaryChildFragment = progressedPrimaryFragment;</span>
      <span class="s1">primaryChildFragment.childLanes = NoLanes;</span>
      <span class="s1">primaryChildFragment.pendingProps = primaryChildProps;</span>

      <span class="s2">if </span><span class="s1">( workInProgress.mode &amp; ProfileMode) {</span>
        <span class="s0">// Reset the durations from the first pass so they aren't included in the</span>
        <span class="s0">// final amounts. This seems counterintuitive, since we're intentionally</span>
        <span class="s0">// not measuring part of the render phase, but this makes it match what we</span>
        <span class="s0">// do in Concurrent Mode.</span>
        <span class="s1">primaryChildFragment.actualDuration = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">primaryChildFragment.actualStartTime = -</span><span class="s4">1</span><span class="s1">;</span>
        <span class="s1">primaryChildFragment.selfBaseDuration = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">primaryChildFragment.treeBaseDuration = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, </span><span class="s2">null</span><span class="s1">);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);</span>
      <span class="s1">fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, </span><span class="s2">null</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s1">primaryChildFragment.</span><span class="s2">return </span><span class="s1">= workInProgress;</span>
    <span class="s1">fallbackChildFragment.</span><span class="s2">return </span><span class="s1">= workInProgress;</span>
    <span class="s1">primaryChildFragment.sibling = fallbackChildFragment;</span>
    <span class="s1">workInProgress.child = primaryChildFragment;</span>
    <span class="s2">return </span><span class="s1">fallbackChildFragment;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">mountWorkInProgressOffscreenFiber(offscreenProps, mode, renderLanes) {</span>
    <span class="s0">// The props argument to `createFiberFromOffscreen` is `any` typed, so we use</span>
    <span class="s0">// this wrapper function to constrain it.</span>
    <span class="s2">return </span><span class="s1">createFiberFromOffscreen(offscreenProps, mode, NoLanes, </span><span class="s2">null</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">updateWorkInProgressOffscreenFiber(current, offscreenProps) {</span>
    <span class="s0">// The props argument to `createWorkInProgress` is `any` typed, so we use this</span>
    <span class="s0">// wrapper function to constrain it.</span>
    <span class="s2">return </span><span class="s1">createWorkInProgress(current, offscreenProps);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">updateSuspensePrimaryChildren(current, workInProgress, primaryChildren, renderLanes) {</span>
    <span class="s2">var </span><span class="s1">currentPrimaryChildFragment = current.child;</span>
    <span class="s2">var </span><span class="s1">currentFallbackChildFragment = currentPrimaryChildFragment.sibling;</span>
    <span class="s2">var </span><span class="s1">primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, {</span>
      <span class="s1">mode: </span><span class="s3">'visible'</span><span class="s1">,</span>
      <span class="s1">children: primaryChildren</span>
    <span class="s1">});</span>

    <span class="s2">if </span><span class="s1">((workInProgress.mode &amp; ConcurrentMode) === NoMode) {</span>
      <span class="s1">primaryChildFragment.lanes = renderLanes;</span>
    <span class="s1">}</span>

    <span class="s1">primaryChildFragment.</span><span class="s2">return </span><span class="s1">= workInProgress;</span>
    <span class="s1">primaryChildFragment.sibling = </span><span class="s2">null</span><span class="s1">;</span>

    <span class="s2">if </span><span class="s1">(currentFallbackChildFragment !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s0">// Delete the fallback child fragment</span>
      <span class="s2">var </span><span class="s1">deletions = workInProgress.deletions;</span>

      <span class="s2">if </span><span class="s1">(deletions === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">workInProgress.deletions = [currentFallbackChildFragment];</span>
        <span class="s1">workInProgress.flags |= ChildDeletion;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">deletions.push(currentFallbackChildFragment);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">workInProgress.child = primaryChildFragment;</span>
    <span class="s2">return </span><span class="s1">primaryChildFragment;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">updateSuspenseFallbackChildren(current, workInProgress, primaryChildren, fallbackChildren, renderLanes) {</span>
    <span class="s2">var </span><span class="s1">mode = workInProgress.mode;</span>
    <span class="s2">var </span><span class="s1">currentPrimaryChildFragment = current.child;</span>
    <span class="s2">var </span><span class="s1">currentFallbackChildFragment = currentPrimaryChildFragment.sibling;</span>
    <span class="s2">var </span><span class="s1">primaryChildProps = {</span>
      <span class="s1">mode: </span><span class="s3">'hidden'</span><span class="s1">,</span>
      <span class="s1">children: primaryChildren</span>
    <span class="s1">};</span>
    <span class="s2">var </span><span class="s1">primaryChildFragment;</span>

    <span class="s2">if </span><span class="s1">( </span><span class="s0">// In legacy mode, we commit the primary tree as if it successfully</span>
    <span class="s0">// completed, even though it's in an inconsistent state.</span>
    <span class="s1">(mode &amp; ConcurrentMode) === NoMode &amp;&amp; </span><span class="s0">// Make sure we're on the second pass, i.e. the primary child fragment was</span>
    <span class="s0">// already cloned. In legacy mode, the only case where this isn't true is</span>
    <span class="s0">// when DevTools forces us to display a fallback; we skip the first render</span>
    <span class="s0">// pass entirely and go straight to rendering the fallback. (In Concurrent</span>
    <span class="s0">// Mode, SuspenseList can also trigger this scenario, but this is a legacy-</span>
    <span class="s0">// only codepath.)</span>
    <span class="s1">workInProgress.child !== currentPrimaryChildFragment) {</span>
      <span class="s2">var </span><span class="s1">progressedPrimaryFragment = workInProgress.child;</span>
      <span class="s1">primaryChildFragment = progressedPrimaryFragment;</span>
      <span class="s1">primaryChildFragment.childLanes = NoLanes;</span>
      <span class="s1">primaryChildFragment.pendingProps = primaryChildProps;</span>

      <span class="s2">if </span><span class="s1">( workInProgress.mode &amp; ProfileMode) {</span>
        <span class="s0">// Reset the durations from the first pass so they aren't included in the</span>
        <span class="s0">// final amounts. This seems counterintuitive, since we're intentionally</span>
        <span class="s0">// not measuring part of the render phase, but this makes it match what we</span>
        <span class="s0">// do in Concurrent Mode.</span>
        <span class="s1">primaryChildFragment.actualDuration = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">primaryChildFragment.actualStartTime = -</span><span class="s4">1</span><span class="s1">;</span>
        <span class="s1">primaryChildFragment.selfBaseDuration = currentPrimaryChildFragment.selfBaseDuration;</span>
        <span class="s1">primaryChildFragment.treeBaseDuration = currentPrimaryChildFragment.treeBaseDuration;</span>
      <span class="s1">} </span><span class="s0">// The fallback fiber was added as a deletion during the first pass.</span>
      <span class="s0">// However, since we're going to remain on the fallback, we no longer want</span>
      <span class="s0">// to delete it.</span>


      <span class="s1">workInProgress.deletions = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, primaryChildProps); </span><span class="s0">// Since we're reusing a current tree, we need to reuse the flags, too.</span>
      <span class="s0">// (We don't do this in legacy mode, because in legacy mode we don't re-use</span>
      <span class="s0">// the current tree; see previous branch.)</span>

      <span class="s1">primaryChildFragment.subtreeFlags = currentPrimaryChildFragment.subtreeFlags &amp; StaticMask;</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">fallbackChildFragment;</span>

    <span class="s2">if </span><span class="s1">(currentFallbackChildFragment !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">fallbackChildFragment = createWorkInProgress(currentFallbackChildFragment, fallbackChildren);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, </span><span class="s2">null</span><span class="s1">); </span><span class="s0">// Needs a placement effect because the parent (the Suspense boundary) already</span>
      <span class="s0">// mounted but this is a new fiber.</span>

      <span class="s1">fallbackChildFragment.flags |= Placement;</span>
    <span class="s1">}</span>

    <span class="s1">fallbackChildFragment.</span><span class="s2">return </span><span class="s1">= workInProgress;</span>
    <span class="s1">primaryChildFragment.</span><span class="s2">return </span><span class="s1">= workInProgress;</span>
    <span class="s1">primaryChildFragment.sibling = fallbackChildFragment;</span>
    <span class="s1">workInProgress.child = primaryChildFragment;</span>
    <span class="s2">return </span><span class="s1">fallbackChildFragment;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, recoverableError) {</span>
    <span class="s0">// Falling back to client rendering. Because this has performance</span>
    <span class="s0">// implications, it's considered a recoverable error, even though the user</span>
    <span class="s0">// likely won't observe anything wrong with the UI.</span>
    <span class="s0">//</span>
    <span class="s0">// The error is passed in as an argument to enforce that every caller provide</span>
    <span class="s0">// a custom message, or explicitly opt out (currently the only path that opts</span>
    <span class="s0">// out is legacy mode; every concurrent path provides an error).</span>
    <span class="s2">if </span><span class="s1">(recoverableError !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">queueHydrationError(recoverableError);</span>
    <span class="s1">} </span><span class="s0">// This will add the old fiber to the deletion list</span>


    <span class="s1">reconcileChildFibers(workInProgress, current.child, </span><span class="s2">null</span><span class="s1">, renderLanes); </span><span class="s0">// We're now not suspended nor dehydrated.</span>

    <span class="s2">var </span><span class="s1">nextProps = workInProgress.pendingProps;</span>
    <span class="s2">var </span><span class="s1">primaryChildren = nextProps.children;</span>
    <span class="s2">var </span><span class="s1">primaryChildFragment = mountSuspensePrimaryChildren(workInProgress, primaryChildren); </span><span class="s0">// Needs a placement effect because the parent (the Suspense boundary) already</span>
    <span class="s0">// mounted but this is a new fiber.</span>

    <span class="s1">primaryChildFragment.flags |= Placement;</span>
    <span class="s1">workInProgress.memoizedState = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">return </span><span class="s1">primaryChildFragment;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">mountSuspenseFallbackAfterRetryWithoutHydrating(current, workInProgress, primaryChildren, fallbackChildren, renderLanes) {</span>
    <span class="s2">var </span><span class="s1">fiberMode = workInProgress.mode;</span>
    <span class="s2">var </span><span class="s1">primaryChildProps = {</span>
      <span class="s1">mode: </span><span class="s3">'visible'</span><span class="s1">,</span>
      <span class="s1">children: primaryChildren</span>
    <span class="s1">};</span>
    <span class="s2">var </span><span class="s1">primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, fiberMode);</span>
    <span class="s2">var </span><span class="s1">fallbackChildFragment = createFiberFromFragment(fallbackChildren, fiberMode, renderLanes, </span><span class="s2">null</span><span class="s1">); </span><span class="s0">// Needs a placement effect because the parent (the Suspense</span>
    <span class="s0">// boundary) already mounted but this is a new fiber.</span>

    <span class="s1">fallbackChildFragment.flags |= Placement;</span>
    <span class="s1">primaryChildFragment.</span><span class="s2">return </span><span class="s1">= workInProgress;</span>
    <span class="s1">fallbackChildFragment.</span><span class="s2">return </span><span class="s1">= workInProgress;</span>
    <span class="s1">primaryChildFragment.sibling = fallbackChildFragment;</span>
    <span class="s1">workInProgress.child = primaryChildFragment;</span>

    <span class="s2">if </span><span class="s1">((workInProgress.mode &amp; ConcurrentMode) !== NoMode) {</span>
      <span class="s0">// We will have dropped the effect list which contains the</span>
      <span class="s0">// deletion. We need to reconcile to delete the current child.</span>
      <span class="s1">reconcileChildFibers(workInProgress, current.child, </span><span class="s2">null</span><span class="s1">, renderLanes);</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">fallbackChildFragment;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">mountDehydratedSuspenseComponent(workInProgress, suspenseInstance, renderLanes) {</span>
    <span class="s0">// During the first pass, we'll bail out and not drill into the children.</span>
    <span class="s0">// Instead, we'll leave the content in place and try to hydrate it later.</span>
    <span class="s2">if </span><span class="s1">((workInProgress.mode &amp; ConcurrentMode) === NoMode) {</span>
      <span class="s1">{</span>
        <span class="s1">error(</span><span class="s3">'Cannot hydrate Suspense in legacy mode. Switch from ' </span><span class="s1">+ </span><span class="s3">'ReactDOM.hydrate(element, container) to ' </span><span class="s1">+ </span><span class="s3">'ReactDOMClient.hydrateRoot(container, &lt;App /&gt;)' </span><span class="s1">+ </span><span class="s3">'.render(element) or remove the Suspense components from ' </span><span class="s1">+ </span><span class="s3">'the server rendered components.'</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s1">workInProgress.lanes = laneToLanes(SyncLane);</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isSuspenseInstanceFallback()) {</span>
      <span class="s0">// This is a client-only boundary. Since we won't get any content from the server</span>
      <span class="s0">// for this, we need to schedule that at a higher priority based on when it would</span>
      <span class="s0">// have timed out. In theory we could render it in this pass but it would have the</span>
      <span class="s0">// wrong priority associated with it and will prevent hydration of parent path.</span>
      <span class="s0">// Instead, we'll leave work left on it to render it in a separate commit.</span>
      <span class="s0">// TODO This time should be the time at which the server rendered response that is</span>
      <span class="s0">// a parent to this boundary was displayed. However, since we currently don't have</span>
      <span class="s0">// a protocol to transfer that time, we'll just estimate it by using the current</span>
      <span class="s0">// time. This will mean that Suspense timeouts are slightly shifted to later than</span>
      <span class="s0">// they should be.</span>
      <span class="s0">// Schedule a normal pri update to render this content.</span>
      <span class="s1">workInProgress.lanes = laneToLanes(DefaultHydrationLane);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s0">// We'll continue hydrating the rest at offscreen priority since we'll already</span>
      <span class="s0">// be showing the right content coming from the server, it is no rush.</span>
      <span class="s1">workInProgress.lanes = laneToLanes(OffscreenLane);</span>
    <span class="s1">}</span>

    <span class="s2">return null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">updateDehydratedSuspenseComponent(current, workInProgress, didSuspend, nextProps, suspenseInstance, suspenseState, renderLanes) {</span>
    <span class="s2">if </span><span class="s1">(!didSuspend) {</span>

      <span class="s2">if </span><span class="s1">((workInProgress.mode &amp; ConcurrentMode) === NoMode) {</span>
        <span class="s2">return </span><span class="s1">retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, </span><span class="s0">// TODO: When we delete legacy mode, we should make this error argument</span>
        <span class="s0">// required  every concurrent mode path that causes hydration to</span>
        <span class="s0">// de-opt to client rendering should have an error message.</span>
        <span class="s2">null</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(isSuspenseInstanceFallback()) {</span>
        <span class="s0">// This boundary is in a permanent fallback state. In this case, we'll never</span>
        <span class="s0">// get an update and we'll never be able to hydrate the final content. Let's just try the</span>
        <span class="s0">// client side render instead.</span>
        <span class="s2">var </span><span class="s1">digest, message, stack;</span>

        <span class="s1">{</span>
          <span class="s2">var </span><span class="s1">_getSuspenseInstanceF = getSuspenseInstanceFallbackErrorDetails();</span>

          <span class="s1">digest = _getSuspenseInstanceF.digest;</span>
          <span class="s1">message = _getSuspenseInstanceF.message;</span>
          <span class="s1">stack = _getSuspenseInstanceF.stack;</span>
        <span class="s1">}</span>

        <span class="s2">var </span><span class="s1">error;</span>

        <span class="s2">if </span><span class="s1">(message) {</span>
          <span class="s0">// eslint-disable-next-line react-internal/prod-error-codes</span>
          <span class="s1">error = </span><span class="s2">new </span><span class="s1">Error(message);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">error = </span><span class="s2">new </span><span class="s1">Error(</span><span class="s3">'The server could not finish this Suspense boundary, likely ' </span><span class="s1">+ </span><span class="s3">'due to an error during server rendering. Switched to ' </span><span class="s1">+ </span><span class="s3">'client rendering.'</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s2">var </span><span class="s1">capturedValue = createCapturedValue(error, digest, stack);</span>
        <span class="s2">return </span><span class="s1">retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, capturedValue);</span>
      <span class="s1">}</span>
      <span class="s0">// any context has changed, we need to treat is as if the input might have changed.</span>


      <span class="s2">var </span><span class="s1">hasContextChanged = includesSomeLane(renderLanes, current.childLanes);</span>

      <span class="s2">if </span><span class="s1">(didReceiveUpdate || hasContextChanged) {</span>
        <span class="s0">// This boundary has changed since the first render. This means that we are now unable to</span>
        <span class="s0">// hydrate it. We might still be able to hydrate it using a higher priority lane.</span>
        <span class="s2">var </span><span class="s1">root = getWorkInProgressRoot();</span>

        <span class="s2">if </span><span class="s1">(root !== </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s2">var </span><span class="s1">attemptHydrationAtLane = getBumpedLaneForHydration(root, renderLanes);</span>

          <span class="s2">if </span><span class="s1">(attemptHydrationAtLane !== NoLane &amp;&amp; attemptHydrationAtLane !== suspenseState.retryLane) {</span>
            <span class="s0">// Intentionally mutating since this render will get interrupted. This</span>
            <span class="s0">// is one of the very rare times where we mutate the current tree</span>
            <span class="s0">// during the render phase.</span>
            <span class="s1">suspenseState.retryLane = attemptHydrationAtLane; </span><span class="s0">// TODO: Ideally this would inherit the event time of the current render</span>

            <span class="s2">var </span><span class="s1">eventTime = NoTimestamp;</span>
            <span class="s1">enqueueConcurrentRenderForLane(current, attemptHydrationAtLane);</span>
            <span class="s1">scheduleUpdateOnFiber(root, current, attemptHydrationAtLane, eventTime);</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s0">// If we have scheduled higher pri work above, this will probably just abort the render</span>
        <span class="s0">// since we now have higher priority work, but in case it doesn't, we need to prepare to</span>
        <span class="s0">// render something, if we time out. Even if that requires us to delete everything and</span>
        <span class="s0">// skip hydration.</span>
        <span class="s0">// Delay having to do this as long as the suspense timeout allows us.</span>


        <span class="s1">renderDidSuspendDelayIfPossible();</span>

        <span class="s2">var </span><span class="s1">_capturedValue = createCapturedValue(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s3">'This Suspense boundary received an update before it finished ' </span><span class="s1">+ </span><span class="s3">'hydrating. This caused the boundary to switch to client rendering. ' </span><span class="s1">+ </span><span class="s3">'The usual way to fix this is to wrap the original update ' </span><span class="s1">+ </span><span class="s3">'in startTransition.'</span><span class="s1">));</span>

        <span class="s2">return </span><span class="s1">retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, _capturedValue);</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isSuspenseInstancePending()) {</span>
        <span class="s0">// This component is still pending more data from the server, so we can't hydrate its</span>
        <span class="s0">// content. We treat it as if this component suspended itself. It might seem as if</span>
        <span class="s0">// we could just try to render it client-side instead. However, this will perform a</span>
        <span class="s0">// lot of unnecessary work and is unlikely to complete since it often will suspend</span>
        <span class="s0">// on missing data anyway. Additionally, the server might be able to render more</span>
        <span class="s0">// than we can on the client yet. In that case we'd end up with more fallback states</span>
        <span class="s0">// on the client than if we just leave it alone. If the server times out or errors</span>
        <span class="s0">// these should update this boundary to the permanent Fallback state instead.</span>
        <span class="s0">// Mark it as having captured (i.e. suspended).</span>
        <span class="s1">workInProgress.flags |= DidCapture; </span><span class="s0">// Leave the child in place. I.e. the dehydrated fragment.</span>

        <span class="s1">workInProgress.child = current.child; </span><span class="s0">// Register a callback to retry this boundary once the server has sent the result.</span>

        <span class="s2">var </span><span class="s1">retry = retryDehydratedSuspenseBoundary.bind(</span><span class="s2">null</span><span class="s1">, current);</span>
        <span class="s1">registerSuspenseInstanceRetry();</span>
        <span class="s2">return null</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s0">// This is the first attempt.</span>
        <span class="s1">reenterHydrationStateFromDehydratedSuspenseInstance(workInProgress, suspenseInstance, suspenseState.treeContext);</span>
        <span class="s2">var </span><span class="s1">primaryChildren = nextProps.children;</span>
        <span class="s2">var </span><span class="s1">primaryChildFragment = mountSuspensePrimaryChildren(workInProgress, primaryChildren); </span><span class="s0">// Mark the children as hydrating. This is a fast path to know whether this</span>
        <span class="s0">// tree is part of a hydrating tree. This is used to determine if a child</span>
        <span class="s0">// node has fully mounted yet, and for scheduling event replaying.</span>
        <span class="s0">// Conceptually this is similar to Placement in that a new subtree is</span>
        <span class="s0">// inserted into the React tree here. It just happens to not need DOM</span>
        <span class="s0">// mutations because it already exists.</span>

        <span class="s1">primaryChildFragment.flags |= Hydrating;</span>
        <span class="s2">return </span><span class="s1">primaryChildFragment;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s0">// This is the second render pass. We already attempted to hydrated, but</span>
      <span class="s0">// something either suspended or errored.</span>
      <span class="s2">if </span><span class="s1">(workInProgress.flags &amp; ForceClientRender) {</span>
        <span class="s0">// Something errored during hydration. Try again without hydrating.</span>
        <span class="s1">workInProgress.flags &amp;= ~ForceClientRender;</span>

        <span class="s2">var </span><span class="s1">_capturedValue2 = createCapturedValue(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s3">'There was an error while hydrating this Suspense boundary. ' </span><span class="s1">+ </span><span class="s3">'Switched to client rendering.'</span><span class="s1">));</span>

        <span class="s2">return </span><span class="s1">retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, _capturedValue2);</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(workInProgress.memoizedState !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s0">// Something suspended and we should still be in dehydrated mode.</span>
        <span class="s0">// Leave the existing child in place.</span>
        <span class="s1">workInProgress.child = current.child; </span><span class="s0">// The dehydrated completion pass expects this flag to be there</span>
        <span class="s0">// but the normal suspense pass doesn't.</span>

        <span class="s1">workInProgress.flags |= DidCapture;</span>
        <span class="s2">return null</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s0">// Suspended but we should no longer be in dehydrated mode.</span>
        <span class="s0">// Therefore we now have to render the fallback.</span>
        <span class="s2">var </span><span class="s1">nextPrimaryChildren = nextProps.children;</span>
        <span class="s2">var </span><span class="s1">nextFallbackChildren = nextProps.fallback;</span>
        <span class="s2">var </span><span class="s1">fallbackChildFragment = mountSuspenseFallbackAfterRetryWithoutHydrating(current, workInProgress, nextPrimaryChildren, nextFallbackChildren, renderLanes);</span>
        <span class="s2">var </span><span class="s1">_primaryChildFragment4 = workInProgress.child;</span>
        <span class="s1">_primaryChildFragment4.memoizedState = mountSuspenseOffscreenState(renderLanes);</span>
        <span class="s1">workInProgress.memoizedState = SUSPENDED_MARKER;</span>
        <span class="s2">return </span><span class="s1">fallbackChildFragment;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">scheduleSuspenseWorkOnFiber(fiber, renderLanes, propagationRoot) {</span>
    <span class="s1">fiber.lanes = mergeLanes(fiber.lanes, renderLanes);</span>
    <span class="s2">var </span><span class="s1">alternate = fiber.alternate;</span>

    <span class="s2">if </span><span class="s1">(alternate !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">alternate.lanes = mergeLanes(alternate.lanes, renderLanes);</span>
    <span class="s1">}</span>

    <span class="s1">scheduleContextWorkOnParentPath(fiber.</span><span class="s2">return</span><span class="s1">, renderLanes, propagationRoot);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">propagateSuspenseContextChange(workInProgress, firstChild, renderLanes) {</span>
    <span class="s0">// Mark any Suspense boundaries with fallbacks as having work to do.</span>
    <span class="s0">// If they were previously forced into fallbacks, they may now be able</span>
    <span class="s0">// to unblock.</span>
    <span class="s2">var </span><span class="s1">node = firstChild;</span>

    <span class="s2">while </span><span class="s1">(node !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(node.tag === SuspenseComponent) {</span>
        <span class="s2">var </span><span class="s1">state = node.memoizedState;</span>

        <span class="s2">if </span><span class="s1">(state !== </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">scheduleSuspenseWorkOnFiber(node, renderLanes, workInProgress);</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(node.tag === SuspenseListComponent) {</span>
        <span class="s0">// If the tail is hidden there might not be an Suspense boundaries</span>
        <span class="s0">// to schedule work on. In this case we have to schedule it on the</span>
        <span class="s0">// list itself.</span>
        <span class="s0">// We don't have to traverse to the children of the list since</span>
        <span class="s0">// the list will propagate the change when it rerenders.</span>
        <span class="s1">scheduleSuspenseWorkOnFiber(node, renderLanes, workInProgress);</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(node.child !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">node.child.</span><span class="s2">return </span><span class="s1">= node;</span>
        <span class="s1">node = node.child;</span>
        <span class="s2">continue</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(node === workInProgress) {</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">while </span><span class="s1">(node.sibling === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(node.</span><span class="s2">return </span><span class="s1">=== </span><span class="s2">null </span><span class="s1">|| node.</span><span class="s2">return </span><span class="s1">=== workInProgress) {</span>
          <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">node = node.</span><span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">node.sibling.</span><span class="s2">return </span><span class="s1">= node.</span><span class="s2">return</span><span class="s1">;</span>
      <span class="s1">node = node.sibling;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">findLastContentRow(firstChild) {</span>
    <span class="s0">// This is going to find the last row among these children that is already</span>
    <span class="s0">// showing content on the screen, as opposed to being in fallback state or</span>
    <span class="s0">// new. If a row has multiple Suspense boundaries, any of them being in the</span>
    <span class="s0">// fallback state, counts as the whole row being in a fallback state.</span>
    <span class="s0">// Note that the &quot;rows&quot; will be workInProgress, but any nested children</span>
    <span class="s0">// will still be current since we haven't rendered them yet. The mounted</span>
    <span class="s0">// order may not be the same as the new order. We use the new order.</span>
    <span class="s2">var </span><span class="s1">row = firstChild;</span>
    <span class="s2">var </span><span class="s1">lastContentRow = </span><span class="s2">null</span><span class="s1">;</span>

    <span class="s2">while </span><span class="s1">(row !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">currentRow = row.alternate; </span><span class="s0">// New rows can't be content rows.</span>

      <span class="s2">if </span><span class="s1">(currentRow !== </span><span class="s2">null </span><span class="s1">&amp;&amp; findFirstSuspended(currentRow) === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">lastContentRow = row;</span>
      <span class="s1">}</span>

      <span class="s1">row = row.sibling;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">lastContentRow;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">validateRevealOrder(revealOrder) {</span>
    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(revealOrder !== undefined &amp;&amp; revealOrder !== </span><span class="s3">'forwards' </span><span class="s1">&amp;&amp; revealOrder !== </span><span class="s3">'backwards' </span><span class="s1">&amp;&amp; revealOrder !== </span><span class="s3">'together' </span><span class="s1">&amp;&amp; !didWarnAboutRevealOrder[revealOrder]) {</span>
        <span class="s1">didWarnAboutRevealOrder[revealOrder] = </span><span class="s2">true</span><span class="s1">;</span>

        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">revealOrder === </span><span class="s3">'string'</span><span class="s1">) {</span>
          <span class="s2">switch </span><span class="s1">(revealOrder.toLowerCase()) {</span>
            <span class="s2">case </span><span class="s3">'together'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s3">'forwards'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s3">'backwards'</span><span class="s1">:</span>
              <span class="s1">{</span>
                <span class="s1">error(</span><span class="s3">'&quot;%s&quot; is not a valid value for revealOrder on &lt;SuspenseList /&gt;. ' </span><span class="s1">+ </span><span class="s3">'Use lowercase &quot;%s&quot; instead.'</span><span class="s1">, revealOrder, revealOrder.toLowerCase());</span>

                <span class="s2">break</span><span class="s1">;</span>
              <span class="s1">}</span>

            <span class="s2">case </span><span class="s3">'forward'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s3">'backward'</span><span class="s1">:</span>
              <span class="s1">{</span>
                <span class="s1">error(</span><span class="s3">'&quot;%s&quot; is not a valid value for revealOrder on &lt;SuspenseList /&gt;. ' </span><span class="s1">+ </span><span class="s3">'React uses the -s suffix in the spelling. Use &quot;%ss&quot; instead.'</span><span class="s1">, revealOrder, revealOrder.toLowerCase());</span>

                <span class="s2">break</span><span class="s1">;</span>
              <span class="s1">}</span>

            <span class="s2">default</span><span class="s1">:</span>
              <span class="s1">error(</span><span class="s3">'&quot;%s&quot; is not a supported revealOrder on &lt;SuspenseList /&gt;. ' </span><span class="s1">+ </span><span class="s3">'Did you mean &quot;together&quot;, &quot;forwards&quot; or &quot;backwards&quot;?'</span><span class="s1">, revealOrder);</span>

              <span class="s2">break</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">error(</span><span class="s3">'%s is not a supported value for revealOrder on &lt;SuspenseList /&gt;. ' </span><span class="s1">+ </span><span class="s3">'Did you mean &quot;together&quot;, &quot;forwards&quot; or &quot;backwards&quot;?'</span><span class="s1">, revealOrder);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">validateTailOptions(tailMode, revealOrder) {</span>
    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(tailMode !== undefined &amp;&amp; !didWarnAboutTailOptions[tailMode]) {</span>
        <span class="s2">if </span><span class="s1">(tailMode !== </span><span class="s3">'collapsed' </span><span class="s1">&amp;&amp; tailMode !== </span><span class="s3">'hidden'</span><span class="s1">) {</span>
          <span class="s1">didWarnAboutTailOptions[tailMode] = </span><span class="s2">true</span><span class="s1">;</span>

          <span class="s1">error(</span><span class="s3">'&quot;%s&quot; is not a supported value for tail on &lt;SuspenseList /&gt;. ' </span><span class="s1">+ </span><span class="s3">'Did you mean &quot;collapsed&quot; or &quot;hidden&quot;?'</span><span class="s1">, tailMode);</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(revealOrder !== </span><span class="s3">'forwards' </span><span class="s1">&amp;&amp; revealOrder !== </span><span class="s3">'backwards'</span><span class="s1">) {</span>
          <span class="s1">didWarnAboutTailOptions[tailMode] = </span><span class="s2">true</span><span class="s1">;</span>

          <span class="s1">error(</span><span class="s3">'&lt;SuspenseList tail=&quot;%s&quot; /&gt; is only valid if revealOrder is ' </span><span class="s1">+ </span><span class="s3">'&quot;forwards&quot; or &quot;backwards&quot;. ' </span><span class="s1">+ </span><span class="s3">'Did you mean to specify revealOrder=&quot;forwards&quot;?'</span><span class="s1">, tailMode);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">validateSuspenseListNestedChild(childSlot, index) {</span>
    <span class="s1">{</span>
      <span class="s2">var </span><span class="s1">isAnArray = isArray(childSlot);</span>
      <span class="s2">var </span><span class="s1">isIterable = !isAnArray &amp;&amp; </span><span class="s2">typeof </span><span class="s1">getIteratorFn(childSlot) === </span><span class="s3">'function'</span><span class="s1">;</span>

      <span class="s2">if </span><span class="s1">(isAnArray || isIterable) {</span>
        <span class="s2">var </span><span class="s1">type = isAnArray ? </span><span class="s3">'array' </span><span class="s1">: </span><span class="s3">'iterable'</span><span class="s1">;</span>

        <span class="s1">error(</span><span class="s3">'A nested %s was passed to row #%s in &lt;SuspenseList /&gt;. Wrap it in ' </span><span class="s1">+ </span><span class="s3">'an additional SuspenseList to configure its revealOrder: ' </span><span class="s1">+ </span><span class="s3">'&lt;SuspenseList revealOrder=...&gt; ... ' </span><span class="s1">+ </span><span class="s3">'&lt;SuspenseList revealOrder=...&gt;{%s}&lt;/SuspenseList&gt; ... ' </span><span class="s1">+ </span><span class="s3">'&lt;/SuspenseList&gt;'</span><span class="s1">, type, index, type);</span>

        <span class="s2">return false</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return true</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">validateSuspenseListChildren(children, revealOrder) {</span>
    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">((revealOrder === </span><span class="s3">'forwards' </span><span class="s1">|| revealOrder === </span><span class="s3">'backwards'</span><span class="s1">) &amp;&amp; children !== undefined &amp;&amp; children !== </span><span class="s2">null </span><span class="s1">&amp;&amp; children !== </span><span class="s2">false</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(isArray(children)) {</span>
          <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; children.length; i++) {</span>
            <span class="s2">if </span><span class="s1">(!validateSuspenseListNestedChild(children[i], i)) {</span>
              <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s2">var </span><span class="s1">iteratorFn = getIteratorFn(children);</span>

          <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">iteratorFn === </span><span class="s3">'function'</span><span class="s1">) {</span>
            <span class="s2">var </span><span class="s1">childrenIterator = iteratorFn.call(children);</span>

            <span class="s2">if </span><span class="s1">(childrenIterator) {</span>
              <span class="s2">var </span><span class="s1">step = childrenIterator.next();</span>
              <span class="s2">var </span><span class="s1">_i = </span><span class="s4">0</span><span class="s1">;</span>

              <span class="s2">for </span><span class="s1">(; !step.done; step = childrenIterator.next()) {</span>
                <span class="s2">if </span><span class="s1">(!validateSuspenseListNestedChild(step.value, _i)) {</span>
                  <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>

                <span class="s1">_i++;</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">error(</span><span class="s3">'A single row was passed to a &lt;SuspenseList revealOrder=&quot;%s&quot; /&gt;. ' </span><span class="s1">+ </span><span class="s3">'This is not useful since it needs multiple rows. ' </span><span class="s1">+ </span><span class="s3">'Did you mean to pass multiple children or an array?'</span><span class="s1">, revealOrder);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">initSuspenseListRenderState(workInProgress, isBackwards, tail, lastContentRow, tailMode) {</span>
    <span class="s2">var </span><span class="s1">renderState = workInProgress.memoizedState;</span>

    <span class="s2">if </span><span class="s1">(renderState === </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">workInProgress.memoizedState = {</span>
        <span class="s1">isBackwards: isBackwards,</span>
        <span class="s1">rendering: </span><span class="s2">null</span><span class="s1">,</span>
        <span class="s1">renderingStartTime: </span><span class="s4">0</span><span class="s1">,</span>
        <span class="s1">last: lastContentRow,</span>
        <span class="s1">tail: tail,</span>
        <span class="s1">tailMode: tailMode</span>
      <span class="s1">};</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s0">// We can reuse the existing object from previous renders.</span>
      <span class="s1">renderState.isBackwards = isBackwards;</span>
      <span class="s1">renderState.rendering = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">renderState.renderingStartTime = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s1">renderState.last = lastContentRow;</span>
      <span class="s1">renderState.tail = tail;</span>
      <span class="s1">renderState.tailMode = tailMode;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s0">// This can end up rendering this component multiple passes.</span>
  <span class="s0">// The first pass splits the children fibers into two sets. A head and tail.</span>
  <span class="s0">// We first render the head. If anything is in fallback state, we do another</span>
  <span class="s0">// pass through beginWork to rerender all children (including the tail) with</span>
  <span class="s0">// the force suspend context. If the first render didn't have anything in</span>
  <span class="s0">// in fallback state. Then we render each row in the tail one-by-one.</span>
  <span class="s0">// That happens in the completeWork phase without going back to beginWork.</span>


  <span class="s2">function </span><span class="s1">updateSuspenseListComponent(current, workInProgress, renderLanes) {</span>
    <span class="s2">var </span><span class="s1">nextProps = workInProgress.pendingProps;</span>
    <span class="s2">var </span><span class="s1">revealOrder = nextProps.revealOrder;</span>
    <span class="s2">var </span><span class="s1">tailMode = nextProps.tail;</span>
    <span class="s2">var </span><span class="s1">newChildren = nextProps.children;</span>
    <span class="s1">validateRevealOrder(revealOrder);</span>
    <span class="s1">validateTailOptions(tailMode, revealOrder);</span>
    <span class="s1">validateSuspenseListChildren(newChildren, revealOrder);</span>
    <span class="s1">reconcileChildren(current, workInProgress, newChildren, renderLanes);</span>
    <span class="s2">var </span><span class="s1">suspenseContext = suspenseStackCursor.current;</span>
    <span class="s2">var </span><span class="s1">shouldForceFallback = hasSuspenseContext(suspenseContext, ForceSuspenseFallback);</span>

    <span class="s2">if </span><span class="s1">(shouldForceFallback) {</span>
      <span class="s1">suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);</span>
      <span class="s1">workInProgress.flags |= DidCapture;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">var </span><span class="s1">didSuspendBefore = current !== </span><span class="s2">null </span><span class="s1">&amp;&amp; (current.flags &amp; DidCapture) !== NoFlags;</span>

      <span class="s2">if </span><span class="s1">(didSuspendBefore) {</span>
        <span class="s0">// If we previously forced a fallback, we need to schedule work</span>
        <span class="s0">// on any nested boundaries to let them know to try to render</span>
        <span class="s0">// again. This is the same as context updating.</span>
        <span class="s1">propagateSuspenseContextChange(workInProgress, workInProgress.child, renderLanes);</span>
      <span class="s1">}</span>

      <span class="s1">suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);</span>
    <span class="s1">}</span>

    <span class="s1">pushSuspenseContext(workInProgress, suspenseContext);</span>

    <span class="s2">if </span><span class="s1">((workInProgress.mode &amp; ConcurrentMode) === NoMode) {</span>
      <span class="s0">// In legacy mode, SuspenseList doesn't work so we just</span>
      <span class="s0">// use make it a noop by treating it as the default revealOrder.</span>
      <span class="s1">workInProgress.memoizedState = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">switch </span><span class="s1">(revealOrder) {</span>
        <span class="s2">case </span><span class="s3">'forwards'</span><span class="s1">:</span>
          <span class="s1">{</span>
            <span class="s2">var </span><span class="s1">lastContentRow = findLastContentRow(workInProgress.child);</span>
            <span class="s2">var </span><span class="s1">tail;</span>

            <span class="s2">if </span><span class="s1">(lastContentRow === </span><span class="s2">null</span><span class="s1">) {</span>
              <span class="s0">// The whole list is part of the tail.</span>
              <span class="s0">// TODO: We could fast path by just rendering the tail now.</span>
              <span class="s1">tail = workInProgress.child;</span>
              <span class="s1">workInProgress.child = </span><span class="s2">null</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
              <span class="s0">// Disconnect the tail rows after the content row.</span>
              <span class="s0">// We're going to render them separately later.</span>
              <span class="s1">tail = lastContentRow.sibling;</span>
              <span class="s1">lastContentRow.sibling = </span><span class="s2">null</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s1">initSuspenseListRenderState(workInProgress, </span><span class="s2">false</span><span class="s1">, </span><span class="s0">// isBackwards</span>
            <span class="s1">tail, lastContentRow, tailMode);</span>
            <span class="s2">break</span><span class="s1">;</span>
          <span class="s1">}</span>

        <span class="s2">case </span><span class="s3">'backwards'</span><span class="s1">:</span>
          <span class="s1">{</span>
            <span class="s0">// We're going to find the first row that has existing content.</span>
            <span class="s0">// At the same time we're going to reverse the list of everything</span>
            <span class="s0">// we pass in the meantime. That's going to be our tail in reverse</span>
            <span class="s0">// order.</span>
            <span class="s2">var </span><span class="s1">_tail = </span><span class="s2">null</span><span class="s1">;</span>
            <span class="s2">var </span><span class="s1">row = workInProgress.child;</span>
            <span class="s1">workInProgress.child = </span><span class="s2">null</span><span class="s1">;</span>

            <span class="s2">while </span><span class="s1">(row !== </span><span class="s2">null</span><span class="s1">) {</span>
              <span class="s2">var </span><span class="s1">currentRow = row.alternate; </span><span class="s0">// New rows can't be content rows.</span>

              <span class="s2">if </span><span class="s1">(currentRow !== </span><span class="s2">null </span><span class="s1">&amp;&amp; findFirstSuspended(currentRow) === </span><span class="s2">null</span><span class="s1">) {</span>
                <span class="s0">// This is the beginning of the main content.</span>
                <span class="s1">workInProgress.child = row;</span>
                <span class="s2">break</span><span class="s1">;</span>
              <span class="s1">}</span>

              <span class="s2">var </span><span class="s1">nextRow = row.sibling;</span>
              <span class="s1">row.sibling = _tail;</span>
              <span class="s1">_tail = row;</span>
              <span class="s1">row = nextRow;</span>
            <span class="s1">} </span><span class="s0">// TODO: If workInProgress.child is null, we can continue on the tail immediately.</span>


            <span class="s1">initSuspenseListRenderState(workInProgress, </span><span class="s2">true</span><span class="s1">, </span><span class="s0">// isBackwards</span>
            <span class="s1">_tail, </span><span class="s2">null</span><span class="s1">, </span><span class="s0">// last</span>
            <span class="s1">tailMode);</span>
            <span class="s2">break</span><span class="s1">;</span>
          <span class="s1">}</span>

        <span class="s2">case </span><span class="s3">'together'</span><span class="s1">:</span>
          <span class="s1">{</span>
            <span class="s1">initSuspenseListRenderState(workInProgress, </span><span class="s2">false</span><span class="s1">, </span><span class="s0">// isBackwards</span>
            <span class="s2">null</span><span class="s1">, </span><span class="s0">// tail</span>
            <span class="s2">null</span><span class="s1">, </span><span class="s0">// last</span>
            <span class="s1">undefined);</span>
            <span class="s2">break</span><span class="s1">;</span>
          <span class="s1">}</span>

        <span class="s2">default</span><span class="s1">:</span>
          <span class="s1">{</span>
            <span class="s0">// The default reveal order is the same as not having</span>
            <span class="s0">// a boundary.</span>
            <span class="s1">workInProgress.memoizedState = </span><span class="s2">null</span><span class="s1">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">workInProgress.child;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">updatePortalComponent(current, workInProgress, renderLanes) {</span>
    <span class="s1">pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);</span>
    <span class="s2">var </span><span class="s1">nextChildren = workInProgress.pendingProps;</span>

    <span class="s2">if </span><span class="s1">(current === </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s0">// Portals are special because we don't append the children during mount</span>
      <span class="s0">// but at commit. Therefore we need to track insertions which the normal</span>
      <span class="s0">// flow doesn't do during mount. This doesn't happen at the root because</span>
      <span class="s0">// the root always starts with a &quot;current&quot; with a null child.</span>
      <span class="s0">// TODO: Consider unifying this with how the root works.</span>
      <span class="s1">workInProgress.child = reconcileChildFibers(workInProgress, </span><span class="s2">null</span><span class="s1">, nextChildren, renderLanes);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">reconcileChildren(current, workInProgress, nextChildren, renderLanes);</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">workInProgress.child;</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">hasWarnedAboutUsingNoValuePropOnContextProvider = </span><span class="s2">false</span><span class="s1">;</span>

  <span class="s2">function </span><span class="s1">updateContextProvider(current, workInProgress, renderLanes) {</span>
    <span class="s2">var </span><span class="s1">providerType = workInProgress.type;</span>
    <span class="s2">var </span><span class="s1">context = providerType._context;</span>
    <span class="s2">var </span><span class="s1">newProps = workInProgress.pendingProps;</span>
    <span class="s2">var </span><span class="s1">oldProps = workInProgress.memoizedProps;</span>
    <span class="s2">var </span><span class="s1">newValue = newProps.value;</span>

    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(!(</span><span class="s3">'value' </span><span class="s2">in </span><span class="s1">newProps)) {</span>
        <span class="s2">if </span><span class="s1">(!hasWarnedAboutUsingNoValuePropOnContextProvider) {</span>
          <span class="s1">hasWarnedAboutUsingNoValuePropOnContextProvider = </span><span class="s2">true</span><span class="s1">;</span>

          <span class="s1">error(</span><span class="s3">'The `value` prop is required for the `&lt;Context.Provider&gt;`. Did you misspell it or forget to pass it?'</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">providerPropTypes = workInProgress.type.propTypes;</span>

      <span class="s2">if </span><span class="s1">(providerPropTypes) {</span>
        <span class="s1">checkPropTypes(providerPropTypes, newProps, </span><span class="s3">'prop'</span><span class="s1">, </span><span class="s3">'Context.Provider'</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">pushProvider(workInProgress, context, newValue);</span>

    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(oldProps !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">var </span><span class="s1">oldValue = oldProps.value;</span>

        <span class="s2">if </span><span class="s1">(objectIs(oldValue, newValue)) {</span>
          <span class="s0">// No change. Bailout early if children are the same.</span>
          <span class="s2">if </span><span class="s1">(oldProps.children === newProps.children &amp;&amp; !hasContextChanged()) {</span>
            <span class="s2">return </span><span class="s1">bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s0">// The context value changed. Search for matching consumers and schedule</span>
          <span class="s0">// them to update.</span>
          <span class="s1">propagateContextChange(workInProgress, context, renderLanes);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">newChildren = newProps.children;</span>
    <span class="s1">reconcileChildren(current, workInProgress, newChildren, renderLanes);</span>
    <span class="s2">return </span><span class="s1">workInProgress.child;</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">hasWarnedAboutUsingContextAsConsumer = </span><span class="s2">false</span><span class="s1">;</span>

  <span class="s2">function </span><span class="s1">updateContextConsumer(current, workInProgress, renderLanes) {</span>
    <span class="s2">var </span><span class="s1">context = workInProgress.type; </span><span class="s0">// The logic below for Context differs depending on PROD or DEV mode. In</span>
    <span class="s0">// DEV mode, we create a separate object for Context.Consumer that acts</span>
    <span class="s0">// like a proxy to Context. This proxy object adds unnecessary code in PROD</span>
    <span class="s0">// so we use the old behaviour (Context.Consumer references Context) to</span>
    <span class="s0">// reduce size and overhead. The separate object references context via</span>
    <span class="s0">// a property called &quot;_context&quot;, which also gives us the ability to check</span>
    <span class="s0">// in DEV mode if this property exists or not and warn if it does not.</span>

    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(context._context === undefined) {</span>
        <span class="s0">// This may be because it's a Context (rather than a Consumer).</span>
        <span class="s0">// Or it may be because it's older React where they're the same thing.</span>
        <span class="s0">// We only want to warn if we're sure it's a new React.</span>
        <span class="s2">if </span><span class="s1">(context !== context.Consumer) {</span>
          <span class="s2">if </span><span class="s1">(!hasWarnedAboutUsingContextAsConsumer) {</span>
            <span class="s1">hasWarnedAboutUsingContextAsConsumer = </span><span class="s2">true</span><span class="s1">;</span>

            <span class="s1">error(</span><span class="s3">'Rendering &lt;Context&gt; directly is not supported and will be removed in ' </span><span class="s1">+ </span><span class="s3">'a future major release. Did you mean to render &lt;Context.Consumer&gt; instead?'</span><span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">context = context._context;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">newProps = workInProgress.pendingProps;</span>
    <span class="s2">var </span><span class="s1">render = newProps.children;</span>

    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">render !== </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s3">'A context consumer was rendered with multiple children, or a child ' </span><span class="s1">+ </span><span class="s3">&quot;that isn't a function. A context consumer expects a single child &quot; </span><span class="s1">+ </span><span class="s3">'that is a function. If you did pass a function, make sure there ' </span><span class="s1">+ </span><span class="s3">'is no trailing or leading whitespace around it.'</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">prepareToReadContext(workInProgress, renderLanes);</span>
    <span class="s2">var </span><span class="s1">newValue = readContext(context);</span>

    <span class="s2">var </span><span class="s1">newChildren;</span>

    <span class="s1">{</span>
      <span class="s1">ReactCurrentOwner$1.current = workInProgress;</span>
      <span class="s1">setIsRendering(</span><span class="s2">true</span><span class="s1">);</span>
      <span class="s1">newChildren = render(newValue);</span>
      <span class="s1">setIsRendering(</span><span class="s2">false</span><span class="s1">);</span>
    <span class="s1">}</span>


    <span class="s1">workInProgress.flags |= PerformedWork;</span>
    <span class="s1">reconcileChildren(current, workInProgress, newChildren, renderLanes);</span>
    <span class="s2">return </span><span class="s1">workInProgress.child;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">markWorkInProgressReceivedUpdate() {</span>
    <span class="s1">didReceiveUpdate = </span><span class="s2">true</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">resetSuspendedCurrentOnMountInLegacyMode(current, workInProgress) {</span>
    <span class="s2">if </span><span class="s1">((workInProgress.mode &amp; ConcurrentMode) === NoMode) {</span>
      <span class="s2">if </span><span class="s1">(current !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s0">// A lazy component only mounts if it suspended inside a non-</span>
        <span class="s0">// concurrent tree, in an inconsistent state. We want to treat it like</span>
        <span class="s0">// a new mount, even though an empty version of it already committed.</span>
        <span class="s0">// Disconnect the alternate pointers.</span>
        <span class="s1">current.alternate = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s1">workInProgress.alternate = </span><span class="s2">null</span><span class="s1">; </span><span class="s0">// Since this is conceptually a new fiber, schedule a Placement effect</span>

        <span class="s1">workInProgress.flags |= Placement;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {</span>
    <span class="s2">if </span><span class="s1">(current !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s0">// Reuse previous dependencies</span>
      <span class="s1">workInProgress.dependencies = current.dependencies;</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s0">// Don't update &quot;base&quot; render times for bailouts.</span>
      <span class="s1">stopProfilerTimerIfRunning();</span>
    <span class="s1">}</span>

    <span class="s1">markSkippedUpdateLanes(workInProgress.lanes); </span><span class="s0">// Check if the children have any pending work.</span>

    <span class="s2">if </span><span class="s1">(!includesSomeLane(renderLanes, workInProgress.childLanes)) {</span>
      <span class="s0">// The children don't have any work either. We can skip them.</span>
      <span class="s0">// TODO: Once we add back resuming, we should check if the children are</span>
      <span class="s0">// a work-in-progress set. If so, we need to transfer their effects.</span>
      <span class="s1">{</span>
        <span class="s2">return null</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// This fiber doesn't have work, but its subtree does. Clone the child</span>
    <span class="s0">// fibers and continue.</span>


    <span class="s1">cloneChildFibers(current, workInProgress);</span>
    <span class="s2">return </span><span class="s1">workInProgress.child;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">remountFiber(current, oldWorkInProgress, newWorkInProgress) {</span>
    <span class="s1">{</span>
      <span class="s2">var </span><span class="s1">returnFiber = oldWorkInProgress.</span><span class="s2">return</span><span class="s1">;</span>

      <span class="s2">if </span><span class="s1">(returnFiber === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s0">// eslint-disable-next-line react-internal/prod-error-codes</span>
        <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Cannot swap the root fiber.'</span><span class="s1">);</span>
      <span class="s1">} </span><span class="s0">// Disconnect from the old current.</span>
      <span class="s0">// It will get deleted.</span>


      <span class="s1">current.alternate = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">oldWorkInProgress.alternate = </span><span class="s2">null</span><span class="s1">; </span><span class="s0">// Connect to the new tree.</span>

      <span class="s1">newWorkInProgress.index = oldWorkInProgress.index;</span>
      <span class="s1">newWorkInProgress.sibling = oldWorkInProgress.sibling;</span>
      <span class="s1">newWorkInProgress.</span><span class="s2">return </span><span class="s1">= oldWorkInProgress.</span><span class="s2">return</span><span class="s1">;</span>
      <span class="s1">newWorkInProgress.ref = oldWorkInProgress.ref; </span><span class="s0">// Replace the child/sibling pointers above it.</span>

      <span class="s2">if </span><span class="s1">(oldWorkInProgress === returnFiber.child) {</span>
        <span class="s1">returnFiber.child = newWorkInProgress;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">var </span><span class="s1">prevSibling = returnFiber.child;</span>

        <span class="s2">if </span><span class="s1">(prevSibling === </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s0">// eslint-disable-next-line react-internal/prod-error-codes</span>
          <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Expected parent to have a child.'</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s2">while </span><span class="s1">(prevSibling.sibling !== oldWorkInProgress) {</span>
          <span class="s1">prevSibling = prevSibling.sibling;</span>

          <span class="s2">if </span><span class="s1">(prevSibling === </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s0">// eslint-disable-next-line react-internal/prod-error-codes</span>
            <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Expected to find the previous sibling.'</span><span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s1">prevSibling.sibling = newWorkInProgress;</span>
      <span class="s1">} </span><span class="s0">// Delete the old fiber and place the new one.</span>
      <span class="s0">// Since the old fiber is disconnected, we have to schedule it manually.</span>


      <span class="s2">var </span><span class="s1">deletions = returnFiber.deletions;</span>

      <span class="s2">if </span><span class="s1">(deletions === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">returnFiber.deletions = [current];</span>
        <span class="s1">returnFiber.flags |= ChildDeletion;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">deletions.push(current);</span>
      <span class="s1">}</span>

      <span class="s1">newWorkInProgress.flags |= Placement; </span><span class="s0">// Restart work from the new fiber.</span>

      <span class="s2">return </span><span class="s1">newWorkInProgress;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">checkScheduledUpdateOrContext(current, renderLanes) {</span>
    <span class="s0">// Before performing an early bailout, we must check if there are pending</span>
    <span class="s0">// updates or context.</span>
    <span class="s2">var </span><span class="s1">updateLanes = current.lanes;</span>

    <span class="s2">if </span><span class="s1">(includesSomeLane(updateLanes, renderLanes)) {</span>
      <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s0">// No pending update, but because context is propagated lazily, we need</span>

    <span class="s2">return false</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes) {</span>
    <span class="s0">// This fiber does not have any pending work. Bailout without entering</span>
    <span class="s0">// the begin phase. There's still some bookkeeping we that needs to be done</span>
    <span class="s0">// in this optimized path, mostly pushing stuff onto the stack.</span>
    <span class="s2">switch </span><span class="s1">(workInProgress.tag) {</span>
      <span class="s2">case </span><span class="s1">HostRoot:</span>
        <span class="s1">pushHostRootContext(workInProgress);</span>
        <span class="s2">var </span><span class="s1">root = workInProgress.stateNode;</span>
        <span class="s2">break</span><span class="s1">;</span>

      <span class="s2">case </span><span class="s1">HostComponent:</span>
        <span class="s1">pushHostContext(workInProgress);</span>
        <span class="s2">break</span><span class="s1">;</span>

      <span class="s2">case </span><span class="s1">ClassComponent:</span>
        <span class="s1">{</span>
          <span class="s2">var </span><span class="s1">Component = workInProgress.type;</span>

          <span class="s2">if </span><span class="s1">(isContextProvider(Component)) {</span>
            <span class="s1">pushContextProvider(workInProgress);</span>
          <span class="s1">}</span>

          <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s2">case </span><span class="s1">HostPortal:</span>
        <span class="s1">pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);</span>
        <span class="s2">break</span><span class="s1">;</span>

      <span class="s2">case </span><span class="s1">ContextProvider:</span>
        <span class="s1">{</span>
          <span class="s2">var </span><span class="s1">newValue = workInProgress.memoizedProps.value;</span>
          <span class="s2">var </span><span class="s1">context = workInProgress.type._context;</span>
          <span class="s1">pushProvider(workInProgress, context, newValue);</span>
          <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s2">case </span><span class="s1">Profiler:</span>
        <span class="s1">{</span>
          <span class="s0">// Profiler should only call onRender when one of its descendants actually rendered.</span>
          <span class="s2">var </span><span class="s1">hasChildWork = includesSomeLane(renderLanes, workInProgress.childLanes);</span>

          <span class="s2">if </span><span class="s1">(hasChildWork) {</span>
            <span class="s1">workInProgress.flags |= Update;</span>
          <span class="s1">}</span>

          <span class="s1">{</span>
            <span class="s0">// Reset effect durations for the next eventual effect phase.</span>
            <span class="s0">// These are reset during render to allow the DevTools commit hook a chance to read them,</span>
            <span class="s2">var </span><span class="s1">stateNode = workInProgress.stateNode;</span>
            <span class="s1">stateNode.effectDuration = </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s1">stateNode.passiveEffectDuration = </span><span class="s4">0</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s2">break</span><span class="s1">;</span>

      <span class="s2">case </span><span class="s1">SuspenseComponent:</span>
        <span class="s1">{</span>
          <span class="s2">var </span><span class="s1">state = workInProgress.memoizedState;</span>

          <span class="s2">if </span><span class="s1">(state !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(state.dehydrated !== </span><span class="s2">null</span><span class="s1">) {</span>
              <span class="s1">pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current)); </span><span class="s0">// We know that this component will suspend again because if it has</span>
              <span class="s0">// been unsuspended it has committed as a resolved Suspense component.</span>
              <span class="s0">// If it needs to be retried, it should have work scheduled on it.</span>

              <span class="s1">workInProgress.flags |= DidCapture; </span><span class="s0">// We should never render the children of a dehydrated boundary until we</span>
              <span class="s0">// upgrade it. We return null instead of bailoutOnAlreadyFinishedWork.</span>

              <span class="s2">return null</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s0">// If this boundary is currently timed out, we need to decide</span>
            <span class="s0">// whether to retry the primary children, or to skip over it and</span>
            <span class="s0">// go straight to the fallback. Check the priority of the primary</span>
            <span class="s0">// child fragment.</span>


            <span class="s2">var </span><span class="s1">primaryChildFragment = workInProgress.child;</span>
            <span class="s2">var </span><span class="s1">primaryChildLanes = primaryChildFragment.childLanes;</span>

            <span class="s2">if </span><span class="s1">(includesSomeLane(renderLanes, primaryChildLanes)) {</span>
              <span class="s0">// The primary children have pending work. Use the normal path</span>
              <span class="s0">// to attempt to render the primary children again.</span>
              <span class="s2">return </span><span class="s1">updateSuspenseComponent(current, workInProgress, renderLanes);</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
              <span class="s0">// The primary child fragment does not have pending work marked</span>
              <span class="s0">// on it</span>
              <span class="s1">pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current)); </span><span class="s0">// The primary children do not have pending work with sufficient</span>
              <span class="s0">// priority. Bailout.</span>

              <span class="s2">var </span><span class="s1">child = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);</span>

              <span class="s2">if </span><span class="s1">(child !== </span><span class="s2">null</span><span class="s1">) {</span>
                <span class="s0">// The fallback children have pending work. Skip over the</span>
                <span class="s0">// primary children and work on the fallback.</span>
                <span class="s2">return </span><span class="s1">child.sibling;</span>
              <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s0">// Note: We can return `null` here because we already checked</span>
                <span class="s0">// whether there were nested context consumers, via the call to</span>
                <span class="s0">// `bailoutOnAlreadyFinishedWork` above.</span>
                <span class="s2">return null</span><span class="s1">;</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current));</span>
          <span class="s1">}</span>

          <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s2">case </span><span class="s1">SuspenseListComponent:</span>
        <span class="s1">{</span>
          <span class="s2">var </span><span class="s1">didSuspendBefore = (current.flags &amp; DidCapture) !== NoFlags;</span>

          <span class="s2">var </span><span class="s1">_hasChildWork = includesSomeLane(renderLanes, workInProgress.childLanes);</span>

          <span class="s2">if </span><span class="s1">(didSuspendBefore) {</span>
            <span class="s2">if </span><span class="s1">(_hasChildWork) {</span>
              <span class="s0">// If something was in fallback state last time, and we have all the</span>
              <span class="s0">// same children then we're still in progressive loading state.</span>
              <span class="s0">// Something might get unblocked by state updates or retries in the</span>
              <span class="s0">// tree which will affect the tail. So we need to use the normal</span>
              <span class="s0">// path to compute the correct tail.</span>
              <span class="s2">return </span><span class="s1">updateSuspenseListComponent(current, workInProgress, renderLanes);</span>
            <span class="s1">} </span><span class="s0">// If none of the children had any work, that means that none of</span>
            <span class="s0">// them got retried so they'll still be blocked in the same way</span>
            <span class="s0">// as before. We can fast bail out.</span>


            <span class="s1">workInProgress.flags |= DidCapture;</span>
          <span class="s1">} </span><span class="s0">// If nothing suspended before and we're rendering the same children,</span>
          <span class="s0">// then the tail doesn't matter. Anything new that suspends will work</span>
          <span class="s0">// in the &quot;together&quot; mode, so we can continue from the state we had.</span>


          <span class="s2">var </span><span class="s1">renderState = workInProgress.memoizedState;</span>

          <span class="s2">if </span><span class="s1">(renderState !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s0">// Reset to the &quot;together&quot; mode in case we've started a different</span>
            <span class="s0">// update in the past but didn't complete it.</span>
            <span class="s1">renderState.rendering = </span><span class="s2">null</span><span class="s1">;</span>
            <span class="s1">renderState.tail = </span><span class="s2">null</span><span class="s1">;</span>
            <span class="s1">renderState.lastEffect = </span><span class="s2">null</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s1">pushSuspenseContext(workInProgress, suspenseStackCursor.current);</span>

          <span class="s2">if </span><span class="s1">(_hasChildWork) {</span>
            <span class="s2">break</span><span class="s1">;</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s0">// If none of the children had any work, that means that none of</span>
            <span class="s0">// them got retried so they'll still be blocked in the same way</span>
            <span class="s0">// as before. We can fast bail out.</span>
            <span class="s2">return null</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

      <span class="s2">case </span><span class="s1">OffscreenComponent:</span>
      <span class="s2">case </span><span class="s1">LegacyHiddenComponent:</span>
        <span class="s1">{</span>
          <span class="s0">// Need to check if the tree still needs to be deferred. This is</span>
          <span class="s0">// almost identical to the logic used in the normal update path,</span>
          <span class="s0">// so we'll just enter that. The only difference is we'll bail out</span>
          <span class="s0">// at the next level instead of this one, because the child props</span>
          <span class="s0">// have not changed. Which is fine.</span>
          <span class="s0">// TODO: Probably should refactor `beginWork` to split the bailout</span>
          <span class="s0">// path from the normal path. I'm tempted to do a labeled break here</span>
          <span class="s0">// but I won't :)</span>
          <span class="s1">workInProgress.lanes = NoLanes;</span>
          <span class="s2">return </span><span class="s1">updateOffscreenComponent(current, workInProgress, renderLanes);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">beginWork(current, workInProgress, renderLanes) {</span>
    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(workInProgress._debugNeedsRemount &amp;&amp; current !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s0">// This will restart the begin phase with a new fiber.</span>
        <span class="s2">return </span><span class="s1">remountFiber(current, workInProgress, createFiberFromTypeAndProps(workInProgress.type, workInProgress.key, workInProgress.pendingProps, workInProgress._debugOwner || </span><span class="s2">null</span><span class="s1">, workInProgress.mode, workInProgress.lanes));</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(current !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">oldProps = current.memoizedProps;</span>
      <span class="s2">var </span><span class="s1">newProps = workInProgress.pendingProps;</span>

      <span class="s2">if </span><span class="s1">(oldProps !== newProps || hasContextChanged() || ( </span><span class="s0">// Force a re-render if the implementation changed due to hot reload:</span>
       <span class="s1">workInProgress.type !== current.type )) {</span>
        <span class="s0">// If props or context changed, mark the fiber as having performed work.</span>
        <span class="s0">// This may be unset if the props are determined to be equal later (memo).</span>
        <span class="s1">didReceiveUpdate = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s0">// Neither props nor legacy context changes. Check if there's a pending</span>
        <span class="s0">// update or context change.</span>
        <span class="s2">var </span><span class="s1">hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current, renderLanes);</span>

        <span class="s2">if </span><span class="s1">(!hasScheduledUpdateOrContext &amp;&amp; </span><span class="s0">// If this is the second pass of an error or suspense boundary, there</span>
        <span class="s0">// may not be work scheduled on `current`, so we check for this flag.</span>
        <span class="s1">(workInProgress.flags &amp; DidCapture) === NoFlags) {</span>
          <span class="s0">// No pending updates or context. Bail out now.</span>
          <span class="s1">didReceiveUpdate = </span><span class="s2">false</span><span class="s1">;</span>
          <span class="s2">return </span><span class="s1">attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes);</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">((current.flags &amp; ForceUpdateForLegacySuspense) !== NoFlags) {</span>
          <span class="s0">// This is a special case that only exists for legacy mode.</span>
          <span class="s0">// See https://github.com/facebook/react/pull/19216.</span>
          <span class="s1">didReceiveUpdate = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s0">// An update was scheduled on this fiber, but there are no new props</span>
          <span class="s0">// nor legacy context. Set this to false. If an update queue or context</span>
          <span class="s0">// consumer produces a changed value, it will set this to true. Otherwise,</span>
          <span class="s0">// the component will assume the children have not changed and bail out.</span>
          <span class="s1">didReceiveUpdate = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">didReceiveUpdate = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s0">// Before entering the begin phase, clear pending update priority.</span>
    <span class="s0">// TODO: This assumes that we're about to evaluate the component and process</span>
    <span class="s0">// the update queue. However, there's an exception: SimpleMemoComponent</span>
    <span class="s0">// sometimes bails out later in the begin phase. This indicates that we should</span>
    <span class="s0">// move this assignment out of the common path and into each branch.</span>


    <span class="s1">workInProgress.lanes = NoLanes;</span>

    <span class="s2">switch </span><span class="s1">(workInProgress.tag) {</span>
      <span class="s2">case </span><span class="s1">IndeterminateComponent:</span>
        <span class="s1">{</span>
          <span class="s2">return </span><span class="s1">mountIndeterminateComponent(current, workInProgress, workInProgress.type, renderLanes);</span>
        <span class="s1">}</span>

      <span class="s2">case </span><span class="s1">LazyComponent:</span>
        <span class="s1">{</span>
          <span class="s2">var </span><span class="s1">elementType = workInProgress.elementType;</span>
          <span class="s2">return </span><span class="s1">mountLazyComponent(current, workInProgress, elementType, renderLanes);</span>
        <span class="s1">}</span>

      <span class="s2">case </span><span class="s1">FunctionComponent:</span>
        <span class="s1">{</span>
          <span class="s2">var </span><span class="s1">Component = workInProgress.type;</span>
          <span class="s2">var </span><span class="s1">unresolvedProps = workInProgress.pendingProps;</span>
          <span class="s2">var </span><span class="s1">resolvedProps = workInProgress.elementType === Component ? unresolvedProps : resolveDefaultProps(Component, unresolvedProps);</span>
          <span class="s2">return </span><span class="s1">updateFunctionComponent(current, workInProgress, Component, resolvedProps, renderLanes);</span>
        <span class="s1">}</span>

      <span class="s2">case </span><span class="s1">ClassComponent:</span>
        <span class="s1">{</span>
          <span class="s2">var </span><span class="s1">_Component = workInProgress.type;</span>
          <span class="s2">var </span><span class="s1">_unresolvedProps = workInProgress.pendingProps;</span>

          <span class="s2">var </span><span class="s1">_resolvedProps = workInProgress.elementType === _Component ? _unresolvedProps : resolveDefaultProps(_Component, _unresolvedProps);</span>

          <span class="s2">return </span><span class="s1">updateClassComponent(current, workInProgress, _Component, _resolvedProps, renderLanes);</span>
        <span class="s1">}</span>

      <span class="s2">case </span><span class="s1">HostRoot:</span>
        <span class="s2">return </span><span class="s1">updateHostRoot(current, workInProgress, renderLanes);</span>

      <span class="s2">case </span><span class="s1">HostComponent:</span>
        <span class="s2">return </span><span class="s1">updateHostComponent(current, workInProgress, renderLanes);</span>

      <span class="s2">case </span><span class="s1">HostText:</span>
        <span class="s2">return </span><span class="s1">updateHostText();</span>

      <span class="s2">case </span><span class="s1">SuspenseComponent:</span>
        <span class="s2">return </span><span class="s1">updateSuspenseComponent(current, workInProgress, renderLanes);</span>

      <span class="s2">case </span><span class="s1">HostPortal:</span>
        <span class="s2">return </span><span class="s1">updatePortalComponent(current, workInProgress, renderLanes);</span>

      <span class="s2">case </span><span class="s1">ForwardRef:</span>
        <span class="s1">{</span>
          <span class="s2">var </span><span class="s1">type = workInProgress.type;</span>
          <span class="s2">var </span><span class="s1">_unresolvedProps2 = workInProgress.pendingProps;</span>

          <span class="s2">var </span><span class="s1">_resolvedProps2 = workInProgress.elementType === type ? _unresolvedProps2 : resolveDefaultProps(type, _unresolvedProps2);</span>

          <span class="s2">return </span><span class="s1">updateForwardRef(current, workInProgress, type, _resolvedProps2, renderLanes);</span>
        <span class="s1">}</span>

      <span class="s2">case </span><span class="s1">Fragment:</span>
        <span class="s2">return </span><span class="s1">updateFragment(current, workInProgress, renderLanes);</span>

      <span class="s2">case </span><span class="s1">Mode:</span>
        <span class="s2">return </span><span class="s1">updateMode(current, workInProgress, renderLanes);</span>

      <span class="s2">case </span><span class="s1">Profiler:</span>
        <span class="s2">return </span><span class="s1">updateProfiler(current, workInProgress, renderLanes);</span>

      <span class="s2">case </span><span class="s1">ContextProvider:</span>
        <span class="s2">return </span><span class="s1">updateContextProvider(current, workInProgress, renderLanes);</span>

      <span class="s2">case </span><span class="s1">ContextConsumer:</span>
        <span class="s2">return </span><span class="s1">updateContextConsumer(current, workInProgress, renderLanes);</span>

      <span class="s2">case </span><span class="s1">MemoComponent:</span>
        <span class="s1">{</span>
          <span class="s2">var </span><span class="s1">_type2 = workInProgress.type;</span>
          <span class="s2">var </span><span class="s1">_unresolvedProps3 = workInProgress.pendingProps; </span><span class="s0">// Resolve outer props first, then resolve inner props.</span>

          <span class="s2">var </span><span class="s1">_resolvedProps3 = resolveDefaultProps(_type2, _unresolvedProps3);</span>

          <span class="s1">{</span>
            <span class="s2">if </span><span class="s1">(workInProgress.type !== workInProgress.elementType) {</span>
              <span class="s2">var </span><span class="s1">outerPropTypes = _type2.propTypes;</span>

              <span class="s2">if </span><span class="s1">(outerPropTypes) {</span>
                <span class="s1">checkPropTypes(outerPropTypes, _resolvedProps3, </span><span class="s0">// Resolved for outer only</span>
                <span class="s3">'prop'</span><span class="s1">, getComponentNameFromType(_type2));</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s1">_resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3);</span>
          <span class="s2">return </span><span class="s1">updateMemoComponent(current, workInProgress, _type2, _resolvedProps3, renderLanes);</span>
        <span class="s1">}</span>

      <span class="s2">case </span><span class="s1">SimpleMemoComponent:</span>
        <span class="s1">{</span>
          <span class="s2">return </span><span class="s1">updateSimpleMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);</span>
        <span class="s1">}</span>

      <span class="s2">case </span><span class="s1">IncompleteClassComponent:</span>
        <span class="s1">{</span>
          <span class="s2">var </span><span class="s1">_Component2 = workInProgress.type;</span>
          <span class="s2">var </span><span class="s1">_unresolvedProps4 = workInProgress.pendingProps;</span>

          <span class="s2">var </span><span class="s1">_resolvedProps4 = workInProgress.elementType === _Component2 ? _unresolvedProps4 : resolveDefaultProps(_Component2, _unresolvedProps4);</span>

          <span class="s2">return </span><span class="s1">mountIncompleteClassComponent(current, workInProgress, _Component2, _resolvedProps4, renderLanes);</span>
        <span class="s1">}</span>

      <span class="s2">case </span><span class="s1">SuspenseListComponent:</span>
        <span class="s1">{</span>
          <span class="s2">return </span><span class="s1">updateSuspenseListComponent(current, workInProgress, renderLanes);</span>
        <span class="s1">}</span>

      <span class="s2">case </span><span class="s1">ScopeComponent:</span>
        <span class="s1">{</span>

          <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s2">case </span><span class="s1">OffscreenComponent:</span>
        <span class="s1">{</span>
          <span class="s2">return </span><span class="s1">updateOffscreenComponent(current, workInProgress, renderLanes);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">&quot;Unknown unit of work tag (&quot; </span><span class="s1">+ workInProgress.tag + </span><span class="s3">&quot;). This error is likely caused by a bug in &quot; </span><span class="s1">+ </span><span class="s3">'React. Please file an issue.'</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">markUpdate(workInProgress) {</span>
    <span class="s0">// Tag the fiber with an update effect. This turns a Placement into</span>
    <span class="s0">// a PlacementAndUpdate.</span>
    <span class="s1">workInProgress.flags |= Update;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">markRef$1(workInProgress) {</span>
    <span class="s1">workInProgress.flags |= Ref;</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">appendAllChildren;</span>
  <span class="s2">var </span><span class="s1">updateHostContainer;</span>
  <span class="s2">var </span><span class="s1">updateHostComponent$1;</span>
  <span class="s2">var </span><span class="s1">updateHostText$1;</span>

  <span class="s1">{</span>
    <span class="s0">// Mutation mode</span>
    <span class="s1">appendAllChildren = </span><span class="s2">function </span><span class="s1">(parent, workInProgress, needsVisibilityToggle, isHidden) {</span>
      <span class="s0">// We only have the top Fiber that was created but we need recurse down its</span>
      <span class="s0">// children to find all the terminal nodes.</span>
      <span class="s2">var </span><span class="s1">node = workInProgress.child;</span>

      <span class="s2">while </span><span class="s1">(node !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(node.tag === HostComponent || node.tag === HostText) {</span>
          <span class="s1">appendInitialChild(parent, node.stateNode);</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(node.tag === HostPortal) ; </span><span class="s2">else if </span><span class="s1">(node.child !== </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">node.child.</span><span class="s2">return </span><span class="s1">= node;</span>
          <span class="s1">node = node.child;</span>
          <span class="s2">continue</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(node === workInProgress) {</span>
          <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s2">while </span><span class="s1">(node.sibling === </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s2">if </span><span class="s1">(node.</span><span class="s2">return </span><span class="s1">=== </span><span class="s2">null </span><span class="s1">|| node.</span><span class="s2">return </span><span class="s1">=== workInProgress) {</span>
            <span class="s2">return</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s1">node = node.</span><span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">node.sibling.</span><span class="s2">return </span><span class="s1">= node.</span><span class="s2">return</span><span class="s1">;</span>
        <span class="s1">node = node.sibling;</span>
      <span class="s1">}</span>
    <span class="s1">};</span>

    <span class="s1">updateHostContainer = </span><span class="s2">function </span><span class="s1">(current, workInProgress) {</span><span class="s0">// Noop</span>
    <span class="s1">};</span>

    <span class="s1">updateHostComponent$1 = </span><span class="s2">function </span><span class="s1">(current, workInProgress, type, newProps, rootContainerInstance) {</span>
      <span class="s0">// If we have an alternate, that means this is an update and we need to</span>
      <span class="s0">// schedule a side-effect to do the updates.</span>
      <span class="s2">var </span><span class="s1">oldProps = current.memoizedProps;</span>

      <span class="s2">if </span><span class="s1">(oldProps === newProps) {</span>
        <span class="s0">// In mutation mode, this is sufficient for a bailout because</span>
        <span class="s0">// we won't touch this node even if children changed.</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// If we get updated because one of our children updated, we don't</span>
      <span class="s0">// have newProps so we'll have to reuse them.</span>
      <span class="s0">// TODO: Split the update API as separate for the props vs. children.</span>
      <span class="s0">// Even better would be if children weren't special cased at all tho.</span>


      <span class="s2">var </span><span class="s1">instance = workInProgress.stateNode;</span>
      <span class="s2">var </span><span class="s1">currentHostContext = getHostContext(); </span><span class="s0">// TODO: Experiencing an error where oldProps is null. Suggests a host</span>
      <span class="s0">// component is hitting the resume path. Figure out why. Possibly</span>
      <span class="s0">// related to `hidden`.</span>

      <span class="s2">var </span><span class="s1">updatePayload = prepareUpdate(); </span><span class="s0">// TODO: Type this specific to this type of component.</span>

      <span class="s1">workInProgress.updateQueue = updatePayload; </span><span class="s0">// If the update payload indicates that there is a change or if there</span>
      <span class="s0">// is a new ref we mark this as an update. All the work is done in commitWork.</span>

      <span class="s2">if </span><span class="s1">(updatePayload) {</span>
        <span class="s1">markUpdate(workInProgress);</span>
      <span class="s1">}</span>
    <span class="s1">};</span>

    <span class="s1">updateHostText$1 = </span><span class="s2">function </span><span class="s1">(current, workInProgress, oldText, newText) {</span>
      <span class="s0">// If the text differs, mark it as an update. All the work in done in commitWork.</span>
      <span class="s2">if </span><span class="s1">(oldText !== newText) {</span>
        <span class="s1">markUpdate(workInProgress);</span>
      <span class="s1">}</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {</span>

    <span class="s2">switch </span><span class="s1">(renderState.tailMode) {</span>
      <span class="s2">case </span><span class="s3">'hidden'</span><span class="s1">:</span>
        <span class="s1">{</span>
          <span class="s0">// Any insertions at the end of the tail list after this point</span>
          <span class="s0">// should be invisible. If there are already mounted boundaries</span>
          <span class="s0">// anything before them are not considered for collapsing.</span>
          <span class="s0">// Therefore we need to go through the whole tail to find if</span>
          <span class="s0">// there are any.</span>
          <span class="s2">var </span><span class="s1">tailNode = renderState.tail;</span>
          <span class="s2">var </span><span class="s1">lastTailNode = </span><span class="s2">null</span><span class="s1">;</span>

          <span class="s2">while </span><span class="s1">(tailNode !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(tailNode.alternate !== </span><span class="s2">null</span><span class="s1">) {</span>
              <span class="s1">lastTailNode = tailNode;</span>
            <span class="s1">}</span>

            <span class="s1">tailNode = tailNode.sibling;</span>
          <span class="s1">} </span><span class="s0">// Next we're simply going to delete all insertions after the</span>
          <span class="s0">// last rendered item.</span>


          <span class="s2">if </span><span class="s1">(lastTailNode === </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s0">// All remaining items in the tail are insertions.</span>
            <span class="s1">renderState.tail = </span><span class="s2">null</span><span class="s1">;</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s0">// Detach the insertion after the last node that was already</span>
            <span class="s0">// inserted.</span>
            <span class="s1">lastTailNode.sibling = </span><span class="s2">null</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s2">case </span><span class="s3">'collapsed'</span><span class="s1">:</span>
        <span class="s1">{</span>
          <span class="s0">// Any insertions at the end of the tail list after this point</span>
          <span class="s0">// should be invisible. If there are already mounted boundaries</span>
          <span class="s0">// anything before them are not considered for collapsing.</span>
          <span class="s0">// Therefore we need to go through the whole tail to find if</span>
          <span class="s0">// there are any.</span>
          <span class="s2">var </span><span class="s1">_tailNode = renderState.tail;</span>
          <span class="s2">var </span><span class="s1">_lastTailNode = </span><span class="s2">null</span><span class="s1">;</span>

          <span class="s2">while </span><span class="s1">(_tailNode !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(_tailNode.alternate !== </span><span class="s2">null</span><span class="s1">) {</span>
              <span class="s1">_lastTailNode = _tailNode;</span>
            <span class="s1">}</span>

            <span class="s1">_tailNode = _tailNode.sibling;</span>
          <span class="s1">} </span><span class="s0">// Next we're simply going to delete all insertions after the</span>
          <span class="s0">// last rendered item.</span>


          <span class="s2">if </span><span class="s1">(_lastTailNode === </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s0">// All remaining items in the tail are insertions.</span>
            <span class="s2">if </span><span class="s1">(!hasRenderedATailFallback &amp;&amp; renderState.tail !== </span><span class="s2">null</span><span class="s1">) {</span>
              <span class="s0">// We suspended during the head. We want to show at least one</span>
              <span class="s0">// row at the tail. So we'll keep on and cut off the rest.</span>
              <span class="s1">renderState.tail.sibling = </span><span class="s2">null</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
              <span class="s1">renderState.tail = </span><span class="s2">null</span><span class="s1">;</span>
            <span class="s1">}</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s0">// Detach the insertion after the last node that was already</span>
            <span class="s0">// inserted.</span>
            <span class="s1">_lastTailNode.sibling = </span><span class="s2">null</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">bubbleProperties(completedWork) {</span>
    <span class="s2">var </span><span class="s1">didBailout = completedWork.alternate !== </span><span class="s2">null </span><span class="s1">&amp;&amp; completedWork.alternate.child === completedWork.child;</span>
    <span class="s2">var </span><span class="s1">newChildLanes = NoLanes;</span>
    <span class="s2">var </span><span class="s1">subtreeFlags = NoFlags;</span>

    <span class="s2">if </span><span class="s1">(!didBailout) {</span>
      <span class="s0">// Bubble up the earliest expiration time.</span>
      <span class="s2">if </span><span class="s1">( (completedWork.mode &amp; ProfileMode) !== NoMode) {</span>
        <span class="s0">// In profiling mode, resetChildExpirationTime is also used to reset</span>
        <span class="s0">// profiler durations.</span>
        <span class="s2">var </span><span class="s1">actualDuration = completedWork.actualDuration;</span>
        <span class="s2">var </span><span class="s1">treeBaseDuration = completedWork.selfBaseDuration;</span>
        <span class="s2">var </span><span class="s1">child = completedWork.child;</span>

        <span class="s2">while </span><span class="s1">(child !== </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));</span>
          <span class="s1">subtreeFlags |= child.subtreeFlags;</span>
          <span class="s1">subtreeFlags |= child.flags; </span><span class="s0">// When a fiber is cloned, its actualDuration is reset to 0. This value will</span>
          <span class="s0">// only be updated if work is done on the fiber (i.e. it doesn't bailout).</span>
          <span class="s0">// When work is done, it should bubble to the parent's actualDuration. If</span>
          <span class="s0">// the fiber has not been cloned though, (meaning no work was done), then</span>
          <span class="s0">// this value will reflect the amount of time spent working on a previous</span>
          <span class="s0">// render. In that case it should not bubble. We determine whether it was</span>
          <span class="s0">// cloned by comparing the child pointer.</span>

          <span class="s1">actualDuration += child.actualDuration;</span>
          <span class="s1">treeBaseDuration += child.treeBaseDuration;</span>
          <span class="s1">child = child.sibling;</span>
        <span class="s1">}</span>

        <span class="s1">completedWork.actualDuration = actualDuration;</span>
        <span class="s1">completedWork.treeBaseDuration = treeBaseDuration;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">var </span><span class="s1">_child = completedWork.child;</span>

        <span class="s2">while </span><span class="s1">(_child !== </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child.lanes, _child.childLanes));</span>
          <span class="s1">subtreeFlags |= _child.subtreeFlags;</span>
          <span class="s1">subtreeFlags |= _child.flags; </span><span class="s0">// Update the return pointer so the tree is consistent. This is a code</span>
          <span class="s0">// smell because it assumes the commit phase is never concurrent with</span>
          <span class="s0">// the render phase. Will address during refactor to alternate model.</span>

          <span class="s1">_child.</span><span class="s2">return </span><span class="s1">= completedWork;</span>
          <span class="s1">_child = _child.sibling;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">completedWork.subtreeFlags |= subtreeFlags;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s0">// Bubble up the earliest expiration time.</span>
      <span class="s2">if </span><span class="s1">( (completedWork.mode &amp; ProfileMode) !== NoMode) {</span>
        <span class="s0">// In profiling mode, resetChildExpirationTime is also used to reset</span>
        <span class="s0">// profiler durations.</span>
        <span class="s2">var </span><span class="s1">_treeBaseDuration = completedWork.selfBaseDuration;</span>
        <span class="s2">var </span><span class="s1">_child2 = completedWork.child;</span>

        <span class="s2">while </span><span class="s1">(_child2 !== </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child2.lanes, _child2.childLanes)); </span><span class="s0">// &quot;Static&quot; flags share the lifetime of the fiber/hook they belong to,</span>
          <span class="s0">// so we should bubble those up even during a bailout. All the other</span>
          <span class="s0">// flags have a lifetime only of a single render + commit, so we should</span>
          <span class="s0">// ignore them.</span>

          <span class="s1">subtreeFlags |= _child2.subtreeFlags &amp; StaticMask;</span>
          <span class="s1">subtreeFlags |= _child2.flags &amp; StaticMask;</span>
          <span class="s1">_treeBaseDuration += _child2.treeBaseDuration;</span>
          <span class="s1">_child2 = _child2.sibling;</span>
        <span class="s1">}</span>

        <span class="s1">completedWork.treeBaseDuration = _treeBaseDuration;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">var </span><span class="s1">_child3 = completedWork.child;</span>

        <span class="s2">while </span><span class="s1">(_child3 !== </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child3.lanes, _child3.childLanes)); </span><span class="s0">// &quot;Static&quot; flags share the lifetime of the fiber/hook they belong to,</span>
          <span class="s0">// so we should bubble those up even during a bailout. All the other</span>
          <span class="s0">// flags have a lifetime only of a single render + commit, so we should</span>
          <span class="s0">// ignore them.</span>

          <span class="s1">subtreeFlags |= _child3.subtreeFlags &amp; StaticMask;</span>
          <span class="s1">subtreeFlags |= _child3.flags &amp; StaticMask; </span><span class="s0">// Update the return pointer so the tree is consistent. This is a code</span>
          <span class="s0">// smell because it assumes the commit phase is never concurrent with</span>
          <span class="s0">// the render phase. Will address during refactor to alternate model.</span>

          <span class="s1">_child3.</span><span class="s2">return </span><span class="s1">= completedWork;</span>
          <span class="s1">_child3 = _child3.sibling;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">completedWork.subtreeFlags |= subtreeFlags;</span>
    <span class="s1">}</span>

    <span class="s1">completedWork.childLanes = newChildLanes;</span>
    <span class="s2">return </span><span class="s1">didBailout;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">completeDehydratedSuspenseBoundary(current, workInProgress, nextState) {</span>

    <span class="s2">var </span><span class="s1">wasHydrated = popHydrationState();</span>

    <span class="s2">if </span><span class="s1">(nextState !== </span><span class="s2">null </span><span class="s1">&amp;&amp; nextState.dehydrated !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s0">// We might be inside a hydration state the first time we're picking up this</span>
      <span class="s0">// Suspense boundary, and also after we've reentered it for further hydration.</span>
      <span class="s2">if </span><span class="s1">(current === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(!wasHydrated) {</span>
          <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'A dehydrated suspense component was completed without a hydrated node. ' </span><span class="s1">+ </span><span class="s3">'This is probably a bug in React.'</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s1">prepareToHydrateHostSuspenseInstance();</span>
        <span class="s1">bubbleProperties(workInProgress);</span>

        <span class="s1">{</span>
          <span class="s2">if </span><span class="s1">((workInProgress.mode &amp; ProfileMode) !== NoMode) {</span>
            <span class="s2">var </span><span class="s1">isTimedOutSuspense = nextState !== </span><span class="s2">null</span><span class="s1">;</span>

            <span class="s2">if </span><span class="s1">(isTimedOutSuspense) {</span>
              <span class="s0">// Don't count time spent in a timed out Suspense subtree as part of the base duration.</span>
              <span class="s2">var </span><span class="s1">primaryChildFragment = workInProgress.child;</span>

              <span class="s2">if </span><span class="s1">(primaryChildFragment !== </span><span class="s2">null</span><span class="s1">) {</span>
                <span class="s0">// $FlowFixMe Flow doesn't support type casting in combination with the -= operator</span>
                <span class="s1">workInProgress.treeBaseDuration -= primaryChildFragment.treeBaseDuration;</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s2">return false</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>

        <span class="s2">if </span><span class="s1">((workInProgress.flags &amp; DidCapture) === NoFlags) {</span>
          <span class="s0">// This boundary did not suspend so it's now hydrated and unsuspended.</span>
          <span class="s1">workInProgress.memoizedState = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s0">// If nothing suspended, we need to schedule an effect to mark this boundary</span>
        <span class="s0">// as having hydrated so events know that they're free to be invoked.</span>
        <span class="s0">// It's also a signal to replay events and the suspense callback.</span>
        <span class="s0">// If something suspended, schedule an effect to attach retry listeners.</span>
        <span class="s0">// So we might as well always mark this.</span>


        <span class="s1">workInProgress.flags |= Update;</span>
        <span class="s1">bubbleProperties(workInProgress);</span>

        <span class="s1">{</span>
          <span class="s2">if </span><span class="s1">((workInProgress.mode &amp; ProfileMode) !== NoMode) {</span>
            <span class="s2">var </span><span class="s1">_isTimedOutSuspense = nextState !== </span><span class="s2">null</span><span class="s1">;</span>

            <span class="s2">if </span><span class="s1">(_isTimedOutSuspense) {</span>
              <span class="s0">// Don't count time spent in a timed out Suspense subtree as part of the base duration.</span>
              <span class="s2">var </span><span class="s1">_primaryChildFragment = workInProgress.child;</span>

              <span class="s2">if </span><span class="s1">(_primaryChildFragment !== </span><span class="s2">null</span><span class="s1">) {</span>
                <span class="s0">// $FlowFixMe Flow doesn't support type casting in combination with the -= operator</span>
                <span class="s1">workInProgress.treeBaseDuration -= _primaryChildFragment.treeBaseDuration;</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s2">return false</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s0">// Successfully completed this tree. If this was a forced client render,</span>
      <span class="s0">// there may have been recoverable errors during first hydration</span>
      <span class="s0">// attempt. If so, add them to a queue so we can log them in the</span>
      <span class="s0">// commit phase.</span>
      <span class="s1">upgradeHydrationErrorsToRecoverable(); </span><span class="s0">// Fall through to normal Suspense path</span>

      <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">completeWork(current, workInProgress, renderLanes) {</span>
    <span class="s2">var </span><span class="s1">newProps = workInProgress.pendingProps; </span><span class="s0">// Note: This intentionally doesn't check if we're hydrating because comparing</span>
    <span class="s0">// to the current tree provider fiber is just as fast and less error-prone.</span>
    <span class="s0">// Ideally we would have a special version of the work loop only</span>
    <span class="s0">// for hydration.</span>

    <span class="s1">popTreeContext(workInProgress);</span>

    <span class="s2">switch </span><span class="s1">(workInProgress.tag) {</span>
      <span class="s2">case </span><span class="s1">IndeterminateComponent:</span>
      <span class="s2">case </span><span class="s1">LazyComponent:</span>
      <span class="s2">case </span><span class="s1">SimpleMemoComponent:</span>
      <span class="s2">case </span><span class="s1">FunctionComponent:</span>
      <span class="s2">case </span><span class="s1">ForwardRef:</span>
      <span class="s2">case </span><span class="s1">Fragment:</span>
      <span class="s2">case </span><span class="s1">Mode:</span>
      <span class="s2">case </span><span class="s1">Profiler:</span>
      <span class="s2">case </span><span class="s1">ContextConsumer:</span>
      <span class="s2">case </span><span class="s1">MemoComponent:</span>
        <span class="s1">bubbleProperties(workInProgress);</span>
        <span class="s2">return null</span><span class="s1">;</span>

      <span class="s2">case </span><span class="s1">ClassComponent:</span>
        <span class="s1">{</span>
          <span class="s2">var </span><span class="s1">Component = workInProgress.type;</span>

          <span class="s2">if </span><span class="s1">(isContextProvider(Component)) {</span>
            <span class="s1">popContext(workInProgress);</span>
          <span class="s1">}</span>

          <span class="s1">bubbleProperties(workInProgress);</span>
          <span class="s2">return null</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s2">case </span><span class="s1">HostRoot:</span>
        <span class="s1">{</span>
          <span class="s2">var </span><span class="s1">fiberRoot = workInProgress.stateNode;</span>
          <span class="s1">popHostContainer(workInProgress);</span>
          <span class="s1">popTopLevelContextObject(workInProgress);</span>
          <span class="s1">resetWorkInProgressVersions();</span>

          <span class="s2">if </span><span class="s1">(fiberRoot.pendingContext) {</span>
            <span class="s1">fiberRoot.context = fiberRoot.pendingContext;</span>
            <span class="s1">fiberRoot.pendingContext = </span><span class="s2">null</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s2">if </span><span class="s1">(current === </span><span class="s2">null </span><span class="s1">|| current.child === </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s0">// If we hydrated, pop so that we can delete any remaining children</span>
            <span class="s0">// that weren't hydrated.</span>
            <span class="s2">var </span><span class="s1">wasHydrated = popHydrationState();</span>

            <span class="s2">if </span><span class="s1">(wasHydrated) {</span>
              <span class="s0">// If we hydrated, then we'll need to schedule an update for</span>
              <span class="s0">// the commit side-effects on the root.</span>
              <span class="s1">markUpdate(workInProgress);</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
              <span class="s2">if </span><span class="s1">(current !== </span><span class="s2">null</span><span class="s1">) {</span>
                <span class="s2">var </span><span class="s1">prevState = current.memoizedState;</span>

                <span class="s2">if </span><span class="s1">( </span><span class="s0">// Check if this is a client root</span>
                <span class="s1">!prevState.isDehydrated || </span><span class="s0">// Check if we reverted to client rendering (e.g. due to an error)</span>
                <span class="s1">(workInProgress.flags &amp; ForceClientRender) !== NoFlags) {</span>
                  <span class="s0">// Schedule an effect to clear this container at the start of the</span>
                  <span class="s0">// next commit. This handles the case of React rendering into a</span>
                  <span class="s0">// container with previous children. It's also safe to do for</span>
                  <span class="s0">// updates too, because current.child would only be null if the</span>
                  <span class="s0">// previous render was null (so the container would already</span>
                  <span class="s0">// be empty).</span>
                  <span class="s1">workInProgress.flags |= Snapshot; </span><span class="s0">// If this was a forced client render, there may have been</span>
                  <span class="s0">// recoverable errors during first hydration attempt. If so, add</span>
                  <span class="s0">// them to a queue so we can log them in the commit phase.</span>

                  <span class="s1">upgradeHydrationErrorsToRecoverable();</span>
                <span class="s1">}</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s1">updateHostContainer(current, workInProgress);</span>
          <span class="s1">bubbleProperties(workInProgress);</span>

          <span class="s2">return null</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s2">case </span><span class="s1">HostComponent:</span>
        <span class="s1">{</span>
          <span class="s1">popHostContext(workInProgress);</span>
          <span class="s2">var </span><span class="s1">rootContainerInstance = getRootHostContainer();</span>
          <span class="s2">var </span><span class="s1">type = workInProgress.type;</span>

          <span class="s2">if </span><span class="s1">(current !== </span><span class="s2">null </span><span class="s1">&amp;&amp; workInProgress.stateNode != </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">updateHostComponent$1(current, workInProgress, type, newProps, rootContainerInstance);</span>

            <span class="s2">if </span><span class="s1">(current.ref !== workInProgress.ref) {</span>
              <span class="s1">markRef$1(workInProgress);</span>
            <span class="s1">}</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s2">if </span><span class="s1">(!newProps) {</span>
              <span class="s2">if </span><span class="s1">(workInProgress.stateNode === </span><span class="s2">null</span><span class="s1">) {</span>
                <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'We must have new props for new mounts. This error is likely ' </span><span class="s1">+ </span><span class="s3">'caused by a bug in React. Please file an issue.'</span><span class="s1">);</span>
              <span class="s1">} </span><span class="s0">// This can happen when we abort work.</span>


              <span class="s1">bubbleProperties(workInProgress);</span>
              <span class="s2">return null</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s2">var </span><span class="s1">currentHostContext = getHostContext(); </span><span class="s0">// TODO: Move createInstance to beginWork and keep it on a context</span>
            <span class="s0">// &quot;stack&quot; as the parent. Then append children as we go in beginWork</span>
            <span class="s0">// or completeWork depending on whether we want to add them top-&gt;down or</span>
            <span class="s0">// bottom-&gt;up. Top-&gt;down is faster in IE11.</span>

            <span class="s2">var </span><span class="s1">_wasHydrated = popHydrationState();</span>

            <span class="s2">if </span><span class="s1">(_wasHydrated) {</span>
              <span class="s0">// TODO: Move this and createInstance step into the beginPhase</span>
              <span class="s0">// to consolidate.</span>
              <span class="s2">if </span><span class="s1">(prepareToHydrateHostInstance()) {</span>
                <span class="s0">// If changes to the hydrated node need to be applied at the</span>
                <span class="s0">// commit-phase we mark this as such.</span>
                <span class="s1">markUpdate(workInProgress);</span>
              <span class="s1">}</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
              <span class="s2">var </span><span class="s1">instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress);</span>
              <span class="s1">appendAllChildren(instance, workInProgress, </span><span class="s2">false</span><span class="s1">, </span><span class="s2">false</span><span class="s1">);</span>
              <span class="s1">workInProgress.stateNode = instance; </span><span class="s0">// Certain renderers require commit-time effects for initial mount.</span>
            <span class="s1">}</span>

            <span class="s2">if </span><span class="s1">(workInProgress.ref !== </span><span class="s2">null</span><span class="s1">) {</span>
              <span class="s0">// If there is a ref on a host node we need to schedule a callback</span>
              <span class="s1">markRef$1(workInProgress);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s1">bubbleProperties(workInProgress);</span>
          <span class="s2">return null</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s2">case </span><span class="s1">HostText:</span>
        <span class="s1">{</span>
          <span class="s2">var </span><span class="s1">newText = newProps;</span>

          <span class="s2">if </span><span class="s1">(current &amp;&amp; workInProgress.stateNode != </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">var </span><span class="s1">oldText = current.memoizedProps; </span><span class="s0">// If we have an alternate, that means this is an update and we need</span>
            <span class="s0">// to schedule a side-effect to do the updates.</span>

            <span class="s1">updateHostText$1(current, workInProgress, oldText, newText);</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">newText !== </span><span class="s3">'string'</span><span class="s1">) {</span>
              <span class="s2">if </span><span class="s1">(workInProgress.stateNode === </span><span class="s2">null</span><span class="s1">) {</span>
                <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'We must have new props for new mounts. This error is likely ' </span><span class="s1">+ </span><span class="s3">'caused by a bug in React. Please file an issue.'</span><span class="s1">);</span>
              <span class="s1">} </span><span class="s0">// This can happen when we abort work.</span>

            <span class="s1">}</span>

            <span class="s2">var </span><span class="s1">_rootContainerInstance = getRootHostContainer();</span>

            <span class="s2">var </span><span class="s1">_currentHostContext = getHostContext();</span>

            <span class="s2">var </span><span class="s1">_wasHydrated2 = popHydrationState();</span>

            <span class="s2">if </span><span class="s1">(_wasHydrated2) {</span>
              <span class="s2">if </span><span class="s1">(prepareToHydrateHostTextInstance()) {</span>
                <span class="s1">markUpdate(workInProgress);</span>
              <span class="s1">}</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
              <span class="s1">workInProgress.stateNode = createTextInstance(newText);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s1">bubbleProperties(workInProgress);</span>
          <span class="s2">return null</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s2">case </span><span class="s1">SuspenseComponent:</span>
        <span class="s1">{</span>
          <span class="s1">popSuspenseContext(workInProgress);</span>
          <span class="s2">var </span><span class="s1">nextState = workInProgress.memoizedState; </span><span class="s0">// Special path for dehydrated boundaries. We may eventually move this</span>
          <span class="s0">// to its own fiber type so that we can add other kinds of hydration</span>
          <span class="s0">// boundaries that aren't associated with a Suspense tree. In anticipation</span>
          <span class="s0">// of such a refactor, all the hydration logic is contained in</span>
          <span class="s0">// this branch.</span>

          <span class="s2">if </span><span class="s1">(current === </span><span class="s2">null </span><span class="s1">|| current.memoizedState !== </span><span class="s2">null </span><span class="s1">&amp;&amp; current.memoizedState.dehydrated !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">var </span><span class="s1">fallthroughToNormalSuspensePath = completeDehydratedSuspenseBoundary(current, workInProgress, nextState);</span>

            <span class="s2">if </span><span class="s1">(!fallthroughToNormalSuspensePath) {</span>
              <span class="s2">if </span><span class="s1">(workInProgress.flags &amp; ShouldCapture) {</span>
                <span class="s0">// Special case. There were remaining unhydrated nodes. We treat</span>
                <span class="s0">// this as a mismatch. Revert to client rendering.</span>
                <span class="s2">return </span><span class="s1">workInProgress;</span>
              <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s0">// Did not finish hydrating, either because this is the initial</span>
                <span class="s0">// render or because something suspended.</span>
                <span class="s2">return null</span><span class="s1">;</span>
              <span class="s1">}</span>
            <span class="s1">} </span><span class="s0">// Continue with the normal Suspense path.</span>

          <span class="s1">}</span>

          <span class="s2">if </span><span class="s1">((workInProgress.flags &amp; DidCapture) !== NoFlags) {</span>
            <span class="s0">// Something suspended. Re-render with the fallback children.</span>
            <span class="s1">workInProgress.lanes = renderLanes; </span><span class="s0">// Do not reset the effect list.</span>

            <span class="s2">if </span><span class="s1">( (workInProgress.mode &amp; ProfileMode) !== NoMode) {</span>
              <span class="s1">transferActualDuration(workInProgress);</span>
            <span class="s1">} </span><span class="s0">// Don't bubble properties in this case.</span>


            <span class="s2">return </span><span class="s1">workInProgress;</span>
          <span class="s1">}</span>

          <span class="s2">var </span><span class="s1">nextDidTimeout = nextState !== </span><span class="s2">null</span><span class="s1">;</span>
          <span class="s2">var </span><span class="s1">prevDidTimeout = current !== </span><span class="s2">null </span><span class="s1">&amp;&amp; current.memoizedState !== </span><span class="s2">null</span><span class="s1">;</span>
          <span class="s0">// a passive effect, which is when we process the transitions</span>


          <span class="s2">if </span><span class="s1">(nextDidTimeout !== prevDidTimeout) {</span>
            <span class="s0">// an effect to toggle the subtree's visibility. When we switch from</span>
            <span class="s0">// fallback -&gt; primary, the inner Offscreen fiber schedules this effect</span>
            <span class="s0">// as part of its normal complete phase. But when we switch from</span>
            <span class="s0">// primary -&gt; fallback, the inner Offscreen fiber does not have a complete</span>
            <span class="s0">// phase. So we need to schedule its effect here.</span>
            <span class="s0">//</span>
            <span class="s0">// We also use this flag to connect/disconnect the effects, but the same</span>
            <span class="s0">// logic applies: when re-connecting, the Offscreen fiber's complete</span>
            <span class="s0">// phase will handle scheduling the effect. It's only when the fallback</span>
            <span class="s0">// is active that we have to do anything special.</span>


            <span class="s2">if </span><span class="s1">(nextDidTimeout) {</span>
              <span class="s2">var </span><span class="s1">_offscreenFiber2 = workInProgress.child;</span>
              <span class="s1">_offscreenFiber2.flags |= Visibility; </span><span class="s0">// TODO: This will still suspend a synchronous tree if anything</span>
              <span class="s0">// in the concurrent tree already suspended during this render.</span>
              <span class="s0">// This is a known bug.</span>

              <span class="s2">if </span><span class="s1">((workInProgress.mode &amp; ConcurrentMode) !== NoMode) {</span>
                <span class="s0">// TODO: Move this back to throwException because this is too late</span>
                <span class="s0">// if this is a large tree which is common for initial loads. We</span>
                <span class="s0">// don't know if we should restart a render or not until we get</span>
                <span class="s0">// this marker, and this is too late.</span>
                <span class="s0">// If this render already had a ping or lower pri updates,</span>
                <span class="s0">// and this is the first time we know we're going to suspend we</span>
                <span class="s0">// should be able to immediately restart from within throwException.</span>
                <span class="s2">var </span><span class="s1">hasInvisibleChildContext = current === </span><span class="s2">null </span><span class="s1">&amp;&amp; (workInProgress.memoizedProps.unstable_avoidThisFallback !== </span><span class="s2">true </span><span class="s1">|| !enableSuspenseAvoidThisFallback);</span>

                <span class="s2">if </span><span class="s1">(hasInvisibleChildContext || hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext)) {</span>
                  <span class="s0">// If this was in an invisible tree or a new render, then showing</span>
                  <span class="s0">// this boundary is ok.</span>
                  <span class="s1">renderDidSuspend();</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                  <span class="s0">// Otherwise, we're going to have to hide content so we should</span>
                  <span class="s0">// suspend for longer if possible.</span>
                  <span class="s1">renderDidSuspendDelayIfPossible();</span>
                <span class="s1">}</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s2">var </span><span class="s1">wakeables = workInProgress.updateQueue;</span>

          <span class="s2">if </span><span class="s1">(wakeables !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s0">// Schedule an effect to attach a retry listener to the promise.</span>
            <span class="s0">// TODO: Move to passive phase</span>
            <span class="s1">workInProgress.flags |= Update;</span>
          <span class="s1">}</span>

          <span class="s1">bubbleProperties(workInProgress);</span>

          <span class="s1">{</span>
            <span class="s2">if </span><span class="s1">((workInProgress.mode &amp; ProfileMode) !== NoMode) {</span>
              <span class="s2">if </span><span class="s1">(nextDidTimeout) {</span>
                <span class="s0">// Don't count time spent in a timed out Suspense subtree as part of the base duration.</span>
                <span class="s2">var </span><span class="s1">primaryChildFragment = workInProgress.child;</span>

                <span class="s2">if </span><span class="s1">(primaryChildFragment !== </span><span class="s2">null</span><span class="s1">) {</span>
                  <span class="s0">// $FlowFixMe Flow doesn't support type casting in combination with the -= operator</span>
                  <span class="s1">workInProgress.treeBaseDuration -= primaryChildFragment.treeBaseDuration;</span>
                <span class="s1">}</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s2">return null</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s2">case </span><span class="s1">HostPortal:</span>
        <span class="s1">popHostContainer(workInProgress);</span>
        <span class="s1">updateHostContainer(current, workInProgress);</span>

        <span class="s2">if </span><span class="s1">(current === </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">preparePortalMount(workInProgress.stateNode.containerInfo);</span>
        <span class="s1">}</span>

        <span class="s1">bubbleProperties(workInProgress);</span>
        <span class="s2">return null</span><span class="s1">;</span>

      <span class="s2">case </span><span class="s1">ContextProvider:</span>
        <span class="s0">// Pop provider fiber</span>
        <span class="s2">var </span><span class="s1">context = workInProgress.type._context;</span>
        <span class="s1">popProvider(context, workInProgress);</span>
        <span class="s1">bubbleProperties(workInProgress);</span>
        <span class="s2">return null</span><span class="s1">;</span>

      <span class="s2">case </span><span class="s1">IncompleteClassComponent:</span>
        <span class="s1">{</span>
          <span class="s0">// Same as class component case. I put it down here so that the tags are</span>
          <span class="s0">// sequential to ensure this switch is compiled to a jump table.</span>
          <span class="s2">var </span><span class="s1">_Component = workInProgress.type;</span>

          <span class="s2">if </span><span class="s1">(isContextProvider(_Component)) {</span>
            <span class="s1">popContext(workInProgress);</span>
          <span class="s1">}</span>

          <span class="s1">bubbleProperties(workInProgress);</span>
          <span class="s2">return null</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s2">case </span><span class="s1">SuspenseListComponent:</span>
        <span class="s1">{</span>
          <span class="s1">popSuspenseContext(workInProgress);</span>
          <span class="s2">var </span><span class="s1">renderState = workInProgress.memoizedState;</span>

          <span class="s2">if </span><span class="s1">(renderState === </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s0">// We're running in the default, &quot;independent&quot; mode.</span>
            <span class="s0">// We don't do anything in this mode.</span>
            <span class="s1">bubbleProperties(workInProgress);</span>
            <span class="s2">return null</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s2">var </span><span class="s1">didSuspendAlready = (workInProgress.flags &amp; DidCapture) !== NoFlags;</span>
          <span class="s2">var </span><span class="s1">renderedTail = renderState.rendering;</span>

          <span class="s2">if </span><span class="s1">(renderedTail === </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s0">// We just rendered the head.</span>
            <span class="s2">if </span><span class="s1">(!didSuspendAlready) {</span>
              <span class="s0">// This is the first pass. We need to figure out if anything is still</span>
              <span class="s0">// suspended in the rendered set.</span>
              <span class="s0">// If new content unsuspended, but there's still some content that</span>
              <span class="s0">// didn't. Then we need to do a second pass that forces everything</span>
              <span class="s0">// to keep showing their fallbacks.</span>
              <span class="s0">// We might be suspended if something in this render pass suspended, or</span>
              <span class="s0">// something in the previous committed pass suspended. Otherwise,</span>
              <span class="s0">// there's no chance so we can skip the expensive call to</span>
              <span class="s0">// findFirstSuspended.</span>
              <span class="s2">var </span><span class="s1">cannotBeSuspended = renderHasNotSuspendedYet() &amp;&amp; (current === </span><span class="s2">null </span><span class="s1">|| (current.flags &amp; DidCapture) === NoFlags);</span>

              <span class="s2">if </span><span class="s1">(!cannotBeSuspended) {</span>
                <span class="s2">var </span><span class="s1">row = workInProgress.child;</span>

                <span class="s2">while </span><span class="s1">(row !== </span><span class="s2">null</span><span class="s1">) {</span>
                  <span class="s2">var </span><span class="s1">suspended = findFirstSuspended(row);</span>

                  <span class="s2">if </span><span class="s1">(suspended !== </span><span class="s2">null</span><span class="s1">) {</span>
                    <span class="s1">didSuspendAlready = </span><span class="s2">true</span><span class="s1">;</span>
                    <span class="s1">workInProgress.flags |= DidCapture;</span>
                    <span class="s1">cutOffTailIfNeeded(renderState, </span><span class="s2">false</span><span class="s1">); </span><span class="s0">// If this is a newly suspended tree, it might not get committed as</span>
                    <span class="s0">// part of the second pass. In that case nothing will subscribe to</span>
                    <span class="s0">// its thenables. Instead, we'll transfer its thenables to the</span>
                    <span class="s0">// SuspenseList so that it can retry if they resolve.</span>
                    <span class="s0">// There might be multiple of these in the list but since we're</span>
                    <span class="s0">// going to wait for all of them anyway, it doesn't really matter</span>
                    <span class="s0">// which ones gets to ping. In theory we could get clever and keep</span>
                    <span class="s0">// track of how many dependencies remain but it gets tricky because</span>
                    <span class="s0">// in the meantime, we can add/remove/change items and dependencies.</span>
                    <span class="s0">// We might bail out of the loop before finding any but that</span>
                    <span class="s0">// doesn't matter since that means that the other boundaries that</span>
                    <span class="s0">// we did find already has their listeners attached.</span>

                    <span class="s2">var </span><span class="s1">newThenables = suspended.updateQueue;</span>

                    <span class="s2">if </span><span class="s1">(newThenables !== </span><span class="s2">null</span><span class="s1">) {</span>
                      <span class="s1">workInProgress.updateQueue = newThenables;</span>
                      <span class="s1">workInProgress.flags |= Update;</span>
                    <span class="s1">} </span><span class="s0">// Rerender the whole list, but this time, we'll force fallbacks</span>
                    <span class="s0">// to stay in place.</span>
                    <span class="s0">// Reset the effect flags before doing the second pass since that's now invalid.</span>
                    <span class="s0">// Reset the child fibers to their original state.</span>


                    <span class="s1">workInProgress.subtreeFlags = NoFlags;</span>
                    <span class="s1">resetChildFibers(workInProgress, renderLanes); </span><span class="s0">// Set up the Suspense Context to force suspense and immediately</span>
                    <span class="s0">// rerender the children.</span>

                    <span class="s1">pushSuspenseContext(workInProgress, setShallowSuspenseContext(suspenseStackCursor.current, ForceSuspenseFallback)); </span><span class="s0">// Don't bubble properties in this case.</span>

                    <span class="s2">return </span><span class="s1">workInProgress.child;</span>
                  <span class="s1">}</span>

                  <span class="s1">row = row.sibling;</span>
                <span class="s1">}</span>
              <span class="s1">}</span>

              <span class="s2">if </span><span class="s1">(renderState.tail !== </span><span class="s2">null </span><span class="s1">&amp;&amp; now() &gt; getRenderTargetTime()) {</span>
                <span class="s0">// We have already passed our CPU deadline but we still have rows</span>
                <span class="s0">// left in the tail. We'll just give up further attempts to render</span>
                <span class="s0">// the main content and only render fallbacks.</span>
                <span class="s1">workInProgress.flags |= DidCapture;</span>
                <span class="s1">didSuspendAlready = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s1">cutOffTailIfNeeded(renderState, </span><span class="s2">false</span><span class="s1">); </span><span class="s0">// Since nothing actually suspended, there will nothing to ping this</span>
                <span class="s0">// to get it started back up to attempt the next item. While in terms</span>
                <span class="s0">// of priority this work has the same priority as this current render,</span>
                <span class="s0">// it's not part of the same transition once the transition has</span>
                <span class="s0">// committed. If it's sync, we still want to yield so that it can be</span>
                <span class="s0">// painted. Conceptually, this is really the same as pinging.</span>
                <span class="s0">// We can use any RetryLane even if it's the one currently rendering</span>
                <span class="s0">// since we're leaving it behind on this node.</span>

                <span class="s1">workInProgress.lanes = SomeRetryLane;</span>
              <span class="s1">}</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
              <span class="s1">cutOffTailIfNeeded(renderState, </span><span class="s2">false</span><span class="s1">);</span>
            <span class="s1">} </span><span class="s0">// Next we're going to render the tail.</span>

          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s0">// Append the rendered row to the child list.</span>
            <span class="s2">if </span><span class="s1">(!didSuspendAlready) {</span>
              <span class="s2">var </span><span class="s1">_suspended = findFirstSuspended(renderedTail);</span>

              <span class="s2">if </span><span class="s1">(_suspended !== </span><span class="s2">null</span><span class="s1">) {</span>
                <span class="s1">workInProgress.flags |= DidCapture;</span>
                <span class="s1">didSuspendAlready = </span><span class="s2">true</span><span class="s1">; </span><span class="s0">// Ensure we transfer the update queue to the parent so that it doesn't</span>
                <span class="s0">// get lost if this row ends up dropped during a second pass.</span>

                <span class="s2">var </span><span class="s1">_newThenables = _suspended.updateQueue;</span>

                <span class="s2">if </span><span class="s1">(_newThenables !== </span><span class="s2">null</span><span class="s1">) {</span>
                  <span class="s1">workInProgress.updateQueue = _newThenables;</span>
                  <span class="s1">workInProgress.flags |= Update;</span>
                <span class="s1">}</span>

                <span class="s1">cutOffTailIfNeeded(renderState, </span><span class="s2">true</span><span class="s1">); </span><span class="s0">// This might have been modified.</span>

                <span class="s2">if </span><span class="s1">(renderState.tail === </span><span class="s2">null </span><span class="s1">&amp;&amp; renderState.tailMode === </span><span class="s3">'hidden' </span><span class="s1">&amp;&amp; !renderedTail.alternate &amp;&amp; !getIsHydrating() </span><span class="s0">// We don't cut it if we're hydrating.</span>
                <span class="s1">) {</span>
                    <span class="s0">// We're done.</span>
                    <span class="s1">bubbleProperties(workInProgress);</span>
                    <span class="s2">return null</span><span class="s1">;</span>
                  <span class="s1">}</span>
              <span class="s1">} </span><span class="s2">else if </span><span class="s1">( </span><span class="s0">// The time it took to render last row is greater than the remaining</span>
              <span class="s0">// time we have to render. So rendering one more row would likely</span>
              <span class="s0">// exceed it.</span>
              <span class="s1">now() * </span><span class="s4">2 </span><span class="s1">- renderState.renderingStartTime &gt; getRenderTargetTime() &amp;&amp; renderLanes !== OffscreenLane) {</span>
                <span class="s0">// We have now passed our CPU deadline and we'll just give up further</span>
                <span class="s0">// attempts to render the main content and only render fallbacks.</span>
                <span class="s0">// The assumption is that this is usually faster.</span>
                <span class="s1">workInProgress.flags |= DidCapture;</span>
                <span class="s1">didSuspendAlready = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s1">cutOffTailIfNeeded(renderState, </span><span class="s2">false</span><span class="s1">); </span><span class="s0">// Since nothing actually suspended, there will nothing to ping this</span>
                <span class="s0">// to get it started back up to attempt the next item. While in terms</span>
                <span class="s0">// of priority this work has the same priority as this current render,</span>
                <span class="s0">// it's not part of the same transition once the transition has</span>
                <span class="s0">// committed. If it's sync, we still want to yield so that it can be</span>
                <span class="s0">// painted. Conceptually, this is really the same as pinging.</span>
                <span class="s0">// We can use any RetryLane even if it's the one currently rendering</span>
                <span class="s0">// since we're leaving it behind on this node.</span>

                <span class="s1">workInProgress.lanes = SomeRetryLane;</span>
              <span class="s1">}</span>
            <span class="s1">}</span>

            <span class="s2">if </span><span class="s1">(renderState.isBackwards) {</span>
              <span class="s0">// The effect list of the backwards tail will have been added</span>
              <span class="s0">// to the end. This breaks the guarantee that life-cycles fire in</span>
              <span class="s0">// sibling order but that isn't a strong guarantee promised by React.</span>
              <span class="s0">// Especially since these might also just pop in during future commits.</span>
              <span class="s0">// Append to the beginning of the list.</span>
              <span class="s1">renderedTail.sibling = workInProgress.child;</span>
              <span class="s1">workInProgress.child = renderedTail;</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
              <span class="s2">var </span><span class="s1">previousSibling = renderState.last;</span>

              <span class="s2">if </span><span class="s1">(previousSibling !== </span><span class="s2">null</span><span class="s1">) {</span>
                <span class="s1">previousSibling.sibling = renderedTail;</span>
              <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">workInProgress.child = renderedTail;</span>
              <span class="s1">}</span>

              <span class="s1">renderState.last = renderedTail;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s2">if </span><span class="s1">(renderState.tail !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s0">// We still have tail rows to render.</span>
            <span class="s0">// Pop a row.</span>
            <span class="s2">var </span><span class="s1">next = renderState.tail;</span>
            <span class="s1">renderState.rendering = next;</span>
            <span class="s1">renderState.tail = next.sibling;</span>
            <span class="s1">renderState.renderingStartTime = now();</span>
            <span class="s1">next.sibling = </span><span class="s2">null</span><span class="s1">; </span><span class="s0">// Restore the context.</span>
            <span class="s0">// TODO: We can probably just avoid popping it instead and only</span>
            <span class="s0">// setting it the first time we go from not suspended to suspended.</span>

            <span class="s2">var </span><span class="s1">suspenseContext = suspenseStackCursor.current;</span>

            <span class="s2">if </span><span class="s1">(didSuspendAlready) {</span>
              <span class="s1">suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
              <span class="s1">suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);</span>
            <span class="s1">}</span>

            <span class="s1">pushSuspenseContext(workInProgress, suspenseContext); </span><span class="s0">// Do a pass over the next row.</span>
            <span class="s0">// Don't bubble properties in this case.</span>

            <span class="s2">return </span><span class="s1">next;</span>
          <span class="s1">}</span>

          <span class="s1">bubbleProperties(workInProgress);</span>
          <span class="s2">return null</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s2">case </span><span class="s1">ScopeComponent:</span>
        <span class="s1">{</span>

          <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s2">case </span><span class="s1">OffscreenComponent:</span>
      <span class="s2">case </span><span class="s1">LegacyHiddenComponent:</span>
        <span class="s1">{</span>
          <span class="s1">popRenderLanes(workInProgress);</span>
          <span class="s2">var </span><span class="s1">_nextState = workInProgress.memoizedState;</span>
          <span class="s2">var </span><span class="s1">nextIsHidden = _nextState !== </span><span class="s2">null</span><span class="s1">;</span>

          <span class="s2">if </span><span class="s1">(current !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">var </span><span class="s1">_prevState = current.memoizedState;</span>
            <span class="s2">var </span><span class="s1">prevIsHidden = _prevState !== </span><span class="s2">null</span><span class="s1">;</span>

            <span class="s2">if </span><span class="s1">(prevIsHidden !== nextIsHidden &amp;&amp; ( </span><span class="s0">// LegacyHidden doesn't do any hiding  it only pre-renders.</span>
            <span class="s1">!enableLegacyHidden )) {</span>
              <span class="s1">workInProgress.flags |= Visibility;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s2">if </span><span class="s1">(!nextIsHidden || (workInProgress.mode &amp; ConcurrentMode) === NoMode) {</span>
            <span class="s1">bubbleProperties(workInProgress);</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s0">// Don't bubble properties for hidden children unless we're rendering</span>
            <span class="s0">// at offscreen priority.</span>
            <span class="s2">if </span><span class="s1">(includesSomeLane(subtreeRenderLanes, OffscreenLane)) {</span>
              <span class="s1">bubbleProperties(workInProgress);</span>

              <span class="s1">{</span>
                <span class="s0">// Check if there was an insertion or update in the hidden subtree.</span>
                <span class="s0">// If so, we need to hide those nodes in the commit phase, so</span>
                <span class="s0">// schedule a visibility effect.</span>
                <span class="s2">if </span><span class="s1">( workInProgress.subtreeFlags &amp; (Placement | Update)) {</span>
                  <span class="s1">workInProgress.flags |= Visibility;</span>
                <span class="s1">}</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
          <span class="s2">return null</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s2">case </span><span class="s1">CacheComponent:</span>
        <span class="s1">{</span>

          <span class="s2">return null</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s2">case </span><span class="s1">TracingMarkerComponent:</span>
        <span class="s1">{</span>

          <span class="s2">return null</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">&quot;Unknown unit of work tag (&quot; </span><span class="s1">+ workInProgress.tag + </span><span class="s3">&quot;). This error is likely caused by a bug in &quot; </span><span class="s1">+ </span><span class="s3">'React. Please file an issue.'</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">unwindWork(current, workInProgress, renderLanes) {</span>
    <span class="s0">// Note: This intentionally doesn't check if we're hydrating because comparing</span>
    <span class="s0">// to the current tree provider fiber is just as fast and less error-prone.</span>
    <span class="s0">// Ideally we would have a special version of the work loop only</span>
    <span class="s0">// for hydration.</span>
    <span class="s1">popTreeContext(workInProgress);</span>

    <span class="s2">switch </span><span class="s1">(workInProgress.tag) {</span>
      <span class="s2">case </span><span class="s1">ClassComponent:</span>
        <span class="s1">{</span>
          <span class="s2">var </span><span class="s1">Component = workInProgress.type;</span>

          <span class="s2">if </span><span class="s1">(isContextProvider(Component)) {</span>
            <span class="s1">popContext(workInProgress);</span>
          <span class="s1">}</span>

          <span class="s2">var </span><span class="s1">flags = workInProgress.flags;</span>

          <span class="s2">if </span><span class="s1">(flags &amp; ShouldCapture) {</span>
            <span class="s1">workInProgress.flags = flags &amp; ~ShouldCapture | DidCapture;</span>

            <span class="s2">if </span><span class="s1">( (workInProgress.mode &amp; ProfileMode) !== NoMode) {</span>
              <span class="s1">transferActualDuration(workInProgress);</span>
            <span class="s1">}</span>

            <span class="s2">return </span><span class="s1">workInProgress;</span>
          <span class="s1">}</span>

          <span class="s2">return null</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s2">case </span><span class="s1">HostRoot:</span>
        <span class="s1">{</span>
          <span class="s2">var </span><span class="s1">root = workInProgress.stateNode;</span>
          <span class="s1">popHostContainer(workInProgress);</span>
          <span class="s1">popTopLevelContextObject(workInProgress);</span>
          <span class="s1">resetWorkInProgressVersions();</span>
          <span class="s2">var </span><span class="s1">_flags = workInProgress.flags;</span>

          <span class="s2">if </span><span class="s1">((_flags &amp; ShouldCapture) !== NoFlags &amp;&amp; (_flags &amp; DidCapture) === NoFlags) {</span>
            <span class="s0">// There was an error during render that wasn't captured by a suspense</span>
            <span class="s0">// boundary. Do a second pass on the root to unmount the children.</span>
            <span class="s1">workInProgress.flags = _flags &amp; ~ShouldCapture | DidCapture;</span>
            <span class="s2">return </span><span class="s1">workInProgress;</span>
          <span class="s1">} </span><span class="s0">// We unwound to the root without completing it. Exit.</span>


          <span class="s2">return null</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s2">case </span><span class="s1">HostComponent:</span>
        <span class="s1">{</span>
          <span class="s0">// TODO: popHydrationState</span>
          <span class="s1">popHostContext(workInProgress);</span>
          <span class="s2">return null</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s2">case </span><span class="s1">SuspenseComponent:</span>
        <span class="s1">{</span>
          <span class="s1">popSuspenseContext(workInProgress);</span>
          <span class="s2">var </span><span class="s1">suspenseState = workInProgress.memoizedState;</span>

          <span class="s2">if </span><span class="s1">(suspenseState !== </span><span class="s2">null </span><span class="s1">&amp;&amp; suspenseState.dehydrated !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(workInProgress.alternate === </span><span class="s2">null</span><span class="s1">) {</span>
              <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Threw in newly mounted dehydrated component. This is likely a bug in ' </span><span class="s1">+ </span><span class="s3">'React. Please file an issue.'</span><span class="s1">);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s2">var </span><span class="s1">_flags2 = workInProgress.flags;</span>

          <span class="s2">if </span><span class="s1">(_flags2 &amp; ShouldCapture) {</span>
            <span class="s1">workInProgress.flags = _flags2 &amp; ~ShouldCapture | DidCapture; </span><span class="s0">// Captured a suspense effect. Re-render the boundary.</span>

            <span class="s2">if </span><span class="s1">( (workInProgress.mode &amp; ProfileMode) !== NoMode) {</span>
              <span class="s1">transferActualDuration(workInProgress);</span>
            <span class="s1">}</span>

            <span class="s2">return </span><span class="s1">workInProgress;</span>
          <span class="s1">}</span>

          <span class="s2">return null</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s2">case </span><span class="s1">SuspenseListComponent:</span>
        <span class="s1">{</span>
          <span class="s1">popSuspenseContext(workInProgress); </span><span class="s0">// SuspenseList doesn't actually catch anything. It should've been</span>
          <span class="s0">// caught by a nested boundary. If not, it should bubble through.</span>

          <span class="s2">return null</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s2">case </span><span class="s1">HostPortal:</span>
        <span class="s1">popHostContainer(workInProgress);</span>
        <span class="s2">return null</span><span class="s1">;</span>

      <span class="s2">case </span><span class="s1">ContextProvider:</span>
        <span class="s2">var </span><span class="s1">context = workInProgress.type._context;</span>
        <span class="s1">popProvider(context, workInProgress);</span>
        <span class="s2">return null</span><span class="s1">;</span>

      <span class="s2">case </span><span class="s1">OffscreenComponent:</span>
      <span class="s2">case </span><span class="s1">LegacyHiddenComponent:</span>
        <span class="s1">popRenderLanes(workInProgress);</span>
        <span class="s2">return null</span><span class="s1">;</span>

      <span class="s2">case </span><span class="s1">CacheComponent:</span>

        <span class="s2">return null</span><span class="s1">;</span>

      <span class="s2">default</span><span class="s1">:</span>
        <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">unwindInterruptedWork(current, interruptedWork, renderLanes) {</span>
    <span class="s0">// Note: This intentionally doesn't check if we're hydrating because comparing</span>
    <span class="s0">// to the current tree provider fiber is just as fast and less error-prone.</span>
    <span class="s0">// Ideally we would have a special version of the work loop only</span>
    <span class="s0">// for hydration.</span>
    <span class="s1">popTreeContext(interruptedWork);</span>

    <span class="s2">switch </span><span class="s1">(interruptedWork.tag) {</span>
      <span class="s2">case </span><span class="s1">ClassComponent:</span>
        <span class="s1">{</span>
          <span class="s2">var </span><span class="s1">childContextTypes = interruptedWork.type.childContextTypes;</span>

          <span class="s2">if </span><span class="s1">(childContextTypes !== </span><span class="s2">null </span><span class="s1">&amp;&amp; childContextTypes !== undefined) {</span>
            <span class="s1">popContext(interruptedWork);</span>
          <span class="s1">}</span>

          <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s2">case </span><span class="s1">HostRoot:</span>
        <span class="s1">{</span>
          <span class="s2">var </span><span class="s1">root = interruptedWork.stateNode;</span>
          <span class="s1">popHostContainer(interruptedWork);</span>
          <span class="s1">popTopLevelContextObject(interruptedWork);</span>
          <span class="s1">resetWorkInProgressVersions();</span>
          <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s2">case </span><span class="s1">HostComponent:</span>
        <span class="s1">{</span>
          <span class="s1">popHostContext(interruptedWork);</span>
          <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s2">case </span><span class="s1">HostPortal:</span>
        <span class="s1">popHostContainer(interruptedWork);</span>
        <span class="s2">break</span><span class="s1">;</span>

      <span class="s2">case </span><span class="s1">SuspenseComponent:</span>
        <span class="s1">popSuspenseContext(interruptedWork);</span>
        <span class="s2">break</span><span class="s1">;</span>

      <span class="s2">case </span><span class="s1">SuspenseListComponent:</span>
        <span class="s1">popSuspenseContext(interruptedWork);</span>
        <span class="s2">break</span><span class="s1">;</span>

      <span class="s2">case </span><span class="s1">ContextProvider:</span>
        <span class="s2">var </span><span class="s1">context = interruptedWork.type._context;</span>
        <span class="s1">popProvider(context, interruptedWork);</span>
        <span class="s2">break</span><span class="s1">;</span>

      <span class="s2">case </span><span class="s1">OffscreenComponent:</span>
      <span class="s2">case </span><span class="s1">LegacyHiddenComponent:</span>
        <span class="s1">popRenderLanes(interruptedWork);</span>
        <span class="s2">break</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">invokeGuardedCallbackProd(name, func, context, a, b, c, d, e, f) {</span>
    <span class="s2">var </span><span class="s1">funcArgs = Array.prototype.slice.call(arguments, </span><span class="s4">3</span><span class="s1">);</span>

    <span class="s2">try </span><span class="s1">{</span>
      <span class="s1">func.apply(context, funcArgs);</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(error) {</span>
      <span class="s2">this</span><span class="s1">.onError(error);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">invokeGuardedCallbackImpl = invokeGuardedCallbackProd;</span>

  <span class="s1">{</span>
    <span class="s0">// In DEV mode, we swap out invokeGuardedCallback for a special version</span>
    <span class="s0">// that plays more nicely with the browser's DevTools. The idea is to preserve</span>
    <span class="s0">// &quot;Pause on exceptions&quot; behavior. Because React wraps all user-provided</span>
    <span class="s0">// functions in invokeGuardedCallback, and the production version of</span>
    <span class="s0">// invokeGuardedCallback uses a try-catch, all user exceptions are treated</span>
    <span class="s0">// like caught exceptions, and the DevTools won't pause unless the developer</span>
    <span class="s0">// takes the extra step of enabling pause on caught exceptions. This is</span>
    <span class="s0">// unintuitive, though, because even though React has caught the error, from</span>
    <span class="s0">// the developer's perspective, the error is uncaught.</span>
    <span class="s0">//</span>
    <span class="s0">// To preserve the expected &quot;Pause on exceptions&quot; behavior, we don't use a</span>
    <span class="s0">// try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake</span>
    <span class="s0">// DOM node, and call the user-provided callback from inside an event handler</span>
    <span class="s0">// for that fake event. If the callback throws, the error is &quot;captured&quot; using</span>
    <span class="s0">// a global event handler. But because the error happens in a different</span>
    <span class="s0">// event loop context, it does not interrupt the normal program flow.</span>
    <span class="s0">// Effectively, this gives us try-catch behavior without actually using</span>
    <span class="s0">// try-catch. Neat!</span>
    <span class="s0">// Check that the browser supports the APIs we need to implement our special</span>
    <span class="s0">// DEV version of invokeGuardedCallback</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">window !== </span><span class="s3">'undefined' </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">window.dispatchEvent === </span><span class="s3">'function' </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">document !== </span><span class="s3">'undefined' </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">document.createEvent === </span><span class="s3">'function'</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">fakeNode = document.createElement(</span><span class="s3">'react'</span><span class="s1">);</span>

      <span class="s1">invokeGuardedCallbackImpl = </span><span class="s2">function </span><span class="s1">invokeGuardedCallbackDev(name, func, context, a, b, c, d, e, f) {</span>
        <span class="s0">// If document doesn't exist we know for sure we will crash in this method</span>
        <span class="s0">// when we call document.createEvent(). However this can cause confusing</span>
        <span class="s0">// errors: https://github.com/facebook/create-react-app/issues/3482</span>
        <span class="s0">// So we preemptively throw with a better message instead.</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">document === </span><span class="s3">'undefined' </span><span class="s1">|| document === </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'The `document` global was defined when React was initialized, but is not ' </span><span class="s1">+ </span><span class="s3">'defined anymore. This can happen in a test environment if a component ' </span><span class="s1">+ </span><span class="s3">'schedules an update from an asynchronous callback, but the test has already ' </span><span class="s1">+ </span><span class="s3">'finished running. To solve this, you can either unmount the component at ' </span><span class="s1">+ </span><span class="s3">'the end of your test (and ensure that any asynchronous operations get ' </span><span class="s1">+ </span><span class="s3">'canceled in `componentWillUnmount`), or you can change the test itself ' </span><span class="s1">+ </span><span class="s3">'to be asynchronous.'</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s2">var </span><span class="s1">evt = document.createEvent(</span><span class="s3">'Event'</span><span class="s1">);</span>
        <span class="s2">var </span><span class="s1">didCall = </span><span class="s2">false</span><span class="s1">; </span><span class="s0">// Keeps track of whether the user-provided callback threw an error. We</span>
        <span class="s0">// set this to true at the beginning, then set it to false right after</span>
        <span class="s0">// calling the function. If the function errors, `didError` will never be</span>
        <span class="s0">// set to false. This strategy works even if the browser is flaky and</span>
        <span class="s0">// fails to call our global error handler, because it doesn't rely on</span>
        <span class="s0">// the error event at all.</span>

        <span class="s2">var </span><span class="s1">didError = </span><span class="s2">true</span><span class="s1">; </span><span class="s0">// Keeps track of the value of window.event so that we can reset it</span>
        <span class="s0">// during the callback to let user code access window.event in the</span>
        <span class="s0">// browsers that support it.</span>

        <span class="s2">var </span><span class="s1">windowEvent = window.event; </span><span class="s0">// Keeps track of the descriptor of window.event to restore it after event</span>
        <span class="s0">// dispatching: https://github.com/facebook/react/issues/13688</span>

        <span class="s2">var </span><span class="s1">windowEventDescriptor = Object.getOwnPropertyDescriptor(window, </span><span class="s3">'event'</span><span class="s1">);</span>

        <span class="s2">function </span><span class="s1">restoreAfterDispatch() {</span>
          <span class="s0">// We immediately remove the callback from event listeners so that</span>
          <span class="s0">// nested `invokeGuardedCallback` calls do not clash. Otherwise, a</span>
          <span class="s0">// nested call would trigger the fake event handlers of any call higher</span>
          <span class="s0">// in the stack.</span>
          <span class="s1">fakeNode.removeEventListener(evtType, callCallback, </span><span class="s2">false</span><span class="s1">); </span><span class="s0">// We check for window.hasOwnProperty('event') to prevent the</span>
          <span class="s0">// window.event assignment in both IE &lt;= 10 as they throw an error</span>
          <span class="s0">// &quot;Member not found&quot; in strict mode, and in Firefox which does not</span>
          <span class="s0">// support window.event.</span>

          <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">window.event !== </span><span class="s3">'undefined' </span><span class="s1">&amp;&amp; window.hasOwnProperty(</span><span class="s3">'event'</span><span class="s1">)) {</span>
            <span class="s1">window.event = windowEvent;</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s0">// Create an event handler for our fake event. We will synchronously</span>
        <span class="s0">// dispatch our fake event using `dispatchEvent`. Inside the handler, we</span>
        <span class="s0">// call the user-provided callback.</span>


        <span class="s2">var </span><span class="s1">funcArgs = Array.prototype.slice.call(arguments, </span><span class="s4">3</span><span class="s1">);</span>

        <span class="s2">function </span><span class="s1">callCallback() {</span>
          <span class="s1">didCall = </span><span class="s2">true</span><span class="s1">;</span>
          <span class="s1">restoreAfterDispatch();</span>
          <span class="s1">func.apply(context, funcArgs);</span>
          <span class="s1">didError = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s0">// Create a global error event handler. We use this to capture the value</span>
        <span class="s0">// that was thrown. It's possible that this error handler will fire more</span>
        <span class="s0">// than once; for example, if non-React code also calls `dispatchEvent`</span>
        <span class="s0">// and a handler for that event throws. We should be resilient to most of</span>
        <span class="s0">// those cases. Even if our error event handler fires more than once, the</span>
        <span class="s0">// last error event is always used. If the callback actually does error,</span>
        <span class="s0">// we know that the last error event is the correct one, because it's not</span>
        <span class="s0">// possible for anything else to have happened in between our callback</span>
        <span class="s0">// erroring and the code that follows the `dispatchEvent` call below. If</span>
        <span class="s0">// the callback doesn't error, but the error event was fired, we know to</span>
        <span class="s0">// ignore it because `didError` will be false, as described above.</span>


        <span class="s2">var </span><span class="s1">error; </span><span class="s0">// Use this to track whether the error event is ever called.</span>

        <span class="s2">var </span><span class="s1">didSetError = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s2">var </span><span class="s1">isCrossOriginError = </span><span class="s2">false</span><span class="s1">;</span>

        <span class="s2">function </span><span class="s1">handleWindowError(event) {</span>
          <span class="s1">error = event.error;</span>
          <span class="s1">didSetError = </span><span class="s2">true</span><span class="s1">;</span>

          <span class="s2">if </span><span class="s1">(error === </span><span class="s2">null </span><span class="s1">&amp;&amp; event.colno === </span><span class="s4">0 </span><span class="s1">&amp;&amp; event.lineno === </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s1">isCrossOriginError = </span><span class="s2">true</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s2">if </span><span class="s1">(event.defaultPrevented) {</span>
            <span class="s0">// Some other error handler has prevented default.</span>
            <span class="s0">// Browsers silence the error report if this happens.</span>
            <span class="s0">// We'll remember this to later decide whether to log it or not.</span>
            <span class="s2">if </span><span class="s1">(error != </span><span class="s2">null </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">error === </span><span class="s3">'object'</span><span class="s1">) {</span>
              <span class="s2">try </span><span class="s1">{</span>
                <span class="s1">error._suppressLogging = </span><span class="s2">true</span><span class="s1">;</span>
              <span class="s1">} </span><span class="s2">catch </span><span class="s1">(inner) {</span><span class="s0">// Ignore.</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s0">// Create a fake event type.</span>


        <span class="s2">var </span><span class="s1">evtType = </span><span class="s3">&quot;react-&quot; </span><span class="s1">+ (name ? name : </span><span class="s3">'invokeguardedcallback'</span><span class="s1">); </span><span class="s0">// Attach our event handlers</span>

        <span class="s1">window.addEventListener(</span><span class="s3">'error'</span><span class="s1">, handleWindowError);</span>
        <span class="s1">fakeNode.addEventListener(evtType, callCallback, </span><span class="s2">false</span><span class="s1">); </span><span class="s0">// Synchronously dispatch our fake event. If the user-provided function</span>
        <span class="s0">// errors, it will trigger our global error handler.</span>

        <span class="s1">evt.initEvent(evtType, </span><span class="s2">false</span><span class="s1">, </span><span class="s2">false</span><span class="s1">);</span>
        <span class="s1">fakeNode.dispatchEvent(evt);</span>

        <span class="s2">if </span><span class="s1">(windowEventDescriptor) {</span>
          <span class="s1">Object.defineProperty(window, </span><span class="s3">'event'</span><span class="s1">, windowEventDescriptor);</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(didCall &amp;&amp; didError) {</span>
          <span class="s2">if </span><span class="s1">(!didSetError) {</span>
            <span class="s0">// The callback errored, but the error event never fired.</span>
            <span class="s0">// eslint-disable-next-line react-internal/prod-error-codes</span>
            <span class="s1">error = </span><span class="s2">new </span><span class="s1">Error(</span><span class="s3">'An error was thrown inside one of your components, but React ' </span><span class="s1">+ </span><span class="s3">&quot;doesn't know what it was. This is likely due to browser &quot; </span><span class="s1">+ </span><span class="s3">'flakiness. React does its best to preserve the &quot;Pause on ' </span><span class="s1">+ </span><span class="s3">'exceptions&quot; behavior of the DevTools, which requires some ' </span><span class="s1">+ </span><span class="s3">&quot;DEV-mode only tricks. It's possible that these don't work in &quot; </span><span class="s1">+ </span><span class="s3">'your browser. Try triggering the error in production mode, ' </span><span class="s1">+ </span><span class="s3">'or switching to a modern browser. If you suspect that this is ' </span><span class="s1">+ </span><span class="s3">'actually an issue with React, please file an issue.'</span><span class="s1">);</span>
          <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isCrossOriginError) {</span>
            <span class="s0">// eslint-disable-next-line react-internal/prod-error-codes</span>
            <span class="s1">error = </span><span class="s2">new </span><span class="s1">Error(</span><span class="s3">&quot;A cross-origin error was thrown. React doesn't have access to &quot; </span><span class="s1">+ </span><span class="s3">'the actual error object in development. ' </span><span class="s1">+ </span><span class="s3">'See https://reactjs.org/link/crossorigin-error for more information.'</span><span class="s1">);</span>
          <span class="s1">}</span>

          <span class="s2">this</span><span class="s1">.onError(error);</span>
        <span class="s1">} </span><span class="s0">// Remove our event listeners</span>


        <span class="s1">window.removeEventListener(</span><span class="s3">'error'</span><span class="s1">, handleWindowError);</span>

        <span class="s2">if </span><span class="s1">(!didCall) {</span>
          <span class="s0">// Something went really wrong, and our event was not dispatched.</span>
          <span class="s0">// https://github.com/facebook/react/issues/16734</span>
          <span class="s0">// https://github.com/facebook/react/issues/16585</span>
          <span class="s0">// Fall back to the production implementation.</span>
          <span class="s1">restoreAfterDispatch();</span>
          <span class="s2">return </span><span class="s1">invokeGuardedCallbackProd.apply(</span><span class="s2">this</span><span class="s1">, arguments);</span>
        <span class="s1">}</span>
      <span class="s1">};</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;</span>

  <span class="s2">var </span><span class="s1">hasError = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">caughtError = </span><span class="s2">null</span><span class="s1">; </span><span class="s0">// Used by event system to capture/rethrow the first error.</span>
  <span class="s2">var </span><span class="s1">reporter = {</span>
    <span class="s1">onError: </span><span class="s2">function </span><span class="s1">(error) {</span>
      <span class="s1">hasError = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s1">caughtError = error;</span>
    <span class="s1">}</span>
  <span class="s1">};</span>
  <span class="s0">/** 
   * Call a function while guarding against errors that happens within it. 
   * Returns an error if it throws, otherwise null. 
   * 
   * In production, this is implemented using a try-catch. The reason we don't 
   * use a try-catch directly is so that we can swap out a different 
   * implementation in DEV mode. 
   * 
   * @param {String} name of the guard to use for logging or debugging 
   * @param {Function} func The function to invoke 
   * @param {*} context The context to use when calling the function 
   * @param {...*} args Arguments for function 
   */</span>

  <span class="s2">function </span><span class="s1">invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {</span>
    <span class="s1">hasError = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">caughtError = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">invokeGuardedCallbackImpl$1.apply(reporter, arguments);</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">clearCaughtError() {</span>
    <span class="s2">if </span><span class="s1">(hasError) {</span>
      <span class="s2">var </span><span class="s1">error = caughtError;</span>
      <span class="s1">hasError = </span><span class="s2">false</span><span class="s1">;</span>
      <span class="s1">caughtError = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s2">return </span><span class="s1">error;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'clearCaughtError was called but no error was captured. This error ' </span><span class="s1">+ </span><span class="s3">'is likely caused by a bug in React. Please file an issue.'</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">didWarnAboutUndefinedSnapshotBeforeUpdate = </span><span class="s2">null</span><span class="s1">;</span>

  <span class="s1">{</span>
    <span class="s1">didWarnAboutUndefinedSnapshotBeforeUpdate = </span><span class="s2">new </span><span class="s1">Set();</span>
  <span class="s1">} </span><span class="s0">// Used during the commit phase to track the state of the Offscreen component stack.</span>
  <span class="s2">var </span><span class="s1">PossiblyWeakSet = </span><span class="s2">typeof </span><span class="s1">WeakSet === </span><span class="s3">'function' </span><span class="s1">? WeakSet : Set;</span>
  <span class="s2">var </span><span class="s1">nextEffect = </span><span class="s2">null</span><span class="s1">; </span><span class="s0">// Used for Profiling builds to track updaters.</span>
  <span class="s2">function </span><span class="s1">reportUncaughtErrorInDEV(error) {</span>
    <span class="s0">// Wrapping each small part of the commit phase into a guarded</span>
    <span class="s0">// callback is a bit too slow (https://github.com/facebook/react/pull/21666).</span>
    <span class="s0">// But we rely on it to surface errors to DEV tools like overlays</span>
    <span class="s0">// (https://github.com/facebook/react/issues/21712).</span>
    <span class="s0">// As a compromise, rethrow only caught errors in a guard.</span>
    <span class="s1">{</span>
      <span class="s1">invokeGuardedCallback(</span><span class="s2">null</span><span class="s1">, </span><span class="s2">function </span><span class="s1">() {</span>
        <span class="s2">throw </span><span class="s1">error;</span>
      <span class="s1">});</span>
      <span class="s1">clearCaughtError();</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">callComponentWillUnmountWithTimer = </span><span class="s2">function </span><span class="s1">(current, instance) {</span>
    <span class="s1">instance.props = current.memoizedProps;</span>
    <span class="s1">instance.state = current.memoizedState;</span>

    <span class="s2">if </span><span class="s1">( current.mode &amp; ProfileMode) {</span>
      <span class="s2">try </span><span class="s1">{</span>
        <span class="s1">startLayoutEffectTimer();</span>
        <span class="s1">instance.componentWillUnmount();</span>
      <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
        <span class="s1">recordLayoutEffectDuration(current);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">instance.componentWillUnmount();</span>
    <span class="s1">}</span>
  <span class="s1">}; </span><span class="s0">// Capture errors so they don't interrupt mounting.</span>


  <span class="s2">function </span><span class="s1">safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {</span>
    <span class="s2">try </span><span class="s1">{</span>
      <span class="s1">callComponentWillUnmountWithTimer(current, instance);</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(error) {</span>
      <span class="s1">captureCommitPhaseError(current, nearestMountedAncestor, error);</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s0">// Capture errors so they don't interrupt mounting.</span>

  <span class="s2">function </span><span class="s1">safelyDetachRef(current, nearestMountedAncestor) {</span>
    <span class="s2">var </span><span class="s1">ref = current.ref;</span>

    <span class="s2">if </span><span class="s1">(ref !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">ref === </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s2">var </span><span class="s1">retVal;</span>

        <span class="s2">try </span><span class="s1">{</span>
          <span class="s2">if </span><span class="s1">(enableProfilerTimer &amp;&amp; enableProfilerCommitHooks &amp;&amp; current.mode &amp; ProfileMode) {</span>
            <span class="s2">try </span><span class="s1">{</span>
              <span class="s1">startLayoutEffectTimer();</span>
              <span class="s1">retVal = ref(</span><span class="s2">null</span><span class="s1">);</span>
            <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
              <span class="s1">recordLayoutEffectDuration(current);</span>
            <span class="s1">}</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">retVal = ref(</span><span class="s2">null</span><span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">catch </span><span class="s1">(error) {</span>
          <span class="s1">captureCommitPhaseError(current, nearestMountedAncestor, error);</span>
        <span class="s1">}</span>

        <span class="s1">{</span>
          <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">retVal === </span><span class="s3">'function'</span><span class="s1">) {</span>
            <span class="s1">error(</span><span class="s3">'Unexpected return value from a callback ref in %s. ' </span><span class="s1">+ </span><span class="s3">'A callback ref should not return a function.'</span><span class="s1">, getComponentNameFromFiber(current));</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">ref.current = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">safelyCallDestroy(current, nearestMountedAncestor, destroy) {</span>
    <span class="s2">try </span><span class="s1">{</span>
      <span class="s1">destroy();</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(error) {</span>
      <span class="s1">captureCommitPhaseError(current, nearestMountedAncestor, error);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">focusedInstanceHandle = </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">shouldFireAfterActiveInstanceBlur = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s2">function </span><span class="s1">commitBeforeMutationEffects(root, firstChild) {</span>
    <span class="s1">focusedInstanceHandle = prepareForCommit(root.containerInfo);</span>
    <span class="s1">nextEffect = firstChild;</span>
    <span class="s1">commitBeforeMutationEffects_begin(); </span><span class="s0">// We no longer need to track the active instance fiber</span>

    <span class="s2">var </span><span class="s1">shouldFire = shouldFireAfterActiveInstanceBlur;</span>
    <span class="s1">shouldFireAfterActiveInstanceBlur = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">focusedInstanceHandle = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">return </span><span class="s1">shouldFire;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">commitBeforeMutationEffects_begin() {</span>
    <span class="s2">while </span><span class="s1">(nextEffect !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">fiber = nextEffect; </span><span class="s0">// This phase is only used for beforeActiveInstanceBlur.</span>

      <span class="s2">var </span><span class="s1">child = fiber.child;</span>

      <span class="s2">if </span><span class="s1">((fiber.subtreeFlags &amp; BeforeMutationMask) !== NoFlags &amp;&amp; child !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">child.</span><span class="s2">return </span><span class="s1">= fiber;</span>
        <span class="s1">nextEffect = child;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">commitBeforeMutationEffects_complete();</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">commitBeforeMutationEffects_complete() {</span>
    <span class="s2">while </span><span class="s1">(nextEffect !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">fiber = nextEffect;</span>
      <span class="s1">setCurrentFiber(fiber);</span>

      <span class="s2">try </span><span class="s1">{</span>
        <span class="s1">commitBeforeMutationEffectsOnFiber(fiber);</span>
      <span class="s1">} </span><span class="s2">catch </span><span class="s1">(error) {</span>
        <span class="s1">captureCommitPhaseError(fiber, fiber.</span><span class="s2">return</span><span class="s1">, error);</span>
      <span class="s1">}</span>

      <span class="s1">resetCurrentFiber();</span>
      <span class="s2">var </span><span class="s1">sibling = fiber.sibling;</span>

      <span class="s2">if </span><span class="s1">(sibling !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">sibling.</span><span class="s2">return </span><span class="s1">= fiber.</span><span class="s2">return</span><span class="s1">;</span>
        <span class="s1">nextEffect = sibling;</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">nextEffect = fiber.</span><span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">commitBeforeMutationEffectsOnFiber(finishedWork) {</span>
    <span class="s2">var </span><span class="s1">current = finishedWork.alternate;</span>
    <span class="s2">var </span><span class="s1">flags = finishedWork.flags;</span>

    <span class="s2">if </span><span class="s1">((flags &amp; Snapshot) !== NoFlags) {</span>
      <span class="s1">setCurrentFiber(finishedWork);</span>

      <span class="s2">switch </span><span class="s1">(finishedWork.tag) {</span>
        <span class="s2">case </span><span class="s1">FunctionComponent:</span>
        <span class="s2">case </span><span class="s1">ForwardRef:</span>
        <span class="s2">case </span><span class="s1">SimpleMemoComponent:</span>
          <span class="s1">{</span>
            <span class="s2">break</span><span class="s1">;</span>
          <span class="s1">}</span>

        <span class="s2">case </span><span class="s1">ClassComponent:</span>
          <span class="s1">{</span>
            <span class="s2">if </span><span class="s1">(current !== </span><span class="s2">null</span><span class="s1">) {</span>
              <span class="s2">var </span><span class="s1">prevProps = current.memoizedProps;</span>
              <span class="s2">var </span><span class="s1">prevState = current.memoizedState;</span>
              <span class="s2">var </span><span class="s1">instance = finishedWork.stateNode; </span><span class="s0">// We could update instance props and state here,</span>
              <span class="s0">// but instead we rely on them being set during last render.</span>
              <span class="s0">// TODO: revisit this when we implement resuming.</span>

              <span class="s1">{</span>
                <span class="s2">if </span><span class="s1">(finishedWork.type === finishedWork.elementType &amp;&amp; !didWarnAboutReassigningProps) {</span>
                  <span class="s2">if </span><span class="s1">(instance.props !== finishedWork.memoizedProps) {</span>
                    <span class="s1">error(</span><span class="s3">'Expected %s props to match memoized props before ' </span><span class="s1">+ </span><span class="s3">'getSnapshotBeforeUpdate. ' </span><span class="s1">+ </span><span class="s3">'This might either be because of a bug in React, or because ' </span><span class="s1">+ </span><span class="s3">'a component reassigns its own `this.props`. ' </span><span class="s1">+ </span><span class="s3">'Please file an issue.'</span><span class="s1">, getComponentNameFromFiber(finishedWork) || </span><span class="s3">'instance'</span><span class="s1">);</span>
                  <span class="s1">}</span>

                  <span class="s2">if </span><span class="s1">(instance.state !== finishedWork.memoizedState) {</span>
                    <span class="s1">error(</span><span class="s3">'Expected %s state to match memoized state before ' </span><span class="s1">+ </span><span class="s3">'getSnapshotBeforeUpdate. ' </span><span class="s1">+ </span><span class="s3">'This might either be because of a bug in React, or because ' </span><span class="s1">+ </span><span class="s3">'a component reassigns its own `this.state`. ' </span><span class="s1">+ </span><span class="s3">'Please file an issue.'</span><span class="s1">, getComponentNameFromFiber(finishedWork) || </span><span class="s3">'instance'</span><span class="s1">);</span>
                  <span class="s1">}</span>
                <span class="s1">}</span>
              <span class="s1">}</span>

              <span class="s2">var </span><span class="s1">snapshot = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);</span>

              <span class="s1">{</span>
                <span class="s2">var </span><span class="s1">didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;</span>

                <span class="s2">if </span><span class="s1">(snapshot === undefined &amp;&amp; !didWarnSet.has(finishedWork.type)) {</span>
                  <span class="s1">didWarnSet.add(finishedWork.type);</span>

                  <span class="s1">error(</span><span class="s3">'%s.getSnapshotBeforeUpdate(): A snapshot value (or null) ' </span><span class="s1">+ </span><span class="s3">'must be returned. You have returned undefined.'</span><span class="s1">, getComponentNameFromFiber(finishedWork));</span>
                <span class="s1">}</span>
              <span class="s1">}</span>

              <span class="s1">instance.__reactInternalSnapshotBeforeUpdate = snapshot;</span>
            <span class="s1">}</span>

            <span class="s2">break</span><span class="s1">;</span>
          <span class="s1">}</span>

        <span class="s2">case </span><span class="s1">HostRoot:</span>
          <span class="s1">{</span>
            <span class="s1">{</span>
              <span class="s2">var </span><span class="s1">root = finishedWork.stateNode;</span>
              <span class="s1">clearContainer(root.containerInfo);</span>
            <span class="s1">}</span>

            <span class="s2">break</span><span class="s1">;</span>
          <span class="s1">}</span>

        <span class="s2">case </span><span class="s1">HostComponent:</span>
        <span class="s2">case </span><span class="s1">HostText:</span>
        <span class="s2">case </span><span class="s1">HostPortal:</span>
        <span class="s2">case </span><span class="s1">IncompleteClassComponent:</span>
          <span class="s0">// Nothing to do for these component types</span>
          <span class="s2">break</span><span class="s1">;</span>

        <span class="s2">default</span><span class="s1">:</span>
          <span class="s1">{</span>
            <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'This unit of work tag should not have side-effects. This error is ' </span><span class="s1">+ </span><span class="s3">'likely caused by a bug in React. Please file an issue.'</span><span class="s1">);</span>
          <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">resetCurrentFiber();</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {</span>
    <span class="s2">var </span><span class="s1">updateQueue = finishedWork.updateQueue;</span>
    <span class="s2">var </span><span class="s1">lastEffect = updateQueue !== </span><span class="s2">null </span><span class="s1">? updateQueue.lastEffect : </span><span class="s2">null</span><span class="s1">;</span>

    <span class="s2">if </span><span class="s1">(lastEffect !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">firstEffect = lastEffect.next;</span>
      <span class="s2">var </span><span class="s1">effect = firstEffect;</span>

      <span class="s2">do </span><span class="s1">{</span>
        <span class="s2">if </span><span class="s1">((effect.tag &amp; flags) === flags) {</span>
          <span class="s0">// Unmount</span>
          <span class="s2">var </span><span class="s1">destroy = effect.destroy;</span>
          <span class="s1">effect.destroy = undefined;</span>

          <span class="s2">if </span><span class="s1">(destroy !== undefined) {</span>

            <span class="s1">{</span>
              <span class="s2">if </span><span class="s1">((flags &amp; Insertion) !== NoFlags$1) {</span>
                <span class="s1">setIsRunningInsertionEffect(</span><span class="s2">true</span><span class="s1">);</span>
              <span class="s1">}</span>
            <span class="s1">}</span>

            <span class="s1">safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy);</span>

            <span class="s1">{</span>
              <span class="s2">if </span><span class="s1">((flags &amp; Insertion) !== NoFlags$1) {</span>
                <span class="s1">setIsRunningInsertionEffect(</span><span class="s2">false</span><span class="s1">);</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s1">effect = effect.next;</span>
      <span class="s1">} </span><span class="s2">while </span><span class="s1">(effect !== firstEffect);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">commitHookEffectListMount(flags, finishedWork) {</span>
    <span class="s2">var </span><span class="s1">updateQueue = finishedWork.updateQueue;</span>
    <span class="s2">var </span><span class="s1">lastEffect = updateQueue !== </span><span class="s2">null </span><span class="s1">? updateQueue.lastEffect : </span><span class="s2">null</span><span class="s1">;</span>

    <span class="s2">if </span><span class="s1">(lastEffect !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">firstEffect = lastEffect.next;</span>
      <span class="s2">var </span><span class="s1">effect = firstEffect;</span>

      <span class="s2">do </span><span class="s1">{</span>
        <span class="s2">if </span><span class="s1">((effect.tag &amp; flags) === flags) {</span>


          <span class="s2">var </span><span class="s1">create = effect.create;</span>

          <span class="s1">{</span>
            <span class="s2">if </span><span class="s1">((flags &amp; Insertion) !== NoFlags$1) {</span>
              <span class="s1">setIsRunningInsertionEffect(</span><span class="s2">true</span><span class="s1">);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s1">effect.destroy = create();</span>

          <span class="s1">{</span>
            <span class="s2">if </span><span class="s1">((flags &amp; Insertion) !== NoFlags$1) {</span>
              <span class="s1">setIsRunningInsertionEffect(</span><span class="s2">false</span><span class="s1">);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s1">{</span>
            <span class="s2">var </span><span class="s1">destroy = effect.destroy;</span>

            <span class="s2">if </span><span class="s1">(destroy !== undefined &amp;&amp; </span><span class="s2">typeof </span><span class="s1">destroy !== </span><span class="s3">'function'</span><span class="s1">) {</span>
              <span class="s2">var </span><span class="s1">hookName = </span><span class="s2">void </span><span class="s4">0</span><span class="s1">;</span>

              <span class="s2">if </span><span class="s1">((effect.tag &amp; Layout) !== NoFlags) {</span>
                <span class="s1">hookName = </span><span class="s3">'useLayoutEffect'</span><span class="s1">;</span>
              <span class="s1">} </span><span class="s2">else if </span><span class="s1">((effect.tag &amp; Insertion) !== NoFlags) {</span>
                <span class="s1">hookName = </span><span class="s3">'useInsertionEffect'</span><span class="s1">;</span>
              <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">hookName = </span><span class="s3">'useEffect'</span><span class="s1">;</span>
              <span class="s1">}</span>

              <span class="s2">var </span><span class="s1">addendum = </span><span class="s2">void </span><span class="s4">0</span><span class="s1">;</span>

              <span class="s2">if </span><span class="s1">(destroy === </span><span class="s2">null</span><span class="s1">) {</span>
                <span class="s1">addendum = </span><span class="s3">' You returned null. If your effect does not require clean ' </span><span class="s1">+ </span><span class="s3">'up, return undefined (or nothing).'</span><span class="s1">;</span>
              <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">destroy.then === </span><span class="s3">'function'</span><span class="s1">) {</span>
                <span class="s1">addendum = </span><span class="s3">'</span><span class="s5">\n\n</span><span class="s3">It looks like you wrote ' </span><span class="s1">+ hookName + </span><span class="s3">'(async () =&gt; ...) or returned a Promise. ' </span><span class="s1">+ </span><span class="s3">'Instead, write the async function inside your effect ' </span><span class="s1">+ </span><span class="s3">'and call it immediately:</span><span class="s5">\n\n</span><span class="s3">' </span><span class="s1">+ hookName + </span><span class="s3">'(() =&gt; {</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">'  async function fetchData() {</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">'    // You can await here</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">'    const response = await MyAPI.getData(someId);</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">'    // ...</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">'  }</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">'  fetchData();</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">&quot;}, [someId]); // Or [] if effect doesn't need props or state</span><span class="s5">\n\n</span><span class="s3">&quot; </span><span class="s1">+ </span><span class="s3">'Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching'</span><span class="s1">;</span>
              <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">addendum = </span><span class="s3">' You returned: ' </span><span class="s1">+ destroy;</span>
              <span class="s1">}</span>

              <span class="s1">error(</span><span class="s3">'%s must not return anything besides a function, ' </span><span class="s1">+ </span><span class="s3">'which is used for clean-up.%s'</span><span class="s1">, hookName, addendum);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s1">effect = effect.next;</span>
      <span class="s1">} </span><span class="s2">while </span><span class="s1">(effect !== firstEffect);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">commitPassiveEffectDurations(finishedRoot, finishedWork) {</span>
    <span class="s1">{</span>
      <span class="s0">// Only Profilers with work in their subtree will have an Update effect scheduled.</span>
      <span class="s2">if </span><span class="s1">((finishedWork.flags &amp; Update) !== NoFlags) {</span>
        <span class="s2">switch </span><span class="s1">(finishedWork.tag) {</span>
          <span class="s2">case </span><span class="s1">Profiler:</span>
            <span class="s1">{</span>
              <span class="s2">var </span><span class="s1">passiveEffectDuration = finishedWork.stateNode.passiveEffectDuration;</span>
              <span class="s2">var </span><span class="s1">_finishedWork$memoize = finishedWork.memoizedProps,</span>
                  <span class="s1">id = _finishedWork$memoize.id,</span>
                  <span class="s1">onPostCommit = _finishedWork$memoize.onPostCommit; </span><span class="s0">// This value will still reflect the previous commit phase.</span>
              <span class="s0">// It does not get reset until the start of the next commit phase.</span>

              <span class="s2">var </span><span class="s1">commitTime = getCommitTime();</span>
              <span class="s2">var </span><span class="s1">phase = finishedWork.alternate === </span><span class="s2">null </span><span class="s1">? </span><span class="s3">'mount' </span><span class="s1">: </span><span class="s3">'update'</span><span class="s1">;</span>

              <span class="s1">{</span>
                <span class="s2">if </span><span class="s1">(isCurrentUpdateNested()) {</span>
                  <span class="s1">phase = </span><span class="s3">'nested-update'</span><span class="s1">;</span>
                <span class="s1">}</span>
              <span class="s1">}</span>

              <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">onPostCommit === </span><span class="s3">'function'</span><span class="s1">) {</span>
                <span class="s1">onPostCommit(id, phase, passiveEffectDuration, commitTime);</span>
              <span class="s1">} </span><span class="s0">// Bubble times to the next nearest ancestor Profiler.</span>
              <span class="s0">// After we process that Profiler, we'll bubble further up.</span>


              <span class="s2">var </span><span class="s1">parentFiber = finishedWork.</span><span class="s2">return</span><span class="s1">;</span>

              <span class="s1">outer: </span><span class="s2">while </span><span class="s1">(parentFiber !== </span><span class="s2">null</span><span class="s1">) {</span>
                <span class="s2">switch </span><span class="s1">(parentFiber.tag) {</span>
                  <span class="s2">case </span><span class="s1">HostRoot:</span>
                    <span class="s2">var </span><span class="s1">root = parentFiber.stateNode;</span>
                    <span class="s1">root.passiveEffectDuration += passiveEffectDuration;</span>
                    <span class="s2">break </span><span class="s1">outer;</span>

                  <span class="s2">case </span><span class="s1">Profiler:</span>
                    <span class="s2">var </span><span class="s1">parentStateNode = parentFiber.stateNode;</span>
                    <span class="s1">parentStateNode.passiveEffectDuration += passiveEffectDuration;</span>
                    <span class="s2">break </span><span class="s1">outer;</span>
                <span class="s1">}</span>

                <span class="s1">parentFiber = parentFiber.</span><span class="s2">return</span><span class="s1">;</span>
              <span class="s1">}</span>

              <span class="s2">break</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">commitLayoutEffectOnFiber(finishedRoot, current, finishedWork, committedLanes) {</span>
    <span class="s2">if </span><span class="s1">((finishedWork.flags &amp; LayoutMask) !== NoFlags) {</span>
      <span class="s2">switch </span><span class="s1">(finishedWork.tag) {</span>
        <span class="s2">case </span><span class="s1">FunctionComponent:</span>
        <span class="s2">case </span><span class="s1">ForwardRef:</span>
        <span class="s2">case </span><span class="s1">SimpleMemoComponent:</span>
          <span class="s1">{</span>
            <span class="s1">{</span>
              <span class="s0">// At this point layout effects have already been destroyed (during mutation phase).</span>
              <span class="s0">// This is done to prevent sibling component effects from interfering with each other,</span>
              <span class="s0">// e.g. a destroy function in one component should never override a ref set</span>
              <span class="s0">// by a create function in another component during the same commit.</span>
              <span class="s2">if </span><span class="s1">( finishedWork.mode &amp; ProfileMode) {</span>
                <span class="s2">try </span><span class="s1">{</span>
                  <span class="s1">startLayoutEffectTimer();</span>
                  <span class="s1">commitHookEffectListMount(Layout | HasEffect, finishedWork);</span>
                <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
                  <span class="s1">recordLayoutEffectDuration(finishedWork);</span>
                <span class="s1">}</span>
              <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">commitHookEffectListMount(Layout | HasEffect, finishedWork);</span>
              <span class="s1">}</span>
            <span class="s1">}</span>

            <span class="s2">break</span><span class="s1">;</span>
          <span class="s1">}</span>

        <span class="s2">case </span><span class="s1">ClassComponent:</span>
          <span class="s1">{</span>
            <span class="s2">var </span><span class="s1">instance = finishedWork.stateNode;</span>

            <span class="s2">if </span><span class="s1">(finishedWork.flags &amp; Update) {</span>
              <span class="s1">{</span>
                <span class="s2">if </span><span class="s1">(current === </span><span class="s2">null</span><span class="s1">) {</span>
                  <span class="s0">// We could update instance props and state here,</span>
                  <span class="s0">// but instead we rely on them being set during last render.</span>
                  <span class="s0">// TODO: revisit this when we implement resuming.</span>
                  <span class="s1">{</span>
                    <span class="s2">if </span><span class="s1">(finishedWork.type === finishedWork.elementType &amp;&amp; !didWarnAboutReassigningProps) {</span>
                      <span class="s2">if </span><span class="s1">(instance.props !== finishedWork.memoizedProps) {</span>
                        <span class="s1">error(</span><span class="s3">'Expected %s props to match memoized props before ' </span><span class="s1">+ </span><span class="s3">'componentDidMount. ' </span><span class="s1">+ </span><span class="s3">'This might either be because of a bug in React, or because ' </span><span class="s1">+ </span><span class="s3">'a component reassigns its own `this.props`. ' </span><span class="s1">+ </span><span class="s3">'Please file an issue.'</span><span class="s1">, getComponentNameFromFiber(finishedWork) || </span><span class="s3">'instance'</span><span class="s1">);</span>
                      <span class="s1">}</span>

                      <span class="s2">if </span><span class="s1">(instance.state !== finishedWork.memoizedState) {</span>
                        <span class="s1">error(</span><span class="s3">'Expected %s state to match memoized state before ' </span><span class="s1">+ </span><span class="s3">'componentDidMount. ' </span><span class="s1">+ </span><span class="s3">'This might either be because of a bug in React, or because ' </span><span class="s1">+ </span><span class="s3">'a component reassigns its own `this.state`. ' </span><span class="s1">+ </span><span class="s3">'Please file an issue.'</span><span class="s1">, getComponentNameFromFiber(finishedWork) || </span><span class="s3">'instance'</span><span class="s1">);</span>
                      <span class="s1">}</span>
                    <span class="s1">}</span>
                  <span class="s1">}</span>

                  <span class="s2">if </span><span class="s1">( finishedWork.mode &amp; ProfileMode) {</span>
                    <span class="s2">try </span><span class="s1">{</span>
                      <span class="s1">startLayoutEffectTimer();</span>
                      <span class="s1">instance.componentDidMount();</span>
                    <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
                      <span class="s1">recordLayoutEffectDuration(finishedWork);</span>
                    <span class="s1">}</span>
                  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">instance.componentDidMount();</span>
                  <span class="s1">}</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                  <span class="s2">var </span><span class="s1">prevProps = finishedWork.elementType === finishedWork.type ? current.memoizedProps : resolveDefaultProps(finishedWork.type, current.memoizedProps);</span>
                  <span class="s2">var </span><span class="s1">prevState = current.memoizedState; </span><span class="s0">// We could update instance props and state here,</span>
                  <span class="s0">// but instead we rely on them being set during last render.</span>
                  <span class="s0">// TODO: revisit this when we implement resuming.</span>

                  <span class="s1">{</span>
                    <span class="s2">if </span><span class="s1">(finishedWork.type === finishedWork.elementType &amp;&amp; !didWarnAboutReassigningProps) {</span>
                      <span class="s2">if </span><span class="s1">(instance.props !== finishedWork.memoizedProps) {</span>
                        <span class="s1">error(</span><span class="s3">'Expected %s props to match memoized props before ' </span><span class="s1">+ </span><span class="s3">'componentDidUpdate. ' </span><span class="s1">+ </span><span class="s3">'This might either be because of a bug in React, or because ' </span><span class="s1">+ </span><span class="s3">'a component reassigns its own `this.props`. ' </span><span class="s1">+ </span><span class="s3">'Please file an issue.'</span><span class="s1">, getComponentNameFromFiber(finishedWork) || </span><span class="s3">'instance'</span><span class="s1">);</span>
                      <span class="s1">}</span>

                      <span class="s2">if </span><span class="s1">(instance.state !== finishedWork.memoizedState) {</span>
                        <span class="s1">error(</span><span class="s3">'Expected %s state to match memoized state before ' </span><span class="s1">+ </span><span class="s3">'componentDidUpdate. ' </span><span class="s1">+ </span><span class="s3">'This might either be because of a bug in React, or because ' </span><span class="s1">+ </span><span class="s3">'a component reassigns its own `this.state`. ' </span><span class="s1">+ </span><span class="s3">'Please file an issue.'</span><span class="s1">, getComponentNameFromFiber(finishedWork) || </span><span class="s3">'instance'</span><span class="s1">);</span>
                      <span class="s1">}</span>
                    <span class="s1">}</span>
                  <span class="s1">}</span>

                  <span class="s2">if </span><span class="s1">( finishedWork.mode &amp; ProfileMode) {</span>
                    <span class="s2">try </span><span class="s1">{</span>
                      <span class="s1">startLayoutEffectTimer();</span>
                      <span class="s1">instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);</span>
                    <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
                      <span class="s1">recordLayoutEffectDuration(finishedWork);</span>
                    <span class="s1">}</span>
                  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);</span>
                  <span class="s1">}</span>
                <span class="s1">}</span>
              <span class="s1">}</span>
            <span class="s1">} </span><span class="s0">// TODO: I think this is now always non-null by the time it reaches the</span>
            <span class="s0">// commit phase. Consider removing the type check.</span>


            <span class="s2">var </span><span class="s1">updateQueue = finishedWork.updateQueue;</span>

            <span class="s2">if </span><span class="s1">(updateQueue !== </span><span class="s2">null</span><span class="s1">) {</span>
              <span class="s1">{</span>
                <span class="s2">if </span><span class="s1">(finishedWork.type === finishedWork.elementType &amp;&amp; !didWarnAboutReassigningProps) {</span>
                  <span class="s2">if </span><span class="s1">(instance.props !== finishedWork.memoizedProps) {</span>
                    <span class="s1">error(</span><span class="s3">'Expected %s props to match memoized props before ' </span><span class="s1">+ </span><span class="s3">'processing the update queue. ' </span><span class="s1">+ </span><span class="s3">'This might either be because of a bug in React, or because ' </span><span class="s1">+ </span><span class="s3">'a component reassigns its own `this.props`. ' </span><span class="s1">+ </span><span class="s3">'Please file an issue.'</span><span class="s1">, getComponentNameFromFiber(finishedWork) || </span><span class="s3">'instance'</span><span class="s1">);</span>
                  <span class="s1">}</span>

                  <span class="s2">if </span><span class="s1">(instance.state !== finishedWork.memoizedState) {</span>
                    <span class="s1">error(</span><span class="s3">'Expected %s state to match memoized state before ' </span><span class="s1">+ </span><span class="s3">'processing the update queue. ' </span><span class="s1">+ </span><span class="s3">'This might either be because of a bug in React, or because ' </span><span class="s1">+ </span><span class="s3">'a component reassigns its own `this.state`. ' </span><span class="s1">+ </span><span class="s3">'Please file an issue.'</span><span class="s1">, getComponentNameFromFiber(finishedWork) || </span><span class="s3">'instance'</span><span class="s1">);</span>
                  <span class="s1">}</span>
                <span class="s1">}</span>
              <span class="s1">} </span><span class="s0">// We could update instance props and state here,</span>
              <span class="s0">// but instead we rely on them being set during last render.</span>
              <span class="s0">// TODO: revisit this when we implement resuming.</span>


              <span class="s1">commitUpdateQueue(finishedWork, updateQueue, instance);</span>
            <span class="s1">}</span>

            <span class="s2">break</span><span class="s1">;</span>
          <span class="s1">}</span>

        <span class="s2">case </span><span class="s1">HostRoot:</span>
          <span class="s1">{</span>
            <span class="s0">// TODO: I think this is now always non-null by the time it reaches the</span>
            <span class="s0">// commit phase. Consider removing the type check.</span>
            <span class="s2">var </span><span class="s1">_updateQueue = finishedWork.updateQueue;</span>

            <span class="s2">if </span><span class="s1">(_updateQueue !== </span><span class="s2">null</span><span class="s1">) {</span>
              <span class="s2">var </span><span class="s1">_instance = </span><span class="s2">null</span><span class="s1">;</span>

              <span class="s2">if </span><span class="s1">(finishedWork.child !== </span><span class="s2">null</span><span class="s1">) {</span>
                <span class="s2">switch </span><span class="s1">(finishedWork.child.tag) {</span>
                  <span class="s2">case </span><span class="s1">HostComponent:</span>
                    <span class="s1">_instance = getPublicInstance(finishedWork.child.stateNode);</span>
                    <span class="s2">break</span><span class="s1">;</span>

                  <span class="s2">case </span><span class="s1">ClassComponent:</span>
                    <span class="s1">_instance = finishedWork.child.stateNode;</span>
                    <span class="s2">break</span><span class="s1">;</span>
                <span class="s1">}</span>
              <span class="s1">}</span>

              <span class="s1">commitUpdateQueue(finishedWork, _updateQueue, _instance);</span>
            <span class="s1">}</span>

            <span class="s2">break</span><span class="s1">;</span>
          <span class="s1">}</span>

        <span class="s2">case </span><span class="s1">HostComponent:</span>
          <span class="s1">{</span>
            <span class="s2">var </span><span class="s1">_instance2 = finishedWork.stateNode; </span><span class="s0">// Renderers may schedule work to be done after host components are mounted</span>
            <span class="s0">// (eg DOM renderer may schedule auto-focus for inputs and form controls).</span>
            <span class="s0">// These effects should only be committed when components are first mounted,</span>
            <span class="s0">// aka when there is no current/alternate.</span>

            <span class="s2">if </span><span class="s1">(current === </span><span class="s2">null </span><span class="s1">&amp;&amp; finishedWork.flags &amp; Update) {</span>
              <span class="s2">var </span><span class="s1">type = finishedWork.type;</span>
              <span class="s2">var </span><span class="s1">props = finishedWork.memoizedProps;</span>
            <span class="s1">}</span>

            <span class="s2">break</span><span class="s1">;</span>
          <span class="s1">}</span>

        <span class="s2">case </span><span class="s1">HostText:</span>
          <span class="s1">{</span>
            <span class="s0">// We have no life-cycles associated with text.</span>
            <span class="s2">break</span><span class="s1">;</span>
          <span class="s1">}</span>

        <span class="s2">case </span><span class="s1">HostPortal:</span>
          <span class="s1">{</span>
            <span class="s0">// We have no life-cycles associated with portals.</span>
            <span class="s2">break</span><span class="s1">;</span>
          <span class="s1">}</span>

        <span class="s2">case </span><span class="s1">Profiler:</span>
          <span class="s1">{</span>
            <span class="s1">{</span>
              <span class="s2">var </span><span class="s1">_finishedWork$memoize2 = finishedWork.memoizedProps,</span>
                  <span class="s1">onCommit = _finishedWork$memoize2.onCommit,</span>
                  <span class="s1">onRender = _finishedWork$memoize2.onRender;</span>
              <span class="s2">var </span><span class="s1">effectDuration = finishedWork.stateNode.effectDuration;</span>
              <span class="s2">var </span><span class="s1">commitTime = getCommitTime();</span>
              <span class="s2">var </span><span class="s1">phase = current === </span><span class="s2">null </span><span class="s1">? </span><span class="s3">'mount' </span><span class="s1">: </span><span class="s3">'update'</span><span class="s1">;</span>

              <span class="s1">{</span>
                <span class="s2">if </span><span class="s1">(isCurrentUpdateNested()) {</span>
                  <span class="s1">phase = </span><span class="s3">'nested-update'</span><span class="s1">;</span>
                <span class="s1">}</span>
              <span class="s1">}</span>

              <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">onRender === </span><span class="s3">'function'</span><span class="s1">) {</span>
                <span class="s1">onRender(finishedWork.memoizedProps.id, phase, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitTime);</span>
              <span class="s1">}</span>

              <span class="s1">{</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">onCommit === </span><span class="s3">'function'</span><span class="s1">) {</span>
                  <span class="s1">onCommit(finishedWork.memoizedProps.id, phase, effectDuration, commitTime);</span>
                <span class="s1">} </span><span class="s0">// Schedule a passive effect for this Profiler to call onPostCommit hooks.</span>
                <span class="s0">// This effect should be scheduled even if there is no onPostCommit callback for this Profiler,</span>
                <span class="s0">// because the effect is also where times bubble to parent Profilers.</span>


                <span class="s1">enqueuePendingPassiveProfilerEffect(finishedWork); </span><span class="s0">// Propagate layout effect durations to the next nearest Profiler ancestor.</span>
                <span class="s0">// Do not reset these values until the next render so DevTools has a chance to read them first.</span>

                <span class="s2">var </span><span class="s1">parentFiber = finishedWork.</span><span class="s2">return</span><span class="s1">;</span>

                <span class="s1">outer: </span><span class="s2">while </span><span class="s1">(parentFiber !== </span><span class="s2">null</span><span class="s1">) {</span>
                  <span class="s2">switch </span><span class="s1">(parentFiber.tag) {</span>
                    <span class="s2">case </span><span class="s1">HostRoot:</span>
                      <span class="s2">var </span><span class="s1">root = parentFiber.stateNode;</span>
                      <span class="s1">root.effectDuration += effectDuration;</span>
                      <span class="s2">break </span><span class="s1">outer;</span>

                    <span class="s2">case </span><span class="s1">Profiler:</span>
                      <span class="s2">var </span><span class="s1">parentStateNode = parentFiber.stateNode;</span>
                      <span class="s1">parentStateNode.effectDuration += effectDuration;</span>
                      <span class="s2">break </span><span class="s1">outer;</span>
                  <span class="s1">}</span>

                  <span class="s1">parentFiber = parentFiber.</span><span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
              <span class="s1">}</span>
            <span class="s1">}</span>

            <span class="s2">break</span><span class="s1">;</span>
          <span class="s1">}</span>

        <span class="s2">case </span><span class="s1">SuspenseComponent:</span>
          <span class="s1">{</span>
            <span class="s2">break</span><span class="s1">;</span>
          <span class="s1">}</span>

        <span class="s2">case </span><span class="s1">SuspenseListComponent:</span>
        <span class="s2">case </span><span class="s1">IncompleteClassComponent:</span>
        <span class="s2">case </span><span class="s1">ScopeComponent:</span>
        <span class="s2">case </span><span class="s1">OffscreenComponent:</span>
        <span class="s2">case </span><span class="s1">LegacyHiddenComponent:</span>
        <span class="s2">case </span><span class="s1">TracingMarkerComponent:</span>
          <span class="s1">{</span>
            <span class="s2">break</span><span class="s1">;</span>
          <span class="s1">}</span>

        <span class="s2">default</span><span class="s1">:</span>
          <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'This unit of work tag should not have side-effects. This error is ' </span><span class="s1">+ </span><span class="s3">'likely caused by a bug in React. Please file an issue.'</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(finishedWork.flags &amp; Ref) {</span>
          <span class="s1">commitAttachRef(finishedWork);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">hideOrUnhideAllChildren(finishedWork, isHidden) {</span>
    <span class="s0">// Only hide or unhide the top-most host nodes.</span>
    <span class="s2">var </span><span class="s1">hostSubtreeRoot = </span><span class="s2">null</span><span class="s1">;</span>

    <span class="s1">{</span>
      <span class="s0">// We only have the top Fiber that was inserted but we need to recurse down its</span>
      <span class="s0">// children to find all the terminal nodes.</span>
      <span class="s2">var </span><span class="s1">node = finishedWork;</span>

      <span class="s2">while </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(node.tag === HostComponent) {</span>
          <span class="s2">if </span><span class="s1">(hostSubtreeRoot === </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">hostSubtreeRoot = node;</span>

            <span class="s2">try </span><span class="s1">{</span>
              <span class="s2">var </span><span class="s1">instance = node.stateNode;</span>

              <span class="s2">if </span><span class="s1">(isHidden) {</span>
                <span class="s1">hideInstance(instance);</span>
              <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">unhideInstance(node.stateNode, node.memoizedProps);</span>
              <span class="s1">}</span>
            <span class="s1">} </span><span class="s2">catch </span><span class="s1">(error) {</span>
              <span class="s1">captureCommitPhaseError(finishedWork, finishedWork.</span><span class="s2">return</span><span class="s1">, error);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(node.tag === HostText) {</span>
          <span class="s2">if </span><span class="s1">(hostSubtreeRoot === </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">try </span><span class="s1">{</span>
              <span class="s2">var </span><span class="s1">_instance3 = node.stateNode;</span>

              <span class="s2">if </span><span class="s1">(isHidden) {</span>
                <span class="s1">hideTextInstance(_instance3);</span>
              <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">unhideTextInstance(_instance3, node.memoizedProps);</span>
              <span class="s1">}</span>
            <span class="s1">} </span><span class="s2">catch </span><span class="s1">(error) {</span>
              <span class="s1">captureCommitPhaseError(finishedWork, finishedWork.</span><span class="s2">return</span><span class="s1">, error);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">((node.tag === OffscreenComponent || node.tag === LegacyHiddenComponent) &amp;&amp; node.memoizedState !== </span><span class="s2">null </span><span class="s1">&amp;&amp; node !== finishedWork) ; </span><span class="s2">else if </span><span class="s1">(node.child !== </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">node.child.</span><span class="s2">return </span><span class="s1">= node;</span>
          <span class="s1">node = node.child;</span>
          <span class="s2">continue</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(node === finishedWork) {</span>
          <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s2">while </span><span class="s1">(node.sibling === </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s2">if </span><span class="s1">(node.</span><span class="s2">return </span><span class="s1">=== </span><span class="s2">null </span><span class="s1">|| node.</span><span class="s2">return </span><span class="s1">=== finishedWork) {</span>
            <span class="s2">return</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s2">if </span><span class="s1">(hostSubtreeRoot === node) {</span>
            <span class="s1">hostSubtreeRoot = </span><span class="s2">null</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s1">node = node.</span><span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(hostSubtreeRoot === node) {</span>
          <span class="s1">hostSubtreeRoot = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">node.sibling.</span><span class="s2">return </span><span class="s1">= node.</span><span class="s2">return</span><span class="s1">;</span>
        <span class="s1">node = node.sibling;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">commitAttachRef(finishedWork) {</span>
    <span class="s2">var </span><span class="s1">ref = finishedWork.ref;</span>

    <span class="s2">if </span><span class="s1">(ref !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">instance = finishedWork.stateNode;</span>
      <span class="s2">var </span><span class="s1">instanceToUse;</span>

      <span class="s2">switch </span><span class="s1">(finishedWork.tag) {</span>
        <span class="s2">case </span><span class="s1">HostComponent:</span>
          <span class="s1">instanceToUse = getPublicInstance(instance);</span>
          <span class="s2">break</span><span class="s1">;</span>

        <span class="s2">default</span><span class="s1">:</span>
          <span class="s1">instanceToUse = instance;</span>
      <span class="s1">} </span><span class="s0">// Moved outside to ensure DCE works with this flag</span>

      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">ref === </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s2">var </span><span class="s1">retVal;</span>

        <span class="s2">if </span><span class="s1">( finishedWork.mode &amp; ProfileMode) {</span>
          <span class="s2">try </span><span class="s1">{</span>
            <span class="s1">startLayoutEffectTimer();</span>
            <span class="s1">retVal = ref(instanceToUse);</span>
          <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
            <span class="s1">recordLayoutEffectDuration(finishedWork);</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">retVal = ref(instanceToUse);</span>
        <span class="s1">}</span>

        <span class="s1">{</span>
          <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">retVal === </span><span class="s3">'function'</span><span class="s1">) {</span>
            <span class="s1">error(</span><span class="s3">'Unexpected return value from a callback ref in %s. ' </span><span class="s1">+ </span><span class="s3">'A callback ref should not return a function.'</span><span class="s1">, getComponentNameFromFiber(finishedWork));</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">{</span>
          <span class="s2">if </span><span class="s1">(!ref.hasOwnProperty(</span><span class="s3">'current'</span><span class="s1">)) {</span>
            <span class="s1">error(</span><span class="s3">'Unexpected ref object provided for %s. ' </span><span class="s1">+ </span><span class="s3">'Use either a ref-setter function or React.createRef().'</span><span class="s1">, getComponentNameFromFiber(finishedWork));</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s1">ref.current = instanceToUse;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">detachFiberMutation(fiber) {</span>
    <span class="s0">// Cut off the return pointer to disconnect it from the tree.</span>
    <span class="s0">// This enables us to detect and warn against state updates on an unmounted component.</span>
    <span class="s0">// It also prevents events from bubbling from within disconnected components.</span>
    <span class="s0">//</span>
    <span class="s0">// Ideally, we should also clear the child pointer of the parent alternate to let this</span>
    <span class="s0">// get GC:ed but we don't know which for sure which parent is the current</span>
    <span class="s0">// one so we'll settle for GC:ing the subtree of this child.</span>
    <span class="s0">// This child itself will be GC:ed when the parent updates the next time.</span>
    <span class="s0">//</span>
    <span class="s0">// Note that we can't clear child or sibling pointers yet.</span>
    <span class="s0">// They're needed for passive effects and for findDOMNode.</span>
    <span class="s0">// We defer those fields, and all other cleanup, to the passive phase (see detachFiberAfterEffects).</span>
    <span class="s0">//</span>
    <span class="s0">// Don't reset the alternate yet, either. We need that so we can detach the</span>
    <span class="s0">// alternate's fields in the passive phase. Clearing the return pointer is</span>
    <span class="s0">// sufficient for findDOMNode semantics.</span>
    <span class="s2">var </span><span class="s1">alternate = fiber.alternate;</span>

    <span class="s2">if </span><span class="s1">(alternate !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">alternate.</span><span class="s2">return </span><span class="s1">= </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">fiber.</span><span class="s2">return </span><span class="s1">= </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">detachFiberAfterEffects(fiber) {</span>
    <span class="s2">var </span><span class="s1">alternate = fiber.alternate;</span>

    <span class="s2">if </span><span class="s1">(alternate !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">fiber.alternate = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">detachFiberAfterEffects(alternate);</span>
    <span class="s1">} </span><span class="s0">// Note: Defensively using negation instead of &lt; in case</span>
    <span class="s0">// `deletedTreeCleanUpLevel` is undefined.</span>


    <span class="s1">{</span>
      <span class="s0">// Clear cyclical Fiber fields. This level alone is designed to roughly</span>
      <span class="s0">// approximate the planned Fiber refactor. In that world, `setState` will be</span>
      <span class="s0">// bound to a special &quot;instance&quot; object instead of a Fiber. The Instance</span>
      <span class="s0">// object will not have any of these fields. It will only be connected to</span>
      <span class="s0">// the fiber tree via a single link at the root. So if this level alone is</span>
      <span class="s0">// sufficient to fix memory issues, that bodes well for our plans.</span>
      <span class="s1">fiber.child = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">fiber.deletions = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">fiber.sibling = </span><span class="s2">null</span><span class="s1">; </span><span class="s0">// The `stateNode` is cyclical because on host nodes it points to the host</span>
      <span class="s0">// tree, which has its own pointers to children, parents, and siblings.</span>
      <span class="s0">// The other host nodes also point back to fibers, so we should detach that</span>
      <span class="s0">// one, too.</span>

      <span class="s2">if </span><span class="s1">(fiber.tag === HostComponent) {</span>
        <span class="s2">var </span><span class="s1">hostInstance = fiber.stateNode;</span>
      <span class="s1">}</span>

      <span class="s1">fiber.stateNode = </span><span class="s2">null</span><span class="s1">; </span><span class="s0">// I'm intentionally not clearing the `return` field in this level. We</span>
      <span class="s0">// already disconnect the `return` pointer at the root of the deleted</span>
      <span class="s0">// subtree (in `detachFiberMutation`). Besides, `return` by itself is not</span>
      <span class="s0">// cyclical  it's only cyclical when combined with `child`, `sibling`, and</span>
      <span class="s0">// `alternate`. But we'll clear it in the next level anyway, just in case.</span>

      <span class="s1">{</span>
        <span class="s1">fiber._debugOwner = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">{</span>
        <span class="s0">// Theoretically, nothing in here should be necessary, because we already</span>
        <span class="s0">// disconnected the fiber from the tree. So even if something leaks this</span>
        <span class="s0">// particular fiber, it won't leak anything else</span>
        <span class="s0">//</span>
        <span class="s0">// The purpose of this branch is to be super aggressive so we can measure</span>
        <span class="s0">// if there's any difference in memory impact. If there is, that could</span>
        <span class="s0">// indicate a React leak we don't know about.</span>
        <span class="s1">fiber.</span><span class="s2">return </span><span class="s1">= </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s1">fiber.dependencies = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s1">fiber.memoizedProps = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s1">fiber.memoizedState = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s1">fiber.pendingProps = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s1">fiber.stateNode = </span><span class="s2">null</span><span class="s1">; </span><span class="s0">// TODO: Move to `commitPassiveUnmountInsideDeletedTreeOnFiber` instead.</span>

        <span class="s1">fiber.updateQueue = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">getHostParentFiber(fiber) {</span>
    <span class="s2">var </span><span class="s1">parent = fiber.</span><span class="s2">return</span><span class="s1">;</span>

    <span class="s2">while </span><span class="s1">(parent !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(isHostParent(parent)) {</span>
        <span class="s2">return </span><span class="s1">parent;</span>
      <span class="s1">}</span>

      <span class="s1">parent = parent.</span><span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Expected to find a host parent. This error is likely caused by a bug ' </span><span class="s1">+ </span><span class="s3">'in React. Please file an issue.'</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">isHostParent(fiber) {</span>
    <span class="s2">return </span><span class="s1">fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">getHostSibling(fiber) {</span>
    <span class="s0">// We're going to search forward into the tree until we find a sibling host</span>
    <span class="s0">// node. Unfortunately, if multiple insertions are done in a row we have to</span>
    <span class="s0">// search past them. This leads to exponential search for the next sibling.</span>
    <span class="s0">// TODO: Find a more efficient way to do this.</span>
    <span class="s2">var </span><span class="s1">node = fiber;</span>

    <span class="s1">siblings: </span><span class="s2">while </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
      <span class="s0">// If we didn't find anything, let's try the next sibling.</span>
      <span class="s2">while </span><span class="s1">(node.sibling === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(node.</span><span class="s2">return </span><span class="s1">=== </span><span class="s2">null </span><span class="s1">|| isHostParent(node.</span><span class="s2">return</span><span class="s1">)) {</span>
          <span class="s0">// If we pop out of the root or hit the parent the fiber we are the</span>
          <span class="s0">// last sibling.</span>
          <span class="s2">return null</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">node = node.</span><span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">node.sibling.</span><span class="s2">return </span><span class="s1">= node.</span><span class="s2">return</span><span class="s1">;</span>
      <span class="s1">node = node.sibling;</span>

      <span class="s2">while </span><span class="s1">(node.tag !== HostComponent &amp;&amp; node.tag !== HostText &amp;&amp; node.tag !== DehydratedFragment) {</span>
        <span class="s0">// If it is not host node and, we might have a host node inside it.</span>
        <span class="s0">// Try to search down until we find one.</span>
        <span class="s2">if </span><span class="s1">(node.flags &amp; Placement) {</span>
          <span class="s0">// If we don't have a child, try the siblings instead.</span>
          <span class="s2">continue </span><span class="s1">siblings;</span>
        <span class="s1">} </span><span class="s0">// If we don't have a child, try the siblings instead.</span>
        <span class="s0">// We also skip portals because they are not part of this host tree.</span>


        <span class="s2">if </span><span class="s1">(node.child === </span><span class="s2">null </span><span class="s1">|| node.tag === HostPortal) {</span>
          <span class="s2">continue </span><span class="s1">siblings;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">node.child.</span><span class="s2">return </span><span class="s1">= node;</span>
          <span class="s1">node = node.child;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s0">// Check if this host node is stable or about to be placed.</span>


      <span class="s2">if </span><span class="s1">(!(node.flags &amp; Placement)) {</span>
        <span class="s0">// Found it!</span>
        <span class="s2">return </span><span class="s1">node.stateNode;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">commitPlacement(finishedWork) {</span>


    <span class="s2">var </span><span class="s1">parentFiber = getHostParentFiber(finishedWork); </span><span class="s0">// Note: these two variables *must* always be updated together.</span>

    <span class="s2">switch </span><span class="s1">(parentFiber.tag) {</span>
      <span class="s2">case </span><span class="s1">HostComponent:</span>
        <span class="s1">{</span>
          <span class="s2">var </span><span class="s1">parent = parentFiber.stateNode;</span>

          <span class="s2">if </span><span class="s1">(parentFiber.flags &amp; ContentReset) {</span>

            <span class="s1">parentFiber.flags &amp;= ~ContentReset;</span>
          <span class="s1">}</span>

          <span class="s2">var </span><span class="s1">before = getHostSibling(finishedWork); </span><span class="s0">// We only have the top Fiber that was inserted but we need to recurse down its</span>
          <span class="s0">// children to find all the terminal nodes.</span>

          <span class="s1">insertOrAppendPlacementNode(finishedWork, before, parent);</span>
          <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s2">case </span><span class="s1">HostRoot:</span>
      <span class="s2">case </span><span class="s1">HostPortal:</span>
        <span class="s1">{</span>
          <span class="s2">var </span><span class="s1">_parent = parentFiber.stateNode.containerInfo;</span>

          <span class="s2">var </span><span class="s1">_before = getHostSibling(finishedWork);</span>

          <span class="s1">insertOrAppendPlacementNodeIntoContainer(finishedWork, _before, _parent);</span>
          <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s0">// eslint-disable-next-line-no-fallthrough</span>

      <span class="s2">default</span><span class="s1">:</span>
        <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Invalid host parent fiber. This error is likely caused by a bug ' </span><span class="s1">+ </span><span class="s3">'in React. Please file an issue.'</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">insertOrAppendPlacementNodeIntoContainer(node, before, parent) {</span>
    <span class="s2">var </span><span class="s1">tag = node.tag;</span>
    <span class="s2">var </span><span class="s1">isHost = tag === HostComponent || tag === HostText;</span>

    <span class="s2">if </span><span class="s1">(isHost) {</span>
      <span class="s2">var </span><span class="s1">stateNode = node.stateNode;</span>

      <span class="s2">if </span><span class="s1">(before) {</span>
        <span class="s1">insertInContainerBefore(parent, stateNode, before);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">appendChildToContainer(parent, stateNode);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(tag === HostPortal) ; </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">var </span><span class="s1">child = node.child;</span>

      <span class="s2">if </span><span class="s1">(child !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">insertOrAppendPlacementNodeIntoContainer(child, before, parent);</span>
        <span class="s2">var </span><span class="s1">sibling = child.sibling;</span>

        <span class="s2">while </span><span class="s1">(sibling !== </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);</span>
          <span class="s1">sibling = sibling.sibling;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">insertOrAppendPlacementNode(node, before, parent) {</span>
    <span class="s2">var </span><span class="s1">tag = node.tag;</span>
    <span class="s2">var </span><span class="s1">isHost = tag === HostComponent || tag === HostText;</span>

    <span class="s2">if </span><span class="s1">(isHost) {</span>
      <span class="s2">var </span><span class="s1">stateNode = node.stateNode;</span>

      <span class="s2">if </span><span class="s1">(before) {</span>
        <span class="s1">insertBefore(parent, stateNode, before);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">appendChild(parent, stateNode);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(tag === HostPortal) ; </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">var </span><span class="s1">child = node.child;</span>

      <span class="s2">if </span><span class="s1">(child !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">insertOrAppendPlacementNode(child, before, parent);</span>
        <span class="s2">var </span><span class="s1">sibling = child.sibling;</span>

        <span class="s2">while </span><span class="s1">(sibling !== </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">insertOrAppendPlacementNode(sibling, before, parent);</span>
          <span class="s1">sibling = sibling.sibling;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s0">// These are tracked on the stack as we recursively traverse a</span>
  <span class="s0">// deleted subtree.</span>
  <span class="s0">// TODO: Update these during the whole mutation phase, not just during</span>
  <span class="s0">// a deletion.</span>


  <span class="s2">var </span><span class="s1">hostParent = </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">hostParentIsContainer = </span><span class="s2">false</span><span class="s1">;</span>

  <span class="s2">function </span><span class="s1">commitDeletionEffects(root, returnFiber, deletedFiber) {</span>
    <span class="s1">{</span>
      <span class="s0">// We only have the top Fiber that was deleted but we need to recurse down its</span>
      <span class="s0">// children to find all the terminal nodes.</span>
      <span class="s0">// Recursively delete all host nodes from the parent, detach refs, clean</span>
      <span class="s0">// up mounted layout effects, and call componentWillUnmount.</span>
      <span class="s0">// We only need to remove the topmost host child in each branch. But then we</span>
      <span class="s0">// still need to keep traversing to unmount effects, refs, and cWU. TODO: We</span>
      <span class="s0">// could split this into two separate traversals functions, where the second</span>
      <span class="s0">// one doesn't include any removeChild logic. This is maybe the same</span>
      <span class="s0">// function as &quot;disappearLayoutEffects&quot; (or whatever that turns into after</span>
      <span class="s0">// the layout phase is refactored to use recursion).</span>
      <span class="s0">// Before starting, find the nearest host parent on the stack so we know</span>
      <span class="s0">// which instance/container to remove the children from.</span>
      <span class="s0">// TODO: Instead of searching up the fiber return path on every deletion, we</span>
      <span class="s0">// can track the nearest host component on the JS stack as we traverse the</span>
      <span class="s0">// tree during the commit phase. This would make insertions faster, too.</span>
      <span class="s2">var </span><span class="s1">parent = returnFiber;</span>

      <span class="s1">findParent: </span><span class="s2">while </span><span class="s1">(parent !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">switch </span><span class="s1">(parent.tag) {</span>
          <span class="s2">case </span><span class="s1">HostComponent:</span>
            <span class="s1">{</span>
              <span class="s1">hostParent = parent.stateNode;</span>
              <span class="s1">hostParentIsContainer = </span><span class="s2">false</span><span class="s1">;</span>
              <span class="s2">break </span><span class="s1">findParent;</span>
            <span class="s1">}</span>

          <span class="s2">case </span><span class="s1">HostRoot:</span>
            <span class="s1">{</span>
              <span class="s1">hostParent = parent.stateNode.containerInfo;</span>
              <span class="s1">hostParentIsContainer = </span><span class="s2">true</span><span class="s1">;</span>
              <span class="s2">break </span><span class="s1">findParent;</span>
            <span class="s1">}</span>

          <span class="s2">case </span><span class="s1">HostPortal:</span>
            <span class="s1">{</span>
              <span class="s1">hostParent = parent.stateNode.containerInfo;</span>
              <span class="s1">hostParentIsContainer = </span><span class="s2">true</span><span class="s1">;</span>
              <span class="s2">break </span><span class="s1">findParent;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s1">parent = parent.</span><span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(hostParent === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Expected to find a host parent. This error is likely caused by ' </span><span class="s1">+ </span><span class="s3">'a bug in React. Please file an issue.'</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s1">commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);</span>
      <span class="s1">hostParent = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">hostParentIsContainer = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">detachFiberMutation(deletedFiber);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {</span>
    <span class="s0">// TODO: Use a static flag to skip trees that don't have unmount effects</span>
    <span class="s2">var </span><span class="s1">child = parent.child;</span>

    <span class="s2">while </span><span class="s1">(child !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, child);</span>
      <span class="s1">child = child.sibling;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {</span>
    <span class="s1">onCommitUnmount(deletedFiber); </span><span class="s0">// The cases in this outer switch modify the stack before they traverse</span>
    <span class="s0">// into their subtree. There are simpler cases in the inner switch</span>
    <span class="s0">// that don't modify the stack.</span>

    <span class="s2">switch </span><span class="s1">(deletedFiber.tag) {</span>
      <span class="s2">case </span><span class="s1">HostComponent:</span>
        <span class="s1">{</span>
          <span class="s1">{</span>
            <span class="s1">safelyDetachRef(deletedFiber, nearestMountedAncestor);</span>
          <span class="s1">} </span><span class="s0">// Intentional fallthrough to next branch</span>

        <span class="s1">}</span>
      <span class="s0">// eslint-disable-next-line-no-fallthrough</span>

      <span class="s2">case </span><span class="s1">HostText:</span>
        <span class="s1">{</span>
          <span class="s0">// We only need to remove the nearest host child. Set the host parent</span>
          <span class="s0">// to `null` on the stack to indicate that nested children don't</span>
          <span class="s0">// need to be removed.</span>
          <span class="s1">{</span>
            <span class="s2">var </span><span class="s1">prevHostParent = hostParent;</span>
            <span class="s2">var </span><span class="s1">prevHostParentIsContainer = hostParentIsContainer;</span>
            <span class="s1">hostParent = </span><span class="s2">null</span><span class="s1">;</span>
            <span class="s1">recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);</span>
            <span class="s1">hostParent = prevHostParent;</span>
            <span class="s1">hostParentIsContainer = prevHostParentIsContainer;</span>

            <span class="s2">if </span><span class="s1">(hostParent !== </span><span class="s2">null</span><span class="s1">) {</span>
              <span class="s0">// Now that all the child effects have unmounted, we can remove the</span>
              <span class="s0">// node from the tree.</span>
              <span class="s2">if </span><span class="s1">(hostParentIsContainer) {</span>
                <span class="s1">removeChildFromContainer(hostParent, deletedFiber.stateNode);</span>
              <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">removeChild(hostParent, deletedFiber.stateNode);</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s2">case </span><span class="s1">DehydratedFragment:</span>
        <span class="s1">{</span>
          <span class="s0">// Delete the dehydrated suspense boundary and all of its content.</span>


          <span class="s1">{</span>
            <span class="s2">if </span><span class="s1">(hostParent !== </span><span class="s2">null</span><span class="s1">) {</span>
              <span class="s2">if </span><span class="s1">(hostParentIsContainer) {</span>
                <span class="s1">clearSuspenseBoundaryFromContainer(hostParent, deletedFiber.stateNode);</span>
              <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">clearSuspenseBoundary(hostParent, deletedFiber.stateNode);</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s2">case </span><span class="s1">HostPortal:</span>
        <span class="s1">{</span>
          <span class="s1">{</span>
            <span class="s0">// When we go into a portal, it becomes the parent to remove from.</span>
            <span class="s2">var </span><span class="s1">_prevHostParent = hostParent;</span>
            <span class="s2">var </span><span class="s1">_prevHostParentIsContainer = hostParentIsContainer;</span>
            <span class="s1">hostParent = deletedFiber.stateNode.containerInfo;</span>
            <span class="s1">hostParentIsContainer = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);</span>
            <span class="s1">hostParent = _prevHostParent;</span>
            <span class="s1">hostParentIsContainer = _prevHostParentIsContainer;</span>
          <span class="s1">}</span>

          <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s2">case </span><span class="s1">FunctionComponent:</span>
      <span class="s2">case </span><span class="s1">ForwardRef:</span>
      <span class="s2">case </span><span class="s1">MemoComponent:</span>
      <span class="s2">case </span><span class="s1">SimpleMemoComponent:</span>
        <span class="s1">{</span>
          <span class="s1">{</span>
            <span class="s2">var </span><span class="s1">updateQueue = deletedFiber.updateQueue;</span>

            <span class="s2">if </span><span class="s1">(updateQueue !== </span><span class="s2">null</span><span class="s1">) {</span>
              <span class="s2">var </span><span class="s1">lastEffect = updateQueue.lastEffect;</span>

              <span class="s2">if </span><span class="s1">(lastEffect !== </span><span class="s2">null</span><span class="s1">) {</span>
                <span class="s2">var </span><span class="s1">firstEffect = lastEffect.next;</span>
                <span class="s2">var </span><span class="s1">effect = firstEffect;</span>

                <span class="s2">do </span><span class="s1">{</span>
                  <span class="s2">var </span><span class="s1">_effect = effect,</span>
                      <span class="s1">destroy = _effect.destroy,</span>
                      <span class="s1">tag = _effect.tag;</span>

                  <span class="s2">if </span><span class="s1">(destroy !== undefined) {</span>
                    <span class="s2">if </span><span class="s1">((tag &amp; Insertion) !== NoFlags$1) {</span>
                      <span class="s1">safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);</span>
                    <span class="s1">} </span><span class="s2">else if </span><span class="s1">((tag &amp; Layout) !== NoFlags$1) {</span>

                      <span class="s2">if </span><span class="s1">( deletedFiber.mode &amp; ProfileMode) {</span>
                        <span class="s1">startLayoutEffectTimer();</span>
                        <span class="s1">safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);</span>
                        <span class="s1">recordLayoutEffectDuration(deletedFiber);</span>
                      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);</span>
                      <span class="s1">}</span>
                    <span class="s1">}</span>
                  <span class="s1">}</span>

                  <span class="s1">effect = effect.next;</span>
                <span class="s1">} </span><span class="s2">while </span><span class="s1">(effect !== firstEffect);</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s1">recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);</span>
          <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s2">case </span><span class="s1">ClassComponent:</span>
        <span class="s1">{</span>
          <span class="s1">{</span>
            <span class="s1">safelyDetachRef(deletedFiber, nearestMountedAncestor);</span>
            <span class="s2">var </span><span class="s1">instance = deletedFiber.stateNode;</span>

            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">instance.componentWillUnmount === </span><span class="s3">'function'</span><span class="s1">) {</span>
              <span class="s1">safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, instance);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s1">recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);</span>
          <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s2">case </span><span class="s1">ScopeComponent:</span>
        <span class="s1">{</span>

          <span class="s1">recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);</span>
          <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s2">case </span><span class="s1">OffscreenComponent:</span>
        <span class="s1">{</span>
          <span class="s1">{</span>
            <span class="s1">recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);</span>
          <span class="s1">}</span>

          <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s2">default</span><span class="s1">:</span>
        <span class="s1">{</span>
          <span class="s1">recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);</span>
          <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">commitSuspenseCallback(finishedWork) {</span>
    <span class="s0">// TODO: Move this to passive phase</span>
    <span class="s2">var </span><span class="s1">newState = finishedWork.memoizedState;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">attachSuspenseRetryListeners(finishedWork) {</span>
    <span class="s0">// If this boundary just timed out, then it will have a set of wakeables.</span>
    <span class="s0">// For each wakeable, attach a listener so that when it resolves, React</span>
    <span class="s0">// attempts to re-render the boundary in the primary (pre-timeout) state.</span>
    <span class="s2">var </span><span class="s1">wakeables = finishedWork.updateQueue;</span>

    <span class="s2">if </span><span class="s1">(wakeables !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">finishedWork.updateQueue = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s2">var </span><span class="s1">retryCache = finishedWork.stateNode;</span>

      <span class="s2">if </span><span class="s1">(retryCache === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">retryCache = finishedWork.stateNode = </span><span class="s2">new </span><span class="s1">PossiblyWeakSet();</span>
      <span class="s1">}</span>

      <span class="s1">wakeables.forEach(</span><span class="s2">function </span><span class="s1">(wakeable) {</span>
        <span class="s0">// Memoize using the boundary fiber to prevent redundant listeners.</span>
        <span class="s2">var </span><span class="s1">retry = resolveRetryWakeable.bind(</span><span class="s2">null</span><span class="s1">, finishedWork, wakeable);</span>

        <span class="s2">if </span><span class="s1">(!retryCache.has(wakeable)) {</span>
          <span class="s1">retryCache.add(wakeable);</span>

          <span class="s1">wakeable.then(retry, retry);</span>
        <span class="s1">}</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s0">// This function detects when a Suspense boundary goes from visible to hidden.</span>
  <span class="s2">function </span><span class="s1">commitMutationEffects(root, finishedWork, committedLanes) {</span>
    <span class="s1">setCurrentFiber(finishedWork);</span>
    <span class="s1">commitMutationEffectsOnFiber(finishedWork, root);</span>
    <span class="s1">setCurrentFiber(finishedWork);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">recursivelyTraverseMutationEffects(root, parentFiber, lanes) {</span>
    <span class="s0">// Deletions effects can be scheduled on any fiber type. They need to happen</span>
    <span class="s0">// before the children effects hae fired.</span>
    <span class="s2">var </span><span class="s1">deletions = parentFiber.deletions;</span>

    <span class="s2">if </span><span class="s1">(deletions !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; deletions.length; i++) {</span>
        <span class="s2">var </span><span class="s1">childToDelete = deletions[i];</span>

        <span class="s2">try </span><span class="s1">{</span>
          <span class="s1">commitDeletionEffects(root, parentFiber, childToDelete);</span>
        <span class="s1">} </span><span class="s2">catch </span><span class="s1">(error) {</span>
          <span class="s1">captureCommitPhaseError(childToDelete, parentFiber, error);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">prevDebugFiber = getCurrentFiber();</span>

    <span class="s2">if </span><span class="s1">(parentFiber.subtreeFlags &amp; MutationMask) {</span>
      <span class="s2">var </span><span class="s1">child = parentFiber.child;</span>

      <span class="s2">while </span><span class="s1">(child !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">setCurrentFiber(child);</span>
        <span class="s1">commitMutationEffectsOnFiber(child, root);</span>
        <span class="s1">child = child.sibling;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">setCurrentFiber(prevDebugFiber);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">commitMutationEffectsOnFiber(finishedWork, root, lanes) {</span>
    <span class="s2">var </span><span class="s1">current = finishedWork.alternate;</span>
    <span class="s2">var </span><span class="s1">flags = finishedWork.flags; </span><span class="s0">// The effect flag should be checked *after* we refine the type of fiber,</span>
    <span class="s0">// because the fiber tag is more specific. An exception is any flag related</span>
    <span class="s0">// to reconcilation, because those can be set on all fiber types.</span>

    <span class="s2">switch </span><span class="s1">(finishedWork.tag) {</span>
      <span class="s2">case </span><span class="s1">FunctionComponent:</span>
      <span class="s2">case </span><span class="s1">ForwardRef:</span>
      <span class="s2">case </span><span class="s1">MemoComponent:</span>
      <span class="s2">case </span><span class="s1">SimpleMemoComponent:</span>
        <span class="s1">{</span>
          <span class="s1">recursivelyTraverseMutationEffects(root, finishedWork);</span>
          <span class="s1">commitReconciliationEffects(finishedWork);</span>

          <span class="s2">if </span><span class="s1">(flags &amp; Update) {</span>
            <span class="s2">try </span><span class="s1">{</span>
              <span class="s1">commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.</span><span class="s2">return</span><span class="s1">);</span>
              <span class="s1">commitHookEffectListMount(Insertion | HasEffect, finishedWork);</span>
            <span class="s1">} </span><span class="s2">catch </span><span class="s1">(error) {</span>
              <span class="s1">captureCommitPhaseError(finishedWork, finishedWork.</span><span class="s2">return</span><span class="s1">, error);</span>
            <span class="s1">} </span><span class="s0">// Layout effects are destroyed during the mutation phase so that all</span>
            <span class="s0">// destroy functions for all fibers are called before any create functions.</span>
            <span class="s0">// This prevents sibling component effects from interfering with each other,</span>
            <span class="s0">// e.g. a destroy function in one component should never override a ref set</span>
            <span class="s0">// by a create function in another component during the same commit.</span>


            <span class="s2">if </span><span class="s1">( finishedWork.mode &amp; ProfileMode) {</span>
              <span class="s2">try </span><span class="s1">{</span>
                <span class="s1">startLayoutEffectTimer();</span>
                <span class="s1">commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.</span><span class="s2">return</span><span class="s1">);</span>
              <span class="s1">} </span><span class="s2">catch </span><span class="s1">(error) {</span>
                <span class="s1">captureCommitPhaseError(finishedWork, finishedWork.</span><span class="s2">return</span><span class="s1">, error);</span>
              <span class="s1">}</span>

              <span class="s1">recordLayoutEffectDuration(finishedWork);</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
              <span class="s2">try </span><span class="s1">{</span>
                <span class="s1">commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.</span><span class="s2">return</span><span class="s1">);</span>
              <span class="s1">} </span><span class="s2">catch </span><span class="s1">(error) {</span>
                <span class="s1">captureCommitPhaseError(finishedWork, finishedWork.</span><span class="s2">return</span><span class="s1">, error);</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s2">case </span><span class="s1">ClassComponent:</span>
        <span class="s1">{</span>
          <span class="s1">recursivelyTraverseMutationEffects(root, finishedWork);</span>
          <span class="s1">commitReconciliationEffects(finishedWork);</span>

          <span class="s2">if </span><span class="s1">(flags &amp; Ref) {</span>
            <span class="s2">if </span><span class="s1">(current !== </span><span class="s2">null</span><span class="s1">) {</span>
              <span class="s1">safelyDetachRef(current, current.</span><span class="s2">return</span><span class="s1">);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s2">case </span><span class="s1">HostComponent:</span>
        <span class="s1">{</span>
          <span class="s1">recursivelyTraverseMutationEffects(root, finishedWork);</span>
          <span class="s1">commitReconciliationEffects(finishedWork);</span>

          <span class="s2">if </span><span class="s1">(flags &amp; Ref) {</span>
            <span class="s2">if </span><span class="s1">(current !== </span><span class="s2">null</span><span class="s1">) {</span>
              <span class="s1">safelyDetachRef(current, current.</span><span class="s2">return</span><span class="s1">);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s1">{</span>
            <span class="s0">// TODO: ContentReset gets cleared by the children during the commit</span>
            <span class="s0">// phase. This is a refactor hazard because it means we must read</span>
            <span class="s0">// flags the flags after `commitReconciliationEffects` has already run;</span>
            <span class="s0">// the order matters. We should refactor so that ContentReset does not</span>
            <span class="s0">// rely on mutating the flag during commit. Like by setting a flag</span>
            <span class="s0">// during the render phase instead.</span>
            <span class="s2">if </span><span class="s1">(finishedWork.flags &amp; ContentReset) {</span>
              <span class="s2">var </span><span class="s1">instance = finishedWork.stateNode;</span>

              <span class="s2">try </span><span class="s1">{</span>
                <span class="s1">resetTextContent(instance);</span>
              <span class="s1">} </span><span class="s2">catch </span><span class="s1">(error) {</span>
                <span class="s1">captureCommitPhaseError(finishedWork, finishedWork.</span><span class="s2">return</span><span class="s1">, error);</span>
              <span class="s1">}</span>
            <span class="s1">}</span>

            <span class="s2">if </span><span class="s1">(flags &amp; Update) {</span>
              <span class="s2">var </span><span class="s1">_instance4 = finishedWork.stateNode;</span>

              <span class="s2">if </span><span class="s1">(_instance4 != </span><span class="s2">null</span><span class="s1">) {</span>
                <span class="s0">// Commit the work prepared earlier.</span>
                <span class="s2">var </span><span class="s1">newProps = finishedWork.memoizedProps; </span><span class="s0">// For hydration we reuse the update path but we treat the oldProps</span>
                <span class="s0">// as the newProps. The updatePayload will contain the real change in</span>
                <span class="s0">// this case.</span>

                <span class="s2">var </span><span class="s1">oldProps = current !== </span><span class="s2">null </span><span class="s1">? current.memoizedProps : newProps;</span>
                <span class="s2">var </span><span class="s1">type = finishedWork.type; </span><span class="s0">// TODO: Type the updateQueue to be specific to host components.</span>

                <span class="s2">var </span><span class="s1">updatePayload = finishedWork.updateQueue;</span>
                <span class="s1">finishedWork.updateQueue = </span><span class="s2">null</span><span class="s1">;</span>

                <span class="s2">if </span><span class="s1">(updatePayload !== </span><span class="s2">null</span><span class="s1">) {</span>
                  <span class="s2">try </span><span class="s1">{</span>
                    <span class="s1">commitUpdate(_instance4, updatePayload, type, oldProps, newProps, finishedWork);</span>
                  <span class="s1">} </span><span class="s2">catch </span><span class="s1">(error) {</span>
                    <span class="s1">captureCommitPhaseError(finishedWork, finishedWork.</span><span class="s2">return</span><span class="s1">, error);</span>
                  <span class="s1">}</span>
                <span class="s1">}</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s2">case </span><span class="s1">HostText:</span>
        <span class="s1">{</span>
          <span class="s1">recursivelyTraverseMutationEffects(root, finishedWork);</span>
          <span class="s1">commitReconciliationEffects(finishedWork);</span>

          <span class="s2">if </span><span class="s1">(flags &amp; Update) {</span>
            <span class="s1">{</span>
              <span class="s2">if </span><span class="s1">(finishedWork.stateNode === </span><span class="s2">null</span><span class="s1">) {</span>
                <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'This should have a text node initialized. This error is likely ' </span><span class="s1">+ </span><span class="s3">'caused by a bug in React. Please file an issue.'</span><span class="s1">);</span>
              <span class="s1">}</span>

              <span class="s2">var </span><span class="s1">textInstance = finishedWork.stateNode;</span>
              <span class="s2">var </span><span class="s1">newText = finishedWork.memoizedProps; </span><span class="s0">// For hydration we reuse the update path but we treat the oldProps</span>
              <span class="s0">// as the newProps. The updatePayload will contain the real change in</span>
              <span class="s0">// this case.</span>

              <span class="s2">var </span><span class="s1">oldText = current !== </span><span class="s2">null </span><span class="s1">? current.memoizedProps : newText;</span>

              <span class="s2">try </span><span class="s1">{</span>
                <span class="s1">commitTextUpdate(textInstance, oldText, newText);</span>
              <span class="s1">} </span><span class="s2">catch </span><span class="s1">(error) {</span>
                <span class="s1">captureCommitPhaseError(finishedWork, finishedWork.</span><span class="s2">return</span><span class="s1">, error);</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s2">case </span><span class="s1">HostRoot:</span>
        <span class="s1">{</span>
          <span class="s1">recursivelyTraverseMutationEffects(root, finishedWork);</span>
          <span class="s1">commitReconciliationEffects(finishedWork);</span>

          <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s2">case </span><span class="s1">HostPortal:</span>
        <span class="s1">{</span>
          <span class="s1">recursivelyTraverseMutationEffects(root, finishedWork);</span>
          <span class="s1">commitReconciliationEffects(finishedWork);</span>

          <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s2">case </span><span class="s1">SuspenseComponent:</span>
        <span class="s1">{</span>
          <span class="s1">recursivelyTraverseMutationEffects(root, finishedWork);</span>
          <span class="s1">commitReconciliationEffects(finishedWork);</span>
          <span class="s2">var </span><span class="s1">offscreenFiber = finishedWork.child;</span>

          <span class="s2">if </span><span class="s1">(offscreenFiber.flags &amp; Visibility) {</span>
            <span class="s2">var </span><span class="s1">offscreenInstance = offscreenFiber.stateNode;</span>
            <span class="s2">var </span><span class="s1">newState = offscreenFiber.memoizedState;</span>
            <span class="s2">var </span><span class="s1">isHidden = newState !== </span><span class="s2">null</span><span class="s1">; </span><span class="s0">// Track the current state on the Offscreen instance so we can</span>
            <span class="s0">// read it during an event</span>

            <span class="s1">offscreenInstance.isHidden = isHidden;</span>

            <span class="s2">if </span><span class="s1">(isHidden) {</span>
              <span class="s2">var </span><span class="s1">wasHidden = offscreenFiber.alternate !== </span><span class="s2">null </span><span class="s1">&amp;&amp; offscreenFiber.alternate.memoizedState !== </span><span class="s2">null</span><span class="s1">;</span>

              <span class="s2">if </span><span class="s1">(!wasHidden) {</span>
                <span class="s0">// TODO: Move to passive phase</span>
                <span class="s1">markCommitTimeOfFallback();</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s2">if </span><span class="s1">(flags &amp; Update) {</span>
            <span class="s2">try </span><span class="s1">{</span>
              <span class="s1">commitSuspenseCallback(finishedWork);</span>
            <span class="s1">} </span><span class="s2">catch </span><span class="s1">(error) {</span>
              <span class="s1">captureCommitPhaseError(finishedWork, finishedWork.</span><span class="s2">return</span><span class="s1">, error);</span>
            <span class="s1">}</span>

            <span class="s1">attachSuspenseRetryListeners(finishedWork);</span>
          <span class="s1">}</span>

          <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s2">case </span><span class="s1">OffscreenComponent:</span>
        <span class="s1">{</span>
          <span class="s2">var </span><span class="s1">_wasHidden = current !== </span><span class="s2">null </span><span class="s1">&amp;&amp; current.memoizedState !== </span><span class="s2">null</span><span class="s1">;</span>

          <span class="s1">{</span>
            <span class="s1">recursivelyTraverseMutationEffects(root, finishedWork);</span>
          <span class="s1">}</span>

          <span class="s1">commitReconciliationEffects(finishedWork);</span>

          <span class="s2">if </span><span class="s1">(flags &amp; Visibility) {</span>
            <span class="s2">var </span><span class="s1">_offscreenInstance = finishedWork.stateNode;</span>
            <span class="s2">var </span><span class="s1">_newState = finishedWork.memoizedState;</span>

            <span class="s2">var </span><span class="s1">_isHidden = _newState !== </span><span class="s2">null</span><span class="s1">;</span>

            <span class="s2">var </span><span class="s1">offscreenBoundary = finishedWork; </span><span class="s0">// Track the current state on the Offscreen instance so we can</span>
            <span class="s0">// read it during an event</span>

            <span class="s1">_offscreenInstance.isHidden = _isHidden;</span>

            <span class="s1">{</span>
              <span class="s0">// TODO: This needs to run whenever there's an insertion or update</span>
              <span class="s0">// inside a hidden Offscreen tree.</span>
              <span class="s1">hideOrUnhideAllChildren(offscreenBoundary, _isHidden);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s2">case </span><span class="s1">SuspenseListComponent:</span>
        <span class="s1">{</span>
          <span class="s1">recursivelyTraverseMutationEffects(root, finishedWork);</span>
          <span class="s1">commitReconciliationEffects(finishedWork);</span>

          <span class="s2">if </span><span class="s1">(flags &amp; Update) {</span>
            <span class="s1">attachSuspenseRetryListeners(finishedWork);</span>
          <span class="s1">}</span>

          <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s2">case </span><span class="s1">ScopeComponent:</span>
        <span class="s1">{</span>

          <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s2">default</span><span class="s1">:</span>
        <span class="s1">{</span>
          <span class="s1">recursivelyTraverseMutationEffects(root, finishedWork);</span>
          <span class="s1">commitReconciliationEffects(finishedWork);</span>
          <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">commitReconciliationEffects(finishedWork) {</span>
    <span class="s0">// Placement effects (insertions, reorders) can be scheduled on any fiber</span>
    <span class="s0">// type. They needs to happen after the children effects have fired, but</span>
    <span class="s0">// before the effects on this fiber have fired.</span>
    <span class="s2">var </span><span class="s1">flags = finishedWork.flags;</span>

    <span class="s2">if </span><span class="s1">(flags &amp; Placement) {</span>
      <span class="s2">try </span><span class="s1">{</span>
        <span class="s1">commitPlacement(finishedWork);</span>
      <span class="s1">} </span><span class="s2">catch </span><span class="s1">(error) {</span>
        <span class="s1">captureCommitPhaseError(finishedWork, finishedWork.</span><span class="s2">return</span><span class="s1">, error);</span>
      <span class="s1">} </span><span class="s0">// Clear the &quot;placement&quot; from effect tag so that we know that this is</span>
      <span class="s0">// inserted, before any life-cycles like componentDidMount gets called.</span>
      <span class="s0">// TODO: findDOMNode doesn't rely on this any more but isMounted does</span>
      <span class="s0">// and isMounted is deprecated anyway so we should be able to kill this.</span>


      <span class="s1">finishedWork.flags &amp;= ~Placement;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(flags &amp; Hydrating) {</span>
      <span class="s1">finishedWork.flags &amp;= ~Hydrating;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">commitLayoutEffects(finishedWork, root, committedLanes) {</span>
    <span class="s1">nextEffect = finishedWork;</span>
    <span class="s1">commitLayoutEffects_begin(finishedWork, root, committedLanes);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">commitLayoutEffects_begin(subtreeRoot, root, committedLanes) {</span>
    <span class="s0">// Suspense layout effects semantics don't change for legacy roots.</span>
    <span class="s2">var </span><span class="s1">isModernRoot = (subtreeRoot.mode &amp; ConcurrentMode) !== NoMode;</span>

    <span class="s2">while </span><span class="s1">(nextEffect !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">fiber = nextEffect;</span>
      <span class="s2">var </span><span class="s1">firstChild = fiber.child;</span>

      <span class="s2">if </span><span class="s1">((fiber.subtreeFlags &amp; LayoutMask) !== NoFlags &amp;&amp; firstChild !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">firstChild.</span><span class="s2">return </span><span class="s1">= fiber;</span>
        <span class="s1">nextEffect = firstChild;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes) {</span>
    <span class="s2">while </span><span class="s1">(nextEffect !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">fiber = nextEffect;</span>

      <span class="s2">if </span><span class="s1">((fiber.flags &amp; LayoutMask) !== NoFlags) {</span>
        <span class="s2">var </span><span class="s1">current = fiber.alternate;</span>
        <span class="s1">setCurrentFiber(fiber);</span>

        <span class="s2">try </span><span class="s1">{</span>
          <span class="s1">commitLayoutEffectOnFiber(root, current, fiber, committedLanes);</span>
        <span class="s1">} </span><span class="s2">catch </span><span class="s1">(error) {</span>
          <span class="s1">captureCommitPhaseError(fiber, fiber.</span><span class="s2">return</span><span class="s1">, error);</span>
        <span class="s1">}</span>

        <span class="s1">resetCurrentFiber();</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(fiber === subtreeRoot) {</span>
        <span class="s1">nextEffect = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">sibling = fiber.sibling;</span>

      <span class="s2">if </span><span class="s1">(sibling !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">sibling.</span><span class="s2">return </span><span class="s1">= fiber.</span><span class="s2">return</span><span class="s1">;</span>
        <span class="s1">nextEffect = sibling;</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">nextEffect = fiber.</span><span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">commitPassiveMountEffects(root, finishedWork, committedLanes, committedTransitions) {</span>
    <span class="s1">nextEffect = finishedWork;</span>
    <span class="s1">commitPassiveMountEffects_begin(finishedWork, root, committedLanes, committedTransitions);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">commitPassiveMountEffects_begin(subtreeRoot, root, committedLanes, committedTransitions) {</span>
    <span class="s2">while </span><span class="s1">(nextEffect !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">fiber = nextEffect;</span>
      <span class="s2">var </span><span class="s1">firstChild = fiber.child;</span>

      <span class="s2">if </span><span class="s1">((fiber.subtreeFlags &amp; PassiveMask) !== NoFlags &amp;&amp; firstChild !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">firstChild.</span><span class="s2">return </span><span class="s1">= fiber;</span>
        <span class="s1">nextEffect = firstChild;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">commitPassiveMountEffects_complete(subtreeRoot, root, committedLanes, committedTransitions);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">commitPassiveMountEffects_complete(subtreeRoot, root, committedLanes, committedTransitions) {</span>
    <span class="s2">while </span><span class="s1">(nextEffect !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">fiber = nextEffect;</span>

      <span class="s2">if </span><span class="s1">((fiber.flags &amp; Passive) !== NoFlags) {</span>
        <span class="s1">setCurrentFiber(fiber);</span>

        <span class="s2">try </span><span class="s1">{</span>
          <span class="s1">commitPassiveMountOnFiber(root, fiber, committedLanes, committedTransitions);</span>
        <span class="s1">} </span><span class="s2">catch </span><span class="s1">(error) {</span>
          <span class="s1">captureCommitPhaseError(fiber, fiber.</span><span class="s2">return</span><span class="s1">, error);</span>
        <span class="s1">}</span>

        <span class="s1">resetCurrentFiber();</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(fiber === subtreeRoot) {</span>
        <span class="s1">nextEffect = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">sibling = fiber.sibling;</span>

      <span class="s2">if </span><span class="s1">(sibling !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">sibling.</span><span class="s2">return </span><span class="s1">= fiber.</span><span class="s2">return</span><span class="s1">;</span>
        <span class="s1">nextEffect = sibling;</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">nextEffect = fiber.</span><span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {</span>
    <span class="s2">switch </span><span class="s1">(finishedWork.tag) {</span>
      <span class="s2">case </span><span class="s1">FunctionComponent:</span>
      <span class="s2">case </span><span class="s1">ForwardRef:</span>
      <span class="s2">case </span><span class="s1">SimpleMemoComponent:</span>
        <span class="s1">{</span>
          <span class="s2">if </span><span class="s1">( finishedWork.mode &amp; ProfileMode) {</span>
            <span class="s1">startPassiveEffectTimer();</span>

            <span class="s2">try </span><span class="s1">{</span>
              <span class="s1">commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);</span>
            <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
              <span class="s1">recordPassiveEffectDuration(finishedWork);</span>
            <span class="s1">}</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);</span>
          <span class="s1">}</span>

          <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">commitPassiveUnmountEffects(firstChild) {</span>
    <span class="s1">nextEffect = firstChild;</span>
    <span class="s1">commitPassiveUnmountEffects_begin();</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">commitPassiveUnmountEffects_begin() {</span>
    <span class="s2">while </span><span class="s1">(nextEffect !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">fiber = nextEffect;</span>
      <span class="s2">var </span><span class="s1">child = fiber.child;</span>

      <span class="s2">if </span><span class="s1">((nextEffect.flags &amp; ChildDeletion) !== NoFlags) {</span>
        <span class="s2">var </span><span class="s1">deletions = fiber.deletions;</span>

        <span class="s2">if </span><span class="s1">(deletions !== </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; deletions.length; i++) {</span>
            <span class="s2">var </span><span class="s1">fiberToDelete = deletions[i];</span>
            <span class="s1">nextEffect = fiberToDelete;</span>
            <span class="s1">commitPassiveUnmountEffectsInsideOfDeletedTree_begin(fiberToDelete, fiber);</span>
          <span class="s1">}</span>

          <span class="s1">{</span>
            <span class="s0">// A fiber was deleted from this parent fiber, but it's still part of</span>
            <span class="s0">// the previous (alternate) parent fiber's list of children. Because</span>
            <span class="s0">// children are a linked list, an earlier sibling that's still alive</span>
            <span class="s0">// will be connected to the deleted fiber via its `alternate`:</span>
            <span class="s0">//</span>
            <span class="s0">//   live fiber</span>
            <span class="s0">//   --alternate--&gt; previous live fiber</span>
            <span class="s0">//   --sibling--&gt; deleted fiber</span>
            <span class="s0">//</span>
            <span class="s0">// We can't disconnect `alternate` on nodes that haven't been deleted</span>
            <span class="s0">// yet, but we can disconnect the `sibling` and `child` pointers.</span>
            <span class="s2">var </span><span class="s1">previousFiber = fiber.alternate;</span>

            <span class="s2">if </span><span class="s1">(previousFiber !== </span><span class="s2">null</span><span class="s1">) {</span>
              <span class="s2">var </span><span class="s1">detachedChild = previousFiber.child;</span>

              <span class="s2">if </span><span class="s1">(detachedChild !== </span><span class="s2">null</span><span class="s1">) {</span>
                <span class="s1">previousFiber.child = </span><span class="s2">null</span><span class="s1">;</span>

                <span class="s2">do </span><span class="s1">{</span>
                  <span class="s2">var </span><span class="s1">detachedSibling = detachedChild.sibling;</span>
                  <span class="s1">detachedChild.sibling = </span><span class="s2">null</span><span class="s1">;</span>
                  <span class="s1">detachedChild = detachedSibling;</span>
                <span class="s1">} </span><span class="s2">while </span><span class="s1">(detachedChild !== </span><span class="s2">null</span><span class="s1">);</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s1">nextEffect = fiber;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">((fiber.subtreeFlags &amp; PassiveMask) !== NoFlags &amp;&amp; child !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">child.</span><span class="s2">return </span><span class="s1">= fiber;</span>
        <span class="s1">nextEffect = child;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">commitPassiveUnmountEffects_complete();</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">commitPassiveUnmountEffects_complete() {</span>
    <span class="s2">while </span><span class="s1">(nextEffect !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">fiber = nextEffect;</span>

      <span class="s2">if </span><span class="s1">((fiber.flags &amp; Passive) !== NoFlags) {</span>
        <span class="s1">setCurrentFiber(fiber);</span>
        <span class="s1">commitPassiveUnmountOnFiber(fiber);</span>
        <span class="s1">resetCurrentFiber();</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">sibling = fiber.sibling;</span>

      <span class="s2">if </span><span class="s1">(sibling !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">sibling.</span><span class="s2">return </span><span class="s1">= fiber.</span><span class="s2">return</span><span class="s1">;</span>
        <span class="s1">nextEffect = sibling;</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">nextEffect = fiber.</span><span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">commitPassiveUnmountOnFiber(finishedWork) {</span>
    <span class="s2">switch </span><span class="s1">(finishedWork.tag) {</span>
      <span class="s2">case </span><span class="s1">FunctionComponent:</span>
      <span class="s2">case </span><span class="s1">ForwardRef:</span>
      <span class="s2">case </span><span class="s1">SimpleMemoComponent:</span>
        <span class="s1">{</span>
          <span class="s2">if </span><span class="s1">( finishedWork.mode &amp; ProfileMode) {</span>
            <span class="s1">startPassiveEffectTimer();</span>
            <span class="s1">commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.</span><span class="s2">return</span><span class="s1">);</span>
            <span class="s1">recordPassiveEffectDuration(finishedWork);</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.</span><span class="s2">return</span><span class="s1">);</span>
          <span class="s1">}</span>

          <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {</span>
    <span class="s2">while </span><span class="s1">(nextEffect !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">fiber = nextEffect; </span><span class="s0">// Deletion effects fire in parent -&gt; child order</span>
      <span class="s0">// TODO: Check if fiber has a PassiveStatic flag</span>

      <span class="s1">setCurrentFiber(fiber);</span>
      <span class="s1">commitPassiveUnmountInsideDeletedTreeOnFiber(fiber, nearestMountedAncestor);</span>
      <span class="s1">resetCurrentFiber();</span>
      <span class="s2">var </span><span class="s1">child = fiber.child; </span><span class="s0">// TODO: Only traverse subtree if it has a PassiveStatic flag. (But, if we</span>
      <span class="s0">// do this, still need to handle `deletedTreeCleanUpLevel` correctly.)</span>

      <span class="s2">if </span><span class="s1">(child !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">child.</span><span class="s2">return </span><span class="s1">= fiber;</span>
        <span class="s1">nextEffect = child;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot) {</span>
    <span class="s2">while </span><span class="s1">(nextEffect !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">fiber = nextEffect;</span>
      <span class="s2">var </span><span class="s1">sibling = fiber.sibling;</span>
      <span class="s2">var </span><span class="s1">returnFiber = fiber.</span><span class="s2">return</span><span class="s1">;</span>

      <span class="s1">{</span>
        <span class="s0">// Recursively traverse the entire deleted tree and clean up fiber fields.</span>
        <span class="s0">// This is more aggressive than ideal, and the long term goal is to only</span>
        <span class="s0">// have to detach the deleted tree at the root.</span>
        <span class="s1">detachFiberAfterEffects(fiber);</span>

        <span class="s2">if </span><span class="s1">(fiber === deletedSubtreeRoot) {</span>
          <span class="s1">nextEffect = </span><span class="s2">null</span><span class="s1">;</span>
          <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(sibling !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">sibling.</span><span class="s2">return </span><span class="s1">= returnFiber;</span>
        <span class="s1">nextEffect = sibling;</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">nextEffect = returnFiber;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">commitPassiveUnmountInsideDeletedTreeOnFiber(current, nearestMountedAncestor) {</span>
    <span class="s2">switch </span><span class="s1">(current.tag) {</span>
      <span class="s2">case </span><span class="s1">FunctionComponent:</span>
      <span class="s2">case </span><span class="s1">ForwardRef:</span>
      <span class="s2">case </span><span class="s1">SimpleMemoComponent:</span>
        <span class="s1">{</span>
          <span class="s2">if </span><span class="s1">( current.mode &amp; ProfileMode) {</span>
            <span class="s1">startPassiveEffectTimer();</span>
            <span class="s1">commitHookEffectListUnmount(Passive$1, current, nearestMountedAncestor);</span>
            <span class="s1">recordPassiveEffectDuration(current);</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">commitHookEffectListUnmount(Passive$1, current, nearestMountedAncestor);</span>
          <span class="s1">}</span>

          <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s0">// TODO: Reuse reappearLayoutEffects traversal here?</span>

  <span class="s2">var </span><span class="s1">COMPONENT_TYPE = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">HAS_PSEUDO_CLASS_TYPE = </span><span class="s4">1</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">ROLE_TYPE = </span><span class="s4">2</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">TEST_NAME_TYPE = </span><span class="s4">3</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">TEXT_TYPE = </span><span class="s4">4</span><span class="s1">;</span>

  <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">Symbol === </span><span class="s3">'function' </span><span class="s1">&amp;&amp; Symbol.</span><span class="s2">for</span><span class="s1">) {</span>
    <span class="s2">var </span><span class="s1">symbolFor = Symbol.</span><span class="s2">for</span><span class="s1">;</span>
    <span class="s1">COMPONENT_TYPE = symbolFor(</span><span class="s3">'selector.component'</span><span class="s1">);</span>
    <span class="s1">HAS_PSEUDO_CLASS_TYPE = symbolFor(</span><span class="s3">'selector.has_pseudo_class'</span><span class="s1">);</span>
    <span class="s1">ROLE_TYPE = symbolFor(</span><span class="s3">'selector.role'</span><span class="s1">);</span>
    <span class="s1">TEST_NAME_TYPE = symbolFor(</span><span class="s3">'selector.test_id'</span><span class="s1">);</span>
    <span class="s1">TEXT_TYPE = symbolFor(</span><span class="s3">'selector.text'</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">ReactCurrentActQueue = ReactSharedInternals.ReactCurrentActQueue;</span>
  <span class="s2">function </span><span class="s1">isLegacyActEnvironment(fiber) {</span>
    <span class="s1">{</span>
      <span class="s0">// Legacy mode. We preserve the behavior of React 17's act. It assumes an</span>
      <span class="s0">// act environment whenever `jest` is defined, but you can still turn off</span>
      <span class="s0">// spurious warnings by setting IS_REACT_ACT_ENVIRONMENT explicitly</span>
      <span class="s0">// to false.</span>
      <span class="s2">var </span><span class="s1">isReactActEnvironmentGlobal = </span><span class="s0">// $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global</span>
      <span class="s2">typeof </span><span class="s1">IS_REACT_ACT_ENVIRONMENT !== </span><span class="s3">'undefined' </span><span class="s1">? IS_REACT_ACT_ENVIRONMENT : undefined; </span><span class="s0">// $FlowExpectedError - Flow doesn't know about jest</span>

      <span class="s2">var </span><span class="s1">jestIsDefined = </span><span class="s2">typeof </span><span class="s1">jest !== </span><span class="s3">'undefined'</span><span class="s1">;</span>
      <span class="s2">return  </span><span class="s1">jestIsDefined &amp;&amp; isReactActEnvironmentGlobal !== </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">isConcurrentActEnvironment() {</span>
    <span class="s1">{</span>
      <span class="s2">var </span><span class="s1">isReactActEnvironmentGlobal = </span><span class="s0">// $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global</span>
      <span class="s2">typeof </span><span class="s1">IS_REACT_ACT_ENVIRONMENT !== </span><span class="s3">'undefined' </span><span class="s1">? IS_REACT_ACT_ENVIRONMENT : undefined;</span>

      <span class="s2">if </span><span class="s1">(!isReactActEnvironmentGlobal &amp;&amp; ReactCurrentActQueue.current !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s0">// TODO: Include link to relevant documentation page.</span>
        <span class="s1">error(</span><span class="s3">'The current testing environment is not configured to support ' </span><span class="s1">+ </span><span class="s3">'act(...)'</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s2">return </span><span class="s1">isReactActEnvironmentGlobal;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">ceil = Math.ceil;</span>
  <span class="s2">var </span><span class="s1">ReactCurrentDispatcher$2 = ReactSharedInternals.ReactCurrentDispatcher,</span>
      <span class="s1">ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner,</span>
      <span class="s1">ReactCurrentBatchConfig$2 = ReactSharedInternals.ReactCurrentBatchConfig,</span>
      <span class="s1">ReactCurrentActQueue$1 = ReactSharedInternals.ReactCurrentActQueue;</span>
  <span class="s2">var </span><span class="s1">NoContext =</span>
  <span class="s0">/*             */</span>
  <span class="s4">0</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">BatchedContext =</span>
  <span class="s0">/*               */</span>
  <span class="s4">1</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">RenderContext =</span>
  <span class="s0">/*                */</span>
  <span class="s4">2</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">CommitContext =</span>
  <span class="s0">/*                */</span>
  <span class="s4">4</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">RootInProgress = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">RootFatalErrored = </span><span class="s4">1</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">RootErrored = </span><span class="s4">2</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">RootSuspended = </span><span class="s4">3</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">RootSuspendedWithDelay = </span><span class="s4">4</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">RootCompleted = </span><span class="s4">5</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">RootDidNotComplete = </span><span class="s4">6</span><span class="s1">; </span><span class="s0">// Describes where we are in the React execution stack</span>

  <span class="s2">var </span><span class="s1">executionContext = NoContext; </span><span class="s0">// The root we're working on</span>

  <span class="s2">var </span><span class="s1">workInProgressRoot = </span><span class="s2">null</span><span class="s1">; </span><span class="s0">// The fiber we're working on</span>

  <span class="s2">var </span><span class="s1">workInProgress = </span><span class="s2">null</span><span class="s1">; </span><span class="s0">// The lanes we're rendering</span>

  <span class="s2">var </span><span class="s1">workInProgressRootRenderLanes = NoLanes; </span><span class="s0">// Stack that allows components to change the render lanes for its subtree</span>
  <span class="s0">// This is a superset of the lanes we started working on at the root. The only</span>
  <span class="s0">// case where it's different from `workInProgressRootRenderLanes` is when we</span>
  <span class="s0">// enter a subtree that is hidden and needs to be unhidden: Suspense and</span>
  <span class="s0">// Offscreen component.</span>
  <span class="s0">//</span>
  <span class="s0">// Most things in the work loop should deal with workInProgressRootRenderLanes.</span>
  <span class="s0">// Most things in begin/complete phases should deal with subtreeRenderLanes.</span>

  <span class="s2">var </span><span class="s1">subtreeRenderLanes = NoLanes;</span>
  <span class="s2">var </span><span class="s1">subtreeRenderLanesCursor = createCursor(NoLanes); </span><span class="s0">// Whether to root completed, errored, suspended, etc.</span>

  <span class="s2">var </span><span class="s1">workInProgressRootExitStatus = RootInProgress; </span><span class="s0">// A fatal error, if one is thrown</span>

  <span class="s2">var </span><span class="s1">workInProgressRootFatalError = </span><span class="s2">null</span><span class="s1">; </span><span class="s0">// &quot;Included&quot; lanes refer to lanes that were worked on during this render. It's</span>
  <span class="s0">// slightly different than `renderLanes` because `renderLanes` can change as you</span>
  <span class="s0">// enter and exit an Offscreen tree. This value is the combination of all render</span>
  <span class="s0">// lanes for the entire render phase.</span>

  <span class="s2">var </span><span class="s1">workInProgressRootIncludedLanes = NoLanes; </span><span class="s0">// The work left over by components that were visited during this render. Only</span>
  <span class="s0">// includes unprocessed updates, not work in bailed out children.</span>

  <span class="s2">var </span><span class="s1">workInProgressRootSkippedLanes = NoLanes; </span><span class="s0">// Lanes that were updated (in an interleaved event) during this render.</span>

  <span class="s2">var </span><span class="s1">workInProgressRootInterleavedUpdatedLanes = NoLanes; </span><span class="s0">// Lanes that were updated during the render phase (*not* an interleaved event).</span>

  <span class="s2">var </span><span class="s1">workInProgressRootPingedLanes = NoLanes; </span><span class="s0">// Errors that are thrown during the render phase.</span>

  <span class="s2">var </span><span class="s1">workInProgressRootConcurrentErrors = </span><span class="s2">null</span><span class="s1">; </span><span class="s0">// These are errors that we recovered from without surfacing them to the UI.</span>
  <span class="s0">// We will log them once the tree commits.</span>

  <span class="s2">var </span><span class="s1">workInProgressRootRecoverableErrors = </span><span class="s2">null</span><span class="s1">; </span><span class="s0">// The most recent time we committed a fallback. This lets us ensure a train</span>
  <span class="s0">// model where we don't commit new loading states in too quick succession.</span>

  <span class="s2">var </span><span class="s1">globalMostRecentFallbackTime = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">FALLBACK_THROTTLE_MS = </span><span class="s4">500</span><span class="s1">; </span><span class="s0">// The absolute time for when we should start giving up on rendering</span>
  <span class="s0">// more and prefer CPU suspense heuristics instead.</span>

  <span class="s2">var </span><span class="s1">workInProgressRootRenderTargetTime = Infinity; </span><span class="s0">// How long a render is supposed to take before we start following CPU</span>
  <span class="s0">// suspense heuristics and opt out of rendering more content.</span>

  <span class="s2">var </span><span class="s1">RENDER_TIMEOUT_MS = </span><span class="s4">500</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">workInProgressTransitions = </span><span class="s2">null</span><span class="s1">;</span>

  <span class="s2">function </span><span class="s1">resetRenderTimer() {</span>
    <span class="s1">workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">getRenderTargetTime() {</span>
    <span class="s2">return </span><span class="s1">workInProgressRootRenderTargetTime;</span>
  <span class="s1">}</span>
  <span class="s2">var </span><span class="s1">hasUncaughtError = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">firstUncaughtError = </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">legacyErrorBoundariesThatAlreadyFailed = </span><span class="s2">null</span><span class="s1">; </span><span class="s0">// Only used when enableProfilerNestedUpdateScheduledHook is true;</span>
  <span class="s2">var </span><span class="s1">rootDoesHavePassiveEffects = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">rootWithPendingPassiveEffects = </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">pendingPassiveEffectsLanes = NoLanes;</span>
  <span class="s2">var </span><span class="s1">pendingPassiveProfilerEffects = [];</span>
  <span class="s2">var </span><span class="s1">pendingPassiveTransitions = </span><span class="s2">null</span><span class="s1">; </span><span class="s0">// Use these to prevent an infinite loop of nested updates</span>

  <span class="s2">var </span><span class="s1">NESTED_UPDATE_LIMIT = </span><span class="s4">50</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">nestedUpdateCount = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">rootWithNestedUpdates = </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">isFlushingPassiveEffects = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">didScheduleUpdateDuringPassiveEffects = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">NESTED_PASSIVE_UPDATE_LIMIT = </span><span class="s4">50</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">nestedPassiveUpdateCount = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">rootWithPassiveNestedUpdates = </span><span class="s2">null</span><span class="s1">; </span><span class="s0">// If two updates are scheduled within the same event, we should treat their</span>
  <span class="s0">// event times as simultaneous, even if the actual clock time has advanced</span>
  <span class="s0">// between the first and second call.</span>

  <span class="s2">var </span><span class="s1">currentEventTime = NoTimestamp;</span>
  <span class="s2">var </span><span class="s1">currentEventTransitionLane = NoLanes;</span>
  <span class="s2">var </span><span class="s1">isRunningInsertionEffect = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s2">function </span><span class="s1">getWorkInProgressRoot() {</span>
    <span class="s2">return </span><span class="s1">workInProgressRoot;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">requestEventTime() {</span>
    <span class="s2">if </span><span class="s1">((executionContext &amp; (RenderContext | CommitContext)) !== NoContext) {</span>
      <span class="s0">// We're inside React, so it's fine to read the actual time.</span>
      <span class="s2">return </span><span class="s1">now();</span>
    <span class="s1">} </span><span class="s0">// We're not inside React, so we may be in the middle of a browser event.</span>


    <span class="s2">if </span><span class="s1">(currentEventTime !== NoTimestamp) {</span>
      <span class="s0">// Use the same start time for all updates until we enter React again.</span>
      <span class="s2">return </span><span class="s1">currentEventTime;</span>
    <span class="s1">} </span><span class="s0">// This is the first update since React yielded. Compute a new start time.</span>


    <span class="s1">currentEventTime = now();</span>
    <span class="s2">return </span><span class="s1">currentEventTime;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">requestUpdateLane(fiber) {</span>
    <span class="s0">// Special cases</span>
    <span class="s2">var </span><span class="s1">mode = fiber.mode;</span>

    <span class="s2">if </span><span class="s1">((mode &amp; ConcurrentMode) === NoMode) {</span>
      <span class="s2">return </span><span class="s1">SyncLane;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">( (executionContext &amp; RenderContext) !== NoContext &amp;&amp; workInProgressRootRenderLanes !== NoLanes) {</span>
      <span class="s0">// This is a render phase update. These are not officially supported. The</span>
      <span class="s0">// old behavior is to give this the same &quot;thread&quot; (lanes) as</span>
      <span class="s0">// whatever is currently rendering. So if you call `setState` on a component</span>
      <span class="s0">// that happens later in the same render, it will flush. Ideally, we want to</span>
      <span class="s0">// remove the special case and treat them as if they came from an</span>
      <span class="s0">// interleaved event. Regardless, this pattern is not officially supported.</span>
      <span class="s0">// This behavior is only a fallback. The flag only exists until we can roll</span>
      <span class="s0">// out the setState warning, since existing code might accidentally rely on</span>
      <span class="s0">// the current behavior.</span>
      <span class="s2">return </span><span class="s1">pickArbitraryLane(workInProgressRootRenderLanes);</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">isTransition = requestCurrentTransition() !== NoTransition;</span>

    <span class="s2">if </span><span class="s1">(isTransition) {</span>
      <span class="s2">if </span><span class="s1">( ReactCurrentBatchConfig$2.transition !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">var </span><span class="s1">transition = ReactCurrentBatchConfig$2.transition;</span>

        <span class="s2">if </span><span class="s1">(!transition._updatedFibers) {</span>
          <span class="s1">transition._updatedFibers = </span><span class="s2">new </span><span class="s1">Set();</span>
        <span class="s1">}</span>

        <span class="s1">transition._updatedFibers.add(fiber);</span>
      <span class="s1">} </span><span class="s0">// The algorithm for assigning an update to a lane should be stable for all</span>
      <span class="s0">// updates at the same priority within the same event. To do this, the</span>
      <span class="s0">// inputs to the algorithm must be the same.</span>
      <span class="s0">//</span>
      <span class="s0">// The trick we use is to cache the first of each of these inputs within an</span>
      <span class="s0">// event. Then reset the cached values once we can be sure the event is</span>
      <span class="s0">// over. Our heuristic for that is whenever we enter a concurrent work loop.</span>


      <span class="s2">if </span><span class="s1">(currentEventTransitionLane === NoLane) {</span>
        <span class="s0">// All transitions within the same event are assigned the same lane.</span>
        <span class="s1">currentEventTransitionLane = claimNextTransitionLane();</span>
      <span class="s1">}</span>

      <span class="s2">return </span><span class="s1">currentEventTransitionLane;</span>
    <span class="s1">} </span><span class="s0">// Updates originating inside certain React methods, like flushSync, have</span>
    <span class="s0">// their priority set by tracking it with a context variable.</span>
    <span class="s0">//</span>
    <span class="s0">// The opaque type returned by the host config is internally a lane, so we can</span>
    <span class="s0">// use that directly.</span>
    <span class="s0">// TODO: Move this type conversion to the event priority module.</span>


    <span class="s2">var </span><span class="s1">updateLane = getCurrentUpdatePriority();</span>

    <span class="s2">if </span><span class="s1">(updateLane !== NoLane) {</span>
      <span class="s2">return </span><span class="s1">updateLane;</span>
    <span class="s1">} </span><span class="s0">// This update originated outside React. Ask the host environment for an</span>
    <span class="s0">// appropriate priority, based on the type of event.</span>
    <span class="s0">//</span>
    <span class="s0">// The opaque type returned by the host config is internally a lane, so we can</span>
    <span class="s0">// use that directly.</span>
    <span class="s0">// TODO: Move this type conversion to the event priority module.</span>


    <span class="s2">var </span><span class="s1">eventLane = getCurrentEventPriority();</span>
    <span class="s2">return </span><span class="s1">eventLane;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">requestRetryLane(fiber) {</span>
    <span class="s0">// This is a fork of `requestUpdateLane` designed specifically for Suspense</span>
    <span class="s0">// &quot;retries&quot;  a special update that attempts to flip a Suspense boundary</span>
    <span class="s0">// from its placeholder state to its primary/resolved state.</span>
    <span class="s0">// Special cases</span>
    <span class="s2">var </span><span class="s1">mode = fiber.mode;</span>

    <span class="s2">if </span><span class="s1">((mode &amp; ConcurrentMode) === NoMode) {</span>
      <span class="s2">return </span><span class="s1">SyncLane;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">claimNextRetryLane();</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">scheduleUpdateOnFiber(root, fiber, lane, eventTime) {</span>
    <span class="s1">checkForNestedUpdates();</span>

    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(isRunningInsertionEffect) {</span>
        <span class="s1">error(</span><span class="s3">'useInsertionEffect must not schedule updates.'</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(isFlushingPassiveEffects) {</span>
        <span class="s1">didScheduleUpdateDuringPassiveEffects = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// Mark that the root has a pending update.</span>


    <span class="s1">markRootUpdated(root, lane, eventTime);</span>

    <span class="s2">if </span><span class="s1">((executionContext &amp; RenderContext) !== NoLanes &amp;&amp; root === workInProgressRoot) {</span>
      <span class="s0">// This update was dispatched during the render phase. This is a mistake</span>
      <span class="s0">// if the update originates from user space (with the exception of local</span>
      <span class="s0">// hook updates, which are handled differently and don't reach this</span>
      <span class="s0">// function), but there are some internal React features that use this as</span>
      <span class="s0">// an implementation detail, like selective hydration.</span>
      <span class="s1">warnAboutRenderPhaseUpdatesInDEV(fiber); </span><span class="s0">// Track lanes that were updated during the render phase</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>

      <span class="s1">warnIfUpdatesNotWrappedWithActDEV(fiber);</span>

      <span class="s2">if </span><span class="s1">(root === workInProgressRoot) {</span>
        <span class="s0">// Received an update to a tree that's in the middle of rendering. Mark</span>
        <span class="s0">// that there was an interleaved update work on this root. Unless the</span>
        <span class="s0">// `deferRenderPhaseUpdateToNextBatch` flag is off and this is a render</span>
        <span class="s0">// phase update. In that case, we don't treat render phase updates as if</span>
        <span class="s0">// they were interleaved, for backwards compat reasons.</span>
        <span class="s2">if </span><span class="s1">( (executionContext &amp; RenderContext) === NoContext) {</span>
          <span class="s1">workInProgressRootInterleavedUpdatedLanes = mergeLanes(workInProgressRootInterleavedUpdatedLanes, lane);</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(workInProgressRootExitStatus === RootSuspendedWithDelay) {</span>
          <span class="s0">// The root already suspended with a delay, which means this render</span>
          <span class="s0">// definitely won't finish. Since we have a new update, let's mark it as</span>
          <span class="s0">// suspended now, right before marking the incoming update. This has the</span>
          <span class="s0">// effect of interrupting the current render and switching to the update.</span>
          <span class="s0">// TODO: Make sure this doesn't override pings that happen while we've</span>
          <span class="s0">// already started rendering.</span>
          <span class="s1">markRootSuspended$1(root, workInProgressRootRenderLanes);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">ensureRootIsScheduled(root, eventTime);</span>

      <span class="s2">if </span><span class="s1">(lane === SyncLane &amp;&amp; executionContext === NoContext &amp;&amp; (fiber.mode &amp; ConcurrentMode) === NoMode &amp;&amp; </span><span class="s0">// Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.</span>
      <span class="s1">!( ReactCurrentActQueue$1.isBatchingLegacy)) {</span>
        <span class="s0">// Flush the synchronous work now, unless we're already working or inside</span>
        <span class="s0">// a batch. This is intentionally inside scheduleUpdateOnFiber instead of</span>
        <span class="s0">// scheduleCallbackForFiber to preserve the ability to schedule a callback</span>
        <span class="s0">// without immediately flushing it. We only do this for user-initiated</span>
        <span class="s0">// updates, to preserve historical behavior of legacy mode.</span>
        <span class="s1">resetRenderTimer();</span>
        <span class="s1">flushSyncCallbacksOnlyInLegacyMode();</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">isUnsafeClassRenderPhaseUpdate(fiber) {</span>
    <span class="s0">// Check if this is a render phase update. Only called by class components,</span>
    <span class="s0">// which special (deprecated) behavior for UNSAFE_componentWillReceive props.</span>
    <span class="s2">return </span><span class="s1">(</span><span class="s0">// TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We</span>
      <span class="s0">// decided not to enable it.</span>
       <span class="s1">(executionContext &amp; RenderContext) !== NoContext</span>
    <span class="s1">);</span>
  <span class="s1">} </span><span class="s0">// Use this function to schedule a task for a root. There's only one task per</span>
  <span class="s0">// root; if a task was already scheduled, we'll check to make sure the priority</span>
  <span class="s0">// of the existing task is the same as the priority of the next level that the</span>
  <span class="s0">// root has work on. This function is called on every update, and right before</span>
  <span class="s0">// exiting a task.</span>

  <span class="s2">function </span><span class="s1">ensureRootIsScheduled(root, currentTime) {</span>
    <span class="s2">var </span><span class="s1">existingCallbackNode = root.callbackNode; </span><span class="s0">// Check if any lanes are being starved by other work. If so, mark them as</span>
    <span class="s0">// expired so we know to work on those next.</span>

    <span class="s1">markStarvedLanesAsExpired(root, currentTime); </span><span class="s0">// Determine the next lanes to work on, and their priority.</span>

    <span class="s2">var </span><span class="s1">nextLanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);</span>

    <span class="s2">if </span><span class="s1">(nextLanes === NoLanes) {</span>
      <span class="s0">// Special case: There's nothing to work on.</span>
      <span class="s2">if </span><span class="s1">(existingCallbackNode !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">cancelCallback$1(existingCallbackNode);</span>
      <span class="s1">}</span>

      <span class="s1">root.callbackNode = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">root.callbackPriority = NoLane;</span>
      <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s0">// We use the highest priority lane to represent the priority of the callback.</span>


    <span class="s2">var </span><span class="s1">newCallbackPriority = getHighestPriorityLane(nextLanes); </span><span class="s0">// Check if there's an existing task. We may be able to reuse it.</span>

    <span class="s2">var </span><span class="s1">existingCallbackPriority = root.callbackPriority;</span>

    <span class="s2">if </span><span class="s1">(existingCallbackPriority === newCallbackPriority &amp;&amp; </span><span class="s0">// Special case related to `act`. If the currently scheduled task is a</span>
    <span class="s0">// Scheduler task, rather than an `act` task, cancel it and re-scheduled</span>
    <span class="s0">// on the `act` queue.</span>
    <span class="s1">!( ReactCurrentActQueue$1.current !== </span><span class="s2">null </span><span class="s1">&amp;&amp; existingCallbackNode !== fakeActCallbackNode)) {</span>
      <span class="s1">{</span>
        <span class="s0">// If we're going to re-use an existing task, it needs to exist.</span>
        <span class="s0">// Assume that discrete update microtasks are non-cancellable and null.</span>
        <span class="s0">// TODO: Temporary until we confirm this warning is not fired.</span>
        <span class="s2">if </span><span class="s1">(existingCallbackNode == </span><span class="s2">null </span><span class="s1">&amp;&amp; existingCallbackPriority !== SyncLane) {</span>
          <span class="s1">error(</span><span class="s3">'Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.'</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s0">// The priority hasn't changed. We can reuse the existing task. Exit.</span>


      <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(existingCallbackNode != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s0">// Cancel the existing callback. We'll schedule a new one below.</span>
      <span class="s1">cancelCallback$1(existingCallbackNode);</span>
    <span class="s1">} </span><span class="s0">// Schedule a new callback.</span>


    <span class="s2">var </span><span class="s1">newCallbackNode;</span>

    <span class="s2">if </span><span class="s1">(newCallbackPriority === SyncLane) {</span>
      <span class="s0">// Special case: Sync React callbacks are scheduled on a special</span>
      <span class="s0">// internal queue</span>
      <span class="s2">if </span><span class="s1">(root.tag === LegacyRoot) {</span>
        <span class="s2">if </span><span class="s1">( ReactCurrentActQueue$1.isBatchingLegacy !== </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">ReactCurrentActQueue$1.didScheduleLegacyUpdate = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(</span><span class="s2">null</span><span class="s1">, root));</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">scheduleSyncCallback(performSyncWorkOnRoot.bind(</span><span class="s2">null</span><span class="s1">, root));</span>
      <span class="s1">}</span>

      <span class="s1">{</span>
        <span class="s0">// Flush the queue in an Immediate task.</span>
        <span class="s1">scheduleCallback$1(ImmediatePriority, flushSyncCallbacks);</span>
      <span class="s1">}</span>

      <span class="s1">newCallbackNode = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">var </span><span class="s1">schedulerPriorityLevel;</span>

      <span class="s2">switch </span><span class="s1">(lanesToEventPriority(nextLanes)) {</span>
        <span class="s2">case </span><span class="s1">DiscreteEventPriority:</span>
          <span class="s1">schedulerPriorityLevel = ImmediatePriority;</span>
          <span class="s2">break</span><span class="s1">;</span>

        <span class="s2">case </span><span class="s1">ContinuousEventPriority:</span>
          <span class="s1">schedulerPriorityLevel = UserBlockingPriority;</span>
          <span class="s2">break</span><span class="s1">;</span>

        <span class="s2">case </span><span class="s1">DefaultEventPriority:</span>
          <span class="s1">schedulerPriorityLevel = NormalPriority;</span>
          <span class="s2">break</span><span class="s1">;</span>

        <span class="s2">case </span><span class="s1">IdleEventPriority:</span>
          <span class="s1">schedulerPriorityLevel = IdlePriority;</span>
          <span class="s2">break</span><span class="s1">;</span>

        <span class="s2">default</span><span class="s1">:</span>
          <span class="s1">schedulerPriorityLevel = NormalPriority;</span>
          <span class="s2">break</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">newCallbackNode = scheduleCallback$1(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(</span><span class="s2">null</span><span class="s1">, root));</span>
    <span class="s1">}</span>

    <span class="s1">root.callbackPriority = newCallbackPriority;</span>
    <span class="s1">root.callbackNode = newCallbackNode;</span>
  <span class="s1">} </span><span class="s0">// This is the entry point for every concurrent task, i.e. anything that</span>
  <span class="s0">// goes through Scheduler.</span>


  <span class="s2">function </span><span class="s1">performConcurrentWorkOnRoot(root, didTimeout) {</span>
    <span class="s1">{</span>
      <span class="s1">resetNestedUpdateFlag();</span>
    <span class="s1">} </span><span class="s0">// Since we know we're in a React event, we can clear the current</span>
    <span class="s0">// event time. The next update will compute a new event time.</span>


    <span class="s1">currentEventTime = NoTimestamp;</span>
    <span class="s1">currentEventTransitionLane = NoLanes;</span>

    <span class="s2">if </span><span class="s1">((executionContext &amp; (RenderContext | CommitContext)) !== NoContext) {</span>
      <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Should not already be working.'</span><span class="s1">);</span>
    <span class="s1">} </span><span class="s0">// Flush any pending passive effects before deciding which lanes to work on,</span>
    <span class="s0">// in case they schedule additional work.</span>


    <span class="s2">var </span><span class="s1">originalCallbackNode = root.callbackNode;</span>
    <span class="s2">var </span><span class="s1">didFlushPassiveEffects = flushPassiveEffects();</span>

    <span class="s2">if </span><span class="s1">(didFlushPassiveEffects) {</span>
      <span class="s0">// Something in the passive effect phase may have canceled the current task.</span>
      <span class="s0">// Check if the task node for this root was changed.</span>
      <span class="s2">if </span><span class="s1">(root.callbackNode !== originalCallbackNode) {</span>
        <span class="s0">// The current task was canceled. Exit. We don't need to call</span>
        <span class="s0">// `ensureRootIsScheduled` because the check above implies either that</span>
        <span class="s0">// there's a new task, or that there's no remaining work on this root.</span>
        <span class="s2">return null</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// Determine the next lanes to work on, using the fields stored</span>
    <span class="s0">// on the root.</span>


    <span class="s2">var </span><span class="s1">lanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);</span>

    <span class="s2">if </span><span class="s1">(lanes === NoLanes) {</span>
      <span class="s0">// Defensive coding. This is never expected to happen.</span>
      <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s0">// We disable time-slicing in some cases: if the work has been CPU-bound</span>
    <span class="s0">// for too long (&quot;expired&quot; work, to prevent starvation), or we're in</span>
    <span class="s0">// sync-updates-by-default mode.</span>
    <span class="s0">// TODO: We only check `didTimeout` defensively, to account for a Scheduler</span>
    <span class="s0">// bug we're still investigating. Once the bug in Scheduler is fixed,</span>
    <span class="s0">// we can remove this, since we track expiration ourselves.</span>


    <span class="s2">var </span><span class="s1">shouldTimeSlice = !includesBlockingLane(root, lanes) &amp;&amp; !includesExpiredLane(root, lanes) &amp;&amp; ( !didTimeout);</span>
    <span class="s2">var </span><span class="s1">exitStatus = shouldTimeSlice ? renderRootConcurrent(root, lanes) : renderRootSync(root, lanes);</span>

    <span class="s2">if </span><span class="s1">(exitStatus !== RootInProgress) {</span>
      <span class="s2">if </span><span class="s1">(exitStatus === RootErrored) {</span>
        <span class="s0">// If something threw an error, try rendering one more time. We'll</span>
        <span class="s0">// render synchronously to block concurrent data mutations, and we'll</span>
        <span class="s0">// includes all pending updates are included. If it still fails after</span>
        <span class="s0">// the second attempt, we'll give up and commit the resulting tree.</span>
        <span class="s2">var </span><span class="s1">errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);</span>

        <span class="s2">if </span><span class="s1">(errorRetryLanes !== NoLanes) {</span>
          <span class="s1">lanes = errorRetryLanes;</span>
          <span class="s1">exitStatus = recoverFromConcurrentError(root, errorRetryLanes);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(exitStatus === RootFatalErrored) {</span>
        <span class="s2">var </span><span class="s1">fatalError = workInProgressRootFatalError;</span>
        <span class="s1">prepareFreshStack(root, NoLanes);</span>
        <span class="s1">markRootSuspended$1(root, lanes);</span>
        <span class="s1">ensureRootIsScheduled(root, now());</span>
        <span class="s2">throw </span><span class="s1">fatalError;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(exitStatus === RootDidNotComplete) {</span>
        <span class="s0">// The render unwound without completing the tree. This happens in special</span>
        <span class="s0">// cases where need to exit the current render without producing a</span>
        <span class="s0">// consistent tree or committing.</span>
        <span class="s0">//</span>
        <span class="s0">// This should only happen during a concurrent render, not a discrete or</span>
        <span class="s0">// synchronous update. We should have already checked for this when we</span>
        <span class="s0">// unwound the stack.</span>
        <span class="s1">markRootSuspended$1(root, lanes);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s0">// The render completed.</span>
        <span class="s0">// Check if this render may have yielded to a concurrent event, and if so,</span>
        <span class="s0">// confirm that any newly rendered stores are consistent.</span>
        <span class="s0">// TODO: It's possible that even a concurrent render may never have yielded</span>
        <span class="s0">// to the main thread, if it was fast enough, or if it expired. We could</span>
        <span class="s0">// skip the consistency check in that case, too.</span>
        <span class="s2">var </span><span class="s1">renderWasConcurrent = !includesBlockingLane(root, lanes);</span>
        <span class="s2">var </span><span class="s1">finishedWork = root.current.alternate;</span>

        <span class="s2">if </span><span class="s1">(renderWasConcurrent &amp;&amp; !isRenderConsistentWithExternalStores(finishedWork)) {</span>
          <span class="s0">// A store was mutated in an interleaved event. Render again,</span>
          <span class="s0">// synchronously, to block further mutations.</span>
          <span class="s1">exitStatus = renderRootSync(root, lanes); </span><span class="s0">// We need to check again if something threw</span>

          <span class="s2">if </span><span class="s1">(exitStatus === RootErrored) {</span>
            <span class="s2">var </span><span class="s1">_errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);</span>

            <span class="s2">if </span><span class="s1">(_errorRetryLanes !== NoLanes) {</span>
              <span class="s1">lanes = _errorRetryLanes;</span>
              <span class="s1">exitStatus = recoverFromConcurrentError(root, _errorRetryLanes); </span><span class="s0">// We assume the tree is now consistent because we didn't yield to any</span>
              <span class="s0">// concurrent events.</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s2">if </span><span class="s1">(exitStatus === RootFatalErrored) {</span>
            <span class="s2">var </span><span class="s1">_fatalError = workInProgressRootFatalError;</span>
            <span class="s1">prepareFreshStack(root, NoLanes);</span>
            <span class="s1">markRootSuspended$1(root, lanes);</span>
            <span class="s1">ensureRootIsScheduled(root, now());</span>
            <span class="s2">throw </span><span class="s1">_fatalError;</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s0">// We now have a consistent tree. The next step is either to commit it,</span>
        <span class="s0">// or, if something suspended, wait to commit it after a timeout.</span>


        <span class="s1">root.finishedWork = finishedWork;</span>
        <span class="s1">root.finishedLanes = lanes;</span>
        <span class="s1">finishConcurrentRender(root, exitStatus, lanes);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">ensureRootIsScheduled(root, now());</span>

    <span class="s2">if </span><span class="s1">(root.callbackNode === originalCallbackNode) {</span>
      <span class="s0">// The task node scheduled for this root is the same one that's</span>
      <span class="s0">// currently executed. Need to return a continuation.</span>
      <span class="s2">return </span><span class="s1">performConcurrentWorkOnRoot.bind(</span><span class="s2">null</span><span class="s1">, root);</span>
    <span class="s1">}</span>

    <span class="s2">return null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">recoverFromConcurrentError(root, errorRetryLanes) {</span>
    <span class="s0">// If an error occurred during hydration, discard server response and fall</span>
    <span class="s0">// back to client side render.</span>
    <span class="s0">// Before rendering again, save the errors from the previous attempt.</span>
    <span class="s2">var </span><span class="s1">errorsFromFirstAttempt = workInProgressRootConcurrentErrors;</span>

    <span class="s2">if </span><span class="s1">(isRootDehydrated(root)) {</span>
      <span class="s0">// The shell failed to hydrate. Set a flag to force a client rendering</span>
      <span class="s0">// during the next attempt. To do this, we call prepareFreshStack now</span>
      <span class="s0">// to create the root work-in-progress fiber. This is a bit weird in terms</span>
      <span class="s0">// of factoring, because it relies on renderRootSync not calling</span>
      <span class="s0">// prepareFreshStack again in the call below, which happens because the</span>
      <span class="s0">// root and lanes haven't changed.</span>
      <span class="s0">//</span>
      <span class="s0">// TODO: I think what we should do is set ForceClientRender inside</span>
      <span class="s0">// throwException, like we do for nested Suspense boundaries. The reason</span>
      <span class="s0">// it's here instead is so we can switch to the synchronous work loop, too.</span>
      <span class="s0">// Something to consider for a future refactor.</span>
      <span class="s2">var </span><span class="s1">rootWorkInProgress = prepareFreshStack(root, errorRetryLanes);</span>
      <span class="s1">rootWorkInProgress.flags |= ForceClientRender;</span>

      <span class="s1">{</span>
        <span class="s1">errorHydratingContainer(root.containerInfo);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">exitStatus = renderRootSync(root, errorRetryLanes);</span>

    <span class="s2">if </span><span class="s1">(exitStatus !== RootErrored) {</span>
      <span class="s0">// Successfully finished rendering on retry</span>
      <span class="s0">// The errors from the failed first attempt have been recovered. Add</span>
      <span class="s0">// them to the collection of recoverable errors. We'll log them in the</span>
      <span class="s0">// commit phase.</span>
      <span class="s2">var </span><span class="s1">errorsFromSecondAttempt = workInProgressRootRecoverableErrors;</span>
      <span class="s1">workInProgressRootRecoverableErrors = errorsFromFirstAttempt; </span><span class="s0">// The errors from the second attempt should be queued after the errors</span>
      <span class="s0">// from the first attempt, to preserve the causal sequence.</span>

      <span class="s2">if </span><span class="s1">(errorsFromSecondAttempt !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">queueRecoverableErrors(errorsFromSecondAttempt);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">exitStatus;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">queueRecoverableErrors(errors) {</span>
    <span class="s2">if </span><span class="s1">(workInProgressRootRecoverableErrors === </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">workInProgressRootRecoverableErrors = errors;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, errors);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">finishConcurrentRender(root, exitStatus, lanes) {</span>
    <span class="s2">switch </span><span class="s1">(exitStatus) {</span>
      <span class="s2">case </span><span class="s1">RootInProgress:</span>
      <span class="s2">case </span><span class="s1">RootFatalErrored:</span>
        <span class="s1">{</span>
          <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Root did not complete. This is a bug in React.'</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s0">// Flow knows about invariant, so it complains if I add a break</span>
      <span class="s0">// statement, but eslint doesn't know about invariant, so it complains</span>
      <span class="s0">// if I do. eslint-disable-next-line no-fallthrough</span>

      <span class="s2">case </span><span class="s1">RootErrored:</span>
        <span class="s1">{</span>
          <span class="s0">// We should have already attempted to retry this tree. If we reached</span>
          <span class="s0">// this point, it errored again. Commit it.</span>
          <span class="s1">commitRoot(root, workInProgressRootRecoverableErrors, workInProgressTransitions);</span>
          <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s2">case </span><span class="s1">RootSuspended:</span>
        <span class="s1">{</span>
          <span class="s1">markRootSuspended$1(root, lanes); </span><span class="s0">// We have an acceptable loading state. We need to figure out if we</span>
          <span class="s0">// should immediately commit it or wait a bit.</span>

          <span class="s2">if </span><span class="s1">(includesOnlyRetries(lanes) &amp;&amp; </span><span class="s0">// do not delay if we're inside an act() scope</span>
          <span class="s1">!shouldForceFlushFallbacksInDEV()) {</span>
            <span class="s0">// This render only included retries, no updates. Throttle committing</span>
            <span class="s0">// retries so that we don't show too many loading states too quickly.</span>
            <span class="s2">var </span><span class="s1">msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now(); </span><span class="s0">// Don't bother with a very short suspense time.</span>

            <span class="s2">if </span><span class="s1">(msUntilTimeout &gt; </span><span class="s4">10</span><span class="s1">) {</span>
              <span class="s2">var </span><span class="s1">nextLanes = getNextLanes(root, NoLanes);</span>

              <span class="s2">if </span><span class="s1">(nextLanes !== NoLanes) {</span>
                <span class="s0">// There's additional work on this root.</span>
                <span class="s2">break</span><span class="s1">;</span>
              <span class="s1">}</span>

              <span class="s2">var </span><span class="s1">suspendedLanes = root.suspendedLanes;</span>

              <span class="s2">if </span><span class="s1">(!isSubsetOfLanes(suspendedLanes, lanes)) {</span>
                <span class="s0">// We should prefer to render the fallback of at the last</span>
                <span class="s0">// suspended level. Ping the last suspended level to try</span>
                <span class="s0">// rendering it again.</span>
                <span class="s0">// FIXME: What if the suspended lanes are Idle? Should not restart.</span>
                <span class="s2">var </span><span class="s1">eventTime = requestEventTime();</span>
                <span class="s1">markRootPinged(root, suspendedLanes);</span>
                <span class="s2">break</span><span class="s1">;</span>
              <span class="s1">} </span><span class="s0">// The render is suspended, it hasn't timed out, and there's no</span>
              <span class="s0">// lower priority work to do. Instead of committing the fallback</span>
              <span class="s0">// immediately, wait for more data to arrive.</span>


              <span class="s1">root.timeoutHandle = scheduleTimeout(commitRoot.bind(</span><span class="s2">null</span><span class="s1">, root, workInProgressRootRecoverableErrors, workInProgressTransitions), msUntilTimeout);</span>
              <span class="s2">break</span><span class="s1">;</span>
            <span class="s1">}</span>
          <span class="s1">} </span><span class="s0">// The work expired. Commit immediately.</span>


          <span class="s1">commitRoot(root, workInProgressRootRecoverableErrors, workInProgressTransitions);</span>
          <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s2">case </span><span class="s1">RootSuspendedWithDelay:</span>
        <span class="s1">{</span>
          <span class="s1">markRootSuspended$1(root, lanes);</span>

          <span class="s2">if </span><span class="s1">(includesOnlyTransitions(lanes)) {</span>
            <span class="s0">// This is a transition, so we should exit without committing a</span>
            <span class="s0">// placeholder and without scheduling a timeout. Delay indefinitely</span>
            <span class="s0">// until we receive more data.</span>
            <span class="s2">break</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s2">if </span><span class="s1">(!shouldForceFlushFallbacksInDEV()) {</span>
            <span class="s0">// This is not a transition, but we did trigger an avoided state.</span>
            <span class="s0">// Schedule a placeholder to display after a short delay, using the Just</span>
            <span class="s0">// Noticeable Difference.</span>
            <span class="s0">// TODO: Is the JND optimization worth the added complexity? If this is</span>
            <span class="s0">// the only reason we track the event time, then probably not.</span>
            <span class="s0">// Consider removing.</span>
            <span class="s2">var </span><span class="s1">mostRecentEventTime = getMostRecentEventTime(root, lanes);</span>
            <span class="s2">var </span><span class="s1">eventTimeMs = mostRecentEventTime;</span>
            <span class="s2">var </span><span class="s1">timeElapsedMs = now() - eventTimeMs;</span>

            <span class="s2">var </span><span class="s1">_msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs; </span><span class="s0">// Don't bother with a very short suspense time.</span>


            <span class="s2">if </span><span class="s1">(_msUntilTimeout &gt; </span><span class="s4">10</span><span class="s1">) {</span>
              <span class="s0">// Instead of committing the fallback immediately, wait for more data</span>
              <span class="s0">// to arrive.</span>
              <span class="s1">root.timeoutHandle = scheduleTimeout(commitRoot.bind(</span><span class="s2">null</span><span class="s1">, root, workInProgressRootRecoverableErrors, workInProgressTransitions), _msUntilTimeout);</span>
              <span class="s2">break</span><span class="s1">;</span>
            <span class="s1">}</span>
          <span class="s1">} </span><span class="s0">// Commit the placeholder.</span>


          <span class="s1">commitRoot(root, workInProgressRootRecoverableErrors, workInProgressTransitions);</span>
          <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s2">case </span><span class="s1">RootCompleted:</span>
        <span class="s1">{</span>
          <span class="s0">// The work completed. Ready to commit.</span>
          <span class="s1">commitRoot(root, workInProgressRootRecoverableErrors, workInProgressTransitions);</span>
          <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s2">default</span><span class="s1">:</span>
        <span class="s1">{</span>
          <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Unknown root exit status.'</span><span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">isRenderConsistentWithExternalStores(finishedWork) {</span>
    <span class="s0">// Search the rendered tree for external store reads, and check whether the</span>
    <span class="s0">// stores were mutated in a concurrent event. Intentionally using an iterative</span>
    <span class="s0">// loop instead of recursion so we can exit early.</span>
    <span class="s2">var </span><span class="s1">node = finishedWork;</span>

    <span class="s2">while </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(node.flags &amp; StoreConsistency) {</span>
        <span class="s2">var </span><span class="s1">updateQueue = node.updateQueue;</span>

        <span class="s2">if </span><span class="s1">(updateQueue !== </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s2">var </span><span class="s1">checks = updateQueue.stores;</span>

          <span class="s2">if </span><span class="s1">(checks !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; checks.length; i++) {</span>
              <span class="s2">var </span><span class="s1">check = checks[i];</span>
              <span class="s2">var </span><span class="s1">getSnapshot = check.getSnapshot;</span>
              <span class="s2">var </span><span class="s1">renderedValue = check.value;</span>

              <span class="s2">try </span><span class="s1">{</span>
                <span class="s2">if </span><span class="s1">(!objectIs(getSnapshot(), renderedValue)) {</span>
                  <span class="s0">// Found an inconsistent store.</span>
                  <span class="s2">return false</span><span class="s1">;</span>
                <span class="s1">}</span>
              <span class="s1">} </span><span class="s2">catch </span><span class="s1">(error) {</span>
                <span class="s0">// If `getSnapshot` throws, return `false`. This will schedule</span>
                <span class="s0">// a re-render, and the error will be rethrown during render.</span>
                <span class="s2">return false</span><span class="s1">;</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">child = node.child;</span>

      <span class="s2">if </span><span class="s1">(node.subtreeFlags &amp; StoreConsistency &amp;&amp; child !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">child.</span><span class="s2">return </span><span class="s1">= node;</span>
        <span class="s1">node = child;</span>
        <span class="s2">continue</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(node === finishedWork) {</span>
        <span class="s2">return true</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">while </span><span class="s1">(node.sibling === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(node.</span><span class="s2">return </span><span class="s1">=== </span><span class="s2">null </span><span class="s1">|| node.</span><span class="s2">return </span><span class="s1">=== finishedWork) {</span>
          <span class="s2">return true</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">node = node.</span><span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">node.sibling.</span><span class="s2">return </span><span class="s1">= node.</span><span class="s2">return</span><span class="s1">;</span>
      <span class="s1">node = node.sibling;</span>
    <span class="s1">} </span><span class="s0">// Flow doesn't know this is unreachable, but eslint does</span>
    <span class="s0">// eslint-disable-next-line no-unreachable</span>


    <span class="s2">return true</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">markRootSuspended$1(root, suspendedLanes) {</span>
    <span class="s0">// When suspending, we should always exclude lanes that were pinged or (more</span>
    <span class="s0">// rarely, since we try to avoid it) updated during the render phase.</span>
    <span class="s0">// TODO: Lol maybe there's a better way to factor this besides this</span>
    <span class="s0">// obnoxiously named function :)</span>
    <span class="s1">suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);</span>
    <span class="s1">suspendedLanes = removeLanes(suspendedLanes, workInProgressRootInterleavedUpdatedLanes);</span>
    <span class="s1">markRootSuspended(root, suspendedLanes);</span>
  <span class="s1">} </span><span class="s0">// This is the entry point for synchronous tasks that don't go</span>
  <span class="s0">// through Scheduler</span>


  <span class="s2">function </span><span class="s1">performSyncWorkOnRoot(root) {</span>
    <span class="s1">{</span>
      <span class="s1">syncNestedUpdateFlag();</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">((executionContext &amp; (RenderContext | CommitContext)) !== NoContext) {</span>
      <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Should not already be working.'</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s1">flushPassiveEffects();</span>
    <span class="s2">var </span><span class="s1">lanes = getNextLanes(root, NoLanes);</span>

    <span class="s2">if </span><span class="s1">(!includesSomeLane(lanes, SyncLane)) {</span>
      <span class="s0">// There's no remaining sync work left.</span>
      <span class="s1">ensureRootIsScheduled(root, now());</span>
      <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">exitStatus = renderRootSync(root, lanes);</span>

    <span class="s2">if </span><span class="s1">(root.tag !== LegacyRoot &amp;&amp; exitStatus === RootErrored) {</span>
      <span class="s0">// If something threw an error, try rendering one more time. We'll render</span>
      <span class="s0">// synchronously to block concurrent data mutations, and we'll includes</span>
      <span class="s0">// all pending updates are included. If it still fails after the second</span>
      <span class="s0">// attempt, we'll give up and commit the resulting tree.</span>
      <span class="s2">var </span><span class="s1">errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);</span>

      <span class="s2">if </span><span class="s1">(errorRetryLanes !== NoLanes) {</span>
        <span class="s1">lanes = errorRetryLanes;</span>
        <span class="s1">exitStatus = recoverFromConcurrentError(root, errorRetryLanes);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(exitStatus === RootFatalErrored) {</span>
      <span class="s2">var </span><span class="s1">fatalError = workInProgressRootFatalError;</span>
      <span class="s1">prepareFreshStack(root, NoLanes);</span>
      <span class="s1">markRootSuspended$1(root, lanes);</span>
      <span class="s1">ensureRootIsScheduled(root, now());</span>
      <span class="s2">throw </span><span class="s1">fatalError;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(exitStatus === RootDidNotComplete) {</span>
      <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Root did not complete. This is a bug in React.'</span><span class="s1">);</span>
    <span class="s1">} </span><span class="s0">// We now have a consistent tree. Because this is a sync render, we</span>
    <span class="s0">// will commit it even if something suspended.</span>


    <span class="s2">var </span><span class="s1">finishedWork = root.current.alternate;</span>
    <span class="s1">root.finishedWork = finishedWork;</span>
    <span class="s1">root.finishedLanes = lanes;</span>
    <span class="s1">commitRoot(root, workInProgressRootRecoverableErrors, workInProgressTransitions); </span><span class="s0">// Before exiting, make sure there's a callback scheduled for the next</span>
    <span class="s0">// pending level.</span>

    <span class="s1">ensureRootIsScheduled(root, now());</span>
    <span class="s2">return null</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">batchedUpdates(fn, a) {</span>
    <span class="s2">var </span><span class="s1">prevExecutionContext = executionContext;</span>
    <span class="s1">executionContext |= BatchedContext;</span>

    <span class="s2">try </span><span class="s1">{</span>
      <span class="s2">return </span><span class="s1">fn(a);</span>
    <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
      <span class="s1">executionContext = prevExecutionContext; </span><span class="s0">// If there were legacy sync updates, flush them at the end of the outer</span>
      <span class="s0">// most batchedUpdates-like method.</span>

      <span class="s2">if </span><span class="s1">(executionContext === NoContext &amp;&amp; </span><span class="s0">// Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.</span>
      <span class="s1">!( ReactCurrentActQueue$1.isBatchingLegacy)) {</span>
        <span class="s1">resetRenderTimer();</span>
        <span class="s1">flushSyncCallbacksOnlyInLegacyMode();</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">// Warning, this opts-out of checking the function body.</span>

  <span class="s0">// eslint-disable-next-line no-redeclare</span>
  <span class="s2">function </span><span class="s1">flushSync(fn) {</span>
    <span class="s0">// In legacy mode, we flush pending passive effects at the beginning of the</span>
    <span class="s0">// next event, not at the end of the previous one.</span>
    <span class="s2">if </span><span class="s1">(rootWithPendingPassiveEffects !== </span><span class="s2">null </span><span class="s1">&amp;&amp; rootWithPendingPassiveEffects.tag === LegacyRoot &amp;&amp; (executionContext &amp; (RenderContext | CommitContext)) === NoContext) {</span>
      <span class="s1">flushPassiveEffects();</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">prevExecutionContext = executionContext;</span>
    <span class="s1">executionContext |= BatchedContext;</span>
    <span class="s2">var </span><span class="s1">prevTransition = ReactCurrentBatchConfig$2.transition;</span>
    <span class="s2">var </span><span class="s1">previousPriority = getCurrentUpdatePriority();</span>

    <span class="s2">try </span><span class="s1">{</span>
      <span class="s1">ReactCurrentBatchConfig$2.transition = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">setCurrentUpdatePriority(DiscreteEventPriority);</span>

      <span class="s2">if </span><span class="s1">(fn) {</span>
        <span class="s2">return </span><span class="s1">fn();</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">return </span><span class="s1">undefined;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
      <span class="s1">setCurrentUpdatePriority(previousPriority);</span>
      <span class="s1">ReactCurrentBatchConfig$2.transition = prevTransition;</span>
      <span class="s1">executionContext = prevExecutionContext; </span><span class="s0">// Flush the immediate callbacks that were scheduled during this batch.</span>
      <span class="s0">// Note that this will happen even if batchedUpdates is higher up</span>
      <span class="s0">// the stack.</span>

      <span class="s2">if </span><span class="s1">((executionContext &amp; (RenderContext | CommitContext)) === NoContext) {</span>
        <span class="s1">flushSyncCallbacks();</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">pushRenderLanes(fiber, lanes) {</span>
    <span class="s1">push(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);</span>
    <span class="s1">subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);</span>
    <span class="s1">workInProgressRootIncludedLanes = mergeLanes(workInProgressRootIncludedLanes, lanes);</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">popRenderLanes(fiber) {</span>
    <span class="s1">subtreeRenderLanes = subtreeRenderLanesCursor.current;</span>
    <span class="s1">pop(subtreeRenderLanesCursor, fiber);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">prepareFreshStack(root, lanes) {</span>
    <span class="s1">root.finishedWork = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">root.finishedLanes = NoLanes;</span>
    <span class="s2">var </span><span class="s1">timeoutHandle = root.timeoutHandle;</span>

    <span class="s2">if </span><span class="s1">(timeoutHandle !== noTimeout) {</span>
      <span class="s0">// The root previous suspended and scheduled a timeout to commit a fallback</span>
      <span class="s0">// state. Now that we have additional work, cancel the timeout.</span>
      <span class="s1">root.timeoutHandle = noTimeout; </span><span class="s0">// $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above</span>

      <span class="s1">cancelTimeout(timeoutHandle);</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(workInProgress !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">interruptedWork = workInProgress.</span><span class="s2">return</span><span class="s1">;</span>

      <span class="s2">while </span><span class="s1">(interruptedWork !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">var </span><span class="s1">current = interruptedWork.alternate;</span>
        <span class="s1">unwindInterruptedWork(current, interruptedWork);</span>
        <span class="s1">interruptedWork = interruptedWork.</span><span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">workInProgressRoot = root;</span>
    <span class="s2">var </span><span class="s1">rootWorkInProgress = createWorkInProgress(root.current, </span><span class="s2">null</span><span class="s1">);</span>
    <span class="s1">workInProgress = rootWorkInProgress;</span>
    <span class="s1">workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;</span>
    <span class="s1">workInProgressRootExitStatus = RootInProgress;</span>
    <span class="s1">workInProgressRootFatalError = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">workInProgressRootSkippedLanes = NoLanes;</span>
    <span class="s1">workInProgressRootInterleavedUpdatedLanes = NoLanes;</span>
    <span class="s1">workInProgressRootPingedLanes = NoLanes;</span>
    <span class="s1">workInProgressRootConcurrentErrors = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">workInProgressRootRecoverableErrors = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">finishQueueingConcurrentUpdates();</span>

    <span class="s1">{</span>
      <span class="s1">ReactStrictModeWarnings.discardPendingWarnings();</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">rootWorkInProgress;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">handleError(root, thrownValue) {</span>
    <span class="s2">do </span><span class="s1">{</span>
      <span class="s2">var </span><span class="s1">erroredWork = workInProgress;</span>

      <span class="s2">try </span><span class="s1">{</span>
        <span class="s0">// Reset module-level state that was set during the render phase.</span>
        <span class="s1">resetContextDependencies();</span>
        <span class="s1">resetHooksAfterThrow();</span>
        <span class="s1">resetCurrentFiber(); </span><span class="s0">// TODO: I found and added this missing line while investigating a</span>
        <span class="s0">// separate issue. Write a regression test using string refs.</span>

        <span class="s1">ReactCurrentOwner$2.current = </span><span class="s2">null</span><span class="s1">;</span>

        <span class="s2">if </span><span class="s1">(erroredWork === </span><span class="s2">null </span><span class="s1">|| erroredWork.</span><span class="s2">return </span><span class="s1">=== </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s0">// Expected to be working on a non-root fiber. This is a fatal error</span>
          <span class="s0">// because there's no ancestor that can handle it; the root is</span>
          <span class="s0">// supposed to capture all errors that weren't caught by an error</span>
          <span class="s0">// boundary.</span>
          <span class="s1">workInProgressRootExitStatus = RootFatalErrored;</span>
          <span class="s1">workInProgressRootFatalError = thrownValue; </span><span class="s0">// Set `workInProgress` to null. This represents advancing to the next</span>
          <span class="s0">// sibling, or the parent if there are no siblings. But since the root</span>
          <span class="s0">// has no siblings nor a parent, we set it to null. Usually this is</span>
          <span class="s0">// handled by `completeUnitOfWork` or `unwindWork`, but since we're</span>
          <span class="s0">// intentionally not calling those, we need set it here.</span>
          <span class="s0">// TODO: Consider calling `unwindWork` to pop the contexts.</span>

          <span class="s1">workInProgress = </span><span class="s2">null</span><span class="s1">;</span>
          <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(enableProfilerTimer &amp;&amp; erroredWork.mode &amp; ProfileMode) {</span>
          <span class="s0">// Record the time spent rendering before an error was thrown. This</span>
          <span class="s0">// avoids inaccurate Profiler durations in the case of a</span>
          <span class="s0">// suspended render.</span>
          <span class="s1">stopProfilerTimerIfRunningAndRecordDelta(erroredWork, </span><span class="s2">true</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(enableSchedulingProfiler) {</span>
          <span class="s1">markComponentRenderStopped();</span>

          <span class="s2">if </span><span class="s1">(thrownValue !== </span><span class="s2">null </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">thrownValue === </span><span class="s3">'object' </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">thrownValue.then === </span><span class="s3">'function'</span><span class="s1">) {</span>
            <span class="s2">var </span><span class="s1">wakeable = thrownValue;</span>
            <span class="s1">markComponentSuspended(erroredWork, wakeable, workInProgressRootRenderLanes);</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">markComponentErrored(erroredWork, thrownValue, workInProgressRootRenderLanes);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s1">throwException(root, erroredWork.</span><span class="s2">return</span><span class="s1">, erroredWork, thrownValue, workInProgressRootRenderLanes);</span>
        <span class="s1">completeUnitOfWork(erroredWork);</span>
      <span class="s1">} </span><span class="s2">catch </span><span class="s1">(yetAnotherThrownValue) {</span>
        <span class="s0">// Something in the return path also threw.</span>
        <span class="s1">thrownValue = yetAnotherThrownValue;</span>

        <span class="s2">if </span><span class="s1">(workInProgress === erroredWork &amp;&amp; erroredWork !== </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s0">// If this boundary has already errored, then we had trouble processing</span>
          <span class="s0">// the error. Bubble it to the next boundary.</span>
          <span class="s1">erroredWork = erroredWork.</span><span class="s2">return</span><span class="s1">;</span>
          <span class="s1">workInProgress = erroredWork;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">erroredWork = workInProgress;</span>
        <span class="s1">}</span>

        <span class="s2">continue</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// Return to the normal work loop.</span>


      <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">while </span><span class="s1">(</span><span class="s2">true</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">pushDispatcher() {</span>
    <span class="s2">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher$2.current;</span>
    <span class="s1">ReactCurrentDispatcher$2.current = ContextOnlyDispatcher;</span>

    <span class="s2">if </span><span class="s1">(prevDispatcher === </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s0">// The React isomorphic package does not include a default dispatcher.</span>
      <span class="s0">// Instead the first renderer will lazily attach one, in order to give</span>
      <span class="s0">// nicer error messages.</span>
      <span class="s2">return </span><span class="s1">ContextOnlyDispatcher;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">return </span><span class="s1">prevDispatcher;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">popDispatcher(prevDispatcher) {</span>
    <span class="s1">ReactCurrentDispatcher$2.current = prevDispatcher;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">markCommitTimeOfFallback() {</span>
    <span class="s1">globalMostRecentFallbackTime = now();</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">markSkippedUpdateLanes(lane) {</span>
    <span class="s1">workInProgressRootSkippedLanes = mergeLanes(lane, workInProgressRootSkippedLanes);</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">renderDidSuspend() {</span>
    <span class="s2">if </span><span class="s1">(workInProgressRootExitStatus === RootInProgress) {</span>
      <span class="s1">workInProgressRootExitStatus = RootSuspended;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">renderDidSuspendDelayIfPossible() {</span>
    <span class="s2">if </span><span class="s1">(workInProgressRootExitStatus === RootInProgress || workInProgressRootExitStatus === RootSuspended || workInProgressRootExitStatus === RootErrored) {</span>
      <span class="s1">workInProgressRootExitStatus = RootSuspendedWithDelay;</span>
    <span class="s1">} </span><span class="s0">// Check if there are updates that we skipped tree that might have unblocked</span>
    <span class="s0">// this render.</span>


    <span class="s2">if </span><span class="s1">(workInProgressRoot !== </span><span class="s2">null </span><span class="s1">&amp;&amp; (includesNonIdleWork(workInProgressRootSkippedLanes) || includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes))) {</span>
      <span class="s0">// Mark the current render as suspended so that we switch to working on</span>
      <span class="s0">// the updates that were skipped. Usually we only suspend at the end of</span>
      <span class="s0">// the render phase.</span>
      <span class="s0">// TODO: We should probably always mark the root as suspended immediately</span>
      <span class="s0">// (inside this function), since by suspending at the end of the render</span>
      <span class="s0">// phase introduces a potential mistake where we suspend lanes that were</span>
      <span class="s0">// pinged or updated while we were rendering.</span>
      <span class="s1">markRootSuspended$1(workInProgressRoot, workInProgressRootRenderLanes);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">renderDidError(error) {</span>
    <span class="s2">if </span><span class="s1">(workInProgressRootExitStatus !== RootSuspendedWithDelay) {</span>
      <span class="s1">workInProgressRootExitStatus = RootErrored;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(workInProgressRootConcurrentErrors === </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">workInProgressRootConcurrentErrors = [error];</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">workInProgressRootConcurrentErrors.push(error);</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s0">// Called during render to determine if anything has suspended.</span>
  <span class="s0">// Returns false if we're not sure.</span>

  <span class="s2">function </span><span class="s1">renderHasNotSuspendedYet() {</span>
    <span class="s0">// If something errored or completed, we can't really be sure,</span>
    <span class="s0">// so those are false.</span>
    <span class="s2">return </span><span class="s1">workInProgressRootExitStatus === RootInProgress;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">renderRootSync(root, lanes) {</span>
    <span class="s2">var </span><span class="s1">prevExecutionContext = executionContext;</span>
    <span class="s1">executionContext |= RenderContext;</span>
    <span class="s2">var </span><span class="s1">prevDispatcher = pushDispatcher(); </span><span class="s0">// If the root or lanes have changed, throw out the existing stack</span>
    <span class="s0">// and prepare a fresh one. Otherwise we'll continue where we left off.</span>

    <span class="s2">if </span><span class="s1">(workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {</span>

      <span class="s1">workInProgressTransitions = getTransitionsForLanes();</span>
      <span class="s1">prepareFreshStack(root, lanes);</span>
    <span class="s1">}</span>

    <span class="s2">do </span><span class="s1">{</span>
      <span class="s2">try </span><span class="s1">{</span>
        <span class="s1">workLoopSync();</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s2">catch </span><span class="s1">(thrownValue) {</span>
        <span class="s1">handleError(root, thrownValue);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">while </span><span class="s1">(</span><span class="s2">true</span><span class="s1">);</span>

    <span class="s1">resetContextDependencies();</span>
    <span class="s1">executionContext = prevExecutionContext;</span>
    <span class="s1">popDispatcher(prevDispatcher);</span>

    <span class="s2">if </span><span class="s1">(workInProgress !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s0">// This is a sync render, so we should have finished the whole tree.</span>
      <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Cannot commit an incomplete root. This error is likely caused by a ' </span><span class="s1">+ </span><span class="s3">'bug in React. Please file an issue.'</span><span class="s1">);</span>
    <span class="s1">}</span>


    <span class="s1">workInProgressRoot = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">workInProgressRootRenderLanes = NoLanes;</span>
    <span class="s2">return </span><span class="s1">workInProgressRootExitStatus;</span>
  <span class="s1">} </span><span class="s0">// The work loop is an extremely hot path. Tell Closure not to inline it.</span>

  <span class="s0">/** @noinline */</span>


  <span class="s2">function </span><span class="s1">workLoopSync() {</span>
    <span class="s0">// Already timed out, so perform work without checking if we need to yield.</span>
    <span class="s2">while </span><span class="s1">(workInProgress !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">performUnitOfWork(workInProgress);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">renderRootConcurrent(root, lanes) {</span>
    <span class="s2">var </span><span class="s1">prevExecutionContext = executionContext;</span>
    <span class="s1">executionContext |= RenderContext;</span>
    <span class="s2">var </span><span class="s1">prevDispatcher = pushDispatcher(); </span><span class="s0">// If the root or lanes have changed, throw out the existing stack</span>
    <span class="s0">// and prepare a fresh one. Otherwise we'll continue where we left off.</span>

    <span class="s2">if </span><span class="s1">(workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {</span>

      <span class="s1">workInProgressTransitions = getTransitionsForLanes();</span>
      <span class="s1">resetRenderTimer();</span>
      <span class="s1">prepareFreshStack(root, lanes);</span>
    <span class="s1">}</span>

    <span class="s2">do </span><span class="s1">{</span>
      <span class="s2">try </span><span class="s1">{</span>
        <span class="s1">workLoopConcurrent();</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s2">catch </span><span class="s1">(thrownValue) {</span>
        <span class="s1">handleError(root, thrownValue);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">while </span><span class="s1">(</span><span class="s2">true</span><span class="s1">);</span>

    <span class="s1">resetContextDependencies();</span>
    <span class="s1">popDispatcher(prevDispatcher);</span>
    <span class="s1">executionContext = prevExecutionContext;</span>


    <span class="s2">if </span><span class="s1">(workInProgress !== </span><span class="s2">null</span><span class="s1">) {</span>

      <span class="s2">return </span><span class="s1">RootInProgress;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>


      <span class="s1">workInProgressRoot = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">workInProgressRootRenderLanes = NoLanes; </span><span class="s0">// Return the final exit status.</span>

      <span class="s2">return </span><span class="s1">workInProgressRootExitStatus;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">/** @noinline */</span>


  <span class="s2">function </span><span class="s1">workLoopConcurrent() {</span>
    <span class="s0">// Perform work until Scheduler asks us to yield</span>
    <span class="s2">while </span><span class="s1">(workInProgress !== </span><span class="s2">null </span><span class="s1">&amp;&amp; !shouldYield()) {</span>
      <span class="s1">performUnitOfWork(workInProgress);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">performUnitOfWork(unitOfWork) {</span>
    <span class="s0">// The current, flushed, state of this fiber is the alternate. Ideally</span>
    <span class="s0">// nothing should rely on this, but relying on it here means that we don't</span>
    <span class="s0">// need an additional field on the work in progress.</span>
    <span class="s2">var </span><span class="s1">current = unitOfWork.alternate;</span>
    <span class="s1">setCurrentFiber(unitOfWork);</span>
    <span class="s2">var </span><span class="s1">next;</span>

    <span class="s2">if </span><span class="s1">( (unitOfWork.mode &amp; ProfileMode) !== NoMode) {</span>
      <span class="s1">startProfilerTimer(unitOfWork);</span>
      <span class="s1">next = beginWork$1(current, unitOfWork, subtreeRenderLanes);</span>
      <span class="s1">stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, </span><span class="s2">true</span><span class="s1">);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">next = beginWork$1(current, unitOfWork, subtreeRenderLanes);</span>
    <span class="s1">}</span>

    <span class="s1">resetCurrentFiber();</span>
    <span class="s1">unitOfWork.memoizedProps = unitOfWork.pendingProps;</span>

    <span class="s2">if </span><span class="s1">(next === </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s0">// If this doesn't spawn new work, complete the current work.</span>
      <span class="s1">completeUnitOfWork(unitOfWork);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">workInProgress = next;</span>
    <span class="s1">}</span>

    <span class="s1">ReactCurrentOwner$2.current = </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">completeUnitOfWork(unitOfWork) {</span>
    <span class="s0">// Attempt to complete the current unit of work, then move to the next</span>
    <span class="s0">// sibling. If there are no more siblings, return to the parent fiber.</span>
    <span class="s2">var </span><span class="s1">completedWork = unitOfWork;</span>

    <span class="s2">do </span><span class="s1">{</span>
      <span class="s0">// The current, flushed, state of this fiber is the alternate. Ideally</span>
      <span class="s0">// nothing should rely on this, but relying on it here means that we don't</span>
      <span class="s0">// need an additional field on the work in progress.</span>
      <span class="s2">var </span><span class="s1">current = completedWork.alternate;</span>
      <span class="s2">var </span><span class="s1">returnFiber = completedWork.</span><span class="s2">return</span><span class="s1">; </span><span class="s0">// Check if the work completed or if something threw.</span>

      <span class="s2">if </span><span class="s1">((completedWork.flags &amp; Incomplete) === NoFlags) {</span>
        <span class="s1">setCurrentFiber(completedWork);</span>
        <span class="s2">var </span><span class="s1">next = </span><span class="s2">void </span><span class="s4">0</span><span class="s1">;</span>

        <span class="s2">if </span><span class="s1">( (completedWork.mode &amp; ProfileMode) === NoMode) {</span>
          <span class="s1">next = completeWork(current, completedWork, subtreeRenderLanes);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">startProfilerTimer(completedWork);</span>
          <span class="s1">next = completeWork(current, completedWork, subtreeRenderLanes); </span><span class="s0">// Update render duration assuming we didn't error.</span>

          <span class="s1">stopProfilerTimerIfRunningAndRecordDelta(completedWork, </span><span class="s2">false</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s1">resetCurrentFiber();</span>

        <span class="s2">if </span><span class="s1">(next !== </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s0">// Completing this fiber spawned new work. Work on that next.</span>
          <span class="s1">workInProgress = next;</span>
          <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s0">// This fiber did not complete because something threw. Pop values off</span>
        <span class="s0">// the stack without entering the complete phase. If this is a boundary,</span>
        <span class="s0">// capture values if possible.</span>
        <span class="s2">var </span><span class="s1">_next = unwindWork(current, completedWork); </span><span class="s0">// Because this fiber did not complete, don't reset its lanes.</span>


        <span class="s2">if </span><span class="s1">(_next !== </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s0">// If completing this work spawned new work, do that next. We'll come</span>
          <span class="s0">// back here again.</span>
          <span class="s0">// Since we're restarting, remove anything that is not a host effect</span>
          <span class="s0">// from the effect tag.</span>
          <span class="s1">_next.flags &amp;= HostEffectMask;</span>
          <span class="s1">workInProgress = _next;</span>
          <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">( (completedWork.mode &amp; ProfileMode) !== NoMode) {</span>
          <span class="s0">// Record the render duration for the fiber that errored.</span>
          <span class="s1">stopProfilerTimerIfRunningAndRecordDelta(completedWork, </span><span class="s2">false</span><span class="s1">); </span><span class="s0">// Include the time spent working on failed children before continuing.</span>

          <span class="s2">var </span><span class="s1">actualDuration = completedWork.actualDuration;</span>
          <span class="s2">var </span><span class="s1">child = completedWork.child;</span>

          <span class="s2">while </span><span class="s1">(child !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">actualDuration += child.actualDuration;</span>
            <span class="s1">child = child.sibling;</span>
          <span class="s1">}</span>

          <span class="s1">completedWork.actualDuration = actualDuration;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(returnFiber !== </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s0">// Mark the parent fiber as incomplete and clear its subtree flags.</span>
          <span class="s1">returnFiber.flags |= Incomplete;</span>
          <span class="s1">returnFiber.subtreeFlags = NoFlags;</span>
          <span class="s1">returnFiber.deletions = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s0">// We've unwound all the way to the root.</span>
          <span class="s1">workInProgressRootExitStatus = RootDidNotComplete;</span>
          <span class="s1">workInProgress = </span><span class="s2">null</span><span class="s1">;</span>
          <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">siblingFiber = completedWork.sibling;</span>

      <span class="s2">if </span><span class="s1">(siblingFiber !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s0">// If there is more work to do in this returnFiber, do that next.</span>
        <span class="s1">workInProgress = siblingFiber;</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// Otherwise, return to the parent</span>


      <span class="s1">completedWork = returnFiber; </span><span class="s0">// Update the next thing we're working on in case something throws.</span>

      <span class="s1">workInProgress = completedWork;</span>
    <span class="s1">} </span><span class="s2">while </span><span class="s1">(completedWork !== </span><span class="s2">null</span><span class="s1">); </span><span class="s0">// We've reached the root.</span>


    <span class="s2">if </span><span class="s1">(workInProgressRootExitStatus === RootInProgress) {</span>
      <span class="s1">workInProgressRootExitStatus = RootCompleted;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">commitRoot(root, recoverableErrors, transitions) {</span>
    <span class="s0">// TODO: This no longer makes any sense. We already wrap the mutation and</span>
    <span class="s0">// layout phases. Should be able to remove.</span>
    <span class="s2">var </span><span class="s1">previousUpdateLanePriority = getCurrentUpdatePriority();</span>
    <span class="s2">var </span><span class="s1">prevTransition = ReactCurrentBatchConfig$2.transition;</span>

    <span class="s2">try </span><span class="s1">{</span>
      <span class="s1">ReactCurrentBatchConfig$2.transition = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">setCurrentUpdatePriority(DiscreteEventPriority);</span>
      <span class="s1">commitRootImpl(root, recoverableErrors, transitions, previousUpdateLanePriority);</span>
    <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
      <span class="s1">ReactCurrentBatchConfig$2.transition = prevTransition;</span>
      <span class="s1">setCurrentUpdatePriority(previousUpdateLanePriority);</span>
    <span class="s1">}</span>

    <span class="s2">return null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">commitRootImpl(root, recoverableErrors, transitions, renderPriorityLevel) {</span>
    <span class="s2">do </span><span class="s1">{</span>
      <span class="s0">// `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which</span>
      <span class="s0">// means `flushPassiveEffects` will sometimes result in additional</span>
      <span class="s0">// passive effects. So we need to keep flushing in a loop until there are</span>
      <span class="s0">// no more pending effects.</span>
      <span class="s0">// TODO: Might be better if `flushPassiveEffects` did not automatically</span>
      <span class="s0">// flush synchronous work at the end, to avoid factoring hazards like this.</span>
      <span class="s1">flushPassiveEffects();</span>
    <span class="s1">} </span><span class="s2">while </span><span class="s1">(rootWithPendingPassiveEffects !== </span><span class="s2">null</span><span class="s1">);</span>

    <span class="s1">flushRenderPhaseStrictModeWarningsInDEV();</span>

    <span class="s2">if </span><span class="s1">((executionContext &amp; (RenderContext | CommitContext)) !== NoContext) {</span>
      <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Should not already be working.'</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">finishedWork = root.finishedWork;</span>
    <span class="s2">var </span><span class="s1">lanes = root.finishedLanes;</span>

    <span class="s2">if </span><span class="s1">(finishedWork === </span><span class="s2">null</span><span class="s1">) {</span>

      <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(lanes === NoLanes) {</span>
          <span class="s1">error(</span><span class="s3">'root.finishedLanes should not be empty during a commit. This is a ' </span><span class="s1">+ </span><span class="s3">'bug in React.'</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">root.finishedWork = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">root.finishedLanes = NoLanes;</span>

    <span class="s2">if </span><span class="s1">(finishedWork === root.current) {</span>
      <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Cannot commit the same tree as before. This error is likely caused by ' </span><span class="s1">+ </span><span class="s3">'a bug in React. Please file an issue.'</span><span class="s1">);</span>
    <span class="s1">} </span><span class="s0">// commitRoot never returns a continuation; it always finishes synchronously.</span>
    <span class="s0">// So we can clear these now to allow a new callback to be scheduled.</span>


    <span class="s1">root.callbackNode = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">root.callbackPriority = NoLane; </span><span class="s0">// Update the first and last pending times on this root. The new first</span>
    <span class="s0">// pending time is whatever is left on the root fiber.</span>

    <span class="s2">var </span><span class="s1">remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);</span>
    <span class="s1">markRootFinished(root, remainingLanes);</span>

    <span class="s2">if </span><span class="s1">(root === workInProgressRoot) {</span>
      <span class="s0">// We can reset these now that they are finished.</span>
      <span class="s1">workInProgressRoot = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">workInProgress = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">workInProgressRootRenderLanes = NoLanes;</span>
    <span class="s1">} </span><span class="s0">// If there are pending passive effects, schedule a callback to process them.</span>
    <span class="s0">// Do this as early as possible, so it is queued before anything else that</span>
    <span class="s0">// might get scheduled in the commit phase. (See #16714.)</span>
    <span class="s0">// TODO: Delete all other places that schedule the passive effect callback</span>
    <span class="s0">// They're redundant.</span>


    <span class="s2">if </span><span class="s1">((finishedWork.subtreeFlags &amp; PassiveMask) !== NoFlags || (finishedWork.flags &amp; PassiveMask) !== NoFlags) {</span>
      <span class="s2">if </span><span class="s1">(!rootDoesHavePassiveEffects) {</span>
        <span class="s1">rootDoesHavePassiveEffects = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s0">// to store it in pendingPassiveTransitions until they get processed</span>
        <span class="s0">// We need to pass this through as an argument to commitRoot</span>
        <span class="s0">// because workInProgressTransitions might have changed between</span>
        <span class="s0">// the previous render and commit if we throttle the commit</span>
        <span class="s0">// with setTimeout</span>

        <span class="s1">pendingPassiveTransitions = transitions;</span>
        <span class="s1">scheduleCallback$1(NormalPriority, </span><span class="s2">function </span><span class="s1">() {</span>
          <span class="s1">flushPassiveEffects(); </span><span class="s0">// This render triggered passive effects: release the root cache pool</span>
          <span class="s0">// *after* passive effects fire to avoid freeing a cache pool that may</span>
          <span class="s0">// be referenced by a node in the tree (HostRoot, Cache boundary etc)</span>

          <span class="s2">return null</span><span class="s1">;</span>
        <span class="s1">});</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// Check if there are any effects in the whole tree.</span>
    <span class="s0">// TODO: This is left over from the effect list implementation, where we had</span>
    <span class="s0">// to check for the existence of `firstEffect` to satisfy Flow. I think the</span>
    <span class="s0">// only other reason this optimization exists is because it affects profiling.</span>
    <span class="s0">// Reconsider whether this is necessary.</span>


    <span class="s2">var </span><span class="s1">subtreeHasEffects = (finishedWork.subtreeFlags &amp; (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;</span>
    <span class="s2">var </span><span class="s1">rootHasEffect = (finishedWork.flags &amp; (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;</span>

    <span class="s2">if </span><span class="s1">(subtreeHasEffects || rootHasEffect) {</span>
      <span class="s2">var </span><span class="s1">prevTransition = ReactCurrentBatchConfig$2.transition;</span>
      <span class="s1">ReactCurrentBatchConfig$2.transition = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s2">var </span><span class="s1">previousPriority = getCurrentUpdatePriority();</span>
      <span class="s1">setCurrentUpdatePriority(DiscreteEventPriority);</span>
      <span class="s2">var </span><span class="s1">prevExecutionContext = executionContext;</span>
      <span class="s1">executionContext |= CommitContext; </span><span class="s0">// Reset this to null before calling lifecycles</span>

      <span class="s1">ReactCurrentOwner$2.current = </span><span class="s2">null</span><span class="s1">; </span><span class="s0">// The commit phase is broken into several sub-phases. We do a separate pass</span>
      <span class="s0">// of the effect list for each phase: all mutation effects come before all</span>
      <span class="s0">// layout effects, and so on.</span>
      <span class="s0">// The first phase a &quot;before mutation&quot; phase. We use this phase to read the</span>
      <span class="s0">// state of the host tree right before we mutate it. This is where</span>
      <span class="s0">// getSnapshotBeforeUpdate is called.</span>

      <span class="s2">var </span><span class="s1">shouldFireAfterActiveInstanceBlur = commitBeforeMutationEffects(root, finishedWork);</span>

      <span class="s1">{</span>
        <span class="s0">// Mark the current commit time to be shared by all Profilers in this</span>
        <span class="s0">// batch. This enables them to be grouped later.</span>
        <span class="s1">recordCommitTime();</span>
      <span class="s1">}</span>


      <span class="s1">commitMutationEffects(root, finishedWork);</span>

      <span class="s1">resetAfterCommit(root.containerInfo); </span><span class="s0">// The work-in-progress tree is now the current tree. This must come after</span>
      <span class="s0">// the mutation phase, so that the previous tree is still current during</span>
      <span class="s0">// componentWillUnmount, but before the layout phase, so that the finished</span>
      <span class="s0">// work is current during componentDidMount/Update.</span>

      <span class="s1">root.current = finishedWork; </span><span class="s0">// The next phase is the layout phase, where we call effects that read</span>

      <span class="s1">commitLayoutEffects(finishedWork, root, lanes);</span>
      <span class="s0">// opportunity to paint.</span>


      <span class="s1">requestPaint();</span>
      <span class="s1">executionContext = prevExecutionContext; </span><span class="s0">// Reset the priority to the previous non-sync value.</span>

      <span class="s1">setCurrentUpdatePriority(previousPriority);</span>
      <span class="s1">ReactCurrentBatchConfig$2.transition = prevTransition;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s0">// No effects.</span>
      <span class="s1">root.current = finishedWork; </span><span class="s0">// Measure these anyway so the flamegraph explicitly shows that there were</span>
      <span class="s0">// no effects.</span>
      <span class="s0">// TODO: Maybe there's a better way to report this.</span>

      <span class="s1">{</span>
        <span class="s1">recordCommitTime();</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(rootDoesHavePassiveEffects) {</span>
      <span class="s0">// This commit has passive effects. Stash a reference to them. But don't</span>
      <span class="s0">// schedule a callback until after flushing layout work.</span>
      <span class="s1">rootDoesHavePassiveEffects = </span><span class="s2">false</span><span class="s1">;</span>
      <span class="s1">rootWithPendingPassiveEffects = root;</span>
      <span class="s1">pendingPassiveEffectsLanes = lanes;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>

      <span class="s1">{</span>
        <span class="s1">nestedPassiveUpdateCount = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">rootWithPassiveNestedUpdates = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// Read this again, since an effect might have updated it</span>


    <span class="s1">remainingLanes = root.pendingLanes; </span><span class="s0">// Check if there's remaining work on this root</span>
    <span class="s0">// TODO: This is part of the `componentDidCatch` implementation. Its purpose</span>
    <span class="s0">// is to detect whether something might have called setState inside</span>
    <span class="s0">// `componentDidCatch`. The mechanism is known to be flawed because `setState`</span>
    <span class="s0">// inside `componentDidCatch` is itself flawed  that's why we recommend</span>
    <span class="s0">// `getDerivedStateFromError` instead. However, it could be improved by</span>
    <span class="s0">// checking if remainingLanes includes Sync work, instead of whether there's</span>
    <span class="s0">// any work remaining at all (which would also include stuff like Suspense</span>
    <span class="s0">// retries or transitions). It's been like this for a while, though, so fixing</span>
    <span class="s0">// it probably isn't that urgent.</span>

    <span class="s2">if </span><span class="s1">(remainingLanes === NoLanes) {</span>
      <span class="s0">// If there's no remaining work, we can clear the set of already failed</span>
      <span class="s0">// error boundaries.</span>
      <span class="s1">legacyErrorBoundariesThatAlreadyFailed = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">onCommitRoot(finishedWork.stateNode, renderPriorityLevel);</span>
    <span class="s0">// additional work on this root is scheduled.</span>


    <span class="s1">ensureRootIsScheduled(root, now());</span>

    <span class="s2">if </span><span class="s1">(recoverableErrors !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s0">// There were errors during this render, but recovered from them without</span>
      <span class="s0">// needing to surface it to the UI. We log them here.</span>
      <span class="s2">var </span><span class="s1">onRecoverableError = root.onRecoverableError;</span>

      <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; recoverableErrors.length; i++) {</span>
        <span class="s2">var </span><span class="s1">recoverableError = recoverableErrors[i];</span>
        <span class="s2">var </span><span class="s1">componentStack = recoverableError.stack;</span>
        <span class="s2">var </span><span class="s1">digest = recoverableError.digest;</span>
        <span class="s1">onRecoverableError(recoverableError.value, {</span>
          <span class="s1">componentStack: componentStack,</span>
          <span class="s1">digest: digest</span>
        <span class="s1">});</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(hasUncaughtError) {</span>
      <span class="s1">hasUncaughtError = </span><span class="s2">false</span><span class="s1">;</span>
      <span class="s2">var </span><span class="s1">error$1 = firstUncaughtError;</span>
      <span class="s1">firstUncaughtError = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s2">throw </span><span class="s1">error$1;</span>
    <span class="s1">} </span><span class="s0">// If the passive effects are the result of a discrete render, flush them</span>
    <span class="s0">// synchronously at the end of the current task so that the result is</span>
    <span class="s0">// immediately observable. Otherwise, we assume that they are not</span>
    <span class="s0">// order-dependent and do not need to be observed by external systems, so we</span>
    <span class="s0">// can wait until after paint.</span>
    <span class="s0">// TODO: We can optimize this by not scheduling the callback earlier. Since we</span>
    <span class="s0">// currently schedule the callback in multiple places, will wait until those</span>
    <span class="s0">// are consolidated.</span>


    <span class="s2">if </span><span class="s1">(includesSomeLane(pendingPassiveEffectsLanes, SyncLane) &amp;&amp; root.tag !== LegacyRoot) {</span>
      <span class="s1">flushPassiveEffects();</span>
    <span class="s1">} </span><span class="s0">// Read this again, since a passive effect might have updated it</span>


    <span class="s1">remainingLanes = root.pendingLanes;</span>

    <span class="s2">if </span><span class="s1">(includesSomeLane(remainingLanes, SyncLane)) {</span>
      <span class="s1">{</span>
        <span class="s1">markNestedUpdateScheduled();</span>
      <span class="s1">} </span><span class="s0">// Count the number of times the root synchronously re-renders without</span>
      <span class="s0">// finishing. If there are too many, it indicates an infinite update loop.</span>


      <span class="s2">if </span><span class="s1">(root === rootWithNestedUpdates) {</span>
        <span class="s1">nestedUpdateCount++;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">nestedUpdateCount = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">rootWithNestedUpdates = root;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">nestedUpdateCount = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s0">// If layout work was scheduled, flush it now.</span>


    <span class="s1">flushSyncCallbacks();</span>

    <span class="s2">return null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">flushPassiveEffects() {</span>
    <span class="s0">// Returns whether passive effects were flushed.</span>
    <span class="s0">// TODO: Combine this check with the one in flushPassiveEFfectsImpl. We should</span>
    <span class="s0">// probably just combine the two functions. I believe they were only separate</span>
    <span class="s0">// in the first place because we used to wrap it with</span>
    <span class="s0">// `Scheduler.runWithPriority`, which accepts a function. But now we track the</span>
    <span class="s0">// priority within React itself, so we can mutate the variable directly.</span>
    <span class="s2">if </span><span class="s1">(rootWithPendingPassiveEffects !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes);</span>
      <span class="s2">var </span><span class="s1">priority = lowerEventPriority(DefaultEventPriority, renderPriority);</span>
      <span class="s2">var </span><span class="s1">prevTransition = ReactCurrentBatchConfig$2.transition;</span>
      <span class="s2">var </span><span class="s1">previousPriority = getCurrentUpdatePriority();</span>

      <span class="s2">try </span><span class="s1">{</span>
        <span class="s1">ReactCurrentBatchConfig$2.transition = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s1">setCurrentUpdatePriority(priority);</span>
        <span class="s2">return </span><span class="s1">flushPassiveEffectsImpl();</span>
      <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
        <span class="s1">setCurrentUpdatePriority(previousPriority);</span>
        <span class="s1">ReactCurrentBatchConfig$2.transition = prevTransition; </span><span class="s0">// Once passive effects have run for the tree - giving components a</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return false</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">enqueuePendingPassiveProfilerEffect(fiber) {</span>
    <span class="s1">{</span>
      <span class="s1">pendingPassiveProfilerEffects.push(fiber);</span>

      <span class="s2">if </span><span class="s1">(!rootDoesHavePassiveEffects) {</span>
        <span class="s1">rootDoesHavePassiveEffects = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">scheduleCallback$1(NormalPriority, </span><span class="s2">function </span><span class="s1">() {</span>
          <span class="s1">flushPassiveEffects();</span>
          <span class="s2">return null</span><span class="s1">;</span>
        <span class="s1">});</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">flushPassiveEffectsImpl() {</span>
    <span class="s2">if </span><span class="s1">(rootWithPendingPassiveEffects === </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s0">// Cache and clear the transitions flag</span>


    <span class="s2">var </span><span class="s1">transitions = pendingPassiveTransitions;</span>
    <span class="s1">pendingPassiveTransitions = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">var </span><span class="s1">root = rootWithPendingPassiveEffects;</span>
    <span class="s2">var </span><span class="s1">lanes = pendingPassiveEffectsLanes;</span>
    <span class="s1">rootWithPendingPassiveEffects = </span><span class="s2">null</span><span class="s1">; </span><span class="s0">// TODO: This is sometimes out of sync with rootWithPendingPassiveEffects.</span>
    <span class="s0">// Figure out why and fix it. It's not causing any known issues (probably</span>
    <span class="s0">// because it's only used for profiling), but it's a refactor hazard.</span>

    <span class="s1">pendingPassiveEffectsLanes = NoLanes;</span>

    <span class="s2">if </span><span class="s1">((executionContext &amp; (RenderContext | CommitContext)) !== NoContext) {</span>
      <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Cannot flush passive effects while already rendering.'</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s1">isFlushingPassiveEffects = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s1">didScheduleUpdateDuringPassiveEffects = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">prevExecutionContext = executionContext;</span>
    <span class="s1">executionContext |= CommitContext;</span>
    <span class="s1">commitPassiveUnmountEffects(root.current);</span>
    <span class="s1">commitPassiveMountEffects(root, root.current, lanes, transitions); </span><span class="s0">// TODO: Move to commitPassiveMountEffects</span>

    <span class="s1">{</span>
      <span class="s2">var </span><span class="s1">profilerEffects = pendingPassiveProfilerEffects;</span>
      <span class="s1">pendingPassiveProfilerEffects = [];</span>

      <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; profilerEffects.length; i++) {</span>
        <span class="s2">var </span><span class="s1">_fiber = profilerEffects[i];</span>
        <span class="s1">commitPassiveEffectDurations(root, _fiber);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">executionContext = prevExecutionContext;</span>
    <span class="s1">flushSyncCallbacks();</span>

    <span class="s1">{</span>
      <span class="s0">// If additional passive effects were scheduled, increment a counter. If this</span>
      <span class="s0">// exceeds the limit, we'll fire a warning.</span>
      <span class="s2">if </span><span class="s1">(didScheduleUpdateDuringPassiveEffects) {</span>
        <span class="s2">if </span><span class="s1">(root === rootWithPassiveNestedUpdates) {</span>
          <span class="s1">nestedPassiveUpdateCount++;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">nestedPassiveUpdateCount = </span><span class="s4">0</span><span class="s1">;</span>
          <span class="s1">rootWithPassiveNestedUpdates = root;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">nestedPassiveUpdateCount = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">isFlushingPassiveEffects = </span><span class="s2">false</span><span class="s1">;</span>
      <span class="s1">didScheduleUpdateDuringPassiveEffects = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s0">// TODO: Move to commitPassiveMountEffects</span>


    <span class="s1">onPostCommitRoot(root);</span>

    <span class="s1">{</span>
      <span class="s2">var </span><span class="s1">stateNode = root.current.stateNode;</span>
      <span class="s1">stateNode.effectDuration = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s1">stateNode.passiveEffectDuration = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">return true</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">isAlreadyFailedLegacyErrorBoundary(instance) {</span>
    <span class="s2">return </span><span class="s1">legacyErrorBoundariesThatAlreadyFailed !== </span><span class="s2">null </span><span class="s1">&amp;&amp; legacyErrorBoundariesThatAlreadyFailed.has(instance);</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">markLegacyErrorBoundaryAsFailed(instance) {</span>
    <span class="s2">if </span><span class="s1">(legacyErrorBoundariesThatAlreadyFailed === </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">legacyErrorBoundariesThatAlreadyFailed = </span><span class="s2">new </span><span class="s1">Set([instance]);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">legacyErrorBoundariesThatAlreadyFailed.add(instance);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">prepareToThrowUncaughtError(error) {</span>
    <span class="s2">if </span><span class="s1">(!hasUncaughtError) {</span>
      <span class="s1">hasUncaughtError = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s1">firstUncaughtError = error;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">onUncaughtError = prepareToThrowUncaughtError;</span>

  <span class="s2">function </span><span class="s1">captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {</span>
    <span class="s2">var </span><span class="s1">errorInfo = createCapturedValueAtFiber(error, sourceFiber);</span>
    <span class="s2">var </span><span class="s1">update = createRootErrorUpdate(rootFiber, errorInfo, SyncLane);</span>
    <span class="s2">var </span><span class="s1">root = enqueueUpdate(rootFiber, update, SyncLane);</span>
    <span class="s2">var </span><span class="s1">eventTime = requestEventTime();</span>

    <span class="s2">if </span><span class="s1">(root !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">markRootUpdated(root, SyncLane, eventTime);</span>
      <span class="s1">ensureRootIsScheduled(root, eventTime);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error$1) {</span>
    <span class="s1">{</span>
      <span class="s1">reportUncaughtErrorInDEV(error$1);</span>
      <span class="s1">setIsRunningInsertionEffect(</span><span class="s2">false</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(sourceFiber.tag === HostRoot) {</span>
      <span class="s0">// Error was thrown at the root. There is no parent, so the root</span>
      <span class="s0">// itself should capture it.</span>
      <span class="s1">captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error$1);</span>
      <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">fiber = </span><span class="s2">null</span><span class="s1">;</span>

    <span class="s1">{</span>
      <span class="s1">fiber = sourceFiber.</span><span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">while </span><span class="s1">(fiber !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(fiber.tag === HostRoot) {</span>
        <span class="s1">captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error$1);</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(fiber.tag === ClassComponent) {</span>
        <span class="s2">var </span><span class="s1">ctor = fiber.type;</span>
        <span class="s2">var </span><span class="s1">instance = fiber.stateNode;</span>

        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">ctor.getDerivedStateFromError === </span><span class="s3">'function' </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">instance.componentDidCatch === </span><span class="s3">'function' </span><span class="s1">&amp;&amp; !isAlreadyFailedLegacyErrorBoundary(instance)) {</span>
          <span class="s2">var </span><span class="s1">errorInfo = createCapturedValueAtFiber(error$1, sourceFiber);</span>
          <span class="s2">var </span><span class="s1">update = createClassErrorUpdate(fiber, errorInfo, SyncLane);</span>
          <span class="s2">var </span><span class="s1">root = enqueueUpdate(fiber, update, SyncLane);</span>
          <span class="s2">var </span><span class="s1">eventTime = requestEventTime();</span>

          <span class="s2">if </span><span class="s1">(root !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">markRootUpdated(root, SyncLane, eventTime);</span>
            <span class="s1">ensureRootIsScheduled(root, eventTime);</span>
          <span class="s1">}</span>

          <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">fiber = fiber.</span><span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s0">// TODO: Until we re-land skipUnmountedBoundaries (see #20147), this warning</span>
      <span class="s0">// will fire for errors that are thrown by destroy functions inside deleted</span>
      <span class="s0">// trees. What it should instead do is propagate the error to the parent of</span>
      <span class="s0">// the deleted tree. In the meantime, do not add this warning to the</span>
      <span class="s0">// allowlist; this is only for our internal use.</span>
      <span class="s1">error(</span><span class="s3">'Internal React error: Attempted to capture a commit phase error ' </span><span class="s1">+ </span><span class="s3">'inside a detached tree. This indicates a bug in React. Likely ' </span><span class="s1">+ </span><span class="s3">'causes include deleting the same fiber more than once, committing an ' </span><span class="s1">+ </span><span class="s3">'already-finished tree, or an inconsistent return pointer.</span><span class="s5">\n\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">'Error message:</span><span class="s5">\n\n</span><span class="s3">%s'</span><span class="s1">, error$1);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">pingSuspendedRoot(root, wakeable, pingedLanes) {</span>
    <span class="s2">var </span><span class="s1">pingCache = root.pingCache;</span>

    <span class="s2">if </span><span class="s1">(pingCache !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s0">// The wakeable resolved, so we no longer need to memoize, because it will</span>
      <span class="s0">// never be thrown again.</span>
      <span class="s1">pingCache.</span><span class="s2">delete</span><span class="s1">(wakeable);</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">eventTime = requestEventTime();</span>
    <span class="s1">markRootPinged(root, pingedLanes);</span>
    <span class="s1">warnIfSuspenseResolutionNotWrappedWithActDEV(root);</span>

    <span class="s2">if </span><span class="s1">(workInProgressRoot === root &amp;&amp; isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)) {</span>
      <span class="s0">// Received a ping at the same priority level at which we're currently</span>
      <span class="s0">// rendering. We might want to restart this render. This should mirror</span>
      <span class="s0">// the logic of whether or not a root suspends once it completes.</span>
      <span class="s0">// TODO: If we're rendering sync either due to Sync, Batched or expired,</span>
      <span class="s0">// we should probably never restart.</span>
      <span class="s0">// If we're suspended with delay, or if it's a retry, we'll always suspend</span>
      <span class="s0">// so we can always restart.</span>
      <span class="s2">if </span><span class="s1">(workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended &amp;&amp; includesOnlyRetries(workInProgressRootRenderLanes) &amp;&amp; now() - globalMostRecentFallbackTime &lt; FALLBACK_THROTTLE_MS) {</span>
        <span class="s0">// Restart from the root.</span>
        <span class="s1">prepareFreshStack(root, NoLanes);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s0">// Even though we can't restart right now, we might get an</span>
        <span class="s0">// opportunity later. So we mark this render as having a ping.</span>
        <span class="s1">workInProgressRootPingedLanes = mergeLanes(workInProgressRootPingedLanes, pingedLanes);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">ensureRootIsScheduled(root, eventTime);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">retryTimedOutBoundary(boundaryFiber, retryLane) {</span>
    <span class="s0">// The boundary fiber (a Suspense component or SuspenseList component)</span>
    <span class="s0">// previously was rendered in its fallback state. One of the promises that</span>
    <span class="s0">// suspended it has resolved, which means at least part of the tree was</span>
    <span class="s0">// likely unblocked. Try rendering again, at a new lanes.</span>
    <span class="s2">if </span><span class="s1">(retryLane === NoLane) {</span>
      <span class="s0">// TODO: Assign this to `suspenseState.retryLane`? to avoid</span>
      <span class="s0">// unnecessary entanglement?</span>
      <span class="s1">retryLane = requestRetryLane(boundaryFiber);</span>
    <span class="s1">} </span><span class="s0">// TODO: Special case idle priority?</span>


    <span class="s2">var </span><span class="s1">eventTime = requestEventTime();</span>
    <span class="s2">var </span><span class="s1">root = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);</span>

    <span class="s2">if </span><span class="s1">(root !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">markRootUpdated(root, retryLane, eventTime);</span>
      <span class="s1">ensureRootIsScheduled(root, eventTime);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">retryDehydratedSuspenseBoundary(boundaryFiber) {</span>
    <span class="s2">var </span><span class="s1">suspenseState = boundaryFiber.memoizedState;</span>
    <span class="s2">var </span><span class="s1">retryLane = NoLane;</span>

    <span class="s2">if </span><span class="s1">(suspenseState !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">retryLane = suspenseState.retryLane;</span>
    <span class="s1">}</span>

    <span class="s1">retryTimedOutBoundary(boundaryFiber, retryLane);</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">resolveRetryWakeable(boundaryFiber, wakeable) {</span>
    <span class="s2">var </span><span class="s1">retryLane = NoLane; </span><span class="s0">// Default</span>

    <span class="s2">var </span><span class="s1">retryCache;</span>

    <span class="s2">switch </span><span class="s1">(boundaryFiber.tag) {</span>
      <span class="s2">case </span><span class="s1">SuspenseComponent:</span>
        <span class="s1">retryCache = boundaryFiber.stateNode;</span>
        <span class="s2">var </span><span class="s1">suspenseState = boundaryFiber.memoizedState;</span>

        <span class="s2">if </span><span class="s1">(suspenseState !== </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">retryLane = suspenseState.retryLane;</span>
        <span class="s1">}</span>

        <span class="s2">break</span><span class="s1">;</span>

      <span class="s2">case </span><span class="s1">SuspenseListComponent:</span>
        <span class="s1">retryCache = boundaryFiber.stateNode;</span>
        <span class="s2">break</span><span class="s1">;</span>

      <span class="s2">default</span><span class="s1">:</span>
        <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Pinged unknown suspense boundary type. ' </span><span class="s1">+ </span><span class="s3">'This is probably a bug in React.'</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(retryCache !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s0">// The wakeable resolved, so we no longer need to memoize, because it will</span>
      <span class="s0">// never be thrown again.</span>
      <span class="s1">retryCache.</span><span class="s2">delete</span><span class="s1">(wakeable);</span>
    <span class="s1">}</span>

    <span class="s1">retryTimedOutBoundary(boundaryFiber, retryLane);</span>
  <span class="s1">} </span><span class="s0">// Computes the next Just Noticeable Difference (JND) boundary.</span>
  <span class="s0">// The theory is that a person can't tell the difference between small differences in time.</span>
  <span class="s0">// Therefore, if we wait a bit longer than necessary that won't translate to a noticeable</span>
  <span class="s0">// difference in the experience. However, waiting for longer might mean that we can avoid</span>
  <span class="s0">// showing an intermediate loading state. The longer we have already waited, the harder it</span>
  <span class="s0">// is to tell small differences in time. Therefore, the longer we've already waited,</span>
  <span class="s0">// the longer we can wait additionally. At some point we have to give up though.</span>
  <span class="s0">// We pick a train model where the next boundary commits at a consistent schedule.</span>
  <span class="s0">// These particular numbers are vague estimates. We expect to adjust them based on research.</span>

  <span class="s2">function </span><span class="s1">jnd(timeElapsed) {</span>
    <span class="s2">return </span><span class="s1">timeElapsed &lt; </span><span class="s4">120 </span><span class="s1">? </span><span class="s4">120 </span><span class="s1">: timeElapsed &lt; </span><span class="s4">480 </span><span class="s1">? </span><span class="s4">480 </span><span class="s1">: timeElapsed &lt; </span><span class="s4">1080 </span><span class="s1">? </span><span class="s4">1080 </span><span class="s1">: timeElapsed &lt; </span><span class="s4">1920 </span><span class="s1">? </span><span class="s4">1920 </span><span class="s1">: timeElapsed &lt; </span><span class="s4">3000 </span><span class="s1">? </span><span class="s4">3000 </span><span class="s1">: timeElapsed &lt; </span><span class="s4">4320 </span><span class="s1">? </span><span class="s4">4320 </span><span class="s1">: ceil(timeElapsed / </span><span class="s4">1960</span><span class="s1">) * </span><span class="s4">1960</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">checkForNestedUpdates() {</span>
    <span class="s2">if </span><span class="s1">(nestedUpdateCount &gt; NESTED_UPDATE_LIMIT) {</span>
      <span class="s1">nestedUpdateCount = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s1">rootWithNestedUpdates = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Maximum update depth exceeded. This can happen when a component ' </span><span class="s1">+ </span><span class="s3">'repeatedly calls setState inside componentWillUpdate or ' </span><span class="s1">+ </span><span class="s3">'componentDidUpdate. React limits the number of nested updates to ' </span><span class="s1">+ </span><span class="s3">'prevent infinite loops.'</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(nestedPassiveUpdateCount &gt; NESTED_PASSIVE_UPDATE_LIMIT) {</span>
        <span class="s1">nestedPassiveUpdateCount = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">rootWithPassiveNestedUpdates = </span><span class="s2">null</span><span class="s1">;</span>

        <span class="s1">error(</span><span class="s3">'Maximum update depth exceeded. This can happen when a component ' </span><span class="s1">+ </span><span class="s3">&quot;calls setState inside useEffect, but useEffect either doesn't &quot; </span><span class="s1">+ </span><span class="s3">'have a dependency array, or one of the dependencies changes on ' </span><span class="s1">+ </span><span class="s3">'every render.'</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">flushRenderPhaseStrictModeWarningsInDEV() {</span>
    <span class="s1">{</span>
      <span class="s1">ReactStrictModeWarnings.flushLegacyContextWarning();</span>

      <span class="s1">{</span>
        <span class="s1">ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">didWarnStateUpdateForNotYetMountedComponent = </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s2">function </span><span class="s1">warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {</span>
    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">((executionContext &amp; RenderContext) !== NoContext) {</span>
        <span class="s0">// We let the other warning about render phase updates deal with this one.</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(!(fiber.mode &amp; ConcurrentMode)) {</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">tag = fiber.tag;</span>

      <span class="s2">if </span><span class="s1">(tag !== IndeterminateComponent &amp;&amp; tag !== HostRoot &amp;&amp; tag !== ClassComponent &amp;&amp; tag !== FunctionComponent &amp;&amp; tag !== ForwardRef &amp;&amp; tag !== MemoComponent &amp;&amp; tag !== SimpleMemoComponent) {</span>
        <span class="s0">// Only warn for user-defined components, not internal ones like Suspense.</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// We show the whole stack but dedupe on the top component's name because</span>
      <span class="s0">// the problematic code almost always lies inside that component.</span>


      <span class="s2">var </span><span class="s1">componentName = getComponentNameFromFiber(fiber) || </span><span class="s3">'ReactComponent'</span><span class="s1">;</span>

      <span class="s2">if </span><span class="s1">(didWarnStateUpdateForNotYetMountedComponent !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {</span>
          <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">didWarnStateUpdateForNotYetMountedComponent.add(componentName);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">didWarnStateUpdateForNotYetMountedComponent = </span><span class="s2">new </span><span class="s1">Set([componentName]);</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">previousFiber = current;</span>

      <span class="s2">try </span><span class="s1">{</span>
        <span class="s1">setCurrentFiber(fiber);</span>

        <span class="s1">error(</span><span class="s3">&quot;Can't perform a React state update on a component that hasn't mounted yet. &quot; </span><span class="s1">+ </span><span class="s3">'This indicates that you have a side-effect in your render function that ' </span><span class="s1">+ </span><span class="s3">'asynchronously later calls tries to update the component. Move this work to ' </span><span class="s1">+ </span><span class="s3">'useEffect instead.'</span><span class="s1">);</span>
      <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(previousFiber) {</span>
          <span class="s1">setCurrentFiber(fiber);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">resetCurrentFiber();</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">var </span><span class="s1">beginWork$1;</span>

  <span class="s1">{</span>
    <span class="s1">beginWork$1 = beginWork;</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">didWarnAboutUpdateInRender = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">didWarnAboutUpdateInRenderForAnotherComponent;</span>

  <span class="s1">{</span>
    <span class="s1">didWarnAboutUpdateInRenderForAnotherComponent = </span><span class="s2">new </span><span class="s1">Set();</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">warnAboutRenderPhaseUpdatesInDEV(fiber) {</span>
    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(isRendering &amp;&amp; !getIsUpdatingOpaqueValueInRenderPhaseInDEV()) {</span>
        <span class="s2">switch </span><span class="s1">(fiber.tag) {</span>
          <span class="s2">case </span><span class="s1">FunctionComponent:</span>
          <span class="s2">case </span><span class="s1">ForwardRef:</span>
          <span class="s2">case </span><span class="s1">SimpleMemoComponent:</span>
            <span class="s1">{</span>
              <span class="s2">var </span><span class="s1">renderingComponentName = workInProgress &amp;&amp; getComponentNameFromFiber(workInProgress) || </span><span class="s3">'Unknown'</span><span class="s1">; </span><span class="s0">// Dedupe by the rendering component because it's the one that needs to be fixed.</span>

              <span class="s2">var </span><span class="s1">dedupeKey = renderingComponentName;</span>

              <span class="s2">if </span><span class="s1">(!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {</span>
                <span class="s1">didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);</span>
                <span class="s2">var </span><span class="s1">setStateComponentName = getComponentNameFromFiber(fiber) || </span><span class="s3">'Unknown'</span><span class="s1">;</span>

                <span class="s1">error(</span><span class="s3">'Cannot update a component (`%s`) while rendering a ' </span><span class="s1">+ </span><span class="s3">'different component (`%s`). To locate the bad setState() call inside `%s`, ' </span><span class="s1">+ </span><span class="s3">'follow the stack trace as described in https://reactjs.org/link/setstate-in-render'</span><span class="s1">, setStateComponentName, renderingComponentName, renderingComponentName);</span>
              <span class="s1">}</span>

              <span class="s2">break</span><span class="s1">;</span>
            <span class="s1">}</span>

          <span class="s2">case </span><span class="s1">ClassComponent:</span>
            <span class="s1">{</span>
              <span class="s2">if </span><span class="s1">(!didWarnAboutUpdateInRender) {</span>
                <span class="s1">error(</span><span class="s3">'Cannot update during an existing state transition (such as ' </span><span class="s1">+ </span><span class="s3">'within `render`). Render methods should be a pure ' </span><span class="s1">+ </span><span class="s3">'function of props and state.'</span><span class="s1">);</span>

                <span class="s1">didWarnAboutUpdateInRender = </span><span class="s2">true</span><span class="s1">;</span>
              <span class="s1">}</span>

              <span class="s2">break</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">var </span><span class="s1">fakeActCallbackNode = {};</span>

  <span class="s2">function </span><span class="s1">scheduleCallback$1(priorityLevel, callback) {</span>
    <span class="s1">{</span>
      <span class="s0">// If we're currently inside an `act` scope, bypass Scheduler and push to</span>
      <span class="s0">// the `act` queue instead.</span>
      <span class="s2">var </span><span class="s1">actQueue = ReactCurrentActQueue$1.current;</span>

      <span class="s2">if </span><span class="s1">(actQueue !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">actQueue.push(callback);</span>
        <span class="s2">return </span><span class="s1">fakeActCallbackNode;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">return </span><span class="s1">scheduleCallback(priorityLevel, callback);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">cancelCallback$1(callbackNode) {</span>
    <span class="s2">if </span><span class="s1">( callbackNode === fakeActCallbackNode) {</span>
      <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s0">// In production, always call Scheduler. This function will be stripped out.</span>


    <span class="s2">return </span><span class="s1">cancelCallback(callbackNode);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">shouldForceFlushFallbacksInDEV() {</span>
    <span class="s0">// Never force flush in production. This function should get stripped out.</span>
    <span class="s2">return  </span><span class="s1">ReactCurrentActQueue$1.current !== </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">warnIfUpdatesNotWrappedWithActDEV(fiber) {</span>
    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(fiber.mode &amp; ConcurrentMode) {</span>
        <span class="s2">if </span><span class="s1">(!isConcurrentActEnvironment()) {</span>
          <span class="s0">// Not in an act environment. No need to warn.</span>
          <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s0">// Legacy mode has additional cases where we suppress a warning.</span>
        <span class="s2">if </span><span class="s1">(!isLegacyActEnvironment()) {</span>
          <span class="s0">// Not in an act environment. No need to warn.</span>
          <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(executionContext !== NoContext) {</span>
          <span class="s0">// Legacy mode doesn't warn if the update is batched, i.e.</span>
          <span class="s0">// batchedUpdates or flushSync.</span>
          <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(fiber.tag !== FunctionComponent &amp;&amp; fiber.tag !== ForwardRef &amp;&amp; fiber.tag !== SimpleMemoComponent) {</span>
          <span class="s0">// For backwards compatibility with pre-hooks code, legacy mode only</span>
          <span class="s0">// warns for updates that originate from a hook.</span>
          <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(ReactCurrentActQueue$1.current === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">var </span><span class="s1">previousFiber = current;</span>

        <span class="s2">try </span><span class="s1">{</span>
          <span class="s1">setCurrentFiber(fiber);</span>

          <span class="s1">error(</span><span class="s3">'An update to %s inside a test was not wrapped in act(...).</span><span class="s5">\n\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">'When testing, code that causes React state updates should be ' </span><span class="s1">+ </span><span class="s3">'wrapped into act(...):</span><span class="s5">\n\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">'act(() =&gt; {</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">'  /* fire events that update state */</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">'});</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">'/* assert on the output */</span><span class="s5">\n\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">&quot;This ensures that you're testing the behavior the user would see &quot; </span><span class="s1">+ </span><span class="s3">'in the browser.' </span><span class="s1">+ </span><span class="s3">' Learn more at https://reactjs.org/link/wrap-tests-with-act'</span><span class="s1">, getComponentNameFromFiber(fiber));</span>
        <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
          <span class="s2">if </span><span class="s1">(previousFiber) {</span>
            <span class="s1">setCurrentFiber(fiber);</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">resetCurrentFiber();</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">warnIfSuspenseResolutionNotWrappedWithActDEV(root) {</span>
    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(root.tag !== LegacyRoot &amp;&amp; isConcurrentActEnvironment() &amp;&amp; ReactCurrentActQueue$1.current === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s3">'A suspended resource finished loading inside a test, but the event ' </span><span class="s1">+ </span><span class="s3">'was not wrapped in act(...).</span><span class="s5">\n\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">'When testing, code that resolves suspended data should be wrapped ' </span><span class="s1">+ </span><span class="s3">'into act(...):</span><span class="s5">\n\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">'act(() =&gt; {</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">'  /* finish loading suspended data */</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">'});</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">'/* assert on the output */</span><span class="s5">\n\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">&quot;This ensures that you're testing the behavior the user would see &quot; </span><span class="s1">+ </span><span class="s3">'in the browser.' </span><span class="s1">+ </span><span class="s3">' Learn more at https://reactjs.org/link/wrap-tests-with-act'</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">setIsRunningInsertionEffect(isRunning) {</span>
    <span class="s1">{</span>
      <span class="s1">isRunningInsertionEffect = isRunning;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">/* eslint-disable react-internal/prod-error-codes */</span>
  <span class="s2">var </span><span class="s1">resolveFamily = </span><span class="s2">null</span><span class="s1">; </span><span class="s0">// $FlowFixMe Flow gets confused by a WeakSet feature check below.</span>

  <span class="s2">var </span><span class="s1">failedBoundaries = </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">setRefreshHandler = </span><span class="s2">function </span><span class="s1">(handler) {</span>
    <span class="s1">{</span>
      <span class="s1">resolveFamily = handler;</span>
    <span class="s1">}</span>
  <span class="s1">};</span>
  <span class="s2">function </span><span class="s1">resolveFunctionForHotReloading(type) {</span>
    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(resolveFamily === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s0">// Hot reloading is disabled.</span>
        <span class="s2">return </span><span class="s1">type;</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">family = resolveFamily(type);</span>

      <span class="s2">if </span><span class="s1">(family === undefined) {</span>
        <span class="s2">return </span><span class="s1">type;</span>
      <span class="s1">} </span><span class="s0">// Use the latest known implementation.</span>


      <span class="s2">return </span><span class="s1">family.current;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">resolveClassForHotReloading(type) {</span>
    <span class="s0">// No implementation differences.</span>
    <span class="s2">return </span><span class="s1">resolveFunctionForHotReloading(type);</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">resolveForwardRefForHotReloading(type) {</span>
    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(resolveFamily === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s0">// Hot reloading is disabled.</span>
        <span class="s2">return </span><span class="s1">type;</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">family = resolveFamily(type);</span>

      <span class="s2">if </span><span class="s1">(family === undefined) {</span>
        <span class="s0">// Check if we're dealing with a real forwardRef. Don't want to crash early.</span>
        <span class="s2">if </span><span class="s1">(type !== </span><span class="s2">null </span><span class="s1">&amp;&amp; type !== undefined &amp;&amp; </span><span class="s2">typeof </span><span class="s1">type.render === </span><span class="s3">'function'</span><span class="s1">) {</span>
          <span class="s0">// ForwardRef is special because its resolved .type is an object,</span>
          <span class="s0">// but it's possible that we only have its inner render function in the map.</span>
          <span class="s0">// If that inner render function is different, we'll build a new forwardRef type.</span>
          <span class="s2">var </span><span class="s1">currentRender = resolveFunctionForHotReloading(type.render);</span>

          <span class="s2">if </span><span class="s1">(type.render !== currentRender) {</span>
            <span class="s2">var </span><span class="s1">syntheticType = {</span>
              <span class="s1">$$typeof: REACT_FORWARD_REF_TYPE,</span>
              <span class="s1">render: currentRender</span>
            <span class="s1">};</span>

            <span class="s2">if </span><span class="s1">(type.displayName !== undefined) {</span>
              <span class="s1">syntheticType.displayName = type.displayName;</span>
            <span class="s1">}</span>

            <span class="s2">return </span><span class="s1">syntheticType;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s2">return </span><span class="s1">type;</span>
      <span class="s1">} </span><span class="s0">// Use the latest known implementation.</span>


      <span class="s2">return </span><span class="s1">family.current;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">isCompatibleFamilyForHotReloading(fiber, element) {</span>
    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(resolveFamily === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s0">// Hot reloading is disabled.</span>
        <span class="s2">return false</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">prevType = fiber.elementType;</span>
      <span class="s2">var </span><span class="s1">nextType = element.type; </span><span class="s0">// If we got here, we know types aren't === equal.</span>

      <span class="s2">var </span><span class="s1">needsCompareFamilies = </span><span class="s2">false</span><span class="s1">;</span>
      <span class="s2">var </span><span class="s1">$$typeofNextType = </span><span class="s2">typeof </span><span class="s1">nextType === </span><span class="s3">'object' </span><span class="s1">&amp;&amp; nextType !== </span><span class="s2">null </span><span class="s1">? nextType.$$typeof : </span><span class="s2">null</span><span class="s1">;</span>

      <span class="s2">switch </span><span class="s1">(fiber.tag) {</span>
        <span class="s2">case </span><span class="s1">ClassComponent:</span>
          <span class="s1">{</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">nextType === </span><span class="s3">'function'</span><span class="s1">) {</span>
              <span class="s1">needsCompareFamilies = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s2">break</span><span class="s1">;</span>
          <span class="s1">}</span>

        <span class="s2">case </span><span class="s1">FunctionComponent:</span>
          <span class="s1">{</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">nextType === </span><span class="s3">'function'</span><span class="s1">) {</span>
              <span class="s1">needsCompareFamilies = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s2">else if </span><span class="s1">($$typeofNextType === REACT_LAZY_TYPE) {</span>
              <span class="s0">// We don't know the inner type yet.</span>
              <span class="s0">// We're going to assume that the lazy inner type is stable,</span>
              <span class="s0">// and so it is sufficient to avoid reconciling it away.</span>
              <span class="s0">// We're not going to unwrap or actually use the new lazy type.</span>
              <span class="s1">needsCompareFamilies = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s2">break</span><span class="s1">;</span>
          <span class="s1">}</span>

        <span class="s2">case </span><span class="s1">ForwardRef:</span>
          <span class="s1">{</span>
            <span class="s2">if </span><span class="s1">($$typeofNextType === REACT_FORWARD_REF_TYPE) {</span>
              <span class="s1">needsCompareFamilies = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s2">else if </span><span class="s1">($$typeofNextType === REACT_LAZY_TYPE) {</span>
              <span class="s1">needsCompareFamilies = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s2">break</span><span class="s1">;</span>
          <span class="s1">}</span>

        <span class="s2">case </span><span class="s1">MemoComponent:</span>
        <span class="s2">case </span><span class="s1">SimpleMemoComponent:</span>
          <span class="s1">{</span>
            <span class="s2">if </span><span class="s1">($$typeofNextType === REACT_MEMO_TYPE) {</span>
              <span class="s0">// TODO: if it was but can no longer be simple,</span>
              <span class="s0">// we shouldn't set this.</span>
              <span class="s1">needsCompareFamilies = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s2">else if </span><span class="s1">($$typeofNextType === REACT_LAZY_TYPE) {</span>
              <span class="s1">needsCompareFamilies = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s2">break</span><span class="s1">;</span>
          <span class="s1">}</span>

        <span class="s2">default</span><span class="s1">:</span>
          <span class="s2">return false</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// Check if both types have a family and it's the same one.</span>


      <span class="s2">if </span><span class="s1">(needsCompareFamilies) {</span>
        <span class="s0">// Note: memo() and forwardRef() we'll compare outer rather than inner type.</span>
        <span class="s0">// This means both of them need to be registered to preserve state.</span>
        <span class="s0">// If we unwrapped and compared the inner types for wrappers instead,</span>
        <span class="s0">// then we would risk falsely saying two separate memo(Foo)</span>
        <span class="s0">// calls are equivalent because they wrap the same Foo function.</span>
        <span class="s2">var </span><span class="s1">prevFamily = resolveFamily(prevType);</span>

        <span class="s2">if </span><span class="s1">(prevFamily !== undefined &amp;&amp; prevFamily === resolveFamily(nextType)) {</span>
          <span class="s2">return true</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">markFailedErrorBoundaryForHotReloading(fiber) {</span>
    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(resolveFamily === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s0">// Hot reloading is disabled.</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">WeakSet !== </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(failedBoundaries === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">failedBoundaries = </span><span class="s2">new </span><span class="s1">WeakSet();</span>
      <span class="s1">}</span>

      <span class="s1">failedBoundaries.add(fiber);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">var </span><span class="s1">scheduleRefresh = </span><span class="s2">function </span><span class="s1">(root, update) {</span>
    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(resolveFamily === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s0">// Hot reloading is disabled.</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">staleFamilies = update.staleFamilies,</span>
          <span class="s1">updatedFamilies = update.updatedFamilies;</span>
      <span class="s1">flushPassiveEffects();</span>
      <span class="s1">flushSync(</span><span class="s2">function </span><span class="s1">() {</span>
        <span class="s1">scheduleFibersWithFamiliesRecursively(root.current, updatedFamilies, staleFamilies);</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
  <span class="s1">};</span>
  <span class="s2">var </span><span class="s1">scheduleRoot = </span><span class="s2">function </span><span class="s1">(root, element) {</span>
    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(root.context !== emptyContextObject) {</span>
        <span class="s0">// Super edge case: root has a legacy _renderSubtree context</span>
        <span class="s0">// but we don't know the parentComponent so we can't pass it.</span>
        <span class="s0">// Just ignore. We'll delete this with _renderSubtree code path later.</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">flushPassiveEffects();</span>
      <span class="s1">flushSync(</span><span class="s2">function </span><span class="s1">() {</span>
        <span class="s1">updateContainer(element, root, </span><span class="s2">null</span><span class="s1">, </span><span class="s2">null</span><span class="s1">);</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s2">function </span><span class="s1">scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {</span>
    <span class="s1">{</span>
      <span class="s2">var </span><span class="s1">alternate = fiber.alternate,</span>
          <span class="s1">child = fiber.child,</span>
          <span class="s1">sibling = fiber.sibling,</span>
          <span class="s1">tag = fiber.tag,</span>
          <span class="s1">type = fiber.type;</span>
      <span class="s2">var </span><span class="s1">candidateType = </span><span class="s2">null</span><span class="s1">;</span>

      <span class="s2">switch </span><span class="s1">(tag) {</span>
        <span class="s2">case </span><span class="s1">FunctionComponent:</span>
        <span class="s2">case </span><span class="s1">SimpleMemoComponent:</span>
        <span class="s2">case </span><span class="s1">ClassComponent:</span>
          <span class="s1">candidateType = type;</span>
          <span class="s2">break</span><span class="s1">;</span>

        <span class="s2">case </span><span class="s1">ForwardRef:</span>
          <span class="s1">candidateType = type.render;</span>
          <span class="s2">break</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(resolveFamily === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Expected resolveFamily to be set during hot reload.'</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">needsRender = </span><span class="s2">false</span><span class="s1">;</span>
      <span class="s2">var </span><span class="s1">needsRemount = </span><span class="s2">false</span><span class="s1">;</span>

      <span class="s2">if </span><span class="s1">(candidateType !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">var </span><span class="s1">family = resolveFamily(candidateType);</span>

        <span class="s2">if </span><span class="s1">(family !== undefined) {</span>
          <span class="s2">if </span><span class="s1">(staleFamilies.has(family)) {</span>
            <span class="s1">needsRemount = </span><span class="s2">true</span><span class="s1">;</span>
          <span class="s1">} </span><span class="s2">else if </span><span class="s1">(updatedFamilies.has(family)) {</span>
            <span class="s2">if </span><span class="s1">(tag === ClassComponent) {</span>
              <span class="s1">needsRemount = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
              <span class="s1">needsRender = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(failedBoundaries !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(failedBoundaries.has(fiber) || alternate !== </span><span class="s2">null </span><span class="s1">&amp;&amp; failedBoundaries.has(alternate)) {</span>
          <span class="s1">needsRemount = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(needsRemount) {</span>
        <span class="s1">fiber._debugNeedsRemount = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(needsRemount || needsRender) {</span>
        <span class="s2">var </span><span class="s1">_root = enqueueConcurrentRenderForLane(fiber, SyncLane);</span>

        <span class="s2">if </span><span class="s1">(_root !== </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">scheduleUpdateOnFiber(_root, fiber, SyncLane, NoTimestamp);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(child !== </span><span class="s2">null </span><span class="s1">&amp;&amp; !needsRemount) {</span>
        <span class="s1">scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(sibling !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">findHostInstancesForRefresh = </span><span class="s2">function </span><span class="s1">(root, families) {</span>
    <span class="s1">{</span>
      <span class="s2">var </span><span class="s1">hostInstances = </span><span class="s2">new </span><span class="s1">Set();</span>
      <span class="s2">var </span><span class="s1">types = </span><span class="s2">new </span><span class="s1">Set(families.map(</span><span class="s2">function </span><span class="s1">(family) {</span>
        <span class="s2">return </span><span class="s1">family.current;</span>
      <span class="s1">}));</span>
      <span class="s1">findHostInstancesForMatchingFibersRecursively(root.current, types, hostInstances);</span>
      <span class="s2">return </span><span class="s1">hostInstances;</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s2">function </span><span class="s1">findHostInstancesForMatchingFibersRecursively(fiber, types, hostInstances) {</span>
    <span class="s1">{</span>
      <span class="s2">var </span><span class="s1">child = fiber.child,</span>
          <span class="s1">sibling = fiber.sibling,</span>
          <span class="s1">tag = fiber.tag,</span>
          <span class="s1">type = fiber.type;</span>
      <span class="s2">var </span><span class="s1">candidateType = </span><span class="s2">null</span><span class="s1">;</span>

      <span class="s2">switch </span><span class="s1">(tag) {</span>
        <span class="s2">case </span><span class="s1">FunctionComponent:</span>
        <span class="s2">case </span><span class="s1">SimpleMemoComponent:</span>
        <span class="s2">case </span><span class="s1">ClassComponent:</span>
          <span class="s1">candidateType = type;</span>
          <span class="s2">break</span><span class="s1">;</span>

        <span class="s2">case </span><span class="s1">ForwardRef:</span>
          <span class="s1">candidateType = type.render;</span>
          <span class="s2">break</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">didMatch = </span><span class="s2">false</span><span class="s1">;</span>

      <span class="s2">if </span><span class="s1">(candidateType !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(types.has(candidateType)) {</span>
          <span class="s1">didMatch = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(didMatch) {</span>
        <span class="s0">// We have a match. This only drills down to the closest host components.</span>
        <span class="s0">// There's no need to search deeper because for the purpose of giving</span>
        <span class="s0">// visual feedback, &quot;flashing&quot; outermost parent rectangles is sufficient.</span>
        <span class="s1">findHostInstancesForFiberShallowly(fiber, hostInstances);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s0">// If there's no match, maybe there will be one further down in the child tree.</span>
        <span class="s2">if </span><span class="s1">(child !== </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">findHostInstancesForMatchingFibersRecursively(child, types, hostInstances);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(sibling !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">findHostInstancesForMatchingFibersRecursively(sibling, types, hostInstances);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">findHostInstancesForFiberShallowly(fiber, hostInstances) {</span>
    <span class="s1">{</span>
      <span class="s2">var </span><span class="s1">foundHostInstances = findChildHostInstancesForFiberShallowly(fiber, hostInstances);</span>

      <span class="s2">if </span><span class="s1">(foundHostInstances) {</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// If we didn't find any host children, fallback to closest host parent.</span>


      <span class="s2">var </span><span class="s1">node = fiber;</span>

      <span class="s2">while </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s2">switch </span><span class="s1">(node.tag) {</span>
          <span class="s2">case </span><span class="s1">HostComponent:</span>
            <span class="s1">hostInstances.add(node.stateNode);</span>
            <span class="s2">return</span><span class="s1">;</span>

          <span class="s2">case </span><span class="s1">HostPortal:</span>
            <span class="s1">hostInstances.add(node.stateNode.containerInfo);</span>
            <span class="s2">return</span><span class="s1">;</span>

          <span class="s2">case </span><span class="s1">HostRoot:</span>
            <span class="s1">hostInstances.add(node.stateNode.containerInfo);</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(node.</span><span class="s2">return </span><span class="s1">=== </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Expected to reach root first.'</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s1">node = node.</span><span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">findChildHostInstancesForFiberShallowly(fiber, hostInstances) {</span>
    <span class="s1">{</span>
      <span class="s2">var </span><span class="s1">node = fiber;</span>
      <span class="s2">var </span><span class="s1">foundHostInstances = </span><span class="s2">false</span><span class="s1">;</span>

      <span class="s2">while </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(node.tag === HostComponent) {</span>
          <span class="s0">// We got a match.</span>
          <span class="s1">foundHostInstances = </span><span class="s2">true</span><span class="s1">;</span>
          <span class="s1">hostInstances.add(node.stateNode); </span><span class="s0">// There may still be more, so keep searching.</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(node.child !== </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">node.child.</span><span class="s2">return </span><span class="s1">= node;</span>
          <span class="s1">node = node.child;</span>
          <span class="s2">continue</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(node === fiber) {</span>
          <span class="s2">return </span><span class="s1">foundHostInstances;</span>
        <span class="s1">}</span>

        <span class="s2">while </span><span class="s1">(node.sibling === </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s2">if </span><span class="s1">(node.</span><span class="s2">return </span><span class="s1">=== </span><span class="s2">null </span><span class="s1">|| node.</span><span class="s2">return </span><span class="s1">=== fiber) {</span>
            <span class="s2">return </span><span class="s1">foundHostInstances;</span>
          <span class="s1">}</span>

          <span class="s1">node = node.</span><span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">node.sibling.</span><span class="s2">return </span><span class="s1">= node.</span><span class="s2">return</span><span class="s1">;</span>
        <span class="s1">node = node.sibling;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return false</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">hasBadMapPolyfill;</span>

  <span class="s1">{</span>
    <span class="s1">hasBadMapPolyfill = </span><span class="s2">false</span><span class="s1">;</span>

    <span class="s2">try </span><span class="s1">{</span>
      <span class="s2">var </span><span class="s1">nonExtensibleObject = Object.preventExtensions({});</span>
      <span class="s0">/* eslint-disable no-new */</span>

      <span class="s2">new </span><span class="s1">Map([[nonExtensibleObject, </span><span class="s2">null</span><span class="s1">]]);</span>
      <span class="s2">new </span><span class="s1">Set([nonExtensibleObject]);</span>
      <span class="s0">/* eslint-enable no-new */</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(e) {</span>
      <span class="s0">// TODO: Consider warning about bad polyfills</span>
      <span class="s1">hasBadMapPolyfill = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">FiberNode(tag, pendingProps, key, mode) {</span>
    <span class="s0">// Instance</span>
    <span class="s2">this</span><span class="s1">.tag = tag;</span>
    <span class="s2">this</span><span class="s1">.key = key;</span>
    <span class="s2">this</span><span class="s1">.elementType = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">this</span><span class="s1">.type = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">this</span><span class="s1">.stateNode = </span><span class="s2">null</span><span class="s1">; </span><span class="s0">// Fiber</span>

    <span class="s2">this</span><span class="s1">.</span><span class="s2">return </span><span class="s1">= </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">this</span><span class="s1">.child = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">this</span><span class="s1">.sibling = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">this</span><span class="s1">.index = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s2">this</span><span class="s1">.ref = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">this</span><span class="s1">.pendingProps = pendingProps;</span>
    <span class="s2">this</span><span class="s1">.memoizedProps = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">this</span><span class="s1">.updateQueue = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">this</span><span class="s1">.memoizedState = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">this</span><span class="s1">.dependencies = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">this</span><span class="s1">.mode = mode; </span><span class="s0">// Effects</span>

    <span class="s2">this</span><span class="s1">.flags = NoFlags;</span>
    <span class="s2">this</span><span class="s1">.subtreeFlags = NoFlags;</span>
    <span class="s2">this</span><span class="s1">.deletions = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">this</span><span class="s1">.lanes = NoLanes;</span>
    <span class="s2">this</span><span class="s1">.childLanes = NoLanes;</span>
    <span class="s2">this</span><span class="s1">.alternate = </span><span class="s2">null</span><span class="s1">;</span>

    <span class="s1">{</span>
      <span class="s0">// Note: The following is done to avoid a v8 performance cliff.</span>
      <span class="s0">//</span>
      <span class="s0">// Initializing the fields below to smis and later updating them with</span>
      <span class="s0">// double values will cause Fibers to end up having separate shapes.</span>
      <span class="s0">// This behavior/bug has something to do with Object.preventExtension().</span>
      <span class="s0">// Fortunately this only impacts DEV builds.</span>
      <span class="s0">// Unfortunately it makes React unusably slow for some applications.</span>
      <span class="s0">// To work around this, initialize the fields below with doubles.</span>
      <span class="s0">//</span>
      <span class="s0">// Learn more about this here:</span>
      <span class="s0">// https://github.com/facebook/react/issues/14365</span>
      <span class="s0">// https://bugs.chromium.org/p/v8/issues/detail?id=8538</span>
      <span class="s2">this</span><span class="s1">.actualDuration = Number.NaN;</span>
      <span class="s2">this</span><span class="s1">.actualStartTime = Number.NaN;</span>
      <span class="s2">this</span><span class="s1">.selfBaseDuration = Number.NaN;</span>
      <span class="s2">this</span><span class="s1">.treeBaseDuration = Number.NaN; </span><span class="s0">// It's okay to replace the initial doubles with smis after initialization.</span>
      <span class="s0">// This won't trigger the performance cliff mentioned above,</span>
      <span class="s0">// and it simplifies other profiler code (including DevTools).</span>

      <span class="s2">this</span><span class="s1">.actualDuration = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s2">this</span><span class="s1">.actualStartTime = -</span><span class="s4">1</span><span class="s1">;</span>
      <span class="s2">this</span><span class="s1">.selfBaseDuration = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s2">this</span><span class="s1">.treeBaseDuration = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s0">// This isn't directly used but is handy for debugging internals:</span>
      <span class="s2">this</span><span class="s1">._debugSource = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s2">this</span><span class="s1">._debugOwner = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s2">this</span><span class="s1">._debugNeedsRemount = </span><span class="s2">false</span><span class="s1">;</span>
      <span class="s2">this</span><span class="s1">._debugHookTypes = </span><span class="s2">null</span><span class="s1">;</span>

      <span class="s2">if </span><span class="s1">(!hasBadMapPolyfill &amp;&amp; </span><span class="s2">typeof </span><span class="s1">Object.preventExtensions === </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s1">Object.preventExtensions(</span><span class="s2">this</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s0">// This is a constructor function, rather than a POJO constructor, still</span>
  <span class="s0">// please ensure we do the following:</span>
  <span class="s0">// 1) Nobody should add any instance methods on this. Instance methods can be</span>
  <span class="s0">//    more difficult to predict when they get optimized and they are almost</span>
  <span class="s0">//    never inlined properly in static compilers.</span>
  <span class="s0">// 2) Nobody should rely on `instanceof Fiber` for type testing. We should</span>
  <span class="s0">//    always know when it is a fiber.</span>
  <span class="s0">// 3) We might want to experiment with using numeric keys since they are easier</span>
  <span class="s0">//    to optimize in a non-JIT environment.</span>
  <span class="s0">// 4) We can easily go from a constructor to a createFiber object literal if that</span>
  <span class="s0">//    is faster.</span>
  <span class="s0">// 5) It should be easy to port this to a C struct and keep a C implementation</span>
  <span class="s0">//    compatible.</span>


  <span class="s2">var </span><span class="s1">createFiber = </span><span class="s2">function </span><span class="s1">(tag, pendingProps, key, mode) {</span>
    <span class="s0">// $FlowFixMe: the shapes are exact here but Flow doesn't like constructors</span>
    <span class="s2">return new </span><span class="s1">FiberNode(tag, pendingProps, key, mode);</span>
  <span class="s1">};</span>

  <span class="s2">function </span><span class="s1">shouldConstruct$1(Component) {</span>
    <span class="s2">var </span><span class="s1">prototype = Component.prototype;</span>
    <span class="s2">return </span><span class="s1">!!(prototype &amp;&amp; prototype.isReactComponent);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">isSimpleFunctionComponent(type) {</span>
    <span class="s2">return typeof </span><span class="s1">type === </span><span class="s3">'function' </span><span class="s1">&amp;&amp; !shouldConstruct$1(type) &amp;&amp; type.defaultProps === undefined;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">resolveLazyComponentTag(Component) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">Component === </span><span class="s3">'function'</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">shouldConstruct$1(Component) ? ClassComponent : FunctionComponent;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(Component !== undefined &amp;&amp; Component !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">$$typeof = Component.$$typeof;</span>

      <span class="s2">if </span><span class="s1">($$typeof === REACT_FORWARD_REF_TYPE) {</span>
        <span class="s2">return </span><span class="s1">ForwardRef;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">($$typeof === REACT_MEMO_TYPE) {</span>
        <span class="s2">return </span><span class="s1">MemoComponent;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">IndeterminateComponent;</span>
  <span class="s1">} </span><span class="s0">// This is used to create an alternate fiber to do work on.</span>

  <span class="s2">function </span><span class="s1">createWorkInProgress(current, pendingProps) {</span>
    <span class="s2">var </span><span class="s1">workInProgress = current.alternate;</span>

    <span class="s2">if </span><span class="s1">(workInProgress === </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s0">// We use a double buffering pooling technique because we know that we'll</span>
      <span class="s0">// only ever need at most two versions of a tree. We pool the &quot;other&quot; unused</span>
      <span class="s0">// node that we're free to reuse. This is lazily created to avoid allocating</span>
      <span class="s0">// extra objects for things that are never updated. It also allow us to</span>
      <span class="s0">// reclaim the extra memory if needed.</span>
      <span class="s1">workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode);</span>
      <span class="s1">workInProgress.elementType = current.elementType;</span>
      <span class="s1">workInProgress.type = current.type;</span>
      <span class="s1">workInProgress.stateNode = current.stateNode;</span>

      <span class="s1">{</span>
        <span class="s0">// DEV-only fields</span>
        <span class="s1">workInProgress._debugSource = current._debugSource;</span>
        <span class="s1">workInProgress._debugOwner = current._debugOwner;</span>
        <span class="s1">workInProgress._debugHookTypes = current._debugHookTypes;</span>
      <span class="s1">}</span>

      <span class="s1">workInProgress.alternate = current;</span>
      <span class="s1">current.alternate = workInProgress;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">workInProgress.pendingProps = pendingProps; </span><span class="s0">// Needed because Blocks store data on type.</span>

      <span class="s1">workInProgress.type = current.type; </span><span class="s0">// We already have an alternate.</span>
      <span class="s0">// Reset the effect tag.</span>

      <span class="s1">workInProgress.flags = NoFlags; </span><span class="s0">// The effects are no longer valid.</span>

      <span class="s1">workInProgress.subtreeFlags = NoFlags;</span>
      <span class="s1">workInProgress.deletions = </span><span class="s2">null</span><span class="s1">;</span>

      <span class="s1">{</span>
        <span class="s0">// We intentionally reset, rather than copy, actualDuration &amp; actualStartTime.</span>
        <span class="s0">// This prevents time from endlessly accumulating in new commits.</span>
        <span class="s0">// This has the downside of resetting values for different priority renders,</span>
        <span class="s0">// But works for yielding (the common case) and should support resuming.</span>
        <span class="s1">workInProgress.actualDuration = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">workInProgress.actualStartTime = -</span><span class="s4">1</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// Reset all effects except static ones.</span>
    <span class="s0">// Static effects are not specific to a render.</span>


    <span class="s1">workInProgress.flags = current.flags &amp; StaticMask;</span>
    <span class="s1">workInProgress.childLanes = current.childLanes;</span>
    <span class="s1">workInProgress.lanes = current.lanes;</span>
    <span class="s1">workInProgress.child = current.child;</span>
    <span class="s1">workInProgress.memoizedProps = current.memoizedProps;</span>
    <span class="s1">workInProgress.memoizedState = current.memoizedState;</span>
    <span class="s1">workInProgress.updateQueue = current.updateQueue; </span><span class="s0">// Clone the dependencies object. This is mutated during the render phase, so</span>
    <span class="s0">// it cannot be shared with the current fiber.</span>

    <span class="s2">var </span><span class="s1">currentDependencies = current.dependencies;</span>
    <span class="s1">workInProgress.dependencies = currentDependencies === </span><span class="s2">null </span><span class="s1">? </span><span class="s2">null </span><span class="s1">: {</span>
      <span class="s1">lanes: currentDependencies.lanes,</span>
      <span class="s1">firstContext: currentDependencies.firstContext</span>
    <span class="s1">}; </span><span class="s0">// These will be overridden during the parent's reconciliation</span>

    <span class="s1">workInProgress.sibling = current.sibling;</span>
    <span class="s1">workInProgress.index = current.index;</span>
    <span class="s1">workInProgress.ref = current.ref;</span>

    <span class="s1">{</span>
      <span class="s1">workInProgress.selfBaseDuration = current.selfBaseDuration;</span>
      <span class="s1">workInProgress.treeBaseDuration = current.treeBaseDuration;</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s1">workInProgress._debugNeedsRemount = current._debugNeedsRemount;</span>

      <span class="s2">switch </span><span class="s1">(workInProgress.tag) {</span>
        <span class="s2">case </span><span class="s1">IndeterminateComponent:</span>
        <span class="s2">case </span><span class="s1">FunctionComponent:</span>
        <span class="s2">case </span><span class="s1">SimpleMemoComponent:</span>
          <span class="s1">workInProgress.type = resolveFunctionForHotReloading(current.type);</span>
          <span class="s2">break</span><span class="s1">;</span>

        <span class="s2">case </span><span class="s1">ClassComponent:</span>
          <span class="s1">workInProgress.type = resolveClassForHotReloading(current.type);</span>
          <span class="s2">break</span><span class="s1">;</span>

        <span class="s2">case </span><span class="s1">ForwardRef:</span>
          <span class="s1">workInProgress.type = resolveForwardRefForHotReloading(current.type);</span>
          <span class="s2">break</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">workInProgress;</span>
  <span class="s1">} </span><span class="s0">// Used to reuse a Fiber for a second pass.</span>

  <span class="s2">function </span><span class="s1">resetWorkInProgress(workInProgress, renderLanes) {</span>
    <span class="s0">// This resets the Fiber to what createFiber or createWorkInProgress would</span>
    <span class="s0">// have set the values to before during the first pass. Ideally this wouldn't</span>
    <span class="s0">// be necessary but unfortunately many code paths reads from the workInProgress</span>
    <span class="s0">// when they should be reading from current and writing to workInProgress.</span>
    <span class="s0">// We assume pendingProps, index, key, ref, return are still untouched to</span>
    <span class="s0">// avoid doing another reconciliation.</span>
    <span class="s0">// Reset the effect flags but keep any Placement tags, since that's something</span>
    <span class="s0">// that child fiber is setting, not the reconciliation.</span>
    <span class="s1">workInProgress.flags &amp;= StaticMask | Placement; </span><span class="s0">// The effects are no longer valid.</span>

    <span class="s2">var </span><span class="s1">current = workInProgress.alternate;</span>

    <span class="s2">if </span><span class="s1">(current === </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s0">// Reset to createFiber's initial values.</span>
      <span class="s1">workInProgress.childLanes = NoLanes;</span>
      <span class="s1">workInProgress.lanes = renderLanes;</span>
      <span class="s1">workInProgress.child = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">workInProgress.subtreeFlags = NoFlags;</span>
      <span class="s1">workInProgress.memoizedProps = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">workInProgress.memoizedState = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">workInProgress.updateQueue = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">workInProgress.dependencies = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">workInProgress.stateNode = </span><span class="s2">null</span><span class="s1">;</span>

      <span class="s1">{</span>
        <span class="s0">// Note: We don't reset the actualTime counts. It's useful to accumulate</span>
        <span class="s0">// actual time across multiple render passes.</span>
        <span class="s1">workInProgress.selfBaseDuration = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">workInProgress.treeBaseDuration = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s0">// Reset to the cloned values that createWorkInProgress would've.</span>
      <span class="s1">workInProgress.childLanes = current.childLanes;</span>
      <span class="s1">workInProgress.lanes = current.lanes;</span>
      <span class="s1">workInProgress.child = current.child;</span>
      <span class="s1">workInProgress.subtreeFlags = NoFlags;</span>
      <span class="s1">workInProgress.deletions = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">workInProgress.memoizedProps = current.memoizedProps;</span>
      <span class="s1">workInProgress.memoizedState = current.memoizedState;</span>
      <span class="s1">workInProgress.updateQueue = current.updateQueue; </span><span class="s0">// Needed because Blocks store data on type.</span>

      <span class="s1">workInProgress.type = current.type; </span><span class="s0">// Clone the dependencies object. This is mutated during the render phase, so</span>
      <span class="s0">// it cannot be shared with the current fiber.</span>

      <span class="s2">var </span><span class="s1">currentDependencies = current.dependencies;</span>
      <span class="s1">workInProgress.dependencies = currentDependencies === </span><span class="s2">null </span><span class="s1">? </span><span class="s2">null </span><span class="s1">: {</span>
        <span class="s1">lanes: currentDependencies.lanes,</span>
        <span class="s1">firstContext: currentDependencies.firstContext</span>
      <span class="s1">};</span>

      <span class="s1">{</span>
        <span class="s0">// Note: We don't reset the actualTime counts. It's useful to accumulate</span>
        <span class="s0">// actual time across multiple render passes.</span>
        <span class="s1">workInProgress.selfBaseDuration = current.selfBaseDuration;</span>
        <span class="s1">workInProgress.treeBaseDuration = current.treeBaseDuration;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">workInProgress;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">createHostRootFiber(tag, isStrictMode, concurrentUpdatesByDefaultOverride) {</span>
    <span class="s2">var </span><span class="s1">mode;</span>

    <span class="s2">if </span><span class="s1">(tag === ConcurrentRoot) {</span>
      <span class="s1">mode = ConcurrentMode;</span>

      <span class="s2">if </span><span class="s1">(isStrictMode === </span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s1">mode |= StrictLegacyMode;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">mode = NoMode;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">( isDevToolsPresent) {</span>
      <span class="s0">// Always collect profile timings when DevTools are present.</span>
      <span class="s0">// This enables DevTools to start capturing timing at any point</span>
      <span class="s0">// Without some nodes in the tree having empty base times.</span>
      <span class="s1">mode |= ProfileMode;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">createFiber(HostRoot, </span><span class="s2">null</span><span class="s1">, </span><span class="s2">null</span><span class="s1">, mode);</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">createFiberFromTypeAndProps(type, </span><span class="s0">// React$ElementType</span>
  <span class="s1">key, pendingProps, owner, mode, lanes) {</span>
    <span class="s2">var </span><span class="s1">fiberTag = IndeterminateComponent; </span><span class="s0">// The resolved type is set if we know what the final type will be. I.e. it's not lazy.</span>

    <span class="s2">var </span><span class="s1">resolvedType = type;</span>

    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">type === </span><span class="s3">'function'</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(shouldConstruct$1(type)) {</span>
        <span class="s1">fiberTag = ClassComponent;</span>

        <span class="s1">{</span>
          <span class="s1">resolvedType = resolveClassForHotReloading(resolvedType);</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">{</span>
          <span class="s1">resolvedType = resolveFunctionForHotReloading(resolvedType);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">type === </span><span class="s3">'string'</span><span class="s1">) {</span>
      <span class="s1">fiberTag = HostComponent;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">getTag: </span><span class="s2">switch </span><span class="s1">(type) {</span>
        <span class="s2">case </span><span class="s1">REACT_FRAGMENT_TYPE:</span>
          <span class="s2">return </span><span class="s1">createFiberFromFragment(pendingProps.children, mode, lanes, key);</span>

        <span class="s2">case </span><span class="s1">REACT_STRICT_MODE_TYPE:</span>
          <span class="s1">fiberTag = Mode;</span>
          <span class="s1">mode |= StrictLegacyMode;</span>

          <span class="s2">break</span><span class="s1">;</span>

        <span class="s2">case </span><span class="s1">REACT_PROFILER_TYPE:</span>
          <span class="s2">return </span><span class="s1">createFiberFromProfiler(pendingProps, mode, lanes, key);</span>

        <span class="s2">case </span><span class="s1">REACT_SUSPENSE_TYPE:</span>
          <span class="s2">return </span><span class="s1">createFiberFromSuspense(pendingProps, mode, lanes, key);</span>

        <span class="s2">case </span><span class="s1">REACT_SUSPENSE_LIST_TYPE:</span>
          <span class="s2">return </span><span class="s1">createFiberFromSuspenseList(pendingProps, mode, lanes, key);</span>

        <span class="s2">case </span><span class="s1">REACT_OFFSCREEN_TYPE:</span>
          <span class="s2">return </span><span class="s1">createFiberFromOffscreen(pendingProps, mode, lanes, key);</span>

        <span class="s2">case </span><span class="s1">REACT_LEGACY_HIDDEN_TYPE:</span>

        <span class="s0">// eslint-disable-next-line no-fallthrough</span>

        <span class="s2">case </span><span class="s1">REACT_SCOPE_TYPE:</span>

        <span class="s0">// eslint-disable-next-line no-fallthrough</span>

        <span class="s2">case </span><span class="s1">REACT_CACHE_TYPE:</span>

        <span class="s0">// eslint-disable-next-line no-fallthrough</span>

        <span class="s2">case </span><span class="s1">REACT_TRACING_MARKER_TYPE:</span>

        <span class="s0">// eslint-disable-next-line no-fallthrough</span>

        <span class="s2">case </span><span class="s1">REACT_DEBUG_TRACING_MODE_TYPE:</span>

        <span class="s0">// eslint-disable-next-line no-fallthrough</span>

        <span class="s2">default</span><span class="s1">:</span>
          <span class="s1">{</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">type === </span><span class="s3">'object' </span><span class="s1">&amp;&amp; type !== </span><span class="s2">null</span><span class="s1">) {</span>
              <span class="s2">switch </span><span class="s1">(type.$$typeof) {</span>
                <span class="s2">case </span><span class="s1">REACT_PROVIDER_TYPE:</span>
                  <span class="s1">fiberTag = ContextProvider;</span>
                  <span class="s2">break </span><span class="s1">getTag;</span>

                <span class="s2">case </span><span class="s1">REACT_CONTEXT_TYPE:</span>
                  <span class="s0">// This is a consumer</span>
                  <span class="s1">fiberTag = ContextConsumer;</span>
                  <span class="s2">break </span><span class="s1">getTag;</span>

                <span class="s2">case </span><span class="s1">REACT_FORWARD_REF_TYPE:</span>
                  <span class="s1">fiberTag = ForwardRef;</span>

                  <span class="s1">{</span>
                    <span class="s1">resolvedType = resolveForwardRefForHotReloading(resolvedType);</span>
                  <span class="s1">}</span>

                  <span class="s2">break </span><span class="s1">getTag;</span>

                <span class="s2">case </span><span class="s1">REACT_MEMO_TYPE:</span>
                  <span class="s1">fiberTag = MemoComponent;</span>
                  <span class="s2">break </span><span class="s1">getTag;</span>

                <span class="s2">case </span><span class="s1">REACT_LAZY_TYPE:</span>
                  <span class="s1">fiberTag = LazyComponent;</span>
                  <span class="s1">resolvedType = </span><span class="s2">null</span><span class="s1">;</span>
                  <span class="s2">break </span><span class="s1">getTag;</span>
              <span class="s1">}</span>
            <span class="s1">}</span>

            <span class="s2">var </span><span class="s1">info = </span><span class="s3">''</span><span class="s1">;</span>

            <span class="s1">{</span>
              <span class="s2">if </span><span class="s1">(type === undefined || </span><span class="s2">typeof </span><span class="s1">type === </span><span class="s3">'object' </span><span class="s1">&amp;&amp; type !== </span><span class="s2">null </span><span class="s1">&amp;&amp; Object.keys(type).length === </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s1">info += </span><span class="s3">' You likely forgot to export your component from the file ' </span><span class="s1">+ </span><span class="s3">&quot;it's defined in, or you might have mixed up default and &quot; </span><span class="s1">+ </span><span class="s3">'named imports.'</span><span class="s1">;</span>
              <span class="s1">}</span>

              <span class="s2">var </span><span class="s1">ownerName = owner ? getComponentNameFromFiber(owner) : </span><span class="s2">null</span><span class="s1">;</span>

              <span class="s2">if </span><span class="s1">(ownerName) {</span>
                <span class="s1">info += </span><span class="s3">'</span><span class="s5">\n\n</span><span class="s3">Check the render method of `' </span><span class="s1">+ ownerName + </span><span class="s3">'`.'</span><span class="s1">;</span>
              <span class="s1">}</span>
            <span class="s1">}</span>

            <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Element type is invalid: expected a string (for built-in ' </span><span class="s1">+ </span><span class="s3">'components) or a class/function (for composite components) ' </span><span class="s1">+ (</span><span class="s3">&quot;but got: &quot; </span><span class="s1">+ (type == </span><span class="s2">null </span><span class="s1">? type : </span><span class="s2">typeof </span><span class="s1">type) + </span><span class="s3">&quot;.&quot; </span><span class="s1">+ info));</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">fiber = createFiber(fiberTag, pendingProps, key, mode);</span>
    <span class="s1">fiber.elementType = type;</span>
    <span class="s1">fiber.type = resolvedType;</span>
    <span class="s1">fiber.lanes = lanes;</span>

    <span class="s1">{</span>
      <span class="s1">fiber._debugOwner = owner;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">fiber;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">createFiberFromElement(element, mode, lanes) {</span>
    <span class="s2">var </span><span class="s1">owner = </span><span class="s2">null</span><span class="s1">;</span>

    <span class="s1">{</span>
      <span class="s1">owner = element._owner;</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">type = element.type;</span>
    <span class="s2">var </span><span class="s1">key = element.key;</span>
    <span class="s2">var </span><span class="s1">pendingProps = element.props;</span>
    <span class="s2">var </span><span class="s1">fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes);</span>

    <span class="s1">{</span>
      <span class="s1">fiber._debugSource = element._source;</span>
      <span class="s1">fiber._debugOwner = element._owner;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">fiber;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">createFiberFromFragment(elements, mode, lanes, key) {</span>
    <span class="s2">var </span><span class="s1">fiber = createFiber(Fragment, elements, key, mode);</span>
    <span class="s1">fiber.lanes = lanes;</span>
    <span class="s2">return </span><span class="s1">fiber;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">createFiberFromProfiler(pendingProps, mode, lanes, key) {</span>
    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">pendingProps.id !== </span><span class="s3">'string'</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s3">'Profiler must specify an &quot;id&quot; of type `string` as a prop. Received the type `%s` instead.'</span><span class="s1">, </span><span class="s2">typeof </span><span class="s1">pendingProps.id);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode);</span>
    <span class="s1">fiber.elementType = REACT_PROFILER_TYPE;</span>
    <span class="s1">fiber.lanes = lanes;</span>

    <span class="s1">{</span>
      <span class="s1">fiber.stateNode = {</span>
        <span class="s1">effectDuration: </span><span class="s4">0</span><span class="s1">,</span>
        <span class="s1">passiveEffectDuration: </span><span class="s4">0</span>
      <span class="s1">};</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">fiber;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">createFiberFromSuspense(pendingProps, mode, lanes, key) {</span>
    <span class="s2">var </span><span class="s1">fiber = createFiber(SuspenseComponent, pendingProps, key, mode);</span>
    <span class="s1">fiber.elementType = REACT_SUSPENSE_TYPE;</span>
    <span class="s1">fiber.lanes = lanes;</span>
    <span class="s2">return </span><span class="s1">fiber;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">createFiberFromSuspenseList(pendingProps, mode, lanes, key) {</span>
    <span class="s2">var </span><span class="s1">fiber = createFiber(SuspenseListComponent, pendingProps, key, mode);</span>
    <span class="s1">fiber.elementType = REACT_SUSPENSE_LIST_TYPE;</span>
    <span class="s1">fiber.lanes = lanes;</span>
    <span class="s2">return </span><span class="s1">fiber;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">createFiberFromOffscreen(pendingProps, mode, lanes, key) {</span>
    <span class="s2">var </span><span class="s1">fiber = createFiber(OffscreenComponent, pendingProps, key, mode);</span>
    <span class="s1">fiber.elementType = REACT_OFFSCREEN_TYPE;</span>
    <span class="s1">fiber.lanes = lanes;</span>
    <span class="s2">var </span><span class="s1">primaryChildInstance = {</span>
      <span class="s1">isHidden: </span><span class="s2">false</span>
    <span class="s1">};</span>
    <span class="s1">fiber.stateNode = primaryChildInstance;</span>
    <span class="s2">return </span><span class="s1">fiber;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">createFiberFromText(content, mode, lanes) {</span>
    <span class="s2">var </span><span class="s1">fiber = createFiber(HostText, content, </span><span class="s2">null</span><span class="s1">, mode);</span>
    <span class="s1">fiber.lanes = lanes;</span>
    <span class="s2">return </span><span class="s1">fiber;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">createFiberFromPortal(portal, mode, lanes) {</span>
    <span class="s2">var </span><span class="s1">pendingProps = portal.children !== </span><span class="s2">null </span><span class="s1">? portal.children : [];</span>
    <span class="s2">var </span><span class="s1">fiber = createFiber(HostPortal, pendingProps, portal.key, mode);</span>
    <span class="s1">fiber.lanes = lanes;</span>
    <span class="s1">fiber.stateNode = {</span>
      <span class="s1">containerInfo: portal.containerInfo,</span>
      <span class="s1">pendingChildren: </span><span class="s2">null</span><span class="s1">,</span>
      <span class="s0">// Used by persistent updates</span>
      <span class="s1">implementation: portal.implementation</span>
    <span class="s1">};</span>
    <span class="s2">return </span><span class="s1">fiber;</span>
  <span class="s1">} </span><span class="s0">// Used for stashing WIP properties to replay failed work in DEV.</span>

  <span class="s2">function </span><span class="s1">FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onRecoverableError) {</span>
    <span class="s2">this</span><span class="s1">.tag = tag;</span>
    <span class="s2">this</span><span class="s1">.containerInfo = containerInfo;</span>
    <span class="s2">this</span><span class="s1">.pendingChildren = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">this</span><span class="s1">.current = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">this</span><span class="s1">.pingCache = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">this</span><span class="s1">.finishedWork = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">this</span><span class="s1">.timeoutHandle = noTimeout;</span>
    <span class="s2">this</span><span class="s1">.context = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">this</span><span class="s1">.pendingContext = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">this</span><span class="s1">.callbackNode = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">this</span><span class="s1">.callbackPriority = NoLane;</span>
    <span class="s2">this</span><span class="s1">.eventTimes = createLaneMap(NoLanes);</span>
    <span class="s2">this</span><span class="s1">.expirationTimes = createLaneMap(NoTimestamp);</span>
    <span class="s2">this</span><span class="s1">.pendingLanes = NoLanes;</span>
    <span class="s2">this</span><span class="s1">.suspendedLanes = NoLanes;</span>
    <span class="s2">this</span><span class="s1">.pingedLanes = NoLanes;</span>
    <span class="s2">this</span><span class="s1">.expiredLanes = NoLanes;</span>
    <span class="s2">this</span><span class="s1">.mutableReadLanes = NoLanes;</span>
    <span class="s2">this</span><span class="s1">.finishedLanes = NoLanes;</span>
    <span class="s2">this</span><span class="s1">.entangledLanes = NoLanes;</span>
    <span class="s2">this</span><span class="s1">.entanglements = createLaneMap(NoLanes);</span>
    <span class="s2">this</span><span class="s1">.identifierPrefix = identifierPrefix;</span>
    <span class="s2">this</span><span class="s1">.onRecoverableError = onRecoverableError;</span>

    <span class="s1">{</span>
      <span class="s2">this</span><span class="s1">.effectDuration = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s2">this</span><span class="s1">.passiveEffectDuration = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s2">switch </span><span class="s1">(tag) {</span>
        <span class="s2">case </span><span class="s1">ConcurrentRoot:</span>
          <span class="s2">this</span><span class="s1">._debugRootType = hydrate ? </span><span class="s3">'hydrateRoot()' </span><span class="s1">: </span><span class="s3">'createRoot()'</span><span class="s1">;</span>
          <span class="s2">break</span><span class="s1">;</span>

        <span class="s2">case </span><span class="s1">LegacyRoot:</span>
          <span class="s2">this</span><span class="s1">._debugRootType = hydrate ? </span><span class="s3">'hydrate()' </span><span class="s1">: </span><span class="s3">'render()'</span><span class="s1">;</span>
          <span class="s2">break</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, </span><span class="s0">// TODO: We have several of these arguments that are conceptually part of the</span>
  <span class="s0">// host config, but because they are passed in at runtime, we have to thread</span>
  <span class="s0">// them through the root constructor. Perhaps we should put them all into a</span>
  <span class="s0">// single type, like a DynamicHostConfig that is defined by the renderer.</span>
  <span class="s1">identifierPrefix, onRecoverableError, transitionCallbacks) {</span>
    <span class="s2">var </span><span class="s1">root = </span><span class="s2">new </span><span class="s1">FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onRecoverableError);</span>
    <span class="s0">// stateNode is any.</span>


    <span class="s2">var </span><span class="s1">uninitializedFiber = createHostRootFiber(tag, isStrictMode);</span>
    <span class="s1">root.current = uninitializedFiber;</span>
    <span class="s1">uninitializedFiber.stateNode = root;</span>

    <span class="s1">{</span>
      <span class="s2">var </span><span class="s1">_initialState = {</span>
        <span class="s1">element: initialChildren,</span>
        <span class="s1">isDehydrated: hydrate,</span>
        <span class="s1">cache: </span><span class="s2">null</span><span class="s1">,</span>
        <span class="s0">// not enabled yet</span>
        <span class="s1">transitions: </span><span class="s2">null</span><span class="s1">,</span>
        <span class="s1">pendingSuspenseBoundaries: </span><span class="s2">null</span>
      <span class="s1">};</span>
      <span class="s1">uninitializedFiber.memoizedState = _initialState;</span>
    <span class="s1">}</span>

    <span class="s1">initializeUpdateQueue(uninitializedFiber);</span>
    <span class="s2">return </span><span class="s1">root;</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">ReactVersion = </span><span class="s3">'18.2.0'</span><span class="s1">;</span>

  <span class="s2">var </span><span class="s1">didWarnAboutNestedUpdates;</span>

  <span class="s1">{</span>
    <span class="s1">didWarnAboutNestedUpdates = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">getContextForSubtree(parentComponent) {</span>
    <span class="s2">if </span><span class="s1">(!parentComponent) {</span>
      <span class="s2">return </span><span class="s1">emptyContextObject;</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">fiber = get(parentComponent);</span>
    <span class="s2">var </span><span class="s1">parentContext = findCurrentUnmaskedContext(fiber);</span>

    <span class="s2">if </span><span class="s1">(fiber.tag === ClassComponent) {</span>
      <span class="s2">var </span><span class="s1">Component = fiber.type;</span>

      <span class="s2">if </span><span class="s1">(isContextProvider(Component)) {</span>
        <span class="s2">return </span><span class="s1">processChildContext(fiber, Component, parentContext);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">parentContext;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">createContainer(containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {</span>
    <span class="s2">var </span><span class="s1">hydrate = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s2">var </span><span class="s1">initialChildren = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">return </span><span class="s1">createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">updateContainer(element, container, parentComponent, callback) {</span>
    <span class="s1">{</span>
      <span class="s1">onScheduleRoot(container, element);</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">current$1 = container.current;</span>
    <span class="s2">var </span><span class="s1">eventTime = requestEventTime();</span>
    <span class="s2">var </span><span class="s1">lane = requestUpdateLane(current$1);</span>

    <span class="s2">var </span><span class="s1">context = getContextForSubtree(parentComponent);</span>

    <span class="s2">if </span><span class="s1">(container.context === </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">container.context = context;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">container.pendingContext = context;</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(isRendering &amp;&amp; current !== </span><span class="s2">null </span><span class="s1">&amp;&amp; !didWarnAboutNestedUpdates) {</span>
        <span class="s1">didWarnAboutNestedUpdates = </span><span class="s2">true</span><span class="s1">;</span>

        <span class="s1">error(</span><span class="s3">'Render methods should be a pure function of props and state; ' </span><span class="s1">+ </span><span class="s3">'triggering nested component updates from render is not allowed. ' </span><span class="s1">+ </span><span class="s3">'If necessary, trigger nested updates in componentDidUpdate.</span><span class="s5">\n\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">'Check the render method of %s.'</span><span class="s1">, getComponentNameFromFiber(current) || </span><span class="s3">'Unknown'</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">update = createUpdate(eventTime, lane); </span><span class="s0">// Caution: React DevTools currently depends on this property</span>
    <span class="s0">// being called &quot;element&quot;.</span>

    <span class="s1">update.payload = {</span>
      <span class="s1">element: element</span>
    <span class="s1">};</span>
    <span class="s1">callback = callback === undefined ? </span><span class="s2">null </span><span class="s1">: callback;</span>

    <span class="s2">if </span><span class="s1">(callback !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">callback !== </span><span class="s3">'function'</span><span class="s1">) {</span>
          <span class="s1">error(</span><span class="s3">'render(...): Expected the last optional `callback` argument to be a ' </span><span class="s1">+ </span><span class="s3">'function. Instead received: %s.'</span><span class="s1">, callback);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">update.callback = callback;</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">root = enqueueUpdate(current$1, update, lane);</span>

    <span class="s2">if </span><span class="s1">(root !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">scheduleUpdateOnFiber(root, current$1, lane, eventTime);</span>
      <span class="s1">entangleTransitions(root, current$1, lane);</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">lane;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">getPublicRootInstance(container) {</span>
    <span class="s2">var </span><span class="s1">containerFiber = container.current;</span>

    <span class="s2">if </span><span class="s1">(!containerFiber.child) {</span>
      <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">switch </span><span class="s1">(containerFiber.child.tag) {</span>
      <span class="s2">case </span><span class="s1">HostComponent:</span>
        <span class="s2">return </span><span class="s1">getPublicInstance(containerFiber.child.stateNode);</span>

      <span class="s2">default</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">containerFiber.child.stateNode;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">shouldErrorImpl = </span><span class="s2">function </span><span class="s1">(fiber) {</span>
    <span class="s2">return null</span><span class="s1">;</span>
  <span class="s1">};</span>

  <span class="s2">function </span><span class="s1">shouldError(fiber) {</span>
    <span class="s2">return </span><span class="s1">shouldErrorImpl(fiber);</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">shouldSuspendImpl = </span><span class="s2">function </span><span class="s1">(fiber) {</span>
    <span class="s2">return false</span><span class="s1">;</span>
  <span class="s1">};</span>

  <span class="s2">function </span><span class="s1">shouldSuspend(fiber) {</span>
    <span class="s2">return </span><span class="s1">shouldSuspendImpl(fiber);</span>
  <span class="s1">}</span>
  <span class="s2">var </span><span class="s1">overrideHookState = </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">overrideHookStateDeletePath = </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">overrideHookStateRenamePath = </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">overrideProps = </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">overridePropsDeletePath = </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">overridePropsRenamePath = </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">scheduleUpdate = </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">setErrorHandler = </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">setSuspenseHandler = </span><span class="s2">null</span><span class="s1">;</span>

  <span class="s1">{</span>
    <span class="s2">var </span><span class="s1">copyWithDeleteImpl = </span><span class="s2">function </span><span class="s1">(obj, path, index) {</span>
      <span class="s2">var </span><span class="s1">key = path[index];</span>
      <span class="s2">var </span><span class="s1">updated = isArray(obj) ? obj.slice() : assign({}, obj);</span>

      <span class="s2">if </span><span class="s1">(index + </span><span class="s4">1 </span><span class="s1">=== path.length) {</span>
        <span class="s2">if </span><span class="s1">(isArray(updated)) {</span>
          <span class="s1">updated.splice(key, </span><span class="s4">1</span><span class="s1">);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s2">delete </span><span class="s1">updated[key];</span>
        <span class="s1">}</span>

        <span class="s2">return </span><span class="s1">updated;</span>
      <span class="s1">} </span><span class="s0">// $FlowFixMe number or string is fine here</span>


      <span class="s1">updated[key] = copyWithDeleteImpl(obj[key], path, index + </span><span class="s4">1</span><span class="s1">);</span>
      <span class="s2">return </span><span class="s1">updated;</span>
    <span class="s1">};</span>

    <span class="s2">var </span><span class="s1">copyWithDelete = </span><span class="s2">function </span><span class="s1">(obj, path) {</span>
      <span class="s2">return </span><span class="s1">copyWithDeleteImpl(obj, path, </span><span class="s4">0</span><span class="s1">);</span>
    <span class="s1">};</span>

    <span class="s2">var </span><span class="s1">copyWithRenameImpl = </span><span class="s2">function </span><span class="s1">(obj, oldPath, newPath, index) {</span>
      <span class="s2">var </span><span class="s1">oldKey = oldPath[index];</span>
      <span class="s2">var </span><span class="s1">updated = isArray(obj) ? obj.slice() : assign({}, obj);</span>

      <span class="s2">if </span><span class="s1">(index + </span><span class="s4">1 </span><span class="s1">=== oldPath.length) {</span>
        <span class="s2">var </span><span class="s1">newKey = newPath[index]; </span><span class="s0">// $FlowFixMe number or string is fine here</span>

        <span class="s1">updated[newKey] = updated[oldKey];</span>

        <span class="s2">if </span><span class="s1">(isArray(updated)) {</span>
          <span class="s1">updated.splice(oldKey, </span><span class="s4">1</span><span class="s1">);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s2">delete </span><span class="s1">updated[oldKey];</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s0">// $FlowFixMe number or string is fine here</span>
        <span class="s1">updated[oldKey] = copyWithRenameImpl( </span><span class="s0">// $FlowFixMe number or string is fine here</span>
        <span class="s1">obj[oldKey], oldPath, newPath, index + </span><span class="s4">1</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s2">return </span><span class="s1">updated;</span>
    <span class="s1">};</span>

    <span class="s2">var </span><span class="s1">copyWithRename = </span><span class="s2">function </span><span class="s1">(obj, oldPath, newPath) {</span>
      <span class="s2">if </span><span class="s1">(oldPath.length !== newPath.length) {</span>
        <span class="s1">warn(</span><span class="s3">'copyWithRename() expects paths of the same length'</span><span class="s1">);</span>

        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; newPath.length - </span><span class="s4">1</span><span class="s1">; i++) {</span>
          <span class="s2">if </span><span class="s1">(oldPath[i] !== newPath[i]) {</span>
            <span class="s1">warn(</span><span class="s3">'copyWithRename() expects paths to be the same except for the deepest key'</span><span class="s1">);</span>

            <span class="s2">return</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">return </span><span class="s1">copyWithRenameImpl(obj, oldPath, newPath, </span><span class="s4">0</span><span class="s1">);</span>
    <span class="s1">};</span>

    <span class="s2">var </span><span class="s1">copyWithSetImpl = </span><span class="s2">function </span><span class="s1">(obj, path, index, value) {</span>
      <span class="s2">if </span><span class="s1">(index &gt;= path.length) {</span>
        <span class="s2">return </span><span class="s1">value;</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">key = path[index];</span>
      <span class="s2">var </span><span class="s1">updated = isArray(obj) ? obj.slice() : assign({}, obj); </span><span class="s0">// $FlowFixMe number or string is fine here</span>

      <span class="s1">updated[key] = copyWithSetImpl(obj[key], path, index + </span><span class="s4">1</span><span class="s1">, value);</span>
      <span class="s2">return </span><span class="s1">updated;</span>
    <span class="s1">};</span>

    <span class="s2">var </span><span class="s1">copyWithSet = </span><span class="s2">function </span><span class="s1">(obj, path, value) {</span>
      <span class="s2">return </span><span class="s1">copyWithSetImpl(obj, path, </span><span class="s4">0</span><span class="s1">, value);</span>
    <span class="s1">};</span>

    <span class="s2">var </span><span class="s1">findHook = </span><span class="s2">function </span><span class="s1">(fiber, id) {</span>
      <span class="s0">// For now, the &quot;id&quot; of stateful hooks is just the stateful hook index.</span>
      <span class="s0">// This may change in the future with e.g. nested hooks.</span>
      <span class="s2">var </span><span class="s1">currentHook = fiber.memoizedState;</span>

      <span class="s2">while </span><span class="s1">(currentHook !== </span><span class="s2">null </span><span class="s1">&amp;&amp; id &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">currentHook = currentHook.next;</span>
        <span class="s1">id--;</span>
      <span class="s1">}</span>

      <span class="s2">return </span><span class="s1">currentHook;</span>
    <span class="s1">}; </span><span class="s0">// Support DevTools editable values for useState and useReducer.</span>


    <span class="s1">overrideHookState = </span><span class="s2">function </span><span class="s1">(fiber, id, path, value) {</span>
      <span class="s2">var </span><span class="s1">hook = findHook(fiber, id);</span>

      <span class="s2">if </span><span class="s1">(hook !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">var </span><span class="s1">newState = copyWithSet(hook.memoizedState, path, value);</span>
        <span class="s1">hook.memoizedState = newState;</span>
        <span class="s1">hook.baseState = newState; </span><span class="s0">// We aren't actually adding an update to the queue,</span>
        <span class="s0">// because there is no update we can add for useReducer hooks that won't trigger an error.</span>
        <span class="s0">// (There's no appropriate action type for DevTools overrides.)</span>
        <span class="s0">// As a result though, React will see the scheduled update as a noop and bailout.</span>
        <span class="s0">// Shallow cloning props works as a workaround for now to bypass the bailout check.</span>

        <span class="s1">fiber.memoizedProps = assign({}, fiber.memoizedProps);</span>
        <span class="s2">var </span><span class="s1">root = enqueueConcurrentRenderForLane(fiber, SyncLane);</span>

        <span class="s2">if </span><span class="s1">(root !== </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">};</span>

    <span class="s1">overrideHookStateDeletePath = </span><span class="s2">function </span><span class="s1">(fiber, id, path) {</span>
      <span class="s2">var </span><span class="s1">hook = findHook(fiber, id);</span>

      <span class="s2">if </span><span class="s1">(hook !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">var </span><span class="s1">newState = copyWithDelete(hook.memoizedState, path);</span>
        <span class="s1">hook.memoizedState = newState;</span>
        <span class="s1">hook.baseState = newState; </span><span class="s0">// We aren't actually adding an update to the queue,</span>
        <span class="s0">// because there is no update we can add for useReducer hooks that won't trigger an error.</span>
        <span class="s0">// (There's no appropriate action type for DevTools overrides.)</span>
        <span class="s0">// As a result though, React will see the scheduled update as a noop and bailout.</span>
        <span class="s0">// Shallow cloning props works as a workaround for now to bypass the bailout check.</span>

        <span class="s1">fiber.memoizedProps = assign({}, fiber.memoizedProps);</span>
        <span class="s2">var </span><span class="s1">root = enqueueConcurrentRenderForLane(fiber, SyncLane);</span>

        <span class="s2">if </span><span class="s1">(root !== </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">};</span>

    <span class="s1">overrideHookStateRenamePath = </span><span class="s2">function </span><span class="s1">(fiber, id, oldPath, newPath) {</span>
      <span class="s2">var </span><span class="s1">hook = findHook(fiber, id);</span>

      <span class="s2">if </span><span class="s1">(hook !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">var </span><span class="s1">newState = copyWithRename(hook.memoizedState, oldPath, newPath);</span>
        <span class="s1">hook.memoizedState = newState;</span>
        <span class="s1">hook.baseState = newState; </span><span class="s0">// We aren't actually adding an update to the queue,</span>
        <span class="s0">// because there is no update we can add for useReducer hooks that won't trigger an error.</span>
        <span class="s0">// (There's no appropriate action type for DevTools overrides.)</span>
        <span class="s0">// As a result though, React will see the scheduled update as a noop and bailout.</span>
        <span class="s0">// Shallow cloning props works as a workaround for now to bypass the bailout check.</span>

        <span class="s1">fiber.memoizedProps = assign({}, fiber.memoizedProps);</span>
        <span class="s2">var </span><span class="s1">root = enqueueConcurrentRenderForLane(fiber, SyncLane);</span>

        <span class="s2">if </span><span class="s1">(root !== </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}; </span><span class="s0">// Support DevTools props for function components, forwardRef, memo, host components, etc.</span>


    <span class="s1">overrideProps = </span><span class="s2">function </span><span class="s1">(fiber, path, value) {</span>
      <span class="s1">fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);</span>

      <span class="s2">if </span><span class="s1">(fiber.alternate) {</span>
        <span class="s1">fiber.alternate.pendingProps = fiber.pendingProps;</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">root = enqueueConcurrentRenderForLane(fiber, SyncLane);</span>

      <span class="s2">if </span><span class="s1">(root !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);</span>
      <span class="s1">}</span>
    <span class="s1">};</span>

    <span class="s1">overridePropsDeletePath = </span><span class="s2">function </span><span class="s1">(fiber, path) {</span>
      <span class="s1">fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path);</span>

      <span class="s2">if </span><span class="s1">(fiber.alternate) {</span>
        <span class="s1">fiber.alternate.pendingProps = fiber.pendingProps;</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">root = enqueueConcurrentRenderForLane(fiber, SyncLane);</span>

      <span class="s2">if </span><span class="s1">(root !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);</span>
      <span class="s1">}</span>
    <span class="s1">};</span>

    <span class="s1">overridePropsRenamePath = </span><span class="s2">function </span><span class="s1">(fiber, oldPath, newPath) {</span>
      <span class="s1">fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);</span>

      <span class="s2">if </span><span class="s1">(fiber.alternate) {</span>
        <span class="s1">fiber.alternate.pendingProps = fiber.pendingProps;</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">root = enqueueConcurrentRenderForLane(fiber, SyncLane);</span>

      <span class="s2">if </span><span class="s1">(root !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);</span>
      <span class="s1">}</span>
    <span class="s1">};</span>

    <span class="s1">scheduleUpdate = </span><span class="s2">function </span><span class="s1">(fiber) {</span>
      <span class="s2">var </span><span class="s1">root = enqueueConcurrentRenderForLane(fiber, SyncLane);</span>

      <span class="s2">if </span><span class="s1">(root !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);</span>
      <span class="s1">}</span>
    <span class="s1">};</span>

    <span class="s1">setErrorHandler = </span><span class="s2">function </span><span class="s1">(newShouldErrorImpl) {</span>
      <span class="s1">shouldErrorImpl = newShouldErrorImpl;</span>
    <span class="s1">};</span>

    <span class="s1">setSuspenseHandler = </span><span class="s2">function </span><span class="s1">(newShouldSuspendImpl) {</span>
      <span class="s1">shouldSuspendImpl = newShouldSuspendImpl;</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">findHostInstanceByFiber(fiber) {</span>
    <span class="s2">var </span><span class="s1">hostFiber = findCurrentHostFiber(fiber);</span>

    <span class="s2">if </span><span class="s1">(hostFiber === </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">hostFiber.stateNode;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">emptyFindFiberByHostInstance(instance) {</span>
    <span class="s2">return null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">getCurrentFiberForDevTools() {</span>
    <span class="s2">return </span><span class="s1">current;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">injectIntoDevTools(devToolsConfig) {</span>
    <span class="s2">var </span><span class="s1">findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;</span>
    <span class="s2">var </span><span class="s1">ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;</span>
    <span class="s2">return </span><span class="s1">injectInternals({</span>
      <span class="s1">bundleType: devToolsConfig.bundleType,</span>
      <span class="s1">version: devToolsConfig.version,</span>
      <span class="s1">rendererPackageName: devToolsConfig.rendererPackageName,</span>
      <span class="s1">rendererConfig: devToolsConfig.rendererConfig,</span>
      <span class="s1">overrideHookState: overrideHookState,</span>
      <span class="s1">overrideHookStateDeletePath: overrideHookStateDeletePath,</span>
      <span class="s1">overrideHookStateRenamePath: overrideHookStateRenamePath,</span>
      <span class="s1">overrideProps: overrideProps,</span>
      <span class="s1">overridePropsDeletePath: overridePropsDeletePath,</span>
      <span class="s1">overridePropsRenamePath: overridePropsRenamePath,</span>
      <span class="s1">setErrorHandler: setErrorHandler,</span>
      <span class="s1">setSuspenseHandler: setSuspenseHandler,</span>
      <span class="s1">scheduleUpdate: scheduleUpdate,</span>
      <span class="s1">currentDispatcherRef: ReactCurrentDispatcher,</span>
      <span class="s1">findHostInstanceByFiber: findHostInstanceByFiber,</span>
      <span class="s1">findFiberByHostInstance: findFiberByHostInstance || emptyFindFiberByHostInstance,</span>
      <span class="s0">// React Refresh</span>
      <span class="s1">findHostInstancesForRefresh:  findHostInstancesForRefresh ,</span>
      <span class="s1">scheduleRefresh:  scheduleRefresh ,</span>
      <span class="s1">scheduleRoot:  scheduleRoot ,</span>
      <span class="s1">setRefreshHandler:  setRefreshHandler ,</span>
      <span class="s0">// Enables DevTools to append owner stacks to error messages in DEV mode.</span>
      <span class="s1">getCurrentFiber:  getCurrentFiberForDevTools ,</span>
      <span class="s0">// Enables DevTools to detect reconciler version rather than renderer version</span>
      <span class="s0">// which may not match for third party renderers.</span>
      <span class="s1">reconcilerVersion: ReactVersion</span>
    <span class="s1">});</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">act = React.unstable_act; </span><span class="s0">// TODO: Remove from public bundle</span>

  <span class="s2">var </span><span class="s1">defaultTestOptions = {</span>
    <span class="s1">createNodeMock: </span><span class="s2">function </span><span class="s1">() {</span>
      <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s2">function </span><span class="s1">toJSON(inst) {</span>
    <span class="s2">if </span><span class="s1">(inst.isHidden) {</span>
      <span class="s0">// Omit timed out children from output entirely. This seems like the least</span>
      <span class="s0">// surprising behavior. We could perhaps add a separate API that includes</span>
      <span class="s0">// them, if it turns out people need it.</span>
      <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">switch </span><span class="s1">(inst.tag) {</span>
      <span class="s2">case </span><span class="s3">'TEXT'</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">inst.text;</span>

      <span class="s2">case </span><span class="s3">'INSTANCE'</span><span class="s1">:</span>
        <span class="s1">{</span>
          <span class="s0">/* eslint-disable no-unused-vars */</span>
          <span class="s0">// We don't include the `children` prop in JSON.</span>
          <span class="s0">// Instead, we will include the actual rendered children.</span>
          <span class="s2">var </span><span class="s1">_inst$props = inst.props,</span>
              <span class="s1">children = _inst$props.children,</span>
              <span class="s1">props = _objectWithoutPropertiesLoose(_inst$props, [</span><span class="s3">&quot;children&quot;</span><span class="s1">]);</span>
          <span class="s0">/* eslint-enable */</span>


          <span class="s2">var </span><span class="s1">renderedChildren = </span><span class="s2">null</span><span class="s1">;</span>

          <span class="s2">if </span><span class="s1">(inst.children &amp;&amp; inst.children.length) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; inst.children.length; i++) {</span>
              <span class="s2">var </span><span class="s1">renderedChild = toJSON(inst.children[i]);</span>

              <span class="s2">if </span><span class="s1">(renderedChild !== </span><span class="s2">null</span><span class="s1">) {</span>
                <span class="s2">if </span><span class="s1">(renderedChildren === </span><span class="s2">null</span><span class="s1">) {</span>
                  <span class="s1">renderedChildren = [renderedChild];</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                  <span class="s1">renderedChildren.push(renderedChild);</span>
                <span class="s1">}</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s2">var </span><span class="s1">json = {</span>
            <span class="s1">type: inst.type,</span>
            <span class="s1">props: props,</span>
            <span class="s1">children: renderedChildren</span>
          <span class="s1">};</span>
          <span class="s1">Object.defineProperty(json, </span><span class="s3">'$$typeof'</span><span class="s1">, {</span>
            <span class="s1">value: Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.test.json'</span><span class="s1">)</span>
          <span class="s1">});</span>
          <span class="s2">return </span><span class="s1">json;</span>
        <span class="s1">}</span>

      <span class="s2">default</span><span class="s1">:</span>
        <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">&quot;Unexpected node type in toJSON: &quot; </span><span class="s1">+ inst.tag);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">childrenToTree(node) {</span>
    <span class="s2">if </span><span class="s1">(!node) {</span>
      <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">children = nodeAndSiblingsArray(node);</span>

    <span class="s2">if </span><span class="s1">(children.length === </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(children.length === </span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">toTree(children[</span><span class="s4">0</span><span class="s1">]);</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">flatten(children.map(toTree));</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">nodeAndSiblingsArray(nodeWithSibling) {</span>
    <span class="s2">var </span><span class="s1">array = [];</span>
    <span class="s2">var </span><span class="s1">node = nodeWithSibling;</span>

    <span class="s2">while </span><span class="s1">(node != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">array.push(node);</span>
      <span class="s1">node = node.sibling;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">array;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">flatten(arr) {</span>
    <span class="s2">var </span><span class="s1">result = [];</span>
    <span class="s2">var </span><span class="s1">stack = [{</span>
      <span class="s1">i: </span><span class="s4">0</span><span class="s1">,</span>
      <span class="s1">array: arr</span>
    <span class="s1">}];</span>

    <span class="s2">while </span><span class="s1">(stack.length) {</span>
      <span class="s2">var </span><span class="s1">n = stack.pop();</span>

      <span class="s2">while </span><span class="s1">(n.i &lt; n.array.length) {</span>
        <span class="s2">var </span><span class="s1">el = n.array[n.i];</span>
        <span class="s1">n.i += </span><span class="s4">1</span><span class="s1">;</span>

        <span class="s2">if </span><span class="s1">(isArray(el)) {</span>
          <span class="s1">stack.push(n);</span>
          <span class="s1">stack.push({</span>
            <span class="s1">i: </span><span class="s4">0</span><span class="s1">,</span>
            <span class="s1">array: el</span>
          <span class="s1">});</span>
          <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">result.push(el);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">result;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">toTree(node) {</span>
    <span class="s2">if </span><span class="s1">(node == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">switch </span><span class="s1">(node.tag) {</span>
      <span class="s2">case </span><span class="s1">HostRoot:</span>
        <span class="s2">return </span><span class="s1">childrenToTree(node.child);</span>

      <span class="s2">case </span><span class="s1">HostPortal:</span>
        <span class="s2">return </span><span class="s1">childrenToTree(node.child);</span>

      <span class="s2">case </span><span class="s1">ClassComponent:</span>
        <span class="s2">return </span><span class="s1">{</span>
          <span class="s1">nodeType: </span><span class="s3">'component'</span><span class="s1">,</span>
          <span class="s1">type: node.type,</span>
          <span class="s1">props: assign({}, node.memoizedProps),</span>
          <span class="s1">instance: node.stateNode,</span>
          <span class="s1">rendered: childrenToTree(node.child)</span>
        <span class="s1">};</span>

      <span class="s2">case </span><span class="s1">FunctionComponent:</span>
      <span class="s2">case </span><span class="s1">SimpleMemoComponent:</span>
        <span class="s2">return </span><span class="s1">{</span>
          <span class="s1">nodeType: </span><span class="s3">'component'</span><span class="s1">,</span>
          <span class="s1">type: node.type,</span>
          <span class="s1">props: assign({}, node.memoizedProps),</span>
          <span class="s1">instance: </span><span class="s2">null</span><span class="s1">,</span>
          <span class="s1">rendered: childrenToTree(node.child)</span>
        <span class="s1">};</span>

      <span class="s2">case </span><span class="s1">HostComponent:</span>
        <span class="s1">{</span>
          <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">nodeType: </span><span class="s3">'host'</span><span class="s1">,</span>
            <span class="s1">type: node.type,</span>
            <span class="s1">props: assign({}, node.memoizedProps),</span>
            <span class="s1">instance: </span><span class="s2">null</span><span class="s1">,</span>
            <span class="s0">// TODO: use createNodeMock here somehow?</span>
            <span class="s1">rendered: flatten(nodeAndSiblingsArray(node.child).map(toTree))</span>
          <span class="s1">};</span>
        <span class="s1">}</span>

      <span class="s2">case </span><span class="s1">HostText:</span>
        <span class="s2">return </span><span class="s1">node.stateNode.text;</span>

      <span class="s2">case </span><span class="s1">Fragment:</span>
      <span class="s2">case </span><span class="s1">ContextProvider:</span>
      <span class="s2">case </span><span class="s1">ContextConsumer:</span>
      <span class="s2">case </span><span class="s1">Mode:</span>
      <span class="s2">case </span><span class="s1">Profiler:</span>
      <span class="s2">case </span><span class="s1">ForwardRef:</span>
      <span class="s2">case </span><span class="s1">MemoComponent:</span>
      <span class="s2">case </span><span class="s1">IncompleteClassComponent:</span>
      <span class="s2">case </span><span class="s1">ScopeComponent:</span>
        <span class="s2">return </span><span class="s1">childrenToTree(node.child);</span>

      <span class="s2">default</span><span class="s1">:</span>
        <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">&quot;toTree() does not yet know how to handle nodes with tag=&quot; </span><span class="s1">+ node.tag);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">validWrapperTypes = </span><span class="s2">new </span><span class="s1">Set([FunctionComponent, ClassComponent, HostComponent, ForwardRef, MemoComponent, SimpleMemoComponent, </span><span class="s0">// Normally skipped, but used when there's more than one root child.</span>
  <span class="s1">HostRoot]);</span>

  <span class="s2">function </span><span class="s1">getChildren(parent) {</span>
    <span class="s2">var </span><span class="s1">children = [];</span>
    <span class="s2">var </span><span class="s1">startingNode = parent;</span>
    <span class="s2">var </span><span class="s1">node = startingNode;</span>

    <span class="s2">if </span><span class="s1">(node.child === </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">children;</span>
    <span class="s1">}</span>

    <span class="s1">node.child.</span><span class="s2">return </span><span class="s1">= node;</span>
    <span class="s1">node = node.child;</span>

    <span class="s1">outer: </span><span class="s2">while </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">descend = </span><span class="s2">false</span><span class="s1">;</span>

      <span class="s2">if </span><span class="s1">(validWrapperTypes.has(node.tag)) {</span>
        <span class="s1">children.push(wrapFiber(node));</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(node.tag === HostText) {</span>
        <span class="s1">{</span>
          <span class="s1">checkPropStringCoercion(node.memoizedProps, </span><span class="s3">'memoizedProps'</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s1">children.push(</span><span class="s3">'' </span><span class="s1">+ node.memoizedProps);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">descend = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(descend &amp;&amp; node.child !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">node.child.</span><span class="s2">return </span><span class="s1">= node;</span>
        <span class="s1">node = node.child;</span>
        <span class="s2">continue</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">while </span><span class="s1">(node.sibling === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(node.</span><span class="s2">return </span><span class="s1">=== startingNode) {</span>
          <span class="s2">break </span><span class="s1">outer;</span>
        <span class="s1">}</span>

        <span class="s1">node = node.</span><span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">node.sibling.</span><span class="s2">return </span><span class="s1">= node.</span><span class="s2">return</span><span class="s1">;</span>
      <span class="s1">node = node.sibling;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">children;</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">ReactTestInstance = </span><span class="s0">/*#__PURE__*/</span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">var </span><span class="s1">_proto = ReactTestInstance.prototype;</span>

    <span class="s1">_proto._currentFiber = </span><span class="s2">function </span><span class="s1">_currentFiber() {</span>
      <span class="s0">// Throws if this component has been unmounted.</span>
      <span class="s2">var </span><span class="s1">fiber = findCurrentFiberUsingSlowPath(</span><span class="s2">this</span><span class="s1">._fiber);</span>

      <span class="s2">if </span><span class="s1">(fiber === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">&quot;Can't read from currently-mounting component. This error is likely &quot; </span><span class="s1">+ </span><span class="s3">'caused by a bug in React. Please file an issue.'</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s2">return </span><span class="s1">fiber;</span>
    <span class="s1">};</span>

    <span class="s2">function </span><span class="s1">ReactTestInstance(fiber) {</span>
      <span class="s2">if </span><span class="s1">(!validWrapperTypes.has(fiber.tag)) {</span>
        <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">&quot;Unexpected object passed to ReactTestInstance constructor (tag: &quot; </span><span class="s1">+ fiber.tag + </span><span class="s3">&quot;). &quot; </span><span class="s1">+ </span><span class="s3">'This is probably a bug in React.'</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s2">this</span><span class="s1">._fiber = fiber;</span>
    <span class="s1">}</span>

    <span class="s0">// Custom search functions</span>
    <span class="s1">_proto.find = </span><span class="s2">function </span><span class="s1">find(predicate) {</span>
      <span class="s2">return </span><span class="s1">expectOne(</span><span class="s2">this</span><span class="s1">.findAll(predicate, {</span>
        <span class="s1">deep: </span><span class="s2">false</span>
      <span class="s1">}), </span><span class="s3">&quot;matching custom predicate: &quot; </span><span class="s1">+ predicate.toString());</span>
    <span class="s1">};</span>

    <span class="s1">_proto.findByType = </span><span class="s2">function </span><span class="s1">findByType(type) {</span>
      <span class="s2">return </span><span class="s1">expectOne(</span><span class="s2">this</span><span class="s1">.findAllByType(type, {</span>
        <span class="s1">deep: </span><span class="s2">false</span>
      <span class="s1">}), </span><span class="s3">&quot;with node type: </span><span class="s5">\&quot;</span><span class="s3">&quot; </span><span class="s1">+ (getComponentNameFromType(type) || </span><span class="s3">'Unknown'</span><span class="s1">) + </span><span class="s3">&quot;</span><span class="s5">\&quot;</span><span class="s3">&quot;</span><span class="s1">);</span>
    <span class="s1">};</span>

    <span class="s1">_proto.findByProps = </span><span class="s2">function </span><span class="s1">findByProps(props) {</span>
      <span class="s2">return </span><span class="s1">expectOne(</span><span class="s2">this</span><span class="s1">.findAllByProps(props, {</span>
        <span class="s1">deep: </span><span class="s2">false</span>
      <span class="s1">}), </span><span class="s3">&quot;with props: &quot; </span><span class="s1">+ JSON.stringify(props));</span>
    <span class="s1">};</span>

    <span class="s1">_proto.findAll = </span><span class="s2">function </span><span class="s1">findAll(predicate) {</span>
      <span class="s2">var </span><span class="s1">options = arguments.length &gt; </span><span class="s4">1 </span><span class="s1">&amp;&amp; arguments[</span><span class="s4">1</span><span class="s1">] !== undefined ? arguments[</span><span class="s4">1</span><span class="s1">] : </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s2">return </span><span class="s1">_findAll(</span><span class="s2">this</span><span class="s1">, predicate, options);</span>
    <span class="s1">};</span>

    <span class="s1">_proto.findAllByType = </span><span class="s2">function </span><span class="s1">findAllByType(type) {</span>
      <span class="s2">var </span><span class="s1">options = arguments.length &gt; </span><span class="s4">1 </span><span class="s1">&amp;&amp; arguments[</span><span class="s4">1</span><span class="s1">] !== undefined ? arguments[</span><span class="s4">1</span><span class="s1">] : </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s2">return </span><span class="s1">_findAll(</span><span class="s2">this</span><span class="s1">, </span><span class="s2">function </span><span class="s1">(node) {</span>
        <span class="s2">return </span><span class="s1">node.type === type;</span>
      <span class="s1">}, options);</span>
    <span class="s1">};</span>

    <span class="s1">_proto.findAllByProps = </span><span class="s2">function </span><span class="s1">findAllByProps(props) {</span>
      <span class="s2">var </span><span class="s1">options = arguments.length &gt; </span><span class="s4">1 </span><span class="s1">&amp;&amp; arguments[</span><span class="s4">1</span><span class="s1">] !== undefined ? arguments[</span><span class="s4">1</span><span class="s1">] : </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s2">return </span><span class="s1">_findAll(</span><span class="s2">this</span><span class="s1">, </span><span class="s2">function </span><span class="s1">(node) {</span>
        <span class="s2">return </span><span class="s1">node.props &amp;&amp; propsMatch(node.props, props);</span>
      <span class="s1">}, options);</span>
    <span class="s1">};</span>

    <span class="s1">_createClass(ReactTestInstance, [{</span>
      <span class="s1">key: </span><span class="s3">&quot;instance&quot;</span><span class="s1">,</span>
      <span class="s1">get: </span><span class="s2">function </span><span class="s1">() {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">._fiber.tag === HostComponent) {</span>
          <span class="s2">return </span><span class="s1">getPublicInstance(</span><span class="s2">this</span><span class="s1">._fiber.stateNode);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s2">return this</span><span class="s1">._fiber.stateNode;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}, {</span>
      <span class="s1">key: </span><span class="s3">&quot;type&quot;</span><span class="s1">,</span>
      <span class="s1">get: </span><span class="s2">function </span><span class="s1">() {</span>
        <span class="s2">return this</span><span class="s1">._fiber.type;</span>
      <span class="s1">}</span>
    <span class="s1">}, {</span>
      <span class="s1">key: </span><span class="s3">&quot;props&quot;</span><span class="s1">,</span>
      <span class="s1">get: </span><span class="s2">function </span><span class="s1">() {</span>
        <span class="s2">return this</span><span class="s1">._currentFiber().memoizedProps;</span>
      <span class="s1">}</span>
    <span class="s1">}, {</span>
      <span class="s1">key: </span><span class="s3">&quot;parent&quot;</span><span class="s1">,</span>
      <span class="s1">get: </span><span class="s2">function </span><span class="s1">() {</span>
        <span class="s2">var </span><span class="s1">parent = </span><span class="s2">this</span><span class="s1">._fiber.</span><span class="s2">return</span><span class="s1">;</span>

        <span class="s2">while </span><span class="s1">(parent !== </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s2">if </span><span class="s1">(validWrapperTypes.has(parent.tag)) {</span>
            <span class="s2">if </span><span class="s1">(parent.tag === HostRoot) {</span>
              <span class="s0">// Special case: we only &quot;materialize&quot; instances for roots</span>
              <span class="s0">// if they have more than a single child. So we'll check that now.</span>
              <span class="s2">if </span><span class="s1">(getChildren(parent).length &lt; </span><span class="s4">2</span><span class="s1">) {</span>
                <span class="s2">return null</span><span class="s1">;</span>
              <span class="s1">}</span>
            <span class="s1">}</span>

            <span class="s2">return </span><span class="s1">wrapFiber(parent);</span>
          <span class="s1">}</span>

          <span class="s1">parent = parent.</span><span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s2">return null</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}, {</span>
      <span class="s1">key: </span><span class="s3">&quot;children&quot;</span><span class="s1">,</span>
      <span class="s1">get: </span><span class="s2">function </span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">getChildren(</span><span class="s2">this</span><span class="s1">._currentFiber());</span>
      <span class="s1">}</span>
    <span class="s1">}]);</span>

    <span class="s2">return </span><span class="s1">ReactTestInstance;</span>
  <span class="s1">}();</span>

  <span class="s2">function </span><span class="s1">_findAll(root, predicate, options) {</span>
    <span class="s2">var </span><span class="s1">deep = options ? options.deep : </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s2">var </span><span class="s1">results = [];</span>

    <span class="s2">if </span><span class="s1">(predicate(root)) {</span>
      <span class="s1">results.push(root);</span>

      <span class="s2">if </span><span class="s1">(!deep) {</span>
        <span class="s2">return </span><span class="s1">results;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">root.children.forEach(</span><span class="s2">function </span><span class="s1">(child) {</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">child === </span><span class="s3">'string'</span><span class="s1">) {</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">results.push.apply(results, _findAll(child, predicate, options));</span>
    <span class="s1">});</span>
    <span class="s2">return </span><span class="s1">results;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">expectOne(all, message) {</span>
    <span class="s2">if </span><span class="s1">(all.length === </span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">all[</span><span class="s4">0</span><span class="s1">];</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">prefix = all.length === </span><span class="s4">0 </span><span class="s1">? </span><span class="s3">'No instances found ' </span><span class="s1">: </span><span class="s3">&quot;Expected 1 but found &quot; </span><span class="s1">+ all.length + </span><span class="s3">&quot; instances &quot;</span><span class="s1">;</span>
    <span class="s2">throw new </span><span class="s1">Error(prefix + message);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">propsMatch(props, filter) {</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">key </span><span class="s2">in </span><span class="s1">filter) {</span>
      <span class="s2">if </span><span class="s1">(props[key] !== filter[key]) {</span>
        <span class="s2">return false</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return true</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">onRecoverableError(error$1) {</span>
    <span class="s0">// TODO: Expose onRecoverableError option to userspace</span>
    <span class="s0">// eslint-disable-next-line react-internal/no-production-logging, react-internal/warning-args</span>
    <span class="s1">error(error$1);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">create(element, options) {</span>
    <span class="s2">var </span><span class="s1">createNodeMock = defaultTestOptions.createNodeMock;</span>
    <span class="s2">var </span><span class="s1">isConcurrent = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s2">var </span><span class="s1">isStrictMode = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s2">var </span><span class="s1">concurrentUpdatesByDefault = </span><span class="s2">null</span><span class="s1">;</span>

    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">options === </span><span class="s3">'object' </span><span class="s1">&amp;&amp; options !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">options.createNodeMock === </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s1">createNodeMock = options.createNodeMock;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(options.unstable_isConcurrent === </span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s1">isConcurrent = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(options.unstable_strictMode === </span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s1">isStrictMode = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">container = {</span>
      <span class="s1">children: [],</span>
      <span class="s1">createNodeMock: createNodeMock,</span>
      <span class="s1">tag: </span><span class="s3">'CONTAINER'</span>
    <span class="s1">};</span>
    <span class="s2">var </span><span class="s1">root = createContainer(container, isConcurrent ? ConcurrentRoot : LegacyRoot, </span><span class="s2">null</span><span class="s1">, isStrictMode, concurrentUpdatesByDefault, </span><span class="s3">''</span><span class="s1">, onRecoverableError);</span>

    <span class="s2">if </span><span class="s1">(root == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'something went wrong'</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s1">updateContainer(element, root, </span><span class="s2">null</span><span class="s1">, </span><span class="s2">null</span><span class="s1">);</span>
    <span class="s2">var </span><span class="s1">entry = {</span>
      <span class="s1">_Scheduler: Scheduler,</span>
      <span class="s1">root: undefined,</span>
      <span class="s0">// makes flow happy</span>
      <span class="s0">// we define a 'getter' for 'root' below using 'Object.defineProperty'</span>
      <span class="s1">toJSON: </span><span class="s2">function </span><span class="s1">() {</span>
        <span class="s2">if </span><span class="s1">(root == </span><span class="s2">null </span><span class="s1">|| root.current == </span><span class="s2">null </span><span class="s1">|| container == </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s2">return null</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(container.children.length === </span><span class="s4">0</span><span class="s1">) {</span>
          <span class="s2">return null</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(container.children.length === </span><span class="s4">1</span><span class="s1">) {</span>
          <span class="s2">return </span><span class="s1">toJSON(container.children[</span><span class="s4">0</span><span class="s1">]);</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(container.children.length === </span><span class="s4">2 </span><span class="s1">&amp;&amp; container.children[</span><span class="s4">0</span><span class="s1">].isHidden === </span><span class="s2">true </span><span class="s1">&amp;&amp; container.children[</span><span class="s4">1</span><span class="s1">].isHidden === </span><span class="s2">false</span><span class="s1">) {</span>
          <span class="s0">// Omit timed out children from output entirely, including the fact that we</span>
          <span class="s0">// temporarily wrap fallback and timed out children in an array.</span>
          <span class="s2">return </span><span class="s1">toJSON(container.children[</span><span class="s4">1</span><span class="s1">]);</span>
        <span class="s1">}</span>

        <span class="s2">var </span><span class="s1">renderedChildren = </span><span class="s2">null</span><span class="s1">;</span>

        <span class="s2">if </span><span class="s1">(container.children &amp;&amp; container.children.length) {</span>
          <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; container.children.length; i++) {</span>
            <span class="s2">var </span><span class="s1">renderedChild = toJSON(container.children[i]);</span>

            <span class="s2">if </span><span class="s1">(renderedChild !== </span><span class="s2">null</span><span class="s1">) {</span>
              <span class="s2">if </span><span class="s1">(renderedChildren === </span><span class="s2">null</span><span class="s1">) {</span>
                <span class="s1">renderedChildren = [renderedChild];</span>
              <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">renderedChildren.push(renderedChild);</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s2">return </span><span class="s1">renderedChildren;</span>
      <span class="s1">},</span>
      <span class="s1">toTree: </span><span class="s2">function </span><span class="s1">() {</span>
        <span class="s2">if </span><span class="s1">(root == </span><span class="s2">null </span><span class="s1">|| root.current == </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s2">return null</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s2">return </span><span class="s1">toTree(root.current);</span>
      <span class="s1">},</span>
      <span class="s1">update: </span><span class="s2">function </span><span class="s1">(newElement) {</span>
        <span class="s2">if </span><span class="s1">(root == </span><span class="s2">null </span><span class="s1">|| root.current == </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">updateContainer(newElement, root, </span><span class="s2">null</span><span class="s1">, </span><span class="s2">null</span><span class="s1">);</span>
      <span class="s1">},</span>
      <span class="s1">unmount: </span><span class="s2">function </span><span class="s1">() {</span>
        <span class="s2">if </span><span class="s1">(root == </span><span class="s2">null </span><span class="s1">|| root.current == </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">updateContainer(</span><span class="s2">null</span><span class="s1">, root, </span><span class="s2">null</span><span class="s1">, </span><span class="s2">null</span><span class="s1">);</span>
        <span class="s1">container = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s1">root = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">},</span>
      <span class="s1">getInstance: </span><span class="s2">function </span><span class="s1">() {</span>
        <span class="s2">if </span><span class="s1">(root == </span><span class="s2">null </span><span class="s1">|| root.current == </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s2">return null</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s2">return </span><span class="s1">getPublicRootInstance(root);</span>
      <span class="s1">},</span>
      <span class="s1">unstable_flushSync: flushSync</span>
    <span class="s1">};</span>
    <span class="s1">Object.defineProperty(entry, </span><span class="s3">'root'</span><span class="s1">, {</span>
      <span class="s1">configurable: </span><span class="s2">true</span><span class="s1">,</span>
      <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
      <span class="s1">get: </span><span class="s2">function </span><span class="s1">() {</span>
        <span class="s2">if </span><span class="s1">(root === </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">&quot;Can't access .root on unmounted test renderer&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s2">var </span><span class="s1">children = getChildren(root.current);</span>

        <span class="s2">if </span><span class="s1">(children.length === </span><span class="s4">0</span><span class="s1">) {</span>
          <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">&quot;Can't access .root on unmounted test renderer&quot;</span><span class="s1">);</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(children.length === </span><span class="s4">1</span><span class="s1">) {</span>
          <span class="s0">// Normally, we skip the root and just give you the child.</span>
          <span class="s2">return </span><span class="s1">children[</span><span class="s4">0</span><span class="s1">];</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s0">// However, we give you the root if there's more than one root child.</span>
          <span class="s0">// We could make this the behavior for all cases but it would be a breaking change.</span>
          <span class="s2">return </span><span class="s1">wrapFiber(root.current);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s2">return </span><span class="s1">entry;</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">fiberToWrapper = </span><span class="s2">new </span><span class="s1">WeakMap();</span>

  <span class="s2">function </span><span class="s1">wrapFiber(fiber) {</span>
    <span class="s2">var </span><span class="s1">wrapper = fiberToWrapper.get(fiber);</span>

    <span class="s2">if </span><span class="s1">(wrapper === undefined &amp;&amp; fiber.alternate !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">wrapper = fiberToWrapper.get(fiber.alternate);</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(wrapper === undefined) {</span>
      <span class="s1">wrapper = </span><span class="s2">new </span><span class="s1">ReactTestInstance(fiber);</span>
      <span class="s1">fiberToWrapper.set(fiber, wrapper);</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">wrapper;</span>
  <span class="s1">} </span><span class="s0">// Enable ReactTestRenderer to be used to test DevTools integration.</span>


  <span class="s1">injectIntoDevTools({</span>
    <span class="s1">findFiberByHostInstance: </span><span class="s2">function </span><span class="s1">() {</span>
      <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'TestRenderer does not support findFiberByHostInstance()'</span><span class="s1">);</span>
    <span class="s1">},</span>
    <span class="s1">bundleType:  </span><span class="s4">1 </span><span class="s1">,</span>
    <span class="s1">version: ReactVersion,</span>
    <span class="s1">rendererPackageName: </span><span class="s3">'react-test-renderer'</span>
  <span class="s1">});</span>

  <span class="s1">exports._Scheduler = Scheduler;</span>
  <span class="s1">exports.act = act;</span>
  <span class="s1">exports.create = create;</span>
  <span class="s1">exports.unstable_batchedUpdates = batchedUpdates;</span>

<span class="s1">})));</span>
</pre>
</body>
</html>
<html>
<head>
<title>readline.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #cc7832;}
.s2 { color: #a9b7c6;}
.s3 { color: #a9b7c6;}
.s4 { color: #6a8759;}
.s5 { color: #9876aa; font-style: italic;}
.s6 { color: #ffc66d;}
.s7 { color: #6897bb; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
readline.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* The `node:readline` module provides an interface for reading data from a `Readable` stream (such as `process.stdin`) one line at a time. 
 * 
 * To use the promise-based APIs: 
 * 
 * ```js 
 * import * as readline from 'node:readline/promises'; 
 * ``` 
 * 
 * To use the callback and sync APIs: 
 * 
 * ```js 
 * import * as readline from 'node:readline'; 
 * ``` 
 * 
 * The following simple example illustrates the basic use of the `node:readline`module. 
 * 
 * ```js 
 * import * as readline from 'node:readline/promises'; 
 * import { stdin as input, stdout as output } from 'node:process'; 
 * 
 * const rl = readline.createInterface({ input, output }); 
 * 
 * const answer = await rl.question('What do you think of Node.js? '); 
 * 
 * console.log(`Thank you for your valuable feedback: ${answer}`); 
 * 
 * rl.close(); 
 * ``` 
 * 
 * Once this code is invoked, the Node.js application will not terminate until the`readline.Interface` is closed because the interface waits for data to be 
 * received on the `input` stream. 
 * </span><span class="s1">@see </span><span class="s2">[source](https:</span><span class="s0">//github.com/nodejs/node/blob/v20.2.0/lib/readline.js) 
 */</span>
<span class="s1">declare module </span><span class="s4">'readline' </span><span class="s3">{</span>
    <span class="s1">import </span><span class="s3">{ </span><span class="s2">Abortable</span><span class="s3">, </span><span class="s2">EventEmitter </span><span class="s3">} </span><span class="s1">from </span><span class="s4">'node:events'</span><span class="s3">;</span>
    <span class="s1">import </span><span class="s5">* </span><span class="s1">as </span><span class="s2">promises </span><span class="s1">from </span><span class="s4">'node:readline/promises'</span><span class="s3">;</span>
    <span class="s1">export </span><span class="s3">{ </span><span class="s2">promises </span><span class="s3">};</span>
    <span class="s1">export interface </span><span class="s2">Key </span><span class="s3">{</span>
        <span class="s3">sequence</span><span class="s1">?: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s3">name</span><span class="s1">?: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s3">ctrl</span><span class="s1">?: </span><span class="s2">boolean </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s3">meta</span><span class="s1">?: </span><span class="s2">boolean </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s3">shift</span><span class="s1">?: </span><span class="s2">boolean </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Instances of the `readline.Interface` class are constructed using the`readline.createInterface()` method. Every instance is associated with a 
     * single `input` `Readable` stream and a single `output` `Writable` stream. 
     * The `output` stream is used to print prompts for user input that arrives on, 
     * and is read from, the `input` stream. 
     * </span><span class="s1">@since </span><span class="s0">v0.1.104 
     */</span>
    <span class="s1">export class </span><span class="s2">Interface </span><span class="s1">extends </span><span class="s2">EventEmitter </span><span class="s3">{</span>
        <span class="s1">readonly </span><span class="s3">terminal</span><span class="s1">: </span><span class="s2">boolean</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The current input data being processed by node. 
         * 
         * This can be used when collecting input from a TTY stream to retrieve the 
         * current value that has been processed thus far, prior to the `line` event 
         * being emitted. Once the `line` event has been emitted, this property will 
         * be an empty string. 
         * 
         * Be aware that modifying the value during the instance runtime may have 
         * unintended consequences if `rl.cursor` is not also controlled. 
         * 
         * **If not using a TTY stream for input, use the `'line'` event.** 
         * 
         * One possible use case would be as follows: 
         * 
         * ```js 
         * const values = ['lorem ipsum', 'dolor sit amet']; 
         * const rl = readline.createInterface(process.stdin); 
         * const showResults = debounce(() =&gt; { 
         *   console.log( 
         *     '\n', 
         *     values.filter((val) =&gt; val.startsWith(rl.line)).join(' '), 
         *   ); 
         * }, 300); 
         * process.stdin.on('keypress', (c, k) =&gt; { 
         *   showResults(); 
         * }); 
         * ``` 
         * </span><span class="s1">@since </span><span class="s0">v0.1.98 
         */</span>
        <span class="s1">readonly </span><span class="s3">line</span><span class="s1">: </span><span class="s2">string</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The cursor position relative to `rl.line`. 
         * 
         * This will track where the current cursor lands in the input string, when 
         * reading input from a TTY stream. The position of cursor determines the 
         * portion of the input string that will be modified as input is processed, 
         * as well as the column where the terminal caret will be rendered. 
         * </span><span class="s1">@since </span><span class="s0">v0.1.98 
         */</span>
        <span class="s1">readonly </span><span class="s3">cursor</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* NOTE: According to the documentation: 
         * 
         * &gt; Instances of the `readline.Interface` class are constructed using the 
         * &gt; `readline.createInterface()` method. 
         * 
         * </span><span class="s1">@see </span><span class="s2">https://nodejs.org/dist/latest-v20.x/docs/api/readline.html#class-interfaceconstructor</span>
         <span class="s0">*/</span>
        <span class="s1">protected constructor</span><span class="s3">(</span><span class="s2">input</span><span class="s1">: </span><span class="s2">NodeJS</span><span class="s3">.</span><span class="s2">ReadableStream</span><span class="s3">, </span><span class="s2">output</span><span class="s1">?: </span><span class="s2">NodeJS</span><span class="s3">.</span><span class="s2">WritableStream</span><span class="s3">, </span><span class="s2">completer</span><span class="s1">?: </span><span class="s2">Completer </span><span class="s1">| </span><span class="s2">AsyncCompleter</span><span class="s3">, </span><span class="s2">terminal</span><span class="s1">?: </span><span class="s2">boolean</span><span class="s3">);</span>
        <span class="s0">/**</span>
         <span class="s0">* NOTE: According to the documentation: 
         * 
         * &gt; Instances of the `readline.Interface` class are constructed using the 
         * &gt; `readline.createInterface()` method. 
         * 
         * </span><span class="s1">@see </span><span class="s2">https://nodejs.org/dist/latest-v20.x/docs/api/readline.html#class-interfaceconstructor</span>
         <span class="s0">*/</span>
        <span class="s1">protected constructor</span><span class="s3">(</span><span class="s2">options</span><span class="s1">: </span><span class="s2">ReadLineOptions</span><span class="s3">);</span>
        <span class="s0">/**</span>
         <span class="s0">* The `rl.getPrompt()` method returns the current prompt used by `rl.prompt()`. 
         * </span><span class="s1">@since </span><span class="s0">v15.3.0, v14.17.0 
         * </span><span class="s1">@return </span><span class="s0">the current prompt string 
         */</span>
        <span class="s3">getPrompt()</span><span class="s1">: </span><span class="s2">string</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The `rl.setPrompt()` method sets the prompt that will be written to `output`whenever `rl.prompt()` is called. 
         * </span><span class="s1">@since </span><span class="s0">v0.1.98 
         */</span>
        <span class="s3">setPrompt(</span><span class="s2">prompt</span><span class="s1">: </span><span class="s2">string</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The `rl.prompt()` method writes the `Interface` instances configured`prompt` to a new line in `output` in order to provide a user with a new 
         * location at which to provide input. 
         * 
         * When called, `rl.prompt()` will resume the `input` stream if it has been 
         * paused. 
         * 
         * If the `Interface` was created with `output` set to `null` or`undefined` the prompt is not written. 
         * </span><span class="s1">@since </span><span class="s0">v0.1.98 
         * </span><span class="s1">@param </span><span class="s2">preserveCursor </span><span class="s0">If `true`, prevents the cursor placement from being reset to `0`. 
         */</span>
        <span class="s3">prompt(</span><span class="s2">preserveCursor</span><span class="s1">?: </span><span class="s2">boolean</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The `rl.question()` method displays the `query` by writing it to the `output`, 
         * waits for user input to be provided on `input`, then invokes the `callback`function passing the provided input as the first argument. 
         * 
         * When called, `rl.question()` will resume the `input` stream if it has been 
         * paused. 
         * 
         * If the `Interface` was created with `output` set to `null` or`undefined` the `query` is not written. 
         * 
         * The `callback` function passed to `rl.question()` does not follow the typical 
         * pattern of accepting an `Error` object or `null` as the first argument. 
         * The `callback` is called with the provided answer as the only argument. 
         * 
         * An error will be thrown if calling `rl.question()` after `rl.close()`. 
         * 
         * Example usage: 
         * 
         * ```js 
         * rl.question('What is your favorite food? ', (answer) =&gt; { 
         *   console.log(`Oh, so your favorite food is ${answer}`); 
         * }); 
         * ``` 
         * 
         * Using an `AbortController` to cancel a question. 
         * 
         * ```js 
         * const ac = new AbortController(); 
         * const signal = ac.signal; 
         * 
         * rl.question('What is your favorite food? ', { signal }, (answer) =&gt; { 
         *   console.log(`Oh, so your favorite food is ${answer}`); 
         * }); 
         * 
         * signal.addEventListener('abort', () =&gt; { 
         *   console.log('The food question timed out'); 
         * }, { once: true }); 
         * 
         * setTimeout(() =&gt; ac.abort(), 10000); 
         * ``` 
         * </span><span class="s1">@since </span><span class="s0">v0.3.3 
         * </span><span class="s1">@param </span><span class="s2">query </span><span class="s0">A statement or query to write to `output`, prepended to the prompt. 
         * </span><span class="s1">@param </span><span class="s2">callback </span><span class="s0">A callback function that is invoked with the user's input in response to the `query`. 
         */</span>
        <span class="s3">question(</span><span class="s2">query</span><span class="s1">: </span><span class="s2">string</span><span class="s3">, </span><span class="s6">callback</span><span class="s1">: </span><span class="s3">(</span><span class="s2">answer</span><span class="s1">: </span><span class="s2">string</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s3">question(</span><span class="s2">query</span><span class="s1">: </span><span class="s2">string</span><span class="s3">, </span><span class="s2">options</span><span class="s1">: </span><span class="s2">Abortable</span><span class="s3">, </span><span class="s6">callback</span><span class="s1">: </span><span class="s3">(</span><span class="s2">answer</span><span class="s1">: </span><span class="s2">string</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The `rl.pause()` method pauses the `input` stream, allowing it to be resumed 
         * later if necessary. 
         * 
         * Calling `rl.pause()` does not immediately pause other events (including`'line'`) from being emitted by the `Interface` instance. 
         * </span><span class="s1">@since </span><span class="s0">v0.3.4 
         */</span>
        <span class="s3">pause()</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The `rl.resume()` method resumes the `input` stream if it has been paused. 
         * </span><span class="s1">@since </span><span class="s0">v0.3.4 
         */</span>
        <span class="s3">resume()</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The `rl.close()` method closes the `Interface` instance and 
         * relinquishes control over the `input` and `output` streams. When called, 
         * the `'close'` event will be emitted. 
         * 
         * Calling `rl.close()` does not immediately stop other events (including `'line'`) 
         * from being emitted by the `Interface` instance. 
         * </span><span class="s1">@since </span><span class="s0">v0.1.98 
         */</span>
        <span class="s3">close()</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The `rl.write()` method will write either `data` or a key sequence identified 
         * by `key` to the `output`. The `key` argument is supported only if `output` is 
         * a `TTY` text terminal. See `TTY keybindings` for a list of key 
         * combinations. 
         * 
         * If `key` is specified, `data` is ignored. 
         * 
         * When called, `rl.write()` will resume the `input` stream if it has been 
         * paused. 
         * 
         * If the `Interface` was created with `output` set to `null` or`undefined` the `data` and `key` are not written. 
         * 
         * ```js 
         * rl.write('Delete this!'); 
         * // Simulate Ctrl+U to delete the line written previously 
         * rl.write(null, { ctrl: true, name: 'u' }); 
         * ``` 
         * 
         * The `rl.write()` method will write the data to the `readline` `Interface`'s`input`_as if it were provided by the user_. 
         * </span><span class="s1">@since </span><span class="s0">v0.1.98 
         */</span>
        <span class="s3">write(</span><span class="s2">data</span><span class="s1">: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">Buffer</span><span class="s3">, </span><span class="s2">key</span><span class="s1">?: </span><span class="s2">Key</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s3">write(</span><span class="s2">data</span><span class="s1">: </span><span class="s2">undefined </span><span class="s1">| </span><span class="s2">null </span><span class="s1">| </span><span class="s2">string </span><span class="s1">| </span><span class="s2">Buffer</span><span class="s3">, </span><span class="s2">key</span><span class="s1">: </span><span class="s2">Key</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns the real position of the cursor in relation to the input 
         * prompt + string. Long input (wrapping) strings, as well as multiple 
         * line prompts are included in the calculations. 
         * </span><span class="s1">@since </span><span class="s0">v13.5.0, v12.16.0 
         */</span>
        <span class="s3">getCursorPos()</span><span class="s1">: </span><span class="s2">CursorPos</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* events.EventEmitter 
         * 1. close 
         * 2. line 
         * 3. pause 
         * 4. resume 
         * 5. SIGCONT 
         * 6. SIGINT 
         * 7. SIGTSTP 
         * 8. history 
         */</span>
        <span class="s3">addListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s2">string</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s1">...</span><span class="s2">args</span><span class="s1">: </span><span class="s2">any</span><span class="s3">[]) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">addListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'close'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">() </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">addListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'line'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">input</span><span class="s1">: </span><span class="s2">string</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">addListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'pause'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">() </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">addListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'resume'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">() </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">addListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'SIGCONT'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">() </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">addListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'SIGINT'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">() </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">addListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'SIGTSTP'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">() </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">addListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'history'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">history</span><span class="s1">: </span><span class="s2">string</span><span class="s3">[]) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">emit(</span><span class="s2">event</span><span class="s1">: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">symbol</span><span class="s3">, </span><span class="s1">...</span><span class="s2">args</span><span class="s1">: </span><span class="s2">any</span><span class="s3">[])</span><span class="s1">: </span><span class="s2">boolean</span><span class="s3">;</span>
        <span class="s3">emit(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'close'</span><span class="s3">)</span><span class="s1">: </span><span class="s2">boolean</span><span class="s3">;</span>
        <span class="s3">emit(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'line'</span><span class="s3">, </span><span class="s2">input</span><span class="s1">: </span><span class="s2">string</span><span class="s3">)</span><span class="s1">: </span><span class="s2">boolean</span><span class="s3">;</span>
        <span class="s3">emit(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'pause'</span><span class="s3">)</span><span class="s1">: </span><span class="s2">boolean</span><span class="s3">;</span>
        <span class="s3">emit(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'resume'</span><span class="s3">)</span><span class="s1">: </span><span class="s2">boolean</span><span class="s3">;</span>
        <span class="s3">emit(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'SIGCONT'</span><span class="s3">)</span><span class="s1">: </span><span class="s2">boolean</span><span class="s3">;</span>
        <span class="s3">emit(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'SIGINT'</span><span class="s3">)</span><span class="s1">: </span><span class="s2">boolean</span><span class="s3">;</span>
        <span class="s3">emit(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'SIGTSTP'</span><span class="s3">)</span><span class="s1">: </span><span class="s2">boolean</span><span class="s3">;</span>
        <span class="s3">emit(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'history'</span><span class="s3">, </span><span class="s2">history</span><span class="s1">: </span><span class="s2">string</span><span class="s3">[])</span><span class="s1">: </span><span class="s2">boolean</span><span class="s3">;</span>
        <span class="s3">on(</span><span class="s2">event</span><span class="s1">: </span><span class="s2">string</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s1">...</span><span class="s2">args</span><span class="s1">: </span><span class="s2">any</span><span class="s3">[]) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">on(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'close'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">() </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">on(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'line'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">input</span><span class="s1">: </span><span class="s2">string</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">on(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'pause'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">() </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">on(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'resume'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">() </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">on(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'SIGCONT'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">() </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">on(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'SIGINT'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">() </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">on(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'SIGTSTP'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">() </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">on(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'history'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">history</span><span class="s1">: </span><span class="s2">string</span><span class="s3">[]) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">once(</span><span class="s2">event</span><span class="s1">: </span><span class="s2">string</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s1">...</span><span class="s2">args</span><span class="s1">: </span><span class="s2">any</span><span class="s3">[]) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">once(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'close'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">() </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">once(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'line'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">input</span><span class="s1">: </span><span class="s2">string</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">once(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'pause'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">() </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">once(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'resume'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">() </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">once(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'SIGCONT'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">() </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">once(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'SIGINT'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">() </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">once(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'SIGTSTP'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">() </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">once(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'history'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">history</span><span class="s1">: </span><span class="s2">string</span><span class="s3">[]) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">prependListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s2">string</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s1">...</span><span class="s2">args</span><span class="s1">: </span><span class="s2">any</span><span class="s3">[]) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">prependListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'close'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">() </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">prependListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'line'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">input</span><span class="s1">: </span><span class="s2">string</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">prependListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'pause'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">() </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">prependListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'resume'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">() </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">prependListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'SIGCONT'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">() </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">prependListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'SIGINT'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">() </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">prependListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'SIGTSTP'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">() </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">prependListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'history'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">history</span><span class="s1">: </span><span class="s2">string</span><span class="s3">[]) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">prependOnceListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s2">string</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s1">...</span><span class="s2">args</span><span class="s1">: </span><span class="s2">any</span><span class="s3">[]) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">prependOnceListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'close'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">() </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">prependOnceListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'line'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">input</span><span class="s1">: </span><span class="s2">string</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">prependOnceListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'pause'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">() </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">prependOnceListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'resume'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">() </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">prependOnceListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'SIGCONT'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">() </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">prependOnceListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'SIGINT'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">() </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">prependOnceListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'SIGTSTP'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">() </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">prependOnceListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'history'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">history</span><span class="s1">: </span><span class="s2">string</span><span class="s3">[]) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">[</span><span class="s2">Symbol</span><span class="s3">.</span><span class="s2">asyncIterator</span><span class="s3">]()</span><span class="s1">: </span><span class="s2">AsyncIterableIterator</span><span class="s3">&lt;</span><span class="s2">string</span><span class="s3">&gt;;</span>
    <span class="s3">}</span>
    <span class="s1">export type </span><span class="s2">ReadLine </span><span class="s1">= </span><span class="s2">Interface</span><span class="s3">; </span><span class="s0">// type forwarded for backwards compatibility</span>
    <span class="s1">export type </span><span class="s2">Completer </span><span class="s1">= </span><span class="s3">(</span><span class="s2">line</span><span class="s1">: </span><span class="s2">string</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">CompleterResult</span><span class="s3">;</span>
    <span class="s1">export type </span><span class="s2">AsyncCompleter </span><span class="s1">= </span><span class="s3">(</span><span class="s2">line</span><span class="s1">: </span><span class="s2">string</span><span class="s3">, </span><span class="s6">callback</span><span class="s1">: </span><span class="s3">(</span><span class="s2">err</span><span class="s1">?: </span><span class="s2">null </span><span class="s1">| </span><span class="s2">Error</span><span class="s3">, </span><span class="s2">result</span><span class="s1">?: </span><span class="s2">CompleterResult</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">;</span>
    <span class="s1">export type </span><span class="s2">CompleterResult </span><span class="s1">= </span><span class="s3">[</span><span class="s2">string</span><span class="s3">[], </span><span class="s2">string</span><span class="s3">];</span>
    <span class="s1">export interface </span><span class="s2">ReadLineOptions </span><span class="s3">{</span>
        <span class="s3">input</span><span class="s1">: </span><span class="s2">NodeJS</span><span class="s3">.</span><span class="s2">ReadableStream</span><span class="s3">;</span>
        <span class="s3">output</span><span class="s1">?: </span><span class="s2">NodeJS</span><span class="s3">.</span><span class="s2">WritableStream </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s3">completer</span><span class="s1">?: </span><span class="s2">Completer </span><span class="s1">| </span><span class="s2">AsyncCompleter </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s3">terminal</span><span class="s1">?: </span><span class="s2">boolean </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">*  Initial list of history lines. This option makes sense 
         * only if `terminal` is set to `true` by the user or by an internal `output` 
         * check, otherwise the history caching mechanism is not initialized at all. 
         * </span><span class="s1">@default </span><span class="s2">[]</span>
         <span class="s0">*/</span>
        <span class="s3">history</span><span class="s1">?: </span><span class="s2">string</span><span class="s3">[] </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s3">historySize</span><span class="s1">?: </span><span class="s2">number </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s3">prompt</span><span class="s1">?: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s3">crlfDelay</span><span class="s1">?: </span><span class="s2">number </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If `true`, when a new input line added 
         * to the history list duplicates an older one, this removes the older line 
         * from the list. 
         * </span><span class="s1">@default </span><span class="s2">false</span>
         <span class="s0">*/</span>
        <span class="s3">removeHistoryDuplicates</span><span class="s1">?: </span><span class="s2">boolean </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s3">escapeCodeTimeout</span><span class="s1">?: </span><span class="s2">number </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s3">tabSize</span><span class="s1">?: </span><span class="s2">number </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s0">/**</span>
     <span class="s0">* The `readline.createInterface()` method creates a new `readline.Interface`instance. 
     * 
     * ```js 
     * const readline = require('node:readline'); 
     * const rl = readline.createInterface({ 
     *   input: process.stdin, 
     *   output: process.stdout, 
     * }); 
     * ``` 
     * 
     * Once the `readline.Interface` instance is created, the most common case is to 
     * listen for the `'line'` event: 
     * 
     * ```js 
     * rl.on('line', (line) =&gt; { 
     *   console.log(`Received: ${line}`); 
     * }); 
     * ``` 
     * 
     * If `terminal` is `true` for this instance then the `output` stream will get 
     * the best compatibility if it defines an `output.columns` property and emits 
     * a `'resize'` event on the `output` if or when the columns ever change 
     * (`process.stdout` does this automatically when it is a TTY). 
     * 
     * When creating a `readline.Interface` using `stdin` as input, the program 
     * will not terminate until it receives an [EOF character](https://en.wikipedia.org/wiki/End-of-file#EOF_character). To exit without 
     * waiting for user input, call `process.stdin.unref()`. 
     * </span><span class="s1">@since </span><span class="s0">v0.1.98 
     */</span>
    <span class="s1">export function </span><span class="s3">createInterface(</span><span class="s2">input</span><span class="s1">: </span><span class="s2">NodeJS</span><span class="s3">.</span><span class="s2">ReadableStream</span><span class="s3">, </span><span class="s2">output</span><span class="s1">?: </span><span class="s2">NodeJS</span><span class="s3">.</span><span class="s2">WritableStream</span><span class="s3">, </span><span class="s2">completer</span><span class="s1">?: </span><span class="s2">Completer </span><span class="s1">| </span><span class="s2">AsyncCompleter</span><span class="s3">, </span><span class="s2">terminal</span><span class="s1">?: </span><span class="s2">boolean</span><span class="s3">)</span><span class="s1">: </span><span class="s2">Interface</span><span class="s3">;</span>
    <span class="s1">export function </span><span class="s3">createInterface(</span><span class="s2">options</span><span class="s1">: </span><span class="s2">ReadLineOptions</span><span class="s3">)</span><span class="s1">: </span><span class="s2">Interface</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The `readline.emitKeypressEvents()` method causes the given `Readable` stream to begin emitting `'keypress'` events corresponding to received input. 
     * 
     * Optionally, `interface` specifies a `readline.Interface` instance for which 
     * autocompletion is disabled when copy-pasted input is detected. 
     * 
     * If the `stream` is a `TTY`, then it must be in raw mode. 
     * 
     * This is automatically called by any readline instance on its `input` if the`input` is a terminal. Closing the `readline` instance does not stop 
     * the `input` from emitting `'keypress'` events. 
     * 
     * ```js 
     * readline.emitKeypressEvents(process.stdin); 
     * if (process.stdin.isTTY) 
     *   process.stdin.setRawMode(true); 
     * ``` 
     * 
     * ## Example: Tiny CLI 
     * 
     * The following example illustrates the use of `readline.Interface` class to 
     * implement a small command-line interface: 
     * 
     * ```js 
     * const readline = require('node:readline'); 
     * const rl = readline.createInterface({ 
     *   input: process.stdin, 
     *   output: process.stdout, 
     *   prompt: 'OHAI&gt; ', 
     * }); 
     * 
     * rl.prompt(); 
     * 
     * rl.on('line', (line) =&gt; { 
     *   switch (line.trim()) { 
     *     case 'hello': 
     *       console.log('world!'); 
     *       break; 
     *     default: 
     *       console.log(`Say what? I might have heard '${line.trim()}'`); 
     *       break; 
     *   } 
     *   rl.prompt(); 
     * }).on('close', () =&gt; { 
     *   console.log('Have a great day!'); 
     *   process.exit(0); 
     * }); 
     * ``` 
     * 
     * ## Example: Read file stream line-by-Line 
     * 
     * A common use case for `readline` is to consume an input file one line at a 
     * time. The easiest way to do so is leveraging the `fs.ReadStream` API as 
     * well as a `for await...of` loop: 
     * 
     * ```js 
     * const fs = require('node:fs'); 
     * const readline = require('node:readline'); 
     * 
     * async function processLineByLine() { 
     *   const fileStream = fs.createReadStream('input.txt'); 
     * 
     *   const rl = readline.createInterface({ 
     *     input: fileStream, 
     *     crlfDelay: Infinity, 
     *   }); 
     *   // Note: we use the crlfDelay option to recognize all instances of CR LF 
     *   // ('\r\n') in input.txt as a single line break. 
     * 
     *   for await (const line of rl) { 
     *     // Each line in input.txt will be successively available here as `line`. 
     *     console.log(`Line from file: ${line}`); 
     *   } 
     * } 
     * 
     * processLineByLine(); 
     * ``` 
     * 
     * Alternatively, one could use the `'line'` event: 
     * 
     * ```js 
     * const fs = require('node:fs'); 
     * const readline = require('node:readline'); 
     * 
     * const rl = readline.createInterface({ 
     *   input: fs.createReadStream('sample.txt'), 
     *   crlfDelay: Infinity, 
     * }); 
     * 
     * rl.on('line', (line) =&gt; { 
     *   console.log(`Line from file: ${line}`); 
     * }); 
     * ``` 
     * 
     * Currently, `for await...of` loop can be a bit slower. If `async` / `await`flow and speed are both essential, a mixed approach can be applied: 
     * 
     * ```js 
     * const { once } = require('node:events'); 
     * const { createReadStream } = require('node:fs'); 
     * const { createInterface } = require('node:readline'); 
     * 
     * (async function processLineByLine() { 
     *   try { 
     *     const rl = createInterface({ 
     *       input: createReadStream('big-file.txt'), 
     *       crlfDelay: Infinity, 
     *     }); 
     * 
     *     rl.on('line', (line) =&gt; { 
     *       // Process the line. 
     *     }); 
     * 
     *     await once(rl, 'close'); 
     * 
     *     console.log('File processed.'); 
     *   } catch (err) { 
     *     console.error(err); 
     *   } 
     * })(); 
     * ``` 
     * </span><span class="s1">@since </span><span class="s0">v0.7.7 
     */</span>
    <span class="s1">export function </span><span class="s3">emitKeypressEvents(</span><span class="s2">stream</span><span class="s1">: </span><span class="s2">NodeJS</span><span class="s3">.</span><span class="s2">ReadableStream</span><span class="s3">, </span><span class="s2">readlineInterface</span><span class="s1">?: </span><span class="s2">Interface</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
    <span class="s1">export type </span><span class="s2">Direction </span><span class="s1">= </span><span class="s3">-</span><span class="s7">1 </span><span class="s1">| </span><span class="s7">0 </span><span class="s1">| </span><span class="s7">1</span><span class="s3">;</span>
    <span class="s1">export interface </span><span class="s2">CursorPos </span><span class="s3">{</span>
        <span class="s3">rows</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s3">cols</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s0">/**</span>
     <span class="s0">* The `readline.clearLine()` method clears current line of given `TTY` stream 
     * in a specified direction identified by `dir`. 
     * </span><span class="s1">@since </span><span class="s0">v0.7.7 
     * </span><span class="s1">@param </span><span class="s2">callback </span><span class="s0">Invoked once the operation completes. 
     * </span><span class="s1">@return </span><span class="s0">`false` if `stream` wishes for the calling code to wait for the `'drain'` event to be emitted before continuing to write additional data; otherwise `true`. 
     */</span>
    <span class="s1">export function </span><span class="s3">clearLine(</span><span class="s2">stream</span><span class="s1">: </span><span class="s2">NodeJS</span><span class="s3">.</span><span class="s2">WritableStream</span><span class="s3">, </span><span class="s2">dir</span><span class="s1">: </span><span class="s2">Direction</span><span class="s3">, </span><span class="s6">callback</span><span class="s1">?: </span><span class="s3">() </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">boolean</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The `readline.clearScreenDown()` method clears the given `TTY` stream from 
     * the current position of the cursor down. 
     * </span><span class="s1">@since </span><span class="s0">v0.7.7 
     * </span><span class="s1">@param </span><span class="s2">callback </span><span class="s0">Invoked once the operation completes. 
     * </span><span class="s1">@return </span><span class="s0">`false` if `stream` wishes for the calling code to wait for the `'drain'` event to be emitted before continuing to write additional data; otherwise `true`. 
     */</span>
    <span class="s1">export function </span><span class="s3">clearScreenDown(</span><span class="s2">stream</span><span class="s1">: </span><span class="s2">NodeJS</span><span class="s3">.</span><span class="s2">WritableStream</span><span class="s3">, </span><span class="s6">callback</span><span class="s1">?: </span><span class="s3">() </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">boolean</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The `readline.cursorTo()` method moves cursor to the specified position in a 
     * given `TTY` `stream`. 
     * </span><span class="s1">@since </span><span class="s0">v0.7.7 
     * </span><span class="s1">@param </span><span class="s2">callback </span><span class="s0">Invoked once the operation completes. 
     * </span><span class="s1">@return </span><span class="s0">`false` if `stream` wishes for the calling code to wait for the `'drain'` event to be emitted before continuing to write additional data; otherwise `true`. 
     */</span>
    <span class="s1">export function </span><span class="s3">cursorTo(</span><span class="s2">stream</span><span class="s1">: </span><span class="s2">NodeJS</span><span class="s3">.</span><span class="s2">WritableStream</span><span class="s3">, </span><span class="s2">x</span><span class="s1">: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">y</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">, </span><span class="s6">callback</span><span class="s1">?: </span><span class="s3">() </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">boolean</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The `readline.moveCursor()` method moves the cursor _relative_ to its current 
     * position in a given `TTY` `stream`. 
     * </span><span class="s1">@since </span><span class="s0">v0.7.7 
     * </span><span class="s1">@param </span><span class="s2">callback </span><span class="s0">Invoked once the operation completes. 
     * </span><span class="s1">@return </span><span class="s0">`false` if `stream` wishes for the calling code to wait for the `'drain'` event to be emitted before continuing to write additional data; otherwise `true`. 
     */</span>
    <span class="s1">export function </span><span class="s3">moveCursor(</span><span class="s2">stream</span><span class="s1">: </span><span class="s2">NodeJS</span><span class="s3">.</span><span class="s2">WritableStream</span><span class="s3">, </span><span class="s2">dx</span><span class="s1">: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">dy</span><span class="s1">: </span><span class="s2">number</span><span class="s3">, </span><span class="s6">callback</span><span class="s1">?: </span><span class="s3">() </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">boolean</span><span class="s3">;</span>
<span class="s3">}</span>
<span class="s1">declare module </span><span class="s4">'node:readline' </span><span class="s3">{</span>
    <span class="s1">export </span><span class="s5">* </span><span class="s1">from </span><span class="s4">'readline'</span><span class="s3">;</span>
<span class="s3">}</span>
</pre>
</body>
</html>
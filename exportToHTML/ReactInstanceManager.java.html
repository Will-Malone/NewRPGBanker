<html>
<head>
<title>ReactInstanceManager.java</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #629755; font-weight: bold; font-style: italic;}
.s5 { color: #77b767; font-style: italic;}
.s6 { color: #6a8759;}
.s7 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
ReactInstanceManager.java</font>
</center></td></tr></table>
<pre><span class="s0">/* 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>

<span class="s2">package </span><span class="s1">com.facebook.react</span><span class="s2">;</span>

<span class="s2">import static </span><span class="s1">com.facebook.infer.annotation.ThreadConfined.UI</span><span class="s2">;</span>
<span class="s2">import static </span><span class="s1">com.facebook.react.bridge.ReactMarkerConstants.ATTACH_MEASURED_ROOT_VIEWS_END</span><span class="s2">;</span>
<span class="s2">import static </span><span class="s1">com.facebook.react.bridge.ReactMarkerConstants.ATTACH_MEASURED_ROOT_VIEWS_START</span><span class="s2">;</span>
<span class="s2">import static </span><span class="s1">com.facebook.react.bridge.ReactMarkerConstants.BUILD_NATIVE_MODULE_REGISTRY_END</span><span class="s2">;</span>
<span class="s2">import static </span><span class="s1">com.facebook.react.bridge.ReactMarkerConstants.BUILD_NATIVE_MODULE_REGISTRY_START</span><span class="s2">;</span>
<span class="s2">import static </span><span class="s1">com.facebook.react.bridge.ReactMarkerConstants.CHANGE_THREAD_PRIORITY</span><span class="s2">;</span>
<span class="s2">import static </span><span class="s1">com.facebook.react.bridge.ReactMarkerConstants.CREATE_CATALYST_INSTANCE_END</span><span class="s2">;</span>
<span class="s2">import static </span><span class="s1">com.facebook.react.bridge.ReactMarkerConstants.CREATE_CATALYST_INSTANCE_START</span><span class="s2">;</span>
<span class="s2">import static </span><span class="s1">com.facebook.react.bridge.ReactMarkerConstants.CREATE_REACT_CONTEXT_START</span><span class="s2">;</span>
<span class="s2">import static </span><span class="s1">com.facebook.react.bridge.ReactMarkerConstants.CREATE_VIEW_MANAGERS_END</span><span class="s2">;</span>
<span class="s2">import static </span><span class="s1">com.facebook.react.bridge.ReactMarkerConstants.CREATE_VIEW_MANAGERS_START</span><span class="s2">;</span>
<span class="s2">import static </span><span class="s1">com.facebook.react.bridge.ReactMarkerConstants.PRE_SETUP_REACT_CONTEXT_END</span><span class="s2">;</span>
<span class="s2">import static </span><span class="s1">com.facebook.react.bridge.ReactMarkerConstants.PRE_SETUP_REACT_CONTEXT_START</span><span class="s2">;</span>
<span class="s2">import static </span><span class="s1">com.facebook.react.bridge.ReactMarkerConstants.PROCESS_PACKAGES_END</span><span class="s2">;</span>
<span class="s2">import static </span><span class="s1">com.facebook.react.bridge.ReactMarkerConstants.PROCESS_PACKAGES_START</span><span class="s2">;</span>
<span class="s2">import static </span><span class="s1">com.facebook.react.bridge.ReactMarkerConstants.REACT_CONTEXT_THREAD_END</span><span class="s2">;</span>
<span class="s2">import static </span><span class="s1">com.facebook.react.bridge.ReactMarkerConstants.REACT_CONTEXT_THREAD_START</span><span class="s2">;</span>
<span class="s2">import static </span><span class="s1">com.facebook.react.bridge.ReactMarkerConstants.SETUP_REACT_CONTEXT_END</span><span class="s2">;</span>
<span class="s2">import static </span><span class="s1">com.facebook.react.bridge.ReactMarkerConstants.SETUP_REACT_CONTEXT_START</span><span class="s2">;</span>
<span class="s2">import static </span><span class="s1">com.facebook.react.bridge.ReactMarkerConstants.VM_INIT</span><span class="s2">;</span>
<span class="s2">import static </span><span class="s1">com.facebook.react.uimanager.common.UIManagerType.FABRIC</span><span class="s2">;</span>
<span class="s2">import static </span><span class="s1">com.facebook.systrace.Systrace.TRACE_TAG_REACT_APPS</span><span class="s2">;</span>
<span class="s2">import static </span><span class="s1">com.facebook.systrace.Systrace.TRACE_TAG_REACT_JAVA_BRIDGE</span><span class="s2">;</span>
<span class="s2">import static </span><span class="s1">com.facebook.systrace.Systrace.TRACE_TAG_REACT_JS_VM_CALLS</span><span class="s2">;</span>

<span class="s2">import </span><span class="s1">android.app.Activity</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.content.Context</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.content.Intent</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.content.res.Configuration</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.net.Uri</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.nfc.NfcAdapter</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.os.Bundle</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.os.Process</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.view.View</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.view.ViewGroup</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">androidx.annotation.Nullable</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">androidx.core.view.ViewCompat</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.common.logging.FLog</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.debug.holder.PrinterHolder</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.debug.tags.ReactDebugOverlayTags</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.infer.annotation.Assertions</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.infer.annotation.ThreadConfined</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.infer.annotation.ThreadSafe</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.Arguments</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.CatalystInstance</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.CatalystInstanceImpl</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.JSBundleLoader</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.JSExceptionHandler</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.JSIModulePackage</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.JSIModuleType</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.JavaJSExecutor</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.JavaScriptExecutor</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.JavaScriptExecutorFactory</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.NativeModuleRegistry</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.NotThreadSafeBridgeIdleDebugListener</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.ProxyJavaScriptExecutor</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.ReactApplicationContext</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.ReactContext</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.ReactCxxErrorHandler</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.ReactMarker</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.ReactMarkerConstants</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.ReactNoCrashSoftException</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.ReactSoftExceptionLogger</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.UIManager</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.UiThreadUtil</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.WritableNativeMap</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.queue.ReactQueueConfigurationSpec</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.common.LifecycleState</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.common.ReactConstants</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.common.SurfaceDelegateFactory</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.common.annotations.VisibleForTesting</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.config.ReactFeatureFlags</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.devsupport.DevSupportManagerFactory</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.devsupport.ReactInstanceDevHelper</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.devsupport.interfaces.DevBundleDownloadListener</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.devsupport.interfaces.DevLoadingViewManager</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.devsupport.interfaces.DevSupportManager</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.devsupport.interfaces.PackagerStatusCallback</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.devsupport.interfaces.RedBoxHandler</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.modules.appearance.AppearanceModule</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.modules.appregistry.AppRegistry</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.modules.core.DefaultHardwareBackBtnHandler</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.modules.core.DeviceEventManagerModule</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.modules.core.ReactChoreographer</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.modules.debug.interfaces.DeveloperSettings</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.modules.fabric.ReactFabric</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.packagerconnection.RequestHandler</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.surface.ReactStage</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.turbomodule.core.TurboModuleManager</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.turbomodule.core.TurboModuleManagerDelegate</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.turbomodule.core.interfaces.TurboModuleRegistry</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.DisplayMetricsHolder</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.ReactRoot</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.UIManagerHelper</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.ViewManager</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.views.imagehelper.ResourceDrawableIdHelper</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.soloader.SoLoader</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.systrace.Systrace</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.systrace.SystraceMessage</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.lang.reflect.Method</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.ArrayList</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.Collection</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.Collections</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.HashSet</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.List</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.Map</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.Set</span><span class="s2">;</span>

<span class="s3">/**</span>
 <span class="s3">* This class is managing instances of {</span><span class="s4">@link </span><span class="s3">CatalystInstance}. It exposes a way to configure</span>
 <span class="s3">* catalyst instance using {</span><span class="s4">@link </span><span class="s3">ReactPackage} and keeps track of the lifecycle of that instance.</span>
 <span class="s3">* It also sets up connection between the instance and developers support functionality of the</span>
 <span class="s3">* framework.</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">An instance of this manager is required to start JS application in {</span><span class="s4">@link </span><span class="s3">ReactRootView} (see</span>
 <span class="s3">* {</span><span class="s4">@link </span><span class="s3">ReactRootView#startReactApplication} for more info).</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">The lifecycle of the instance of {</span><span class="s4">@link </span><span class="s3">ReactInstanceManager} should be bound to the activity</span>
 <span class="s3">* that owns the {</span><span class="s4">@link </span><span class="s3">ReactRootView} that is used to render react application using this instance</span>
 <span class="s3">* manager (see {</span><span class="s4">@link </span><span class="s3">ReactRootView#startReactApplication}). It's required to pass owning</span>
 <span class="s3">* activity's lifecycle events to the instance manager (see {</span><span class="s4">@link </span><span class="s3">#onHostPause}, {</span><span class="s4">@link</span>
 <span class="s3">* #onHostDestroy} and {</span><span class="s4">@link </span><span class="s3">#onHostResume}).</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">To instantiate an instance of this class use {</span><span class="s4">@link </span><span class="s3">#builder}.</span>
 <span class="s3">*/</span>
<span class="s1">@ThreadSafe</span>
<span class="s2">public class </span><span class="s1">ReactInstanceManager {</span>

  <span class="s2">private static final </span><span class="s1">String TAG = ReactInstanceManager.</span><span class="s2">class</span><span class="s1">.getSimpleName()</span><span class="s2">;</span>

  <span class="s3">/**</span>
   <span class="s3">* Listener interface for react instance events. This class extends {</span><span class="s4">@Link</span>
   <span class="s3">* com.facebook.react.ReactInstanceEventListener} as a mitigation for both bridgeless and OSS</span>
   <span class="s3">* compatibility: We create a separate ReactInstanceEventListener class to remove dependency on</span>
   <span class="s3">* ReactInstanceManager which is a bridge-specific class, but in the mean time we have to keep</span>
   <span class="s3">* ReactInstanceManager.ReactInstanceEventListener so OSS won't break.</span>
   <span class="s3">*/</span>
  <span class="s1">@Deprecated</span>
  <span class="s2">public interface </span><span class="s1">ReactInstanceEventListener</span>
      <span class="s2">extends </span><span class="s1">com.facebook.react.ReactInstanceEventListener {}</span>

  <span class="s2">private final </span><span class="s1">Set&lt;ReactRoot&gt; mAttachedReactRoots =</span>
      <span class="s1">Collections.synchronizedSet(</span><span class="s2">new </span><span class="s1">HashSet&lt;ReactRoot&gt;())</span><span class="s2">;</span>

  <span class="s2">private volatile </span><span class="s1">LifecycleState mLifecycleState</span><span class="s2">;</span>

  <span class="s2">private </span><span class="s1">@Nullable @ThreadConfined(UI) ReactContextInitParams mPendingReactContextInitParams</span><span class="s2">;</span>
  <span class="s2">private volatile </span><span class="s1">@Nullable Thread mCreateReactContextThread</span><span class="s2">;</span>
  <span class="s0">/* accessed from any thread */</span>
  <span class="s2">private final </span><span class="s1">JavaScriptExecutorFactory mJavaScriptExecutorFactory</span><span class="s2">;</span>

  <span class="s0">// See {@code ReactInstanceManagerBuilder} for description of all flags here.</span>
  <span class="s2">private </span><span class="s1">@Nullable Collection&lt;String&gt; mViewManagerNames = </span><span class="s2">null;</span>
  <span class="s2">private final </span><span class="s1">@Nullable JSBundleLoader mBundleLoader</span><span class="s2">;</span>
  <span class="s2">private final </span><span class="s1">@Nullable String mJSMainModulePath</span><span class="s2">; </span><span class="s0">/* path to JS bundle root on Metro */</span>
  <span class="s2">private final </span><span class="s1">List&lt;ReactPackage&gt; mPackages</span><span class="s2">;</span>
  <span class="s2">private final </span><span class="s1">DevSupportManager mDevSupportManager</span><span class="s2">;</span>
  <span class="s2">private final boolean </span><span class="s1">mUseDeveloperSupport</span><span class="s2">;</span>
  <span class="s2">private final boolean </span><span class="s1">mRequireActivity</span><span class="s2">;</span>
  <span class="s2">private final </span><span class="s1">@Nullable NotThreadSafeBridgeIdleDebugListener mBridgeIdleDebugListener</span><span class="s2">;</span>
  <span class="s2">private final </span><span class="s1">Object mReactContextLock = </span><span class="s2">new </span><span class="s1">Object()</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable </span><span class="s2">volatile </span><span class="s1">ReactContext mCurrentReactContext</span><span class="s2">;</span>
  <span class="s2">private final </span><span class="s1">Context mApplicationContext</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable @ThreadConfined(UI) DefaultHardwareBackBtnHandler mDefaultBackButtonImpl</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable Activity mCurrentActivity</span><span class="s2">;</span>
  <span class="s2">private final </span><span class="s1">Collection&lt;com.facebook.react.ReactInstanceEventListener&gt;</span>
      <span class="s1">mReactInstanceEventListeners =</span>
          <span class="s1">Collections.synchronizedList(</span>
              <span class="s2">new </span><span class="s1">ArrayList&lt;com.facebook.react.ReactInstanceEventListener&gt;())</span><span class="s2">;</span>
  <span class="s0">// Identifies whether the instance manager is or soon will be initialized (on background thread)</span>
  <span class="s2">private volatile boolean </span><span class="s1">mHasStartedCreatingInitialContext = </span><span class="s2">false;</span>
  <span class="s0">// Identifies whether the instance manager destroy function is in process,</span>
  <span class="s0">// while true any spawned create thread should wait for proper clean up before initializing</span>
  <span class="s2">private volatile </span><span class="s1">Boolean mHasStartedDestroying = </span><span class="s2">false;</span>
  <span class="s2">private final </span><span class="s1">MemoryPressureRouter mMemoryPressureRouter</span><span class="s2">;</span>
  <span class="s2">private final </span><span class="s1">@Nullable JSExceptionHandler mJSExceptionHandler</span><span class="s2">;</span>
  <span class="s2">private final </span><span class="s1">@Nullable JSIModulePackage mJSIModulePackage</span><span class="s2">;</span>
  <span class="s2">private final </span><span class="s1">@Nullable ReactPackageTurboModuleManagerDelegate.Builder mTMMDelegateBuilder</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">List&lt;ViewManager&gt; mViewManagers</span><span class="s2">;</span>
  <span class="s2">private boolean </span><span class="s1">mUseFallbackBundle = </span><span class="s2">false;</span>

  <span class="s2">private class </span><span class="s1">ReactContextInitParams {</span>
    <span class="s2">private final </span><span class="s1">JavaScriptExecutorFactory mJsExecutorFactory</span><span class="s2">;</span>
    <span class="s2">private final </span><span class="s1">JSBundleLoader mJsBundleLoader</span><span class="s2">;</span>

    <span class="s2">public </span><span class="s1">ReactContextInitParams(</span>
        <span class="s1">JavaScriptExecutorFactory jsExecutorFactory</span><span class="s2">, </span><span class="s1">JSBundleLoader jsBundleLoader) {</span>
      <span class="s1">mJsExecutorFactory = Assertions.assertNotNull(jsExecutorFactory)</span><span class="s2">;</span>
      <span class="s1">mJsBundleLoader = Assertions.assertNotNull(jsBundleLoader)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">public </span><span class="s1">JavaScriptExecutorFactory getJsExecutorFactory() {</span>
      <span class="s2">return </span><span class="s1">mJsExecutorFactory</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">public </span><span class="s1">JSBundleLoader getJsBundleLoader() {</span>
      <span class="s2">return </span><span class="s1">mJsBundleLoader</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">/** Creates a builder that is capable of creating an instance of {</span><span class="s4">@link </span><span class="s3">ReactInstanceManager}. */</span>
  <span class="s2">public static </span><span class="s1">ReactInstanceManagerBuilder builder() {</span>
    <span class="s2">return new </span><span class="s1">ReactInstanceManagerBuilder()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">/* package */ </span><span class="s1">ReactInstanceManager(</span>
      <span class="s1">Context applicationContext</span><span class="s2">,</span>
      <span class="s1">@Nullable Activity currentActivity</span><span class="s2">,</span>
      <span class="s1">@Nullable DefaultHardwareBackBtnHandler defaultHardwareBackBtnHandler</span><span class="s2">,</span>
      <span class="s1">JavaScriptExecutorFactory javaScriptExecutorFactory</span><span class="s2">,</span>
      <span class="s1">@Nullable JSBundleLoader bundleLoader</span><span class="s2">,</span>
      <span class="s1">@Nullable String jsMainModulePath</span><span class="s2">,</span>
      <span class="s1">List&lt;ReactPackage&gt; packages</span><span class="s2">,</span>
      <span class="s2">boolean </span><span class="s1">useDeveloperSupport</span><span class="s2">,</span>
      <span class="s1">DevSupportManagerFactory devSupportManagerFactory</span><span class="s2">,</span>
      <span class="s2">boolean </span><span class="s1">requireActivity</span><span class="s2">,</span>
      <span class="s1">@Nullable NotThreadSafeBridgeIdleDebugListener bridgeIdleDebugListener</span><span class="s2">,</span>
      <span class="s1">LifecycleState initialLifecycleState</span><span class="s2">,</span>
      <span class="s1">JSExceptionHandler jSExceptionHandler</span><span class="s2">,</span>
      <span class="s1">@Nullable RedBoxHandler redBoxHandler</span><span class="s2">,</span>
      <span class="s2">boolean </span><span class="s1">lazyViewManagersEnabled</span><span class="s2">,</span>
      <span class="s1">@Nullable DevBundleDownloadListener devBundleDownloadListener</span><span class="s2">,</span>
      <span class="s2">int </span><span class="s1">minNumShakes</span><span class="s2">,</span>
      <span class="s2">int </span><span class="s1">minTimeLeftInFrameForNonBatchedOperationMs</span><span class="s2">,</span>
      <span class="s1">@Nullable JSIModulePackage jsiModulePackage</span><span class="s2">,</span>
      <span class="s1">@Nullable Map&lt;String</span><span class="s2">, </span><span class="s1">RequestHandler&gt; customPackagerCommandHandlers</span><span class="s2">,</span>
      <span class="s1">@Nullable ReactPackageTurboModuleManagerDelegate.Builder tmmDelegateBuilder</span><span class="s2">,</span>
      <span class="s1">@Nullable SurfaceDelegateFactory surfaceDelegateFactory</span><span class="s2">,</span>
      <span class="s1">@Nullable DevLoadingViewManager devLoadingViewManager) {</span>
    <span class="s1">FLog.d(TAG</span><span class="s2">, </span><span class="s6">&quot;ReactInstanceManager.ctor()&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">initializeSoLoaderIfNecessary(applicationContext)</span><span class="s2">;</span>

    <span class="s1">DisplayMetricsHolder.initDisplayMetricsIfNotInitialized(applicationContext)</span><span class="s2">;</span>

    <span class="s0">// See {@code ReactInstanceManagerBuilder} for description of all flags here.</span>
    <span class="s1">mApplicationContext = applicationContext</span><span class="s2">;</span>
    <span class="s1">mCurrentActivity = currentActivity</span><span class="s2">;</span>
    <span class="s1">mDefaultBackButtonImpl = defaultHardwareBackBtnHandler</span><span class="s2">;</span>
    <span class="s1">mJavaScriptExecutorFactory = javaScriptExecutorFactory</span><span class="s2">;</span>
    <span class="s1">mBundleLoader = bundleLoader</span><span class="s2">;</span>
    <span class="s1">mJSMainModulePath = jsMainModulePath</span><span class="s2">;</span>
    <span class="s1">mPackages = </span><span class="s2">new </span><span class="s1">ArrayList&lt;&gt;()</span><span class="s2">;</span>
    <span class="s1">mUseDeveloperSupport = useDeveloperSupport</span><span class="s2">;</span>
    <span class="s1">mRequireActivity = requireActivity</span><span class="s2">;</span>
    <span class="s1">Systrace.beginSection(</span>
        <span class="s1">Systrace.TRACE_TAG_REACT_JAVA_BRIDGE</span><span class="s2">, </span><span class="s6">&quot;ReactInstanceManager.initDevSupportManager&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">mDevSupportManager =</span>
        <span class="s1">devSupportManagerFactory.create(</span>
            <span class="s1">applicationContext</span><span class="s2">,</span>
            <span class="s1">createDevHelperInterface()</span><span class="s2">,</span>
            <span class="s1">mJSMainModulePath</span><span class="s2">,</span>
            <span class="s1">useDeveloperSupport</span><span class="s2">,</span>
            <span class="s1">redBoxHandler</span><span class="s2">,</span>
            <span class="s1">devBundleDownloadListener</span><span class="s2">,</span>
            <span class="s1">minNumShakes</span><span class="s2">,</span>
            <span class="s1">customPackagerCommandHandlers</span><span class="s2">,</span>
            <span class="s1">surfaceDelegateFactory</span><span class="s2">,</span>
            <span class="s1">devLoadingViewManager)</span><span class="s2">;</span>
    <span class="s1">Systrace.endSection(TRACE_TAG_REACT_JAVA_BRIDGE)</span><span class="s2">;</span>
    <span class="s1">mBridgeIdleDebugListener = bridgeIdleDebugListener</span><span class="s2">;</span>
    <span class="s1">mLifecycleState = initialLifecycleState</span><span class="s2">;</span>
    <span class="s1">mMemoryPressureRouter = </span><span class="s2">new </span><span class="s1">MemoryPressureRouter(applicationContext)</span><span class="s2">;</span>
    <span class="s1">mJSExceptionHandler = jSExceptionHandler</span><span class="s2">;</span>
    <span class="s1">mTMMDelegateBuilder = tmmDelegateBuilder</span><span class="s2">;</span>
    <span class="s2">synchronized </span><span class="s1">(mPackages) {</span>
      <span class="s1">PrinterHolder.getPrinter()</span>
          <span class="s1">.logMessage(ReactDebugOverlayTags.RN_CORE</span><span class="s2">, </span><span class="s6">&quot;RNCore: Use Split Packages&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">mPackages.add(</span>
          <span class="s2">new </span><span class="s1">CoreModulesPackage(</span>
              <span class="s2">this,</span>
              <span class="s2">new </span><span class="s1">DefaultHardwareBackBtnHandler() {</span>
                <span class="s1">@Override</span>
                <span class="s2">public void </span><span class="s1">invokeDefaultOnBackPressed() {</span>
                  <span class="s1">ReactInstanceManager.</span><span class="s2">this</span><span class="s1">.invokeDefaultOnBackPressed()</span><span class="s2">;</span>
                <span class="s1">}</span>
              <span class="s1">}</span><span class="s2">,</span>
              <span class="s1">lazyViewManagersEnabled</span><span class="s2">,</span>
              <span class="s1">minTimeLeftInFrameForNonBatchedOperationMs))</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(mUseDeveloperSupport) {</span>
        <span class="s1">mPackages.add(</span><span class="s2">new </span><span class="s1">DebugCorePackage())</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s1">mPackages.addAll(packages)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">mJSIModulePackage = jsiModulePackage</span><span class="s2">;</span>

    <span class="s0">// Instantiate ReactChoreographer in UI thread.</span>
    <span class="s1">ReactChoreographer.initialize()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(mUseDeveloperSupport) {</span>
      <span class="s1">mDevSupportManager.startInspector()</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">registerCxxErrorHandlerFunc()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private </span><span class="s1">ReactInstanceDevHelper createDevHelperInterface() {</span>
    <span class="s2">return new </span><span class="s1">ReactInstanceDevHelper() {</span>
      <span class="s1">@Override</span>
      <span class="s2">public void </span><span class="s1">onReloadWithJSDebugger(JavaJSExecutor.Factory jsExecutorFactory) {</span>
        <span class="s1">ReactInstanceManager.</span><span class="s2">this</span><span class="s1">.onReloadWithJSDebugger(jsExecutorFactory)</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s1">@Override</span>
      <span class="s2">public void </span><span class="s1">onJSBundleLoadedFromServer() {</span>
        <span class="s1">ReactInstanceManager.</span><span class="s2">this</span><span class="s1">.onJSBundleLoadedFromServer()</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s1">@Override</span>
      <span class="s2">public void </span><span class="s1">toggleElementInspector() {</span>
        <span class="s1">ReactInstanceManager.</span><span class="s2">this</span><span class="s1">.toggleElementInspector()</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s1">@Override</span>
      <span class="s2">public </span><span class="s1">@Nullable Activity getCurrentActivity() {</span>
        <span class="s2">return </span><span class="s1">ReactInstanceManager.</span><span class="s2">this</span><span class="s1">.mCurrentActivity</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s1">@Override</span>
      <span class="s2">public </span><span class="s1">JavaScriptExecutorFactory getJavaScriptExecutorFactory() {</span>
        <span class="s2">return </span><span class="s1">ReactInstanceManager.</span><span class="s2">this</span><span class="s1">.getJSExecutorFactory()</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s1">@Override</span>
      <span class="s2">public </span><span class="s1">@Nullable View createRootView(String appKey) {</span>
        <span class="s1">Activity currentActivity = getCurrentActivity()</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(currentActivity != </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">ReactRootView rootView = </span><span class="s2">new </span><span class="s1">ReactRootView(currentActivity)</span><span class="s2">;</span>
          <span class="s1">rootView.setIsFabric(ReactFeatureFlags.enableFabricRenderer)</span><span class="s2">;</span>
          <span class="s1">rootView.startReactApplication(ReactInstanceManager.</span><span class="s2">this, </span><span class="s1">appKey</span><span class="s2">, null</span><span class="s1">)</span><span class="s2">;</span>
          <span class="s2">return </span><span class="s1">rootView</span><span class="s2">;</span>
        <span class="s1">}</span>

        <span class="s2">return null;</span>
      <span class="s1">}</span>

      <span class="s1">@Override</span>
      <span class="s2">public void </span><span class="s1">destroyRootView(View rootView) {</span>
        <span class="s0">// TODO T62192299: remove when investigation is complete</span>
        <span class="s1">FLog.e(TAG</span><span class="s2">, </span><span class="s6">&quot;destroyRootView called&quot;</span><span class="s1">)</span><span class="s2">;</span>

        <span class="s2">if </span><span class="s1">(rootView </span><span class="s2">instanceof </span><span class="s1">ReactRootView) {</span>
          <span class="s0">// TODO T62192299: remove when investigation is complete</span>
          <span class="s1">FLog.e(TAG</span><span class="s2">, </span><span class="s6">&quot;destroyRootView called, unmountReactApplication&quot;</span><span class="s1">)</span><span class="s2">;</span>

          <span class="s1">((ReactRootView) rootView).unmountReactApplication()</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public synchronized void </span><span class="s1">setUseFallbackBundle(</span><span class="s2">boolean </span><span class="s1">useFallbackBundle) {</span>
    <span class="s1">mUseFallbackBundle = useFallbackBundle</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private </span><span class="s1">JavaScriptExecutorFactory getJSExecutorFactory() {</span>
    <span class="s2">return </span><span class="s1">mJavaScriptExecutorFactory</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public </span><span class="s1">DevSupportManager getDevSupportManager() {</span>
    <span class="s2">return </span><span class="s1">mDevSupportManager</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public </span><span class="s1">MemoryPressureRouter getMemoryPressureRouter() {</span>
    <span class="s2">return </span><span class="s1">mMemoryPressureRouter</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public </span><span class="s1">List&lt;ReactPackage&gt; getPackages() {</span>
    <span class="s2">return new </span><span class="s1">ArrayList&lt;&gt;(mPackages)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">handleCxxError(Exception e) {</span>
    <span class="s1">mDevSupportManager.handleException(e)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">registerCxxErrorHandlerFunc() {</span>
    <span class="s1">Class[] parameterTypes = </span><span class="s2">new </span><span class="s1">Class[</span><span class="s7">1</span><span class="s1">]</span><span class="s2">;</span>
    <span class="s1">parameterTypes[</span><span class="s7">0</span><span class="s1">] = Exception.</span><span class="s2">class;</span>
    <span class="s1">Method handleCxxErrorFunc = </span><span class="s2">null;</span>
    <span class="s2">try </span><span class="s1">{</span>
      <span class="s1">handleCxxErrorFunc = ReactInstanceManager.</span><span class="s2">class</span><span class="s1">.getMethod(</span><span class="s6">&quot;handleCxxError&quot;</span><span class="s2">, </span><span class="s1">parameterTypes)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(NoSuchMethodException e) {</span>
      <span class="s1">FLog.e(</span><span class="s6">&quot;ReactInstanceHolder&quot;</span><span class="s2">, </span><span class="s6">&quot;Failed to set cxx error handler function&quot;</span><span class="s2">, </span><span class="s1">e)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">ReactCxxErrorHandler.setHandleErrorFunc(</span><span class="s2">this, </span><span class="s1">handleCxxErrorFunc)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">static void </span><span class="s1">initializeSoLoaderIfNecessary(Context applicationContext) {</span>
    <span class="s0">// Call SoLoader.initialize here, this is required for apps that does not use exopackage and</span>
    <span class="s0">// does not use SoLoader for loading other native code except from the one used by React Native</span>
    <span class="s0">// This way we don't need to require others to have additional initialization code and to</span>
    <span class="s0">// subclass android.app.Application.</span>

    <span class="s0">// Method SoLoader.init is idempotent, so if you wish to use native exopackage, just call</span>
    <span class="s0">// SoLoader.init with appropriate args before initializing ReactInstanceManager</span>
    <span class="s1">SoLoader.init(applicationContext</span><span class="s2">, </span><span class="s0">/* native exopackage */ </span><span class="s2">false</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Trigger react context initialization asynchronously in a background async task. This enables</span>
   <span class="s3">* applications to pre-load the application JS, and execute global code before {</span><span class="s4">@link</span>
   <span class="s3">* ReactRootView} is available and measured.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">Called from UI thread.</span>
   <span class="s3">*/</span>
  <span class="s1">@ThreadConfined(UI)</span>
  <span class="s2">public void </span><span class="s1">createReactContextInBackground() {</span>
    <span class="s1">FLog.d(TAG</span><span class="s2">, </span><span class="s6">&quot;ReactInstanceManager.createReactContextInBackground()&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">UiThreadUtil</span>
        <span class="s1">.assertOnUiThread()</span><span class="s2">; </span><span class="s0">// Assert before setting mHasStartedCreatingInitialContext = true</span>
    <span class="s2">if </span><span class="s1">(!mHasStartedCreatingInitialContext) {</span>
      <span class="s1">mHasStartedCreatingInitialContext = </span><span class="s2">true;</span>
      <span class="s1">recreateReactContextInBackgroundInner()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Recreate the react application and context. This should be called if configuration has changed</span>
   <span class="s3">* or the developer has requested the app to be reloaded. It should only be called after an</span>
   <span class="s3">* initial call to createReactContextInBackground.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">Called from UI thread.</span>
   <span class="s3">*/</span>
  <span class="s1">@ThreadConfined(UI)</span>
  <span class="s2">public void </span><span class="s1">recreateReactContextInBackground() {</span>
    <span class="s1">Assertions.assertCondition(</span>
        <span class="s1">mHasStartedCreatingInitialContext</span><span class="s2">,</span>
        <span class="s6">&quot;recreateReactContextInBackground should only be called after the initial &quot;</span>
            <span class="s1">+ </span><span class="s6">&quot;createReactContextInBackground call.&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">recreateReactContextInBackgroundInner()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@ThreadConfined(UI)</span>
  <span class="s2">private void </span><span class="s1">recreateReactContextInBackgroundInner() {</span>
    <span class="s1">FLog.d(TAG</span><span class="s2">, </span><span class="s6">&quot;ReactInstanceManager.recreateReactContextInBackgroundInner()&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">PrinterHolder.getPrinter()</span>
        <span class="s1">.logMessage(ReactDebugOverlayTags.RN_CORE</span><span class="s2">, </span><span class="s6">&quot;RNCore: recreateReactContextInBackground&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(mUseDeveloperSupport &amp;&amp; mJSMainModulePath != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">final </span><span class="s1">DeveloperSettings devSettings = mDevSupportManager.getDevSettings()</span><span class="s2">;</span>

      <span class="s2">if </span><span class="s1">(!Systrace.isTracing(TRACE_TAG_REACT_APPS | TRACE_TAG_REACT_JS_VM_CALLS)) {</span>
        <span class="s2">if </span><span class="s1">(mBundleLoader == </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">mDevSupportManager.handleReloadJS()</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">mDevSupportManager.isPackagerRunning(</span>
              <span class="s2">new </span><span class="s1">PackagerStatusCallback() {</span>
                <span class="s1">@Override</span>
                <span class="s2">public void </span><span class="s1">onPackagerStatusFetched(</span><span class="s2">final boolean </span><span class="s1">packagerIsRunning) {</span>
                  <span class="s1">UiThreadUtil.runOnUiThread(</span>
                      <span class="s2">new </span><span class="s1">Runnable() {</span>
                        <span class="s1">@Override</span>
                        <span class="s2">public void </span><span class="s1">run() {</span>
                          <span class="s2">if </span><span class="s1">(packagerIsRunning) {</span>
                            <span class="s1">mDevSupportManager.handleReloadJS()</span><span class="s2">;</span>
                          <span class="s1">} </span><span class="s2">else if </span><span class="s1">(mDevSupportManager.hasUpToDateJSBundleInCache()</span>
                              <span class="s1">&amp;&amp; !devSettings.isRemoteJSDebugEnabled()</span>
                              <span class="s1">&amp;&amp; !mUseFallbackBundle) {</span>
                            <span class="s0">// If there is a up-to-date bundle downloaded from server,</span>
                            <span class="s0">// with remote JS debugging disabled, always use that.</span>
                            <span class="s1">onJSBundleLoadedFromServer()</span><span class="s2">;</span>
                          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                            <span class="s0">// If dev server is down, disable the remote JS debugging.</span>
                            <span class="s1">devSettings.setRemoteJSDebugEnabled(</span><span class="s2">false</span><span class="s1">)</span><span class="s2">;</span>
                            <span class="s1">recreateReactContextInBackgroundFromBundleLoader()</span><span class="s2">;</span>
                          <span class="s1">}</span>
                        <span class="s1">}</span>
                      <span class="s1">})</span><span class="s2">;</span>
                <span class="s1">}</span>
              <span class="s1">})</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">recreateReactContextInBackgroundFromBundleLoader()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@ThreadConfined(UI)</span>
  <span class="s2">private void </span><span class="s1">recreateReactContextInBackgroundFromBundleLoader() {</span>
    <span class="s1">FLog.d(TAG</span><span class="s2">, </span><span class="s6">&quot;ReactInstanceManager.recreateReactContextInBackgroundFromBundleLoader()&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">PrinterHolder.getPrinter()</span>
        <span class="s1">.logMessage(ReactDebugOverlayTags.RN_CORE</span><span class="s2">, </span><span class="s6">&quot;RNCore: load from BundleLoader&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">recreateReactContextInBackground(mJavaScriptExecutorFactory</span><span class="s2">, </span><span class="s1">mBundleLoader)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* </span><span class="s4">@return </span><span class="s3">whether createReactContextInBackground has been called. Will return false after</span>
   <span class="s3">*     onDestroy until a new initial context has been created.</span>
   <span class="s3">*/</span>
  <span class="s2">public boolean </span><span class="s1">hasStartedCreatingInitialContext() {</span>
    <span class="s2">return </span><span class="s1">mHasStartedCreatingInitialContext</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* This method will give JS the opportunity to consume the back button event. If JS does not</span>
   <span class="s3">* consume the event, mDefaultBackButtonImpl will be invoked at the end of the round trip to JS.</span>
   <span class="s3">*/</span>
  <span class="s2">public void </span><span class="s1">onBackPressed() {</span>
    <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>
    <span class="s1">ReactContext reactContext = mCurrentReactContext</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(reactContext == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s0">// Invoke without round trip to JS.</span>
      <span class="s1">FLog.w(TAG</span><span class="s2">, </span><span class="s6">&quot;Instance detached from instance manager&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">invokeDefaultOnBackPressed()</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">DeviceEventManagerModule deviceEventManagerModule =</span>
          <span class="s1">reactContext.getNativeModule(DeviceEventManagerModule.</span><span class="s2">class</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(deviceEventManagerModule != </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">deviceEventManagerModule.emitHardwareBackPressed()</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">private void </span><span class="s1">invokeDefaultOnBackPressed() {</span>
    <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(mDefaultBackButtonImpl != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mDefaultBackButtonImpl.invokeDefaultOnBackPressed()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">/** This method will give JS the opportunity to receive intents via Linking. */</span>
  <span class="s1">@ThreadConfined(UI)</span>
  <span class="s2">public void </span><span class="s1">onNewIntent(Intent intent) {</span>
    <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>
    <span class="s1">ReactContext currentContext = getCurrentReactContext()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(currentContext == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">FLog.w(TAG</span><span class="s2">, </span><span class="s6">&quot;Instance detached from instance manager&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">String action = intent.getAction()</span><span class="s2">;</span>
      <span class="s1">Uri uri = intent.getData()</span><span class="s2">;</span>

      <span class="s2">if </span><span class="s1">(uri != </span><span class="s2">null</span>
          <span class="s1">&amp;&amp; (Intent.ACTION_VIEW.equals(action)</span>
              <span class="s1">|| NfcAdapter.ACTION_NDEF_DISCOVERED.equals(action))) {</span>
        <span class="s1">DeviceEventManagerModule deviceEventManagerModule =</span>
            <span class="s1">currentContext.getNativeModule(DeviceEventManagerModule.</span><span class="s2">class</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(deviceEventManagerModule != </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">deviceEventManagerModule.emitNewIntentReceived(uri)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s1">currentContext.onNewIntent(mCurrentActivity</span><span class="s2">, </span><span class="s1">intent)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">private void </span><span class="s1">toggleElementInspector() {</span>
    <span class="s1">ReactContext currentContext = getCurrentReactContext()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(currentContext != </span><span class="s2">null </span><span class="s1">&amp;&amp; currentContext.hasActiveReactInstance()) {</span>
      <span class="s1">currentContext.emitDeviceEvent(</span><span class="s6">&quot;toggleElementInspector&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">ReactSoftExceptionLogger.logSoftException(</span>
          <span class="s1">TAG</span><span class="s2">,</span>
          <span class="s2">new </span><span class="s1">ReactNoCrashSoftException(</span>
              <span class="s6">&quot;Cannot toggleElementInspector, CatalystInstance not available&quot;</span><span class="s1">))</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Call this from {</span><span class="s4">@link </span><span class="s3">Activity#onPause()}. This notifies any listening modules so they can do</span>
   <span class="s3">* any necessary cleanup.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s4">@deprecated </span><span class="s3">Use {</span><span class="s4">@link </span><span class="s3">#onHostPause(Activity)} instead.</span>
   <span class="s3">*/</span>
  <span class="s1">@ThreadConfined(UI)</span>
  <span class="s2">public void </span><span class="s1">onHostPause() {</span>
    <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>

    <span class="s1">mDefaultBackButtonImpl = </span><span class="s2">null;</span>
    <span class="s2">if </span><span class="s1">(mUseDeveloperSupport) {</span>
      <span class="s1">mDevSupportManager.setDevSupportEnabled(</span><span class="s2">false</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">moveToBeforeResumeLifecycleState()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Call this from {</span><span class="s4">@link </span><span class="s3">Activity#onPause()}. This notifies any listening modules so they can do</span>
   <span class="s3">* any necessary cleanup. The passed Activity is the current Activity being paused. This will</span>
   <span class="s3">* always be the foreground activity that would be returned by {</span><span class="s4">@link</span>
   <span class="s3">* ReactContext#getCurrentActivity()}.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">activity the activity being paused</span>
   <span class="s3">*/</span>
  <span class="s1">@ThreadConfined(UI)</span>
  <span class="s2">public void </span><span class="s1">onHostPause(@Nullable Activity activity) {</span>
    <span class="s2">if </span><span class="s1">(mRequireActivity) {</span>
      <span class="s1">Assertions.assertCondition(mCurrentActivity != </span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(mCurrentActivity != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">Assertions.assertCondition(</span>
          <span class="s1">activity == mCurrentActivity</span><span class="s2">,</span>
          <span class="s6">&quot;Pausing an activity that is not the current activity, this is incorrect! &quot;</span>
              <span class="s1">+ </span><span class="s6">&quot;Current activity: &quot;</span>
              <span class="s1">+ mCurrentActivity.getClass().getSimpleName()</span>
              <span class="s1">+ </span><span class="s6">&quot; &quot;</span>
              <span class="s1">+ </span><span class="s6">&quot;Paused activity: &quot;</span>
              <span class="s1">+ activity.getClass().getSimpleName())</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">onHostPause()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Use this method when the activity resumes to enable invoking the back button directly from JS.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">This method retains an instance to provided mDefaultBackButtonImpl. Thus it's important to</span>
   <span class="s3">* pass from the activity instance that owns this particular instance of {</span><span class="s4">@link</span>
   <span class="s3">* ReactInstanceManager}, so that once this instance receive {</span><span class="s4">@link </span><span class="s3">#onHostDestroy} event it will</span>
   <span class="s3">* clear the reference to that defaultBackButtonImpl.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">defaultBackButtonImpl a {</span><span class="s4">@link </span><span class="s3">DefaultHardwareBackBtnHandler} from an Activity that owns</span>
   <span class="s3">*     this instance of {</span><span class="s4">@link </span><span class="s3">ReactInstanceManager}.</span>
   <span class="s3">*/</span>
  <span class="s1">@ThreadConfined(UI)</span>
  <span class="s2">public void </span><span class="s1">onHostResume(</span>
      <span class="s1">@Nullable Activity activity</span><span class="s2">, </span><span class="s1">DefaultHardwareBackBtnHandler defaultBackButtonImpl) {</span>
    <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>

    <span class="s1">mDefaultBackButtonImpl = defaultBackButtonImpl</span><span class="s2">;</span>
    <span class="s1">onHostResume(activity)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/** Use this method when the activity resumes. */</span>
  <span class="s1">@ThreadConfined(UI)</span>
  <span class="s2">public void </span><span class="s1">onHostResume(@Nullable Activity activity) {</span>
    <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>

    <span class="s1">mCurrentActivity = activity</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(mUseDeveloperSupport) {</span>
      <span class="s0">// Resume can be called from one of three different states:</span>
      <span class="s0">// a) when activity was paused</span>
      <span class="s0">// b) when activity has just been created</span>
      <span class="s0">// c) when there is no activity</span>
      <span class="s0">// In case of (a) the activity is attached to window and it is ok to add new views to it or</span>
      <span class="s0">// open dialogs. In case of (b) there is often a slight delay before such a thing happens.</span>
      <span class="s0">// As dev support manager can add views or open dialogs immediately after it gets enabled</span>
      <span class="s0">// (e.g. in the case when JS bundle is being fetched in background) we only want to enable</span>
      <span class="s0">// it once we know for sure the current activity is attached.</span>
      <span class="s0">// We want to enable the various devsupport tools in case of (c) even without any activity</span>

      <span class="s2">if </span><span class="s1">(mCurrentActivity != </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s0">// We check if activity is attached to window by checking if decor view is attached</span>
        <span class="s2">final </span><span class="s1">View decorView = mCurrentActivity.getWindow().getDecorView()</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!ViewCompat.isAttachedToWindow(decorView)) {</span>
          <span class="s1">decorView.addOnAttachStateChangeListener(</span>
              <span class="s2">new </span><span class="s1">View.OnAttachStateChangeListener() {</span>
                <span class="s1">@Override</span>
                <span class="s2">public void </span><span class="s1">onViewAttachedToWindow(View v) {</span>
                  <span class="s0">// we can drop listener now that we know the view is attached</span>
                  <span class="s1">decorView.removeOnAttachStateChangeListener(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
                  <span class="s1">mDevSupportManager.setDevSupportEnabled(</span><span class="s2">true</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>

                <span class="s1">@Override</span>
                <span class="s2">public void </span><span class="s1">onViewDetachedFromWindow(View v) {</span>
                  <span class="s0">// do nothing</span>
                <span class="s1">}</span>
              <span class="s1">})</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s0">// activity is attached to window, we can enable dev support immediately</span>
          <span class="s1">mDevSupportManager.setDevSupportEnabled(</span><span class="s2">true</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!mRequireActivity) {</span>
        <span class="s0">// there is no activity, but we can enable dev support</span>
        <span class="s1">mDevSupportManager.setDevSupportEnabled(</span><span class="s2">true</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">moveToResumedLifecycleState(</span><span class="s2">false</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Call this from {</span><span class="s4">@link </span><span class="s3">Activity#onDestroy()}. This notifies any listening modules so they can do</span>
   <span class="s3">* any necessary cleanup.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s4">@deprecated </span><span class="s3">use {</span><span class="s4">@link </span><span class="s3">#onHostDestroy(Activity)} instead</span>
   <span class="s3">*/</span>
  <span class="s1">@ThreadConfined(UI)</span>
  <span class="s2">public void </span><span class="s1">onHostDestroy() {</span>
    <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(mUseDeveloperSupport) {</span>
      <span class="s1">mDevSupportManager.setDevSupportEnabled(</span><span class="s2">false</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">moveToBeforeCreateLifecycleState()</span><span class="s2">;</span>
    <span class="s1">mCurrentActivity = </span><span class="s2">null;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Call this from {</span><span class="s4">@link </span><span class="s3">Activity#onDestroy()}. This notifies any listening modules so they can do</span>
   <span class="s3">* any necessary cleanup. If the activity being destroyed is not the current activity, no modules</span>
   <span class="s3">* are notified.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">activity the activity being destroyed</span>
   <span class="s3">*/</span>
  <span class="s1">@ThreadConfined(UI)</span>
  <span class="s2">public void </span><span class="s1">onHostDestroy(@Nullable Activity activity) {</span>
    <span class="s0">// In some cases, Activity may (correctly) be null.</span>
    <span class="s0">// See mRequireActivity flag.</span>
    <span class="s2">if </span><span class="s1">(activity == mCurrentActivity) {</span>
      <span class="s1">onHostDestroy()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">/** Temporary: due to T67035147, log sources of destroy calls. TODO T67035147: delete */</span>
  <span class="s2">private void </span><span class="s1">logOnDestroy() {</span>
    <span class="s1">FLog.d(</span>
        <span class="s1">TAG</span><span class="s2">,</span>
        <span class="s6">&quot;ReactInstanceManager.destroy called&quot;</span><span class="s2">,</span>
        <span class="s2">new </span><span class="s1">RuntimeException(</span><span class="s6">&quot;ReactInstanceManager.destroy called&quot;</span><span class="s1">))</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/** Destroy this React instance and the attached JS context. */</span>
  <span class="s1">@ThreadConfined(UI)</span>
  <span class="s2">public void </span><span class="s1">destroy() {</span>
    <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>
    <span class="s1">PrinterHolder.getPrinter().logMessage(ReactDebugOverlayTags.RN_CORE</span><span class="s2">, </span><span class="s6">&quot;RNCore: Destroy&quot;</span><span class="s1">)</span><span class="s2">;</span>

    <span class="s1">logOnDestroy()</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(mHasStartedDestroying) {</span>
      <span class="s1">FLog.e(</span>
          <span class="s1">ReactConstants.TAG</span><span class="s2">, </span><span class="s6">&quot;ReactInstanceManager.destroy called: bail out, already destroying&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s1">mHasStartedDestroying = </span><span class="s2">true;</span>

    <span class="s2">if </span><span class="s1">(mUseDeveloperSupport) {</span>
      <span class="s1">mDevSupportManager.setDevSupportEnabled(</span><span class="s2">false</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">mDevSupportManager.stopInspector()</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">moveToBeforeCreateLifecycleState()</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(mCreateReactContextThread != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mCreateReactContextThread = </span><span class="s2">null;</span>
    <span class="s1">}</span>

    <span class="s1">mMemoryPressureRouter.destroy(mApplicationContext)</span><span class="s2">;</span>

    <span class="s2">synchronized </span><span class="s1">(mReactContextLock) {</span>
      <span class="s2">if </span><span class="s1">(mCurrentReactContext != </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">mCurrentReactContext.destroy()</span><span class="s2">;</span>
        <span class="s1">mCurrentReactContext = </span><span class="s2">null;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">mHasStartedCreatingInitialContext = </span><span class="s2">false;</span>
    <span class="s1">mCurrentActivity = </span><span class="s2">null;</span>

    <span class="s1">ResourceDrawableIdHelper.getInstance().clear()</span><span class="s2">;</span>
    <span class="s1">mHasStartedDestroying = </span><span class="s2">false;</span>
    <span class="s2">synchronized </span><span class="s1">(mHasStartedDestroying) {</span>
      <span class="s1">mHasStartedDestroying.notifyAll()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">synchronized </span><span class="s1">(mPackages) {</span>
      <span class="s1">mViewManagerNames = </span><span class="s2">null;</span>
    <span class="s1">}</span>
    <span class="s1">FLog.d(ReactConstants.TAG</span><span class="s2">, </span><span class="s6">&quot;ReactInstanceManager has been destroyed&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private synchronized void </span><span class="s1">moveToResumedLifecycleState(</span><span class="s2">boolean </span><span class="s1">force) {</span>
    <span class="s1">ReactContext currentContext = getCurrentReactContext()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(currentContext != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s0">// we currently don't have an onCreate callback so we call onResume for both transitions</span>
      <span class="s2">if </span><span class="s1">(force</span>
          <span class="s1">|| mLifecycleState == LifecycleState.BEFORE_RESUME</span>
          <span class="s1">|| mLifecycleState == LifecycleState.BEFORE_CREATE) {</span>
        <span class="s1">currentContext.onHostResume(mCurrentActivity)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">mLifecycleState = LifecycleState.RESUMED</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private synchronized void </span><span class="s1">moveToBeforeResumeLifecycleState() {</span>
    <span class="s1">ReactContext currentContext = getCurrentReactContext()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(currentContext != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(mLifecycleState == LifecycleState.BEFORE_CREATE) {</span>
        <span class="s1">currentContext.onHostResume(mCurrentActivity)</span><span class="s2">;</span>
        <span class="s1">currentContext.onHostPause()</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(mLifecycleState == LifecycleState.RESUMED) {</span>
        <span class="s1">currentContext.onHostPause()</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">mLifecycleState = LifecycleState.BEFORE_RESUME</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private synchronized void </span><span class="s1">moveToBeforeCreateLifecycleState() {</span>
    <span class="s1">ReactContext currentContext = getCurrentReactContext()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(currentContext != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(mLifecycleState == LifecycleState.RESUMED) {</span>
        <span class="s1">currentContext.onHostPause()</span><span class="s2">;</span>
        <span class="s1">mLifecycleState = LifecycleState.BEFORE_RESUME</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(mLifecycleState == LifecycleState.BEFORE_RESUME) {</span>
        <span class="s1">currentContext.onHostDestroy()</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">mLifecycleState = LifecycleState.BEFORE_CREATE</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private synchronized void </span><span class="s1">moveReactContextToCurrentLifecycleState() {</span>
    <span class="s2">if </span><span class="s1">(mLifecycleState == LifecycleState.RESUMED) {</span>
      <span class="s1">moveToResumedLifecycleState(</span><span class="s2">true</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@ThreadConfined(UI)</span>
  <span class="s2">public void </span><span class="s1">onActivityResult(</span>
      <span class="s1">Activity activity</span><span class="s2">, int </span><span class="s1">requestCode</span><span class="s2">, int </span><span class="s1">resultCode</span><span class="s2">, </span><span class="s1">@Nullable Intent data) {</span>
    <span class="s1">ReactContext currentContext = getCurrentReactContext()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(currentContext != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">currentContext.onActivityResult(activity</span><span class="s2">, </span><span class="s1">requestCode</span><span class="s2">, </span><span class="s1">resultCode</span><span class="s2">, </span><span class="s1">data)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@ThreadConfined(UI)</span>
  <span class="s2">public void </span><span class="s1">onWindowFocusChange(</span><span class="s2">boolean </span><span class="s1">hasFocus) {</span>
    <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>
    <span class="s1">ReactContext currentContext = getCurrentReactContext()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(currentContext != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">currentContext.onWindowFocusChange(hasFocus)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">/** Call this from {</span><span class="s4">@link </span><span class="s3">Activity#onConfigurationChanged()}. */</span>
  <span class="s1">@ThreadConfined(UI)</span>
  <span class="s2">public void </span><span class="s1">onConfigurationChanged(Context updatedContext</span><span class="s2">, </span><span class="s1">@Nullable Configuration newConfig) {</span>
    <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>

    <span class="s1">ReactContext currentReactContext = getCurrentReactContext()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(currentReactContext != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">AppearanceModule appearanceModule =</span>
          <span class="s1">currentReactContext.getNativeModule(AppearanceModule.</span><span class="s2">class</span><span class="s1">)</span><span class="s2">;</span>

      <span class="s2">if </span><span class="s1">(appearanceModule != </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">appearanceModule.onConfigurationChanged(updatedContext)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@ThreadConfined(UI)</span>
  <span class="s2">public void </span><span class="s1">showDevOptionsDialog() {</span>
    <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>
    <span class="s1">mDevSupportManager.showDevOptionsDialog()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@ThreadConfined(UI)</span>
  <span class="s2">private void </span><span class="s1">clearReactRoot(ReactRoot reactRoot) {</span>
    <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>
    <span class="s1">reactRoot.getState().compareAndSet(ReactRoot.STATE_STARTED</span><span class="s2">, </span><span class="s1">ReactRoot.STATE_STOPPED)</span><span class="s2">;</span>
    <span class="s1">ViewGroup rootViewGroup = reactRoot.getRootViewGroup()</span><span class="s2">;</span>
    <span class="s1">rootViewGroup.removeAllViews()</span><span class="s2">;</span>
    <span class="s1">rootViewGroup.setId(View.NO_ID)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Attach given {</span><span class="s4">@param </span><span class="s3">reactRoot} to a catalyst instance manager and start JS application using</span>
   <span class="s3">* JS module provided by {</span><span class="s4">@link </span><span class="s3">ReactRootView#getJSModuleName}. If the react context is currently</span>
   <span class="s3">* being (re)-created, or if react context has not been created yet, the JS application associated</span>
   <span class="s3">* with the provided reactRoot reactRoot will be started asynchronously, i.e this method won't</span>
   <span class="s3">* block. This reactRoot will then be tracked by this manager and in case of catalyst instance</span>
   <span class="s3">* restart it will be re-attached.</span>
   <span class="s3">*/</span>
  <span class="s1">@ThreadConfined(UI)</span>
  <span class="s2">public void </span><span class="s1">attachRootView(ReactRoot reactRoot) {</span>
    <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>

    <span class="s0">// Calling clearReactRoot is necessary to initialize the Id on reactRoot</span>
    <span class="s0">// This is necessary independently if the RN Bridge has been initialized or not.</span>
    <span class="s0">// Ideally reactRoot should be initialized with id == NO_ID</span>
    <span class="s2">if </span><span class="s1">(mAttachedReactRoots.add(reactRoot)) {</span>
      <span class="s1">clearReactRoot(reactRoot)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s0">// If react context is being created in the background, JS application will be started</span>
    <span class="s0">// automatically when creation completes, as reactRoot reactRoot is part of the attached</span>
    <span class="s0">// reactRoot reactRoot list.</span>
    <span class="s1">ReactContext currentContext = getCurrentReactContext()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(mCreateReactContextThread == </span><span class="s2">null </span><span class="s1">&amp;&amp; currentContext != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(reactRoot.getState().compareAndSet(ReactRoot.STATE_STOPPED</span><span class="s2">, </span><span class="s1">ReactRoot.STATE_STARTED)) {</span>
        <span class="s1">attachRootViewToInstance(reactRoot)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Detach given {</span><span class="s4">@param </span><span class="s3">reactRoot} from current catalyst instance. It's safe to call this method</span>
   <span class="s3">* multiple times on the same {</span><span class="s4">@param </span><span class="s3">reactRoot} - in that case view will be detached with the</span>
   <span class="s3">* first call.</span>
   <span class="s3">*/</span>
  <span class="s1">@ThreadConfined(UI)</span>
  <span class="s2">public void </span><span class="s1">detachRootView(ReactRoot reactRoot) {</span>
    <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>
    <span class="s2">synchronized </span><span class="s1">(mAttachedReactRoots) {</span>
      <span class="s2">if </span><span class="s1">(mAttachedReactRoots.contains(reactRoot)) {</span>
        <span class="s1">ReactContext currentContext = getCurrentReactContext()</span><span class="s2">;</span>
        <span class="s1">mAttachedReactRoots.remove(reactRoot)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(currentContext != </span><span class="s2">null </span><span class="s1">&amp;&amp; currentContext.hasActiveReactInstance()) {</span>
          <span class="s1">detachViewFromInstance(reactRoot</span><span class="s2">, </span><span class="s1">currentContext.getCatalystInstance())</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">/** Uses configured {</span><span class="s4">@link </span><span class="s3">ReactPackage} instances to create all view managers. */</span>
  <span class="s2">public </span><span class="s1">List&lt;ViewManager&gt; getOrCreateViewManagers(</span>
      <span class="s1">ReactApplicationContext catalystApplicationContext) {</span>
    <span class="s1">ReactMarker.logMarker(CREATE_VIEW_MANAGERS_START)</span><span class="s2">;</span>
    <span class="s1">Systrace.beginSection(TRACE_TAG_REACT_JAVA_BRIDGE</span><span class="s2">, </span><span class="s6">&quot;createAllViewManagers&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">try </span><span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(mViewManagers == </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">synchronized </span><span class="s1">(mPackages) {</span>
          <span class="s2">if </span><span class="s1">(mViewManagers == </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">ArrayList&lt;ViewManager&gt; viewManagers = </span><span class="s2">new </span><span class="s1">ArrayList&lt;&gt;()</span><span class="s2">;</span>
            <span class="s2">for </span><span class="s1">(ReactPackage reactPackage : mPackages) {</span>
              <span class="s1">viewManagers.addAll(reactPackage.createViewManagers(catalystApplicationContext))</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">mViewManagers = viewManagers</span><span class="s2">;</span>
            <span class="s2">return </span><span class="s1">mViewManagers</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">mViewManagers</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
      <span class="s1">Systrace.endSection(TRACE_TAG_REACT_JAVA_BRIDGE)</span><span class="s2">;</span>
      <span class="s1">ReactMarker.logMarker(CREATE_VIEW_MANAGERS_END)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">public </span><span class="s1">@Nullable ViewManager createViewManager(String viewManagerName) {</span>
    <span class="s1">ReactApplicationContext context</span><span class="s2">;</span>
    <span class="s2">synchronized </span><span class="s1">(mReactContextLock) {</span>
      <span class="s1">context = (ReactApplicationContext) getCurrentReactContext()</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(context == </span><span class="s2">null </span><span class="s1">|| !context.hasActiveReactInstance()) {</span>
        <span class="s2">return null;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">synchronized </span><span class="s1">(mPackages) {</span>
      <span class="s2">for </span><span class="s1">(ReactPackage reactPackage : mPackages) {</span>
        <span class="s2">if </span><span class="s1">(reactPackage </span><span class="s2">instanceof </span><span class="s1">ViewManagerOnDemandReactPackage) {</span>
          <span class="s1">ViewManager viewManager =</span>
              <span class="s1">((ViewManagerOnDemandReactPackage) reactPackage)</span>
                  <span class="s1">.createViewManager(context</span><span class="s2">, </span><span class="s1">viewManagerName)</span><span class="s2">;</span>
          <span class="s2">if </span><span class="s1">(viewManager != </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">viewManager</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return null;</span>
  <span class="s1">}</span>

  <span class="s2">public </span><span class="s1">Collection&lt;String&gt; getViewManagerNames() {</span>
    <span class="s1">Systrace.beginSection(TRACE_TAG_REACT_JAVA_BRIDGE</span><span class="s2">, </span><span class="s6">&quot;ReactInstanceManager.getViewManagerNames&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">try </span><span class="s1">{</span>
      <span class="s1">Collection&lt;String&gt; viewManagerNames = mViewManagerNames</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(viewManagerNames != </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">viewManagerNames</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s1">ReactApplicationContext context</span><span class="s2">;</span>
      <span class="s2">synchronized </span><span class="s1">(mReactContextLock) {</span>
        <span class="s1">context = (ReactApplicationContext) getCurrentReactContext()</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(context == </span><span class="s2">null </span><span class="s1">|| !context.hasActiveReactInstance()) {</span>
          <span class="s1">FLog.w(ReactConstants.TAG</span><span class="s2">, </span><span class="s6">&quot;Calling getViewManagerNames without active context&quot;</span><span class="s1">)</span><span class="s2">;</span>
          <span class="s2">return </span><span class="s1">Collections.emptyList()</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">synchronized </span><span class="s1">(mPackages) {</span>
        <span class="s2">if </span><span class="s1">(mViewManagerNames == </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">Set&lt;String&gt; uniqueNames = </span><span class="s2">new </span><span class="s1">HashSet&lt;&gt;()</span><span class="s2">;</span>
          <span class="s2">for </span><span class="s1">(ReactPackage reactPackage : mPackages) {</span>
            <span class="s1">SystraceMessage.beginSection(</span>
                    <span class="s1">TRACE_TAG_REACT_JAVA_BRIDGE</span><span class="s2">, </span><span class="s6">&quot;ReactInstanceManager.getViewManagerName&quot;</span><span class="s1">)</span>
                <span class="s1">.arg(</span><span class="s6">&quot;Package&quot;</span><span class="s2">, </span><span class="s1">reactPackage.getClass().getSimpleName())</span>
                <span class="s1">.flush()</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(reactPackage </span><span class="s2">instanceof </span><span class="s1">ViewManagerOnDemandReactPackage) {</span>
              <span class="s1">Collection&lt;String&gt; names =</span>
                  <span class="s1">((ViewManagerOnDemandReactPackage) reactPackage).getViewManagerNames(context)</span><span class="s2">;</span>
              <span class="s2">if </span><span class="s1">(names != </span><span class="s2">null</span><span class="s1">) {</span>
                <span class="s1">uniqueNames.addAll(names)</span><span class="s2">;</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">Systrace.endSection(TRACE_TAG_REACT_JAVA_BRIDGE)</span><span class="s2">;</span>
          <span class="s1">}</span>
          <span class="s1">mViewManagerNames = uniqueNames</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">mViewManagerNames</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
      <span class="s1">Systrace.endSection(TRACE_TAG_REACT_JAVA_BRIDGE)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">/** Add a listener to be notified of react instance events. */</span>
  <span class="s2">public void </span><span class="s1">addReactInstanceEventListener(</span>
      <span class="s1">com.facebook.react.ReactInstanceEventListener listener) {</span>
    <span class="s1">mReactInstanceEventListeners.add(listener)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/** Remove a listener previously added with {</span><span class="s4">@link </span><span class="s3">#addReactInstanceEventListener}. */</span>
  <span class="s2">public void </span><span class="s1">removeReactInstanceEventListener(</span>
      <span class="s1">com.facebook.react.ReactInstanceEventListener listener) {</span>
    <span class="s1">mReactInstanceEventListeners.remove(listener)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/** </span><span class="s4">@return </span><span class="s3">current ReactApplicationContext */</span>
  <span class="s1">@VisibleForTesting</span>
  <span class="s2">public </span><span class="s1">@Nullable ReactContext getCurrentReactContext() {</span>
    <span class="s2">synchronized </span><span class="s1">(mReactContextLock) {</span>
      <span class="s2">return </span><span class="s1">mCurrentReactContext</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">public </span><span class="s1">LifecycleState getLifecycleState() {</span>
    <span class="s2">return </span><span class="s1">mLifecycleState</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public </span><span class="s1">String getJsExecutorName() {</span>
    <span class="s2">return </span><span class="s1">mJavaScriptExecutorFactory.toString()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@ThreadConfined(UI)</span>
  <span class="s2">private void </span><span class="s1">onReloadWithJSDebugger(JavaJSExecutor.Factory jsExecutorFactory) {</span>
    <span class="s1">FLog.d(ReactConstants.TAG</span><span class="s2">, </span><span class="s6">&quot;ReactInstanceManager.onReloadWithJSDebugger()&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">recreateReactContextInBackground(</span>
        <span class="s2">new </span><span class="s1">ProxyJavaScriptExecutor.Factory(jsExecutorFactory)</span><span class="s2">,</span>
        <span class="s1">JSBundleLoader.createRemoteDebuggerBundleLoader(</span>
            <span class="s1">mDevSupportManager.getJSBundleURLForRemoteDebugging()</span><span class="s2">,</span>
            <span class="s1">mDevSupportManager.getSourceUrl()))</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@ThreadConfined(UI)</span>
  <span class="s2">private void </span><span class="s1">onJSBundleLoadedFromServer() {</span>
    <span class="s1">FLog.d(ReactConstants.TAG</span><span class="s2">, </span><span class="s6">&quot;ReactInstanceManager.onJSBundleLoadedFromServer()&quot;</span><span class="s1">)</span><span class="s2">;</span>

    <span class="s1">JSBundleLoader bundleLoader =</span>
        <span class="s1">JSBundleLoader.createCachedBundleFromNetworkLoader(</span>
            <span class="s1">mDevSupportManager.getSourceUrl()</span><span class="s2">, </span><span class="s1">mDevSupportManager.getDownloadedJSBundleFile())</span><span class="s2">;</span>

    <span class="s1">recreateReactContextInBackground(mJavaScriptExecutorFactory</span><span class="s2">, </span><span class="s1">bundleLoader)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@ThreadConfined(UI)</span>
  <span class="s2">private void </span><span class="s1">recreateReactContextInBackground(</span>
      <span class="s1">JavaScriptExecutorFactory jsExecutorFactory</span><span class="s2">, </span><span class="s1">JSBundleLoader jsBundleLoader) {</span>
    <span class="s1">FLog.d(ReactConstants.TAG</span><span class="s2">, </span><span class="s6">&quot;ReactInstanceManager.recreateReactContextInBackground()&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>

    <span class="s2">final </span><span class="s1">ReactContextInitParams initParams =</span>
        <span class="s2">new </span><span class="s1">ReactContextInitParams(jsExecutorFactory</span><span class="s2">, </span><span class="s1">jsBundleLoader)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(mCreateReactContextThread == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">runCreateReactContextOnNewThread(initParams)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">mPendingReactContextInitParams = initParams</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@ThreadConfined(UI)</span>
  <span class="s2">private void </span><span class="s1">runCreateReactContextOnNewThread(</span><span class="s2">final </span><span class="s1">ReactContextInitParams initParams) {</span>
    <span class="s1">FLog.d(ReactConstants.TAG</span><span class="s2">, </span><span class="s6">&quot;ReactInstanceManager.runCreateReactContextOnNewThread()&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>

    <span class="s0">// Mark start of bridge loading</span>
    <span class="s1">ReactMarker.logMarker(ReactMarkerConstants.REACT_BRIDGE_LOADING_START)</span><span class="s2">;</span>
    <span class="s2">synchronized </span><span class="s1">(mAttachedReactRoots) {</span>
      <span class="s2">synchronized </span><span class="s1">(mReactContextLock) {</span>
        <span class="s2">if </span><span class="s1">(mCurrentReactContext != </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">tearDownReactContext(mCurrentReactContext)</span><span class="s2">;</span>
          <span class="s1">mCurrentReactContext = </span><span class="s2">null;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">mCreateReactContextThread =</span>
        <span class="s2">new </span><span class="s1">Thread(</span>
            <span class="s2">null,</span>
            <span class="s2">new </span><span class="s1">Runnable() {</span>
              <span class="s1">@Override</span>
              <span class="s2">public void </span><span class="s1">run() {</span>
                <span class="s1">ReactMarker.logMarker(REACT_CONTEXT_THREAD_END)</span><span class="s2">;</span>
                <span class="s2">synchronized </span><span class="s1">(ReactInstanceManager.</span><span class="s2">this</span><span class="s1">.mHasStartedDestroying) {</span>
                  <span class="s2">while </span><span class="s1">(ReactInstanceManager.</span><span class="s2">this</span><span class="s1">.mHasStartedDestroying) {</span>
                    <span class="s2">try </span><span class="s1">{</span>
                      <span class="s1">ReactInstanceManager.</span><span class="s2">this</span><span class="s1">.mHasStartedDestroying.wait()</span><span class="s2">;</span>
                    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(InterruptedException e) {</span>
                      <span class="s2">continue;</span>
                    <span class="s1">}</span>
                  <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s0">// As destroy() may have run and set this to false, ensure that it is true before we</span>
                <span class="s0">// create</span>
                <span class="s1">mHasStartedCreatingInitialContext = </span><span class="s2">true;</span>

                <span class="s2">final </span><span class="s1">ReactApplicationContext reactApplicationContext</span><span class="s2">;</span>
                <span class="s2">try </span><span class="s1">{</span>
                  <span class="s1">Process.setThreadPriority(Process.THREAD_PRIORITY_DISPLAY)</span><span class="s2">;</span>
                  <span class="s1">ReactMarker.logMarker(VM_INIT)</span><span class="s2">;</span>
                  <span class="s1">reactApplicationContext =</span>
                      <span class="s1">createReactContext(</span>
                          <span class="s1">initParams.getJsExecutorFactory().create()</span><span class="s2">,</span>
                          <span class="s1">initParams.getJsBundleLoader())</span><span class="s2">;</span>
                <span class="s1">} </span><span class="s2">catch </span><span class="s1">(Exception e) {</span>
                  <span class="s0">// Reset state and bail out. This lets us try again later.</span>
                  <span class="s1">mHasStartedCreatingInitialContext = </span><span class="s2">false;</span>
                  <span class="s1">mCreateReactContextThread = </span><span class="s2">null;</span>
                  <span class="s1">mDevSupportManager.handleException(e)</span><span class="s2">;</span>
                  <span class="s2">return;</span>
                <span class="s1">}</span>
                <span class="s2">try </span><span class="s1">{</span>
                  <span class="s1">mCreateReactContextThread = </span><span class="s2">null;</span>
                  <span class="s1">ReactMarker.logMarker(PRE_SETUP_REACT_CONTEXT_START)</span><span class="s2">;</span>
                  <span class="s2">final </span><span class="s1">Runnable maybeRecreateReactContextRunnable =</span>
                      <span class="s2">new </span><span class="s1">Runnable() {</span>
                        <span class="s1">@Override</span>
                        <span class="s2">public void </span><span class="s1">run() {</span>
                          <span class="s2">if </span><span class="s1">(mPendingReactContextInitParams != </span><span class="s2">null</span><span class="s1">) {</span>
                            <span class="s1">runCreateReactContextOnNewThread(mPendingReactContextInitParams)</span><span class="s2">;</span>
                            <span class="s1">mPendingReactContextInitParams = </span><span class="s2">null;</span>
                          <span class="s1">}</span>
                        <span class="s1">}</span>
                      <span class="s1">}</span><span class="s2">;</span>
                  <span class="s1">Runnable setupReactContextRunnable =</span>
                      <span class="s2">new </span><span class="s1">Runnable() {</span>
                        <span class="s1">@Override</span>
                        <span class="s2">public void </span><span class="s1">run() {</span>
                          <span class="s2">try </span><span class="s1">{</span>
                            <span class="s1">setupReactContext(reactApplicationContext)</span><span class="s2">;</span>
                          <span class="s1">} </span><span class="s2">catch </span><span class="s1">(Exception e) {</span>
                            <span class="s0">// TODO T62192299: remove this after investigation</span>
                            <span class="s1">FLog.e(</span>
                                <span class="s1">ReactConstants.TAG</span><span class="s2">,</span>
                                <span class="s6">&quot;ReactInstanceManager caught exception in setupReactContext&quot;</span><span class="s2">,</span>
                                <span class="s1">e)</span><span class="s2">;</span>

                            <span class="s1">mDevSupportManager.handleException(e)</span><span class="s2">;</span>
                          <span class="s1">}</span>
                        <span class="s1">}</span>
                      <span class="s1">}</span><span class="s2">;</span>

                  <span class="s1">reactApplicationContext.runOnNativeModulesQueueThread(setupReactContextRunnable)</span><span class="s2">;</span>
                  <span class="s1">UiThreadUtil.runOnUiThread(maybeRecreateReactContextRunnable)</span><span class="s2">;</span>
                <span class="s1">} </span><span class="s2">catch </span><span class="s1">(Exception e) {</span>
                  <span class="s1">mDevSupportManager.handleException(e)</span><span class="s2">;</span>
                <span class="s1">}</span>
              <span class="s1">}</span>
            <span class="s1">}</span><span class="s2">,</span>
            <span class="s6">&quot;create_react_context&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">ReactMarker.logMarker(REACT_CONTEXT_THREAD_START)</span><span class="s2">;</span>
    <span class="s1">mCreateReactContextThread.start()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private void </span><span class="s1">setupReactContext(</span><span class="s2">final </span><span class="s1">ReactApplicationContext reactContext) {</span>
    <span class="s1">FLog.d(ReactConstants.TAG</span><span class="s2">, </span><span class="s6">&quot;ReactInstanceManager.setupReactContext()&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">ReactMarker.logMarker(PRE_SETUP_REACT_CONTEXT_END)</span><span class="s2">;</span>
    <span class="s1">ReactMarker.logMarker(SETUP_REACT_CONTEXT_START)</span><span class="s2">;</span>
    <span class="s1">Systrace.beginSection(TRACE_TAG_REACT_JAVA_BRIDGE</span><span class="s2">, </span><span class="s6">&quot;setupReactContext&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">synchronized </span><span class="s1">(mAttachedReactRoots) {</span>
      <span class="s2">synchronized </span><span class="s1">(mReactContextLock) {</span>
        <span class="s1">mCurrentReactContext = Assertions.assertNotNull(reactContext)</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s1">CatalystInstance catalystInstance =</span>
          <span class="s1">Assertions.assertNotNull(reactContext.getCatalystInstance())</span><span class="s2">;</span>

      <span class="s1">catalystInstance.initialize()</span><span class="s2">;</span>

      <span class="s1">mDevSupportManager.onNewReactContextCreated(reactContext)</span><span class="s2">;</span>
      <span class="s1">mMemoryPressureRouter.addMemoryPressureListener(catalystInstance)</span><span class="s2">;</span>

      <span class="s1">ReactMarker.logMarker(ATTACH_MEASURED_ROOT_VIEWS_START)</span><span class="s2">;</span>
      <span class="s2">for </span><span class="s1">(ReactRoot reactRoot : mAttachedReactRoots) {</span>
        <span class="s2">if </span><span class="s1">(reactRoot.getState().compareAndSet(ReactRoot.STATE_STOPPED</span><span class="s2">, </span><span class="s1">ReactRoot.STATE_STARTED)) {</span>
          <span class="s1">attachRootViewToInstance(reactRoot)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s1">ReactMarker.logMarker(ATTACH_MEASURED_ROOT_VIEWS_END)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s0">// There is a race condition here - `finalListeners` can contain null entries</span>
    <span class="s0">// See usage below for more details.</span>
    <span class="s1">com.facebook.react.ReactInstanceEventListener[] listeners =</span>
        <span class="s2">new </span><span class="s1">com.facebook.react.ReactInstanceEventListener[mReactInstanceEventListeners.size()]</span><span class="s2">;</span>
    <span class="s2">final </span><span class="s1">com.facebook.react.ReactInstanceEventListener[] finalListeners =</span>
        <span class="s1">mReactInstanceEventListeners.toArray(listeners)</span><span class="s2">;</span>

    <span class="s1">UiThreadUtil.runOnUiThread(</span>
        <span class="s2">new </span><span class="s1">Runnable() {</span>
          <span class="s1">@Override</span>
          <span class="s2">public void </span><span class="s1">run() {</span>
            <span class="s1">moveReactContextToCurrentLifecycleState()</span><span class="s2">;</span>

            <span class="s2">for </span><span class="s1">(com.facebook.react.ReactInstanceEventListener listener : finalListeners) {</span>
              <span class="s0">// Sometimes this listener is null - probably due to race</span>
              <span class="s0">// condition between allocating listeners with a certain</span>
              <span class="s0">// size, and getting a `final` version of the array on</span>
              <span class="s0">// the following line.</span>
              <span class="s2">if </span><span class="s1">(listener != </span><span class="s2">null</span><span class="s1">) {</span>
                <span class="s1">listener.onReactContextInitialized(reactContext)</span><span class="s2">;</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">reactContext.runOnJSQueueThread(</span>
        <span class="s2">new </span><span class="s1">Runnable() {</span>
          <span class="s1">@Override</span>
          <span class="s2">public void </span><span class="s1">run() {</span>
            <span class="s1">Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT)</span><span class="s2">;</span>
            <span class="s1">ReactMarker.logMarker(CHANGE_THREAD_PRIORITY</span><span class="s2">, </span><span class="s6">&quot;js_default&quot;</span><span class="s1">)</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">reactContext.runOnNativeModulesQueueThread(</span>
        <span class="s2">new </span><span class="s1">Runnable() {</span>
          <span class="s1">@Override</span>
          <span class="s2">public void </span><span class="s1">run() {</span>
            <span class="s1">Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT)</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">})</span><span class="s2">;</span>

    <span class="s1">Systrace.endSection(TRACE_TAG_REACT_JAVA_BRIDGE)</span><span class="s2">;</span>
    <span class="s1">ReactMarker.logMarker(SETUP_REACT_CONTEXT_END)</span><span class="s2">;</span>
    <span class="s0">// Mark end of bridge loading</span>
    <span class="s1">ReactMarker.logMarker(ReactMarkerConstants.REACT_BRIDGE_LOADING_END)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private void </span><span class="s1">attachRootViewToInstance(</span><span class="s2">final </span><span class="s1">ReactRoot reactRoot) {</span>
    <span class="s1">FLog.d(ReactConstants.TAG</span><span class="s2">, </span><span class="s6">&quot;ReactInstanceManager.attachRootViewToInstance()&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">Systrace.beginSection(TRACE_TAG_REACT_JAVA_BRIDGE</span><span class="s2">, </span><span class="s6">&quot;attachRootViewToInstance&quot;</span><span class="s1">)</span><span class="s2">;</span>

    <span class="s1">@Nullable</span>
    <span class="s1">UIManager uiManager =</span>
        <span class="s1">UIManagerHelper.getUIManager(mCurrentReactContext</span><span class="s2">, </span><span class="s1">reactRoot.getUIManagerType())</span><span class="s2">;</span>

    <span class="s0">// If we can't get a UIManager something has probably gone horribly wrong</span>
    <span class="s2">if </span><span class="s1">(uiManager == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">IllegalStateException(</span>
          <span class="s6">&quot;Unable to attach a rootView to ReactInstance when UIManager is not properly&quot;</span>
              <span class="s1">+ </span><span class="s6">&quot; initialized.&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">@Nullable Bundle initialProperties = reactRoot.getAppProperties()</span><span class="s2">;</span>

    <span class="s2">final int </span><span class="s1">rootTag</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(reactRoot.getUIManagerType() == FABRIC) {</span>
      <span class="s1">rootTag =</span>
          <span class="s1">uiManager.startSurface(</span>
              <span class="s1">reactRoot.getRootViewGroup()</span><span class="s2">,</span>
              <span class="s1">reactRoot.getJSModuleName()</span><span class="s2">,</span>
              <span class="s1">initialProperties == </span><span class="s2">null</span>
                  <span class="s1">? </span><span class="s2">new </span><span class="s1">WritableNativeMap()</span>
                  <span class="s1">: Arguments.fromBundle(initialProperties)</span><span class="s2">,</span>
              <span class="s1">reactRoot.getWidthMeasureSpec()</span><span class="s2">,</span>
              <span class="s1">reactRoot.getHeightMeasureSpec())</span><span class="s2">;</span>
      <span class="s1">reactRoot.setShouldLogContentAppeared(</span><span class="s2">true</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">rootTag =</span>
          <span class="s1">uiManager.addRootView(</span>
              <span class="s1">reactRoot.getRootViewGroup()</span><span class="s2">,</span>
              <span class="s1">initialProperties == </span><span class="s2">null</span>
                  <span class="s1">? </span><span class="s2">new </span><span class="s1">WritableNativeMap()</span>
                  <span class="s1">: Arguments.fromBundle(initialProperties)</span><span class="s2">,</span>
              <span class="s1">reactRoot.getInitialUITemplate())</span><span class="s2">;</span>
      <span class="s1">reactRoot.setRootViewTag(rootTag)</span><span class="s2">;</span>
      <span class="s1">reactRoot.runApplication()</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">Systrace.beginAsyncSection(</span>
        <span class="s1">TRACE_TAG_REACT_JAVA_BRIDGE</span><span class="s2">, </span><span class="s6">&quot;pre_rootView.onAttachedToReactInstance&quot;</span><span class="s2">, </span><span class="s1">rootTag)</span><span class="s2">;</span>
    <span class="s1">UiThreadUtil.runOnUiThread(</span>
        <span class="s2">new </span><span class="s1">Runnable() {</span>
          <span class="s1">@Override</span>
          <span class="s2">public void </span><span class="s1">run() {</span>
            <span class="s1">Systrace.endAsyncSection(</span>
                <span class="s1">TRACE_TAG_REACT_JAVA_BRIDGE</span><span class="s2">, </span><span class="s6">&quot;pre_rootView.onAttachedToReactInstance&quot;</span><span class="s2">, </span><span class="s1">rootTag)</span><span class="s2">;</span>
            <span class="s1">reactRoot.onStage(ReactStage.ON_ATTACH_TO_INSTANCE)</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">Systrace.endSection(TRACE_TAG_REACT_JAVA_BRIDGE)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private void </span><span class="s1">detachViewFromInstance(ReactRoot reactRoot</span><span class="s2">, </span><span class="s1">CatalystInstance catalystInstance) {</span>
    <span class="s1">FLog.d(ReactConstants.TAG</span><span class="s2">, </span><span class="s6">&quot;ReactInstanceManager.detachViewFromInstance()&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(reactRoot.getUIManagerType() == FABRIC) {</span>
      <span class="s1">catalystInstance</span>
          <span class="s1">.getJSModule(ReactFabric.</span><span class="s2">class</span><span class="s1">)</span>
          <span class="s1">.unmountComponentAtNode(reactRoot.getRootViewTag())</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">catalystInstance</span>
          <span class="s1">.getJSModule(AppRegistry.</span><span class="s2">class</span><span class="s1">)</span>
          <span class="s1">.unmountApplicationComponentAtRootTag(reactRoot.getRootViewTag())</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@ThreadConfined(UI)</span>
  <span class="s2">private void </span><span class="s1">tearDownReactContext(ReactContext reactContext) {</span>
    <span class="s1">FLog.d(ReactConstants.TAG</span><span class="s2">, </span><span class="s6">&quot;ReactInstanceManager.tearDownReactContext()&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(mLifecycleState == LifecycleState.RESUMED) {</span>
      <span class="s1">reactContext.onHostPause()</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">synchronized </span><span class="s1">(mAttachedReactRoots) {</span>
      <span class="s2">for </span><span class="s1">(ReactRoot reactRoot : mAttachedReactRoots) {</span>
        <span class="s1">clearReactRoot(reactRoot)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">// Remove memory pressure listener before tearing down react context</span>
    <span class="s0">// We cannot access the CatalystInstance after destroying the ReactContext.</span>
    <span class="s1">mMemoryPressureRouter.removeMemoryPressureListener(reactContext.getCatalystInstance())</span><span class="s2">;</span>

    <span class="s1">reactContext.destroy()</span><span class="s2">;</span>
    <span class="s1">mDevSupportManager.onReactInstanceDestroyed(reactContext)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/** </span><span class="s4">@return </span><span class="s3">instance of {</span><span class="s4">@link </span><span class="s3">ReactContext} configured a {</span><span class="s4">@link </span><span class="s3">CatalystInstance} set */</span>
  <span class="s2">private </span><span class="s1">ReactApplicationContext createReactContext(</span>
      <span class="s1">JavaScriptExecutor jsExecutor</span><span class="s2">, </span><span class="s1">JSBundleLoader jsBundleLoader) {</span>
    <span class="s1">FLog.d(ReactConstants.TAG</span><span class="s2">, </span><span class="s6">&quot;ReactInstanceManager.createReactContext()&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">ReactMarker.logMarker(CREATE_REACT_CONTEXT_START</span><span class="s2">, </span><span class="s1">jsExecutor.getName())</span><span class="s2">;</span>
    <span class="s2">final </span><span class="s1">ReactApplicationContext reactContext = </span><span class="s2">new </span><span class="s1">ReactApplicationContext(mApplicationContext)</span><span class="s2">;</span>

    <span class="s1">JSExceptionHandler exceptionHandler =</span>
        <span class="s1">mJSExceptionHandler != </span><span class="s2">null </span><span class="s1">? mJSExceptionHandler : mDevSupportManager</span><span class="s2">;</span>
    <span class="s1">reactContext.setJSExceptionHandler(exceptionHandler)</span><span class="s2">;</span>

    <span class="s1">NativeModuleRegistry nativeModuleRegistry = processPackages(reactContext</span><span class="s2">, </span><span class="s1">mPackages</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">;</span>

    <span class="s1">CatalystInstanceImpl.Builder catalystInstanceBuilder =</span>
        <span class="s2">new </span><span class="s1">CatalystInstanceImpl.Builder()</span>
            <span class="s1">.setReactQueueConfigurationSpec(ReactQueueConfigurationSpec.createDefault())</span>
            <span class="s1">.setJSExecutor(jsExecutor)</span>
            <span class="s1">.setRegistry(nativeModuleRegistry)</span>
            <span class="s1">.setJSBundleLoader(jsBundleLoader)</span>
            <span class="s1">.setJSExceptionHandler(exceptionHandler)</span><span class="s2">;</span>

    <span class="s1">ReactMarker.logMarker(CREATE_CATALYST_INSTANCE_START)</span><span class="s2">;</span>
    <span class="s0">// CREATE_CATALYST_INSTANCE_END is in JSCExecutor.cpp</span>
    <span class="s1">Systrace.beginSection(TRACE_TAG_REACT_JAVA_BRIDGE</span><span class="s2">, </span><span class="s6">&quot;createCatalystInstance&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">final </span><span class="s1">CatalystInstance catalystInstance</span><span class="s2">;</span>
    <span class="s2">try </span><span class="s1">{</span>
      <span class="s1">catalystInstance = catalystInstanceBuilder.build()</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
      <span class="s1">Systrace.endSection(TRACE_TAG_REACT_JAVA_BRIDGE)</span><span class="s2">;</span>
      <span class="s1">ReactMarker.logMarker(CREATE_CATALYST_INSTANCE_END)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">reactContext.initializeWithInstance(catalystInstance)</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(ReactFeatureFlags.unstable_useRuntimeSchedulerAlways) {</span>
      <span class="s0">// On Old Architecture, we need to initialize the Native Runtime Scheduler so that</span>
      <span class="s0">// the `nativeRuntimeScheduler` object is registered on JS.</span>
      <span class="s0">// On New Architecture, this is normally triggered by instantiate a TurboModuleManager.</span>
      <span class="s0">// Here we invoke getRuntimeScheduler() to trigger the creation of it regardless of the</span>
      <span class="s0">// architecture so it will always be there.</span>
      <span class="s1">catalystInstance.getRuntimeScheduler()</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(ReactFeatureFlags.useTurboModules &amp;&amp; mTMMDelegateBuilder != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">TurboModuleManagerDelegate tmmDelegate =</span>
          <span class="s1">mTMMDelegateBuilder</span>
              <span class="s1">.setPackages(mPackages)</span>
              <span class="s1">.setReactApplicationContext(reactContext)</span>
              <span class="s1">.build()</span><span class="s2">;</span>

      <span class="s1">TurboModuleManager turboModuleManager =</span>
          <span class="s2">new </span><span class="s1">TurboModuleManager(</span>
              <span class="s1">catalystInstance.getRuntimeExecutor()</span><span class="s2">,</span>
              <span class="s1">tmmDelegate</span><span class="s2">,</span>
              <span class="s1">catalystInstance.getJSCallInvokerHolder()</span><span class="s2">,</span>
              <span class="s1">catalystInstance.getNativeCallInvokerHolder())</span><span class="s2">;</span>

      <span class="s1">catalystInstance.setTurboModuleManager(turboModuleManager)</span><span class="s2">;</span>

      <span class="s1">TurboModuleRegistry registry = (TurboModuleRegistry) turboModuleManager</span><span class="s2">;</span>

      <span class="s0">// Eagerly initialize TurboModules</span>
      <span class="s2">for </span><span class="s1">(String moduleName : registry.getEagerInitModuleNames()) {</span>
        <span class="s1">registry.getModule(moduleName)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(mJSIModulePackage != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">catalystInstance.addJSIModules(</span>
          <span class="s1">mJSIModulePackage.getJSIModules(</span>
              <span class="s1">reactContext</span><span class="s2">, </span><span class="s1">catalystInstance.getJavaScriptContextHolder()))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(ReactFeatureFlags.enableFabricRenderer) {</span>
      <span class="s1">catalystInstance.getJSIModule(JSIModuleType.UIManager)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(mBridgeIdleDebugListener != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">catalystInstance.addBridgeIdleDebugListener(mBridgeIdleDebugListener)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(Systrace.isTracing(TRACE_TAG_REACT_APPS | TRACE_TAG_REACT_JS_VM_CALLS)) {</span>
      <span class="s1">catalystInstance.setGlobalVariable(</span><span class="s6">&quot;__RCTProfileIsProfiling&quot;</span><span class="s2">, </span><span class="s6">&quot;true&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">ReactMarker.logMarker(ReactMarkerConstants.PRE_RUN_JS_BUNDLE_START)</span><span class="s2">;</span>
    <span class="s1">Systrace.beginSection(TRACE_TAG_REACT_JAVA_BRIDGE</span><span class="s2">, </span><span class="s6">&quot;runJSBundle&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">catalystInstance.runJSBundle()</span><span class="s2">;</span>
    <span class="s1">Systrace.endSection(TRACE_TAG_REACT_JAVA_BRIDGE)</span><span class="s2">;</span>

    <span class="s2">return </span><span class="s1">reactContext</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private </span><span class="s1">NativeModuleRegistry processPackages(</span>
      <span class="s1">ReactApplicationContext reactContext</span><span class="s2">,</span>
      <span class="s1">List&lt;ReactPackage&gt; packages</span><span class="s2">,</span>
      <span class="s2">boolean </span><span class="s1">checkAndUpdatePackageMembership) {</span>
    <span class="s1">NativeModuleRegistryBuilder nativeModuleRegistryBuilder =</span>
        <span class="s2">new </span><span class="s1">NativeModuleRegistryBuilder(reactContext</span><span class="s2">, this</span><span class="s1">)</span><span class="s2">;</span>

    <span class="s1">ReactMarker.logMarker(PROCESS_PACKAGES_START)</span><span class="s2">;</span>

    <span class="s2">synchronized </span><span class="s1">(mPackages) {</span>
      <span class="s2">for </span><span class="s1">(ReactPackage reactPackage : packages) {</span>
        <span class="s2">if </span><span class="s1">(checkAndUpdatePackageMembership &amp;&amp; mPackages.contains(reactPackage)) {</span>
          <span class="s2">continue;</span>
        <span class="s1">}</span>
        <span class="s1">Systrace.beginSection(TRACE_TAG_REACT_JAVA_BRIDGE</span><span class="s2">, </span><span class="s6">&quot;createAndProcessCustomReactPackage&quot;</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">try </span><span class="s1">{</span>
          <span class="s2">if </span><span class="s1">(checkAndUpdatePackageMembership) {</span>
            <span class="s1">mPackages.add(reactPackage)</span><span class="s2">;</span>
          <span class="s1">}</span>
          <span class="s1">processPackage(reactPackage</span><span class="s2">, </span><span class="s1">nativeModuleRegistryBuilder)</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
          <span class="s1">Systrace.endSection(TRACE_TAG_REACT_JAVA_BRIDGE)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">ReactMarker.logMarker(PROCESS_PACKAGES_END)</span><span class="s2">;</span>

    <span class="s1">ReactMarker.logMarker(BUILD_NATIVE_MODULE_REGISTRY_START)</span><span class="s2">;</span>
    <span class="s1">Systrace.beginSection(TRACE_TAG_REACT_JAVA_BRIDGE</span><span class="s2">, </span><span class="s6">&quot;buildNativeModuleRegistry&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">NativeModuleRegistry nativeModuleRegistry</span><span class="s2">;</span>
    <span class="s2">try </span><span class="s1">{</span>
      <span class="s1">nativeModuleRegistry = nativeModuleRegistryBuilder.build()</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
      <span class="s1">Systrace.endSection(TRACE_TAG_REACT_JAVA_BRIDGE)</span><span class="s2">;</span>
      <span class="s1">ReactMarker.logMarker(BUILD_NATIVE_MODULE_REGISTRY_END)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">nativeModuleRegistry</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private void </span><span class="s1">processPackage(</span>
      <span class="s1">ReactPackage reactPackage</span><span class="s2">, </span><span class="s1">NativeModuleRegistryBuilder nativeModuleRegistryBuilder) {</span>
    <span class="s1">SystraceMessage.beginSection(TRACE_TAG_REACT_JAVA_BRIDGE</span><span class="s2">, </span><span class="s6">&quot;processPackage&quot;</span><span class="s1">)</span>
        <span class="s1">.arg(</span><span class="s6">&quot;className&quot;</span><span class="s2">, </span><span class="s1">reactPackage.getClass().getSimpleName())</span>
        <span class="s1">.flush()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(reactPackage </span><span class="s2">instanceof </span><span class="s1">ReactPackageLogger) {</span>
      <span class="s1">((ReactPackageLogger) reactPackage).startProcessPackage()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">nativeModuleRegistryBuilder.processPackage(reactPackage)</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(reactPackage </span><span class="s2">instanceof </span><span class="s1">ReactPackageLogger) {</span>
      <span class="s1">((ReactPackageLogger) reactPackage).endProcessPackage()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">SystraceMessage.endSection(TRACE_TAG_REACT_JAVA_BRIDGE).flush()</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
</pre>
</body>
</html>
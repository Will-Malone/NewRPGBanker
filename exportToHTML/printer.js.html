<html>
<head>
<title>printer.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6a8759;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
.s5 { color: #4646f1;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
printer.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, { value: </span><span class="s2">true </span><span class="s1">});</span>
<span class="s1">exports.Printer = </span><span class="s2">void </span><span class="s3">0</span><span class="s1">;</span>
<span class="s2">var </span><span class="s1">tslib_1 = require(</span><span class="s0">&quot;tslib&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">assert_1 = tslib_1.__importDefault(require(</span><span class="s0">&quot;assert&quot;</span><span class="s1">));</span>
<span class="s2">var </span><span class="s1">comments_1 = require(</span><span class="s0">&quot;./comments&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">lines_1 = require(</span><span class="s0">&quot;./lines&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">options_1 = require(</span><span class="s0">&quot;./options&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">patcher_1 = require(</span><span class="s0">&quot;./patcher&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">types = tslib_1.__importStar(require(</span><span class="s0">&quot;ast-types&quot;</span><span class="s1">));</span>
<span class="s2">var </span><span class="s1">namedTypes = types.namedTypes;</span>
<span class="s2">var </span><span class="s1">isString = types.builtInTypes.string;</span>
<span class="s2">var </span><span class="s1">isObject = types.builtInTypes.object;</span>
<span class="s2">var </span><span class="s1">fast_path_1 = tslib_1.__importDefault(require(</span><span class="s0">&quot;./fast-path&quot;</span><span class="s1">));</span>
<span class="s2">var </span><span class="s1">util = tslib_1.__importStar(require(</span><span class="s0">&quot;./util&quot;</span><span class="s1">));</span>
<span class="s2">var </span><span class="s1">PrintResult = </span><span class="s2">function </span><span class="s1">PrintResult(code, sourceMap) {</span>
    <span class="s1">assert_1.</span><span class="s2">default</span><span class="s1">.ok(</span><span class="s2">this instanceof </span><span class="s1">PrintResult);</span>
    <span class="s1">isString.assert(code);</span>
    <span class="s2">this</span><span class="s1">.code = code;</span>
    <span class="s2">if </span><span class="s1">(sourceMap) {</span>
        <span class="s1">isObject.assert(sourceMap);</span>
        <span class="s2">this</span><span class="s1">.map = sourceMap;</span>
    <span class="s1">}</span>
<span class="s1">};</span>
<span class="s2">var </span><span class="s1">PRp = PrintResult.prototype;</span>
<span class="s2">var </span><span class="s1">warnedAboutToString = </span><span class="s2">false</span><span class="s1">;</span>
<span class="s1">PRp.toString = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">if </span><span class="s1">(!warnedAboutToString) {</span>
        <span class="s1">console.warn(</span><span class="s0">&quot;Deprecation warning: recast.print now returns an object with &quot; </span><span class="s1">+</span>
            <span class="s0">&quot;a .code property. You appear to be treating the object as a &quot; </span><span class="s1">+</span>
            <span class="s0">&quot;string, which might still work but is strongly discouraged.&quot;</span><span class="s1">);</span>
        <span class="s1">warnedAboutToString = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return this</span><span class="s1">.code;</span>
<span class="s1">};</span>
<span class="s2">var </span><span class="s1">emptyPrintResult = </span><span class="s2">new </span><span class="s1">PrintResult(</span><span class="s0">&quot;&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">Printer = </span><span class="s2">function </span><span class="s1">Printer(config) {</span>
    <span class="s1">assert_1.</span><span class="s2">default</span><span class="s1">.ok(</span><span class="s2">this instanceof </span><span class="s1">Printer);</span>
    <span class="s2">var </span><span class="s1">explicitTabWidth = config &amp;&amp; config.tabWidth;</span>
    <span class="s1">config = options_1.normalize(config);</span>
    <span class="s4">// It's common for client code to pass the same options into both</span>
    <span class="s4">// recast.parse and recast.print, but the Printer doesn't need (and</span>
    <span class="s4">// can be confused by) config.sourceFileName, so we null it out.</span>
    <span class="s1">config.sourceFileName = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s4">// Non-destructively modifies options with overrides, and returns a</span>
    <span class="s4">// new print function that uses the modified options.</span>
    <span class="s2">function </span><span class="s1">makePrintFunctionWith(options, overrides) {</span>
        <span class="s1">options = Object.assign({}, options, overrides);</span>
        <span class="s2">return function </span><span class="s1">(path) { </span><span class="s2">return </span><span class="s1">print(path, options); };</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">print(path, options) {</span>
        <span class="s1">assert_1.</span><span class="s2">default</span><span class="s1">.ok(path </span><span class="s2">instanceof </span><span class="s1">fast_path_1.</span><span class="s2">default</span><span class="s1">);</span>
        <span class="s1">options = options || {};</span>
        <span class="s2">if </span><span class="s1">(options.includeComments) {</span>
            <span class="s2">return </span><span class="s1">comments_1.printComments(path, makePrintFunctionWith(options, {</span>
                <span class="s1">includeComments: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">}));</span>
        <span class="s1">}</span>
        <span class="s2">var </span><span class="s1">oldTabWidth = config.tabWidth;</span>
        <span class="s2">if </span><span class="s1">(!explicitTabWidth) {</span>
            <span class="s2">var </span><span class="s1">loc = path.getNode().loc;</span>
            <span class="s2">if </span><span class="s1">(loc &amp;&amp; loc.lines &amp;&amp; loc.lines.guessTabWidth) {</span>
                <span class="s1">config.tabWidth = loc.lines.guessTabWidth();</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">var </span><span class="s1">reprinter = patcher_1.getReprinter(path);</span>
        <span class="s2">var </span><span class="s1">lines = reprinter</span>
            <span class="s1">? </span><span class="s4">// Since the print function that we pass to the reprinter will</span>
                <span class="s4">// be used to print &quot;new&quot; nodes, it's tempting to think we</span>
                <span class="s4">// should pass printRootGenerically instead of print, to avoid</span>
                <span class="s4">// calling maybeReprint again, but that would be a mistake</span>
                <span class="s4">// because the new nodes might not be entirely new, but merely</span>
                <span class="s4">// moved from elsewhere in the AST. The print function is the</span>
                <span class="s4">// right choice because it gives us the opportunity to reprint</span>
                <span class="s4">// such nodes using their original source.</span>
                <span class="s1">reprinter(print)</span>
            <span class="s1">: genericPrint(path, config, options, makePrintFunctionWith(options, {</span>
                <span class="s1">includeComments: </span><span class="s2">true</span><span class="s1">,</span>
                <span class="s1">avoidRootParens: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">}));</span>
        <span class="s1">config.tabWidth = oldTabWidth;</span>
        <span class="s2">return </span><span class="s1">lines;</span>
    <span class="s1">}</span>
    <span class="s2">this</span><span class="s1">.print = </span><span class="s2">function </span><span class="s1">(ast) {</span>
        <span class="s2">if </span><span class="s1">(!ast) {</span>
            <span class="s2">return </span><span class="s1">emptyPrintResult;</span>
        <span class="s1">}</span>
        <span class="s2">var </span><span class="s1">lines = print(fast_path_1.</span><span class="s2">default</span><span class="s1">.from(ast), {</span>
            <span class="s1">includeComments: </span><span class="s2">true</span><span class="s1">,</span>
            <span class="s1">avoidRootParens: </span><span class="s2">false</span><span class="s1">,</span>
        <span class="s1">});</span>
        <span class="s2">return new </span><span class="s1">PrintResult(lines.toString(config), util.composeSourceMaps(config.inputSourceMap, lines.getSourceMap(config.sourceMapName, config.sourceRoot)));</span>
    <span class="s1">};</span>
    <span class="s2">this</span><span class="s1">.printGenerically = </span><span class="s2">function </span><span class="s1">(ast) {</span>
        <span class="s2">if </span><span class="s1">(!ast) {</span>
            <span class="s2">return </span><span class="s1">emptyPrintResult;</span>
        <span class="s1">}</span>
        <span class="s4">// Print the entire AST generically.</span>
        <span class="s2">function </span><span class="s1">printGenerically(path) {</span>
            <span class="s2">return </span><span class="s1">comments_1.printComments(path, </span><span class="s2">function </span><span class="s1">(path) {</span>
                <span class="s2">return </span><span class="s1">genericPrint(path, config, {</span>
                    <span class="s1">includeComments: </span><span class="s2">true</span><span class="s1">,</span>
                    <span class="s1">avoidRootParens: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">}, printGenerically);</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">var </span><span class="s1">path = fast_path_1.</span><span class="s2">default</span><span class="s1">.from(ast);</span>
        <span class="s2">var </span><span class="s1">oldReuseWhitespace = config.reuseWhitespace;</span>
        <span class="s4">// Do not reuse whitespace (or anything else, for that matter)</span>
        <span class="s4">// when printing generically.</span>
        <span class="s1">config.reuseWhitespace = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s4">// TODO Allow printing of comments?</span>
        <span class="s2">var </span><span class="s1">pr = </span><span class="s2">new </span><span class="s1">PrintResult(printGenerically(path).toString(config));</span>
        <span class="s1">config.reuseWhitespace = oldReuseWhitespace;</span>
        <span class="s2">return </span><span class="s1">pr;</span>
    <span class="s1">};</span>
<span class="s1">};</span>
<span class="s1">exports.Printer = Printer;</span>
<span class="s2">function </span><span class="s1">genericPrint(path, config, options, printPath) {</span>
    <span class="s1">assert_1.</span><span class="s2">default</span><span class="s1">.ok(path </span><span class="s2">instanceof </span><span class="s1">fast_path_1.</span><span class="s2">default</span><span class="s1">);</span>
    <span class="s2">var </span><span class="s1">node = path.getValue();</span>
    <span class="s2">var </span><span class="s1">parts = [];</span>
    <span class="s2">var </span><span class="s1">linesWithoutParens = genericPrintNoParens(path, config, printPath);</span>
    <span class="s2">if </span><span class="s1">(!node || linesWithoutParens.isEmpty()) {</span>
        <span class="s2">return </span><span class="s1">linesWithoutParens;</span>
    <span class="s1">}</span>
    <span class="s2">var </span><span class="s1">shouldAddParens = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s2">var </span><span class="s1">decoratorsLines = printDecorators(path, printPath);</span>
    <span class="s2">if </span><span class="s1">(decoratorsLines.isEmpty()) {</span>
        <span class="s4">// Nodes with decorators can't have parentheses, so we can avoid</span>
        <span class="s4">// computing path.needsParens() except in this case.</span>
        <span class="s2">if </span><span class="s1">(!options.avoidRootParens) {</span>
            <span class="s1">shouldAddParens = path.needsParens();</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">parts.push(decoratorsLines);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(shouldAddParens) {</span>
        <span class="s1">parts.unshift(</span><span class="s0">&quot;(&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">parts.push(linesWithoutParens);</span>
    <span class="s2">if </span><span class="s1">(shouldAddParens) {</span>
        <span class="s1">parts.push(</span><span class="s0">&quot;)&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
<span class="s1">}</span>
<span class="s4">// Note that the `options` parameter of this function is what other</span>
<span class="s4">// functions in this file call the `config` object (that is, the</span>
<span class="s4">// configuration object originally passed into the Printer constructor).</span>
<span class="s4">// Its properties are documented in lib/options.js.</span>
<span class="s2">function </span><span class="s1">genericPrintNoParens(path, options, print) {</span>
    <span class="s2">var </span><span class="s1">n = path.getValue();</span>
    <span class="s2">if </span><span class="s1">(!n) {</span>
        <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot;&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">n === </span><span class="s0">&quot;string&quot;</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">lines_1.fromString(n, options);</span>
    <span class="s1">}</span>
    <span class="s1">namedTypes.Printable.assert(n);</span>
    <span class="s2">var </span><span class="s1">parts = [];</span>
    <span class="s2">switch </span><span class="s1">(n.type) {</span>
        <span class="s2">case </span><span class="s0">&quot;File&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">path.call(print, </span><span class="s0">&quot;program&quot;</span><span class="s1">);</span>
        <span class="s2">case </span><span class="s0">&quot;Program&quot;</span><span class="s1">:</span>
            <span class="s4">// Babel 6</span>
            <span class="s2">if </span><span class="s1">(n.directives) {</span>
                <span class="s1">path.each(</span><span class="s2">function </span><span class="s1">(childPath) {</span>
                    <span class="s1">parts.push(print(childPath), </span><span class="s0">&quot;;</span><span class="s5">\n</span><span class="s0">&quot;</span><span class="s1">);</span>
                <span class="s1">}, </span><span class="s0">&quot;directives&quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(n.interpreter) {</span>
                <span class="s1">parts.push(path.call(print, </span><span class="s0">&quot;interpreter&quot;</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s1">parts.push(path.call(</span><span class="s2">function </span><span class="s1">(bodyPath) { </span><span class="s2">return </span><span class="s1">printStatementSequence(bodyPath, options, print); }, </span><span class="s0">&quot;body&quot;</span><span class="s1">));</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s2">case </span><span class="s0">&quot;Noop&quot;</span><span class="s1">: </span><span class="s4">// Babel extension.</span>
        <span class="s2">case </span><span class="s0">&quot;EmptyStatement&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot;&quot;</span><span class="s1">);</span>
        <span class="s2">case </span><span class="s0">&quot;ExpressionStatement&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([path.call(print, </span><span class="s0">&quot;expression&quot;</span><span class="s1">), </span><span class="s0">&quot;;&quot;</span><span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;ParenthesizedExpression&quot;</span><span class="s1">: </span><span class="s4">// Babel extension.</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span><span class="s0">&quot;(&quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;expression&quot;</span><span class="s1">), </span><span class="s0">&quot;)&quot;</span><span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;BinaryExpression&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;LogicalExpression&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;AssignmentExpression&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot; &quot;</span><span class="s1">).join([</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;left&quot;</span><span class="s1">),</span>
                <span class="s1">n.operator,</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;right&quot;</span><span class="s1">),</span>
            <span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;AssignmentPattern&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;left&quot;</span><span class="s1">),</span>
                <span class="s0">&quot; = &quot;</span><span class="s1">,</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;right&quot;</span><span class="s1">),</span>
            <span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;MemberExpression&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;OptionalMemberExpression&quot;</span><span class="s1">: {</span>
            <span class="s1">parts.push(path.call(print, </span><span class="s0">&quot;object&quot;</span><span class="s1">));</span>
            <span class="s2">var </span><span class="s1">property = path.call(print, </span><span class="s0">&quot;property&quot;</span><span class="s1">);</span>
            <span class="s4">// Like n.optional, except with defaults applied, so optional</span>
            <span class="s4">// defaults to true for OptionalMemberExpression nodes.</span>
            <span class="s2">var </span><span class="s1">optional = types.getFieldValue(n, </span><span class="s0">&quot;optional&quot;</span><span class="s1">);</span>
            <span class="s2">if </span><span class="s1">(n.computed) {</span>
                <span class="s1">parts.push(optional ? </span><span class="s0">&quot;?.[&quot; </span><span class="s1">: </span><span class="s0">&quot;[&quot;</span><span class="s1">, property, </span><span class="s0">&quot;]&quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">parts.push(optional ? </span><span class="s0">&quot;?.&quot; </span><span class="s1">: </span><span class="s0">&quot;.&quot;</span><span class="s1">, property);</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s1">}</span>
        <span class="s2">case </span><span class="s0">&quot;ChainExpression&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">path.call(print, </span><span class="s0">&quot;expression&quot;</span><span class="s1">);</span>
        <span class="s2">case </span><span class="s0">&quot;MetaProperty&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;meta&quot;</span><span class="s1">),</span>
                <span class="s0">&quot;.&quot;</span><span class="s1">,</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;property&quot;</span><span class="s1">),</span>
            <span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;BindExpression&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">(n.object) {</span>
                <span class="s1">parts.push(path.call(print, </span><span class="s0">&quot;object&quot;</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s1">parts.push(</span><span class="s0">&quot;::&quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;callee&quot;</span><span class="s1">));</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s2">case </span><span class="s0">&quot;Path&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot;.&quot;</span><span class="s1">).join(n.body);</span>
        <span class="s2">case </span><span class="s0">&quot;Identifier&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span>
                <span class="s1">lines_1.fromString(n.name, options),</span>
                <span class="s1">n.optional ? </span><span class="s0">&quot;?&quot; </span><span class="s1">: </span><span class="s0">&quot;&quot;</span><span class="s1">,</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;typeAnnotation&quot;</span><span class="s1">),</span>
            <span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;SpreadElement&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;SpreadElementPattern&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;RestProperty&quot;</span><span class="s1">: </span><span class="s4">// Babel 6 for ObjectPattern</span>
        <span class="s2">case </span><span class="s0">&quot;SpreadProperty&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;SpreadPropertyPattern&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;ObjectTypeSpreadProperty&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;RestElement&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span>
                <span class="s0">&quot;...&quot;</span><span class="s1">,</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;argument&quot;</span><span class="s1">),</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;typeAnnotation&quot;</span><span class="s1">),</span>
            <span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;FunctionDeclaration&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;FunctionExpression&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;TSDeclareFunction&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">(n.declare) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;declare &quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(n.async) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;async &quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s1">parts.push(</span><span class="s0">&quot;function&quot;</span><span class="s1">);</span>
            <span class="s2">if </span><span class="s1">(n.generator)</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;*&quot;</span><span class="s1">);</span>
            <span class="s2">if </span><span class="s1">(n.id) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot; &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;id&quot;</span><span class="s1">), path.call(print, </span><span class="s0">&quot;typeParameters&quot;</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s2">if </span><span class="s1">(n.typeParameters) {</span>
                    <span class="s1">parts.push(path.call(print, </span><span class="s0">&quot;typeParameters&quot;</span><span class="s1">));</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">parts.push(</span><span class="s0">&quot;(&quot;</span><span class="s1">, printFunctionParams(path, options, print), </span><span class="s0">&quot;)&quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;returnType&quot;</span><span class="s1">));</span>
            <span class="s2">if </span><span class="s1">(n.body) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot; &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;body&quot;</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s2">case </span><span class="s0">&quot;ArrowFunctionExpression&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">(n.async) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;async &quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(n.typeParameters) {</span>
                <span class="s1">parts.push(path.call(print, </span><span class="s0">&quot;typeParameters&quot;</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(!options.arrowParensAlways &amp;&amp;</span>
                <span class="s1">n.params.length === </span><span class="s3">1 </span><span class="s1">&amp;&amp;</span>
                <span class="s1">!n.rest &amp;&amp;</span>
                <span class="s1">n.params[</span><span class="s3">0</span><span class="s1">].type === </span><span class="s0">&quot;Identifier&quot; </span><span class="s1">&amp;&amp;</span>
                <span class="s1">!n.params[</span><span class="s3">0</span><span class="s1">].typeAnnotation &amp;&amp;</span>
                <span class="s1">!n.returnType) {</span>
                <span class="s1">parts.push(path.call(print, </span><span class="s0">&quot;params&quot;</span><span class="s1">, </span><span class="s3">0</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;(&quot;</span><span class="s1">, printFunctionParams(path, options, print), </span><span class="s0">&quot;)&quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;returnType&quot;</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s1">parts.push(</span><span class="s0">&quot; =&gt; &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;body&quot;</span><span class="s1">));</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s2">case </span><span class="s0">&quot;MethodDefinition&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">printMethod(path, options, print);</span>
        <span class="s2">case </span><span class="s0">&quot;YieldExpression&quot;</span><span class="s1">:</span>
            <span class="s1">parts.push(</span><span class="s0">&quot;yield&quot;</span><span class="s1">);</span>
            <span class="s2">if </span><span class="s1">(n.delegate)</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;*&quot;</span><span class="s1">);</span>
            <span class="s2">if </span><span class="s1">(n.argument)</span>
                <span class="s1">parts.push(</span><span class="s0">&quot; &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;argument&quot;</span><span class="s1">));</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s2">case </span><span class="s0">&quot;AwaitExpression&quot;</span><span class="s1">:</span>
            <span class="s1">parts.push(</span><span class="s0">&quot;await&quot;</span><span class="s1">);</span>
            <span class="s2">if </span><span class="s1">(n.all)</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;*&quot;</span><span class="s1">);</span>
            <span class="s2">if </span><span class="s1">(n.argument)</span>
                <span class="s1">parts.push(</span><span class="s0">&quot; &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;argument&quot;</span><span class="s1">));</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s2">case </span><span class="s0">&quot;ModuleExpression&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span>
                <span class="s0">&quot;module {</span><span class="s5">\n</span><span class="s0">&quot;</span><span class="s1">,</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;body&quot;</span><span class="s1">).indent(options.tabWidth),</span>
                <span class="s0">&quot;</span><span class="s5">\n</span><span class="s0">}&quot;</span><span class="s1">,</span>
            <span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;ModuleDeclaration&quot;</span><span class="s1">:</span>
            <span class="s1">parts.push(</span><span class="s0">&quot;module&quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;id&quot;</span><span class="s1">));</span>
            <span class="s2">if </span><span class="s1">(n.source) {</span>
                <span class="s1">assert_1.</span><span class="s2">default</span><span class="s1">.ok(!n.body);</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;from&quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;source&quot;</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">parts.push(path.call(print, </span><span class="s0">&quot;body&quot;</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot; &quot;</span><span class="s1">).join(parts);</span>
        <span class="s2">case </span><span class="s0">&quot;ImportSpecifier&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">(n.importKind &amp;&amp; n.importKind !== </span><span class="s0">&quot;value&quot;</span><span class="s1">) {</span>
                <span class="s1">parts.push(n.importKind + </span><span class="s0">&quot; &quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(n.imported) {</span>
                <span class="s1">parts.push(path.call(print, </span><span class="s0">&quot;imported&quot;</span><span class="s1">));</span>
                <span class="s2">if </span><span class="s1">(n.local &amp;&amp; n.local.name !== n.imported.name) {</span>
                    <span class="s1">parts.push(</span><span class="s0">&quot; as &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;local&quot;</span><span class="s1">));</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(n.id) {</span>
                <span class="s1">parts.push(path.call(print, </span><span class="s0">&quot;id&quot;</span><span class="s1">));</span>
                <span class="s2">if </span><span class="s1">(n.name) {</span>
                    <span class="s1">parts.push(</span><span class="s0">&quot; as &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;name&quot;</span><span class="s1">));</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s2">case </span><span class="s0">&quot;ExportSpecifier&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">(n.local) {</span>
                <span class="s1">parts.push(path.call(print, </span><span class="s0">&quot;local&quot;</span><span class="s1">));</span>
                <span class="s2">if </span><span class="s1">(n.exported &amp;&amp; n.exported.name !== n.local.name) {</span>
                    <span class="s1">parts.push(</span><span class="s0">&quot; as &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;exported&quot;</span><span class="s1">));</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(n.id) {</span>
                <span class="s1">parts.push(path.call(print, </span><span class="s0">&quot;id&quot;</span><span class="s1">));</span>
                <span class="s2">if </span><span class="s1">(n.name) {</span>
                    <span class="s1">parts.push(</span><span class="s0">&quot; as &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;name&quot;</span><span class="s1">));</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s2">case </span><span class="s0">&quot;ExportBatchSpecifier&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot;*&quot;</span><span class="s1">);</span>
        <span class="s2">case </span><span class="s0">&quot;ImportNamespaceSpecifier&quot;</span><span class="s1">:</span>
            <span class="s1">parts.push(</span><span class="s0">&quot;* as &quot;</span><span class="s1">);</span>
            <span class="s2">if </span><span class="s1">(n.local) {</span>
                <span class="s1">parts.push(path.call(print, </span><span class="s0">&quot;local&quot;</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(n.id) {</span>
                <span class="s1">parts.push(path.call(print, </span><span class="s0">&quot;id&quot;</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s2">case </span><span class="s0">&quot;ImportDefaultSpecifier&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">(n.local) {</span>
                <span class="s2">return </span><span class="s1">path.call(print, </span><span class="s0">&quot;local&quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">path.call(print, </span><span class="s0">&quot;id&quot;</span><span class="s1">);</span>
        <span class="s2">case </span><span class="s0">&quot;TSExportAssignment&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span><span class="s0">&quot;export = &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;expression&quot;</span><span class="s1">)]);</span>
        <span class="s2">case </span><span class="s0">&quot;ExportDeclaration&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;ExportDefaultDeclaration&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;ExportNamedDeclaration&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">printExportDeclaration(path, options, print);</span>
        <span class="s2">case </span><span class="s0">&quot;ExportAllDeclaration&quot;</span><span class="s1">:</span>
            <span class="s1">parts.push(</span><span class="s0">&quot;export *&quot;</span><span class="s1">);</span>
            <span class="s2">if </span><span class="s1">(n.exported) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot; as &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;exported&quot;</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s1">parts.push(</span><span class="s0">&quot; from &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;source&quot;</span><span class="s1">), </span><span class="s0">&quot;;&quot;</span><span class="s1">);</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s2">case </span><span class="s0">&quot;TSNamespaceExportDeclaration&quot;</span><span class="s1">:</span>
            <span class="s1">parts.push(</span><span class="s0">&quot;export as namespace &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;id&quot;</span><span class="s1">));</span>
            <span class="s2">return </span><span class="s1">maybeAddSemicolon(lines_1.concat(parts));</span>
        <span class="s2">case </span><span class="s0">&quot;ExportNamespaceSpecifier&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span><span class="s0">&quot;* as &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;exported&quot;</span><span class="s1">)]);</span>
        <span class="s2">case </span><span class="s0">&quot;ExportDefaultSpecifier&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">path.call(print, </span><span class="s0">&quot;exported&quot;</span><span class="s1">);</span>
        <span class="s2">case </span><span class="s0">&quot;Import&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot;import&quot;</span><span class="s1">, options);</span>
        <span class="s4">// Recast and ast-types currently support dynamic import(...) using</span>
        <span class="s4">// either this dedicated ImportExpression type or a CallExpression</span>
        <span class="s4">// whose callee has type Import.</span>
        <span class="s4">// https://github.com/benjamn/ast-types/pull/365#issuecomment-605214486</span>
        <span class="s2">case </span><span class="s0">&quot;ImportExpression&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span><span class="s0">&quot;import(&quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;source&quot;</span><span class="s1">), </span><span class="s0">&quot;)&quot;</span><span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;ImportDeclaration&quot;</span><span class="s1">: {</span>
            <span class="s1">parts.push(</span><span class="s0">&quot;import &quot;</span><span class="s1">);</span>
            <span class="s2">if </span><span class="s1">(n.importKind &amp;&amp; n.importKind !== </span><span class="s0">&quot;value&quot;</span><span class="s1">) {</span>
                <span class="s1">parts.push(n.importKind + </span><span class="s0">&quot; &quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(n.specifiers &amp;&amp; n.specifiers.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s2">var </span><span class="s1">unbracedSpecifiers_1 = [];</span>
                <span class="s2">var </span><span class="s1">bracedSpecifiers_1 = [];</span>
                <span class="s1">path.each(</span><span class="s2">function </span><span class="s1">(specifierPath) {</span>
                    <span class="s2">var </span><span class="s1">spec = specifierPath.getValue();</span>
                    <span class="s2">if </span><span class="s1">(spec.type === </span><span class="s0">&quot;ImportSpecifier&quot;</span><span class="s1">) {</span>
                        <span class="s1">bracedSpecifiers_1.push(print(specifierPath));</span>
                    <span class="s1">}</span>
                    <span class="s2">else if </span><span class="s1">(spec.type === </span><span class="s0">&quot;ImportDefaultSpecifier&quot; </span><span class="s1">||</span>
                        <span class="s1">spec.type === </span><span class="s0">&quot;ImportNamespaceSpecifier&quot;</span><span class="s1">) {</span>
                        <span class="s1">unbracedSpecifiers_1.push(print(specifierPath));</span>
                    <span class="s1">}</span>
                <span class="s1">}, </span><span class="s0">&quot;specifiers&quot;</span><span class="s1">);</span>
                <span class="s1">unbracedSpecifiers_1.forEach(</span><span class="s2">function </span><span class="s1">(lines, i) {</span>
                    <span class="s2">if </span><span class="s1">(i &gt; </span><span class="s3">0</span><span class="s1">) {</span>
                        <span class="s1">parts.push(</span><span class="s0">&quot;, &quot;</span><span class="s1">);</span>
                    <span class="s1">}</span>
                    <span class="s1">parts.push(lines);</span>
                <span class="s1">});</span>
                <span class="s2">if </span><span class="s1">(bracedSpecifiers_1.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
                    <span class="s2">var </span><span class="s1">lines = lines_1.fromString(</span><span class="s0">&quot;, &quot;</span><span class="s1">).join(bracedSpecifiers_1);</span>
                    <span class="s2">if </span><span class="s1">(lines.getLineLength(</span><span class="s3">1</span><span class="s1">) &gt; options.wrapColumn) {</span>
                        <span class="s1">lines = lines_1.concat([</span>
                            <span class="s1">lines_1.fromString(</span><span class="s0">&quot;,</span><span class="s5">\n</span><span class="s0">&quot;</span><span class="s1">).join(bracedSpecifiers_1).indent(options.tabWidth),</span>
                            <span class="s0">&quot;,&quot;</span><span class="s1">,</span>
                        <span class="s1">]);</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">(unbracedSpecifiers_1.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
                        <span class="s1">parts.push(</span><span class="s0">&quot;, &quot;</span><span class="s1">);</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">(lines.length &gt; </span><span class="s3">1</span><span class="s1">) {</span>
                        <span class="s1">parts.push(</span><span class="s0">&quot;{</span><span class="s5">\n</span><span class="s0">&quot;</span><span class="s1">, lines, </span><span class="s0">&quot;</span><span class="s5">\n</span><span class="s0">}&quot;</span><span class="s1">);</span>
                    <span class="s1">}</span>
                    <span class="s2">else if </span><span class="s1">(options.objectCurlySpacing) {</span>
                        <span class="s1">parts.push(</span><span class="s0">&quot;{ &quot;</span><span class="s1">, lines, </span><span class="s0">&quot; }&quot;</span><span class="s1">);</span>
                    <span class="s1">}</span>
                    <span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">parts.push(</span><span class="s0">&quot;{&quot;</span><span class="s1">, lines, </span><span class="s0">&quot;}&quot;</span><span class="s1">);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s1">parts.push(</span><span class="s0">&quot; from &quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s1">parts.push(path.call(print, </span><span class="s0">&quot;source&quot;</span><span class="s1">), maybePrintImportAssertions(path, options, print), </span><span class="s0">&quot;;&quot;</span><span class="s1">);</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s1">}</span>
        <span class="s2">case </span><span class="s0">&quot;ImportAttribute&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([path.call(print, </span><span class="s0">&quot;key&quot;</span><span class="s1">), </span><span class="s0">&quot;: &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;value&quot;</span><span class="s1">)]);</span>
        <span class="s2">case </span><span class="s0">&quot;StaticBlock&quot;</span><span class="s1">:</span>
            <span class="s1">parts.push(</span><span class="s0">&quot;static &quot;</span><span class="s1">);</span>
        <span class="s4">// Intentionally fall through to BlockStatement below.</span>
        <span class="s2">case </span><span class="s0">&quot;BlockStatement&quot;</span><span class="s1">: {</span>
            <span class="s2">var </span><span class="s1">naked_1 = path.call(</span><span class="s2">function </span><span class="s1">(bodyPath) { </span><span class="s2">return </span><span class="s1">printStatementSequence(bodyPath, options, print); }, </span><span class="s0">&quot;body&quot;</span><span class="s1">);</span>
            <span class="s2">if </span><span class="s1">(naked_1.isEmpty()) {</span>
                <span class="s2">if </span><span class="s1">(!n.directives || n.directives.length === </span><span class="s3">0</span><span class="s1">) {</span>
                    <span class="s1">parts.push(</span><span class="s0">&quot;{}&quot;</span><span class="s1">);</span>
                    <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">parts.push(</span><span class="s0">&quot;{</span><span class="s5">\n</span><span class="s0">&quot;</span><span class="s1">);</span>
            <span class="s4">// Babel 6</span>
            <span class="s2">if </span><span class="s1">(n.directives) {</span>
                <span class="s1">path.each(</span><span class="s2">function </span><span class="s1">(childPath) {</span>
                    <span class="s1">parts.push(maybeAddSemicolon(print(childPath).indent(options.tabWidth)), n.directives.length &gt; </span><span class="s3">1 </span><span class="s1">|| !naked_1.isEmpty() ? </span><span class="s0">&quot;</span><span class="s5">\n</span><span class="s0">&quot; </span><span class="s1">: </span><span class="s0">&quot;&quot;</span><span class="s1">);</span>
                <span class="s1">}, </span><span class="s0">&quot;directives&quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s1">parts.push(naked_1.indent(options.tabWidth));</span>
            <span class="s1">parts.push(</span><span class="s0">&quot;</span><span class="s5">\n</span><span class="s0">}&quot;</span><span class="s1">);</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s1">}</span>
        <span class="s2">case </span><span class="s0">&quot;ReturnStatement&quot;</span><span class="s1">: {</span>
            <span class="s1">parts.push(</span><span class="s0">&quot;return&quot;</span><span class="s1">);</span>
            <span class="s2">if </span><span class="s1">(n.argument) {</span>
                <span class="s2">var </span><span class="s1">argLines = path.call(print, </span><span class="s0">&quot;argument&quot;</span><span class="s1">);</span>
                <span class="s2">if </span><span class="s1">(argLines.startsWithComment() ||</span>
                    <span class="s1">(argLines.length &gt; </span><span class="s3">1 </span><span class="s1">&amp;&amp;</span>
                        <span class="s1">namedTypes.JSXElement &amp;&amp;</span>
                        <span class="s1">namedTypes.JSXElement.check(n.argument))) {</span>
                    <span class="s1">parts.push(</span><span class="s0">&quot; (</span><span class="s5">\n</span><span class="s0">&quot;</span><span class="s1">, argLines.indent(options.tabWidth), </span><span class="s0">&quot;</span><span class="s5">\n</span><span class="s0">)&quot;</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">parts.push(</span><span class="s0">&quot; &quot;</span><span class="s1">, argLines);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">parts.push(</span><span class="s0">&quot;;&quot;</span><span class="s1">);</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s1">}</span>
        <span class="s2">case </span><span class="s0">&quot;CallExpression&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;OptionalCallExpression&quot;</span><span class="s1">:</span>
            <span class="s1">parts.push(path.call(print, </span><span class="s0">&quot;callee&quot;</span><span class="s1">));</span>
            <span class="s2">if </span><span class="s1">(n.typeParameters) {</span>
                <span class="s1">parts.push(path.call(print, </span><span class="s0">&quot;typeParameters&quot;</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(n.typeArguments) {</span>
                <span class="s1">parts.push(path.call(print, </span><span class="s0">&quot;typeArguments&quot;</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s4">// Like n.optional, but defaults to true for OptionalCallExpression</span>
            <span class="s4">// nodes that are missing an n.optional property (unusual),</span>
            <span class="s4">// according to the OptionalCallExpression definition in ast-types.</span>
            <span class="s2">if </span><span class="s1">(types.getFieldValue(n, </span><span class="s0">&quot;optional&quot;</span><span class="s1">)) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;?.&quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s1">parts.push(printArgumentsList(path, options, print));</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s2">case </span><span class="s0">&quot;RecordExpression&quot;</span><span class="s1">:</span>
            <span class="s1">parts.push(</span><span class="s0">&quot;#&quot;</span><span class="s1">);</span>
        <span class="s4">// Intentionally fall through to printing the object literal...</span>
        <span class="s2">case </span><span class="s0">&quot;ObjectExpression&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;ObjectPattern&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;ObjectTypeAnnotation&quot;</span><span class="s1">: {</span>
            <span class="s2">var </span><span class="s1">isTypeAnnotation_1 = n.type === </span><span class="s0">&quot;ObjectTypeAnnotation&quot;</span><span class="s1">;</span>
            <span class="s2">var </span><span class="s1">separator_1 = options.flowObjectCommas</span>
                <span class="s1">? </span><span class="s0">&quot;,&quot;</span>
                <span class="s1">: isTypeAnnotation_1</span>
                    <span class="s1">? </span><span class="s0">&quot;;&quot;</span>
                    <span class="s1">: </span><span class="s0">&quot;,&quot;</span><span class="s1">;</span>
            <span class="s2">var </span><span class="s1">fields = [];</span>
            <span class="s2">var </span><span class="s1">allowBreak_1 = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s2">if </span><span class="s1">(isTypeAnnotation_1) {</span>
                <span class="s1">fields.push(</span><span class="s0">&quot;indexers&quot;</span><span class="s1">, </span><span class="s0">&quot;callProperties&quot;</span><span class="s1">);</span>
                <span class="s2">if </span><span class="s1">(n.internalSlots != </span><span class="s2">null</span><span class="s1">) {</span>
                    <span class="s1">fields.push(</span><span class="s0">&quot;internalSlots&quot;</span><span class="s1">);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">fields.push(</span><span class="s0">&quot;properties&quot;</span><span class="s1">);</span>
            <span class="s2">var </span><span class="s1">len_1 = </span><span class="s3">0</span><span class="s1">;</span>
            <span class="s1">fields.forEach(</span><span class="s2">function </span><span class="s1">(field) {</span>
                <span class="s1">len_1 += n[field].length;</span>
            <span class="s1">});</span>
            <span class="s2">var </span><span class="s1">oneLine_1 = (isTypeAnnotation_1 &amp;&amp; len_1 === </span><span class="s3">1</span><span class="s1">) || len_1 === </span><span class="s3">0</span><span class="s1">;</span>
            <span class="s2">var </span><span class="s1">leftBrace = n.exact ? </span><span class="s0">&quot;{|&quot; </span><span class="s1">: </span><span class="s0">&quot;{&quot;</span><span class="s1">;</span>
            <span class="s2">var </span><span class="s1">rightBrace = n.exact ? </span><span class="s0">&quot;|}&quot; </span><span class="s1">: </span><span class="s0">&quot;}&quot;</span><span class="s1">;</span>
            <span class="s1">parts.push(oneLine_1 ? leftBrace : leftBrace + </span><span class="s0">&quot;</span><span class="s5">\n</span><span class="s0">&quot;</span><span class="s1">);</span>
            <span class="s2">var </span><span class="s1">leftBraceIndex = parts.length - </span><span class="s3">1</span><span class="s1">;</span>
            <span class="s2">var </span><span class="s1">i_1 = </span><span class="s3">0</span><span class="s1">;</span>
            <span class="s1">fields.forEach(</span><span class="s2">function </span><span class="s1">(field) {</span>
                <span class="s1">path.each(</span><span class="s2">function </span><span class="s1">(childPath) {</span>
                    <span class="s2">var </span><span class="s1">lines = print(childPath);</span>
                    <span class="s2">if </span><span class="s1">(!oneLine_1) {</span>
                        <span class="s1">lines = lines.indent(options.tabWidth);</span>
                    <span class="s1">}</span>
                    <span class="s2">var </span><span class="s1">multiLine = !isTypeAnnotation_1 &amp;&amp; lines.length &gt; </span><span class="s3">1</span><span class="s1">;</span>
                    <span class="s2">if </span><span class="s1">(multiLine &amp;&amp; allowBreak_1) {</span>
                        <span class="s4">// Similar to the logic for BlockStatement.</span>
                        <span class="s1">parts.push(</span><span class="s0">&quot;</span><span class="s5">\n</span><span class="s0">&quot;</span><span class="s1">);</span>
                    <span class="s1">}</span>
                    <span class="s1">parts.push(lines);</span>
                    <span class="s2">if </span><span class="s1">(i_1 &lt; len_1 - </span><span class="s3">1</span><span class="s1">) {</span>
                        <span class="s4">// Add an extra line break if the previous object property</span>
                        <span class="s4">// had a multi-line value.</span>
                        <span class="s1">parts.push(separator_1 + (multiLine ? </span><span class="s0">&quot;</span><span class="s5">\n\n</span><span class="s0">&quot; </span><span class="s1">: </span><span class="s0">&quot;</span><span class="s5">\n</span><span class="s0">&quot;</span><span class="s1">));</span>
                        <span class="s1">allowBreak_1 = !multiLine;</span>
                    <span class="s1">}</span>
                    <span class="s2">else if </span><span class="s1">(len_1 !== </span><span class="s3">1 </span><span class="s1">&amp;&amp; isTypeAnnotation_1) {</span>
                        <span class="s1">parts.push(separator_1);</span>
                    <span class="s1">}</span>
                    <span class="s2">else if </span><span class="s1">(!oneLine_1 &amp;&amp;</span>
                        <span class="s1">util.isTrailingCommaEnabled(options, </span><span class="s0">&quot;objects&quot;</span><span class="s1">) &amp;&amp;</span>
                        <span class="s1">childPath.getValue().type !== </span><span class="s0">&quot;RestElement&quot;</span><span class="s1">) {</span>
                        <span class="s1">parts.push(separator_1);</span>
                    <span class="s1">}</span>
                    <span class="s1">i_1++;</span>
                <span class="s1">}, field);</span>
            <span class="s1">});</span>
            <span class="s2">if </span><span class="s1">(n.inexact) {</span>
                <span class="s2">var </span><span class="s1">line = lines_1.fromString(</span><span class="s0">&quot;...&quot;</span><span class="s1">, options);</span>
                <span class="s2">if </span><span class="s1">(oneLine_1) {</span>
                    <span class="s2">if </span><span class="s1">(len_1 &gt; </span><span class="s3">0</span><span class="s1">) {</span>
                        <span class="s1">parts.push(separator_1, </span><span class="s0">&quot; &quot;</span><span class="s1">);</span>
                    <span class="s1">}</span>
                    <span class="s1">parts.push(line);</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s4">// No trailing separator after ... to maintain parity with prettier.</span>
                    <span class="s1">parts.push(</span><span class="s0">&quot;</span><span class="s5">\n</span><span class="s0">&quot;</span><span class="s1">, line.indent(options.tabWidth));</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">parts.push(oneLine_1 ? rightBrace : </span><span class="s0">&quot;</span><span class="s5">\n</span><span class="s0">&quot; </span><span class="s1">+ rightBrace);</span>
            <span class="s2">if </span><span class="s1">(i_1 !== </span><span class="s3">0 </span><span class="s1">&amp;&amp; oneLine_1 &amp;&amp; options.objectCurlySpacing) {</span>
                <span class="s1">parts[leftBraceIndex] = leftBrace + </span><span class="s0">&quot; &quot;</span><span class="s1">;</span>
                <span class="s1">parts[parts.length - </span><span class="s3">1</span><span class="s1">] = </span><span class="s0">&quot; &quot; </span><span class="s1">+ rightBrace;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(n.typeAnnotation) {</span>
                <span class="s1">parts.push(path.call(print, </span><span class="s0">&quot;typeAnnotation&quot;</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s1">}</span>
        <span class="s2">case </span><span class="s0">&quot;PropertyPattern&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;key&quot;</span><span class="s1">),</span>
                <span class="s0">&quot;: &quot;</span><span class="s1">,</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;pattern&quot;</span><span class="s1">),</span>
            <span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;ObjectProperty&quot;</span><span class="s1">: </span><span class="s4">// Babel 6</span>
        <span class="s2">case </span><span class="s0">&quot;Property&quot;</span><span class="s1">: {</span>
            <span class="s4">// Non-standard AST node type.</span>
            <span class="s2">if </span><span class="s1">(n.method || n.kind === </span><span class="s0">&quot;get&quot; </span><span class="s1">|| n.kind === </span><span class="s0">&quot;set&quot;</span><span class="s1">) {</span>
                <span class="s2">return </span><span class="s1">printMethod(path, options, print);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(n.shorthand &amp;&amp; n.value.type === </span><span class="s0">&quot;AssignmentPattern&quot;</span><span class="s1">) {</span>
                <span class="s2">return </span><span class="s1">path.call(print, </span><span class="s0">&quot;value&quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">var </span><span class="s1">key = path.call(print, </span><span class="s0">&quot;key&quot;</span><span class="s1">);</span>
            <span class="s2">if </span><span class="s1">(n.computed) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;[&quot;</span><span class="s1">, key, </span><span class="s0">&quot;]&quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">parts.push(key);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(!n.shorthand || n.key.name !== n.value.name) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;: &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;value&quot;</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s1">}</span>
        <span class="s2">case </span><span class="s0">&quot;ClassMethod&quot;</span><span class="s1">: </span><span class="s4">// Babel 6</span>
        <span class="s2">case </span><span class="s0">&quot;ObjectMethod&quot;</span><span class="s1">: </span><span class="s4">// Babel 6</span>
        <span class="s2">case </span><span class="s0">&quot;ClassPrivateMethod&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;TSDeclareMethod&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">printMethod(path, options, print);</span>
        <span class="s2">case </span><span class="s0">&quot;PrivateName&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span><span class="s0">&quot;#&quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;id&quot;</span><span class="s1">)]);</span>
        <span class="s2">case </span><span class="s0">&quot;Decorator&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span><span class="s0">&quot;@&quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;expression&quot;</span><span class="s1">)]);</span>
        <span class="s2">case </span><span class="s0">&quot;TupleExpression&quot;</span><span class="s1">:</span>
            <span class="s1">parts.push(</span><span class="s0">&quot;#&quot;</span><span class="s1">);</span>
        <span class="s4">// Intentionally fall through to printing the tuple elements...</span>
        <span class="s2">case </span><span class="s0">&quot;ArrayExpression&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;ArrayPattern&quot;</span><span class="s1">: {</span>
            <span class="s2">var </span><span class="s1">elems = n.elements;</span>
            <span class="s2">var </span><span class="s1">len_2 = elems.length;</span>
            <span class="s2">var </span><span class="s1">printed_1 = path.map(print, </span><span class="s0">&quot;elements&quot;</span><span class="s1">);</span>
            <span class="s2">var </span><span class="s1">joined = lines_1.fromString(</span><span class="s0">&quot;, &quot;</span><span class="s1">).join(printed_1);</span>
            <span class="s2">var </span><span class="s1">oneLine_2 = joined.getLineLength(</span><span class="s3">1</span><span class="s1">) &lt;= options.wrapColumn;</span>
            <span class="s2">if </span><span class="s1">(oneLine_2) {</span>
                <span class="s2">if </span><span class="s1">(options.arrayBracketSpacing) {</span>
                    <span class="s1">parts.push(</span><span class="s0">&quot;[ &quot;</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">parts.push(</span><span class="s0">&quot;[&quot;</span><span class="s1">);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;[</span><span class="s5">\n</span><span class="s0">&quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s1">path.each(</span><span class="s2">function </span><span class="s1">(elemPath) {</span>
                <span class="s2">var </span><span class="s1">i = elemPath.getName();</span>
                <span class="s2">var </span><span class="s1">elem = elemPath.getValue();</span>
                <span class="s2">if </span><span class="s1">(!elem) {</span>
                    <span class="s4">// If the array expression ends with a hole, that hole</span>
                    <span class="s4">// will be ignored by the interpreter, but if it ends with</span>
                    <span class="s4">// two (or more) holes, we need to write out two (or more)</span>
                    <span class="s4">// commas so that the resulting code is interpreted with</span>
                    <span class="s4">// both (all) of the holes.</span>
                    <span class="s1">parts.push(</span><span class="s0">&quot;,&quot;</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s2">var </span><span class="s1">lines = printed_1[i];</span>
                    <span class="s2">if </span><span class="s1">(oneLine_2) {</span>
                        <span class="s2">if </span><span class="s1">(i &gt; </span><span class="s3">0</span><span class="s1">)</span>
                            <span class="s1">parts.push(</span><span class="s0">&quot; &quot;</span><span class="s1">);</span>
                    <span class="s1">}</span>
                    <span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">lines = lines.indent(options.tabWidth);</span>
                    <span class="s1">}</span>
                    <span class="s1">parts.push(lines);</span>
                    <span class="s2">if </span><span class="s1">(i &lt; len_2 - </span><span class="s3">1 </span><span class="s1">||</span>
                        <span class="s1">(!oneLine_2 &amp;&amp; util.isTrailingCommaEnabled(options, </span><span class="s0">&quot;arrays&quot;</span><span class="s1">)))</span>
                        <span class="s1">parts.push(</span><span class="s0">&quot;,&quot;</span><span class="s1">);</span>
                    <span class="s2">if </span><span class="s1">(!oneLine_2)</span>
                        <span class="s1">parts.push(</span><span class="s0">&quot;</span><span class="s5">\n</span><span class="s0">&quot;</span><span class="s1">);</span>
                <span class="s1">}</span>
            <span class="s1">}, </span><span class="s0">&quot;elements&quot;</span><span class="s1">);</span>
            <span class="s2">if </span><span class="s1">(oneLine_2 &amp;&amp; options.arrayBracketSpacing) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot; ]&quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;]&quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(n.typeAnnotation) {</span>
                <span class="s1">parts.push(path.call(print, </span><span class="s0">&quot;typeAnnotation&quot;</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s1">}</span>
        <span class="s2">case </span><span class="s0">&quot;SequenceExpression&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot;, &quot;</span><span class="s1">).join(path.map(print, </span><span class="s0">&quot;expressions&quot;</span><span class="s1">));</span>
        <span class="s2">case </span><span class="s0">&quot;ThisExpression&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot;this&quot;</span><span class="s1">);</span>
        <span class="s2">case </span><span class="s0">&quot;Super&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot;super&quot;</span><span class="s1">);</span>
        <span class="s2">case </span><span class="s0">&quot;NullLiteral&quot;</span><span class="s1">: </span><span class="s4">// Babel 6 Literal split</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot;null&quot;</span><span class="s1">);</span>
        <span class="s2">case </span><span class="s0">&quot;RegExpLiteral&quot;</span><span class="s1">: </span><span class="s4">// Babel 6 Literal split</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(getPossibleRaw(n) || </span><span class="s0">&quot;/&quot; </span><span class="s1">+ n.pattern + </span><span class="s0">&quot;/&quot; </span><span class="s1">+ (n.flags || </span><span class="s0">&quot;&quot;</span><span class="s1">), options);</span>
        <span class="s2">case </span><span class="s0">&quot;BigIntLiteral&quot;</span><span class="s1">: </span><span class="s4">// Babel 7 Literal split</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(getPossibleRaw(n) || n.value + </span><span class="s0">&quot;n&quot;</span><span class="s1">, options);</span>
        <span class="s2">case </span><span class="s0">&quot;NumericLiteral&quot;</span><span class="s1">: </span><span class="s4">// Babel 6 Literal Split</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(getPossibleRaw(n) || n.value, options);</span>
        <span class="s2">case </span><span class="s0">&quot;DecimalLiteral&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(getPossibleRaw(n) || n.value + </span><span class="s0">&quot;m&quot;</span><span class="s1">, options);</span>
        <span class="s2">case </span><span class="s0">&quot;StringLiteral&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(nodeStr(n.value, options));</span>
        <span class="s2">case </span><span class="s0">&quot;BooleanLiteral&quot;</span><span class="s1">: </span><span class="s4">// Babel 6 Literal split</span>
        <span class="s2">case </span><span class="s0">&quot;Literal&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(getPossibleRaw(n) ||</span>
                <span class="s1">(</span><span class="s2">typeof </span><span class="s1">n.value === </span><span class="s0">&quot;string&quot; </span><span class="s1">? nodeStr(n.value, options) : n.value), options);</span>
        <span class="s2">case </span><span class="s0">&quot;Directive&quot;</span><span class="s1">: </span><span class="s4">// Babel 6</span>
            <span class="s2">return </span><span class="s1">path.call(print, </span><span class="s0">&quot;value&quot;</span><span class="s1">);</span>
        <span class="s2">case </span><span class="s0">&quot;DirectiveLiteral&quot;</span><span class="s1">: </span><span class="s4">// Babel 6</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(getPossibleRaw(n) || nodeStr(n.value, options), options);</span>
        <span class="s2">case </span><span class="s0">&quot;InterpreterDirective&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot;#!&quot; </span><span class="s1">+ n.value + </span><span class="s0">&quot;</span><span class="s5">\n</span><span class="s0">&quot;</span><span class="s1">, options);</span>
        <span class="s2">case </span><span class="s0">&quot;ModuleSpecifier&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">(n.local) {</span>
                <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">&quot;The ESTree ModuleSpecifier type should be abstract&quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s4">// The Esprima ModuleSpecifier type is just a string-valued</span>
            <span class="s4">// Literal identifying the imported-from module.</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(nodeStr(n.value, options), options);</span>
        <span class="s2">case </span><span class="s0">&quot;UnaryExpression&quot;</span><span class="s1">:</span>
            <span class="s1">parts.push(n.operator);</span>
            <span class="s2">if </span><span class="s1">(/[a-z]$/.test(n.operator))</span>
                <span class="s1">parts.push(</span><span class="s0">&quot; &quot;</span><span class="s1">);</span>
            <span class="s1">parts.push(path.call(print, </span><span class="s0">&quot;argument&quot;</span><span class="s1">));</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s2">case </span><span class="s0">&quot;UpdateExpression&quot;</span><span class="s1">:</span>
            <span class="s1">parts.push(path.call(print, </span><span class="s0">&quot;argument&quot;</span><span class="s1">), n.operator);</span>
            <span class="s2">if </span><span class="s1">(n.prefix)</span>
                <span class="s1">parts.reverse();</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s2">case </span><span class="s0">&quot;ConditionalExpression&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;test&quot;</span><span class="s1">),</span>
                <span class="s0">&quot; ? &quot;</span><span class="s1">,</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;consequent&quot;</span><span class="s1">),</span>
                <span class="s0">&quot; : &quot;</span><span class="s1">,</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;alternate&quot;</span><span class="s1">),</span>
            <span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;NewExpression&quot;</span><span class="s1">: {</span>
            <span class="s1">parts.push(</span><span class="s0">&quot;new &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;callee&quot;</span><span class="s1">));</span>
            <span class="s2">if </span><span class="s1">(n.typeParameters) {</span>
                <span class="s1">parts.push(path.call(print, </span><span class="s0">&quot;typeParameters&quot;</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(n.typeArguments) {</span>
                <span class="s1">parts.push(path.call(print, </span><span class="s0">&quot;typeArguments&quot;</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s2">var </span><span class="s1">args = n.arguments;</span>
            <span class="s2">if </span><span class="s1">(args) {</span>
                <span class="s1">parts.push(printArgumentsList(path, options, print));</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s1">}</span>
        <span class="s2">case </span><span class="s0">&quot;VariableDeclaration&quot;</span><span class="s1">: {</span>
            <span class="s2">if </span><span class="s1">(n.declare) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;declare &quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s1">parts.push(n.kind, </span><span class="s0">&quot; &quot;</span><span class="s1">);</span>
            <span class="s2">var </span><span class="s1">maxLen_1 = </span><span class="s3">0</span><span class="s1">;</span>
            <span class="s2">var </span><span class="s1">printed = path.map(</span><span class="s2">function </span><span class="s1">(childPath) {</span>
                <span class="s2">var </span><span class="s1">lines = print(childPath);</span>
                <span class="s1">maxLen_1 = Math.max(lines.length, maxLen_1);</span>
                <span class="s2">return </span><span class="s1">lines;</span>
            <span class="s1">}, </span><span class="s0">&quot;declarations&quot;</span><span class="s1">);</span>
            <span class="s2">if </span><span class="s1">(maxLen_1 === </span><span class="s3">1</span><span class="s1">) {</span>
                <span class="s1">parts.push(lines_1.fromString(</span><span class="s0">&quot;, &quot;</span><span class="s1">).join(printed));</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(printed.length &gt; </span><span class="s3">1</span><span class="s1">) {</span>
                <span class="s1">parts.push(lines_1.fromString(</span><span class="s0">&quot;,</span><span class="s5">\n</span><span class="s0">&quot;</span><span class="s1">)</span>
                    <span class="s1">.join(printed)</span>
                    <span class="s1">.indentTail(n.kind.length + </span><span class="s3">1</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">parts.push(printed[</span><span class="s3">0</span><span class="s1">]);</span>
            <span class="s1">}</span>
            <span class="s4">// We generally want to terminate all variable declarations with a</span>
            <span class="s4">// semicolon, except when they are children of for loops.</span>
            <span class="s2">var </span><span class="s1">parentNode = path.getParentNode();</span>
            <span class="s2">if </span><span class="s1">(!namedTypes.ForStatement.check(parentNode) &amp;&amp;</span>
                <span class="s1">!namedTypes.ForInStatement.check(parentNode) &amp;&amp;</span>
                <span class="s1">!(namedTypes.ForOfStatement &amp;&amp;</span>
                    <span class="s1">namedTypes.ForOfStatement.check(parentNode)) &amp;&amp;</span>
                <span class="s1">!(namedTypes.ForAwaitStatement &amp;&amp;</span>
                    <span class="s1">namedTypes.ForAwaitStatement.check(parentNode))) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;;&quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s1">}</span>
        <span class="s2">case </span><span class="s0">&quot;VariableDeclarator&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">n.init</span>
                <span class="s1">? lines_1.fromString(</span><span class="s0">&quot; = &quot;</span><span class="s1">).join([</span>
                    <span class="s1">path.call(print, </span><span class="s0">&quot;id&quot;</span><span class="s1">),</span>
                    <span class="s1">path.call(print, </span><span class="s0">&quot;init&quot;</span><span class="s1">),</span>
                <span class="s1">])</span>
                <span class="s1">: path.call(print, </span><span class="s0">&quot;id&quot;</span><span class="s1">);</span>
        <span class="s2">case </span><span class="s0">&quot;WithStatement&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span>
                <span class="s0">&quot;with (&quot;</span><span class="s1">,</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;object&quot;</span><span class="s1">),</span>
                <span class="s0">&quot;) &quot;</span><span class="s1">,</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;body&quot;</span><span class="s1">),</span>
            <span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;IfStatement&quot;</span><span class="s1">: {</span>
            <span class="s2">var </span><span class="s1">con = adjustClause(path.call(print, </span><span class="s0">&quot;consequent&quot;</span><span class="s1">), options);</span>
            <span class="s1">parts.push(</span><span class="s0">&quot;if (&quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;test&quot;</span><span class="s1">), </span><span class="s0">&quot;)&quot;</span><span class="s1">, con);</span>
            <span class="s2">if </span><span class="s1">(n.alternate)</span>
                <span class="s1">parts.push(endsWithBrace(con) ? </span><span class="s0">&quot; else&quot; </span><span class="s1">: </span><span class="s0">&quot;</span><span class="s5">\n</span><span class="s0">else&quot;</span><span class="s1">, adjustClause(path.call(print, </span><span class="s0">&quot;alternate&quot;</span><span class="s1">), options));</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s1">}</span>
        <span class="s2">case </span><span class="s0">&quot;ForStatement&quot;</span><span class="s1">: {</span>
            <span class="s4">// TODO Get the for (;;) case right.</span>
            <span class="s2">var </span><span class="s1">init = path.call(print, </span><span class="s0">&quot;init&quot;</span><span class="s1">);</span>
            <span class="s2">var </span><span class="s1">sep = init.length &gt; </span><span class="s3">1 </span><span class="s1">? </span><span class="s0">&quot;;</span><span class="s5">\n</span><span class="s0">&quot; </span><span class="s1">: </span><span class="s0">&quot;; &quot;</span><span class="s1">;</span>
            <span class="s2">var </span><span class="s1">forParen = </span><span class="s0">&quot;for (&quot;</span><span class="s1">;</span>
            <span class="s2">var </span><span class="s1">indented = lines_1.fromString(sep)</span>
                <span class="s1">.join([init, path.call(print, </span><span class="s0">&quot;test&quot;</span><span class="s1">), path.call(print, </span><span class="s0">&quot;update&quot;</span><span class="s1">)])</span>
                <span class="s1">.indentTail(forParen.length);</span>
            <span class="s2">var </span><span class="s1">head = lines_1.concat([forParen, indented, </span><span class="s0">&quot;)&quot;</span><span class="s1">]);</span>
            <span class="s2">var </span><span class="s1">clause = adjustClause(path.call(print, </span><span class="s0">&quot;body&quot;</span><span class="s1">), options);</span>
            <span class="s1">parts.push(head);</span>
            <span class="s2">if </span><span class="s1">(head.length &gt; </span><span class="s3">1</span><span class="s1">) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;</span><span class="s5">\n</span><span class="s0">&quot;</span><span class="s1">);</span>
                <span class="s1">clause = clause.trimLeft();</span>
            <span class="s1">}</span>
            <span class="s1">parts.push(clause);</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s1">}</span>
        <span class="s2">case </span><span class="s0">&quot;WhileStatement&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span>
                <span class="s0">&quot;while (&quot;</span><span class="s1">,</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;test&quot;</span><span class="s1">),</span>
                <span class="s0">&quot;)&quot;</span><span class="s1">,</span>
                <span class="s1">adjustClause(path.call(print, </span><span class="s0">&quot;body&quot;</span><span class="s1">), options),</span>
            <span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;ForInStatement&quot;</span><span class="s1">:</span>
            <span class="s4">// Note: esprima can't actually parse &quot;for each (&quot;.</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span>
                <span class="s1">n.each ? </span><span class="s0">&quot;for each (&quot; </span><span class="s1">: </span><span class="s0">&quot;for (&quot;</span><span class="s1">,</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;left&quot;</span><span class="s1">),</span>
                <span class="s0">&quot; in &quot;</span><span class="s1">,</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;right&quot;</span><span class="s1">),</span>
                <span class="s0">&quot;)&quot;</span><span class="s1">,</span>
                <span class="s1">adjustClause(path.call(print, </span><span class="s0">&quot;body&quot;</span><span class="s1">), options),</span>
            <span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;ForOfStatement&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;ForAwaitStatement&quot;</span><span class="s1">:</span>
            <span class="s1">parts.push(</span><span class="s0">&quot;for &quot;</span><span class="s1">);</span>
            <span class="s2">if </span><span class="s1">(n.await || n.type === </span><span class="s0">&quot;ForAwaitStatement&quot;</span><span class="s1">) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;await &quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s1">parts.push(</span><span class="s0">&quot;(&quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;left&quot;</span><span class="s1">), </span><span class="s0">&quot; of &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;right&quot;</span><span class="s1">), </span><span class="s0">&quot;)&quot;</span><span class="s1">, adjustClause(path.call(print, </span><span class="s0">&quot;body&quot;</span><span class="s1">), options));</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s2">case </span><span class="s0">&quot;DoWhileStatement&quot;</span><span class="s1">: {</span>
            <span class="s2">var </span><span class="s1">doBody = lines_1.concat([</span>
                <span class="s0">&quot;do&quot;</span><span class="s1">,</span>
                <span class="s1">adjustClause(path.call(print, </span><span class="s0">&quot;body&quot;</span><span class="s1">), options),</span>
            <span class="s1">]);</span>
            <span class="s1">parts.push(doBody);</span>
            <span class="s2">if </span><span class="s1">(endsWithBrace(doBody))</span>
                <span class="s1">parts.push(</span><span class="s0">&quot; while&quot;</span><span class="s1">);</span>
            <span class="s2">else</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;</span><span class="s5">\n</span><span class="s0">while&quot;</span><span class="s1">);</span>
            <span class="s1">parts.push(</span><span class="s0">&quot; (&quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;test&quot;</span><span class="s1">), </span><span class="s0">&quot;);&quot;</span><span class="s1">);</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s1">}</span>
        <span class="s2">case </span><span class="s0">&quot;DoExpression&quot;</span><span class="s1">: {</span>
            <span class="s2">var </span><span class="s1">statements = path.call(</span><span class="s2">function </span><span class="s1">(bodyPath) { </span><span class="s2">return </span><span class="s1">printStatementSequence(bodyPath, options, print); }, </span><span class="s0">&quot;body&quot;</span><span class="s1">);</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span><span class="s0">&quot;do {</span><span class="s5">\n</span><span class="s0">&quot;</span><span class="s1">, statements.indent(options.tabWidth), </span><span class="s0">&quot;</span><span class="s5">\n</span><span class="s0">}&quot;</span><span class="s1">]);</span>
        <span class="s1">}</span>
        <span class="s2">case </span><span class="s0">&quot;BreakStatement&quot;</span><span class="s1">:</span>
            <span class="s1">parts.push(</span><span class="s0">&quot;break&quot;</span><span class="s1">);</span>
            <span class="s2">if </span><span class="s1">(n.label)</span>
                <span class="s1">parts.push(</span><span class="s0">&quot; &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;label&quot;</span><span class="s1">));</span>
            <span class="s1">parts.push(</span><span class="s0">&quot;;&quot;</span><span class="s1">);</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s2">case </span><span class="s0">&quot;ContinueStatement&quot;</span><span class="s1">:</span>
            <span class="s1">parts.push(</span><span class="s0">&quot;continue&quot;</span><span class="s1">);</span>
            <span class="s2">if </span><span class="s1">(n.label)</span>
                <span class="s1">parts.push(</span><span class="s0">&quot; &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;label&quot;</span><span class="s1">));</span>
            <span class="s1">parts.push(</span><span class="s0">&quot;;&quot;</span><span class="s1">);</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s2">case </span><span class="s0">&quot;LabeledStatement&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;label&quot;</span><span class="s1">),</span>
                <span class="s0">&quot;:</span><span class="s5">\n</span><span class="s0">&quot;</span><span class="s1">,</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;body&quot;</span><span class="s1">),</span>
            <span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;TryStatement&quot;</span><span class="s1">:</span>
            <span class="s1">parts.push(</span><span class="s0">&quot;try &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;block&quot;</span><span class="s1">));</span>
            <span class="s2">if </span><span class="s1">(n.handler) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot; &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;handler&quot;</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(n.handlers) {</span>
                <span class="s1">path.each(</span><span class="s2">function </span><span class="s1">(handlerPath) {</span>
                    <span class="s1">parts.push(</span><span class="s0">&quot; &quot;</span><span class="s1">, print(handlerPath));</span>
                <span class="s1">}, </span><span class="s0">&quot;handlers&quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(n.finalizer) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot; finally &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;finalizer&quot;</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s2">case </span><span class="s0">&quot;CatchClause&quot;</span><span class="s1">:</span>
            <span class="s1">parts.push(</span><span class="s0">&quot;catch &quot;</span><span class="s1">);</span>
            <span class="s2">if </span><span class="s1">(n.param) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;(&quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;param&quot;</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(n.guard) {</span>
                <span class="s4">// Note: esprima does not recognize conditional catch clauses.</span>
                <span class="s1">parts.push(</span><span class="s0">&quot; if &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;guard&quot;</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(n.param) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;) &quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s1">parts.push(path.call(print, </span><span class="s0">&quot;body&quot;</span><span class="s1">));</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s2">case </span><span class="s0">&quot;ThrowStatement&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span><span class="s0">&quot;throw &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;argument&quot;</span><span class="s1">), </span><span class="s0">&quot;;&quot;</span><span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;SwitchStatement&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span>
                <span class="s0">&quot;switch (&quot;</span><span class="s1">,</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;discriminant&quot;</span><span class="s1">),</span>
                <span class="s0">&quot;) {</span><span class="s5">\n</span><span class="s0">&quot;</span><span class="s1">,</span>
                <span class="s1">lines_1.fromString(</span><span class="s0">&quot;</span><span class="s5">\n</span><span class="s0">&quot;</span><span class="s1">).join(path.map(print, </span><span class="s0">&quot;cases&quot;</span><span class="s1">)),</span>
                <span class="s0">&quot;</span><span class="s5">\n</span><span class="s0">}&quot;</span><span class="s1">,</span>
            <span class="s1">]);</span>
        <span class="s4">// Note: ignoring n.lexical because it has no printing consequences.</span>
        <span class="s2">case </span><span class="s0">&quot;SwitchCase&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">(n.test)</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;case &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;test&quot;</span><span class="s1">), </span><span class="s0">&quot;:&quot;</span><span class="s1">);</span>
            <span class="s2">else</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;default:&quot;</span><span class="s1">);</span>
            <span class="s2">if </span><span class="s1">(n.consequent.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;</span><span class="s5">\n</span><span class="s0">&quot;</span><span class="s1">, path</span>
                    <span class="s1">.call(</span><span class="s2">function </span><span class="s1">(consequentPath) {</span>
                    <span class="s2">return </span><span class="s1">printStatementSequence(consequentPath, options, print);</span>
                <span class="s1">}, </span><span class="s0">&quot;consequent&quot;</span><span class="s1">)</span>
                    <span class="s1">.indent(options.tabWidth));</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s2">case </span><span class="s0">&quot;DebuggerStatement&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot;debugger;&quot;</span><span class="s1">);</span>
        <span class="s4">// JSX extensions below.</span>
        <span class="s2">case </span><span class="s0">&quot;JSXAttribute&quot;</span><span class="s1">:</span>
            <span class="s1">parts.push(path.call(print, </span><span class="s0">&quot;name&quot;</span><span class="s1">));</span>
            <span class="s2">if </span><span class="s1">(n.value)</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;=&quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;value&quot;</span><span class="s1">));</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s2">case </span><span class="s0">&quot;JSXIdentifier&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(n.name, options);</span>
        <span class="s2">case </span><span class="s0">&quot;JSXNamespacedName&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot;:&quot;</span><span class="s1">).join([</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;namespace&quot;</span><span class="s1">),</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;name&quot;</span><span class="s1">),</span>
            <span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;JSXMemberExpression&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot;.&quot;</span><span class="s1">).join([</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;object&quot;</span><span class="s1">),</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;property&quot;</span><span class="s1">),</span>
            <span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;JSXSpreadAttribute&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span><span class="s0">&quot;{...&quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;argument&quot;</span><span class="s1">), </span><span class="s0">&quot;}&quot;</span><span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;JSXSpreadChild&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span><span class="s0">&quot;{...&quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;expression&quot;</span><span class="s1">), </span><span class="s0">&quot;}&quot;</span><span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;JSXExpressionContainer&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span><span class="s0">&quot;{&quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;expression&quot;</span><span class="s1">), </span><span class="s0">&quot;}&quot;</span><span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;JSXElement&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;JSXFragment&quot;</span><span class="s1">: {</span>
            <span class="s2">var </span><span class="s1">openingPropName = </span><span class="s0">&quot;opening&quot; </span><span class="s1">+ (n.type === </span><span class="s0">&quot;JSXElement&quot; </span><span class="s1">? </span><span class="s0">&quot;Element&quot; </span><span class="s1">: </span><span class="s0">&quot;Fragment&quot;</span><span class="s1">);</span>
            <span class="s2">var </span><span class="s1">closingPropName = </span><span class="s0">&quot;closing&quot; </span><span class="s1">+ (n.type === </span><span class="s0">&quot;JSXElement&quot; </span><span class="s1">? </span><span class="s0">&quot;Element&quot; </span><span class="s1">: </span><span class="s0">&quot;Fragment&quot;</span><span class="s1">);</span>
            <span class="s2">var </span><span class="s1">openingLines = path.call(print, openingPropName);</span>
            <span class="s2">if </span><span class="s1">(n[openingPropName].selfClosing) {</span>
                <span class="s1">assert_1.</span><span class="s2">default</span><span class="s1">.ok(!n[closingPropName], </span><span class="s0">&quot;unexpected &quot; </span><span class="s1">+</span>
                    <span class="s1">closingPropName +</span>
                    <span class="s0">&quot; element in self-closing &quot; </span><span class="s1">+</span>
                    <span class="s1">n.type);</span>
                <span class="s2">return </span><span class="s1">openingLines;</span>
            <span class="s1">}</span>
            <span class="s2">var </span><span class="s1">childLines = lines_1.concat(path.map(</span><span class="s2">function </span><span class="s1">(childPath) {</span>
                <span class="s2">var </span><span class="s1">child = childPath.getValue();</span>
                <span class="s2">if </span><span class="s1">(namedTypes.Literal.check(child) &amp;&amp;</span>
                    <span class="s2">typeof </span><span class="s1">child.value === </span><span class="s0">&quot;string&quot;</span><span class="s1">) {</span>
                    <span class="s2">if </span><span class="s1">(/\S/.test(child.value)) {</span>
                        <span class="s2">return </span><span class="s1">child.value.replace(/^\s+|\s+$/g, </span><span class="s0">&quot;&quot;</span><span class="s1">);</span>
                    <span class="s1">}</span>
                    <span class="s2">else if </span><span class="s1">(/\n/.test(child.value)) {</span>
                        <span class="s2">return </span><span class="s0">&quot;</span><span class="s5">\n</span><span class="s0">&quot;</span><span class="s1">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">print(childPath);</span>
            <span class="s1">}, </span><span class="s0">&quot;children&quot;</span><span class="s1">)).indentTail(options.tabWidth);</span>
            <span class="s2">var </span><span class="s1">closingLines = path.call(print, closingPropName);</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([openingLines, childLines, closingLines]);</span>
        <span class="s1">}</span>
        <span class="s2">case </span><span class="s0">&quot;JSXOpeningElement&quot;</span><span class="s1">: {</span>
            <span class="s1">parts.push(</span><span class="s0">&quot;&lt;&quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;name&quot;</span><span class="s1">));</span>
            <span class="s2">var </span><span class="s1">attrParts_1 = [];</span>
            <span class="s1">path.each(</span><span class="s2">function </span><span class="s1">(attrPath) {</span>
                <span class="s1">attrParts_1.push(</span><span class="s0">&quot; &quot;</span><span class="s1">, print(attrPath));</span>
            <span class="s1">}, </span><span class="s0">&quot;attributes&quot;</span><span class="s1">);</span>
            <span class="s2">var </span><span class="s1">attrLines = lines_1.concat(attrParts_1);</span>
            <span class="s2">var </span><span class="s1">needLineWrap = attrLines.length &gt; </span><span class="s3">1 </span><span class="s1">|| attrLines.getLineLength(</span><span class="s3">1</span><span class="s1">) &gt; options.wrapColumn;</span>
            <span class="s2">if </span><span class="s1">(needLineWrap) {</span>
                <span class="s1">attrParts_1.forEach(</span><span class="s2">function </span><span class="s1">(part, i) {</span>
                    <span class="s2">if </span><span class="s1">(part === </span><span class="s0">&quot; &quot;</span><span class="s1">) {</span>
                        <span class="s1">assert_1.</span><span class="s2">default</span><span class="s1">.strictEqual(i % </span><span class="s3">2</span><span class="s1">, </span><span class="s3">0</span><span class="s1">);</span>
                        <span class="s1">attrParts_1[i] = </span><span class="s0">&quot;</span><span class="s5">\n</span><span class="s0">&quot;</span><span class="s1">;</span>
                    <span class="s1">}</span>
                <span class="s1">});</span>
                <span class="s1">attrLines = lines_1.concat(attrParts_1).indentTail(options.tabWidth);</span>
            <span class="s1">}</span>
            <span class="s1">parts.push(attrLines, n.selfClosing ? </span><span class="s0">&quot; /&gt;&quot; </span><span class="s1">: </span><span class="s0">&quot;&gt;&quot;</span><span class="s1">);</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s1">}</span>
        <span class="s2">case </span><span class="s0">&quot;JSXClosingElement&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span><span class="s0">&quot;&lt;/&quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;name&quot;</span><span class="s1">), </span><span class="s0">&quot;&gt;&quot;</span><span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;JSXOpeningFragment&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot;&lt;&gt;&quot;</span><span class="s1">);</span>
        <span class="s2">case </span><span class="s0">&quot;JSXClosingFragment&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot;&lt;/&gt;&quot;</span><span class="s1">);</span>
        <span class="s2">case </span><span class="s0">&quot;JSXText&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(n.value, options);</span>
        <span class="s2">case </span><span class="s0">&quot;JSXEmptyExpression&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot;&quot;</span><span class="s1">);</span>
        <span class="s2">case </span><span class="s0">&quot;TypeAnnotatedIdentifier&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;annotation&quot;</span><span class="s1">),</span>
                <span class="s0">&quot; &quot;</span><span class="s1">,</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;identifier&quot;</span><span class="s1">),</span>
            <span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;ClassBody&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">(n.body.length === </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot;{}&quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span>
                <span class="s0">&quot;{</span><span class="s5">\n</span><span class="s0">&quot;</span><span class="s1">,</span>
                <span class="s1">path</span>
                    <span class="s1">.call(</span><span class="s2">function </span><span class="s1">(bodyPath) { </span><span class="s2">return </span><span class="s1">printStatementSequence(bodyPath, options, print); }, </span><span class="s0">&quot;body&quot;</span><span class="s1">)</span>
                    <span class="s1">.indent(options.tabWidth),</span>
                <span class="s0">&quot;</span><span class="s5">\n</span><span class="s0">}&quot;</span><span class="s1">,</span>
            <span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;ClassPropertyDefinition&quot;</span><span class="s1">:</span>
            <span class="s1">parts.push(</span><span class="s0">&quot;static &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;definition&quot;</span><span class="s1">));</span>
            <span class="s2">if </span><span class="s1">(!namedTypes.MethodDefinition.check(n.definition))</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;;&quot;</span><span class="s1">);</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s2">case </span><span class="s0">&quot;ClassProperty&quot;</span><span class="s1">: {</span>
            <span class="s2">if </span><span class="s1">(n.declare) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;declare &quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">var </span><span class="s1">access = n.accessibility || n.access;</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">access === </span><span class="s0">&quot;string&quot;</span><span class="s1">) {</span>
                <span class="s1">parts.push(access, </span><span class="s0">&quot; &quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(n.static) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;static &quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(n.abstract) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;abstract &quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(n.readonly) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;readonly &quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">var </span><span class="s1">key = path.call(print, </span><span class="s0">&quot;key&quot;</span><span class="s1">);</span>
            <span class="s2">if </span><span class="s1">(n.computed) {</span>
                <span class="s1">key = lines_1.concat([</span><span class="s0">&quot;[&quot;</span><span class="s1">, key, </span><span class="s0">&quot;]&quot;</span><span class="s1">]);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(n.variance) {</span>
                <span class="s1">key = lines_1.concat([printVariance(path, print), key]);</span>
            <span class="s1">}</span>
            <span class="s1">parts.push(key);</span>
            <span class="s2">if </span><span class="s1">(n.optional) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;?&quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(n.definite) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;!&quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(n.typeAnnotation) {</span>
                <span class="s1">parts.push(path.call(print, </span><span class="s0">&quot;typeAnnotation&quot;</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(n.value) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot; = &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;value&quot;</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s1">parts.push(</span><span class="s0">&quot;;&quot;</span><span class="s1">);</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s1">}</span>
        <span class="s2">case </span><span class="s0">&quot;ClassPrivateProperty&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">(n.static) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;static &quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s1">parts.push(path.call(print, </span><span class="s0">&quot;key&quot;</span><span class="s1">));</span>
            <span class="s2">if </span><span class="s1">(n.typeAnnotation) {</span>
                <span class="s1">parts.push(path.call(print, </span><span class="s0">&quot;typeAnnotation&quot;</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(n.value) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot; = &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;value&quot;</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s1">parts.push(</span><span class="s0">&quot;;&quot;</span><span class="s1">);</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s2">case </span><span class="s0">&quot;ClassDeclaration&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;ClassExpression&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;DeclareClass&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">(n.declare) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;declare &quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(n.abstract) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;abstract &quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s1">parts.push(</span><span class="s0">&quot;class&quot;</span><span class="s1">);</span>
            <span class="s2">if </span><span class="s1">(n.id) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot; &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;id&quot;</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(n.typeParameters) {</span>
                <span class="s1">parts.push(path.call(print, </span><span class="s0">&quot;typeParameters&quot;</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(n.superClass) {</span>
                <span class="s4">// ClassDeclaration and ClassExpression only</span>
                <span class="s1">parts.push(</span><span class="s0">&quot; extends &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;superClass&quot;</span><span class="s1">), path.call(print, </span><span class="s0">&quot;superTypeParameters&quot;</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(n.extends &amp;&amp; n.extends.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s4">// DeclareClass only</span>
                <span class="s1">parts.push(</span><span class="s0">&quot; extends &quot;</span><span class="s1">, lines_1.fromString(</span><span class="s0">&quot;, &quot;</span><span class="s1">).join(path.map(print, </span><span class="s0">&quot;extends&quot;</span><span class="s1">)));</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(n[</span><span class="s0">&quot;implements&quot;</span><span class="s1">] &amp;&amp; n[</span><span class="s0">&quot;implements&quot;</span><span class="s1">].length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot; implements &quot;</span><span class="s1">, lines_1.fromString(</span><span class="s0">&quot;, &quot;</span><span class="s1">).join(path.map(print, </span><span class="s0">&quot;implements&quot;</span><span class="s1">)));</span>
            <span class="s1">}</span>
            <span class="s1">parts.push(</span><span class="s0">&quot; &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;body&quot;</span><span class="s1">));</span>
            <span class="s2">if </span><span class="s1">(n.type === </span><span class="s0">&quot;DeclareClass&quot;</span><span class="s1">) {</span>
                <span class="s2">return </span><span class="s1">printFlowDeclaration(path, parts);</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
            <span class="s1">}</span>
        <span class="s2">case </span><span class="s0">&quot;TemplateElement&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(n.value.raw, options).lockIndentTail();</span>
        <span class="s2">case </span><span class="s0">&quot;TemplateLiteral&quot;</span><span class="s1">: {</span>
            <span class="s2">var </span><span class="s1">expressions_1 = path.map(print, </span><span class="s0">&quot;expressions&quot;</span><span class="s1">);</span>
            <span class="s1">parts.push(</span><span class="s0">&quot;`&quot;</span><span class="s1">);</span>
            <span class="s1">path.each(</span><span class="s2">function </span><span class="s1">(childPath) {</span>
                <span class="s2">var </span><span class="s1">i = childPath.getName();</span>
                <span class="s1">parts.push(print(childPath));</span>
                <span class="s2">if </span><span class="s1">(i &lt; expressions_1.length) {</span>
                    <span class="s1">parts.push(</span><span class="s0">&quot;${&quot;</span><span class="s1">, expressions_1[i], </span><span class="s0">&quot;}&quot;</span><span class="s1">);</span>
                <span class="s1">}</span>
            <span class="s1">}, </span><span class="s0">&quot;quasis&quot;</span><span class="s1">);</span>
            <span class="s1">parts.push(</span><span class="s0">&quot;`&quot;</span><span class="s1">);</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts).lockIndentTail();</span>
        <span class="s1">}</span>
        <span class="s2">case </span><span class="s0">&quot;TaggedTemplateExpression&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([path.call(print, </span><span class="s0">&quot;tag&quot;</span><span class="s1">), path.call(print, </span><span class="s0">&quot;quasi&quot;</span><span class="s1">)]);</span>
        <span class="s4">// These types are unprintable because they serve as abstract</span>
        <span class="s4">// supertypes for other (printable) types.</span>
        <span class="s2">case </span><span class="s0">&quot;Node&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;Printable&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;SourceLocation&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;Position&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;Statement&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;Function&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;Pattern&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;Expression&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;Declaration&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;Specifier&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;NamedSpecifier&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;Comment&quot;</span><span class="s1">: </span><span class="s4">// Supertype of Block and Line</span>
        <span class="s2">case </span><span class="s0">&quot;Flow&quot;</span><span class="s1">: </span><span class="s4">// Supertype of all Flow AST node types</span>
        <span class="s2">case </span><span class="s0">&quot;FlowType&quot;</span><span class="s1">: </span><span class="s4">// Supertype of all Flow types</span>
        <span class="s2">case </span><span class="s0">&quot;FlowPredicate&quot;</span><span class="s1">: </span><span class="s4">// Supertype of InferredPredicate and DeclaredPredicate</span>
        <span class="s2">case </span><span class="s0">&quot;MemberTypeAnnotation&quot;</span><span class="s1">: </span><span class="s4">// Flow</span>
        <span class="s2">case </span><span class="s0">&quot;Type&quot;</span><span class="s1">: </span><span class="s4">// Flow</span>
        <span class="s2">case </span><span class="s0">&quot;TSHasOptionalTypeParameterInstantiation&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;TSHasOptionalTypeParameters&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;TSHasOptionalTypeAnnotation&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;ChainElement&quot;</span><span class="s1">: </span><span class="s4">// Supertype of MemberExpression and CallExpression</span>
            <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">&quot;unprintable type: &quot; </span><span class="s1">+ JSON.stringify(n.type));</span>
        <span class="s2">case </span><span class="s0">&quot;CommentBlock&quot;</span><span class="s1">: </span><span class="s4">// Babel block comment.</span>
        <span class="s2">case </span><span class="s0">&quot;Block&quot;</span><span class="s1">: </span><span class="s4">// Esprima block comment.</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span><span class="s0">&quot;/*&quot;</span><span class="s1">, lines_1.fromString(n.value, options), </span><span class="s0">&quot;*/&quot;</span><span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;CommentLine&quot;</span><span class="s1">: </span><span class="s4">// Babel line comment.</span>
        <span class="s2">case </span><span class="s0">&quot;Line&quot;</span><span class="s1">: </span><span class="s4">// Esprima line comment.</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span><span class="s0">&quot;//&quot;</span><span class="s1">, lines_1.fromString(n.value, options)]);</span>
        <span class="s4">// Type Annotations for Facebook Flow, typically stripped out or</span>
        <span class="s4">// transformed away before printing.</span>
        <span class="s2">case </span><span class="s0">&quot;TypeAnnotation&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">(n.typeAnnotation) {</span>
                <span class="s2">if </span><span class="s1">(n.typeAnnotation.type !== </span><span class="s0">&quot;FunctionTypeAnnotation&quot;</span><span class="s1">) {</span>
                    <span class="s1">parts.push(</span><span class="s0">&quot;: &quot;</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s1">parts.push(path.call(print, </span><span class="s0">&quot;typeAnnotation&quot;</span><span class="s1">));</span>
                <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot;&quot;</span><span class="s1">);</span>
        <span class="s2">case </span><span class="s0">&quot;ExistentialTypeParam&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;ExistsTypeAnnotation&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot;*&quot;</span><span class="s1">, options);</span>
        <span class="s2">case </span><span class="s0">&quot;EmptyTypeAnnotation&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot;empty&quot;</span><span class="s1">, options);</span>
        <span class="s2">case </span><span class="s0">&quot;AnyTypeAnnotation&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot;any&quot;</span><span class="s1">, options);</span>
        <span class="s2">case </span><span class="s0">&quot;MixedTypeAnnotation&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot;mixed&quot;</span><span class="s1">, options);</span>
        <span class="s2">case </span><span class="s0">&quot;ArrayTypeAnnotation&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([path.call(print, </span><span class="s0">&quot;elementType&quot;</span><span class="s1">), </span><span class="s0">&quot;[]&quot;</span><span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;TupleTypeAnnotation&quot;</span><span class="s1">: {</span>
            <span class="s2">var </span><span class="s1">printed_2 = path.map(print, </span><span class="s0">&quot;types&quot;</span><span class="s1">);</span>
            <span class="s2">var </span><span class="s1">joined = lines_1.fromString(</span><span class="s0">&quot;, &quot;</span><span class="s1">).join(printed_2);</span>
            <span class="s2">var </span><span class="s1">oneLine_3 = joined.getLineLength(</span><span class="s3">1</span><span class="s1">) &lt;= options.wrapColumn;</span>
            <span class="s2">if </span><span class="s1">(oneLine_3) {</span>
                <span class="s2">if </span><span class="s1">(options.arrayBracketSpacing) {</span>
                    <span class="s1">parts.push(</span><span class="s0">&quot;[ &quot;</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">parts.push(</span><span class="s0">&quot;[&quot;</span><span class="s1">);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;[</span><span class="s5">\n</span><span class="s0">&quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s1">path.each(</span><span class="s2">function </span><span class="s1">(elemPath) {</span>
                <span class="s2">var </span><span class="s1">i = elemPath.getName();</span>
                <span class="s2">var </span><span class="s1">elem = elemPath.getValue();</span>
                <span class="s2">if </span><span class="s1">(!elem) {</span>
                    <span class="s4">// If the array expression ends with a hole, that hole</span>
                    <span class="s4">// will be ignored by the interpreter, but if it ends with</span>
                    <span class="s4">// two (or more) holes, we need to write out two (or more)</span>
                    <span class="s4">// commas so that the resulting code is interpreted with</span>
                    <span class="s4">// both (all) of the holes.</span>
                    <span class="s1">parts.push(</span><span class="s0">&quot;,&quot;</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s2">var </span><span class="s1">lines = printed_2[i];</span>
                    <span class="s2">if </span><span class="s1">(oneLine_3) {</span>
                        <span class="s2">if </span><span class="s1">(i &gt; </span><span class="s3">0</span><span class="s1">)</span>
                            <span class="s1">parts.push(</span><span class="s0">&quot; &quot;</span><span class="s1">);</span>
                    <span class="s1">}</span>
                    <span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">lines = lines.indent(options.tabWidth);</span>
                    <span class="s1">}</span>
                    <span class="s1">parts.push(lines);</span>
                    <span class="s2">if </span><span class="s1">(i &lt; n.types.length - </span><span class="s3">1 </span><span class="s1">||</span>
                        <span class="s1">(!oneLine_3 &amp;&amp; util.isTrailingCommaEnabled(options, </span><span class="s0">&quot;arrays&quot;</span><span class="s1">)))</span>
                        <span class="s1">parts.push(</span><span class="s0">&quot;,&quot;</span><span class="s1">);</span>
                    <span class="s2">if </span><span class="s1">(!oneLine_3)</span>
                        <span class="s1">parts.push(</span><span class="s0">&quot;</span><span class="s5">\n</span><span class="s0">&quot;</span><span class="s1">);</span>
                <span class="s1">}</span>
            <span class="s1">}, </span><span class="s0">&quot;types&quot;</span><span class="s1">);</span>
            <span class="s2">if </span><span class="s1">(oneLine_3 &amp;&amp; options.arrayBracketSpacing) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot; ]&quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;]&quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s1">}</span>
        <span class="s2">case </span><span class="s0">&quot;BooleanTypeAnnotation&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot;boolean&quot;</span><span class="s1">, options);</span>
        <span class="s2">case </span><span class="s0">&quot;BooleanLiteralTypeAnnotation&quot;</span><span class="s1">:</span>
            <span class="s1">assert_1.</span><span class="s2">default</span><span class="s1">.strictEqual(</span><span class="s2">typeof </span><span class="s1">n.value, </span><span class="s0">&quot;boolean&quot;</span><span class="s1">);</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot;&quot; </span><span class="s1">+ n.value, options);</span>
        <span class="s2">case </span><span class="s0">&quot;InterfaceTypeAnnotation&quot;</span><span class="s1">:</span>
            <span class="s1">parts.push(</span><span class="s0">&quot;interface&quot;</span><span class="s1">);</span>
            <span class="s2">if </span><span class="s1">(n.extends &amp;&amp; n.extends.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot; extends &quot;</span><span class="s1">, lines_1.fromString(</span><span class="s0">&quot;, &quot;</span><span class="s1">).join(path.map(print, </span><span class="s0">&quot;extends&quot;</span><span class="s1">)));</span>
            <span class="s1">}</span>
            <span class="s1">parts.push(</span><span class="s0">&quot; &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;body&quot;</span><span class="s1">));</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s2">case </span><span class="s0">&quot;DeclareFunction&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">printFlowDeclaration(path, [</span>
                <span class="s0">&quot;function &quot;</span><span class="s1">,</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;id&quot;</span><span class="s1">),</span>
                <span class="s0">&quot;;&quot;</span><span class="s1">,</span>
            <span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;DeclareModule&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">printFlowDeclaration(path, [</span>
                <span class="s0">&quot;module &quot;</span><span class="s1">,</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;id&quot;</span><span class="s1">),</span>
                <span class="s0">&quot; &quot;</span><span class="s1">,</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;body&quot;</span><span class="s1">),</span>
            <span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;DeclareModuleExports&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">printFlowDeclaration(path, [</span>
                <span class="s0">&quot;module.exports&quot;</span><span class="s1">,</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;typeAnnotation&quot;</span><span class="s1">),</span>
            <span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;DeclareVariable&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">printFlowDeclaration(path, [</span><span class="s0">&quot;var &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;id&quot;</span><span class="s1">), </span><span class="s0">&quot;;&quot;</span><span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;DeclareExportDeclaration&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;DeclareExportAllDeclaration&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span><span class="s0">&quot;declare &quot;</span><span class="s1">, printExportDeclaration(path, options, print)]);</span>
        <span class="s2">case </span><span class="s0">&quot;EnumDeclaration&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span>
                <span class="s0">&quot;enum &quot;</span><span class="s1">,</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;id&quot;</span><span class="s1">),</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;body&quot;</span><span class="s1">),</span>
            <span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;EnumBooleanBody&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;EnumNumberBody&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;EnumStringBody&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;EnumSymbolBody&quot;</span><span class="s1">: {</span>
            <span class="s2">if </span><span class="s1">(n.type === </span><span class="s0">&quot;EnumSymbolBody&quot; </span><span class="s1">|| n.explicitType) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot; of &quot;</span><span class="s1">, </span>
                <span class="s4">// EnumBooleanBody =&gt; boolean, etc.</span>
                <span class="s1">n.type.slice(</span><span class="s3">4</span><span class="s1">, -</span><span class="s3">4</span><span class="s1">).toLowerCase());</span>
            <span class="s1">}</span>
            <span class="s1">parts.push(</span><span class="s0">&quot; {</span><span class="s5">\n</span><span class="s0">&quot;</span><span class="s1">, lines_1.fromString(</span><span class="s0">&quot;</span><span class="s5">\n</span><span class="s0">&quot;</span><span class="s1">)</span>
                <span class="s1">.join(path.map(print, </span><span class="s0">&quot;members&quot;</span><span class="s1">))</span>
                <span class="s1">.indent(options.tabWidth), </span><span class="s0">&quot;</span><span class="s5">\n</span><span class="s0">}&quot;</span><span class="s1">);</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s1">}</span>
        <span class="s2">case </span><span class="s0">&quot;EnumDefaultedMember&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([path.call(print, </span><span class="s0">&quot;id&quot;</span><span class="s1">), </span><span class="s0">&quot;,&quot;</span><span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;EnumBooleanMember&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;EnumNumberMember&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;EnumStringMember&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;id&quot;</span><span class="s1">),</span>
                <span class="s0">&quot; = &quot;</span><span class="s1">,</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;init&quot;</span><span class="s1">),</span>
                <span class="s0">&quot;,&quot;</span><span class="s1">,</span>
            <span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;InferredPredicate&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot;%checks&quot;</span><span class="s1">, options);</span>
        <span class="s2">case </span><span class="s0">&quot;DeclaredPredicate&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span><span class="s0">&quot;%checks(&quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;value&quot;</span><span class="s1">), </span><span class="s0">&quot;)&quot;</span><span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;FunctionTypeAnnotation&quot;</span><span class="s1">: {</span>
            <span class="s4">// FunctionTypeAnnotation is ambiguous:</span>
            <span class="s4">// declare function(a: B): void; OR</span>
            <span class="s4">// const A: (a: B) =&gt; void;</span>
            <span class="s2">var </span><span class="s1">parent = path.getParentNode(</span><span class="s3">0</span><span class="s1">);</span>
            <span class="s2">var </span><span class="s1">isArrowFunctionTypeAnnotation = !(namedTypes.ObjectTypeCallProperty.check(parent) ||</span>
                <span class="s1">(namedTypes.ObjectTypeInternalSlot.check(parent) &amp;&amp; parent.method) ||</span>
                <span class="s1">namedTypes.DeclareFunction.check(path.getParentNode(</span><span class="s3">2</span><span class="s1">)));</span>
            <span class="s2">var </span><span class="s1">needsColon = isArrowFunctionTypeAnnotation &amp;&amp;</span>
                <span class="s1">!namedTypes.FunctionTypeParam.check(parent) &amp;&amp;</span>
                <span class="s1">!namedTypes.TypeAlias.check(parent);</span>
            <span class="s2">if </span><span class="s1">(needsColon) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;: &quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">var </span><span class="s1">hasTypeParameters = !!n.typeParameters;</span>
            <span class="s2">var </span><span class="s1">needsParens = hasTypeParameters || n.params.length !== </span><span class="s3">1 </span><span class="s1">|| n.params[</span><span class="s3">0</span><span class="s1">].name;</span>
            <span class="s1">parts.push(hasTypeParameters ? path.call(print, </span><span class="s0">&quot;typeParameters&quot;</span><span class="s1">) : </span><span class="s0">&quot;&quot;</span><span class="s1">, needsParens ? </span><span class="s0">&quot;(&quot; </span><span class="s1">: </span><span class="s0">&quot;&quot;</span><span class="s1">, printFunctionParams(path, options, print), needsParens ? </span><span class="s0">&quot;)&quot; </span><span class="s1">: </span><span class="s0">&quot;&quot;</span><span class="s1">);</span>
            <span class="s4">// The returnType is not wrapped in a TypeAnnotation, so the colon</span>
            <span class="s4">// needs to be added separately.</span>
            <span class="s2">if </span><span class="s1">(n.returnType) {</span>
                <span class="s1">parts.push(isArrowFunctionTypeAnnotation ? </span><span class="s0">&quot; =&gt; &quot; </span><span class="s1">: </span><span class="s0">&quot;: &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;returnType&quot;</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s1">}</span>
        <span class="s2">case </span><span class="s0">&quot;FunctionTypeParam&quot;</span><span class="s1">: {</span>
            <span class="s2">var </span><span class="s1">name = path.call(print, </span><span class="s0">&quot;name&quot;</span><span class="s1">);</span>
            <span class="s1">parts.push(name);</span>
            <span class="s2">if </span><span class="s1">(n.optional) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;?&quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(name.infos[</span><span class="s3">0</span><span class="s1">].line) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;: &quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s1">parts.push(path.call(print, </span><span class="s0">&quot;typeAnnotation&quot;</span><span class="s1">));</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s1">}</span>
        <span class="s2">case </span><span class="s0">&quot;GenericTypeAnnotation&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;id&quot;</span><span class="s1">),</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;typeParameters&quot;</span><span class="s1">),</span>
            <span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;DeclareInterface&quot;</span><span class="s1">:</span>
            <span class="s1">parts.push(</span><span class="s0">&quot;declare &quot;</span><span class="s1">);</span>
        <span class="s4">// Fall through to InterfaceDeclaration...</span>
        <span class="s2">case </span><span class="s0">&quot;InterfaceDeclaration&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;TSInterfaceDeclaration&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">(n.declare) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;declare &quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s1">parts.push(</span><span class="s0">&quot;interface &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;id&quot;</span><span class="s1">), path.call(print, </span><span class="s0">&quot;typeParameters&quot;</span><span class="s1">), </span><span class="s0">&quot; &quot;</span><span class="s1">);</span>
            <span class="s2">if </span><span class="s1">(n[</span><span class="s0">&quot;extends&quot;</span><span class="s1">] &amp;&amp; n[</span><span class="s0">&quot;extends&quot;</span><span class="s1">].length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;extends &quot;</span><span class="s1">, lines_1.fromString(</span><span class="s0">&quot;, &quot;</span><span class="s1">).join(path.map(print, </span><span class="s0">&quot;extends&quot;</span><span class="s1">)), </span><span class="s0">&quot; &quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(n.body) {</span>
                <span class="s1">parts.push(path.call(print, </span><span class="s0">&quot;body&quot;</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s2">case </span><span class="s0">&quot;ClassImplements&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;InterfaceExtends&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;id&quot;</span><span class="s1">),</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;typeParameters&quot;</span><span class="s1">),</span>
            <span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;IntersectionTypeAnnotation&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot; &amp; &quot;</span><span class="s1">).join(path.map(print, </span><span class="s0">&quot;types&quot;</span><span class="s1">));</span>
        <span class="s2">case </span><span class="s0">&quot;NullableTypeAnnotation&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span><span class="s0">&quot;?&quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;typeAnnotation&quot;</span><span class="s1">)]);</span>
        <span class="s2">case </span><span class="s0">&quot;NullLiteralTypeAnnotation&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot;null&quot;</span><span class="s1">, options);</span>
        <span class="s2">case </span><span class="s0">&quot;ThisTypeAnnotation&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot;this&quot;</span><span class="s1">, options);</span>
        <span class="s2">case </span><span class="s0">&quot;NumberTypeAnnotation&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot;number&quot;</span><span class="s1">, options);</span>
        <span class="s2">case </span><span class="s0">&quot;ObjectTypeCallProperty&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">path.call(print, </span><span class="s0">&quot;value&quot;</span><span class="s1">);</span>
        <span class="s2">case </span><span class="s0">&quot;ObjectTypeIndexer&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">(n.static) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;static &quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s1">parts.push(printVariance(path, print), </span><span class="s0">&quot;[&quot;</span><span class="s1">);</span>
            <span class="s2">if </span><span class="s1">(n.id) {</span>
                <span class="s1">parts.push(path.call(print, </span><span class="s0">&quot;id&quot;</span><span class="s1">), </span><span class="s0">&quot;: &quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s1">parts.push(path.call(print, </span><span class="s0">&quot;key&quot;</span><span class="s1">), </span><span class="s0">&quot;]: &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;value&quot;</span><span class="s1">));</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s2">case </span><span class="s0">&quot;ObjectTypeProperty&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span>
                <span class="s1">printVariance(path, print),</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;key&quot;</span><span class="s1">),</span>
                <span class="s1">n.optional ? </span><span class="s0">&quot;?&quot; </span><span class="s1">: </span><span class="s0">&quot;&quot;</span><span class="s1">,</span>
                <span class="s0">&quot;: &quot;</span><span class="s1">,</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;value&quot;</span><span class="s1">),</span>
            <span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;ObjectTypeInternalSlot&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span>
                <span class="s1">n.static ? </span><span class="s0">&quot;static &quot; </span><span class="s1">: </span><span class="s0">&quot;&quot;</span><span class="s1">,</span>
                <span class="s0">&quot;[[&quot;</span><span class="s1">,</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;id&quot;</span><span class="s1">),</span>
                <span class="s0">&quot;]]&quot;</span><span class="s1">,</span>
                <span class="s1">n.optional ? </span><span class="s0">&quot;?&quot; </span><span class="s1">: </span><span class="s0">&quot;&quot;</span><span class="s1">,</span>
                <span class="s1">n.value.type !== </span><span class="s0">&quot;FunctionTypeAnnotation&quot; </span><span class="s1">? </span><span class="s0">&quot;: &quot; </span><span class="s1">: </span><span class="s0">&quot;&quot;</span><span class="s1">,</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;value&quot;</span><span class="s1">),</span>
            <span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;QualifiedTypeIdentifier&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;qualification&quot;</span><span class="s1">),</span>
                <span class="s0">&quot;.&quot;</span><span class="s1">,</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;id&quot;</span><span class="s1">),</span>
            <span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;StringLiteralTypeAnnotation&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(nodeStr(n.value, options), options);</span>
        <span class="s2">case </span><span class="s0">&quot;NumberLiteralTypeAnnotation&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;NumericLiteralTypeAnnotation&quot;</span><span class="s1">:</span>
            <span class="s1">assert_1.</span><span class="s2">default</span><span class="s1">.strictEqual(</span><span class="s2">typeof </span><span class="s1">n.value, </span><span class="s0">&quot;number&quot;</span><span class="s1">);</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(JSON.stringify(n.value), options);</span>
        <span class="s2">case </span><span class="s0">&quot;BigIntLiteralTypeAnnotation&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(n.raw, options);</span>
        <span class="s2">case </span><span class="s0">&quot;StringTypeAnnotation&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot;string&quot;</span><span class="s1">, options);</span>
        <span class="s2">case </span><span class="s0">&quot;DeclareTypeAlias&quot;</span><span class="s1">:</span>
            <span class="s1">parts.push(</span><span class="s0">&quot;declare &quot;</span><span class="s1">);</span>
        <span class="s4">// Fall through to TypeAlias...</span>
        <span class="s2">case </span><span class="s0">&quot;TypeAlias&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span>
                <span class="s0">&quot;type &quot;</span><span class="s1">,</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;id&quot;</span><span class="s1">),</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;typeParameters&quot;</span><span class="s1">),</span>
                <span class="s0">&quot; = &quot;</span><span class="s1">,</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;right&quot;</span><span class="s1">),</span>
                <span class="s0">&quot;;&quot;</span><span class="s1">,</span>
            <span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;DeclareOpaqueType&quot;</span><span class="s1">:</span>
            <span class="s1">parts.push(</span><span class="s0">&quot;declare &quot;</span><span class="s1">);</span>
        <span class="s4">// Fall through to OpaqueType...</span>
        <span class="s2">case </span><span class="s0">&quot;OpaqueType&quot;</span><span class="s1">:</span>
            <span class="s1">parts.push(</span><span class="s0">&quot;opaque type &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;id&quot;</span><span class="s1">), path.call(print, </span><span class="s0">&quot;typeParameters&quot;</span><span class="s1">));</span>
            <span class="s2">if </span><span class="s1">(n[</span><span class="s0">&quot;supertype&quot;</span><span class="s1">]) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;: &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;supertype&quot;</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(n[</span><span class="s0">&quot;impltype&quot;</span><span class="s1">]) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot; = &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;impltype&quot;</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s1">parts.push(</span><span class="s0">&quot;;&quot;</span><span class="s1">);</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s2">case </span><span class="s0">&quot;TypeCastExpression&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span>
                <span class="s0">&quot;(&quot;</span><span class="s1">,</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;expression&quot;</span><span class="s1">),</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;typeAnnotation&quot;</span><span class="s1">),</span>
                <span class="s0">&quot;)&quot;</span><span class="s1">,</span>
            <span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;TypeParameterDeclaration&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;TypeParameterInstantiation&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span>
                <span class="s0">&quot;&lt;&quot;</span><span class="s1">,</span>
                <span class="s1">lines_1.fromString(</span><span class="s0">&quot;, &quot;</span><span class="s1">).join(path.map(print, </span><span class="s0">&quot;params&quot;</span><span class="s1">)),</span>
                <span class="s0">&quot;&gt;&quot;</span><span class="s1">,</span>
            <span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;Variance&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">(n.kind === </span><span class="s0">&quot;plus&quot;</span><span class="s1">) {</span>
                <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot;+&quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(n.kind === </span><span class="s0">&quot;minus&quot;</span><span class="s1">) {</span>
                <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot;-&quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot;&quot;</span><span class="s1">);</span>
        <span class="s2">case </span><span class="s0">&quot;TypeParameter&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">(n.variance) {</span>
                <span class="s1">parts.push(printVariance(path, print));</span>
            <span class="s1">}</span>
            <span class="s1">parts.push(path.call(print, </span><span class="s0">&quot;name&quot;</span><span class="s1">));</span>
            <span class="s2">if </span><span class="s1">(n.bound) {</span>
                <span class="s1">parts.push(path.call(print, </span><span class="s0">&quot;bound&quot;</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(n[</span><span class="s0">&quot;default&quot;</span><span class="s1">]) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;=&quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;default&quot;</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s2">case </span><span class="s0">&quot;TypeofTypeAnnotation&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span>
                <span class="s1">lines_1.fromString(</span><span class="s0">&quot;typeof &quot;</span><span class="s1">, options),</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;argument&quot;</span><span class="s1">),</span>
            <span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;IndexedAccessType&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;OptionalIndexedAccessType&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;objectType&quot;</span><span class="s1">),</span>
                <span class="s1">n.optional ? </span><span class="s0">&quot;?.&quot; </span><span class="s1">: </span><span class="s0">&quot;&quot;</span><span class="s1">,</span>
                <span class="s0">&quot;[&quot;</span><span class="s1">,</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;indexType&quot;</span><span class="s1">),</span>
                <span class="s0">&quot;]&quot;</span><span class="s1">,</span>
            <span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;UnionTypeAnnotation&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot; | &quot;</span><span class="s1">).join(path.map(print, </span><span class="s0">&quot;types&quot;</span><span class="s1">));</span>
        <span class="s2">case </span><span class="s0">&quot;VoidTypeAnnotation&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot;void&quot;</span><span class="s1">, options);</span>
        <span class="s2">case </span><span class="s0">&quot;NullTypeAnnotation&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot;null&quot;</span><span class="s1">, options);</span>
        <span class="s2">case </span><span class="s0">&quot;SymbolTypeAnnotation&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot;symbol&quot;</span><span class="s1">, options);</span>
        <span class="s2">case </span><span class="s0">&quot;BigIntTypeAnnotation&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot;bigint&quot;</span><span class="s1">, options);</span>
        <span class="s4">// Type Annotations for TypeScript (when using Babylon as parser)</span>
        <span class="s2">case </span><span class="s0">&quot;TSType&quot;</span><span class="s1">:</span>
            <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">&quot;unprintable type: &quot; </span><span class="s1">+ JSON.stringify(n.type));</span>
        <span class="s2">case </span><span class="s0">&quot;TSNumberKeyword&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot;number&quot;</span><span class="s1">, options);</span>
        <span class="s2">case </span><span class="s0">&quot;TSBigIntKeyword&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot;bigint&quot;</span><span class="s1">, options);</span>
        <span class="s2">case </span><span class="s0">&quot;TSObjectKeyword&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot;object&quot;</span><span class="s1">, options);</span>
        <span class="s2">case </span><span class="s0">&quot;TSBooleanKeyword&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot;boolean&quot;</span><span class="s1">, options);</span>
        <span class="s2">case </span><span class="s0">&quot;TSStringKeyword&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot;string&quot;</span><span class="s1">, options);</span>
        <span class="s2">case </span><span class="s0">&quot;TSSymbolKeyword&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot;symbol&quot;</span><span class="s1">, options);</span>
        <span class="s2">case </span><span class="s0">&quot;TSAnyKeyword&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot;any&quot;</span><span class="s1">, options);</span>
        <span class="s2">case </span><span class="s0">&quot;TSVoidKeyword&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot;void&quot;</span><span class="s1">, options);</span>
        <span class="s2">case </span><span class="s0">&quot;TSIntrinsicKeyword&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot;intrinsic&quot;</span><span class="s1">, options);</span>
        <span class="s2">case </span><span class="s0">&quot;TSThisType&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot;this&quot;</span><span class="s1">, options);</span>
        <span class="s2">case </span><span class="s0">&quot;TSNullKeyword&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot;null&quot;</span><span class="s1">, options);</span>
        <span class="s2">case </span><span class="s0">&quot;TSUndefinedKeyword&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot;undefined&quot;</span><span class="s1">, options);</span>
        <span class="s2">case </span><span class="s0">&quot;TSUnknownKeyword&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot;unknown&quot;</span><span class="s1">, options);</span>
        <span class="s2">case </span><span class="s0">&quot;TSNeverKeyword&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot;never&quot;</span><span class="s1">, options);</span>
        <span class="s2">case </span><span class="s0">&quot;TSArrayType&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([path.call(print, </span><span class="s0">&quot;elementType&quot;</span><span class="s1">), </span><span class="s0">&quot;[]&quot;</span><span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;TSLiteralType&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">path.call(print, </span><span class="s0">&quot;literal&quot;</span><span class="s1">);</span>
        <span class="s2">case </span><span class="s0">&quot;TSUnionType&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot; | &quot;</span><span class="s1">).join(path.map(print, </span><span class="s0">&quot;types&quot;</span><span class="s1">));</span>
        <span class="s2">case </span><span class="s0">&quot;TSIntersectionType&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot; &amp; &quot;</span><span class="s1">).join(path.map(print, </span><span class="s0">&quot;types&quot;</span><span class="s1">));</span>
        <span class="s2">case </span><span class="s0">&quot;TSConditionalType&quot;</span><span class="s1">:</span>
            <span class="s1">parts.push(path.call(print, </span><span class="s0">&quot;checkType&quot;</span><span class="s1">), </span><span class="s0">&quot; extends &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;extendsType&quot;</span><span class="s1">), </span><span class="s0">&quot; ? &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;trueType&quot;</span><span class="s1">), </span><span class="s0">&quot; : &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;falseType&quot;</span><span class="s1">));</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s2">case </span><span class="s0">&quot;TSInferType&quot;</span><span class="s1">:</span>
            <span class="s1">parts.push(</span><span class="s0">&quot;infer &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;typeParameter&quot;</span><span class="s1">));</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s2">case </span><span class="s0">&quot;TSParenthesizedType&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span><span class="s0">&quot;(&quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;typeAnnotation&quot;</span><span class="s1">), </span><span class="s0">&quot;)&quot;</span><span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;TSFunctionType&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;typeParameters&quot;</span><span class="s1">),</span>
                <span class="s0">&quot;(&quot;</span><span class="s1">,</span>
                <span class="s1">printFunctionParams(path, options, print),</span>
                <span class="s0">&quot;) =&gt; &quot;</span><span class="s1">,</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;typeAnnotation&quot;</span><span class="s1">, </span><span class="s0">&quot;typeAnnotation&quot;</span><span class="s1">),</span>
            <span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;TSConstructorType&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span>
                <span class="s0">&quot;new &quot;</span><span class="s1">,</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;typeParameters&quot;</span><span class="s1">),</span>
                <span class="s0">&quot;(&quot;</span><span class="s1">,</span>
                <span class="s1">printFunctionParams(path, options, print),</span>
                <span class="s0">&quot;) =&gt; &quot;</span><span class="s1">,</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;typeAnnotation&quot;</span><span class="s1">, </span><span class="s0">&quot;typeAnnotation&quot;</span><span class="s1">),</span>
            <span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;TSMappedType&quot;</span><span class="s1">: {</span>
            <span class="s1">parts.push(n.readonly ? </span><span class="s0">&quot;readonly &quot; </span><span class="s1">: </span><span class="s0">&quot;&quot;</span><span class="s1">, </span><span class="s0">&quot;[&quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;typeParameter&quot;</span><span class="s1">), </span><span class="s0">&quot;]&quot;</span><span class="s1">, n.optional ? </span><span class="s0">&quot;?&quot; </span><span class="s1">: </span><span class="s0">&quot;&quot;</span><span class="s1">);</span>
            <span class="s2">if </span><span class="s1">(n.typeAnnotation) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;: &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;typeAnnotation&quot;</span><span class="s1">), </span><span class="s0">&quot;;&quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span><span class="s0">&quot;{</span><span class="s5">\n</span><span class="s0">&quot;</span><span class="s1">, lines_1.concat(parts).indent(options.tabWidth), </span><span class="s0">&quot;</span><span class="s5">\n</span><span class="s0">}&quot;</span><span class="s1">]);</span>
        <span class="s1">}</span>
        <span class="s2">case </span><span class="s0">&quot;TSTupleType&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span>
                <span class="s0">&quot;[&quot;</span><span class="s1">,</span>
                <span class="s1">lines_1.fromString(</span><span class="s0">&quot;, &quot;</span><span class="s1">).join(path.map(print, </span><span class="s0">&quot;elementTypes&quot;</span><span class="s1">)),</span>
                <span class="s0">&quot;]&quot;</span><span class="s1">,</span>
            <span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;TSNamedTupleMember&quot;</span><span class="s1">:</span>
            <span class="s1">parts.push(path.call(print, </span><span class="s0">&quot;label&quot;</span><span class="s1">));</span>
            <span class="s2">if </span><span class="s1">(n.optional) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;?&quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s1">parts.push(</span><span class="s0">&quot;: &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;elementType&quot;</span><span class="s1">));</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s2">case </span><span class="s0">&quot;TSRestType&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span><span class="s0">&quot;...&quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;typeAnnotation&quot;</span><span class="s1">)]);</span>
        <span class="s2">case </span><span class="s0">&quot;TSOptionalType&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([path.call(print, </span><span class="s0">&quot;typeAnnotation&quot;</span><span class="s1">), </span><span class="s0">&quot;?&quot;</span><span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;TSIndexedAccessType&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;objectType&quot;</span><span class="s1">),</span>
                <span class="s0">&quot;[&quot;</span><span class="s1">,</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;indexType&quot;</span><span class="s1">),</span>
                <span class="s0">&quot;]&quot;</span><span class="s1">,</span>
            <span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;TSTypeOperator&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;operator&quot;</span><span class="s1">),</span>
                <span class="s0">&quot; &quot;</span><span class="s1">,</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;typeAnnotation&quot;</span><span class="s1">),</span>
            <span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;TSTypeLiteral&quot;</span><span class="s1">: {</span>
            <span class="s2">var </span><span class="s1">memberLines = lines_1.fromString(</span><span class="s0">&quot;</span><span class="s5">\n</span><span class="s0">&quot;</span><span class="s1">).join(path.map(print, </span><span class="s0">&quot;members&quot;</span><span class="s1">));</span>
            <span class="s2">if </span><span class="s1">(memberLines.isEmpty()) {</span>
                <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot;{}&quot;</span><span class="s1">, options);</span>
            <span class="s1">}</span>
            <span class="s1">parts.push(</span><span class="s0">&quot;{</span><span class="s5">\n</span><span class="s0">&quot;</span><span class="s1">, memberLines.indent(options.tabWidth), </span><span class="s0">&quot;</span><span class="s5">\n</span><span class="s0">}&quot;</span><span class="s1">);</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s1">}</span>
        <span class="s2">case </span><span class="s0">&quot;TSEnumMember&quot;</span><span class="s1">:</span>
            <span class="s1">parts.push(path.call(print, </span><span class="s0">&quot;id&quot;</span><span class="s1">));</span>
            <span class="s2">if </span><span class="s1">(n.initializer) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot; = &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;initializer&quot;</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s2">case </span><span class="s0">&quot;TSTypeQuery&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span><span class="s0">&quot;typeof &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;exprName&quot;</span><span class="s1">)]);</span>
        <span class="s2">case </span><span class="s0">&quot;TSParameterProperty&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">(n.accessibility) {</span>
                <span class="s1">parts.push(n.accessibility, </span><span class="s0">&quot; &quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(n.export) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;export &quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(n.static) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;static &quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(n.readonly) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;readonly &quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s1">parts.push(path.call(print, </span><span class="s0">&quot;parameter&quot;</span><span class="s1">));</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s2">case </span><span class="s0">&quot;TSTypeReference&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;typeName&quot;</span><span class="s1">),</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;typeParameters&quot;</span><span class="s1">),</span>
            <span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;TSQualifiedName&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([path.call(print, </span><span class="s0">&quot;left&quot;</span><span class="s1">), </span><span class="s0">&quot;.&quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;right&quot;</span><span class="s1">)]);</span>
        <span class="s2">case </span><span class="s0">&quot;TSAsExpression&quot;</span><span class="s1">: {</span>
            <span class="s2">var </span><span class="s1">expression = path.call(print, </span><span class="s0">&quot;expression&quot;</span><span class="s1">);</span>
            <span class="s1">parts.push(expression, lines_1.fromString(</span><span class="s0">&quot; as &quot;</span><span class="s1">), path.call(print, </span><span class="s0">&quot;typeAnnotation&quot;</span><span class="s1">));</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s1">}</span>
        <span class="s2">case </span><span class="s0">&quot;TSNonNullExpression&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([path.call(print, </span><span class="s0">&quot;expression&quot;</span><span class="s1">), </span><span class="s0">&quot;!&quot;</span><span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;TSTypeAnnotation&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span><span class="s0">&quot;: &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;typeAnnotation&quot;</span><span class="s1">)]);</span>
        <span class="s2">case </span><span class="s0">&quot;TSIndexSignature&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span>
                <span class="s1">n.readonly ? </span><span class="s0">&quot;readonly &quot; </span><span class="s1">: </span><span class="s0">&quot;&quot;</span><span class="s1">,</span>
                <span class="s0">&quot;[&quot;</span><span class="s1">,</span>
                <span class="s1">path.map(print, </span><span class="s0">&quot;parameters&quot;</span><span class="s1">),</span>
                <span class="s0">&quot;]&quot;</span><span class="s1">,</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;typeAnnotation&quot;</span><span class="s1">),</span>
            <span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;TSPropertySignature&quot;</span><span class="s1">:</span>
            <span class="s1">parts.push(printVariance(path, print), n.readonly ? </span><span class="s0">&quot;readonly &quot; </span><span class="s1">: </span><span class="s0">&quot;&quot;</span><span class="s1">);</span>
            <span class="s2">if </span><span class="s1">(n.computed) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;[&quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;key&quot;</span><span class="s1">), </span><span class="s0">&quot;]&quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">parts.push(path.call(print, </span><span class="s0">&quot;key&quot;</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s1">parts.push(n.optional ? </span><span class="s0">&quot;?&quot; </span><span class="s1">: </span><span class="s0">&quot;&quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;typeAnnotation&quot;</span><span class="s1">));</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s2">case </span><span class="s0">&quot;TSMethodSignature&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">(n.computed) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;[&quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;key&quot;</span><span class="s1">), </span><span class="s0">&quot;]&quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">parts.push(path.call(print, </span><span class="s0">&quot;key&quot;</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(n.optional) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;?&quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s1">parts.push(path.call(print, </span><span class="s0">&quot;typeParameters&quot;</span><span class="s1">), </span><span class="s0">&quot;(&quot;</span><span class="s1">, printFunctionParams(path, options, print), </span><span class="s0">&quot;)&quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;typeAnnotation&quot;</span><span class="s1">));</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s2">case </span><span class="s0">&quot;TSTypePredicate&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">(n.asserts) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;asserts &quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s1">parts.push(path.call(print, </span><span class="s0">&quot;parameterName&quot;</span><span class="s1">));</span>
            <span class="s2">if </span><span class="s1">(n.typeAnnotation) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot; is &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;typeAnnotation&quot;</span><span class="s1">, </span><span class="s0">&quot;typeAnnotation&quot;</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s2">case </span><span class="s0">&quot;TSCallSignatureDeclaration&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;typeParameters&quot;</span><span class="s1">),</span>
                <span class="s0">&quot;(&quot;</span><span class="s1">,</span>
                <span class="s1">printFunctionParams(path, options, print),</span>
                <span class="s0">&quot;)&quot;</span><span class="s1">,</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;typeAnnotation&quot;</span><span class="s1">),</span>
            <span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;TSConstructSignatureDeclaration&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">(n.typeParameters) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;new&quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;typeParameters&quot;</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;new &quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s1">parts.push(</span><span class="s0">&quot;(&quot;</span><span class="s1">, printFunctionParams(path, options, print), </span><span class="s0">&quot;)&quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;typeAnnotation&quot;</span><span class="s1">));</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s2">case </span><span class="s0">&quot;TSTypeAliasDeclaration&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span>
                <span class="s1">n.declare ? </span><span class="s0">&quot;declare &quot; </span><span class="s1">: </span><span class="s0">&quot;&quot;</span><span class="s1">,</span>
                <span class="s0">&quot;type &quot;</span><span class="s1">,</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;id&quot;</span><span class="s1">),</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;typeParameters&quot;</span><span class="s1">),</span>
                <span class="s0">&quot; = &quot;</span><span class="s1">,</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;typeAnnotation&quot;</span><span class="s1">),</span>
                <span class="s0">&quot;;&quot;</span><span class="s1">,</span>
            <span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;TSTypeParameter&quot;</span><span class="s1">: {</span>
            <span class="s1">parts.push(path.call(print, </span><span class="s0">&quot;name&quot;</span><span class="s1">));</span>
            <span class="s4">// ambiguous because of TSMappedType</span>
            <span class="s2">var </span><span class="s1">parent = path.getParentNode(</span><span class="s3">0</span><span class="s1">);</span>
            <span class="s2">var </span><span class="s1">isInMappedType = namedTypes.TSMappedType.check(parent);</span>
            <span class="s2">if </span><span class="s1">(n.constraint) {</span>
                <span class="s1">parts.push(isInMappedType ? </span><span class="s0">&quot; in &quot; </span><span class="s1">: </span><span class="s0">&quot; extends &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;constraint&quot;</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(n[</span><span class="s0">&quot;default&quot;</span><span class="s1">]) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot; = &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;default&quot;</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s1">}</span>
        <span class="s2">case </span><span class="s0">&quot;TSTypeAssertion&quot;</span><span class="s1">: {</span>
            <span class="s1">parts.push(</span><span class="s0">&quot;&lt;&quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;typeAnnotation&quot;</span><span class="s1">), </span><span class="s0">&quot;&gt; &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;expression&quot;</span><span class="s1">));</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s1">}</span>
        <span class="s2">case </span><span class="s0">&quot;TSTypeParameterDeclaration&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;TSTypeParameterInstantiation&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span>
                <span class="s0">&quot;&lt;&quot;</span><span class="s1">,</span>
                <span class="s1">lines_1.fromString(</span><span class="s0">&quot;, &quot;</span><span class="s1">).join(path.map(print, </span><span class="s0">&quot;params&quot;</span><span class="s1">)),</span>
                <span class="s0">&quot;&gt;&quot;</span><span class="s1">,</span>
            <span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;TSEnumDeclaration&quot;</span><span class="s1">: {</span>
            <span class="s1">parts.push(n.declare ? </span><span class="s0">&quot;declare &quot; </span><span class="s1">: </span><span class="s0">&quot;&quot;</span><span class="s1">, n.const ? </span><span class="s0">&quot;const &quot; </span><span class="s1">: </span><span class="s0">&quot;&quot;</span><span class="s1">, </span><span class="s0">&quot;enum &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;id&quot;</span><span class="s1">));</span>
            <span class="s2">var </span><span class="s1">memberLines = lines_1.fromString(</span><span class="s0">&quot;,</span><span class="s5">\n</span><span class="s0">&quot;</span><span class="s1">).join(path.map(print, </span><span class="s0">&quot;members&quot;</span><span class="s1">));</span>
            <span class="s2">if </span><span class="s1">(memberLines.isEmpty()) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot; {}&quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">parts.push(</span><span class="s0">&quot; {</span><span class="s5">\n</span><span class="s0">&quot;</span><span class="s1">, memberLines.indent(options.tabWidth), </span><span class="s0">&quot;</span><span class="s5">\n</span><span class="s0">}&quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s1">}</span>
        <span class="s2">case </span><span class="s0">&quot;TSExpressionWithTypeArguments&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;expression&quot;</span><span class="s1">),</span>
                <span class="s1">path.call(print, </span><span class="s0">&quot;typeParameters&quot;</span><span class="s1">),</span>
            <span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;TSInterfaceBody&quot;</span><span class="s1">: {</span>
            <span class="s2">var </span><span class="s1">lines = lines_1.fromString(</span><span class="s0">&quot;</span><span class="s5">\n</span><span class="s0">&quot;</span><span class="s1">).join(path.map(print, </span><span class="s0">&quot;body&quot;</span><span class="s1">));</span>
            <span class="s2">if </span><span class="s1">(lines.isEmpty()) {</span>
                <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot;{}&quot;</span><span class="s1">, options);</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span><span class="s0">&quot;{</span><span class="s5">\n</span><span class="s0">&quot;</span><span class="s1">, lines.indent(options.tabWidth), </span><span class="s0">&quot;</span><span class="s5">\n</span><span class="s0">}&quot;</span><span class="s1">]);</span>
        <span class="s1">}</span>
        <span class="s2">case </span><span class="s0">&quot;TSImportType&quot;</span><span class="s1">:</span>
            <span class="s1">parts.push(</span><span class="s0">&quot;import(&quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;argument&quot;</span><span class="s1">), </span><span class="s0">&quot;)&quot;</span><span class="s1">);</span>
            <span class="s2">if </span><span class="s1">(n.qualifier) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;.&quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;qualifier&quot;</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(n.typeParameters) {</span>
                <span class="s1">parts.push(path.call(print, </span><span class="s0">&quot;typeParameters&quot;</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s2">case </span><span class="s0">&quot;TSImportEqualsDeclaration&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">(n.isExport) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;export &quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s1">parts.push(</span><span class="s0">&quot;import &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;id&quot;</span><span class="s1">), </span><span class="s0">&quot; = &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;moduleReference&quot;</span><span class="s1">));</span>
            <span class="s2">return </span><span class="s1">maybeAddSemicolon(lines_1.concat(parts));</span>
        <span class="s2">case </span><span class="s0">&quot;TSExternalModuleReference&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span><span class="s0">&quot;require(&quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;expression&quot;</span><span class="s1">), </span><span class="s0">&quot;)&quot;</span><span class="s1">]);</span>
        <span class="s2">case </span><span class="s0">&quot;TSModuleDeclaration&quot;</span><span class="s1">: {</span>
            <span class="s2">var </span><span class="s1">parent = path.getParentNode();</span>
            <span class="s2">if </span><span class="s1">(parent.type === </span><span class="s0">&quot;TSModuleDeclaration&quot;</span><span class="s1">) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;.&quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s2">if </span><span class="s1">(n.declare) {</span>
                    <span class="s1">parts.push(</span><span class="s0">&quot;declare &quot;</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(!n.global) {</span>
                    <span class="s2">var </span><span class="s1">isExternal = n.id.type === </span><span class="s0">&quot;StringLiteral&quot; </span><span class="s1">||</span>
                        <span class="s1">(n.id.type === </span><span class="s0">&quot;Literal&quot; </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">n.id.value === </span><span class="s0">&quot;string&quot;</span><span class="s1">);</span>
                    <span class="s2">if </span><span class="s1">(isExternal) {</span>
                        <span class="s1">parts.push(</span><span class="s0">&quot;module &quot;</span><span class="s1">);</span>
                    <span class="s1">}</span>
                    <span class="s2">else if </span><span class="s1">(n.loc &amp;&amp; n.loc.lines &amp;&amp; n.id.loc) {</span>
                        <span class="s2">var </span><span class="s1">prefix = n.loc.lines.sliceString(n.loc.start, n.id.loc.start);</span>
                        <span class="s4">// These keywords are fundamentally ambiguous in the</span>
                        <span class="s4">// Babylon parser, and not reflected in the AST, so</span>
                        <span class="s4">// the best we can do is to match the original code,</span>
                        <span class="s4">// when possible.</span>
                        <span class="s2">if </span><span class="s1">(prefix.indexOf(</span><span class="s0">&quot;module&quot;</span><span class="s1">) &gt;= </span><span class="s3">0</span><span class="s1">) {</span>
                            <span class="s1">parts.push(</span><span class="s0">&quot;module &quot;</span><span class="s1">);</span>
                        <span class="s1">}</span>
                        <span class="s2">else </span><span class="s1">{</span>
                            <span class="s1">parts.push(</span><span class="s0">&quot;namespace &quot;</span><span class="s1">);</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">parts.push(</span><span class="s0">&quot;namespace &quot;</span><span class="s1">);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">parts.push(path.call(print, </span><span class="s0">&quot;id&quot;</span><span class="s1">));</span>
            <span class="s2">if </span><span class="s1">(n.body) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot; &quot;</span><span class="s1">);</span>
                <span class="s1">parts.push(path.call(print, </span><span class="s0">&quot;body&quot;</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s1">}</span>
        <span class="s2">case </span><span class="s0">&quot;TSModuleBlock&quot;</span><span class="s1">: {</span>
            <span class="s2">var </span><span class="s1">naked = path.call(</span><span class="s2">function </span><span class="s1">(bodyPath) { </span><span class="s2">return </span><span class="s1">printStatementSequence(bodyPath, options, print); }, </span><span class="s0">&quot;body&quot;</span><span class="s1">);</span>
            <span class="s2">if </span><span class="s1">(naked.isEmpty()) {</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;{}&quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">parts.push(</span><span class="s0">&quot;{</span><span class="s5">\n</span><span class="s0">&quot;</span><span class="s1">, naked.indent(options.tabWidth), </span><span class="s0">&quot;</span><span class="s5">\n</span><span class="s0">}&quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
        <span class="s1">}</span>
        <span class="s4">// https://github.com/babel/babel/pull/10148</span>
        <span class="s2">case </span><span class="s0">&quot;V8IntrinsicIdentifier&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.concat([</span><span class="s0">&quot;%&quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;name&quot;</span><span class="s1">)]);</span>
        <span class="s4">// https://github.com/babel/babel/pull/13191</span>
        <span class="s2">case </span><span class="s0">&quot;TopicReference&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot;#&quot;</span><span class="s1">);</span>
        <span class="s4">// Unhandled types below. If encountered, nodes of these types should</span>
        <span class="s4">// be either left alone or desugared into AST types that are fully</span>
        <span class="s4">// supported by the pretty-printer.</span>
        <span class="s2">case </span><span class="s0">&quot;ClassHeritage&quot;</span><span class="s1">: </span><span class="s4">// TODO</span>
        <span class="s2">case </span><span class="s0">&quot;ComprehensionBlock&quot;</span><span class="s1">: </span><span class="s4">// TODO</span>
        <span class="s2">case </span><span class="s0">&quot;ComprehensionExpression&quot;</span><span class="s1">: </span><span class="s4">// TODO</span>
        <span class="s2">case </span><span class="s0">&quot;Glob&quot;</span><span class="s1">: </span><span class="s4">// TODO</span>
        <span class="s2">case </span><span class="s0">&quot;GeneratorExpression&quot;</span><span class="s1">: </span><span class="s4">// TODO</span>
        <span class="s2">case </span><span class="s0">&quot;LetStatement&quot;</span><span class="s1">: </span><span class="s4">// TODO</span>
        <span class="s2">case </span><span class="s0">&quot;LetExpression&quot;</span><span class="s1">: </span><span class="s4">// TODO</span>
        <span class="s2">case </span><span class="s0">&quot;GraphExpression&quot;</span><span class="s1">: </span><span class="s4">// TODO</span>
        <span class="s2">case </span><span class="s0">&quot;GraphIndexExpression&quot;</span><span class="s1">: </span><span class="s4">// TODO</span>
        <span class="s2">case </span><span class="s0">&quot;XMLDefaultDeclaration&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;XMLAnyName&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;XMLQualifiedIdentifier&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;XMLFunctionQualifiedIdentifier&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;XMLAttributeSelector&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;XMLFilterExpression&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;XML&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;XMLElement&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;XMLList&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;XMLEscape&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;XMLText&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;XMLStartTag&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;XMLEndTag&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;XMLPointTag&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;XMLName&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;XMLAttribute&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;XMLCdata&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;XMLComment&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;XMLProcessingInstruction&quot;</span><span class="s1">:</span>
        <span class="s2">default</span><span class="s1">:</span>
            <span class="s1">debugger;</span>
            <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">&quot;unknown type: &quot; </span><span class="s1">+ JSON.stringify(n.type));</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">printDecorators(path, printPath) {</span>
    <span class="s2">var </span><span class="s1">parts = [];</span>
    <span class="s2">var </span><span class="s1">node = path.getValue();</span>
    <span class="s2">if </span><span class="s1">(node.decorators &amp;&amp;</span>
        <span class="s1">node.decorators.length &gt; </span><span class="s3">0 </span><span class="s1">&amp;&amp;</span>
        <span class="s4">// If the parent node is an export declaration, it will be</span>
        <span class="s4">// responsible for printing node.decorators.</span>
        <span class="s1">!util.getParentExportDeclaration(path)) {</span>
        <span class="s1">path.each(</span><span class="s2">function </span><span class="s1">(decoratorPath) {</span>
            <span class="s1">parts.push(printPath(decoratorPath), </span><span class="s0">&quot;</span><span class="s5">\n</span><span class="s0">&quot;</span><span class="s1">);</span>
        <span class="s1">}, </span><span class="s0">&quot;decorators&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(util.isExportDeclaration(node) &amp;&amp;</span>
        <span class="s1">node.declaration &amp;&amp;</span>
        <span class="s1">node.declaration.decorators) {</span>
        <span class="s4">// Export declarations are responsible for printing any decorators</span>
        <span class="s4">// that logically apply to node.declaration.</span>
        <span class="s1">path.each(</span><span class="s2">function </span><span class="s1">(decoratorPath) {</span>
            <span class="s1">parts.push(printPath(decoratorPath), </span><span class="s0">&quot;</span><span class="s5">\n</span><span class="s0">&quot;</span><span class="s1">);</span>
        <span class="s1">}, </span><span class="s0">&quot;declaration&quot;</span><span class="s1">, </span><span class="s0">&quot;decorators&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">printStatementSequence(path, options, print) {</span>
    <span class="s2">var </span><span class="s1">filtered = [];</span>
    <span class="s2">var </span><span class="s1">sawComment = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s2">var </span><span class="s1">sawStatement = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">path.each(</span><span class="s2">function </span><span class="s1">(stmtPath) {</span>
        <span class="s2">var </span><span class="s1">stmt = stmtPath.getValue();</span>
        <span class="s4">// Just in case the AST has been modified to contain falsy</span>
        <span class="s4">// &quot;statements,&quot; it's safer simply to skip them.</span>
        <span class="s2">if </span><span class="s1">(!stmt) {</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s4">// Skip printing EmptyStatement nodes to avoid leaving stray</span>
        <span class="s4">// semicolons lying around.</span>
        <span class="s2">if </span><span class="s1">(stmt.type === </span><span class="s0">&quot;EmptyStatement&quot; </span><span class="s1">&amp;&amp;</span>
            <span class="s1">!(stmt.comments &amp;&amp; stmt.comments.length &gt; </span><span class="s3">0</span><span class="s1">)) {</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(namedTypes.Comment.check(stmt)) {</span>
            <span class="s4">// The pretty printer allows a dangling Comment node to act as</span>
            <span class="s4">// a Statement when the Comment can't be attached to any other</span>
            <span class="s4">// non-Comment node in the tree.</span>
            <span class="s1">sawComment = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(namedTypes.Statement.check(stmt)) {</span>
            <span class="s1">sawStatement = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s4">// When the pretty printer encounters a string instead of an</span>
            <span class="s4">// AST node, it just prints the string. This behavior can be</span>
            <span class="s4">// useful for fine-grained formatting decisions like inserting</span>
            <span class="s4">// blank lines.</span>
            <span class="s1">isString.assert(stmt);</span>
        <span class="s1">}</span>
        <span class="s4">// We can't hang onto stmtPath outside of this function, because</span>
        <span class="s4">// it's just a reference to a mutable FastPath object, so we have</span>
        <span class="s4">// to go ahead and print it here.</span>
        <span class="s1">filtered.push({</span>
            <span class="s1">node: stmt,</span>
            <span class="s1">printed: print(stmtPath),</span>
        <span class="s1">});</span>
    <span class="s1">});</span>
    <span class="s2">if </span><span class="s1">(sawComment) {</span>
        <span class="s1">assert_1.</span><span class="s2">default</span><span class="s1">.strictEqual(sawStatement, </span><span class="s2">false</span><span class="s1">, </span><span class="s0">&quot;Comments may appear as statements in otherwise empty statement &quot; </span><span class="s1">+</span>
            <span class="s0">&quot;lists, but may not coexist with non-Comment nodes.&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">var </span><span class="s1">prevTrailingSpace = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">var </span><span class="s1">len = filtered.length;</span>
    <span class="s2">var </span><span class="s1">parts = [];</span>
    <span class="s1">filtered.forEach(</span><span class="s2">function </span><span class="s1">(info, i) {</span>
        <span class="s2">var </span><span class="s1">printed = info.printed;</span>
        <span class="s2">var </span><span class="s1">stmt = info.node;</span>
        <span class="s2">var </span><span class="s1">multiLine = printed.length &gt; </span><span class="s3">1</span><span class="s1">;</span>
        <span class="s2">var </span><span class="s1">notFirst = i &gt; </span><span class="s3">0</span><span class="s1">;</span>
        <span class="s2">var </span><span class="s1">notLast = i &lt; len - </span><span class="s3">1</span><span class="s1">;</span>
        <span class="s2">var </span><span class="s1">leadingSpace;</span>
        <span class="s2">var </span><span class="s1">trailingSpace;</span>
        <span class="s2">var </span><span class="s1">lines = stmt &amp;&amp; stmt.loc &amp;&amp; stmt.loc.lines;</span>
        <span class="s2">var </span><span class="s1">trueLoc = lines &amp;&amp; options.reuseWhitespace &amp;&amp; util.getTrueLoc(stmt, lines);</span>
        <span class="s2">if </span><span class="s1">(notFirst) {</span>
            <span class="s2">if </span><span class="s1">(trueLoc) {</span>
                <span class="s2">var </span><span class="s1">beforeStart = lines.skipSpaces(trueLoc.start, </span><span class="s2">true</span><span class="s1">);</span>
                <span class="s2">var </span><span class="s1">beforeStartLine = beforeStart ? beforeStart.line : </span><span class="s3">1</span><span class="s1">;</span>
                <span class="s2">var </span><span class="s1">leadingGap = trueLoc.start.line - beforeStartLine;</span>
                <span class="s1">leadingSpace = Array(leadingGap + </span><span class="s3">1</span><span class="s1">).join(</span><span class="s0">&quot;</span><span class="s5">\n</span><span class="s0">&quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">leadingSpace = multiLine ? </span><span class="s0">&quot;</span><span class="s5">\n\n</span><span class="s0">&quot; </span><span class="s1">: </span><span class="s0">&quot;</span><span class="s5">\n</span><span class="s0">&quot;</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">leadingSpace = </span><span class="s0">&quot;&quot;</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(notLast) {</span>
            <span class="s2">if </span><span class="s1">(trueLoc) {</span>
                <span class="s2">var </span><span class="s1">afterEnd = lines.skipSpaces(trueLoc.end);</span>
                <span class="s2">var </span><span class="s1">afterEndLine = afterEnd ? afterEnd.line : lines.length;</span>
                <span class="s2">var </span><span class="s1">trailingGap = afterEndLine - trueLoc.end.line;</span>
                <span class="s1">trailingSpace = Array(trailingGap + </span><span class="s3">1</span><span class="s1">).join(</span><span class="s0">&quot;</span><span class="s5">\n</span><span class="s0">&quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">trailingSpace = multiLine ? </span><span class="s0">&quot;</span><span class="s5">\n\n</span><span class="s0">&quot; </span><span class="s1">: </span><span class="s0">&quot;</span><span class="s5">\n</span><span class="s0">&quot;</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">trailingSpace = </span><span class="s0">&quot;&quot;</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">parts.push(maxSpace(prevTrailingSpace, leadingSpace), printed);</span>
        <span class="s2">if </span><span class="s1">(notLast) {</span>
            <span class="s1">prevTrailingSpace = trailingSpace;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(trailingSpace) {</span>
            <span class="s1">parts.push(trailingSpace);</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">maxSpace(s1, s2) {</span>
    <span class="s2">if </span><span class="s1">(!s1 &amp;&amp; !s2) {</span>
        <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot;&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!s1) {</span>
        <span class="s2">return </span><span class="s1">lines_1.fromString(s2);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!s2) {</span>
        <span class="s2">return </span><span class="s1">lines_1.fromString(s1);</span>
    <span class="s1">}</span>
    <span class="s2">var </span><span class="s1">spaceLines1 = lines_1.fromString(s1);</span>
    <span class="s2">var </span><span class="s1">spaceLines2 = lines_1.fromString(s2);</span>
    <span class="s2">if </span><span class="s1">(spaceLines2.length &gt; spaceLines1.length) {</span>
        <span class="s2">return </span><span class="s1">spaceLines2;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">spaceLines1;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">printMethod(path, options, print) {</span>
    <span class="s2">var </span><span class="s1">node = path.getNode();</span>
    <span class="s2">var </span><span class="s1">kind = node.kind;</span>
    <span class="s2">var </span><span class="s1">parts = [];</span>
    <span class="s2">var </span><span class="s1">nodeValue = node.value;</span>
    <span class="s2">if </span><span class="s1">(!namedTypes.FunctionExpression.check(nodeValue)) {</span>
        <span class="s1">nodeValue = node;</span>
    <span class="s1">}</span>
    <span class="s2">var </span><span class="s1">access = node.accessibility || node.access;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">access === </span><span class="s0">&quot;string&quot;</span><span class="s1">) {</span>
        <span class="s1">parts.push(access, </span><span class="s0">&quot; &quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(node.static) {</span>
        <span class="s1">parts.push(</span><span class="s0">&quot;static &quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(node.abstract) {</span>
        <span class="s1">parts.push(</span><span class="s0">&quot;abstract &quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(node.override) {</span>
        <span class="s1">parts.push(</span><span class="s0">&quot;override &quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(node.readonly) {</span>
        <span class="s1">parts.push(</span><span class="s0">&quot;readonly &quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(nodeValue.async) {</span>
        <span class="s1">parts.push(</span><span class="s0">&quot;async &quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(nodeValue.generator) {</span>
        <span class="s1">parts.push(</span><span class="s0">&quot;*&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(kind === </span><span class="s0">&quot;get&quot; </span><span class="s1">|| kind === </span><span class="s0">&quot;set&quot;</span><span class="s1">) {</span>
        <span class="s1">parts.push(kind, </span><span class="s0">&quot; &quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">var </span><span class="s1">key = path.call(print, </span><span class="s0">&quot;key&quot;</span><span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(node.computed) {</span>
        <span class="s1">key = lines_1.concat([</span><span class="s0">&quot;[&quot;</span><span class="s1">, key, </span><span class="s0">&quot;]&quot;</span><span class="s1">]);</span>
    <span class="s1">}</span>
    <span class="s1">parts.push(key);</span>
    <span class="s2">if </span><span class="s1">(node.optional) {</span>
        <span class="s1">parts.push(</span><span class="s0">&quot;?&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(node === nodeValue) {</span>
        <span class="s1">parts.push(path.call(print, </span><span class="s0">&quot;typeParameters&quot;</span><span class="s1">), </span><span class="s0">&quot;(&quot;</span><span class="s1">, printFunctionParams(path, options, print), </span><span class="s0">&quot;)&quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;returnType&quot;</span><span class="s1">));</span>
        <span class="s2">if </span><span class="s1">(node.body) {</span>
            <span class="s1">parts.push(</span><span class="s0">&quot; &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;body&quot;</span><span class="s1">));</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">parts.push(</span><span class="s0">&quot;;&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">parts.push(path.call(print, </span><span class="s0">&quot;value&quot;</span><span class="s1">, </span><span class="s0">&quot;typeParameters&quot;</span><span class="s1">), </span><span class="s0">&quot;(&quot;</span><span class="s1">, path.call(</span><span class="s2">function </span><span class="s1">(valuePath) { </span><span class="s2">return </span><span class="s1">printFunctionParams(valuePath, options, print); }, </span><span class="s0">&quot;value&quot;</span><span class="s1">), </span><span class="s0">&quot;)&quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;value&quot;</span><span class="s1">, </span><span class="s0">&quot;returnType&quot;</span><span class="s1">));</span>
        <span class="s2">if </span><span class="s1">(nodeValue.body) {</span>
            <span class="s1">parts.push(</span><span class="s0">&quot; &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;value&quot;</span><span class="s1">, </span><span class="s0">&quot;body&quot;</span><span class="s1">));</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">parts.push(</span><span class="s0">&quot;;&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">printArgumentsList(path, options, print) {</span>
    <span class="s2">var </span><span class="s1">printed = path.map(print, </span><span class="s0">&quot;arguments&quot;</span><span class="s1">);</span>
    <span class="s2">var </span><span class="s1">trailingComma = util.isTrailingCommaEnabled(options, </span><span class="s0">&quot;parameters&quot;</span><span class="s1">);</span>
    <span class="s2">var </span><span class="s1">joined = lines_1.fromString(</span><span class="s0">&quot;, &quot;</span><span class="s1">).join(printed);</span>
    <span class="s2">if </span><span class="s1">(joined.getLineLength(</span><span class="s3">1</span><span class="s1">) &gt; options.wrapColumn) {</span>
        <span class="s1">joined = lines_1.fromString(</span><span class="s0">&quot;,</span><span class="s5">\n</span><span class="s0">&quot;</span><span class="s1">).join(printed);</span>
        <span class="s2">return </span><span class="s1">lines_1.concat([</span>
            <span class="s0">&quot;(</span><span class="s5">\n</span><span class="s0">&quot;</span><span class="s1">,</span>
            <span class="s1">joined.indent(options.tabWidth),</span>
            <span class="s1">trailingComma ? </span><span class="s0">&quot;,</span><span class="s5">\n</span><span class="s0">)&quot; </span><span class="s1">: </span><span class="s0">&quot;</span><span class="s5">\n</span><span class="s0">)&quot;</span><span class="s1">,</span>
        <span class="s1">]);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">lines_1.concat([</span><span class="s0">&quot;(&quot;</span><span class="s1">, joined, </span><span class="s0">&quot;)&quot;</span><span class="s1">]);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">printFunctionParams(path, options, print) {</span>
    <span class="s2">var </span><span class="s1">fun = path.getValue();</span>
    <span class="s2">var </span><span class="s1">params;</span>
    <span class="s2">var </span><span class="s1">printed = [];</span>
    <span class="s2">if </span><span class="s1">(fun.params) {</span>
        <span class="s1">params = fun.params;</span>
        <span class="s1">printed = path.map(print, </span><span class="s0">&quot;params&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(fun.parameters) {</span>
        <span class="s1">params = fun.parameters;</span>
        <span class="s1">printed = path.map(print, </span><span class="s0">&quot;parameters&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(fun.defaults) {</span>
        <span class="s1">path.each(</span><span class="s2">function </span><span class="s1">(defExprPath) {</span>
            <span class="s2">var </span><span class="s1">i = defExprPath.getName();</span>
            <span class="s2">var </span><span class="s1">p = printed[i];</span>
            <span class="s2">if </span><span class="s1">(p &amp;&amp; defExprPath.getValue()) {</span>
                <span class="s1">printed[i] = lines_1.concat([p, </span><span class="s0">&quot; = &quot;</span><span class="s1">, print(defExprPath)]);</span>
            <span class="s1">}</span>
        <span class="s1">}, </span><span class="s0">&quot;defaults&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(fun.rest) {</span>
        <span class="s1">printed.push(lines_1.concat([</span><span class="s0">&quot;...&quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;rest&quot;</span><span class="s1">)]));</span>
    <span class="s1">}</span>
    <span class="s2">var </span><span class="s1">joined = lines_1.fromString(</span><span class="s0">&quot;, &quot;</span><span class="s1">).join(printed);</span>
    <span class="s2">if </span><span class="s1">(joined.length &gt; </span><span class="s3">1 </span><span class="s1">|| joined.getLineLength(</span><span class="s3">1</span><span class="s1">) &gt; options.wrapColumn) {</span>
        <span class="s1">joined = lines_1.fromString(</span><span class="s0">&quot;,</span><span class="s5">\n</span><span class="s0">&quot;</span><span class="s1">).join(printed);</span>
        <span class="s2">if </span><span class="s1">(util.isTrailingCommaEnabled(options, </span><span class="s0">&quot;parameters&quot;</span><span class="s1">) &amp;&amp;</span>
            <span class="s1">!fun.rest &amp;&amp;</span>
            <span class="s1">params[params.length - </span><span class="s3">1</span><span class="s1">].type !== </span><span class="s0">&quot;RestElement&quot;</span><span class="s1">) {</span>
            <span class="s1">joined = lines_1.concat([joined, </span><span class="s0">&quot;,</span><span class="s5">\n</span><span class="s0">&quot;</span><span class="s1">]);</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">joined = lines_1.concat([joined, </span><span class="s0">&quot;</span><span class="s5">\n</span><span class="s0">&quot;</span><span class="s1">]);</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">lines_1.concat([</span><span class="s0">&quot;</span><span class="s5">\n</span><span class="s0">&quot;</span><span class="s1">, joined.indent(options.tabWidth)]);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">joined;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">maybePrintImportAssertions(path, options, print) {</span>
    <span class="s2">var </span><span class="s1">n = path.getValue();</span>
    <span class="s2">if </span><span class="s1">(n.assertions &amp;&amp; n.assertions.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
        <span class="s2">var </span><span class="s1">parts = [</span><span class="s0">&quot; assert {&quot;</span><span class="s1">];</span>
        <span class="s2">var </span><span class="s1">printed = path.map(print, </span><span class="s0">&quot;assertions&quot;</span><span class="s1">);</span>
        <span class="s2">var </span><span class="s1">flat = lines_1.fromString(</span><span class="s0">&quot;, &quot;</span><span class="s1">).join(printed);</span>
        <span class="s2">if </span><span class="s1">(flat.length &gt; </span><span class="s3">1 </span><span class="s1">|| flat.getLineLength(</span><span class="s3">1</span><span class="s1">) &gt; options.wrapColumn) {</span>
            <span class="s1">parts.push(</span><span class="s0">&quot;</span><span class="s5">\n</span><span class="s0">&quot;</span><span class="s1">, lines_1.fromString(</span><span class="s0">&quot;,</span><span class="s5">\n</span><span class="s0">&quot;</span><span class="s1">).join(printed).indent(options.tabWidth), </span><span class="s0">&quot;</span><span class="s5">\n</span><span class="s0">}&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">parts.push(</span><span class="s0">&quot; &quot;</span><span class="s1">, flat, </span><span class="s0">&quot; }&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot;&quot;</span><span class="s1">);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">printExportDeclaration(path, options, print) {</span>
    <span class="s2">var </span><span class="s1">decl = path.getValue();</span>
    <span class="s2">var </span><span class="s1">parts = [</span><span class="s0">&quot;export &quot;</span><span class="s1">];</span>
    <span class="s2">if </span><span class="s1">(decl.exportKind &amp;&amp; decl.exportKind === </span><span class="s0">&quot;type&quot;</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(!decl.declaration) {</span>
            <span class="s1">parts.push(</span><span class="s0">&quot;type &quot;</span><span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">var </span><span class="s1">shouldPrintSpaces = options.objectCurlySpacing;</span>
    <span class="s1">namedTypes.Declaration.assert(decl);</span>
    <span class="s2">if </span><span class="s1">(decl[</span><span class="s0">&quot;default&quot;</span><span class="s1">] || decl.type === </span><span class="s0">&quot;ExportDefaultDeclaration&quot;</span><span class="s1">) {</span>
        <span class="s1">parts.push(</span><span class="s0">&quot;default &quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(decl.declaration) {</span>
        <span class="s1">parts.push(path.call(print, </span><span class="s0">&quot;declaration&quot;</span><span class="s1">));</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(decl.specifiers) {</span>
        <span class="s2">if </span><span class="s1">(decl.specifiers.length === </span><span class="s3">1 </span><span class="s1">&amp;&amp;</span>
            <span class="s1">decl.specifiers[</span><span class="s3">0</span><span class="s1">].type === </span><span class="s0">&quot;ExportBatchSpecifier&quot;</span><span class="s1">) {</span>
            <span class="s1">parts.push(</span><span class="s0">&quot;*&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(decl.specifiers.length === </span><span class="s3">0</span><span class="s1">) {</span>
            <span class="s1">parts.push(</span><span class="s0">&quot;{}&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(decl.specifiers[</span><span class="s3">0</span><span class="s1">].type === </span><span class="s0">&quot;ExportDefaultSpecifier&quot;</span><span class="s1">) {</span>
            <span class="s2">var </span><span class="s1">unbracedSpecifiers_2 = [];</span>
            <span class="s2">var </span><span class="s1">bracedSpecifiers_2 = [];</span>
            <span class="s1">path.each(</span><span class="s2">function </span><span class="s1">(specifierPath) {</span>
                <span class="s2">var </span><span class="s1">spec = specifierPath.getValue();</span>
                <span class="s2">if </span><span class="s1">(spec.type === </span><span class="s0">&quot;ExportDefaultSpecifier&quot;</span><span class="s1">) {</span>
                    <span class="s1">unbracedSpecifiers_2.push(print(specifierPath));</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">bracedSpecifiers_2.push(print(specifierPath));</span>
                <span class="s1">}</span>
            <span class="s1">}, </span><span class="s0">&quot;specifiers&quot;</span><span class="s1">);</span>
            <span class="s1">unbracedSpecifiers_2.forEach(</span><span class="s2">function </span><span class="s1">(lines, i) {</span>
                <span class="s2">if </span><span class="s1">(i &gt; </span><span class="s3">0</span><span class="s1">) {</span>
                    <span class="s1">parts.push(</span><span class="s0">&quot;, &quot;</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s1">parts.push(lines);</span>
            <span class="s1">});</span>
            <span class="s2">if </span><span class="s1">(bracedSpecifiers_2.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s2">var </span><span class="s1">lines_2 = lines_1.fromString(</span><span class="s0">&quot;, &quot;</span><span class="s1">).join(bracedSpecifiers_2);</span>
                <span class="s2">if </span><span class="s1">(lines_2.getLineLength(</span><span class="s3">1</span><span class="s1">) &gt; options.wrapColumn) {</span>
                    <span class="s1">lines_2 = lines_1.concat([</span>
                        <span class="s1">lines_1.fromString(</span><span class="s0">&quot;,</span><span class="s5">\n</span><span class="s0">&quot;</span><span class="s1">).join(bracedSpecifiers_2).indent(options.tabWidth),</span>
                        <span class="s0">&quot;,&quot;</span><span class="s1">,</span>
                    <span class="s1">]);</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(unbracedSpecifiers_2.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
                    <span class="s1">parts.push(</span><span class="s0">&quot;, &quot;</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(lines_2.length &gt; </span><span class="s3">1</span><span class="s1">) {</span>
                    <span class="s1">parts.push(</span><span class="s0">&quot;{</span><span class="s5">\n</span><span class="s0">&quot;</span><span class="s1">, lines_2, </span><span class="s0">&quot;</span><span class="s5">\n</span><span class="s0">}&quot;</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(options.objectCurlySpacing) {</span>
                    <span class="s1">parts.push(</span><span class="s0">&quot;{ &quot;</span><span class="s1">, lines_2, </span><span class="s0">&quot; }&quot;</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">parts.push(</span><span class="s0">&quot;{&quot;</span><span class="s1">, lines_2, </span><span class="s0">&quot;}&quot;</span><span class="s1">);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">parts.push(shouldPrintSpaces ? </span><span class="s0">&quot;{ &quot; </span><span class="s1">: </span><span class="s0">&quot;{&quot;</span><span class="s1">, lines_1.fromString(</span><span class="s0">&quot;, &quot;</span><span class="s1">).join(path.map(print, </span><span class="s0">&quot;specifiers&quot;</span><span class="s1">)), shouldPrintSpaces ? </span><span class="s0">&quot; }&quot; </span><span class="s1">: </span><span class="s0">&quot;}&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(decl.source) {</span>
            <span class="s1">parts.push(</span><span class="s0">&quot; from &quot;</span><span class="s1">, path.call(print, </span><span class="s0">&quot;source&quot;</span><span class="s1">), maybePrintImportAssertions(path, options, print));</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">var </span><span class="s1">lines = lines_1.concat(parts);</span>
    <span class="s2">if </span><span class="s1">(lastNonSpaceCharacter(lines) !== </span><span class="s0">&quot;;&quot; </span><span class="s1">&amp;&amp;</span>
        <span class="s1">!(decl.declaration &amp;&amp;</span>
            <span class="s1">(decl.declaration.type === </span><span class="s0">&quot;FunctionDeclaration&quot; </span><span class="s1">||</span>
                <span class="s1">decl.declaration.type === </span><span class="s0">&quot;ClassDeclaration&quot; </span><span class="s1">||</span>
                <span class="s1">decl.declaration.type === </span><span class="s0">&quot;TSModuleDeclaration&quot; </span><span class="s1">||</span>
                <span class="s1">decl.declaration.type === </span><span class="s0">&quot;TSInterfaceDeclaration&quot; </span><span class="s1">||</span>
                <span class="s1">decl.declaration.type === </span><span class="s0">&quot;TSEnumDeclaration&quot;</span><span class="s1">))) {</span>
        <span class="s1">lines = lines_1.concat([lines, </span><span class="s0">&quot;;&quot;</span><span class="s1">]);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">lines;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">printFlowDeclaration(path, parts) {</span>
    <span class="s2">var </span><span class="s1">parentExportDecl = util.getParentExportDeclaration(path);</span>
    <span class="s2">if </span><span class="s1">(parentExportDecl) {</span>
        <span class="s1">assert_1.</span><span class="s2">default</span><span class="s1">.strictEqual(parentExportDecl.type, </span><span class="s0">&quot;DeclareExportDeclaration&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s4">// If the parent node has type DeclareExportDeclaration, then it</span>
        <span class="s4">// will be responsible for printing the &quot;declare&quot; token. Otherwise</span>
        <span class="s4">// it needs to be printed with this non-exported declaration node.</span>
        <span class="s1">parts.unshift(</span><span class="s0">&quot;declare &quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">lines_1.concat(parts);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">printVariance(path, print) {</span>
    <span class="s2">return </span><span class="s1">path.call(</span><span class="s2">function </span><span class="s1">(variancePath) {</span>
        <span class="s2">var </span><span class="s1">value = variancePath.getValue();</span>
        <span class="s2">if </span><span class="s1">(value) {</span>
            <span class="s2">if </span><span class="s1">(value === </span><span class="s0">&quot;plus&quot;</span><span class="s1">) {</span>
                <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot;+&quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(value === </span><span class="s0">&quot;minus&quot;</span><span class="s1">) {</span>
                <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot;-&quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">print(variancePath);</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">lines_1.fromString(</span><span class="s0">&quot;&quot;</span><span class="s1">);</span>
    <span class="s1">}, </span><span class="s0">&quot;variance&quot;</span><span class="s1">);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">adjustClause(clause, options) {</span>
    <span class="s2">if </span><span class="s1">(clause.length &gt; </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">lines_1.concat([</span><span class="s0">&quot; &quot;</span><span class="s1">, clause]);</span>
    <span class="s2">return </span><span class="s1">lines_1.concat([</span><span class="s0">&quot;</span><span class="s5">\n</span><span class="s0">&quot;</span><span class="s1">, maybeAddSemicolon(clause).indent(options.tabWidth)]);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">lastNonSpaceCharacter(lines) {</span>
    <span class="s2">var </span><span class="s1">pos = lines.lastPos();</span>
    <span class="s2">do </span><span class="s1">{</span>
        <span class="s2">var </span><span class="s1">ch = lines.charAt(pos);</span>
        <span class="s2">if </span><span class="s1">(/\S/.test(ch))</span>
            <span class="s2">return </span><span class="s1">ch;</span>
    <span class="s1">} </span><span class="s2">while </span><span class="s1">(lines.prevPos(pos));</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">endsWithBrace(lines) {</span>
    <span class="s2">return </span><span class="s1">lastNonSpaceCharacter(lines) === </span><span class="s0">&quot;}&quot;</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">swapQuotes(str) {</span>
    <span class="s2">return </span><span class="s1">str.replace(/[</span><span class="s0">'&quot;]/g, function (m) { return (m === '&quot;' ? &quot;'&quot; : '&quot;'); });</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getPossibleRaw(node) {</span>
    <span class="s2">var </span><span class="s1">value = types.getFieldValue(node, </span><span class="s0">&quot;value&quot;</span><span class="s1">);</span>
    <span class="s2">var </span><span class="s1">extra = types.getFieldValue(node, </span><span class="s0">&quot;extra&quot;</span><span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(extra &amp;&amp; </span><span class="s2">typeof </span><span class="s1">extra.raw === </span><span class="s0">&quot;string&quot; </span><span class="s1">&amp;&amp; value == extra.rawValue) {</span>
        <span class="s2">return </span><span class="s1">extra.raw;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(node.type === </span><span class="s0">&quot;Literal&quot;</span><span class="s1">) {</span>
        <span class="s2">var </span><span class="s1">raw = node.raw;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">raw === </span><span class="s0">&quot;string&quot; </span><span class="s1">&amp;&amp; value == raw) {</span>
            <span class="s2">return </span><span class="s1">raw;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">jsSafeStringify(str) {</span>
    <span class="s2">return </span><span class="s1">JSON.stringify(str).replace(/[\u2028\u2029]/g, </span><span class="s2">function </span><span class="s1">(m) {</span>
        <span class="s2">return </span><span class="s0">&quot;</span><span class="s5">\\</span><span class="s0">u&quot; </span><span class="s1">+ m.charCodeAt(</span><span class="s3">0</span><span class="s1">).toString(</span><span class="s3">16</span><span class="s1">);</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">nodeStr(str, options) {</span>
    <span class="s1">isString.assert(str);</span>
    <span class="s2">switch </span><span class="s1">(options.quote) {</span>
        <span class="s2">case </span><span class="s0">&quot;auto&quot;</span><span class="s1">: {</span>
            <span class="s2">var </span><span class="s1">double = jsSafeStringify(str);</span>
            <span class="s2">var </span><span class="s1">single = swapQuotes(jsSafeStringify(swapQuotes(str)));</span>
            <span class="s2">return </span><span class="s1">double.length &gt; single.length ? single : double;</span>
        <span class="s1">}</span>
        <span class="s2">case </span><span class="s0">&quot;single&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">swapQuotes(jsSafeStringify(swapQuotes(str)));</span>
        <span class="s2">case </span><span class="s0">&quot;double&quot;</span><span class="s1">:</span>
        <span class="s2">default</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">jsSafeStringify(str);</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">maybeAddSemicolon(lines) {</span>
    <span class="s2">var </span><span class="s1">eoc = lastNonSpaceCharacter(lines);</span>
    <span class="s2">if </span><span class="s1">(!eoc || </span><span class="s0">&quot;</span><span class="s5">\n</span><span class="s0">};&quot;</span><span class="s1">.indexOf(eoc) &lt; </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">lines_1.concat([lines, </span><span class="s0">&quot;;&quot;</span><span class="s1">]);</span>
    <span class="s2">return </span><span class="s1">lines;</span>
<span class="s1">}</span>
</pre>
</body>
</html>
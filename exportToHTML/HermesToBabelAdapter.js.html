<html>
<head>
<title>HermesToBabelAdapter.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6a8759;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
HermesToBabelAdapter.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>

<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
  <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s1">exports.</span><span class="s2">default </span><span class="s1">= </span><span class="s2">void </span><span class="s3">0</span><span class="s1">;</span>

<span class="s2">var </span><span class="s1">_HermesASTAdapter = _interopRequireDefault(require(</span><span class="s0">&quot;./HermesASTAdapter&quot;</span><span class="s1">));</span>

<span class="s2">function </span><span class="s1">_interopRequireDefault(obj) { </span><span class="s2">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : { </span><span class="s2">default</span><span class="s1">: obj }; }</span>

<span class="s4">/** 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 * 
 *  
 * @format 
 */</span>
<span class="s2">function </span><span class="s1">createSyntaxError(node, err) {</span>
  <span class="s1">const syntaxError = </span><span class="s2">new </span><span class="s1">SyntaxError(err); </span><span class="s4">// $FlowExpectedError[prop-missing]</span>

  <span class="s1">syntaxError.loc = {</span>
    <span class="s1">line: node.loc.start.line,</span>
    <span class="s1">column: node.loc.start.column</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">syntaxError;</span>
<span class="s1">}</span>

<span class="s1">class HermesToBabelAdapter extends _HermesASTAdapter.</span><span class="s2">default </span><span class="s1">{</span>
  <span class="s1">fixSourceLocation(node) {</span>
    <span class="s2">var </span><span class="s1">_this$sourceFilename;</span>

    <span class="s1">const loc = node.loc;</span>

    <span class="s2">if </span><span class="s1">(loc == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">node.loc = {</span>
      <span class="s1">source: (_this$sourceFilename = </span><span class="s2">this</span><span class="s1">.sourceFilename) != </span><span class="s2">null </span><span class="s1">? _this$sourceFilename : </span><span class="s2">null</span><span class="s1">,</span>
      <span class="s1">start: loc.start,</span>
      <span class="s1">end: loc.end</span>
    <span class="s1">};</span>
    <span class="s1">node.start = loc.rangeStart;</span>
    <span class="s1">node.end = loc.rangeEnd;</span>
  <span class="s1">}</span>

  <span class="s1">mapNode(node) {</span>
    <span class="s2">this</span><span class="s1">.fixSourceLocation(node);</span>

    <span class="s2">switch </span><span class="s1">(node.type) {</span>
      <span class="s2">case </span><span class="s0">'Program'</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.mapProgram(node);</span>

      <span class="s2">case </span><span class="s0">'BlockStatement'</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.mapNodeWithDirectives(node);</span>

      <span class="s2">case </span><span class="s0">'Empty'</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.mapEmpty(node);</span>

      <span class="s2">case </span><span class="s0">'Identifier'</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.mapIdentifier(node);</span>

      <span class="s2">case </span><span class="s0">'TemplateElement'</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.mapTemplateElement(node);</span>

      <span class="s2">case </span><span class="s0">'GenericTypeAnnotation'</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.mapGenericTypeAnnotation(node);</span>

      <span class="s2">case </span><span class="s0">'SymbolTypeAnnotation'</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.mapSymbolTypeAnnotation(node);</span>

      <span class="s2">case </span><span class="s0">'Property'</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.mapProperty(node);</span>

      <span class="s2">case </span><span class="s0">'MethodDefinition'</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.mapMethodDefinition(node);</span>

      <span class="s2">case </span><span class="s0">'ImportDeclaration'</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.mapImportDeclaration(node);</span>

      <span class="s2">case </span><span class="s0">'ImportSpecifier'</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.mapImportSpecifier(node);</span>

      <span class="s2">case </span><span class="s0">'ExportDefaultDeclaration'</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.mapExportDefaultDeclaration(node);</span>

      <span class="s2">case </span><span class="s0">'ExportNamedDeclaration'</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.mapExportNamedDeclaration(node);</span>

      <span class="s2">case </span><span class="s0">'ExportNamespaceSpecifier'</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.mapExportNamespaceSpecifier(node);</span>

      <span class="s2">case </span><span class="s0">'ExportAllDeclaration'</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.mapExportAllDeclaration(node);</span>

      <span class="s2">case </span><span class="s0">'RestElement'</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.mapRestElement(node);</span>

      <span class="s2">case </span><span class="s0">'ImportExpression'</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.mapImportExpression(node);</span>

      <span class="s2">case </span><span class="s0">'JSXStringLiteral'</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.mapJSXStringLiteral(node);</span>

      <span class="s2">case </span><span class="s0">'PrivateName'</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.mapPrivateName(node);</span>

      <span class="s2">case </span><span class="s0">'ClassPrivateProperty'</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.mapPrivateProperty(node);</span>

      <span class="s2">case </span><span class="s0">'FunctionDeclaration'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'FunctionExpression'</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.mapFunction(node);</span>

      <span class="s2">case </span><span class="s0">'IndexedAccessType'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'OptionalIndexedAccessType'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'KeyofTypeAnnotation'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'ConditionalType'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'InferType'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'TupleTypeLabeledElement'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'TupleTypeSpreadElement'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'ObjectTypeMappedTypeProperty'</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s0">'ComponentTypeAnnotation'</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.mapUnsupportedTypeAnnotation(node);</span>

      <span class="s2">case </span><span class="s0">'BigIntLiteral'</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.mapBigIntLiteral(node);</span>

      <span class="s2">case </span><span class="s0">'BigIntLiteralTypeAnnotation'</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.mapBigIntLiteralTypeAnnotation(node);</span>

      <span class="s2">case </span><span class="s0">'BigIntTypeAnnotation'</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.mapBigIntTypeAnnotation(node);</span>

      <span class="s2">case </span><span class="s0">'TypeofTypeAnnotation'</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.mapTypeofTypeAnnotation(node);</span>

      <span class="s2">case </span><span class="s0">'QualifiedTypeofIdentifier'</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.mapQualifiedTypeofIdentifier(node);</span>

      <span class="s2">case </span><span class="s0">'DeclareVariable'</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.mapDeclareVariable(node);</span>

      <span class="s2">case </span><span class="s0">'DeclareEnum'</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.mapDeclareEnum(node);</span>

      <span class="s2">case </span><span class="s0">'DeclareComponent'</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.mapDeclareComponent(node);</span>

      <span class="s2">case </span><span class="s0">'JSXElement'</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.mapJSXElement(node);</span>

      <span class="s2">case </span><span class="s0">'ComponentDeclaration'</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.mapComponentDeclaration(node);</span>

      <span class="s2">default</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.mapNodeDefault(node);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">mapProgram(node) {</span>
    <span class="s4">// Visit child nodes and convert to directives</span>
    <span class="s1">const {</span>
      <span class="s1">comments,</span>
      <span class="s1">...program</span>
    <span class="s1">} = </span><span class="s2">this</span><span class="s1">.mapNodeWithDirectives(node);</span>
    <span class="s1">program.sourceType = </span><span class="s2">this</span><span class="s1">.getSourceType(); </span><span class="s4">// Adjust start loc to beginning of file</span>

    <span class="s1">program.loc.start = {</span>
      <span class="s1">line: </span><span class="s3">1</span><span class="s1">,</span>
      <span class="s1">column: </span><span class="s3">0</span>
    <span class="s1">};</span>
    <span class="s1">program.start = </span><span class="s3">0</span><span class="s1">; </span><span class="s4">// Adjust end loc to include last comment if program ends with a comment</span>

    <span class="s2">if </span><span class="s1">(comments.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
      <span class="s1">const lastComment = comments[comments.length - </span><span class="s3">1</span><span class="s1">];</span>

      <span class="s2">if </span><span class="s1">(lastComment.end &gt; program.end) {</span>
        <span class="s1">program.loc.end = lastComment.loc.end;</span>
        <span class="s1">program.end = lastComment.end;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s4">// Rename root node to File node and move Program node under program property</span>


    <span class="s2">return </span><span class="s1">{</span>
      <span class="s1">type: </span><span class="s0">'File'</span><span class="s1">,</span>
      <span class="s1">loc: program.loc,</span>
      <span class="s1">start: program.start,</span>
      <span class="s1">end: program.end,</span>
      <span class="s1">program,</span>
      <span class="s1">comments</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s1">mapNodeWithDirectives(node) {</span>
    <span class="s1">const directives = [];</span>

    <span class="s2">for </span><span class="s1">(const child of node.body) {</span>
      <span class="s2">if </span><span class="s1">(child.type === </span><span class="s0">'ExpressionStatement' </span><span class="s1">&amp;&amp; child.directive != </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s4">// Visit directive children</span>
        <span class="s1">const directiveChild = </span><span class="s2">this</span><span class="s1">.mapNode(child); </span><span class="s4">// Modify string literal node to be DirectiveLiteral node</span>

        <span class="s1">directiveChild.expression.type = </span><span class="s0">'DirectiveLiteral'</span><span class="s1">; </span><span class="s4">// Construct Directive node with DirectiveLiteral value</span>

        <span class="s1">directives.push({</span>
          <span class="s1">type: </span><span class="s0">'Directive'</span><span class="s1">,</span>
          <span class="s1">loc: directiveChild.loc,</span>
          <span class="s1">start: directiveChild.start,</span>
          <span class="s1">end: directiveChild.end,</span>
          <span class="s1">value: directiveChild.expression</span>
        <span class="s1">});</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s4">// Once we have found the first non-directive node we know there cannot be any more directives</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s4">// Move directives from body to new directives array</span>


    <span class="s1">node.directives = directives;</span>

    <span class="s2">if </span><span class="s1">(directives.length !== </span><span class="s3">0</span><span class="s1">) {</span>
      <span class="s1">node.body = node.body.slice(directives.length);</span>
    <span class="s1">} </span><span class="s4">// Visit expression statement children</span>


    <span class="s1">const body = node.body;</span>

    <span class="s2">for </span><span class="s1">(let i = </span><span class="s3">0</span><span class="s1">; i &lt; body.length; i++) {</span>
      <span class="s1">const child = body[i];</span>

      <span class="s2">if </span><span class="s1">(child != </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">body[i] = </span><span class="s2">this</span><span class="s1">.mapNode(child);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">node;</span>
  <span class="s1">}</span>

  <span class="s1">mapIdentifier(node) {</span>
    <span class="s1">node.loc.identifierName = node.name;</span>
    <span class="s2">return this</span><span class="s1">.mapNodeDefault(node);</span>
  <span class="s1">}</span>

  <span class="s1">mapTemplateElement(node) {</span>
    <span class="s4">// Adjust start loc to exclude &quot;`&quot; at beginning of template literal if this is the first quasi,</span>
    <span class="s4">// otherwise exclude &quot;}&quot; from previous expression.</span>
    <span class="s1">const startCharsToExclude = </span><span class="s3">1</span><span class="s1">; </span><span class="s4">// Adjust end loc to exclude &quot;`&quot; at end of template literal if this is the last quasi,</span>
    <span class="s4">// otherwise exclude &quot;${&quot; from next expression.</span>

    <span class="s1">const endCharsToExclude = node.tail ? </span><span class="s3">1 </span><span class="s1">: </span><span class="s3">2</span><span class="s1">;</span>
    <span class="s2">return </span><span class="s1">{</span>
      <span class="s1">type: </span><span class="s0">'TemplateElement'</span><span class="s1">,</span>
      <span class="s1">loc: {</span>
        <span class="s1">start: {</span>
          <span class="s1">line: node.loc.start.line,</span>
          <span class="s1">column: node.loc.start.column + startCharsToExclude</span>
        <span class="s1">},</span>
        <span class="s1">end: {</span>
          <span class="s1">line: node.loc.end.line,</span>
          <span class="s1">column: node.loc.end.column - endCharsToExclude</span>
        <span class="s1">}</span>
      <span class="s1">},</span>
      <span class="s1">start: node.start + startCharsToExclude,</span>
      <span class="s1">end: node.end - endCharsToExclude,</span>
      <span class="s1">tail: node.tail,</span>
      <span class="s1">value: {</span>
        <span class="s1">cooked: node.cooked,</span>
        <span class="s1">raw: node.raw</span>
      <span class="s1">}</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s1">mapGenericTypeAnnotation(node) {</span>
    <span class="s4">// Convert simple `this` generic type to ThisTypeAnnotation</span>
    <span class="s2">if </span><span class="s1">(node.typeParameters == </span><span class="s2">null </span><span class="s1">&amp;&amp; node.id.type === </span><span class="s0">'Identifier' </span><span class="s1">&amp;&amp; node.id.name === </span><span class="s0">'this'</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">type: </span><span class="s0">'ThisTypeAnnotation'</span><span class="s1">,</span>
        <span class="s1">loc: node.loc,</span>
        <span class="s1">start: node.start,</span>
        <span class="s1">end: node.end</span>
      <span class="s1">};</span>
    <span class="s1">}</span>

    <span class="s2">return this</span><span class="s1">.mapNodeDefault(node);</span>
  <span class="s1">}</span>

  <span class="s1">mapSymbolTypeAnnotation(node) {</span>
    <span class="s2">return </span><span class="s1">{</span>
      <span class="s1">type: </span><span class="s0">'GenericTypeAnnotation'</span><span class="s1">,</span>
      <span class="s1">loc: node.loc,</span>
      <span class="s1">start: node.start,</span>
      <span class="s1">end: node.end,</span>
      <span class="s1">id: {</span>
        <span class="s1">type: </span><span class="s0">'Identifier'</span><span class="s1">,</span>
        <span class="s1">loc: node.loc,</span>
        <span class="s1">start: node.start,</span>
        <span class="s1">end: node.end,</span>
        <span class="s1">name: </span><span class="s0">'symbol'</span>
      <span class="s1">},</span>
      <span class="s1">typeParameters: </span><span class="s2">null</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s1">mapProperty(node) {</span>
    <span class="s1">const key = </span><span class="s2">this</span><span class="s1">.mapNode(node.key);</span>
    <span class="s1">const value = </span><span class="s2">this</span><span class="s1">.mapNode(node.value); </span><span class="s4">// Convert methods, getters, and setters to ObjectMethod nodes</span>

    <span class="s2">if </span><span class="s1">(node.method || node.kind !== </span><span class="s0">'init'</span><span class="s1">) {</span>
      <span class="s4">// Properties under the FunctionExpression value that should be moved</span>
      <span class="s4">// to the ObjectMethod node itself.</span>
      <span class="s1">const {</span>
        <span class="s1">id,</span>
        <span class="s1">params,</span>
        <span class="s1">body,</span>
        <span class="s1">async,</span>
        <span class="s1">generator,</span>
        <span class="s1">returnType,</span>
        <span class="s1">typeParameters,</span>
        <span class="s1">predicate</span>
      <span class="s1">} = value;</span>
      <span class="s1">const newNode = {</span>
        <span class="s1">type: </span><span class="s0">'ObjectMethod'</span><span class="s1">,</span>
        <span class="s1">loc: node.loc,</span>
        <span class="s1">start: node.start,</span>
        <span class="s1">end: node.end,</span>
        <span class="s4">// Non getter or setter methods have `kind = method`</span>
        <span class="s1">kind: node.kind === </span><span class="s0">'init' </span><span class="s1">? </span><span class="s0">'method' </span><span class="s1">: node.kind,</span>
        <span class="s1">method: node.kind === </span><span class="s0">'init' </span><span class="s1">? </span><span class="s2">true </span><span class="s1">: </span><span class="s2">false</span><span class="s1">,</span>
        <span class="s1">computed: node.computed,</span>
        <span class="s1">key,</span>
        <span class="s1">id,</span>
        <span class="s1">params,</span>
        <span class="s1">body,</span>
        <span class="s1">async,</span>
        <span class="s1">generator,</span>
        <span class="s1">returnType,</span>
        <span class="s1">typeParameters,</span>
        <span class="s1">predicate</span>
      <span class="s1">};</span>

      <span class="s2">if </span><span class="s1">(node.kind !== </span><span class="s0">'init'</span><span class="s1">) {</span>
        <span class="s4">// babel emits an empty variance property on accessors for some reason</span>
        <span class="s1">newNode.variance = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">return </span><span class="s1">newNode;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s4">// Non-method property nodes should be renamed to ObjectProperty</span>
      <span class="s1">node.type = </span><span class="s0">'ObjectProperty'</span><span class="s1">;</span>
      <span class="s2">return </span><span class="s1">node;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">mapMethodDefinition(node) {</span>
    <span class="s1">const key = </span><span class="s2">this</span><span class="s1">.mapNode(node.key);</span>
    <span class="s1">const value = </span><span class="s2">this</span><span class="s1">.mapNode(node.value); </span><span class="s4">// Properties under the FunctionExpression value that should be moved</span>
    <span class="s4">// to the ClassMethod node itself.</span>

    <span class="s1">const {</span>
      <span class="s1">id,</span>
      <span class="s1">params,</span>
      <span class="s1">body,</span>
      <span class="s1">async,</span>
      <span class="s1">generator,</span>
      <span class="s1">returnType,</span>
      <span class="s1">typeParameters,</span>
      <span class="s1">predicate</span>
    <span class="s1">} = value;</span>
    <span class="s2">return </span><span class="s1">{</span>
      <span class="s1">type: </span><span class="s0">'ClassMethod'</span><span class="s1">,</span>
      <span class="s1">loc: node.loc,</span>
      <span class="s1">start: node.start,</span>
      <span class="s1">end: node.end,</span>
      <span class="s1">kind: node.kind,</span>
      <span class="s1">computed: node.computed,</span>
      <span class="s1">static: node.static,</span>
      <span class="s1">key,</span>
      <span class="s1">id,</span>
      <span class="s1">params,</span>
      <span class="s1">body,</span>
      <span class="s1">async,</span>
      <span class="s1">generator,</span>
      <span class="s1">returnType,</span>
      <span class="s1">typeParameters,</span>
      <span class="s1">predicate</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s1">mapRestElement(node) {</span>
    <span class="s1">const restElement = </span><span class="s2">this</span><span class="s1">.mapNodeDefault(node); </span><span class="s4">// Hermes puts type annotations on rest elements on the argument node,</span>
    <span class="s4">// but Babel expects type annotations on the rest element node itself.</span>

    <span class="s1">const annotation = restElement.argument.typeAnnotation;</span>

    <span class="s2">if </span><span class="s1">(annotation != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">restElement.typeAnnotation = annotation;</span>
      <span class="s1">restElement.argument.typeAnnotation = </span><span class="s2">null</span><span class="s1">; </span><span class="s4">// Unfortunately there's no way for us to recover the end location of</span>
      <span class="s4">// the argument for the general case</span>

      <span class="s2">if </span><span class="s1">(restElement.argument.type === </span><span class="s0">'Identifier'</span><span class="s1">) {</span>
        <span class="s1">restElement.argument.end = restElement.argument.start + restElement.argument.name.length;</span>
        <span class="s1">restElement.argument.loc.end = { ...restElement.argument.loc.start,</span>
          <span class="s1">column: restElement.argument.loc.start.column + restElement.argument.name.length</span>
        <span class="s1">};</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">restElement;</span>
  <span class="s1">}</span>

  <span class="s1">mapImportExpression(node) {</span>
    <span class="s4">// Babel expects ImportExpression to be structued as a regular</span>
    <span class="s4">// CallExpression where the callee is an Import node.</span>
    <span class="s2">return </span><span class="s1">{</span>
      <span class="s1">type: </span><span class="s0">'CallExpression'</span><span class="s1">,</span>
      <span class="s1">loc: node.loc,</span>
      <span class="s1">start: node.start,</span>
      <span class="s1">end: node.end,</span>
      <span class="s1">callee: {</span>
        <span class="s1">type: </span><span class="s0">'Import'</span><span class="s1">,</span>
        <span class="s1">loc: { ...node.loc,</span>
          <span class="s1">end: { ...node.loc.start,</span>
            <span class="s1">column: node.loc.start.column + </span><span class="s0">'import'</span><span class="s1">.length</span>
          <span class="s1">}</span>
        <span class="s1">},</span>
        <span class="s1">start: node.start,</span>
        <span class="s1">end: node.start + </span><span class="s0">'import'</span><span class="s1">.length</span>
      <span class="s1">},</span>
      <span class="s1">arguments: [</span><span class="s2">this</span><span class="s1">.mapNode(node.source)]</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s1">mapJSXStringLiteral(node) {</span>
    <span class="s4">// Babel expects StringLiterals in JSX,</span>
    <span class="s4">// but Hermes uses JSXStringLiteral to attach the raw value without</span>
    <span class="s4">// having to internally attach it to every single string literal.</span>
    <span class="s2">return </span><span class="s1">{</span>
      <span class="s1">type: </span><span class="s0">'StringLiteral'</span><span class="s1">,</span>
      <span class="s1">loc: node.loc,</span>
      <span class="s1">start: node.start,</span>
      <span class="s1">end: node.end,</span>
      <span class="s1">value: node.value</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s1">mapFunction(node) {</span>
    <span class="s4">// Remove the first parameter if it is a this-type annotation,</span>
    <span class="s4">// which is not recognized by Babel.</span>
    <span class="s2">if </span><span class="s1">(node.params.length !== </span><span class="s3">0 </span><span class="s1">&amp;&amp; node.params[</span><span class="s3">0</span><span class="s1">].name === </span><span class="s0">'this'</span><span class="s1">) {</span>
      <span class="s1">node.params.shift();</span>
    <span class="s1">}</span>

    <span class="s2">return this</span><span class="s1">.mapNodeDefault(node);</span>
  <span class="s1">}</span>
  <span class="s4">/** 
   * If Babel (the version we target) does not support a type annotation we 
   * parse, we need to return some other valid type annotation in its place. 
   */</span>


  <span class="s1">mapUnsupportedTypeAnnotation(node) {</span>
    <span class="s2">return </span><span class="s1">{</span>
      <span class="s1">type: </span><span class="s0">'AnyTypeAnnotation'</span><span class="s1">,</span>
      <span class="s1">loc: node.loc,</span>
      <span class="s1">start: node.start,</span>
      <span class="s1">end: node.end</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s1">mapBigIntLiteral(node) {</span>
    <span class="s1">node.value = </span><span class="s2">this</span><span class="s1">.getBigIntLiteralValue(node.bigint).value;</span>
    <span class="s2">return </span><span class="s1">node;</span>
  <span class="s1">}</span>

  <span class="s1">mapBigIntLiteralTypeAnnotation(node) {</span>
    <span class="s1">node.value = </span><span class="s2">this</span><span class="s1">.getBigIntLiteralValue(node.raw).value;</span>
    <span class="s2">return </span><span class="s1">node;</span>
  <span class="s1">}</span>
  <span class="s4">/** 
   * Babel does not parse the bigint keyword type as the keyword node. 
   * So we need to down-level the AST to a plain GenericTypeAnnotation 
   */</span>


  <span class="s1">mapBigIntTypeAnnotation(node) {</span>
    <span class="s2">return </span><span class="s1">{</span>
      <span class="s1">type: </span><span class="s0">'GenericTypeAnnotation'</span><span class="s1">,</span>
      <span class="s1">id: {</span>
        <span class="s1">type: </span><span class="s0">'Identifier'</span><span class="s1">,</span>
        <span class="s1">name: </span><span class="s0">'bigint'</span><span class="s1">,</span>
        <span class="s1">loc: node.loc,</span>
        <span class="s1">start: node.start,</span>
        <span class="s1">end: node.end</span>
      <span class="s1">},</span>
      <span class="s1">typeParameters: </span><span class="s2">null</span><span class="s1">,</span>
      <span class="s1">loc: node.loc,</span>
      <span class="s1">start: node.start,</span>
      <span class="s1">end: node.end</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s1">mapPrivateProperty(nodeUnprocessed) {</span>
    <span class="s1">const node = </span><span class="s2">this</span><span class="s1">.mapNodeDefault(nodeUnprocessed);</span>
    <span class="s1">node.key = {</span>
      <span class="s1">type: </span><span class="s0">'PrivateName'</span><span class="s1">,</span>
      <span class="s1">id: { ...node.key,</span>
        <span class="s4">// babel doesn't include the hash in the identifier</span>
        <span class="s1">start: node.key.start + </span><span class="s3">1</span><span class="s1">,</span>
        <span class="s1">loc: { ...node.key.loc,</span>
          <span class="s1">start: { ...node.key.loc.start,</span>
            <span class="s1">column: node.key.loc.start.column + </span><span class="s3">1</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">},</span>
      <span class="s1">start: node.key.start,</span>
      <span class="s1">end: node.key.end,</span>
      <span class="s1">loc: node.key.loc</span>
    <span class="s1">};</span>
    <span class="s2">return </span><span class="s1">node;</span>
  <span class="s1">}</span>

  <span class="s1">mapPrivateName(node) {</span>
    <span class="s4">// babel doesn't include the hash in the identifier</span>
    <span class="s1">node.id.start += </span><span class="s3">1</span><span class="s1">;</span>
    <span class="s1">node.id.loc.start.column += </span><span class="s3">1</span><span class="s1">;</span>
    <span class="s2">return </span><span class="s1">node;</span>
  <span class="s1">}</span>

  <span class="s1">mapExportNamespaceSpecifier(nodeUnprocessed) {</span>
    <span class="s1">const node = </span><span class="s2">this</span><span class="s1">.mapNodeDefault(nodeUnprocessed); </span><span class="s4">// the hermes AST emits the location as the location of the entire export</span>
    <span class="s4">// but babel emits the location as *just* the &quot;* as id&quot; bit</span>
    <span class="s4">// the end will always align with the end of the identifier (ezpz)</span>
    <span class="s4">// but the start will align with the &quot;*&quot; token - which we can't recover from just the AST</span>
    <span class="s4">// so we just fudge the start location a bit to get it &quot;good enough&quot;</span>
    <span class="s4">// it will be wrong if the AST is anything like &quot;export      * as x from 'y'&quot;... but oh well</span>

    <span class="s1">node.start = node.start + </span><span class="s0">'export '</span><span class="s1">.length;</span>
    <span class="s1">node.loc.start.column = node.loc.start.column + </span><span class="s0">'export '</span><span class="s1">.length;</span>
    <span class="s1">node.end = node.exported.end;</span>
    <span class="s1">node.loc.end = {</span>
      <span class="s1">column: node.exported.loc.end.column,</span>
      <span class="s1">line: node.exported.loc.end.line</span>
    <span class="s1">};</span>
    <span class="s2">return </span><span class="s1">node;</span>
  <span class="s1">}</span>

  <span class="s1">mapTypeofTypeAnnotation(nodeUnprocessed) {</span>
    <span class="s1">nodeUnprocessed.argument = {</span>
      <span class="s1">type: </span><span class="s0">'GenericTypeAnnotation'</span><span class="s1">,</span>
      <span class="s1">id: nodeUnprocessed.argument,</span>
      <span class="s1">typeParameters: </span><span class="s2">null</span><span class="s1">,</span>
      <span class="s1">loc: nodeUnprocessed.argument.loc</span>
    <span class="s1">};</span>
    <span class="s2">return this</span><span class="s1">.mapNodeDefault(nodeUnprocessed);</span>
  <span class="s1">}</span>

  <span class="s1">mapQualifiedTypeofIdentifier(nodeUnprocessed) {</span>
    <span class="s1">nodeUnprocessed.type = </span><span class="s0">'QualifiedTypeIdentifier'</span><span class="s1">;</span>
    <span class="s2">return this</span><span class="s1">.mapNodeDefault(nodeUnprocessed);</span>
  <span class="s1">}</span>

  <span class="s1">mapDeclareVariable(nodeUnprocessed) {</span>
    <span class="s2">delete </span><span class="s1">nodeUnprocessed.kind;</span>
    <span class="s2">return this</span><span class="s1">.mapNodeDefault(nodeUnprocessed);</span>
  <span class="s1">}</span>

  <span class="s1">mapDeclareEnum(nodeUnprocessed) {</span>
    <span class="s1">nodeUnprocessed.id.typeAnnotation = </span><span class="s2">this</span><span class="s1">.mapUnsupportedTypeAnnotation(nodeUnprocessed.body);</span>
    <span class="s2">delete </span><span class="s1">nodeUnprocessed.body;</span>
    <span class="s1">nodeUnprocessed.type = </span><span class="s0">'DeclareVariable'</span><span class="s1">;</span>
    <span class="s2">return this</span><span class="s1">.mapDeclareVariable(nodeUnprocessed);</span>
  <span class="s1">}</span>

  <span class="s1">mapDeclareComponent(nodeUnprocessed) {</span>
    <span class="s1">nodeUnprocessed.id.typeAnnotation = </span><span class="s2">this</span><span class="s1">.mapUnsupportedTypeAnnotation(nodeUnprocessed);</span>
    <span class="s2">delete </span><span class="s1">nodeUnprocessed.params;</span>
    <span class="s2">delete </span><span class="s1">nodeUnprocessed.rest;</span>
    <span class="s2">delete </span><span class="s1">nodeUnprocessed.typeParameters;</span>
    <span class="s2">delete </span><span class="s1">nodeUnprocessed.rendersType;</span>
    <span class="s1">nodeUnprocessed.type = </span><span class="s0">'DeclareVariable'</span><span class="s1">;</span>
    <span class="s2">return this</span><span class="s1">.mapDeclareVariable(nodeUnprocessed);</span>
  <span class="s1">}</span>

  <span class="s1">mapJSXElement(nodeUnprocessed) {</span>
    <span class="s2">delete </span><span class="s1">nodeUnprocessed.openingElement.typeArguments;</span>
    <span class="s2">return this</span><span class="s1">.mapNodeDefault(nodeUnprocessed);</span>
  <span class="s1">}</span>

  <span class="s1">mapComponentDeclaration(nodeUnprocessed) {</span>
    <span class="s1">let rendersType = nodeUnprocessed.rendersType;</span>

    <span class="s2">if </span><span class="s1">(rendersType == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s4">// Create empty loc for return type annotation nodes</span>
      <span class="s1">const createRendersTypeLoc = () =&gt; ({</span>
        <span class="s1">loc: {</span>
          <span class="s1">start: { ...nodeUnprocessed.body.loc.end</span>
          <span class="s1">},</span>
          <span class="s1">end: { ...nodeUnprocessed.body.loc.end</span>
          <span class="s1">},</span>
          <span class="s1">rangeStart: nodeUnprocessed.body.loc.rangeStart,</span>
          <span class="s1">rangeEnd: nodeUnprocessed.body.loc.rangeEnd</span>
        <span class="s1">}</span>
      <span class="s1">});</span>

      <span class="s1">rendersType = {</span>
        <span class="s1">type: </span><span class="s0">'GenericTypeAnnotation'</span><span class="s1">,</span>
        <span class="s1">id: {</span>
          <span class="s1">type: </span><span class="s0">'QualifiedTypeIdentifier'</span><span class="s1">,</span>
          <span class="s1">qualification: {</span>
            <span class="s1">type: </span><span class="s0">'Identifier'</span><span class="s1">,</span>
            <span class="s1">name: </span><span class="s0">'React'</span><span class="s1">,</span>
            <span class="s1">...createRendersTypeLoc()</span>
          <span class="s1">},</span>
          <span class="s1">id: {</span>
            <span class="s1">type: </span><span class="s0">'Identifier'</span><span class="s1">,</span>
            <span class="s1">name: </span><span class="s0">'Node'</span><span class="s1">,</span>
            <span class="s1">...createRendersTypeLoc()</span>
          <span class="s1">}</span>
        <span class="s1">},</span>
        <span class="s1">typeParameters: </span><span class="s2">null</span><span class="s1">,</span>
        <span class="s1">...createRendersTypeLoc()</span>
      <span class="s1">};</span>
    <span class="s1">}</span>

    <span class="s2">function </span><span class="s1">getParamName(paramName) {</span>
      <span class="s2">switch </span><span class="s1">(paramName.type) {</span>
        <span class="s2">case </span><span class="s0">'Identifier'</span><span class="s1">:</span>
          <span class="s2">return </span><span class="s1">paramName.name;</span>

        <span class="s2">case </span><span class="s0">'StringLiteral'</span><span class="s1">:</span>
          <span class="s2">return </span><span class="s1">paramName.value;</span>

        <span class="s2">default</span><span class="s1">:</span>
          <span class="s2">throw </span><span class="s1">createSyntaxError(paramName, `Unknown Component parameter name type of </span><span class="s0">&quot;${paramName.type}&quot;</span><span class="s1">`);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">const properties = nodeUnprocessed.params.map(param =&gt; {</span>
      <span class="s2">switch </span><span class="s1">(param.type) {</span>
        <span class="s2">case </span><span class="s0">'RestElement'</span><span class="s1">:</span>
          <span class="s1">{</span>
            <span class="s2">delete </span><span class="s1">param.typeAnnotation;</span>
            <span class="s2">return </span><span class="s1">param;</span>
          <span class="s1">}</span>

        <span class="s2">case </span><span class="s0">'ComponentParameter'</span><span class="s1">:</span>
          <span class="s1">{</span>
            <span class="s2">if </span><span class="s1">(getParamName(param.name) === </span><span class="s0">'ref'</span><span class="s1">) {</span>
              <span class="s2">throw </span><span class="s1">createSyntaxError(param, </span><span class="s0">'Component parameters named &quot;ref&quot; are currently not supported'</span><span class="s1">);</span>
            <span class="s1">}</span>

            <span class="s2">if </span><span class="s1">(param.name.type === </span><span class="s0">'Identifier'</span><span class="s1">) {</span>
              <span class="s2">delete </span><span class="s1">param.name.typeAnnotation;</span>
            <span class="s1">}</span>

            <span class="s2">if </span><span class="s1">(param.local.type === </span><span class="s0">'AssignmentPattern'</span><span class="s1">) {</span>
              <span class="s2">delete </span><span class="s1">param.local.left.typeAnnotation;</span>
              <span class="s2">delete </span><span class="s1">param.local.left.optional;</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
              <span class="s2">delete </span><span class="s1">param.local.typeAnnotation;</span>
              <span class="s2">delete </span><span class="s1">param.local.optional;</span>
            <span class="s1">}</span>

            <span class="s2">return </span><span class="s1">{</span>
              <span class="s1">type: </span><span class="s0">'ObjectProperty'</span><span class="s1">,</span>
              <span class="s1">key: param.name,</span>
              <span class="s1">value: param.local,</span>
              <span class="s1">method: </span><span class="s2">false</span><span class="s1">,</span>
              <span class="s1">shorthand: param.shorthand,</span>
              <span class="s1">computed: </span><span class="s2">false</span><span class="s1">,</span>
              <span class="s1">loc: param.loc,</span>
              <span class="s1">start: param.start,</span>
              <span class="s1">end: param.end</span>
            <span class="s1">};</span>
          <span class="s1">}</span>

        <span class="s2">default</span><span class="s1">:</span>
          <span class="s1">{</span>
            <span class="s2">throw </span><span class="s1">createSyntaxError(param, `Unknown Component parameter type of </span><span class="s0">&quot;${param.type}&quot;</span><span class="s1">`);</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">});</span>

    <span class="s1">const paramsLoc = (() =&gt; {</span>
      <span class="s2">if </span><span class="s1">(properties.length === </span><span class="s3">0</span><span class="s1">) {</span>
        <span class="s4">// No props, approximate range via existing nodes.</span>
        <span class="s1">const startLoc = nodeUnprocessed.typeParameters != </span><span class="s2">null </span><span class="s1">? nodeUnprocessed.typeParameters.loc : nodeUnprocessed.id.loc;</span>
        <span class="s2">return </span><span class="s1">{</span>
          <span class="s1">start: startLoc.end,</span>
          <span class="s1">end: rendersType.loc.start,</span>
          <span class="s1">startRange: startLoc.endRange,</span>
          <span class="s1">endRange: rendersType.loc.startRange</span>
        <span class="s1">};</span>
      <span class="s1">}</span>

      <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">start: properties[</span><span class="s3">0</span><span class="s1">].loc.start,</span>
        <span class="s1">end: properties[properties.length - </span><span class="s3">1</span><span class="s1">].loc.end,</span>
        <span class="s1">startRange: properties[</span><span class="s3">0</span><span class="s1">].loc.startRange,</span>
        <span class="s1">endRange: properties[properties.length - </span><span class="s3">1</span><span class="s1">].loc.endRange</span>
      <span class="s1">};</span>
    <span class="s1">})(); </span><span class="s4">// Create empty loc for type annotation nodes</span>


    <span class="s1">const createParamsTypeLoc = () =&gt; ({</span>
      <span class="s1">loc: {</span>
        <span class="s1">start: { ...paramsLoc.end</span>
        <span class="s1">},</span>
        <span class="s1">end: { ...paramsLoc.end</span>
        <span class="s1">},</span>
        <span class="s1">startRange: paramsLoc.endRange,</span>
        <span class="s1">endRange: paramsLoc.endRange</span>
      <span class="s1">}</span>
    <span class="s1">});</span>

    <span class="s1">const params = [{</span>
      <span class="s1">type: </span><span class="s0">'ObjectPattern'</span><span class="s1">,</span>
      <span class="s1">properties,</span>
      <span class="s1">typeAnnotation: {</span>
        <span class="s1">type: </span><span class="s0">'TypeAnnotation'</span><span class="s1">,</span>
        <span class="s1">typeAnnotation: {</span>
          <span class="s1">type: </span><span class="s0">'GenericTypeAnnotation'</span><span class="s1">,</span>
          <span class="s1">id: {</span>
            <span class="s1">type: </span><span class="s0">'Identifier'</span><span class="s1">,</span>
            <span class="s1">name: </span><span class="s0">'$ReadOnly'</span><span class="s1">,</span>
            <span class="s1">...createParamsTypeLoc()</span>
          <span class="s1">},</span>
          <span class="s1">typeParameters: {</span>
            <span class="s1">type: </span><span class="s0">'TypeParameterInstantiation'</span><span class="s1">,</span>
            <span class="s1">params: [{</span>
              <span class="s1">type: </span><span class="s0">'ObjectTypeAnnotation'</span><span class="s1">,</span>
              <span class="s1">callProperties: [],</span>
              <span class="s1">properties: [],</span>
              <span class="s1">indexers: [],</span>
              <span class="s1">internalSlots: [],</span>
              <span class="s1">exact: </span><span class="s2">false</span><span class="s1">,</span>
              <span class="s1">inexact: </span><span class="s2">true</span><span class="s1">,</span>
              <span class="s1">...createParamsTypeLoc()</span>
            <span class="s1">}],</span>
            <span class="s1">...createParamsTypeLoc()</span>
          <span class="s1">},</span>
          <span class="s1">...createParamsTypeLoc()</span>
        <span class="s1">},</span>
        <span class="s1">...createParamsTypeLoc()</span>
      <span class="s1">},</span>
      <span class="s1">loc: paramsLoc</span>
    <span class="s1">}];</span>
    <span class="s1">const functionComponent = {</span>
      <span class="s1">type: </span><span class="s0">'FunctionDeclaration'</span><span class="s1">,</span>
      <span class="s1">id: nodeUnprocessed.id,</span>
      <span class="s1">typeParameters: nodeUnprocessed.typeParameters,</span>
      <span class="s1">params,</span>
      <span class="s1">returnType: rendersType,</span>
      <span class="s1">body: nodeUnprocessed.body,</span>
      <span class="s1">async: </span><span class="s2">false</span><span class="s1">,</span>
      <span class="s1">generator: </span><span class="s2">false</span><span class="s1">,</span>
      <span class="s1">predicate: </span><span class="s2">null</span><span class="s1">,</span>
      <span class="s1">loc: nodeUnprocessed.loc</span>
    <span class="s1">};</span>
    <span class="s2">return this</span><span class="s1">.mapNodeDefault(functionComponent);</span>
  <span class="s1">}</span>

<span class="s1">}</span>

<span class="s1">exports.</span><span class="s2">default </span><span class="s1">= HermesToBabelAdapter;</span></pre>
</body>
</html>
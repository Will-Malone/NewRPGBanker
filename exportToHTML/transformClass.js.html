<html>
<head>
<title>transformClass.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6a8759;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
transformClass.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>

<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
  <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s1">exports.</span><span class="s2">default </span><span class="s1">= transformClass;</span>
<span class="s2">var </span><span class="s1">_helperFunctionName = require(</span><span class="s0">&quot;@babel/helper-function-name&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_helperReplaceSupers = require(</span><span class="s0">&quot;@babel/helper-replace-supers&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_helperEnvironmentVisitor = require(</span><span class="s0">&quot;@babel/helper-environment-visitor&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_helperOptimiseCallExpression = require(</span><span class="s0">&quot;@babel/helper-optimise-call-expression&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_core = require(</span><span class="s0">&quot;@babel/core&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_helperAnnotateAsPure = require(</span><span class="s0">&quot;@babel/helper-annotate-as-pure&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_inlineCreateSuperHelpers = require(</span><span class="s0">&quot;./inline-createSuper-helpers&quot;</span><span class="s1">);</span>
<span class="s2">function </span><span class="s1">buildConstructor(classRef, constructorBody, node) {</span>
  <span class="s1">const func = _core.types.functionDeclaration(_core.types.cloneNode(classRef), [], constructorBody);</span>
  <span class="s1">_core.types.inherits(func, node);</span>
  <span class="s2">return </span><span class="s1">func;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">transformClass(path, file, builtinClasses, isLoose, assumptions, supportUnicodeId) {</span>
  <span class="s1">const classState = {</span>
    <span class="s1">parent: undefined,</span>
    <span class="s1">scope: undefined,</span>
    <span class="s1">node: undefined,</span>
    <span class="s1">path: undefined,</span>
    <span class="s1">file: undefined,</span>
    <span class="s1">classId: undefined,</span>
    <span class="s1">classRef: undefined,</span>
    <span class="s1">superFnId: undefined,</span>
    <span class="s1">superName: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">superReturns: [],</span>
    <span class="s1">isDerived: </span><span class="s2">false</span><span class="s1">,</span>
    <span class="s1">extendsNative: </span><span class="s2">false</span><span class="s1">,</span>
    <span class="s1">construct: undefined,</span>
    <span class="s1">constructorBody: undefined,</span>
    <span class="s1">userConstructor: undefined,</span>
    <span class="s1">userConstructorPath: undefined,</span>
    <span class="s1">hasConstructor: </span><span class="s2">false</span><span class="s1">,</span>
    <span class="s1">body: [],</span>
    <span class="s1">superThises: [],</span>
    <span class="s1">pushedConstructor: </span><span class="s2">false</span><span class="s1">,</span>
    <span class="s1">pushedInherits: </span><span class="s2">false</span><span class="s1">,</span>
    <span class="s1">pushedCreateClass: </span><span class="s2">false</span><span class="s1">,</span>
    <span class="s1">protoAlias: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">isLoose: </span><span class="s2">false</span><span class="s1">,</span>
    <span class="s1">dynamicKeys: </span><span class="s2">new </span><span class="s1">Map(),</span>
    <span class="s1">methods: {</span>
      <span class="s1">instance: {</span>
        <span class="s1">hasComputed: </span><span class="s2">false</span><span class="s1">,</span>
        <span class="s1">list: [],</span>
        <span class="s1">map: </span><span class="s2">new </span><span class="s1">Map()</span>
      <span class="s1">},</span>
      <span class="s1">static: {</span>
        <span class="s1">hasComputed: </span><span class="s2">false</span><span class="s1">,</span>
        <span class="s1">list: [],</span>
        <span class="s1">map: </span><span class="s2">new </span><span class="s1">Map()</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">};</span>
  <span class="s1">const setState = newState =&gt; {</span>
    <span class="s1">Object.assign(classState, newState);</span>
  <span class="s1">};</span>
  <span class="s1">const findThisesVisitor = _core.traverse.visitors.merge([_helperEnvironmentVisitor.</span><span class="s2">default</span><span class="s1">, {</span>
    <span class="s1">ThisExpression(path) {</span>
      <span class="s1">classState.superThises.push(path);</span>
    <span class="s1">}</span>
  <span class="s1">}]);</span>
  <span class="s2">function </span><span class="s1">createClassHelper(args) {</span>
    <span class="s2">return </span><span class="s1">_core.types.callExpression(classState.file.addHelper(</span><span class="s0">&quot;createClass&quot;</span><span class="s1">), args);</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">maybeCreateConstructor() {</span>
    <span class="s1">const classBodyPath = classState.path.get(</span><span class="s0">&quot;body&quot;</span><span class="s1">);</span>
    <span class="s2">for </span><span class="s1">(const path of classBodyPath.get(</span><span class="s0">&quot;body&quot;</span><span class="s1">)) {</span>
      <span class="s2">if </span><span class="s1">(path.isClassMethod({</span>
        <span class="s1">kind: </span><span class="s0">&quot;constructor&quot;</span>
      <span class="s1">})) </span><span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">let params, body;</span>
    <span class="s2">if </span><span class="s1">(classState.isDerived) {</span>
      <span class="s1">const constructor = _core.template.expression.ast`</span>
        <span class="s1">(</span><span class="s2">function </span><span class="s1">() {</span>
          <span class="s1">super(...arguments);</span>
        <span class="s1">})</span>
      <span class="s1">`;</span>
      <span class="s1">params = constructor.params;</span>
      <span class="s1">body = constructor.body;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">params = [];</span>
      <span class="s1">body = _core.types.blockStatement([]);</span>
    <span class="s1">}</span>
    <span class="s1">classBodyPath.unshiftContainer(</span><span class="s0">&quot;body&quot;</span><span class="s1">, _core.types.classMethod(</span><span class="s0">&quot;constructor&quot;</span><span class="s1">, _core.types.identifier(</span><span class="s0">&quot;constructor&quot;</span><span class="s1">), params, body));</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">buildBody() {</span>
    <span class="s1">maybeCreateConstructor();</span>
    <span class="s1">pushBody();</span>
    <span class="s1">verifyConstructor();</span>
    <span class="s2">if </span><span class="s1">(classState.userConstructor) {</span>
      <span class="s1">const {</span>
        <span class="s1">constructorBody,</span>
        <span class="s1">userConstructor,</span>
        <span class="s1">construct</span>
      <span class="s1">} = classState;</span>
      <span class="s1">constructorBody.body.push(...userConstructor.body.body);</span>
      <span class="s1">_core.types.inherits(construct, userConstructor);</span>
      <span class="s1">_core.types.inherits(constructorBody, userConstructor.body);</span>
    <span class="s1">}</span>
    <span class="s1">pushDescriptors();</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">pushBody() {</span>
    <span class="s1">const classBodyPaths = classState.path.get(</span><span class="s0">&quot;body.body&quot;</span><span class="s1">);</span>
    <span class="s2">for </span><span class="s1">(const path of classBodyPaths) {</span>
      <span class="s1">const node = path.node;</span>
      <span class="s2">if </span><span class="s1">(path.isClassProperty()) {</span>
        <span class="s2">throw </span><span class="s1">path.buildCodeFrameError(</span><span class="s0">&quot;Missing class properties transform.&quot;</span><span class="s1">);</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(node.decorators) {</span>
        <span class="s2">throw </span><span class="s1">path.buildCodeFrameError(</span><span class="s0">&quot;Method has decorators, put the decorator plugin before the classes one.&quot;</span><span class="s1">);</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(_core.types.isClassMethod(node)) {</span>
        <span class="s1">const isConstructor = node.kind === </span><span class="s0">&quot;constructor&quot;</span><span class="s1">;</span>
        <span class="s1">const replaceSupers = </span><span class="s2">new </span><span class="s1">_helperReplaceSupers.</span><span class="s2">default</span><span class="s1">({</span>
          <span class="s1">methodPath: path,</span>
          <span class="s1">objectRef: classState.classRef,</span>
          <span class="s1">superRef: classState.superName,</span>
          <span class="s1">constantSuper: assumptions.constantSuper,</span>
          <span class="s1">file: classState.file,</span>
          <span class="s1">refToPreserve: classState.classRef</span>
        <span class="s1">});</span>
        <span class="s1">replaceSupers.replace();</span>
        <span class="s1">const superReturns = [];</span>
        <span class="s1">path.traverse(_core.traverse.visitors.merge([_helperEnvironmentVisitor.</span><span class="s2">default</span><span class="s1">, {</span>
          <span class="s1">ReturnStatement(path) {</span>
            <span class="s2">if </span><span class="s1">(!path.getFunctionParent().isArrowFunctionExpression()) {</span>
              <span class="s1">superReturns.push(path);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}]));</span>
        <span class="s2">if </span><span class="s1">(isConstructor) {</span>
          <span class="s1">pushConstructor(superReturns, node, path);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">pushMethod(node, path);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">pushDescriptors() {</span>
    <span class="s1">pushInheritsToBody();</span>
    <span class="s1">const {</span>
      <span class="s1">body</span>
    <span class="s1">} = classState;</span>
    <span class="s1">const props = {</span>
      <span class="s1">instance: </span><span class="s2">null</span><span class="s1">,</span>
      <span class="s1">static: </span><span class="s2">null</span>
    <span class="s1">};</span>
    <span class="s2">for </span><span class="s1">(const placement of [</span><span class="s0">&quot;static&quot;</span><span class="s1">, </span><span class="s0">&quot;instance&quot;</span><span class="s1">]) {</span>
      <span class="s2">if </span><span class="s1">(classState.methods[placement].list.length) {</span>
        <span class="s1">props[placement] = classState.methods[placement].list.map(desc =&gt; {</span>
          <span class="s1">const obj = _core.types.objectExpression([_core.types.objectProperty(_core.types.identifier(</span><span class="s0">&quot;key&quot;</span><span class="s1">), desc.key)]);</span>
          <span class="s2">for </span><span class="s1">(const kind of [</span><span class="s0">&quot;get&quot;</span><span class="s1">, </span><span class="s0">&quot;set&quot;</span><span class="s1">, </span><span class="s0">&quot;value&quot;</span><span class="s1">]) {</span>
            <span class="s2">if </span><span class="s1">(desc[kind] != </span><span class="s2">null</span><span class="s1">) {</span>
              <span class="s1">obj.properties.push(_core.types.objectProperty(_core.types.identifier(kind), desc[kind]));</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
          <span class="s2">return </span><span class="s1">obj;</span>
        <span class="s1">});</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(props.instance || props.static) {</span>
      <span class="s1">let args = [_core.types.cloneNode(classState.classRef), props.instance ? _core.types.arrayExpression(props.instance) : _core.types.nullLiteral(), props.static ? _core.types.arrayExpression(props.static) : _core.types.nullLiteral()];</span>
      <span class="s1">let lastNonNullIndex = </span><span class="s3">0</span><span class="s1">;</span>
      <span class="s2">for </span><span class="s1">(let i = </span><span class="s3">0</span><span class="s1">; i &lt; args.length; i++) {</span>
        <span class="s2">if </span><span class="s1">(!_core.types.isNullLiteral(args[i])) lastNonNullIndex = i;</span>
      <span class="s1">}</span>
      <span class="s1">args = args.slice(</span><span class="s3">0</span><span class="s1">, lastNonNullIndex + </span><span class="s3">1</span><span class="s1">);</span>
      <span class="s1">body.push(_core.types.expressionStatement(createClassHelper(args)));</span>
      <span class="s1">classState.pushedCreateClass = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">wrapSuperCall(bareSuper, superRef, thisRef, body) {</span>
    <span class="s1">const bareSuperNode = bareSuper.node;</span>
    <span class="s1">let call;</span>
    <span class="s2">if </span><span class="s1">(assumptions.superIsCallableConstructor) {</span>
      <span class="s1">bareSuperNode.arguments.unshift(_core.types.thisExpression());</span>
      <span class="s2">if </span><span class="s1">(bareSuperNode.arguments.length === </span><span class="s3">2 </span><span class="s1">&amp;&amp; _core.types.isSpreadElement(bareSuperNode.arguments[</span><span class="s3">1</span><span class="s1">]) &amp;&amp; _core.types.isIdentifier(bareSuperNode.arguments[</span><span class="s3">1</span><span class="s1">].argument, {</span>
        <span class="s1">name: </span><span class="s0">&quot;arguments&quot;</span>
      <span class="s1">})) {</span>
        <span class="s1">bareSuperNode.arguments[</span><span class="s3">1</span><span class="s1">] = bareSuperNode.arguments[</span><span class="s3">1</span><span class="s1">].argument;</span>
        <span class="s1">bareSuperNode.callee = _core.types.memberExpression(_core.types.cloneNode(superRef), _core.types.identifier(</span><span class="s0">&quot;apply&quot;</span><span class="s1">));</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">bareSuperNode.callee = _core.types.memberExpression(_core.types.cloneNode(superRef), _core.types.identifier(</span><span class="s0">&quot;call&quot;</span><span class="s1">));</span>
      <span class="s1">}</span>
      <span class="s1">call = _core.types.logicalExpression(</span><span class="s0">&quot;||&quot;</span><span class="s1">, bareSuperNode, _core.types.thisExpression());</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">call = (</span><span class="s3">0</span><span class="s1">, _helperOptimiseCallExpression.</span><span class="s2">default</span><span class="s1">)(_core.types.cloneNode(classState.superFnId), _core.types.thisExpression(), bareSuperNode.arguments, </span><span class="s2">false</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(bareSuper.parentPath.isExpressionStatement() &amp;&amp; bareSuper.parentPath.container === body.node.body &amp;&amp; body.node.body.length - </span><span class="s3">1 </span><span class="s1">=== bareSuper.parentPath.key) {</span>
      <span class="s2">if </span><span class="s1">(classState.superThises.length) {</span>
        <span class="s1">call = _core.types.assignmentExpression(</span><span class="s0">&quot;=&quot;</span><span class="s1">, thisRef(), call);</span>
      <span class="s1">}</span>
      <span class="s1">bareSuper.parentPath.replaceWith(_core.types.returnStatement(call));</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">bareSuper.replaceWith(_core.types.assignmentExpression(</span><span class="s0">&quot;=&quot;</span><span class="s1">, thisRef(), call));</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">verifyConstructor() {</span>
    <span class="s2">if </span><span class="s1">(!classState.isDerived) </span><span class="s2">return</span><span class="s1">;</span>
    <span class="s1">const path = classState.userConstructorPath;</span>
    <span class="s1">const body = path.get(</span><span class="s0">&quot;body&quot;</span><span class="s1">);</span>
    <span class="s1">path.traverse(findThisesVisitor);</span>
    <span class="s1">let thisRef = </span><span class="s2">function </span><span class="s1">() {</span>
      <span class="s1">const ref = path.scope.generateDeclaredUidIdentifier(</span><span class="s0">&quot;this&quot;</span><span class="s1">);</span>
      <span class="s1">thisRef = () =&gt; _core.types.cloneNode(ref);</span>
      <span class="s2">return </span><span class="s1">ref;</span>
    <span class="s1">};</span>
    <span class="s2">for </span><span class="s1">(const thisPath of classState.superThises) {</span>
      <span class="s1">const {</span>
        <span class="s1">node,</span>
        <span class="s1">parentPath</span>
      <span class="s1">} = thisPath;</span>
      <span class="s2">if </span><span class="s1">(parentPath.isMemberExpression({</span>
        <span class="s1">object: node</span>
      <span class="s1">})) {</span>
        <span class="s1">thisPath.replaceWith(thisRef());</span>
        <span class="s2">continue</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s1">thisPath.replaceWith(_core.types.callExpression(classState.file.addHelper(</span><span class="s0">&quot;assertThisInitialized&quot;</span><span class="s1">), [thisRef()]));</span>
    <span class="s1">}</span>
    <span class="s1">const bareSupers = [];</span>
    <span class="s1">path.traverse(_core.traverse.visitors.merge([_helperEnvironmentVisitor.</span><span class="s2">default</span><span class="s1">, {</span>
      <span class="s1">Super(path) {</span>
        <span class="s1">const {</span>
          <span class="s1">node,</span>
          <span class="s1">parentPath</span>
        <span class="s1">} = path;</span>
        <span class="s2">if </span><span class="s1">(parentPath.isCallExpression({</span>
          <span class="s1">callee: node</span>
        <span class="s1">})) {</span>
          <span class="s1">bareSupers.unshift(parentPath);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}]));</span>
    <span class="s1">let guaranteedSuperBeforeFinish = !!bareSupers.length;</span>
    <span class="s2">for </span><span class="s1">(const bareSuper of bareSupers) {</span>
      <span class="s1">wrapSuperCall(bareSuper, classState.superName, thisRef, body);</span>
      <span class="s2">if </span><span class="s1">(guaranteedSuperBeforeFinish) {</span>
        <span class="s1">bareSuper.find(</span><span class="s2">function </span><span class="s1">(parentPath) {</span>
          <span class="s2">if </span><span class="s1">(parentPath === path) {</span>
            <span class="s2">return true</span><span class="s1">;</span>
          <span class="s1">}</span>
          <span class="s2">if </span><span class="s1">(parentPath.isLoop() || parentPath.isConditional() || parentPath.isArrowFunctionExpression()) {</span>
            <span class="s1">guaranteedSuperBeforeFinish = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s2">return true</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">});</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">let wrapReturn;</span>
    <span class="s2">if </span><span class="s1">(classState.isLoose) {</span>
      <span class="s1">wrapReturn = returnArg =&gt; {</span>
        <span class="s1">const thisExpr = _core.types.callExpression(classState.file.addHelper(</span><span class="s0">&quot;assertThisInitialized&quot;</span><span class="s1">), [thisRef()]);</span>
        <span class="s2">return </span><span class="s1">returnArg ? _core.types.logicalExpression(</span><span class="s0">&quot;||&quot;</span><span class="s1">, returnArg, thisExpr) : thisExpr;</span>
      <span class="s1">};</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">wrapReturn = returnArg =&gt; {</span>
        <span class="s1">const returnParams = [thisRef()];</span>
        <span class="s2">if </span><span class="s1">(returnArg != </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">returnParams.push(returnArg);</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">_core.types.callExpression(classState.file.addHelper(</span><span class="s0">&quot;possibleConstructorReturn&quot;</span><span class="s1">), returnParams);</span>
      <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s1">const bodyPaths = body.get(</span><span class="s0">&quot;body&quot;</span><span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(!bodyPaths.length || !bodyPaths.pop().isReturnStatement()) {</span>
      <span class="s1">body.pushContainer(</span><span class="s0">&quot;body&quot;</span><span class="s1">, _core.types.returnStatement(guaranteedSuperBeforeFinish ? thisRef() : wrapReturn()));</span>
    <span class="s1">}</span>
    <span class="s2">for </span><span class="s1">(const returnPath of classState.superReturns) {</span>
      <span class="s1">returnPath.get(</span><span class="s0">&quot;argument&quot;</span><span class="s1">).replaceWith(wrapReturn(returnPath.node.argument));</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">pushMethod(node, path) {</span>
    <span class="s1">const scope = path ? path.scope : classState.scope;</span>
    <span class="s2">if </span><span class="s1">(node.kind === </span><span class="s0">&quot;method&quot;</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(processMethod(node, scope)) </span><span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">const placement = node.static ? </span><span class="s0">&quot;static&quot; </span><span class="s1">: </span><span class="s0">&quot;instance&quot;</span><span class="s1">;</span>
    <span class="s1">const methods = classState.methods[placement];</span>
    <span class="s1">const descKey = node.kind === </span><span class="s0">&quot;method&quot; </span><span class="s1">? </span><span class="s0">&quot;value&quot; </span><span class="s1">: node.kind;</span>
    <span class="s1">const key = _core.types.isNumericLiteral(node.key) || _core.types.isBigIntLiteral(node.key) ? _core.types.stringLiteral(String(node.key.value)) : _core.types.toComputedKey(node);</span>
    <span class="s1">let fn = _core.types.toExpression(node);</span>
    <span class="s2">if </span><span class="s1">(_core.types.isStringLiteral(key)) {</span>
      <span class="s2">if </span><span class="s1">(node.kind === </span><span class="s0">&quot;method&quot;</span><span class="s1">) {</span>
        <span class="s2">var </span><span class="s1">_nameFunction;</span>
        <span class="s1">fn = (_nameFunction = (</span><span class="s3">0</span><span class="s1">, _helperFunctionName.</span><span class="s2">default</span><span class="s1">)({</span>
          <span class="s1">id: key,</span>
          <span class="s1">node: node,</span>
          <span class="s1">scope</span>
        <span class="s1">}, undefined, supportUnicodeId)) != </span><span class="s2">null </span><span class="s1">? _nameFunction : fn;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">methods.hasComputed = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">let descriptor;</span>
    <span class="s2">if </span><span class="s1">(!methods.hasComputed &amp;&amp; methods.map.has(key.value)) {</span>
      <span class="s1">descriptor = methods.map.get(key.value);</span>
      <span class="s1">descriptor[descKey] = fn;</span>
      <span class="s2">if </span><span class="s1">(descKey === </span><span class="s0">&quot;value&quot;</span><span class="s1">) {</span>
        <span class="s1">descriptor.get = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s1">descriptor.set = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">descriptor.value = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">descriptor = {</span>
        <span class="s1">key: key,</span>
        <span class="s1">[descKey]: fn</span>
      <span class="s1">};</span>
      <span class="s1">methods.list.push(descriptor);</span>
      <span class="s2">if </span><span class="s1">(!methods.hasComputed) {</span>
        <span class="s1">methods.map.set(key.value, descriptor);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">processMethod(node, scope) {</span>
    <span class="s2">if </span><span class="s1">(assumptions.setClassMethods &amp;&amp; !node.decorators) {</span>
      <span class="s1">let {</span>
        <span class="s1">classRef</span>
      <span class="s1">} = classState;</span>
      <span class="s2">if </span><span class="s1">(!node.static) {</span>
        <span class="s1">insertProtoAliasOnce();</span>
        <span class="s1">classRef = classState.protoAlias;</span>
      <span class="s1">}</span>
      <span class="s1">const methodName = _core.types.memberExpression(_core.types.cloneNode(classRef), node.key, node.computed || _core.types.isLiteral(node.key));</span>
      <span class="s1">let func = _core.types.functionExpression(</span><span class="s2">null</span><span class="s1">, node.params, node.body, node.generator, node.async);</span>
      <span class="s1">_core.types.inherits(func, node);</span>
      <span class="s1">const key = _core.types.toComputedKey(node, node.key);</span>
      <span class="s2">if </span><span class="s1">(_core.types.isStringLiteral(key)) {</span>
        <span class="s2">var </span><span class="s1">_nameFunction2;</span>
        <span class="s1">func = (_nameFunction2 = (</span><span class="s3">0</span><span class="s1">, _helperFunctionName.</span><span class="s2">default</span><span class="s1">)({</span>
          <span class="s1">node: func,</span>
          <span class="s1">id: key,</span>
          <span class="s1">scope</span>
        <span class="s1">}, undefined, supportUnicodeId)) != </span><span class="s2">null </span><span class="s1">? _nameFunction2 : func;</span>
      <span class="s1">}</span>
      <span class="s1">const expr = _core.types.expressionStatement(_core.types.assignmentExpression(</span><span class="s0">&quot;=&quot;</span><span class="s1">, methodName, func));</span>
      <span class="s1">_core.types.inheritsComments(expr, node);</span>
      <span class="s1">classState.body.push(expr);</span>
      <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return false</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">insertProtoAliasOnce() {</span>
    <span class="s2">if </span><span class="s1">(classState.protoAlias === </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">setState({</span>
        <span class="s1">protoAlias: classState.scope.generateUidIdentifier(</span><span class="s0">&quot;proto&quot;</span><span class="s1">)</span>
      <span class="s1">});</span>
      <span class="s1">const classProto = _core.types.memberExpression(classState.classRef, _core.types.identifier(</span><span class="s0">&quot;prototype&quot;</span><span class="s1">));</span>
      <span class="s1">const protoDeclaration = _core.types.variableDeclaration(</span><span class="s0">&quot;var&quot;</span><span class="s1">, [_core.types.variableDeclarator(classState.protoAlias, classProto)]);</span>
      <span class="s1">classState.body.push(protoDeclaration);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">pushConstructor(superReturns, method, path) {</span>
    <span class="s1">setState({</span>
      <span class="s1">userConstructorPath: path,</span>
      <span class="s1">userConstructor: method,</span>
      <span class="s1">hasConstructor: </span><span class="s2">true</span><span class="s1">,</span>
      <span class="s1">superReturns</span>
    <span class="s1">});</span>
    <span class="s1">const {</span>
      <span class="s1">construct</span>
    <span class="s1">} = classState;</span>
    <span class="s1">_core.types.inheritsComments(construct, method);</span>
    <span class="s1">construct.params = method.params;</span>
    <span class="s1">_core.types.inherits(construct.body, method.body);</span>
    <span class="s1">construct.body.directives = method.body.directives;</span>
    <span class="s1">pushConstructorToBody();</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">pushConstructorToBody() {</span>
    <span class="s2">if </span><span class="s1">(classState.pushedConstructor) </span><span class="s2">return</span><span class="s1">;</span>
    <span class="s1">classState.pushedConstructor = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s2">if </span><span class="s1">(classState.hasInstanceDescriptors || classState.hasStaticDescriptors) {</span>
      <span class="s1">pushDescriptors();</span>
    <span class="s1">}</span>
    <span class="s1">classState.body.push(classState.construct);</span>
    <span class="s1">pushInheritsToBody();</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">pushInheritsToBody() {</span>
    <span class="s2">if </span><span class="s1">(!classState.isDerived || classState.pushedInherits) </span><span class="s2">return</span><span class="s1">;</span>
    <span class="s1">const superFnId = path.scope.generateUidIdentifier(</span><span class="s0">&quot;super&quot;</span><span class="s1">);</span>
    <span class="s1">setState({</span>
      <span class="s1">pushedInherits: </span><span class="s2">true</span><span class="s1">,</span>
      <span class="s1">superFnId</span>
    <span class="s1">});</span>
    <span class="s2">if </span><span class="s1">(!assumptions.superIsCallableConstructor) {</span>
      <span class="s1">classState.body.unshift(_core.types.variableDeclaration(</span><span class="s0">&quot;var&quot;</span><span class="s1">, [_core.types.variableDeclarator(superFnId, _core.types.callExpression((</span><span class="s3">0</span><span class="s1">, _inlineCreateSuperHelpers.</span><span class="s2">default</span><span class="s1">)(classState.file), [_core.types.cloneNode(classState.classRef)]))]));</span>
    <span class="s1">}</span>
    <span class="s1">classState.body.unshift(_core.types.expressionStatement(_core.types.callExpression(classState.file.addHelper(classState.isLoose ? </span><span class="s0">&quot;inheritsLoose&quot; </span><span class="s1">: </span><span class="s0">&quot;inherits&quot;</span><span class="s1">), [_core.types.cloneNode(classState.classRef), _core.types.cloneNode(classState.superName)])));</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">extractDynamicKeys() {</span>
    <span class="s1">const {</span>
      <span class="s1">dynamicKeys,</span>
      <span class="s1">node,</span>
      <span class="s1">scope</span>
    <span class="s1">} = classState;</span>
    <span class="s2">for </span><span class="s1">(const elem of node.body.body) {</span>
      <span class="s2">if </span><span class="s1">(!_core.types.isClassMethod(elem) || !elem.computed) </span><span class="s2">continue</span><span class="s1">;</span>
      <span class="s2">if </span><span class="s1">(scope.isPure(elem.key, </span><span class="s2">true</span><span class="s1">)) </span><span class="s2">continue</span><span class="s1">;</span>
      <span class="s1">const id = scope.generateUidIdentifierBasedOnNode(elem.key);</span>
      <span class="s1">dynamicKeys.set(id.name, elem.key);</span>
      <span class="s1">elem.key = id;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">setupClosureParamsArgs() {</span>
    <span class="s1">const {</span>
      <span class="s1">superName,</span>
      <span class="s1">dynamicKeys</span>
    <span class="s1">} = classState;</span>
    <span class="s1">const closureParams = [];</span>
    <span class="s1">const closureArgs = [];</span>
    <span class="s2">if </span><span class="s1">(classState.isDerived) {</span>
      <span class="s1">let arg = _core.types.cloneNode(superName);</span>
      <span class="s2">if </span><span class="s1">(classState.extendsNative) {</span>
        <span class="s1">arg = _core.types.callExpression(classState.file.addHelper(</span><span class="s0">&quot;wrapNativeSuper&quot;</span><span class="s1">), [arg]);</span>
        <span class="s1">(</span><span class="s3">0</span><span class="s1">, _helperAnnotateAsPure.</span><span class="s2">default</span><span class="s1">)(arg);</span>
      <span class="s1">}</span>
      <span class="s1">const param = classState.scope.generateUidIdentifierBasedOnNode(superName);</span>
      <span class="s1">closureParams.push(param);</span>
      <span class="s1">closureArgs.push(arg);</span>
      <span class="s1">setState({</span>
        <span class="s1">superName: _core.types.cloneNode(param)</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">for </span><span class="s1">(const [name, value] of dynamicKeys) {</span>
      <span class="s1">closureParams.push(_core.types.identifier(name));</span>
      <span class="s1">closureArgs.push(value);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">{</span>
      <span class="s1">closureParams,</span>
      <span class="s1">closureArgs</span>
    <span class="s1">};</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">classTransformer(path, file, builtinClasses, isLoose) {</span>
    <span class="s1">setState({</span>
      <span class="s1">parent: path.parent,</span>
      <span class="s1">scope: path.scope,</span>
      <span class="s1">node: path.node,</span>
      <span class="s1">path,</span>
      <span class="s1">file,</span>
      <span class="s1">isLoose</span>
    <span class="s1">});</span>
    <span class="s1">setState({</span>
      <span class="s1">classId: classState.node.id,</span>
      <span class="s1">classRef: classState.node.id ? _core.types.identifier(classState.node.id.name) : classState.scope.generateUidIdentifier(</span><span class="s0">&quot;class&quot;</span><span class="s1">),</span>
      <span class="s1">superName: classState.node.superClass,</span>
      <span class="s1">isDerived: !!classState.node.superClass,</span>
      <span class="s1">constructorBody: _core.types.blockStatement([])</span>
    <span class="s1">});</span>
    <span class="s1">setState({</span>
      <span class="s1">extendsNative: _core.types.isIdentifier(classState.superName) &amp;&amp; builtinClasses.has(classState.superName.name) &amp;&amp; !classState.scope.hasBinding(classState.superName.name, </span><span class="s2">true</span><span class="s1">)</span>
    <span class="s1">});</span>
    <span class="s1">const {</span>
      <span class="s1">classRef,</span>
      <span class="s1">node,</span>
      <span class="s1">constructorBody</span>
    <span class="s1">} = classState;</span>
    <span class="s1">setState({</span>
      <span class="s1">construct: buildConstructor(classRef, constructorBody, node)</span>
    <span class="s1">});</span>
    <span class="s1">extractDynamicKeys();</span>
    <span class="s1">const {</span>
      <span class="s1">body</span>
    <span class="s1">} = classState;</span>
    <span class="s1">const {</span>
      <span class="s1">closureParams,</span>
      <span class="s1">closureArgs</span>
    <span class="s1">} = setupClosureParamsArgs();</span>
    <span class="s1">buildBody();</span>
    <span class="s2">if </span><span class="s1">(!assumptions.noClassCalls) {</span>
      <span class="s1">constructorBody.body.unshift(_core.types.expressionStatement(_core.types.callExpression(classState.file.addHelper(</span><span class="s0">&quot;classCallCheck&quot;</span><span class="s1">), [_core.types.thisExpression(), _core.types.cloneNode(classState.classRef)])));</span>
    <span class="s1">}</span>
    <span class="s1">const isStrict = path.isInStrictMode();</span>
    <span class="s1">let constructorOnly = classState.classId &amp;&amp; body.length === </span><span class="s3">1</span><span class="s1">;</span>
    <span class="s2">if </span><span class="s1">(constructorOnly &amp;&amp; !isStrict) {</span>
      <span class="s2">for </span><span class="s1">(const param of classState.construct.params) {</span>
        <span class="s2">if </span><span class="s1">(!_core.types.isIdentifier(param)) {</span>
          <span class="s1">constructorOnly = </span><span class="s2">false</span><span class="s1">;</span>
          <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">const directives = constructorOnly ? body[</span><span class="s3">0</span><span class="s1">].body.directives : [];</span>
    <span class="s2">if </span><span class="s1">(!isStrict) {</span>
      <span class="s1">directives.push(_core.types.directive(_core.types.directiveLiteral(</span><span class="s0">&quot;use strict&quot;</span><span class="s1">)));</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(constructorOnly) {</span>
      <span class="s1">const expr = _core.types.toExpression(body[</span><span class="s3">0</span><span class="s1">]);</span>
      <span class="s2">return </span><span class="s1">classState.isLoose ? expr : createClassHelper([expr]);</span>
    <span class="s1">}</span>
    <span class="s1">let returnArg = _core.types.cloneNode(classState.classRef);</span>
    <span class="s2">if </span><span class="s1">(!classState.pushedCreateClass &amp;&amp; !classState.isLoose) {</span>
      <span class="s1">returnArg = createClassHelper([returnArg]);</span>
    <span class="s1">}</span>
    <span class="s1">body.push(_core.types.returnStatement(returnArg));</span>
    <span class="s1">const container = _core.types.arrowFunctionExpression(closureParams, _core.types.blockStatement(body, directives));</span>
    <span class="s2">return </span><span class="s1">_core.types.callExpression(container, closureArgs);</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">classTransformer(path, file, builtinClasses, isLoose);</span>
<span class="s1">}</span>

<span class="s4">//# sourceMappingURL=transformClass.js.map</span>
</pre>
</body>
</html>
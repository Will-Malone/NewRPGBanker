<html>
<head>
<title>expression.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6a8759;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #4646f1;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
expression.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>

<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
  <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s1">exports.</span><span class="s2">default </span><span class="s1">= </span><span class="s2">void </span><span class="s3">0</span><span class="s1">;</span>
<span class="s2">var </span><span class="s1">_types = require(</span><span class="s0">&quot;../tokenizer/types&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_lval = require(</span><span class="s0">&quot;./lval&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_identifier = require(</span><span class="s0">&quot;../util/identifier&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_location = require(</span><span class="s0">&quot;../util/location&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_scopeflags = require(</span><span class="s0">&quot;../util/scopeflags&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_util = require(</span><span class="s0">&quot;./util&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_productionParameter = require(</span><span class="s0">&quot;../util/production-parameter&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_expressionScope = require(</span><span class="s0">&quot;../util/expression-scope&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_parseError = require(</span><span class="s0">&quot;../parse-error&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_pipelineOperatorErrors = require(</span><span class="s0">&quot;../parse-error/pipeline-operator-errors&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_comments = require(</span><span class="s0">&quot;./comments&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_node = require(</span><span class="s0">&quot;./node&quot;</span><span class="s1">);</span>
<span class="s1">class ExpressionParser extends _lval.</span><span class="s2">default </span><span class="s1">{</span>
  <span class="s1">checkProto(prop, isRecord, protoRef, refExpressionErrors) {</span>
    <span class="s2">if </span><span class="s1">(prop.type === </span><span class="s0">&quot;SpreadElement&quot; </span><span class="s1">|| </span><span class="s2">this</span><span class="s1">.isObjectMethod(prop) || prop.computed || prop.shorthand) {</span>
      <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">const key = prop.key;</span>
    <span class="s1">const name = key.type === </span><span class="s0">&quot;Identifier&quot; </span><span class="s1">? key.name : key.value;</span>
    <span class="s2">if </span><span class="s1">(name === </span><span class="s0">&quot;__proto__&quot;</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(isRecord) {</span>
        <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.RecordNoProto, {</span>
          <span class="s1">at: key</span>
        <span class="s1">});</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(protoRef.used) {</span>
        <span class="s2">if </span><span class="s1">(refExpressionErrors) {</span>
          <span class="s2">if </span><span class="s1">(refExpressionErrors.doubleProtoLoc === </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">refExpressionErrors.doubleProtoLoc = key.loc.start;</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.DuplicateProto, {</span>
            <span class="s1">at: key</span>
          <span class="s1">});</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s1">protoRef.used = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">shouldExitDescending(expr, potentialArrowAt) {</span>
    <span class="s2">return </span><span class="s1">expr.type === </span><span class="s0">&quot;ArrowFunctionExpression&quot; </span><span class="s1">&amp;&amp; expr.start === potentialArrowAt;</span>
  <span class="s1">}</span>
  <span class="s1">getExpression() {</span>
    <span class="s2">this</span><span class="s1">.enterInitialScopes();</span>
    <span class="s2">this</span><span class="s1">.nextToken();</span>
    <span class="s1">const expr = </span><span class="s2">this</span><span class="s1">.parseExpression();</span>
    <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">137</span><span class="s1">)) {</span>
      <span class="s2">this</span><span class="s1">.unexpected();</span>
    <span class="s1">}</span>
    <span class="s2">this</span><span class="s1">.finalizeRemainingComments();</span>
    <span class="s1">expr.comments = </span><span class="s2">this</span><span class="s1">.state.comments;</span>
    <span class="s1">expr.errors = </span><span class="s2">this</span><span class="s1">.state.errors;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.tokens) {</span>
      <span class="s1">expr.tokens = </span><span class="s2">this</span><span class="s1">.tokens;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">expr;</span>
  <span class="s1">}</span>
  <span class="s1">parseExpression(disallowIn, refExpressionErrors) {</span>
    <span class="s2">if </span><span class="s1">(disallowIn) {</span>
      <span class="s2">return this</span><span class="s1">.disallowInAnd(() =&gt; </span><span class="s2">this</span><span class="s1">.parseExpressionBase(refExpressionErrors));</span>
    <span class="s1">}</span>
    <span class="s2">return this</span><span class="s1">.allowInAnd(() =&gt; </span><span class="s2">this</span><span class="s1">.parseExpressionBase(refExpressionErrors));</span>
  <span class="s1">}</span>
  <span class="s1">parseExpressionBase(refExpressionErrors) {</span>
    <span class="s1">const startLoc = </span><span class="s2">this</span><span class="s1">.state.startLoc;</span>
    <span class="s1">const expr = </span><span class="s2">this</span><span class="s1">.parseMaybeAssign(refExpressionErrors);</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">12</span><span class="s1">)) {</span>
      <span class="s1">const node = </span><span class="s2">this</span><span class="s1">.startNodeAt(startLoc);</span>
      <span class="s1">node.expressions = [expr];</span>
      <span class="s2">while </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.eat(</span><span class="s3">12</span><span class="s1">)) {</span>
        <span class="s1">node.expressions.push(</span><span class="s2">this</span><span class="s1">.parseMaybeAssign(refExpressionErrors));</span>
      <span class="s1">}</span>
      <span class="s2">this</span><span class="s1">.toReferencedList(node.expressions);</span>
      <span class="s2">return this</span><span class="s1">.finishNode(node, </span><span class="s0">&quot;SequenceExpression&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">expr;</span>
  <span class="s1">}</span>
  <span class="s1">parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {</span>
    <span class="s2">return this</span><span class="s1">.disallowInAnd(() =&gt; </span><span class="s2">this</span><span class="s1">.parseMaybeAssign(refExpressionErrors, afterLeftParse));</span>
  <span class="s1">}</span>
  <span class="s1">parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {</span>
    <span class="s2">return this</span><span class="s1">.allowInAnd(() =&gt; </span><span class="s2">this</span><span class="s1">.parseMaybeAssign(refExpressionErrors, afterLeftParse));</span>
  <span class="s1">}</span>
  <span class="s1">setOptionalParametersError(refExpressionErrors, resultError) {</span>
    <span class="s2">var </span><span class="s1">_resultError$loc;</span>
    <span class="s1">refExpressionErrors.optionalParametersLoc = (_resultError$loc = resultError == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: resultError.loc) != </span><span class="s2">null </span><span class="s1">? _resultError$loc : </span><span class="s2">this</span><span class="s1">.state.startLoc;</span>
  <span class="s1">}</span>
  <span class="s1">parseMaybeAssign(refExpressionErrors, afterLeftParse) {</span>
    <span class="s1">const startLoc = </span><span class="s2">this</span><span class="s1">.state.startLoc;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isContextual(</span><span class="s3">106</span><span class="s1">)) {</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.prodParam.hasYield) {</span>
        <span class="s1">let left = </span><span class="s2">this</span><span class="s1">.parseYield();</span>
        <span class="s2">if </span><span class="s1">(afterLeftParse) {</span>
          <span class="s1">left = afterLeftParse.call(</span><span class="s2">this</span><span class="s1">, left, startLoc);</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">left;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">let ownExpressionErrors;</span>
    <span class="s2">if </span><span class="s1">(refExpressionErrors) {</span>
      <span class="s1">ownExpressionErrors = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">refExpressionErrors = </span><span class="s2">new </span><span class="s1">_util.ExpressionErrors();</span>
      <span class="s1">ownExpressionErrors = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">const {</span>
      <span class="s1">type</span>
    <span class="s1">} = </span><span class="s2">this</span><span class="s1">.state;</span>
    <span class="s2">if </span><span class="s1">(type === </span><span class="s3">10 </span><span class="s1">|| (</span><span class="s3">0</span><span class="s1">, _types.tokenIsIdentifier)(type)) {</span>
      <span class="s2">this</span><span class="s1">.state.potentialArrowAt = </span><span class="s2">this</span><span class="s1">.state.start;</span>
    <span class="s1">}</span>
    <span class="s1">let left = </span><span class="s2">this</span><span class="s1">.parseMaybeConditional(refExpressionErrors);</span>
    <span class="s2">if </span><span class="s1">(afterLeftParse) {</span>
      <span class="s1">left = afterLeftParse.call(</span><span class="s2">this</span><span class="s1">, left, startLoc);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _types.tokenIsAssignment)(</span><span class="s2">this</span><span class="s1">.state.type)) {</span>
      <span class="s1">const node = </span><span class="s2">this</span><span class="s1">.startNodeAt(startLoc);</span>
      <span class="s1">const operator = </span><span class="s2">this</span><span class="s1">.state.value;</span>
      <span class="s1">node.operator = operator;</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">29</span><span class="s1">)) {</span>
        <span class="s2">this</span><span class="s1">.toAssignable(left, </span><span class="s2">true</span><span class="s1">);</span>
        <span class="s1">node.left = left;</span>
        <span class="s1">const startIndex = startLoc.index;</span>
        <span class="s2">if </span><span class="s1">(refExpressionErrors.doubleProtoLoc != </span><span class="s2">null </span><span class="s1">&amp;&amp; refExpressionErrors.doubleProtoLoc.index &gt;= startIndex) {</span>
          <span class="s1">refExpressionErrors.doubleProtoLoc = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(refExpressionErrors.shorthandAssignLoc != </span><span class="s2">null </span><span class="s1">&amp;&amp; refExpressionErrors.shorthandAssignLoc.index &gt;= startIndex) {</span>
          <span class="s1">refExpressionErrors.shorthandAssignLoc = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(refExpressionErrors.privateKeyLoc != </span><span class="s2">null </span><span class="s1">&amp;&amp; refExpressionErrors.privateKeyLoc.index &gt;= startIndex) {</span>
          <span class="s2">this</span><span class="s1">.checkDestructuringPrivate(refExpressionErrors);</span>
          <span class="s1">refExpressionErrors.privateKeyLoc = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">node.left = left;</span>
      <span class="s1">}</span>
      <span class="s2">this</span><span class="s1">.next();</span>
      <span class="s1">node.right = </span><span class="s2">this</span><span class="s1">.parseMaybeAssign();</span>
      <span class="s2">this</span><span class="s1">.checkLVal(left, {</span>
        <span class="s2">in</span><span class="s1">: </span><span class="s2">this</span><span class="s1">.finishNode(node, </span><span class="s0">&quot;AssignmentExpression&quot;</span><span class="s1">)</span>
      <span class="s1">});</span>
      <span class="s2">return </span><span class="s1">node;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(ownExpressionErrors) {</span>
      <span class="s2">this</span><span class="s1">.checkExpressionErrors(refExpressionErrors, </span><span class="s2">true</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">left;</span>
  <span class="s1">}</span>
  <span class="s1">parseMaybeConditional(refExpressionErrors) {</span>
    <span class="s1">const startLoc = </span><span class="s2">this</span><span class="s1">.state.startLoc;</span>
    <span class="s1">const potentialArrowAt = </span><span class="s2">this</span><span class="s1">.state.potentialArrowAt;</span>
    <span class="s1">const expr = </span><span class="s2">this</span><span class="s1">.parseExprOps(refExpressionErrors);</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.shouldExitDescending(expr, potentialArrowAt)) {</span>
      <span class="s2">return </span><span class="s1">expr;</span>
    <span class="s1">}</span>
    <span class="s2">return this</span><span class="s1">.parseConditional(expr, startLoc, refExpressionErrors);</span>
  <span class="s1">}</span>
  <span class="s1">parseConditional(expr, startLoc, refExpressionErrors) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.eat(</span><span class="s3">17</span><span class="s1">)) {</span>
      <span class="s1">const node = </span><span class="s2">this</span><span class="s1">.startNodeAt(startLoc);</span>
      <span class="s1">node.test = expr;</span>
      <span class="s1">node.consequent = </span><span class="s2">this</span><span class="s1">.parseMaybeAssignAllowIn();</span>
      <span class="s2">this</span><span class="s1">.expect(</span><span class="s3">14</span><span class="s1">);</span>
      <span class="s1">node.alternate = </span><span class="s2">this</span><span class="s1">.parseMaybeAssign();</span>
      <span class="s2">return this</span><span class="s1">.finishNode(node, </span><span class="s0">&quot;ConditionalExpression&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">expr;</span>
  <span class="s1">}</span>
  <span class="s1">parseMaybeUnaryOrPrivate(refExpressionErrors) {</span>
    <span class="s2">return this</span><span class="s1">.match(</span><span class="s3">136</span><span class="s1">) ? </span><span class="s2">this</span><span class="s1">.parsePrivateName() : </span><span class="s2">this</span><span class="s1">.parseMaybeUnary(refExpressionErrors);</span>
  <span class="s1">}</span>
  <span class="s1">parseExprOps(refExpressionErrors) {</span>
    <span class="s1">const startLoc = </span><span class="s2">this</span><span class="s1">.state.startLoc;</span>
    <span class="s1">const potentialArrowAt = </span><span class="s2">this</span><span class="s1">.state.potentialArrowAt;</span>
    <span class="s1">const expr = </span><span class="s2">this</span><span class="s1">.parseMaybeUnaryOrPrivate(refExpressionErrors);</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.shouldExitDescending(expr, potentialArrowAt)) {</span>
      <span class="s2">return </span><span class="s1">expr;</span>
    <span class="s1">}</span>
    <span class="s2">return this</span><span class="s1">.parseExprOp(expr, startLoc, -</span><span class="s3">1</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">parseExprOp(left, leftStartLoc, minPrec) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isPrivateName(left)) {</span>
      <span class="s1">const value = </span><span class="s2">this</span><span class="s1">.getPrivateNameSV(left);</span>
      <span class="s2">if </span><span class="s1">(minPrec &gt;= (</span><span class="s3">0</span><span class="s1">, _types.tokenOperatorPrecedence)(</span><span class="s3">58</span><span class="s1">) || !</span><span class="s2">this</span><span class="s1">.prodParam.hasIn || !</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">58</span><span class="s1">)) {</span>
        <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.PrivateInExpectedIn, {</span>
          <span class="s1">at: left,</span>
          <span class="s1">identifierName: value</span>
        <span class="s1">});</span>
      <span class="s1">}</span>
      <span class="s2">this</span><span class="s1">.classScope.usePrivateName(value, left.loc.start);</span>
    <span class="s1">}</span>
    <span class="s1">const op = </span><span class="s2">this</span><span class="s1">.state.type;</span>
    <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _types.tokenIsOperator)(op) &amp;&amp; (</span><span class="s2">this</span><span class="s1">.prodParam.hasIn || !</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">58</span><span class="s1">))) {</span>
      <span class="s1">let prec = (</span><span class="s3">0</span><span class="s1">, _types.tokenOperatorPrecedence)(op);</span>
      <span class="s2">if </span><span class="s1">(prec &gt; minPrec) {</span>
        <span class="s2">if </span><span class="s1">(op === </span><span class="s3">39</span><span class="s1">) {</span>
          <span class="s2">this</span><span class="s1">.expectPlugin(</span><span class="s0">&quot;pipelineOperator&quot;</span><span class="s1">);</span>
          <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.state.inFSharpPipelineDirectBody) {</span>
            <span class="s2">return </span><span class="s1">left;</span>
          <span class="s1">}</span>
          <span class="s2">this</span><span class="s1">.checkPipelineAtInfixOperator(left, leftStartLoc);</span>
        <span class="s1">}</span>
        <span class="s1">const node = </span><span class="s2">this</span><span class="s1">.startNodeAt(leftStartLoc);</span>
        <span class="s1">node.left = left;</span>
        <span class="s1">node.operator = </span><span class="s2">this</span><span class="s1">.state.value;</span>
        <span class="s1">const logical = op === </span><span class="s3">41 </span><span class="s1">|| op === </span><span class="s3">42</span><span class="s1">;</span>
        <span class="s1">const coalesce = op === </span><span class="s3">40</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(coalesce) {</span>
          <span class="s1">prec = (</span><span class="s3">0</span><span class="s1">, _types.tokenOperatorPrecedence)(</span><span class="s3">42</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.next();</span>
        <span class="s2">if </span><span class="s1">(op === </span><span class="s3">39 </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.hasPlugin([</span><span class="s0">&quot;pipelineOperator&quot;</span><span class="s1">, {</span>
          <span class="s1">proposal: </span><span class="s0">&quot;minimal&quot;</span>
        <span class="s1">}])) {</span>
          <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.state.type === </span><span class="s3">96 </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.prodParam.hasAwait) {</span>
            <span class="s2">throw this</span><span class="s1">.raise(_parseError.Errors.UnexpectedAwaitAfterPipelineBody, {</span>
              <span class="s1">at: </span><span class="s2">this</span><span class="s1">.state.startLoc</span>
            <span class="s1">});</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">node.right = </span><span class="s2">this</span><span class="s1">.parseExprOpRightExpr(op, prec);</span>
        <span class="s1">const finishedNode = </span><span class="s2">this</span><span class="s1">.finishNode(node, logical || coalesce ? </span><span class="s0">&quot;LogicalExpression&quot; </span><span class="s1">: </span><span class="s0">&quot;BinaryExpression&quot;</span><span class="s1">);</span>
        <span class="s1">const nextOp = </span><span class="s2">this</span><span class="s1">.state.type;</span>
        <span class="s2">if </span><span class="s1">(coalesce &amp;&amp; (nextOp === </span><span class="s3">41 </span><span class="s1">|| nextOp === </span><span class="s3">42</span><span class="s1">) || logical &amp;&amp; nextOp === </span><span class="s3">40</span><span class="s1">) {</span>
          <span class="s2">throw this</span><span class="s1">.raise(_parseError.Errors.MixingCoalesceWithLogical, {</span>
            <span class="s1">at: </span><span class="s2">this</span><span class="s1">.state.startLoc</span>
          <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">return this</span><span class="s1">.parseExprOp(finishedNode, leftStartLoc, minPrec);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">left;</span>
  <span class="s1">}</span>
  <span class="s1">parseExprOpRightExpr(op, prec) {</span>
    <span class="s1">const startLoc = </span><span class="s2">this</span><span class="s1">.state.startLoc;</span>
    <span class="s2">switch </span><span class="s1">(op) {</span>
      <span class="s2">case </span><span class="s3">39</span><span class="s1">:</span>
        <span class="s2">switch </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.getPluginOption(</span><span class="s0">&quot;pipelineOperator&quot;</span><span class="s1">, </span><span class="s0">&quot;proposal&quot;</span><span class="s1">)) {</span>
          <span class="s2">case </span><span class="s0">&quot;hack&quot;</span><span class="s1">:</span>
            <span class="s2">return this</span><span class="s1">.withTopicBindingContext(() =&gt; {</span>
              <span class="s2">return this</span><span class="s1">.parseHackPipeBody();</span>
            <span class="s1">});</span>
          <span class="s2">case </span><span class="s0">&quot;smart&quot;</span><span class="s1">:</span>
            <span class="s2">return this</span><span class="s1">.withTopicBindingContext(() =&gt; {</span>
              <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.prodParam.hasYield &amp;&amp; </span><span class="s2">this</span><span class="s1">.isContextual(</span><span class="s3">106</span><span class="s1">)) {</span>
                <span class="s2">throw this</span><span class="s1">.raise(_parseError.Errors.PipeBodyIsTighter, {</span>
                  <span class="s1">at: </span><span class="s2">this</span><span class="s1">.state.startLoc</span>
                <span class="s1">});</span>
              <span class="s1">}</span>
              <span class="s2">return this</span><span class="s1">.parseSmartPipelineBodyInStyle(</span><span class="s2">this</span><span class="s1">.parseExprOpBaseRightExpr(op, prec), startLoc);</span>
            <span class="s1">});</span>
          <span class="s2">case </span><span class="s0">&quot;fsharp&quot;</span><span class="s1">:</span>
            <span class="s2">return this</span><span class="s1">.withSoloAwaitPermittingContext(() =&gt; {</span>
              <span class="s2">return this</span><span class="s1">.parseFSharpPipelineBody(prec);</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
      <span class="s2">default</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.parseExprOpBaseRightExpr(op, prec);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">parseExprOpBaseRightExpr(op, prec) {</span>
    <span class="s1">const startLoc = </span><span class="s2">this</span><span class="s1">.state.startLoc;</span>
    <span class="s2">return this</span><span class="s1">.parseExprOp(</span><span class="s2">this</span><span class="s1">.parseMaybeUnaryOrPrivate(), startLoc, (</span><span class="s3">0</span><span class="s1">, _types.tokenIsRightAssociative)(op) ? prec - </span><span class="s3">1 </span><span class="s1">: prec);</span>
  <span class="s1">}</span>
  <span class="s1">parseHackPipeBody() {</span>
    <span class="s2">var </span><span class="s1">_body$extra;</span>
    <span class="s1">const {</span>
      <span class="s1">startLoc</span>
    <span class="s1">} = </span><span class="s2">this</span><span class="s1">.state;</span>
    <span class="s1">const body = </span><span class="s2">this</span><span class="s1">.parseMaybeAssign();</span>
    <span class="s1">const requiredParentheses = _pipelineOperatorErrors.UnparenthesizedPipeBodyDescriptions.has(body.type);</span>
    <span class="s2">if </span><span class="s1">(requiredParentheses &amp;&amp; !((_body$extra = body.extra) != </span><span class="s2">null </span><span class="s1">&amp;&amp; _body$extra.parenthesized)) {</span>
      <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.PipeUnparenthesizedBody, {</span>
        <span class="s1">at: startLoc,</span>
        <span class="s1">type: body.type</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.topicReferenceWasUsedInCurrentContext()) {</span>
      <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.PipeTopicUnused, {</span>
        <span class="s1">at: startLoc</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">body;</span>
  <span class="s1">}</span>
  <span class="s1">checkExponentialAfterUnary(node) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">57</span><span class="s1">)) {</span>
      <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.UnexpectedTokenUnaryExponentiation, {</span>
        <span class="s1">at: node.argument</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">parseMaybeUnary(refExpressionErrors, sawUnary) {</span>
    <span class="s1">const startLoc = </span><span class="s2">this</span><span class="s1">.state.startLoc;</span>
    <span class="s1">const isAwait = </span><span class="s2">this</span><span class="s1">.isContextual(</span><span class="s3">96</span><span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(isAwait &amp;&amp; </span><span class="s2">this</span><span class="s1">.isAwaitAllowed()) {</span>
      <span class="s2">this</span><span class="s1">.next();</span>
      <span class="s1">const expr = </span><span class="s2">this</span><span class="s1">.parseAwait(startLoc);</span>
      <span class="s2">if </span><span class="s1">(!sawUnary) </span><span class="s2">this</span><span class="s1">.checkExponentialAfterUnary(expr);</span>
      <span class="s2">return </span><span class="s1">expr;</span>
    <span class="s1">}</span>
    <span class="s1">const update = </span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">34</span><span class="s1">);</span>
    <span class="s1">const node = </span><span class="s2">this</span><span class="s1">.startNode();</span>
    <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _types.tokenIsPrefix)(</span><span class="s2">this</span><span class="s1">.state.type)) {</span>
      <span class="s1">node.operator = </span><span class="s2">this</span><span class="s1">.state.value;</span>
      <span class="s1">node.prefix = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">72</span><span class="s1">)) {</span>
        <span class="s2">this</span><span class="s1">.expectPlugin(</span><span class="s0">&quot;throwExpressions&quot;</span><span class="s1">);</span>
      <span class="s1">}</span>
      <span class="s1">const isDelete = </span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">89</span><span class="s1">);</span>
      <span class="s2">this</span><span class="s1">.next();</span>
      <span class="s1">node.argument = </span><span class="s2">this</span><span class="s1">.parseMaybeUnary(</span><span class="s2">null</span><span class="s1">, </span><span class="s2">true</span><span class="s1">);</span>
      <span class="s2">this</span><span class="s1">.checkExpressionErrors(refExpressionErrors, </span><span class="s2">true</span><span class="s1">);</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.state.strict &amp;&amp; isDelete) {</span>
        <span class="s1">const arg = node.argument;</span>
        <span class="s2">if </span><span class="s1">(arg.type === </span><span class="s0">&quot;Identifier&quot;</span><span class="s1">) {</span>
          <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.StrictDelete, {</span>
            <span class="s1">at: node</span>
          <span class="s1">});</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.hasPropertyAsPrivateName(arg)) {</span>
          <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.DeletePrivateField, {</span>
            <span class="s1">at: node</span>
          <span class="s1">});</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(!update) {</span>
        <span class="s2">if </span><span class="s1">(!sawUnary) {</span>
          <span class="s2">this</span><span class="s1">.checkExponentialAfterUnary(node);</span>
        <span class="s1">}</span>
        <span class="s2">return this</span><span class="s1">.finishNode(node, </span><span class="s0">&quot;UnaryExpression&quot;</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">const expr = </span><span class="s2">this</span><span class="s1">.parseUpdate(node, update, refExpressionErrors);</span>
    <span class="s2">if </span><span class="s1">(isAwait) {</span>
      <span class="s1">const {</span>
        <span class="s1">type</span>
      <span class="s1">} = </span><span class="s2">this</span><span class="s1">.state;</span>
      <span class="s1">const startsExpr = </span><span class="s2">this</span><span class="s1">.hasPlugin(</span><span class="s0">&quot;v8intrinsic&quot;</span><span class="s1">) ? (</span><span class="s3">0</span><span class="s1">, _types.tokenCanStartExpression)(type) : (</span><span class="s3">0</span><span class="s1">, _types.tokenCanStartExpression)(type) &amp;&amp; !</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">54</span><span class="s1">);</span>
      <span class="s2">if </span><span class="s1">(startsExpr &amp;&amp; !</span><span class="s2">this</span><span class="s1">.isAmbiguousAwait()) {</span>
        <span class="s2">this</span><span class="s1">.raiseOverwrite(_parseError.Errors.AwaitNotInAsyncContext, {</span>
          <span class="s1">at: startLoc</span>
        <span class="s1">});</span>
        <span class="s2">return this</span><span class="s1">.parseAwait(startLoc);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">expr;</span>
  <span class="s1">}</span>
  <span class="s1">parseUpdate(node, update, refExpressionErrors) {</span>
    <span class="s2">if </span><span class="s1">(update) {</span>
      <span class="s1">const updateExpressionNode = node;</span>
      <span class="s2">this</span><span class="s1">.checkLVal(updateExpressionNode.argument, {</span>
        <span class="s2">in</span><span class="s1">: </span><span class="s2">this</span><span class="s1">.finishNode(updateExpressionNode, </span><span class="s0">&quot;UpdateExpression&quot;</span><span class="s1">)</span>
      <span class="s1">});</span>
      <span class="s2">return </span><span class="s1">node;</span>
    <span class="s1">}</span>
    <span class="s1">const startLoc = </span><span class="s2">this</span><span class="s1">.state.startLoc;</span>
    <span class="s1">let expr = </span><span class="s2">this</span><span class="s1">.parseExprSubscripts(refExpressionErrors);</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.checkExpressionErrors(refExpressionErrors, </span><span class="s2">false</span><span class="s1">)) </span><span class="s2">return </span><span class="s1">expr;</span>
    <span class="s2">while </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _types.tokenIsPostfix)(</span><span class="s2">this</span><span class="s1">.state.type) &amp;&amp; !</span><span class="s2">this</span><span class="s1">.canInsertSemicolon()) {</span>
      <span class="s1">const node = </span><span class="s2">this</span><span class="s1">.startNodeAt(startLoc);</span>
      <span class="s1">node.operator = </span><span class="s2">this</span><span class="s1">.state.value;</span>
      <span class="s1">node.prefix = </span><span class="s2">false</span><span class="s1">;</span>
      <span class="s1">node.argument = expr;</span>
      <span class="s2">this</span><span class="s1">.next();</span>
      <span class="s2">this</span><span class="s1">.checkLVal(expr, {</span>
        <span class="s2">in</span><span class="s1">: expr = </span><span class="s2">this</span><span class="s1">.finishNode(node, </span><span class="s0">&quot;UpdateExpression&quot;</span><span class="s1">)</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">expr;</span>
  <span class="s1">}</span>
  <span class="s1">parseExprSubscripts(refExpressionErrors) {</span>
    <span class="s1">const startLoc = </span><span class="s2">this</span><span class="s1">.state.startLoc;</span>
    <span class="s1">const potentialArrowAt = </span><span class="s2">this</span><span class="s1">.state.potentialArrowAt;</span>
    <span class="s1">const expr = </span><span class="s2">this</span><span class="s1">.parseExprAtom(refExpressionErrors);</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.shouldExitDescending(expr, potentialArrowAt)) {</span>
      <span class="s2">return </span><span class="s1">expr;</span>
    <span class="s1">}</span>
    <span class="s2">return this</span><span class="s1">.parseSubscripts(expr, startLoc);</span>
  <span class="s1">}</span>
  <span class="s1">parseSubscripts(base, startLoc, noCalls) {</span>
    <span class="s1">const state = {</span>
      <span class="s1">optionalChainMember: </span><span class="s2">false</span><span class="s1">,</span>
      <span class="s1">maybeAsyncArrow: </span><span class="s2">this</span><span class="s1">.atPossibleAsyncArrow(base),</span>
      <span class="s1">stop: </span><span class="s2">false</span>
    <span class="s1">};</span>
    <span class="s2">do </span><span class="s1">{</span>
      <span class="s1">base = </span><span class="s2">this</span><span class="s1">.parseSubscript(base, startLoc, noCalls, state);</span>
      <span class="s1">state.maybeAsyncArrow = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">while </span><span class="s1">(!state.stop);</span>
    <span class="s2">return </span><span class="s1">base;</span>
  <span class="s1">}</span>
  <span class="s1">parseSubscript(base, startLoc, noCalls, state) {</span>
    <span class="s1">const {</span>
      <span class="s1">type</span>
    <span class="s1">} = </span><span class="s2">this</span><span class="s1">.state;</span>
    <span class="s2">if </span><span class="s1">(!noCalls &amp;&amp; type === </span><span class="s3">15</span><span class="s1">) {</span>
      <span class="s2">return this</span><span class="s1">.parseBind(base, startLoc, noCalls, state);</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _types.tokenIsTemplate)(type)) {</span>
      <span class="s2">return this</span><span class="s1">.parseTaggedTemplateExpression(base, startLoc, state);</span>
    <span class="s1">}</span>
    <span class="s1">let optional = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s2">if </span><span class="s1">(type === </span><span class="s3">18</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(noCalls) {</span>
        <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.OptionalChainingNoNew, {</span>
          <span class="s1">at: </span><span class="s2">this</span><span class="s1">.state.startLoc</span>
        <span class="s1">});</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.lookaheadCharCode() === </span><span class="s3">40</span><span class="s1">) {</span>
          <span class="s1">state.stop = </span><span class="s2">true</span><span class="s1">;</span>
          <span class="s2">return </span><span class="s1">base;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s1">state.optionalChainMember = optional = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s2">this</span><span class="s1">.next();</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!noCalls &amp;&amp; </span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">10</span><span class="s1">)) {</span>
      <span class="s2">return this</span><span class="s1">.parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">const computed = </span><span class="s2">this</span><span class="s1">.eat(</span><span class="s3">0</span><span class="s1">);</span>
      <span class="s2">if </span><span class="s1">(computed || optional || </span><span class="s2">this</span><span class="s1">.eat(</span><span class="s3">16</span><span class="s1">)) {</span>
        <span class="s2">return this</span><span class="s1">.parseMember(base, startLoc, state, computed, optional);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">state.stop = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s2">return </span><span class="s1">base;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">parseMember(base, startLoc, state, computed, optional) {</span>
    <span class="s1">const node = </span><span class="s2">this</span><span class="s1">.startNodeAt(startLoc);</span>
    <span class="s1">node.object = base;</span>
    <span class="s1">node.computed = computed;</span>
    <span class="s2">if </span><span class="s1">(computed) {</span>
      <span class="s1">node.property = </span><span class="s2">this</span><span class="s1">.parseExpression();</span>
      <span class="s2">this</span><span class="s1">.expect(</span><span class="s3">3</span><span class="s1">);</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">136</span><span class="s1">)) {</span>
      <span class="s2">if </span><span class="s1">(base.type === </span><span class="s0">&quot;Super&quot;</span><span class="s1">) {</span>
        <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.SuperPrivateField, {</span>
          <span class="s1">at: startLoc</span>
        <span class="s1">});</span>
      <span class="s1">}</span>
      <span class="s2">this</span><span class="s1">.classScope.usePrivateName(</span><span class="s2">this</span><span class="s1">.state.value, </span><span class="s2">this</span><span class="s1">.state.startLoc);</span>
      <span class="s1">node.property = </span><span class="s2">this</span><span class="s1">.parsePrivateName();</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">node.property = </span><span class="s2">this</span><span class="s1">.parseIdentifier(</span><span class="s2">true</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(state.optionalChainMember) {</span>
      <span class="s1">node.optional = optional;</span>
      <span class="s2">return this</span><span class="s1">.finishNode(node, </span><span class="s0">&quot;OptionalMemberExpression&quot;</span><span class="s1">);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">return this</span><span class="s1">.finishNode(node, </span><span class="s0">&quot;MemberExpression&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">parseBind(base, startLoc, noCalls, state) {</span>
    <span class="s1">const node = </span><span class="s2">this</span><span class="s1">.startNodeAt(startLoc);</span>
    <span class="s1">node.object = base;</span>
    <span class="s2">this</span><span class="s1">.next();</span>
    <span class="s1">node.callee = </span><span class="s2">this</span><span class="s1">.parseNoCallExpr();</span>
    <span class="s1">state.stop = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s2">return this</span><span class="s1">.parseSubscripts(</span><span class="s2">this</span><span class="s1">.finishNode(node, </span><span class="s0">&quot;BindExpression&quot;</span><span class="s1">), startLoc, noCalls);</span>
  <span class="s1">}</span>
  <span class="s1">parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional) {</span>
    <span class="s1">const oldMaybeInArrowParameters = </span><span class="s2">this</span><span class="s1">.state.maybeInArrowParameters;</span>
    <span class="s1">let refExpressionErrors = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">this</span><span class="s1">.state.maybeInArrowParameters = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s2">this</span><span class="s1">.next();</span>
    <span class="s1">const node = </span><span class="s2">this</span><span class="s1">.startNodeAt(startLoc);</span>
    <span class="s1">node.callee = base;</span>
    <span class="s1">const {</span>
      <span class="s1">maybeAsyncArrow,</span>
      <span class="s1">optionalChainMember</span>
    <span class="s1">} = state;</span>
    <span class="s2">if </span><span class="s1">(maybeAsyncArrow) {</span>
      <span class="s2">this</span><span class="s1">.expressionScope.enter((</span><span class="s3">0</span><span class="s1">, _expressionScope.newAsyncArrowScope)());</span>
      <span class="s1">refExpressionErrors = </span><span class="s2">new </span><span class="s1">_util.ExpressionErrors();</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(optionalChainMember) {</span>
      <span class="s1">node.optional = optional;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(optional) {</span>
      <span class="s1">node.arguments = </span><span class="s2">this</span><span class="s1">.parseCallExpressionArguments(</span><span class="s3">11</span><span class="s1">);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">node.arguments = </span><span class="s2">this</span><span class="s1">.parseCallExpressionArguments(</span><span class="s3">11</span><span class="s1">, base.type === </span><span class="s0">&quot;Import&quot;</span><span class="s1">, base.type !== </span><span class="s0">&quot;Super&quot;</span><span class="s1">, node, refExpressionErrors);</span>
    <span class="s1">}</span>
    <span class="s1">let finishedNode = </span><span class="s2">this</span><span class="s1">.finishCallExpression(node, optionalChainMember);</span>
    <span class="s2">if </span><span class="s1">(maybeAsyncArrow &amp;&amp; </span><span class="s2">this</span><span class="s1">.shouldParseAsyncArrow() &amp;&amp; !optional) {</span>
      <span class="s1">state.stop = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s2">this</span><span class="s1">.checkDestructuringPrivate(refExpressionErrors);</span>
      <span class="s2">this</span><span class="s1">.expressionScope.validateAsPattern();</span>
      <span class="s2">this</span><span class="s1">.expressionScope.exit();</span>
      <span class="s1">finishedNode = </span><span class="s2">this</span><span class="s1">.parseAsyncArrowFromCallExpression(</span><span class="s2">this</span><span class="s1">.startNodeAt(startLoc), finishedNode);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(maybeAsyncArrow) {</span>
        <span class="s2">this</span><span class="s1">.checkExpressionErrors(refExpressionErrors, </span><span class="s2">true</span><span class="s1">);</span>
        <span class="s2">this</span><span class="s1">.expressionScope.exit();</span>
      <span class="s1">}</span>
      <span class="s2">this</span><span class="s1">.toReferencedArguments(finishedNode);</span>
    <span class="s1">}</span>
    <span class="s2">this</span><span class="s1">.state.maybeInArrowParameters = oldMaybeInArrowParameters;</span>
    <span class="s2">return </span><span class="s1">finishedNode;</span>
  <span class="s1">}</span>
  <span class="s1">toReferencedArguments(node, isParenthesizedExpr) {</span>
    <span class="s2">this</span><span class="s1">.toReferencedListDeep(node.arguments, isParenthesizedExpr);</span>
  <span class="s1">}</span>
  <span class="s1">parseTaggedTemplateExpression(base, startLoc, state) {</span>
    <span class="s1">const node = </span><span class="s2">this</span><span class="s1">.startNodeAt(startLoc);</span>
    <span class="s1">node.tag = base;</span>
    <span class="s1">node.quasi = </span><span class="s2">this</span><span class="s1">.parseTemplate(</span><span class="s2">true</span><span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(state.optionalChainMember) {</span>
      <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.OptionalChainingNoTemplate, {</span>
        <span class="s1">at: startLoc</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">return this</span><span class="s1">.finishNode(node, </span><span class="s0">&quot;TaggedTemplateExpression&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">atPossibleAsyncArrow(base) {</span>
    <span class="s2">return </span><span class="s1">base.type === </span><span class="s0">&quot;Identifier&quot; </span><span class="s1">&amp;&amp; base.name === </span><span class="s0">&quot;async&quot; </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.state.lastTokEndLoc.index === base.end &amp;&amp; !</span><span class="s2">this</span><span class="s1">.canInsertSemicolon() &amp;&amp; base.end - base.start === </span><span class="s3">5 </span><span class="s1">&amp;&amp; base.start === </span><span class="s2">this</span><span class="s1">.state.potentialArrowAt;</span>
  <span class="s1">}</span>
  <span class="s1">expectImportAttributesPlugin() {</span>
    <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.hasPlugin(</span><span class="s0">&quot;importAssertions&quot;</span><span class="s1">)) {</span>
      <span class="s2">this</span><span class="s1">.expectPlugin(</span><span class="s0">&quot;importAttributes&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">finishCallExpression(node, optional) {</span>
    <span class="s2">if </span><span class="s1">(node.callee.type === </span><span class="s0">&quot;Import&quot;</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(node.arguments.length === </span><span class="s3">2</span><span class="s1">) {</span>
        <span class="s1">{</span>
          <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.hasPlugin(</span><span class="s0">&quot;moduleAttributes&quot;</span><span class="s1">)) {</span>
            <span class="s2">this</span><span class="s1">.expectImportAttributesPlugin();</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(node.arguments.length === </span><span class="s3">0 </span><span class="s1">|| node.arguments.length &gt; </span><span class="s3">2</span><span class="s1">) {</span>
        <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.ImportCallArity, {</span>
          <span class="s1">at: node,</span>
          <span class="s1">maxArgumentCount: </span><span class="s2">this</span><span class="s1">.hasPlugin(</span><span class="s0">&quot;importAttributes&quot;</span><span class="s1">) || </span><span class="s2">this</span><span class="s1">.hasPlugin(</span><span class="s0">&quot;importAssertions&quot;</span><span class="s1">) || </span><span class="s2">this</span><span class="s1">.hasPlugin(</span><span class="s0">&quot;moduleAttributes&quot;</span><span class="s1">) ? </span><span class="s3">2 </span><span class="s1">: </span><span class="s3">1</span>
        <span class="s1">});</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">for </span><span class="s1">(const arg of node.arguments) {</span>
          <span class="s2">if </span><span class="s1">(arg.type === </span><span class="s0">&quot;SpreadElement&quot;</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.ImportCallSpreadArgument, {</span>
              <span class="s1">at: arg</span>
            <span class="s1">});</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return this</span><span class="s1">.finishNode(node, optional ? </span><span class="s0">&quot;OptionalCallExpression&quot; </span><span class="s1">: </span><span class="s0">&quot;CallExpression&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">parseCallExpressionArguments(close, dynamicImport, allowPlaceholder, nodeForExtra, refExpressionErrors) {</span>
    <span class="s1">const elts = [];</span>
    <span class="s1">let first = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">const oldInFSharpPipelineDirectBody = </span><span class="s2">this</span><span class="s1">.state.inFSharpPipelineDirectBody;</span>
    <span class="s2">this</span><span class="s1">.state.inFSharpPipelineDirectBody = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s2">while </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.eat(close)) {</span>
      <span class="s2">if </span><span class="s1">(first) {</span>
        <span class="s1">first = </span><span class="s2">false</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">this</span><span class="s1">.expect(</span><span class="s3">12</span><span class="s1">);</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.match(close)) {</span>
          <span class="s2">if </span><span class="s1">(dynamicImport &amp;&amp; !</span><span class="s2">this</span><span class="s1">.hasPlugin(</span><span class="s0">&quot;importAttributes&quot;</span><span class="s1">) &amp;&amp; !</span><span class="s2">this</span><span class="s1">.hasPlugin(</span><span class="s0">&quot;importAssertions&quot;</span><span class="s1">) &amp;&amp; !</span><span class="s2">this</span><span class="s1">.hasPlugin(</span><span class="s0">&quot;moduleAttributes&quot;</span><span class="s1">)) {</span>
            <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.ImportCallArgumentTrailingComma, {</span>
              <span class="s1">at: </span><span class="s2">this</span><span class="s1">.state.lastTokStartLoc</span>
            <span class="s1">});</span>
          <span class="s1">}</span>
          <span class="s2">if </span><span class="s1">(nodeForExtra) {</span>
            <span class="s2">this</span><span class="s1">.addTrailingCommaExtraToNode(nodeForExtra);</span>
          <span class="s1">}</span>
          <span class="s2">this</span><span class="s1">.next();</span>
          <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s1">elts.push(</span><span class="s2">this</span><span class="s1">.parseExprListItem(</span><span class="s2">false</span><span class="s1">, refExpressionErrors, allowPlaceholder));</span>
    <span class="s1">}</span>
    <span class="s2">this</span><span class="s1">.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;</span>
    <span class="s2">return </span><span class="s1">elts;</span>
  <span class="s1">}</span>
  <span class="s1">shouldParseAsyncArrow() {</span>
    <span class="s2">return this</span><span class="s1">.match(</span><span class="s3">19</span><span class="s1">) &amp;&amp; !</span><span class="s2">this</span><span class="s1">.canInsertSemicolon();</span>
  <span class="s1">}</span>
  <span class="s1">parseAsyncArrowFromCallExpression(node, call) {</span>
    <span class="s2">var </span><span class="s1">_call$extra;</span>
    <span class="s2">this</span><span class="s1">.resetPreviousNodeTrailingComments(call);</span>
    <span class="s2">this</span><span class="s1">.expect(</span><span class="s3">19</span><span class="s1">);</span>
    <span class="s2">this</span><span class="s1">.parseArrowExpression(node, call.arguments, </span><span class="s2">true</span><span class="s1">, (_call$extra = call.extra) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _call$extra.trailingCommaLoc);</span>
    <span class="s2">if </span><span class="s1">(call.innerComments) {</span>
      <span class="s1">(</span><span class="s3">0</span><span class="s1">, _comments.setInnerComments)(node, call.innerComments);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(call.callee.trailingComments) {</span>
      <span class="s1">(</span><span class="s3">0</span><span class="s1">, _comments.setInnerComments)(node, call.callee.trailingComments);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">node;</span>
  <span class="s1">}</span>
  <span class="s1">parseNoCallExpr() {</span>
    <span class="s1">const startLoc = </span><span class="s2">this</span><span class="s1">.state.startLoc;</span>
    <span class="s2">return this</span><span class="s1">.parseSubscripts(</span><span class="s2">this</span><span class="s1">.parseExprAtom(), startLoc, </span><span class="s2">true</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">parseExprAtom(refExpressionErrors) {</span>
    <span class="s1">let node;</span>
    <span class="s1">let decorators = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">const {</span>
      <span class="s1">type</span>
    <span class="s1">} = </span><span class="s2">this</span><span class="s1">.state;</span>
    <span class="s2">switch </span><span class="s1">(type) {</span>
      <span class="s2">case </span><span class="s3">79</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.parseSuper();</span>
      <span class="s2">case </span><span class="s3">83</span><span class="s1">:</span>
        <span class="s1">node = </span><span class="s2">this</span><span class="s1">.startNode();</span>
        <span class="s2">this</span><span class="s1">.next();</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">16</span><span class="s1">)) {</span>
          <span class="s2">return this</span><span class="s1">.parseImportMetaProperty(node);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">10</span><span class="s1">)) {</span>
          <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.UnsupportedImport, {</span>
            <span class="s1">at: </span><span class="s2">this</span><span class="s1">.state.lastTokStartLoc</span>
          <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">return this</span><span class="s1">.finishNode(node, </span><span class="s0">&quot;Import&quot;</span><span class="s1">);</span>
      <span class="s2">case </span><span class="s3">78</span><span class="s1">:</span>
        <span class="s1">node = </span><span class="s2">this</span><span class="s1">.startNode();</span>
        <span class="s2">this</span><span class="s1">.next();</span>
        <span class="s2">return this</span><span class="s1">.finishNode(node, </span><span class="s0">&quot;ThisExpression&quot;</span><span class="s1">);</span>
      <span class="s2">case </span><span class="s3">90</span><span class="s1">:</span>
        <span class="s1">{</span>
          <span class="s2">return this</span><span class="s1">.parseDo(</span><span class="s2">this</span><span class="s1">.startNode(), </span><span class="s2">false</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s2">case </span><span class="s3">56</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s3">31</span><span class="s1">:</span>
        <span class="s1">{</span>
          <span class="s2">this</span><span class="s1">.readRegexp();</span>
          <span class="s2">return this</span><span class="s1">.parseRegExpLiteral(</span><span class="s2">this</span><span class="s1">.state.value);</span>
        <span class="s1">}</span>
      <span class="s2">case </span><span class="s3">132</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.parseNumericLiteral(</span><span class="s2">this</span><span class="s1">.state.value);</span>
      <span class="s2">case </span><span class="s3">133</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.parseBigIntLiteral(</span><span class="s2">this</span><span class="s1">.state.value);</span>
      <span class="s2">case </span><span class="s3">134</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.parseDecimalLiteral(</span><span class="s2">this</span><span class="s1">.state.value);</span>
      <span class="s2">case </span><span class="s3">131</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.parseStringLiteral(</span><span class="s2">this</span><span class="s1">.state.value);</span>
      <span class="s2">case </span><span class="s3">84</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.parseNullLiteral();</span>
      <span class="s2">case </span><span class="s3">85</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.parseBooleanLiteral(</span><span class="s2">true</span><span class="s1">);</span>
      <span class="s2">case </span><span class="s3">86</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.parseBooleanLiteral(</span><span class="s2">false</span><span class="s1">);</span>
      <span class="s2">case </span><span class="s3">10</span><span class="s1">:</span>
        <span class="s1">{</span>
          <span class="s1">const canBeArrow = </span><span class="s2">this</span><span class="s1">.state.potentialArrowAt === </span><span class="s2">this</span><span class="s1">.state.start;</span>
          <span class="s2">return this</span><span class="s1">.parseParenAndDistinguishExpression(canBeArrow);</span>
        <span class="s1">}</span>
      <span class="s2">case </span><span class="s3">2</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s3">1</span><span class="s1">:</span>
        <span class="s1">{</span>
          <span class="s2">return this</span><span class="s1">.parseArrayLike(</span><span class="s2">this</span><span class="s1">.state.type === </span><span class="s3">2 </span><span class="s1">? </span><span class="s3">4 </span><span class="s1">: </span><span class="s3">3</span><span class="s1">, </span><span class="s2">false</span><span class="s1">, </span><span class="s2">true</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s2">case </span><span class="s3">0</span><span class="s1">:</span>
        <span class="s1">{</span>
          <span class="s2">return this</span><span class="s1">.parseArrayLike(</span><span class="s3">3</span><span class="s1">, </span><span class="s2">true</span><span class="s1">, </span><span class="s2">false</span><span class="s1">, refExpressionErrors);</span>
        <span class="s1">}</span>
      <span class="s2">case </span><span class="s3">6</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s3">7</span><span class="s1">:</span>
        <span class="s1">{</span>
          <span class="s2">return this</span><span class="s1">.parseObjectLike(</span><span class="s2">this</span><span class="s1">.state.type === </span><span class="s3">6 </span><span class="s1">? </span><span class="s3">9 </span><span class="s1">: </span><span class="s3">8</span><span class="s1">, </span><span class="s2">false</span><span class="s1">, </span><span class="s2">true</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s2">case </span><span class="s3">5</span><span class="s1">:</span>
        <span class="s1">{</span>
          <span class="s2">return this</span><span class="s1">.parseObjectLike(</span><span class="s3">8</span><span class="s1">, </span><span class="s2">false</span><span class="s1">, </span><span class="s2">false</span><span class="s1">, refExpressionErrors);</span>
        <span class="s1">}</span>
      <span class="s2">case </span><span class="s3">68</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.parseFunctionOrFunctionSent();</span>
      <span class="s2">case </span><span class="s3">26</span><span class="s1">:</span>
        <span class="s1">decorators = </span><span class="s2">this</span><span class="s1">.parseDecorators();</span>
      <span class="s2">case </span><span class="s3">80</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.parseClass(</span><span class="s2">this</span><span class="s1">.maybeTakeDecorators(decorators, </span><span class="s2">this</span><span class="s1">.startNode()), </span><span class="s2">false</span><span class="s1">);</span>
      <span class="s2">case </span><span class="s3">77</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.parseNewOrNewTarget();</span>
      <span class="s2">case </span><span class="s3">25</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s3">24</span><span class="s1">:</span>
        <span class="s2">return this</span><span class="s1">.parseTemplate(</span><span class="s2">false</span><span class="s1">);</span>
      <span class="s2">case </span><span class="s3">15</span><span class="s1">:</span>
        <span class="s1">{</span>
          <span class="s1">node = </span><span class="s2">this</span><span class="s1">.startNode();</span>
          <span class="s2">this</span><span class="s1">.next();</span>
          <span class="s1">node.object = </span><span class="s2">null</span><span class="s1">;</span>
          <span class="s1">const callee = node.callee = </span><span class="s2">this</span><span class="s1">.parseNoCallExpr();</span>
          <span class="s2">if </span><span class="s1">(callee.type === </span><span class="s0">&quot;MemberExpression&quot;</span><span class="s1">) {</span>
            <span class="s2">return this</span><span class="s1">.finishNode(node, </span><span class="s0">&quot;BindExpression&quot;</span><span class="s1">);</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s2">throw this</span><span class="s1">.raise(_parseError.Errors.UnsupportedBind, {</span>
              <span class="s1">at: callee</span>
            <span class="s1">});</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s2">case </span><span class="s3">136</span><span class="s1">:</span>
        <span class="s1">{</span>
          <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.PrivateInExpectedIn, {</span>
            <span class="s1">at: </span><span class="s2">this</span><span class="s1">.state.startLoc,</span>
            <span class="s1">identifierName: </span><span class="s2">this</span><span class="s1">.state.value</span>
          <span class="s1">});</span>
          <span class="s2">return this</span><span class="s1">.parsePrivateName();</span>
        <span class="s1">}</span>
      <span class="s2">case </span><span class="s3">33</span><span class="s1">:</span>
        <span class="s1">{</span>
          <span class="s2">return this</span><span class="s1">.parseTopicReferenceThenEqualsSign(</span><span class="s3">54</span><span class="s1">, </span><span class="s0">&quot;%&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s2">case </span><span class="s3">32</span><span class="s1">:</span>
        <span class="s1">{</span>
          <span class="s2">return this</span><span class="s1">.parseTopicReferenceThenEqualsSign(</span><span class="s3">44</span><span class="s1">, </span><span class="s0">&quot;^&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s2">case </span><span class="s3">37</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s3">38</span><span class="s1">:</span>
        <span class="s1">{</span>
          <span class="s2">return this</span><span class="s1">.parseTopicReference(</span><span class="s0">&quot;hack&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s2">case </span><span class="s3">44</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s3">54</span><span class="s1">:</span>
      <span class="s2">case </span><span class="s3">27</span><span class="s1">:</span>
        <span class="s1">{</span>
          <span class="s1">const pipeProposal = </span><span class="s2">this</span><span class="s1">.getPluginOption(</span><span class="s0">&quot;pipelineOperator&quot;</span><span class="s1">, </span><span class="s0">&quot;proposal&quot;</span><span class="s1">);</span>
          <span class="s2">if </span><span class="s1">(pipeProposal) {</span>
            <span class="s2">return this</span><span class="s1">.parseTopicReference(pipeProposal);</span>
          <span class="s1">}</span>
          <span class="s2">this</span><span class="s1">.unexpected();</span>
          <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s2">case </span><span class="s3">47</span><span class="s1">:</span>
        <span class="s1">{</span>
          <span class="s1">const lookaheadCh = </span><span class="s2">this</span><span class="s1">.input.codePointAt(</span><span class="s2">this</span><span class="s1">.nextTokenStart());</span>
          <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _identifier.isIdentifierStart)(lookaheadCh) || lookaheadCh === </span><span class="s3">62</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.expectOnePlugin([</span><span class="s0">&quot;jsx&quot;</span><span class="s1">, </span><span class="s0">&quot;flow&quot;</span><span class="s1">, </span><span class="s0">&quot;typescript&quot;</span><span class="s1">]);</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s2">this</span><span class="s1">.unexpected();</span>
          <span class="s1">}</span>
          <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s2">default</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _types.tokenIsIdentifier)(type)) {</span>
          <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isContextual(</span><span class="s3">125</span><span class="s1">) &amp;&amp; </span><span class="s2">this</span><span class="s1">.lookaheadInLineCharCode() === </span><span class="s3">123</span><span class="s1">) {</span>
            <span class="s2">return this</span><span class="s1">.parseModuleExpression();</span>
          <span class="s1">}</span>
          <span class="s1">const canBeArrow = </span><span class="s2">this</span><span class="s1">.state.potentialArrowAt === </span><span class="s2">this</span><span class="s1">.state.start;</span>
          <span class="s1">const containsEsc = </span><span class="s2">this</span><span class="s1">.state.containsEsc;</span>
          <span class="s1">const id = </span><span class="s2">this</span><span class="s1">.parseIdentifier();</span>
          <span class="s2">if </span><span class="s1">(!containsEsc &amp;&amp; id.name === </span><span class="s0">&quot;async&quot; </span><span class="s1">&amp;&amp; !</span><span class="s2">this</span><span class="s1">.canInsertSemicolon()) {</span>
            <span class="s1">const {</span>
              <span class="s1">type</span>
            <span class="s1">} = </span><span class="s2">this</span><span class="s1">.state;</span>
            <span class="s2">if </span><span class="s1">(type === </span><span class="s3">68</span><span class="s1">) {</span>
              <span class="s2">this</span><span class="s1">.resetPreviousNodeTrailingComments(id);</span>
              <span class="s2">this</span><span class="s1">.next();</span>
              <span class="s2">return this</span><span class="s1">.parseAsyncFunctionExpression(</span><span class="s2">this</span><span class="s1">.startNodeAtNode(id));</span>
            <span class="s1">} </span><span class="s2">else if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _types.tokenIsIdentifier)(type)) {</span>
              <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.lookaheadCharCode() === </span><span class="s3">61</span><span class="s1">) {</span>
                <span class="s2">return this</span><span class="s1">.parseAsyncArrowUnaryFunction(</span><span class="s2">this</span><span class="s1">.startNodeAtNode(id));</span>
              <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s2">return </span><span class="s1">id;</span>
              <span class="s1">}</span>
            <span class="s1">} </span><span class="s2">else if </span><span class="s1">(type === </span><span class="s3">90</span><span class="s1">) {</span>
              <span class="s2">this</span><span class="s1">.resetPreviousNodeTrailingComments(id);</span>
              <span class="s2">return this</span><span class="s1">.parseDo(</span><span class="s2">this</span><span class="s1">.startNodeAtNode(id), </span><span class="s2">true</span><span class="s1">);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
          <span class="s2">if </span><span class="s1">(canBeArrow &amp;&amp; </span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">19</span><span class="s1">) &amp;&amp; !</span><span class="s2">this</span><span class="s1">.canInsertSemicolon()) {</span>
            <span class="s2">this</span><span class="s1">.next();</span>
            <span class="s2">return this</span><span class="s1">.parseArrowExpression(</span><span class="s2">this</span><span class="s1">.startNodeAtNode(id), [id], </span><span class="s2">false</span><span class="s1">);</span>
          <span class="s1">}</span>
          <span class="s2">return </span><span class="s1">id;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s2">this</span><span class="s1">.unexpected();</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">parseTopicReferenceThenEqualsSign(topicTokenType, topicTokenValue) {</span>
    <span class="s1">const pipeProposal = </span><span class="s2">this</span><span class="s1">.getPluginOption(</span><span class="s0">&quot;pipelineOperator&quot;</span><span class="s1">, </span><span class="s0">&quot;proposal&quot;</span><span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(pipeProposal) {</span>
      <span class="s2">this</span><span class="s1">.state.type = topicTokenType;</span>
      <span class="s2">this</span><span class="s1">.state.value = topicTokenValue;</span>
      <span class="s2">this</span><span class="s1">.state.pos--;</span>
      <span class="s2">this</span><span class="s1">.state.end--;</span>
      <span class="s2">this</span><span class="s1">.state.endLoc = (</span><span class="s3">0</span><span class="s1">, _location.createPositionWithColumnOffset)(</span><span class="s2">this</span><span class="s1">.state.endLoc, -</span><span class="s3">1</span><span class="s1">);</span>
      <span class="s2">return this</span><span class="s1">.parseTopicReference(pipeProposal);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">this</span><span class="s1">.unexpected();</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">parseTopicReference(pipeProposal) {</span>
    <span class="s1">const node = </span><span class="s2">this</span><span class="s1">.startNode();</span>
    <span class="s1">const startLoc = </span><span class="s2">this</span><span class="s1">.state.startLoc;</span>
    <span class="s1">const tokenType = </span><span class="s2">this</span><span class="s1">.state.type;</span>
    <span class="s2">this</span><span class="s1">.next();</span>
    <span class="s2">return this</span><span class="s1">.finishTopicReference(node, startLoc, pipeProposal, tokenType);</span>
  <span class="s1">}</span>
  <span class="s1">finishTopicReference(node, startLoc, pipeProposal, tokenType) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType)) {</span>
      <span class="s1">const nodeType = pipeProposal === </span><span class="s0">&quot;smart&quot; </span><span class="s1">? </span><span class="s0">&quot;PipelinePrimaryTopicReference&quot; </span><span class="s1">: </span><span class="s0">&quot;TopicReference&quot;</span><span class="s1">;</span>
      <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.topicReferenceIsAllowedInCurrentContext()) {</span>
        <span class="s2">this</span><span class="s1">.raise(pipeProposal === </span><span class="s0">&quot;smart&quot; </span><span class="s1">? _parseError.Errors.PrimaryTopicNotAllowed : _parseError.Errors.PipeTopicUnbound, {</span>
          <span class="s1">at: startLoc</span>
        <span class="s1">});</span>
      <span class="s1">}</span>
      <span class="s2">this</span><span class="s1">.registerTopicReference();</span>
      <span class="s2">return this</span><span class="s1">.finishNode(node, nodeType);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">throw this</span><span class="s1">.raise(_parseError.Errors.PipeTopicUnconfiguredToken, {</span>
        <span class="s1">at: startLoc,</span>
        <span class="s1">token: (</span><span class="s3">0</span><span class="s1">, _types.tokenLabelName)(tokenType)</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType) {</span>
    <span class="s2">switch </span><span class="s1">(pipeProposal) {</span>
      <span class="s2">case </span><span class="s0">&quot;hack&quot;</span><span class="s1">:</span>
        <span class="s1">{</span>
          <span class="s2">return this</span><span class="s1">.hasPlugin([</span><span class="s0">&quot;pipelineOperator&quot;</span><span class="s1">, {</span>
            <span class="s1">topicToken: (</span><span class="s3">0</span><span class="s1">, _types.tokenLabelName)(tokenType)</span>
          <span class="s1">}]);</span>
        <span class="s1">}</span>
      <span class="s2">case </span><span class="s0">&quot;smart&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">tokenType === </span><span class="s3">27</span><span class="s1">;</span>
      <span class="s2">default</span><span class="s1">:</span>
        <span class="s2">throw this</span><span class="s1">.raise(_parseError.Errors.PipeTopicRequiresHackPipes, {</span>
          <span class="s1">at: startLoc</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">parseAsyncArrowUnaryFunction(node) {</span>
    <span class="s2">this</span><span class="s1">.prodParam.enter((</span><span class="s3">0</span><span class="s1">, _productionParameter.functionFlags)(</span><span class="s2">true</span><span class="s1">, </span><span class="s2">this</span><span class="s1">.prodParam.hasYield));</span>
    <span class="s1">const params = [</span><span class="s2">this</span><span class="s1">.parseIdentifier()];</span>
    <span class="s2">this</span><span class="s1">.prodParam.exit();</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.hasPrecedingLineBreak()) {</span>
      <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.LineTerminatorBeforeArrow, {</span>
        <span class="s1">at: </span><span class="s2">this</span><span class="s1">.state.curPosition()</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">this</span><span class="s1">.expect(</span><span class="s3">19</span><span class="s1">);</span>
    <span class="s2">return this</span><span class="s1">.parseArrowExpression(node, params, </span><span class="s2">true</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">parseDo(node, isAsync) {</span>
    <span class="s2">this</span><span class="s1">.expectPlugin(</span><span class="s0">&quot;doExpressions&quot;</span><span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(isAsync) {</span>
      <span class="s2">this</span><span class="s1">.expectPlugin(</span><span class="s0">&quot;asyncDoExpressions&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">node.async = isAsync;</span>
    <span class="s2">this</span><span class="s1">.next();</span>
    <span class="s1">const oldLabels = </span><span class="s2">this</span><span class="s1">.state.labels;</span>
    <span class="s2">this</span><span class="s1">.state.labels = [];</span>
    <span class="s2">if </span><span class="s1">(isAsync) {</span>
      <span class="s2">this</span><span class="s1">.prodParam.enter(_productionParameter.PARAM_AWAIT);</span>
      <span class="s1">node.body = </span><span class="s2">this</span><span class="s1">.parseBlock();</span>
      <span class="s2">this</span><span class="s1">.prodParam.exit();</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">node.body = </span><span class="s2">this</span><span class="s1">.parseBlock();</span>
    <span class="s1">}</span>
    <span class="s2">this</span><span class="s1">.state.labels = oldLabels;</span>
    <span class="s2">return this</span><span class="s1">.finishNode(node, </span><span class="s0">&quot;DoExpression&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">parseSuper() {</span>
    <span class="s1">const node = </span><span class="s2">this</span><span class="s1">.startNode();</span>
    <span class="s2">this</span><span class="s1">.next();</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">10</span><span class="s1">) &amp;&amp; !</span><span class="s2">this</span><span class="s1">.scope.allowDirectSuper &amp;&amp; !</span><span class="s2">this</span><span class="s1">.options.allowSuperOutsideMethod) {</span>
      <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.SuperNotAllowed, {</span>
        <span class="s1">at: node</span>
      <span class="s1">});</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.scope.allowSuper &amp;&amp; !</span><span class="s2">this</span><span class="s1">.options.allowSuperOutsideMethod) {</span>
      <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.UnexpectedSuper, {</span>
        <span class="s1">at: node</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">10</span><span class="s1">) &amp;&amp; !</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">0</span><span class="s1">) &amp;&amp; !</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">16</span><span class="s1">)) {</span>
      <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.UnsupportedSuper, {</span>
        <span class="s1">at: node</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">return this</span><span class="s1">.finishNode(node, </span><span class="s0">&quot;Super&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">parsePrivateName() {</span>
    <span class="s1">const node = </span><span class="s2">this</span><span class="s1">.startNode();</span>
    <span class="s1">const id = </span><span class="s2">this</span><span class="s1">.startNodeAt((</span><span class="s3">0</span><span class="s1">, _location.createPositionWithColumnOffset)(</span><span class="s2">this</span><span class="s1">.state.startLoc, </span><span class="s3">1</span><span class="s1">));</span>
    <span class="s1">const name = </span><span class="s2">this</span><span class="s1">.state.value;</span>
    <span class="s2">this</span><span class="s1">.next();</span>
    <span class="s1">node.id = </span><span class="s2">this</span><span class="s1">.createIdentifier(id, name);</span>
    <span class="s2">return this</span><span class="s1">.finishNode(node, </span><span class="s0">&quot;PrivateName&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">parseFunctionOrFunctionSent() {</span>
    <span class="s1">const node = </span><span class="s2">this</span><span class="s1">.startNode();</span>
    <span class="s2">this</span><span class="s1">.next();</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.prodParam.hasYield &amp;&amp; </span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">16</span><span class="s1">)) {</span>
      <span class="s1">const meta = </span><span class="s2">this</span><span class="s1">.createIdentifier(</span><span class="s2">this</span><span class="s1">.startNodeAtNode(node), </span><span class="s0">&quot;function&quot;</span><span class="s1">);</span>
      <span class="s2">this</span><span class="s1">.next();</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">102</span><span class="s1">)) {</span>
        <span class="s2">this</span><span class="s1">.expectPlugin(</span><span class="s0">&quot;functionSent&quot;</span><span class="s1">);</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.hasPlugin(</span><span class="s0">&quot;functionSent&quot;</span><span class="s1">)) {</span>
        <span class="s2">this</span><span class="s1">.unexpected();</span>
      <span class="s1">}</span>
      <span class="s2">return this</span><span class="s1">.parseMetaProperty(node, meta, </span><span class="s0">&quot;sent&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">return this</span><span class="s1">.parseFunction(node);</span>
  <span class="s1">}</span>
  <span class="s1">parseMetaProperty(node, meta, propertyName) {</span>
    <span class="s1">node.meta = meta;</span>
    <span class="s1">const containsEsc = </span><span class="s2">this</span><span class="s1">.state.containsEsc;</span>
    <span class="s1">node.property = </span><span class="s2">this</span><span class="s1">.parseIdentifier(</span><span class="s2">true</span><span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(node.property.name !== propertyName || containsEsc) {</span>
      <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.UnsupportedMetaProperty, {</span>
        <span class="s1">at: node.property,</span>
        <span class="s1">target: meta.name,</span>
        <span class="s1">onlyValidPropertyName: propertyName</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">return this</span><span class="s1">.finishNode(node, </span><span class="s0">&quot;MetaProperty&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">parseImportMetaProperty(node) {</span>
    <span class="s1">const id = </span><span class="s2">this</span><span class="s1">.createIdentifier(</span><span class="s2">this</span><span class="s1">.startNodeAtNode(node), </span><span class="s0">&quot;import&quot;</span><span class="s1">);</span>
    <span class="s2">this</span><span class="s1">.next();</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isContextual(</span><span class="s3">100</span><span class="s1">)) {</span>
      <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.inModule) {</span>
        <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.ImportMetaOutsideModule, {</span>
          <span class="s1">at: id</span>
        <span class="s1">});</span>
      <span class="s1">}</span>
      <span class="s2">this</span><span class="s1">.sawUnambiguousESM = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return this</span><span class="s1">.parseMetaProperty(node, id, </span><span class="s0">&quot;meta&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">parseLiteralAtNode(value, type, node) {</span>
    <span class="s2">this</span><span class="s1">.addExtra(node, </span><span class="s0">&quot;rawValue&quot;</span><span class="s1">, value);</span>
    <span class="s2">this</span><span class="s1">.addExtra(node, </span><span class="s0">&quot;raw&quot;</span><span class="s1">, </span><span class="s2">this</span><span class="s1">.input.slice(node.start, </span><span class="s2">this</span><span class="s1">.state.end));</span>
    <span class="s1">node.value = value;</span>
    <span class="s2">this</span><span class="s1">.next();</span>
    <span class="s2">return this</span><span class="s1">.finishNode(node, type);</span>
  <span class="s1">}</span>
  <span class="s1">parseLiteral(value, type) {</span>
    <span class="s1">const node = </span><span class="s2">this</span><span class="s1">.startNode();</span>
    <span class="s2">return this</span><span class="s1">.parseLiteralAtNode(value, type, node);</span>
  <span class="s1">}</span>
  <span class="s1">parseStringLiteral(value) {</span>
    <span class="s2">return this</span><span class="s1">.parseLiteral(value, </span><span class="s0">&quot;StringLiteral&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">parseNumericLiteral(value) {</span>
    <span class="s2">return this</span><span class="s1">.parseLiteral(value, </span><span class="s0">&quot;NumericLiteral&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">parseBigIntLiteral(value) {</span>
    <span class="s2">return this</span><span class="s1">.parseLiteral(value, </span><span class="s0">&quot;BigIntLiteral&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">parseDecimalLiteral(value) {</span>
    <span class="s2">return this</span><span class="s1">.parseLiteral(value, </span><span class="s0">&quot;DecimalLiteral&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">parseRegExpLiteral(value) {</span>
    <span class="s1">const node = </span><span class="s2">this</span><span class="s1">.parseLiteral(value.value, </span><span class="s0">&quot;RegExpLiteral&quot;</span><span class="s1">);</span>
    <span class="s1">node.pattern = value.pattern;</span>
    <span class="s1">node.flags = value.flags;</span>
    <span class="s2">return </span><span class="s1">node;</span>
  <span class="s1">}</span>
  <span class="s1">parseBooleanLiteral(value) {</span>
    <span class="s1">const node = </span><span class="s2">this</span><span class="s1">.startNode();</span>
    <span class="s1">node.value = value;</span>
    <span class="s2">this</span><span class="s1">.next();</span>
    <span class="s2">return this</span><span class="s1">.finishNode(node, </span><span class="s0">&quot;BooleanLiteral&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">parseNullLiteral() {</span>
    <span class="s1">const node = </span><span class="s2">this</span><span class="s1">.startNode();</span>
    <span class="s2">this</span><span class="s1">.next();</span>
    <span class="s2">return this</span><span class="s1">.finishNode(node, </span><span class="s0">&quot;NullLiteral&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">parseParenAndDistinguishExpression(canBeArrow) {</span>
    <span class="s1">const startLoc = </span><span class="s2">this</span><span class="s1">.state.startLoc;</span>
    <span class="s1">let val;</span>
    <span class="s2">this</span><span class="s1">.next();</span>
    <span class="s2">this</span><span class="s1">.expressionScope.enter((</span><span class="s3">0</span><span class="s1">, _expressionScope.newArrowHeadScope)());</span>
    <span class="s1">const oldMaybeInArrowParameters = </span><span class="s2">this</span><span class="s1">.state.maybeInArrowParameters;</span>
    <span class="s1">const oldInFSharpPipelineDirectBody = </span><span class="s2">this</span><span class="s1">.state.inFSharpPipelineDirectBody;</span>
    <span class="s2">this</span><span class="s1">.state.maybeInArrowParameters = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s2">this</span><span class="s1">.state.inFSharpPipelineDirectBody = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">const innerStartLoc = </span><span class="s2">this</span><span class="s1">.state.startLoc;</span>
    <span class="s1">const exprList = [];</span>
    <span class="s1">const refExpressionErrors = </span><span class="s2">new </span><span class="s1">_util.ExpressionErrors();</span>
    <span class="s1">let first = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">let spreadStartLoc;</span>
    <span class="s1">let optionalCommaStartLoc;</span>
    <span class="s2">while </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">11</span><span class="s1">)) {</span>
      <span class="s2">if </span><span class="s1">(first) {</span>
        <span class="s1">first = </span><span class="s2">false</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">this</span><span class="s1">.expect(</span><span class="s3">12</span><span class="s1">, refExpressionErrors.optionalParametersLoc === </span><span class="s2">null </span><span class="s1">? </span><span class="s2">null </span><span class="s1">: refExpressionErrors.optionalParametersLoc);</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">11</span><span class="s1">)) {</span>
          <span class="s1">optionalCommaStartLoc = </span><span class="s2">this</span><span class="s1">.state.startLoc;</span>
          <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">21</span><span class="s1">)) {</span>
        <span class="s1">const spreadNodeStartLoc = </span><span class="s2">this</span><span class="s1">.state.startLoc;</span>
        <span class="s1">spreadStartLoc = </span><span class="s2">this</span><span class="s1">.state.startLoc;</span>
        <span class="s1">exprList.push(</span><span class="s2">this</span><span class="s1">.parseParenItem(</span><span class="s2">this</span><span class="s1">.parseRestBinding(), spreadNodeStartLoc));</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.checkCommaAfterRest(</span><span class="s3">41</span><span class="s1">)) {</span>
          <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">exprList.push(</span><span class="s2">this</span><span class="s1">.parseMaybeAssignAllowIn(refExpressionErrors, </span><span class="s2">this</span><span class="s1">.parseParenItem));</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">const innerEndLoc = </span><span class="s2">this</span><span class="s1">.state.lastTokEndLoc;</span>
    <span class="s2">this</span><span class="s1">.expect(</span><span class="s3">11</span><span class="s1">);</span>
    <span class="s2">this</span><span class="s1">.state.maybeInArrowParameters = oldMaybeInArrowParameters;</span>
    <span class="s2">this</span><span class="s1">.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;</span>
    <span class="s1">let arrowNode = </span><span class="s2">this</span><span class="s1">.startNodeAt(startLoc);</span>
    <span class="s2">if </span><span class="s1">(canBeArrow &amp;&amp; </span><span class="s2">this</span><span class="s1">.shouldParseArrow(exprList) &amp;&amp; (arrowNode = </span><span class="s2">this</span><span class="s1">.parseArrow(arrowNode))) {</span>
      <span class="s2">this</span><span class="s1">.checkDestructuringPrivate(refExpressionErrors);</span>
      <span class="s2">this</span><span class="s1">.expressionScope.validateAsPattern();</span>
      <span class="s2">this</span><span class="s1">.expressionScope.exit();</span>
      <span class="s2">this</span><span class="s1">.parseArrowExpression(arrowNode, exprList, </span><span class="s2">false</span><span class="s1">);</span>
      <span class="s2">return </span><span class="s1">arrowNode;</span>
    <span class="s1">}</span>
    <span class="s2">this</span><span class="s1">.expressionScope.exit();</span>
    <span class="s2">if </span><span class="s1">(!exprList.length) {</span>
      <span class="s2">this</span><span class="s1">.unexpected(</span><span class="s2">this</span><span class="s1">.state.lastTokStartLoc);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(optionalCommaStartLoc) </span><span class="s2">this</span><span class="s1">.unexpected(optionalCommaStartLoc);</span>
    <span class="s2">if </span><span class="s1">(spreadStartLoc) </span><span class="s2">this</span><span class="s1">.unexpected(spreadStartLoc);</span>
    <span class="s2">this</span><span class="s1">.checkExpressionErrors(refExpressionErrors, </span><span class="s2">true</span><span class="s1">);</span>
    <span class="s2">this</span><span class="s1">.toReferencedListDeep(exprList, </span><span class="s2">true</span><span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(exprList.length &gt; </span><span class="s3">1</span><span class="s1">) {</span>
      <span class="s1">val = </span><span class="s2">this</span><span class="s1">.startNodeAt(innerStartLoc);</span>
      <span class="s1">val.expressions = exprList;</span>
      <span class="s2">this</span><span class="s1">.finishNode(val, </span><span class="s0">&quot;SequenceExpression&quot;</span><span class="s1">);</span>
      <span class="s2">this</span><span class="s1">.resetEndLocation(val, innerEndLoc);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">val = exprList[</span><span class="s3">0</span><span class="s1">];</span>
    <span class="s1">}</span>
    <span class="s2">return this</span><span class="s1">.wrapParenthesis(startLoc, val);</span>
  <span class="s1">}</span>
  <span class="s1">wrapParenthesis(startLoc, expression) {</span>
    <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.options.createParenthesizedExpressions) {</span>
      <span class="s2">this</span><span class="s1">.addExtra(expression, </span><span class="s0">&quot;parenthesized&quot;</span><span class="s1">, </span><span class="s2">true</span><span class="s1">);</span>
      <span class="s2">this</span><span class="s1">.addExtra(expression, </span><span class="s0">&quot;parenStart&quot;</span><span class="s1">, startLoc.index);</span>
      <span class="s2">this</span><span class="s1">.takeSurroundingComments(expression, startLoc.index, </span><span class="s2">this</span><span class="s1">.state.lastTokEndLoc.index);</span>
      <span class="s2">return </span><span class="s1">expression;</span>
    <span class="s1">}</span>
    <span class="s1">const parenExpression = </span><span class="s2">this</span><span class="s1">.startNodeAt(startLoc);</span>
    <span class="s1">parenExpression.expression = expression;</span>
    <span class="s2">return this</span><span class="s1">.finishNode(parenExpression, </span><span class="s0">&quot;ParenthesizedExpression&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">shouldParseArrow(params) {</span>
    <span class="s2">return </span><span class="s1">!</span><span class="s2">this</span><span class="s1">.canInsertSemicolon();</span>
  <span class="s1">}</span>
  <span class="s1">parseArrow(node) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.eat(</span><span class="s3">19</span><span class="s1">)) {</span>
      <span class="s2">return </span><span class="s1">node;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">parseParenItem(node, startLoc) {</span>
    <span class="s2">return </span><span class="s1">node;</span>
  <span class="s1">}</span>
  <span class="s1">parseNewOrNewTarget() {</span>
    <span class="s1">const node = </span><span class="s2">this</span><span class="s1">.startNode();</span>
    <span class="s2">this</span><span class="s1">.next();</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">16</span><span class="s1">)) {</span>
      <span class="s1">const meta = </span><span class="s2">this</span><span class="s1">.createIdentifier(</span><span class="s2">this</span><span class="s1">.startNodeAtNode(node), </span><span class="s0">&quot;new&quot;</span><span class="s1">);</span>
      <span class="s2">this</span><span class="s1">.next();</span>
      <span class="s1">const metaProp = </span><span class="s2">this</span><span class="s1">.parseMetaProperty(node, meta, </span><span class="s0">&quot;target&quot;</span><span class="s1">);</span>
      <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.scope.inNonArrowFunction &amp;&amp; !</span><span class="s2">this</span><span class="s1">.scope.inClass &amp;&amp; !</span><span class="s2">this</span><span class="s1">.options.allowNewTargetOutsideFunction) {</span>
        <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.UnexpectedNewTarget, {</span>
          <span class="s1">at: metaProp</span>
        <span class="s1">});</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">metaProp;</span>
    <span class="s1">}</span>
    <span class="s2">return this</span><span class="s1">.parseNew(node);</span>
  <span class="s1">}</span>
  <span class="s1">parseNew(node) {</span>
    <span class="s2">this</span><span class="s1">.parseNewCallee(node);</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.eat(</span><span class="s3">10</span><span class="s1">)) {</span>
      <span class="s1">const args = </span><span class="s2">this</span><span class="s1">.parseExprList(</span><span class="s3">11</span><span class="s1">);</span>
      <span class="s2">this</span><span class="s1">.toReferencedList(args);</span>
      <span class="s1">node.arguments = args;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">node.arguments = [];</span>
    <span class="s1">}</span>
    <span class="s2">return this</span><span class="s1">.finishNode(node, </span><span class="s0">&quot;NewExpression&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">parseNewCallee(node) {</span>
    <span class="s1">node.callee = </span><span class="s2">this</span><span class="s1">.parseNoCallExpr();</span>
    <span class="s2">if </span><span class="s1">(node.callee.type === </span><span class="s0">&quot;Import&quot;</span><span class="s1">) {</span>
      <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.ImportCallNotNewExpression, {</span>
        <span class="s1">at: node.callee</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">parseTemplateElement(isTagged) {</span>
    <span class="s1">const {</span>
      <span class="s1">start,</span>
      <span class="s1">startLoc,</span>
      <span class="s1">end,</span>
      <span class="s1">value</span>
    <span class="s1">} = </span><span class="s2">this</span><span class="s1">.state;</span>
    <span class="s1">const elemStart = start + </span><span class="s3">1</span><span class="s1">;</span>
    <span class="s1">const elem = </span><span class="s2">this</span><span class="s1">.startNodeAt((</span><span class="s3">0</span><span class="s1">, _location.createPositionWithColumnOffset)(startLoc, </span><span class="s3">1</span><span class="s1">));</span>
    <span class="s2">if </span><span class="s1">(value === </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(!isTagged) {</span>
        <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.InvalidEscapeSequenceTemplate, {</span>
          <span class="s1">at: (</span><span class="s3">0</span><span class="s1">, _location.createPositionWithColumnOffset)(</span><span class="s2">this</span><span class="s1">.state.firstInvalidTemplateEscapePos, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">});</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">const isTail = </span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">24</span><span class="s1">);</span>
    <span class="s1">const endOffset = isTail ? -</span><span class="s3">1 </span><span class="s1">: -</span><span class="s3">2</span><span class="s1">;</span>
    <span class="s1">const elemEnd = end + endOffset;</span>
    <span class="s1">elem.value = {</span>
      <span class="s1">raw: </span><span class="s2">this</span><span class="s1">.input.slice(elemStart, elemEnd).replace(/\r\n?/g, </span><span class="s0">&quot;</span><span class="s4">\n</span><span class="s0">&quot;</span><span class="s1">),</span>
      <span class="s1">cooked: value === </span><span class="s2">null </span><span class="s1">? </span><span class="s2">null </span><span class="s1">: value.slice(</span><span class="s3">1</span><span class="s1">, endOffset)</span>
    <span class="s1">};</span>
    <span class="s1">elem.tail = isTail;</span>
    <span class="s2">this</span><span class="s1">.next();</span>
    <span class="s1">const finishedNode = </span><span class="s2">this</span><span class="s1">.finishNode(elem, </span><span class="s0">&quot;TemplateElement&quot;</span><span class="s1">);</span>
    <span class="s2">this</span><span class="s1">.resetEndLocation(finishedNode, (</span><span class="s3">0</span><span class="s1">, _location.createPositionWithColumnOffset)(</span><span class="s2">this</span><span class="s1">.state.lastTokEndLoc, endOffset));</span>
    <span class="s2">return </span><span class="s1">finishedNode;</span>
  <span class="s1">}</span>
  <span class="s1">parseTemplate(isTagged) {</span>
    <span class="s1">const node = </span><span class="s2">this</span><span class="s1">.startNode();</span>
    <span class="s1">node.expressions = [];</span>
    <span class="s1">let curElt = </span><span class="s2">this</span><span class="s1">.parseTemplateElement(isTagged);</span>
    <span class="s1">node.quasis = [curElt];</span>
    <span class="s2">while </span><span class="s1">(!curElt.tail) {</span>
      <span class="s1">node.expressions.push(</span><span class="s2">this</span><span class="s1">.parseTemplateSubstitution());</span>
      <span class="s2">this</span><span class="s1">.readTemplateContinuation();</span>
      <span class="s1">node.quasis.push(curElt = </span><span class="s2">this</span><span class="s1">.parseTemplateElement(isTagged));</span>
    <span class="s1">}</span>
    <span class="s2">return this</span><span class="s1">.finishNode(node, </span><span class="s0">&quot;TemplateLiteral&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">parseTemplateSubstitution() {</span>
    <span class="s2">return this</span><span class="s1">.parseExpression();</span>
  <span class="s1">}</span>
  <span class="s1">parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {</span>
    <span class="s2">if </span><span class="s1">(isRecord) {</span>
      <span class="s2">this</span><span class="s1">.expectPlugin(</span><span class="s0">&quot;recordAndTuple&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">const oldInFSharpPipelineDirectBody = </span><span class="s2">this</span><span class="s1">.state.inFSharpPipelineDirectBody;</span>
    <span class="s2">this</span><span class="s1">.state.inFSharpPipelineDirectBody = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">const propHash = Object.create(</span><span class="s2">null</span><span class="s1">);</span>
    <span class="s1">let first = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">const node = </span><span class="s2">this</span><span class="s1">.startNode();</span>
    <span class="s1">node.properties = [];</span>
    <span class="s2">this</span><span class="s1">.next();</span>
    <span class="s2">while </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.match(close)) {</span>
      <span class="s2">if </span><span class="s1">(first) {</span>
        <span class="s1">first = </span><span class="s2">false</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">this</span><span class="s1">.expect(</span><span class="s3">12</span><span class="s1">);</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.match(close)) {</span>
          <span class="s2">this</span><span class="s1">.addTrailingCommaExtraToNode(node);</span>
          <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s1">let prop;</span>
      <span class="s2">if </span><span class="s1">(isPattern) {</span>
        <span class="s1">prop = </span><span class="s2">this</span><span class="s1">.parseBindingProperty();</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">prop = </span><span class="s2">this</span><span class="s1">.parsePropertyDefinition(refExpressionErrors);</span>
        <span class="s2">this</span><span class="s1">.checkProto(prop, isRecord, propHash, refExpressionErrors);</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(isRecord &amp;&amp; !</span><span class="s2">this</span><span class="s1">.isObjectProperty(prop) &amp;&amp; prop.type !== </span><span class="s0">&quot;SpreadElement&quot;</span><span class="s1">) {</span>
        <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.InvalidRecordProperty, {</span>
          <span class="s1">at: prop</span>
        <span class="s1">});</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(prop.shorthand) {</span>
        <span class="s2">this</span><span class="s1">.addExtra(prop, </span><span class="s0">&quot;shorthand&quot;</span><span class="s1">, </span><span class="s2">true</span><span class="s1">);</span>
      <span class="s1">}</span>
      <span class="s1">node.properties.push(prop);</span>
    <span class="s1">}</span>
    <span class="s2">this</span><span class="s1">.next();</span>
    <span class="s2">this</span><span class="s1">.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;</span>
    <span class="s1">let type = </span><span class="s0">&quot;ObjectExpression&quot;</span><span class="s1">;</span>
    <span class="s2">if </span><span class="s1">(isPattern) {</span>
      <span class="s1">type = </span><span class="s0">&quot;ObjectPattern&quot;</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isRecord) {</span>
      <span class="s1">type = </span><span class="s0">&quot;RecordExpression&quot;</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return this</span><span class="s1">.finishNode(node, type);</span>
  <span class="s1">}</span>
  <span class="s1">addTrailingCommaExtraToNode(node) {</span>
    <span class="s2">this</span><span class="s1">.addExtra(node, </span><span class="s0">&quot;trailingComma&quot;</span><span class="s1">, </span><span class="s2">this</span><span class="s1">.state.lastTokStart);</span>
    <span class="s2">this</span><span class="s1">.addExtra(node, </span><span class="s0">&quot;trailingCommaLoc&quot;</span><span class="s1">, </span><span class="s2">this</span><span class="s1">.state.lastTokStartLoc, </span><span class="s2">false</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">maybeAsyncOrAccessorProp(prop) {</span>
    <span class="s2">return </span><span class="s1">!prop.computed &amp;&amp; prop.key.type === </span><span class="s0">&quot;Identifier&quot; </span><span class="s1">&amp;&amp; (</span><span class="s2">this</span><span class="s1">.isLiteralPropertyName() || </span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">0</span><span class="s1">) || </span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">55</span><span class="s1">));</span>
  <span class="s1">}</span>
  <span class="s1">parsePropertyDefinition(refExpressionErrors) {</span>
    <span class="s1">let decorators = [];</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">26</span><span class="s1">)) {</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.hasPlugin(</span><span class="s0">&quot;decorators&quot;</span><span class="s1">)) {</span>
        <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.UnsupportedPropertyDecorator, {</span>
          <span class="s1">at: </span><span class="s2">this</span><span class="s1">.state.startLoc</span>
        <span class="s1">});</span>
      <span class="s1">}</span>
      <span class="s2">while </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">26</span><span class="s1">)) {</span>
        <span class="s1">decorators.push(</span><span class="s2">this</span><span class="s1">.parseDecorator());</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">const prop = </span><span class="s2">this</span><span class="s1">.startNode();</span>
    <span class="s1">let isAsync = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">let isAccessor = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">let startLoc;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">21</span><span class="s1">)) {</span>
      <span class="s2">if </span><span class="s1">(decorators.length) </span><span class="s2">this</span><span class="s1">.unexpected();</span>
      <span class="s2">return this</span><span class="s1">.parseSpread();</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(decorators.length) {</span>
      <span class="s1">prop.decorators = decorators;</span>
      <span class="s1">decorators = [];</span>
    <span class="s1">}</span>
    <span class="s1">prop.method = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s2">if </span><span class="s1">(refExpressionErrors) {</span>
      <span class="s1">startLoc = </span><span class="s2">this</span><span class="s1">.state.startLoc;</span>
    <span class="s1">}</span>
    <span class="s1">let isGenerator = </span><span class="s2">this</span><span class="s1">.eat(</span><span class="s3">55</span><span class="s1">);</span>
    <span class="s2">this</span><span class="s1">.parsePropertyNamePrefixOperator(prop);</span>
    <span class="s1">const containsEsc = </span><span class="s2">this</span><span class="s1">.state.containsEsc;</span>
    <span class="s1">const key = </span><span class="s2">this</span><span class="s1">.parsePropertyName(prop, refExpressionErrors);</span>
    <span class="s2">if </span><span class="s1">(!isGenerator &amp;&amp; !containsEsc &amp;&amp; </span><span class="s2">this</span><span class="s1">.maybeAsyncOrAccessorProp(prop)) {</span>
      <span class="s1">const keyName = key.name;</span>
      <span class="s2">if </span><span class="s1">(keyName === </span><span class="s0">&quot;async&quot; </span><span class="s1">&amp;&amp; !</span><span class="s2">this</span><span class="s1">.hasPrecedingLineBreak()) {</span>
        <span class="s1">isAsync = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">.resetPreviousNodeTrailingComments(key);</span>
        <span class="s1">isGenerator = </span><span class="s2">this</span><span class="s1">.eat(</span><span class="s3">55</span><span class="s1">);</span>
        <span class="s2">this</span><span class="s1">.parsePropertyName(prop);</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(keyName === </span><span class="s0">&quot;get&quot; </span><span class="s1">|| keyName === </span><span class="s0">&quot;set&quot;</span><span class="s1">) {</span>
        <span class="s1">isAccessor = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">.resetPreviousNodeTrailingComments(key);</span>
        <span class="s1">prop.kind = keyName;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">55</span><span class="s1">)) {</span>
          <span class="s1">isGenerator = </span><span class="s2">true</span><span class="s1">;</span>
          <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.AccessorIsGenerator, {</span>
            <span class="s1">at: </span><span class="s2">this</span><span class="s1">.state.curPosition(),</span>
            <span class="s1">kind: keyName</span>
          <span class="s1">});</span>
          <span class="s2">this</span><span class="s1">.next();</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.parsePropertyName(prop);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return this</span><span class="s1">.parseObjPropValue(prop, startLoc, isGenerator, isAsync, </span><span class="s2">false</span><span class="s1">, isAccessor, refExpressionErrors);</span>
  <span class="s1">}</span>
  <span class="s1">getGetterSetterExpectedParamCount(method) {</span>
    <span class="s2">return </span><span class="s1">method.kind === </span><span class="s0">&quot;get&quot; </span><span class="s1">? </span><span class="s3">0 </span><span class="s1">: </span><span class="s3">1</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s1">getObjectOrClassMethodParams(method) {</span>
    <span class="s2">return </span><span class="s1">method.params;</span>
  <span class="s1">}</span>
  <span class="s1">checkGetterSetterParams(method) {</span>
    <span class="s2">var </span><span class="s1">_params;</span>
    <span class="s1">const paramCount = </span><span class="s2">this</span><span class="s1">.getGetterSetterExpectedParamCount(method);</span>
    <span class="s1">const params = </span><span class="s2">this</span><span class="s1">.getObjectOrClassMethodParams(method);</span>
    <span class="s2">if </span><span class="s1">(params.length !== paramCount) {</span>
      <span class="s2">this</span><span class="s1">.raise(method.kind === </span><span class="s0">&quot;get&quot; </span><span class="s1">? _parseError.Errors.BadGetterArity : _parseError.Errors.BadSetterArity, {</span>
        <span class="s1">at: method</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(method.kind === </span><span class="s0">&quot;set&quot; </span><span class="s1">&amp;&amp; ((_params = params[params.length - </span><span class="s3">1</span><span class="s1">]) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _params.type) === </span><span class="s0">&quot;RestElement&quot;</span><span class="s1">) {</span>
      <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.BadSetterRestParameter, {</span>
        <span class="s1">at: method</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {</span>
    <span class="s2">if </span><span class="s1">(isAccessor) {</span>
      <span class="s1">const finishedProp = </span><span class="s2">this</span><span class="s1">.parseMethod(prop, isGenerator, </span><span class="s2">false</span><span class="s1">, </span><span class="s2">false</span><span class="s1">, </span><span class="s2">false</span><span class="s1">, </span><span class="s0">&quot;ObjectMethod&quot;</span><span class="s1">);</span>
      <span class="s2">this</span><span class="s1">.checkGetterSetterParams(finishedProp);</span>
      <span class="s2">return </span><span class="s1">finishedProp;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(isAsync || isGenerator || </span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">10</span><span class="s1">)) {</span>
      <span class="s2">if </span><span class="s1">(isPattern) </span><span class="s2">this</span><span class="s1">.unexpected();</span>
      <span class="s1">prop.kind = </span><span class="s0">&quot;method&quot;</span><span class="s1">;</span>
      <span class="s1">prop.method = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s2">return this</span><span class="s1">.parseMethod(prop, isGenerator, isAsync, </span><span class="s2">false</span><span class="s1">, </span><span class="s2">false</span><span class="s1">, </span><span class="s0">&quot;ObjectMethod&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {</span>
    <span class="s1">prop.shorthand = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.eat(</span><span class="s3">14</span><span class="s1">)) {</span>
      <span class="s1">prop.value = isPattern ? </span><span class="s2">this</span><span class="s1">.parseMaybeDefault(</span><span class="s2">this</span><span class="s1">.state.startLoc) : </span><span class="s2">this</span><span class="s1">.parseMaybeAssignAllowIn(refExpressionErrors);</span>
      <span class="s2">return this</span><span class="s1">.finishNode(prop, </span><span class="s0">&quot;ObjectProperty&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!prop.computed &amp;&amp; prop.key.type === </span><span class="s0">&quot;Identifier&quot;</span><span class="s1">) {</span>
      <span class="s2">this</span><span class="s1">.checkReservedWord(prop.key.name, prop.key.loc.start, </span><span class="s2">true</span><span class="s1">, </span><span class="s2">false</span><span class="s1">);</span>
      <span class="s2">if </span><span class="s1">(isPattern) {</span>
        <span class="s1">prop.value = </span><span class="s2">this</span><span class="s1">.parseMaybeDefault(startLoc, (</span><span class="s3">0</span><span class="s1">, _node.cloneIdentifier)(prop.key));</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">29</span><span class="s1">)) {</span>
        <span class="s1">const shorthandAssignLoc = </span><span class="s2">this</span><span class="s1">.state.startLoc;</span>
        <span class="s2">if </span><span class="s1">(refExpressionErrors != </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s2">if </span><span class="s1">(refExpressionErrors.shorthandAssignLoc === </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc;</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.InvalidCoverInitializedName, {</span>
            <span class="s1">at: shorthandAssignLoc</span>
          <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s1">prop.value = </span><span class="s2">this</span><span class="s1">.parseMaybeDefault(startLoc, (</span><span class="s3">0</span><span class="s1">, _node.cloneIdentifier)(prop.key));</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">prop.value = (</span><span class="s3">0</span><span class="s1">, _node.cloneIdentifier)(prop.key);</span>
      <span class="s1">}</span>
      <span class="s1">prop.shorthand = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s2">return this</span><span class="s1">.finishNode(prop, </span><span class="s0">&quot;ObjectProperty&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {</span>
    <span class="s1">const node = </span><span class="s2">this</span><span class="s1">.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || </span><span class="s2">this</span><span class="s1">.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);</span>
    <span class="s2">if </span><span class="s1">(!node) </span><span class="s2">this</span><span class="s1">.unexpected();</span>
    <span class="s2">return </span><span class="s1">node;</span>
  <span class="s1">}</span>
  <span class="s1">parsePropertyName(prop, refExpressionErrors) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.eat(</span><span class="s3">0</span><span class="s1">)) {</span>
      <span class="s1">prop.computed = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s1">prop.key = </span><span class="s2">this</span><span class="s1">.parseMaybeAssignAllowIn();</span>
      <span class="s2">this</span><span class="s1">.expect(</span><span class="s3">3</span><span class="s1">);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">const {</span>
        <span class="s1">type,</span>
        <span class="s1">value</span>
      <span class="s1">} = </span><span class="s2">this</span><span class="s1">.state;</span>
      <span class="s1">let key;</span>
      <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _types.tokenIsKeywordOrIdentifier)(type)) {</span>
        <span class="s1">key = </span><span class="s2">this</span><span class="s1">.parseIdentifier(</span><span class="s2">true</span><span class="s1">);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">switch </span><span class="s1">(type) {</span>
          <span class="s2">case </span><span class="s3">132</span><span class="s1">:</span>
            <span class="s1">key = </span><span class="s2">this</span><span class="s1">.parseNumericLiteral(value);</span>
            <span class="s2">break</span><span class="s1">;</span>
          <span class="s2">case </span><span class="s3">131</span><span class="s1">:</span>
            <span class="s1">key = </span><span class="s2">this</span><span class="s1">.parseStringLiteral(value);</span>
            <span class="s2">break</span><span class="s1">;</span>
          <span class="s2">case </span><span class="s3">133</span><span class="s1">:</span>
            <span class="s1">key = </span><span class="s2">this</span><span class="s1">.parseBigIntLiteral(value);</span>
            <span class="s2">break</span><span class="s1">;</span>
          <span class="s2">case </span><span class="s3">134</span><span class="s1">:</span>
            <span class="s1">key = </span><span class="s2">this</span><span class="s1">.parseDecimalLiteral(value);</span>
            <span class="s2">break</span><span class="s1">;</span>
          <span class="s2">case </span><span class="s3">136</span><span class="s1">:</span>
            <span class="s1">{</span>
              <span class="s1">const privateKeyLoc = </span><span class="s2">this</span><span class="s1">.state.startLoc;</span>
              <span class="s2">if </span><span class="s1">(refExpressionErrors != </span><span class="s2">null</span><span class="s1">) {</span>
                <span class="s2">if </span><span class="s1">(refExpressionErrors.privateKeyLoc === </span><span class="s2">null</span><span class="s1">) {</span>
                  <span class="s1">refExpressionErrors.privateKeyLoc = privateKeyLoc;</span>
                <span class="s1">}</span>
              <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.UnexpectedPrivateField, {</span>
                  <span class="s1">at: privateKeyLoc</span>
                <span class="s1">});</span>
              <span class="s1">}</span>
              <span class="s1">key = </span><span class="s2">this</span><span class="s1">.parsePrivateName();</span>
              <span class="s2">break</span><span class="s1">;</span>
            <span class="s1">}</span>
          <span class="s2">default</span><span class="s1">:</span>
            <span class="s2">this</span><span class="s1">.unexpected();</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s1">prop.key = key;</span>
      <span class="s2">if </span><span class="s1">(type !== </span><span class="s3">136</span><span class="s1">) {</span>
        <span class="s1">prop.computed = </span><span class="s2">false</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">prop.key;</span>
  <span class="s1">}</span>
  <span class="s1">initFunction(node, isAsync) {</span>
    <span class="s1">node.id = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">node.generator = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">node.async = isAsync;</span>
  <span class="s1">}</span>
  <span class="s1">parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = </span><span class="s2">false</span><span class="s1">) {</span>
    <span class="s2">this</span><span class="s1">.initFunction(node, isAsync);</span>
    <span class="s1">node.generator = isGenerator;</span>
    <span class="s2">this</span><span class="s1">.scope.enter(_scopeflags.SCOPE_FUNCTION | _scopeflags.SCOPE_SUPER | (inClassScope ? _scopeflags.SCOPE_CLASS : </span><span class="s3">0</span><span class="s1">) | (allowDirectSuper ? _scopeflags.SCOPE_DIRECT_SUPER : </span><span class="s3">0</span><span class="s1">));</span>
    <span class="s2">this</span><span class="s1">.prodParam.enter((</span><span class="s3">0</span><span class="s1">, _productionParameter.functionFlags)(isAsync, node.generator));</span>
    <span class="s2">this</span><span class="s1">.parseFunctionParams(node, isConstructor);</span>
    <span class="s1">const finishedNode = </span><span class="s2">this</span><span class="s1">.parseFunctionBodyAndFinish(node, type, </span><span class="s2">true</span><span class="s1">);</span>
    <span class="s2">this</span><span class="s1">.prodParam.exit();</span>
    <span class="s2">this</span><span class="s1">.scope.exit();</span>
    <span class="s2">return </span><span class="s1">finishedNode;</span>
  <span class="s1">}</span>
  <span class="s1">parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {</span>
    <span class="s2">if </span><span class="s1">(isTuple) {</span>
      <span class="s2">this</span><span class="s1">.expectPlugin(</span><span class="s0">&quot;recordAndTuple&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">const oldInFSharpPipelineDirectBody = </span><span class="s2">this</span><span class="s1">.state.inFSharpPipelineDirectBody;</span>
    <span class="s2">this</span><span class="s1">.state.inFSharpPipelineDirectBody = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">const node = </span><span class="s2">this</span><span class="s1">.startNode();</span>
    <span class="s2">this</span><span class="s1">.next();</span>
    <span class="s1">node.elements = </span><span class="s2">this</span><span class="s1">.parseExprList(close, !isTuple, refExpressionErrors, node);</span>
    <span class="s2">this</span><span class="s1">.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;</span>
    <span class="s2">return this</span><span class="s1">.finishNode(node, isTuple ? </span><span class="s0">&quot;TupleExpression&quot; </span><span class="s1">: </span><span class="s0">&quot;ArrayExpression&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">parseArrowExpression(node, params, isAsync, trailingCommaLoc) {</span>
    <span class="s2">this</span><span class="s1">.scope.enter(_scopeflags.SCOPE_FUNCTION | _scopeflags.SCOPE_ARROW);</span>
    <span class="s1">let flags = (</span><span class="s3">0</span><span class="s1">, _productionParameter.functionFlags)(isAsync, </span><span class="s2">false</span><span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">5</span><span class="s1">) &amp;&amp; </span><span class="s2">this</span><span class="s1">.prodParam.hasIn) {</span>
      <span class="s1">flags |= _productionParameter.PARAM_IN;</span>
    <span class="s1">}</span>
    <span class="s2">this</span><span class="s1">.prodParam.enter(flags);</span>
    <span class="s2">this</span><span class="s1">.initFunction(node, isAsync);</span>
    <span class="s1">const oldMaybeInArrowParameters = </span><span class="s2">this</span><span class="s1">.state.maybeInArrowParameters;</span>
    <span class="s2">if </span><span class="s1">(params) {</span>
      <span class="s2">this</span><span class="s1">.state.maybeInArrowParameters = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s2">this</span><span class="s1">.setArrowFunctionParameters(node, params, trailingCommaLoc);</span>
    <span class="s1">}</span>
    <span class="s2">this</span><span class="s1">.state.maybeInArrowParameters = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s2">this</span><span class="s1">.parseFunctionBody(node, </span><span class="s2">true</span><span class="s1">);</span>
    <span class="s2">this</span><span class="s1">.prodParam.exit();</span>
    <span class="s2">this</span><span class="s1">.scope.exit();</span>
    <span class="s2">this</span><span class="s1">.state.maybeInArrowParameters = oldMaybeInArrowParameters;</span>
    <span class="s2">return this</span><span class="s1">.finishNode(node, </span><span class="s0">&quot;ArrowFunctionExpression&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">setArrowFunctionParameters(node, params, trailingCommaLoc) {</span>
    <span class="s2">this</span><span class="s1">.toAssignableList(params, trailingCommaLoc, </span><span class="s2">false</span><span class="s1">);</span>
    <span class="s1">node.params = params;</span>
  <span class="s1">}</span>
  <span class="s1">parseFunctionBodyAndFinish(node, type, isMethod = </span><span class="s2">false</span><span class="s1">) {</span>
    <span class="s2">this</span><span class="s1">.parseFunctionBody(node, </span><span class="s2">false</span><span class="s1">, isMethod);</span>
    <span class="s2">return this</span><span class="s1">.finishNode(node, type);</span>
  <span class="s1">}</span>
  <span class="s1">parseFunctionBody(node, allowExpression, isMethod = </span><span class="s2">false</span><span class="s1">) {</span>
    <span class="s1">const isExpression = allowExpression &amp;&amp; !</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">5</span><span class="s1">);</span>
    <span class="s2">this</span><span class="s1">.expressionScope.enter((</span><span class="s3">0</span><span class="s1">, _expressionScope.newExpressionScope)());</span>
    <span class="s2">if </span><span class="s1">(isExpression) {</span>
      <span class="s1">node.body = </span><span class="s2">this</span><span class="s1">.parseMaybeAssign();</span>
      <span class="s2">this</span><span class="s1">.checkParams(node, </span><span class="s2">false</span><span class="s1">, allowExpression, </span><span class="s2">false</span><span class="s1">);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">const oldStrict = </span><span class="s2">this</span><span class="s1">.state.strict;</span>
      <span class="s1">const oldLabels = </span><span class="s2">this</span><span class="s1">.state.labels;</span>
      <span class="s2">this</span><span class="s1">.state.labels = [];</span>
      <span class="s2">this</span><span class="s1">.prodParam.enter(</span><span class="s2">this</span><span class="s1">.prodParam.currentFlags() | _productionParameter.PARAM_RETURN);</span>
      <span class="s1">node.body = </span><span class="s2">this</span><span class="s1">.parseBlock(</span><span class="s2">true</span><span class="s1">, </span><span class="s2">false</span><span class="s1">, hasStrictModeDirective =&gt; {</span>
        <span class="s1">const nonSimple = !</span><span class="s2">this</span><span class="s1">.isSimpleParamList(node.params);</span>
        <span class="s2">if </span><span class="s1">(hasStrictModeDirective &amp;&amp; nonSimple) {</span>
          <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.IllegalLanguageModeDirective, {</span>
            <span class="s1">at: (node.kind === </span><span class="s0">&quot;method&quot; </span><span class="s1">|| node.kind === </span><span class="s0">&quot;constructor&quot;</span><span class="s1">) &amp;&amp; !!node.key ? node.key.loc.end : node</span>
          <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s1">const strictModeChanged = !oldStrict &amp;&amp; </span><span class="s2">this</span><span class="s1">.state.strict;</span>
        <span class="s2">this</span><span class="s1">.checkParams(node, !</span><span class="s2">this</span><span class="s1">.state.strict &amp;&amp; !allowExpression &amp;&amp; !isMethod &amp;&amp; !nonSimple, allowExpression, strictModeChanged);</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.state.strict &amp;&amp; node.id) {</span>
          <span class="s2">this</span><span class="s1">.checkIdentifier(node.id, _scopeflags.BIND_OUTSIDE, strictModeChanged);</span>
        <span class="s1">}</span>
      <span class="s1">});</span>
      <span class="s2">this</span><span class="s1">.prodParam.exit();</span>
      <span class="s2">this</span><span class="s1">.state.labels = oldLabels;</span>
    <span class="s1">}</span>
    <span class="s2">this</span><span class="s1">.expressionScope.exit();</span>
  <span class="s1">}</span>
  <span class="s1">isSimpleParameter(node) {</span>
    <span class="s2">return </span><span class="s1">node.type === </span><span class="s0">&quot;Identifier&quot;</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s1">isSimpleParamList(params) {</span>
    <span class="s2">for </span><span class="s1">(let i = </span><span class="s3">0</span><span class="s1">, len = params.length; i &lt; len; i++) {</span>
      <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.isSimpleParameter(params[i])) </span><span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return true</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s1">checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = </span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s1">const checkClashes = !allowDuplicates &amp;&amp; </span><span class="s2">new </span><span class="s1">Set();</span>
    <span class="s1">const formalParameters = {</span>
      <span class="s1">type: </span><span class="s0">&quot;FormalParameters&quot;</span>
    <span class="s1">};</span>
    <span class="s2">for </span><span class="s1">(const param of node.params) {</span>
      <span class="s2">this</span><span class="s1">.checkLVal(param, {</span>
        <span class="s2">in</span><span class="s1">: formalParameters,</span>
        <span class="s1">binding: _scopeflags.BIND_VAR,</span>
        <span class="s1">checkClashes,</span>
        <span class="s1">strictModeChanged</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {</span>
    <span class="s1">const elts = [];</span>
    <span class="s1">let first = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s2">while </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.eat(close)) {</span>
      <span class="s2">if </span><span class="s1">(first) {</span>
        <span class="s1">first = </span><span class="s2">false</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">this</span><span class="s1">.expect(</span><span class="s3">12</span><span class="s1">);</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.match(close)) {</span>
          <span class="s2">if </span><span class="s1">(nodeForExtra) {</span>
            <span class="s2">this</span><span class="s1">.addTrailingCommaExtraToNode(nodeForExtra);</span>
          <span class="s1">}</span>
          <span class="s2">this</span><span class="s1">.next();</span>
          <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s1">elts.push(</span><span class="s2">this</span><span class="s1">.parseExprListItem(allowEmpty, refExpressionErrors));</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">elts;</span>
  <span class="s1">}</span>
  <span class="s1">parseExprListItem(allowEmpty, refExpressionErrors, allowPlaceholder) {</span>
    <span class="s1">let elt;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">12</span><span class="s1">)) {</span>
      <span class="s2">if </span><span class="s1">(!allowEmpty) {</span>
        <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.UnexpectedToken, {</span>
          <span class="s1">at: </span><span class="s2">this</span><span class="s1">.state.curPosition(),</span>
          <span class="s1">unexpected: </span><span class="s0">&quot;,&quot;</span>
        <span class="s1">});</span>
      <span class="s1">}</span>
      <span class="s1">elt = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">21</span><span class="s1">)) {</span>
      <span class="s1">const spreadNodeStartLoc = </span><span class="s2">this</span><span class="s1">.state.startLoc;</span>
      <span class="s1">elt = </span><span class="s2">this</span><span class="s1">.parseParenItem(</span><span class="s2">this</span><span class="s1">.parseSpread(refExpressionErrors), spreadNodeStartLoc);</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">17</span><span class="s1">)) {</span>
      <span class="s2">this</span><span class="s1">.expectPlugin(</span><span class="s0">&quot;partialApplication&quot;</span><span class="s1">);</span>
      <span class="s2">if </span><span class="s1">(!allowPlaceholder) {</span>
        <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.UnexpectedArgumentPlaceholder, {</span>
          <span class="s1">at: </span><span class="s2">this</span><span class="s1">.state.startLoc</span>
        <span class="s1">});</span>
      <span class="s1">}</span>
      <span class="s1">const node = </span><span class="s2">this</span><span class="s1">.startNode();</span>
      <span class="s2">this</span><span class="s1">.next();</span>
      <span class="s1">elt = </span><span class="s2">this</span><span class="s1">.finishNode(node, </span><span class="s0">&quot;ArgumentPlaceholder&quot;</span><span class="s1">);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">elt = </span><span class="s2">this</span><span class="s1">.parseMaybeAssignAllowIn(refExpressionErrors, </span><span class="s2">this</span><span class="s1">.parseParenItem);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">elt;</span>
  <span class="s1">}</span>
  <span class="s1">parseIdentifier(liberal) {</span>
    <span class="s1">const node = </span><span class="s2">this</span><span class="s1">.startNode();</span>
    <span class="s1">const name = </span><span class="s2">this</span><span class="s1">.parseIdentifierName(liberal);</span>
    <span class="s2">return this</span><span class="s1">.createIdentifier(node, name);</span>
  <span class="s1">}</span>
  <span class="s1">createIdentifier(node, name) {</span>
    <span class="s1">node.name = name;</span>
    <span class="s1">node.loc.identifierName = name;</span>
    <span class="s2">return this</span><span class="s1">.finishNode(node, </span><span class="s0">&quot;Identifier&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">parseIdentifierName(liberal) {</span>
    <span class="s1">let name;</span>
    <span class="s1">const {</span>
      <span class="s1">startLoc,</span>
      <span class="s1">type</span>
    <span class="s1">} = </span><span class="s2">this</span><span class="s1">.state;</span>
    <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _types.tokenIsKeywordOrIdentifier)(type)) {</span>
      <span class="s1">name = </span><span class="s2">this</span><span class="s1">.state.value;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">this</span><span class="s1">.unexpected();</span>
    <span class="s1">}</span>
    <span class="s1">const tokenIsKeyword = (</span><span class="s3">0</span><span class="s1">, _types.tokenKeywordOrIdentifierIsKeyword)(type);</span>
    <span class="s2">if </span><span class="s1">(liberal) {</span>
      <span class="s2">if </span><span class="s1">(tokenIsKeyword) {</span>
        <span class="s2">this</span><span class="s1">.replaceToken(</span><span class="s3">130</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">this</span><span class="s1">.checkReservedWord(name, startLoc, tokenIsKeyword, </span><span class="s2">false</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">this</span><span class="s1">.next();</span>
    <span class="s2">return </span><span class="s1">name;</span>
  <span class="s1">}</span>
  <span class="s1">checkReservedWord(word, startLoc, checkKeywords, isBinding) {</span>
    <span class="s2">if </span><span class="s1">(word.length &gt; </span><span class="s3">10</span><span class="s1">) {</span>
      <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!(</span><span class="s3">0</span><span class="s1">, _identifier.canBeReservedWord)(word)) {</span>
      <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(checkKeywords &amp;&amp; (</span><span class="s3">0</span><span class="s1">, _identifier.isKeyword)(word)) {</span>
      <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.UnexpectedKeyword, {</span>
        <span class="s1">at: startLoc,</span>
        <span class="s1">keyword: word</span>
      <span class="s1">});</span>
      <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">const reservedTest = !</span><span class="s2">this</span><span class="s1">.state.strict ? _identifier.isReservedWord : isBinding ? _identifier.isStrictBindReservedWord : _identifier.isStrictReservedWord;</span>
    <span class="s2">if </span><span class="s1">(reservedTest(word, </span><span class="s2">this</span><span class="s1">.inModule)) {</span>
      <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.UnexpectedReservedWord, {</span>
        <span class="s1">at: startLoc,</span>
        <span class="s1">reservedWord: word</span>
      <span class="s1">});</span>
      <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(word === </span><span class="s0">&quot;yield&quot;</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.prodParam.hasYield) {</span>
        <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.YieldBindingIdentifier, {</span>
          <span class="s1">at: startLoc</span>
        <span class="s1">});</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(word === </span><span class="s0">&quot;await&quot;</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.prodParam.hasAwait) {</span>
        <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.AwaitBindingIdentifier, {</span>
          <span class="s1">at: startLoc</span>
        <span class="s1">});</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.scope.inStaticBlock) {</span>
        <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.AwaitBindingIdentifierInStaticBlock, {</span>
          <span class="s1">at: startLoc</span>
        <span class="s1">});</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s2">this</span><span class="s1">.expressionScope.recordAsyncArrowParametersError({</span>
        <span class="s1">at: startLoc</span>
      <span class="s1">});</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(word === </span><span class="s0">&quot;arguments&quot;</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.scope.inClassAndNotInNonArrowFunction) {</span>
        <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.ArgumentsInClass, {</span>
          <span class="s1">at: startLoc</span>
        <span class="s1">});</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">isAwaitAllowed() {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.prodParam.hasAwait) </span><span class="s2">return true</span><span class="s1">;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.allowAwaitOutsideFunction &amp;&amp; !</span><span class="s2">this</span><span class="s1">.scope.inFunction) {</span>
      <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return false</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s1">parseAwait(startLoc) {</span>
    <span class="s1">const node = </span><span class="s2">this</span><span class="s1">.startNodeAt(startLoc);</span>
    <span class="s2">this</span><span class="s1">.expressionScope.recordParameterInitializerError(_parseError.Errors.AwaitExpressionFormalParameter, {</span>
      <span class="s1">at: node</span>
    <span class="s1">});</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.eat(</span><span class="s3">55</span><span class="s1">)) {</span>
      <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.ObsoleteAwaitStar, {</span>
        <span class="s1">at: node</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.scope.inFunction &amp;&amp; !</span><span class="s2">this</span><span class="s1">.options.allowAwaitOutsideFunction) {</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isAmbiguousAwait()) {</span>
        <span class="s2">this</span><span class="s1">.ambiguousScriptDifferentAst = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">this</span><span class="s1">.sawUnambiguousESM = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.state.soloAwait) {</span>
      <span class="s1">node.argument = </span><span class="s2">this</span><span class="s1">.parseMaybeUnary(</span><span class="s2">null</span><span class="s1">, </span><span class="s2">true</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">return this</span><span class="s1">.finishNode(node, </span><span class="s0">&quot;AwaitExpression&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">isAmbiguousAwait() {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.hasPrecedingLineBreak()) </span><span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">const {</span>
      <span class="s1">type</span>
    <span class="s1">} = </span><span class="s2">this</span><span class="s1">.state;</span>
    <span class="s2">return </span><span class="s1">type === </span><span class="s3">53 </span><span class="s1">|| type === </span><span class="s3">10 </span><span class="s1">|| type === </span><span class="s3">0 </span><span class="s1">|| (</span><span class="s3">0</span><span class="s1">, _types.tokenIsTemplate)(type) || type === </span><span class="s3">101 </span><span class="s1">&amp;&amp; !</span><span class="s2">this</span><span class="s1">.state.containsEsc || type === </span><span class="s3">135 </span><span class="s1">|| type === </span><span class="s3">56 </span><span class="s1">|| </span><span class="s2">this</span><span class="s1">.hasPlugin(</span><span class="s0">&quot;v8intrinsic&quot;</span><span class="s1">) &amp;&amp; type === </span><span class="s3">54</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s1">parseYield() {</span>
    <span class="s1">const node = </span><span class="s2">this</span><span class="s1">.startNode();</span>
    <span class="s2">this</span><span class="s1">.expressionScope.recordParameterInitializerError(_parseError.Errors.YieldInParameter, {</span>
      <span class="s1">at: node</span>
    <span class="s1">});</span>
    <span class="s2">this</span><span class="s1">.next();</span>
    <span class="s1">let delegating = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">let argument = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.hasPrecedingLineBreak()) {</span>
      <span class="s1">delegating = </span><span class="s2">this</span><span class="s1">.eat(</span><span class="s3">55</span><span class="s1">);</span>
      <span class="s2">switch </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.state.type) {</span>
        <span class="s2">case </span><span class="s3">13</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s3">137</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s3">8</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s3">11</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s3">3</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s3">9</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s3">14</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s3">12</span><span class="s1">:</span>
          <span class="s2">if </span><span class="s1">(!delegating) </span><span class="s2">break</span><span class="s1">;</span>
        <span class="s2">default</span><span class="s1">:</span>
          <span class="s1">argument = </span><span class="s2">this</span><span class="s1">.parseMaybeAssign();</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">node.delegate = delegating;</span>
    <span class="s1">node.argument = argument;</span>
    <span class="s2">return this</span><span class="s1">.finishNode(node, </span><span class="s0">&quot;YieldExpression&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">checkPipelineAtInfixOperator(left, leftStartLoc) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.hasPlugin([</span><span class="s0">&quot;pipelineOperator&quot;</span><span class="s1">, {</span>
      <span class="s1">proposal: </span><span class="s0">&quot;smart&quot;</span>
    <span class="s1">}])) {</span>
      <span class="s2">if </span><span class="s1">(left.type === </span><span class="s0">&quot;SequenceExpression&quot;</span><span class="s1">) {</span>
        <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.PipelineHeadSequenceExpression, {</span>
          <span class="s1">at: leftStartLoc</span>
        <span class="s1">});</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">parseSmartPipelineBodyInStyle(childExpr, startLoc) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isSimpleReference(childExpr)) {</span>
      <span class="s1">const bodyNode = </span><span class="s2">this</span><span class="s1">.startNodeAt(startLoc);</span>
      <span class="s1">bodyNode.callee = childExpr;</span>
      <span class="s2">return this</span><span class="s1">.finishNode(bodyNode, </span><span class="s0">&quot;PipelineBareFunction&quot;</span><span class="s1">);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">const bodyNode = </span><span class="s2">this</span><span class="s1">.startNodeAt(startLoc);</span>
      <span class="s2">this</span><span class="s1">.checkSmartPipeTopicBodyEarlyErrors(startLoc);</span>
      <span class="s1">bodyNode.expression = childExpr;</span>
      <span class="s2">return this</span><span class="s1">.finishNode(bodyNode, </span><span class="s0">&quot;PipelineTopicExpression&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">isSimpleReference(expression) {</span>
    <span class="s2">switch </span><span class="s1">(expression.type) {</span>
      <span class="s2">case </span><span class="s0">&quot;MemberExpression&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">!expression.computed &amp;&amp; </span><span class="s2">this</span><span class="s1">.isSimpleReference(expression.object);</span>
      <span class="s2">case </span><span class="s0">&quot;Identifier&quot;</span><span class="s1">:</span>
        <span class="s2">return true</span><span class="s1">;</span>
      <span class="s2">default</span><span class="s1">:</span>
        <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">checkSmartPipeTopicBodyEarlyErrors(startLoc) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">19</span><span class="s1">)) {</span>
      <span class="s2">throw this</span><span class="s1">.raise(_parseError.Errors.PipelineBodyNoArrow, {</span>
        <span class="s1">at: </span><span class="s2">this</span><span class="s1">.state.startLoc</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.topicReferenceWasUsedInCurrentContext()) {</span>
      <span class="s2">this</span><span class="s1">.raise(_parseError.Errors.PipelineTopicUnused, {</span>
        <span class="s1">at: startLoc</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">withTopicBindingContext(callback) {</span>
    <span class="s1">const outerContextTopicState = </span><span class="s2">this</span><span class="s1">.state.topicContext;</span>
    <span class="s2">this</span><span class="s1">.state.topicContext = {</span>
      <span class="s1">maxNumOfResolvableTopics: </span><span class="s3">1</span><span class="s1">,</span>
      <span class="s1">maxTopicIndex: </span><span class="s2">null</span>
    <span class="s1">};</span>
    <span class="s2">try </span><span class="s1">{</span>
      <span class="s2">return </span><span class="s1">callback();</span>
    <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
      <span class="s2">this</span><span class="s1">.state.topicContext = outerContextTopicState;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">withSmartMixTopicForbiddingContext(callback) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.hasPlugin([</span><span class="s0">&quot;pipelineOperator&quot;</span><span class="s1">, {</span>
      <span class="s1">proposal: </span><span class="s0">&quot;smart&quot;</span>
    <span class="s1">}])) {</span>
      <span class="s1">const outerContextTopicState = </span><span class="s2">this</span><span class="s1">.state.topicContext;</span>
      <span class="s2">this</span><span class="s1">.state.topicContext = {</span>
        <span class="s1">maxNumOfResolvableTopics: </span><span class="s3">0</span><span class="s1">,</span>
        <span class="s1">maxTopicIndex: </span><span class="s2">null</span>
      <span class="s1">};</span>
      <span class="s2">try </span><span class="s1">{</span>
        <span class="s2">return </span><span class="s1">callback();</span>
      <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
        <span class="s2">this</span><span class="s1">.state.topicContext = outerContextTopicState;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">return </span><span class="s1">callback();</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">withSoloAwaitPermittingContext(callback) {</span>
    <span class="s1">const outerContextSoloAwaitState = </span><span class="s2">this</span><span class="s1">.state.soloAwait;</span>
    <span class="s2">this</span><span class="s1">.state.soloAwait = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s2">try </span><span class="s1">{</span>
      <span class="s2">return </span><span class="s1">callback();</span>
    <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
      <span class="s2">this</span><span class="s1">.state.soloAwait = outerContextSoloAwaitState;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">allowInAnd(callback) {</span>
    <span class="s1">const flags = </span><span class="s2">this</span><span class="s1">.prodParam.currentFlags();</span>
    <span class="s1">const prodParamToSet = _productionParameter.PARAM_IN &amp; ~flags;</span>
    <span class="s2">if </span><span class="s1">(prodParamToSet) {</span>
      <span class="s2">this</span><span class="s1">.prodParam.enter(flags | _productionParameter.PARAM_IN);</span>
      <span class="s2">try </span><span class="s1">{</span>
        <span class="s2">return </span><span class="s1">callback();</span>
      <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
        <span class="s2">this</span><span class="s1">.prodParam.exit();</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">callback();</span>
  <span class="s1">}</span>
  <span class="s1">disallowInAnd(callback) {</span>
    <span class="s1">const flags = </span><span class="s2">this</span><span class="s1">.prodParam.currentFlags();</span>
    <span class="s1">const prodParamToClear = _productionParameter.PARAM_IN &amp; flags;</span>
    <span class="s2">if </span><span class="s1">(prodParamToClear) {</span>
      <span class="s2">this</span><span class="s1">.prodParam.enter(flags &amp; ~_productionParameter.PARAM_IN);</span>
      <span class="s2">try </span><span class="s1">{</span>
        <span class="s2">return </span><span class="s1">callback();</span>
      <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
        <span class="s2">this</span><span class="s1">.prodParam.exit();</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">callback();</span>
  <span class="s1">}</span>
  <span class="s1">registerTopicReference() {</span>
    <span class="s2">this</span><span class="s1">.state.topicContext.maxTopicIndex = </span><span class="s3">0</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s1">topicReferenceIsAllowedInCurrentContext() {</span>
    <span class="s2">return this</span><span class="s1">.state.topicContext.maxNumOfResolvableTopics &gt;= </span><span class="s3">1</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s1">topicReferenceWasUsedInCurrentContext() {</span>
    <span class="s2">return this</span><span class="s1">.state.topicContext.maxTopicIndex != </span><span class="s2">null </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.state.topicContext.maxTopicIndex &gt;= </span><span class="s3">0</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s1">parseFSharpPipelineBody(prec) {</span>
    <span class="s1">const startLoc = </span><span class="s2">this</span><span class="s1">.state.startLoc;</span>
    <span class="s2">this</span><span class="s1">.state.potentialArrowAt = </span><span class="s2">this</span><span class="s1">.state.start;</span>
    <span class="s1">const oldInFSharpPipelineDirectBody = </span><span class="s2">this</span><span class="s1">.state.inFSharpPipelineDirectBody;</span>
    <span class="s2">this</span><span class="s1">.state.inFSharpPipelineDirectBody = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">const ret = </span><span class="s2">this</span><span class="s1">.parseExprOp(</span><span class="s2">this</span><span class="s1">.parseMaybeUnaryOrPrivate(), startLoc, prec);</span>
    <span class="s2">this</span><span class="s1">.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;</span>
    <span class="s2">return </span><span class="s1">ret;</span>
  <span class="s1">}</span>
  <span class="s1">parseModuleExpression() {</span>
    <span class="s2">this</span><span class="s1">.expectPlugin(</span><span class="s0">&quot;moduleBlocks&quot;</span><span class="s1">);</span>
    <span class="s1">const node = </span><span class="s2">this</span><span class="s1">.startNode();</span>
    <span class="s2">this</span><span class="s1">.next();</span>
    <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.match(</span><span class="s3">5</span><span class="s1">)) {</span>
      <span class="s2">this</span><span class="s1">.unexpected(</span><span class="s2">null</span><span class="s1">, </span><span class="s3">5</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">const program = </span><span class="s2">this</span><span class="s1">.startNodeAt(</span><span class="s2">this</span><span class="s1">.state.endLoc);</span>
    <span class="s2">this</span><span class="s1">.next();</span>
    <span class="s1">const revertScopes = </span><span class="s2">this</span><span class="s1">.initializeScopes(</span><span class="s2">true</span><span class="s1">);</span>
    <span class="s2">this</span><span class="s1">.enterInitialScopes();</span>
    <span class="s2">try </span><span class="s1">{</span>
      <span class="s1">node.body = </span><span class="s2">this</span><span class="s1">.parseProgram(program, </span><span class="s3">8</span><span class="s1">, </span><span class="s0">&quot;module&quot;</span><span class="s1">);</span>
    <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
      <span class="s1">revertScopes();</span>
    <span class="s1">}</span>
    <span class="s2">return this</span><span class="s1">.finishNode(node, </span><span class="s0">&quot;ModuleExpression&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">parsePropertyNamePrefixOperator(prop) {}</span>
<span class="s1">}</span>
<span class="s1">exports.</span><span class="s2">default </span><span class="s1">= ExpressionParser;</span>

<span class="s5">//# sourceMappingURL=expression.js.map</span>
</pre>
</body>
</html>
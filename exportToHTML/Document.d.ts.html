<html>
<head>
<title>Document.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #a9b7c6;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
Document.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">import type </span><span class="s1">{ </span><span class="s2">YAMLError</span><span class="s1">, </span><span class="s2">YAMLWarning </span><span class="s1">} </span><span class="s0">from </span><span class="s3">'../errors.js'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ </span><span class="s2">Alias </span><span class="s1">} </span><span class="s0">from </span><span class="s3">'../nodes/Alias.js'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ </span><span class="s2">NODE_TYPE </span><span class="s1">} </span><span class="s0">from </span><span class="s3">'../nodes/identity.js'</span><span class="s1">;</span>
<span class="s0">import type </span><span class="s1">{ </span><span class="s2">Node</span><span class="s1">, </span><span class="s2">NodeType</span><span class="s1">, </span><span class="s2">ParsedNode</span><span class="s1">, </span><span class="s2">Range </span><span class="s1">} </span><span class="s0">from </span><span class="s3">'../nodes/Node.js'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ </span><span class="s2">Pair </span><span class="s1">} </span><span class="s0">from </span><span class="s3">'../nodes/Pair.js'</span><span class="s1">;</span>
<span class="s0">import type </span><span class="s1">{ </span><span class="s2">Scalar </span><span class="s1">} </span><span class="s0">from </span><span class="s3">'../nodes/Scalar.js'</span><span class="s1">;</span>
<span class="s0">import type </span><span class="s1">{ </span><span class="s2">YAMLMap </span><span class="s1">} </span><span class="s0">from </span><span class="s3">'../nodes/YAMLMap.js'</span><span class="s1">;</span>
<span class="s0">import type </span><span class="s1">{ </span><span class="s2">YAMLSeq </span><span class="s1">} </span><span class="s0">from </span><span class="s3">'../nodes/YAMLSeq.js'</span><span class="s1">;</span>
<span class="s0">import type </span><span class="s1">{ </span><span class="s2">CreateNodeOptions</span><span class="s1">, </span><span class="s2">DocumentOptions</span><span class="s1">, </span><span class="s2">ParseOptions</span><span class="s1">, </span><span class="s2">SchemaOptions</span><span class="s1">, </span><span class="s2">ToJSOptions</span><span class="s1">, </span><span class="s2">ToStringOptions </span><span class="s1">} </span><span class="s0">from </span><span class="s3">'../options.js'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ </span><span class="s2">Schema </span><span class="s1">} </span><span class="s0">from </span><span class="s3">'../schema/Schema.js'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ </span><span class="s2">Directives </span><span class="s1">} </span><span class="s0">from </span><span class="s3">'./directives.js'</span><span class="s1">;</span>
<span class="s0">export type </span><span class="s2">Replacer </span><span class="s0">= </span><span class="s2">any</span><span class="s1">[] </span><span class="s0">| </span><span class="s1">((</span><span class="s2">key</span><span class="s0">: </span><span class="s2">any</span><span class="s1">, </span><span class="s2">value</span><span class="s0">: </span><span class="s2">any</span><span class="s1">) </span><span class="s0">=&gt; </span><span class="s2">unknown</span><span class="s1">);</span>
<span class="s0">export declare namespace </span><span class="s2">Document </span><span class="s1">{</span>
    <span class="s4">/** @ts-ignore The typing of directives fails in TS &lt;= 4.2 */</span>
    <span class="s0">interface </span><span class="s2">Parsed</span><span class="s1">&lt;</span><span class="s2">Contents </span><span class="s0">extends </span><span class="s2">ParsedNode </span><span class="s0">= </span><span class="s2">ParsedNode</span><span class="s1">, </span><span class="s2">Strict </span><span class="s0">extends </span><span class="s2">boolean </span><span class="s0">= </span><span class="s2">true</span><span class="s1">&gt; </span><span class="s0">extends </span><span class="s2">Document</span><span class="s1">&lt;</span><span class="s2">Contents</span><span class="s1">, </span><span class="s2">Strict</span><span class="s1">&gt; {</span>
        <span class="s1">directives</span><span class="s0">: </span><span class="s2">Directives</span><span class="s1">;</span>
        <span class="s1">range</span><span class="s0">: </span><span class="s2">Range</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">export declare class </span><span class="s2">Document</span><span class="s1">&lt;</span><span class="s2">Contents </span><span class="s0">extends </span><span class="s2">Node </span><span class="s0">= </span><span class="s2">Node</span><span class="s1">, </span><span class="s2">Strict </span><span class="s0">extends </span><span class="s2">boolean </span><span class="s0">= </span><span class="s2">true</span><span class="s1">&gt; {</span>
    <span class="s0">readonly </span><span class="s1">[</span><span class="s2">NODE_TYPE</span><span class="s1">]</span><span class="s0">: </span><span class="s2">symbol</span><span class="s1">;</span>
    <span class="s4">/** A comment before this Document */</span>
    <span class="s1">commentBefore</span><span class="s0">: </span><span class="s2">string </span><span class="s0">| </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s4">/** A comment immediately after this Document */</span>
    <span class="s1">comment</span><span class="s0">: </span><span class="s2">string </span><span class="s0">| </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s4">/** The document contents. */</span>
    <span class="s1">contents</span><span class="s0">: </span><span class="s2">Strict </span><span class="s0">extends </span><span class="s2">true </span><span class="s0">? </span><span class="s2">Contents </span><span class="s0">| </span><span class="s2">null </span><span class="s0">: </span><span class="s2">Contents</span><span class="s1">;</span>
    <span class="s1">directives</span><span class="s0">: </span><span class="s2">Strict </span><span class="s0">extends </span><span class="s2">true </span><span class="s0">? </span><span class="s2">Directives </span><span class="s0">| </span><span class="s2">undefined </span><span class="s0">: </span><span class="s2">Directives</span><span class="s1">;</span>
    <span class="s4">/** Errors encountered during parsing. */</span>
    <span class="s1">errors</span><span class="s0">: </span><span class="s2">YAMLError</span><span class="s1">[];</span>
    <span class="s1">options</span><span class="s0">: </span><span class="s2">Required</span><span class="s1">&lt;</span><span class="s2">Omit</span><span class="s1">&lt;</span><span class="s2">ParseOptions </span><span class="s0">&amp; </span><span class="s2">DocumentOptions</span><span class="s1">, </span><span class="s3">'_directives' </span><span class="s0">| </span><span class="s3">'lineCounter' </span><span class="s0">| </span><span class="s3">'version'</span><span class="s1">&gt;&gt;;</span>
    <span class="s4">/**</span>
     <span class="s4">* The `[start, value-end, node-end]` character offsets for the part of the 
     * source parsed into this document (undefined if not parsed). The `value-end` 
     * and `node-end` positions are themselves not included in their respective 
     * ranges. 
     */</span>
    <span class="s1">range</span><span class="s0">?: </span><span class="s2">Range</span><span class="s1">;</span>
    <span class="s4">/** The schema used with the document. Use `setSchema()` to change. */</span>
    <span class="s1">schema</span><span class="s0">: </span><span class="s2">Schema</span><span class="s1">;</span>
    <span class="s4">/** Warnings encountered during parsing. */</span>
    <span class="s1">warnings</span><span class="s0">: </span><span class="s2">YAMLWarning</span><span class="s1">[];</span>
    <span class="s4">/**</span>
     <span class="s4">* </span><span class="s0">@param </span><span class="s2">value </span><span class="s4">- The initial value for the document, which will be wrapped 
     *   in a Node container. 
     */</span>
    <span class="s0">constructor</span><span class="s1">(</span><span class="s2">value</span><span class="s0">?: </span><span class="s2">any</span><span class="s1">, </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">DocumentOptions </span><span class="s0">&amp; </span><span class="s2">SchemaOptions </span><span class="s0">&amp; </span><span class="s2">ParseOptions </span><span class="s0">&amp; </span><span class="s2">CreateNodeOptions</span><span class="s1">);</span>
    <span class="s0">constructor</span><span class="s1">(</span><span class="s2">value</span><span class="s0">: </span><span class="s2">any</span><span class="s1">, </span><span class="s2">replacer</span><span class="s0">: </span><span class="s2">null </span><span class="s0">| </span><span class="s2">Replacer</span><span class="s1">, </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">DocumentOptions </span><span class="s0">&amp; </span><span class="s2">SchemaOptions </span><span class="s0">&amp; </span><span class="s2">ParseOptions </span><span class="s0">&amp; </span><span class="s2">CreateNodeOptions</span><span class="s1">);</span>
    <span class="s4">/**</span>
     <span class="s4">* Create a deep copy of this Document and its contents. 
     * 
     * Custom Node values that inherit from `Object` still refer to their original instances. 
     */</span>
    <span class="s1">clone()</span><span class="s0">: </span><span class="s2">Document</span><span class="s1">&lt;</span><span class="s2">Contents</span><span class="s1">, </span><span class="s2">Strict</span><span class="s1">&gt;;</span>
    <span class="s4">/** Adds a value to the document. */</span>
    <span class="s1">add(</span><span class="s2">value</span><span class="s0">: </span><span class="s2">any</span><span class="s1">)</span><span class="s0">: </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s4">/** Adds a value to the document. */</span>
    <span class="s1">addIn(</span><span class="s2">path</span><span class="s0">: </span><span class="s2">Iterable</span><span class="s1">&lt;</span><span class="s2">unknown</span><span class="s1">&gt;, </span><span class="s2">value</span><span class="s0">: </span><span class="s2">unknown</span><span class="s1">)</span><span class="s0">: </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s4">/**</span>
     <span class="s4">* Create a new `Alias` node, ensuring that the target `node` has the required anchor. 
     * 
     * If `node` already has an anchor, `name` is ignored. 
     * Otherwise, the `node.anchor` value will be set to `name`, 
     * or if an anchor with that name is already present in the document, 
     * `name` will be used as a prefix for a new unique anchor. 
     * If `name` is undefined, the generated anchor will use 'a' as a prefix. 
     */</span>
    <span class="s1">createAlias(</span><span class="s2">node</span><span class="s0">: </span><span class="s2">Strict </span><span class="s0">extends </span><span class="s2">true </span><span class="s0">? </span><span class="s2">Scalar </span><span class="s0">| </span><span class="s2">YAMLMap </span><span class="s0">| </span><span class="s2">YAMLSeq </span><span class="s0">: </span><span class="s2">Node</span><span class="s1">, </span><span class="s2">name</span><span class="s0">?: </span><span class="s2">string</span><span class="s1">)</span><span class="s0">: </span><span class="s2">Alias</span><span class="s1">;</span>
    <span class="s4">/**</span>
     <span class="s4">* Convert any value into a `Node` using the current schema, recursively 
     * turning objects into collections. 
     */</span>
    <span class="s1">createNode&lt;</span><span class="s2">T </span><span class="s0">= </span><span class="s2">unknown</span><span class="s1">&gt;(</span><span class="s2">value</span><span class="s0">: </span><span class="s2">T</span><span class="s1">, </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">CreateNodeOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">NodeType</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt;;</span>
    <span class="s1">createNode&lt;</span><span class="s2">T </span><span class="s0">= </span><span class="s2">unknown</span><span class="s1">&gt;(</span><span class="s2">value</span><span class="s0">: </span><span class="s2">T</span><span class="s1">, </span><span class="s2">replacer</span><span class="s0">: </span><span class="s2">Replacer </span><span class="s0">| </span><span class="s2">CreateNodeOptions </span><span class="s0">| </span><span class="s2">null</span><span class="s1">, </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">CreateNodeOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">NodeType</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt;;</span>
    <span class="s4">/**</span>
     <span class="s4">* Convert a key and a value into a `Pair` using the current schema, 
     * recursively wrapping all values as `Scalar` or `Collection` nodes. 
     */</span>
    <span class="s1">createPair&lt;</span><span class="s2">K </span><span class="s0">extends </span><span class="s2">Node </span><span class="s0">= </span><span class="s2">Node</span><span class="s1">, </span><span class="s2">V </span><span class="s0">extends </span><span class="s2">Node </span><span class="s0">= </span><span class="s2">Node</span><span class="s1">&gt;(</span><span class="s2">key</span><span class="s0">: </span><span class="s2">unknown</span><span class="s1">, </span><span class="s2">value</span><span class="s0">: </span><span class="s2">unknown</span><span class="s1">, </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">CreateNodeOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">Pair</span><span class="s1">&lt;</span><span class="s2">K</span><span class="s1">, </span><span class="s2">V</span><span class="s1">&gt;;</span>
    <span class="s4">/**</span>
     <span class="s4">* Removes a value from the document. 
     * </span><span class="s0">@returns </span><span class="s4">`true` if the item was found and removed. 
     */</span>
    <span class="s1">delete(</span><span class="s2">key</span><span class="s0">: </span><span class="s2">unknown</span><span class="s1">)</span><span class="s0">: </span><span class="s2">boolean</span><span class="s1">;</span>
    <span class="s4">/**</span>
     <span class="s4">* Removes a value from the document. 
     * </span><span class="s0">@returns </span><span class="s4">`true` if the item was found and removed. 
     */</span>
    <span class="s1">deleteIn(</span><span class="s2">path</span><span class="s0">: </span><span class="s2">Iterable</span><span class="s1">&lt;</span><span class="s2">unknown</span><span class="s1">&gt; </span><span class="s0">| </span><span class="s2">null</span><span class="s1">)</span><span class="s0">: </span><span class="s2">boolean</span><span class="s1">;</span>
    <span class="s4">/**</span>
     <span class="s4">* Returns item at `key`, or `undefined` if not found. By default unwraps 
     * scalar values from their surrounding node; to disable set `keepScalar` to 
     * `true` (collections are always returned intact). 
     */</span>
    <span class="s1">get(</span><span class="s2">key</span><span class="s0">: </span><span class="s2">unknown</span><span class="s1">, </span><span class="s2">keepScalar</span><span class="s0">?: </span><span class="s2">boolean</span><span class="s1">)</span><span class="s0">: </span><span class="s2">Strict </span><span class="s0">extends </span><span class="s2">true </span><span class="s0">? </span><span class="s2">unknown </span><span class="s0">: </span><span class="s2">any</span><span class="s1">;</span>
    <span class="s4">/**</span>
     <span class="s4">* Returns item at `path`, or `undefined` if not found. By default unwraps 
     * scalar values from their surrounding node; to disable set `keepScalar` to 
     * `true` (collections are always returned intact). 
     */</span>
    <span class="s1">getIn(</span><span class="s2">path</span><span class="s0">: </span><span class="s2">Iterable</span><span class="s1">&lt;</span><span class="s2">unknown</span><span class="s1">&gt; </span><span class="s0">| </span><span class="s2">null</span><span class="s1">, </span><span class="s2">keepScalar</span><span class="s0">?: </span><span class="s2">boolean</span><span class="s1">)</span><span class="s0">: </span><span class="s2">Strict </span><span class="s0">extends </span><span class="s2">true </span><span class="s0">? </span><span class="s2">unknown </span><span class="s0">: </span><span class="s2">any</span><span class="s1">;</span>
    <span class="s4">/**</span>
     <span class="s4">* Checks if the document includes a value with the key `key`. 
     */</span>
    <span class="s1">has(</span><span class="s2">key</span><span class="s0">: </span><span class="s2">unknown</span><span class="s1">)</span><span class="s0">: </span><span class="s2">boolean</span><span class="s1">;</span>
    <span class="s4">/**</span>
     <span class="s4">* Checks if the document includes a value at `path`. 
     */</span>
    <span class="s1">hasIn(</span><span class="s2">path</span><span class="s0">: </span><span class="s2">Iterable</span><span class="s1">&lt;</span><span class="s2">unknown</span><span class="s1">&gt; </span><span class="s0">| </span><span class="s2">null</span><span class="s1">)</span><span class="s0">: </span><span class="s2">boolean</span><span class="s1">;</span>
    <span class="s4">/**</span>
     <span class="s4">* Sets a value in this document. For `!!set`, `value` needs to be a 
     * boolean to add/remove the item from the set. 
     */</span>
    <span class="s1">set(</span><span class="s2">key</span><span class="s0">: </span><span class="s2">any</span><span class="s1">, </span><span class="s2">value</span><span class="s0">: </span><span class="s2">unknown</span><span class="s1">)</span><span class="s0">: </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s4">/**</span>
     <span class="s4">* Sets a value in this document. For `!!set`, `value` needs to be a 
     * boolean to add/remove the item from the set. 
     */</span>
    <span class="s1">setIn(</span><span class="s2">path</span><span class="s0">: </span><span class="s2">Iterable</span><span class="s1">&lt;</span><span class="s2">unknown</span><span class="s1">&gt; </span><span class="s0">| </span><span class="s2">null</span><span class="s1">, </span><span class="s2">value</span><span class="s0">: </span><span class="s2">unknown</span><span class="s1">)</span><span class="s0">: </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s4">/**</span>
     <span class="s4">* Change the YAML version and schema used by the document. 
     * A `null` version disables support for directives, explicit tags, anchors, and aliases. 
     * It also requires the `schema` option to be given as a `Schema` instance value. 
     * 
     * Overrides all previously set schema options. 
     */</span>
    <span class="s1">setSchema(</span><span class="s2">version</span><span class="s0">: </span><span class="s3">'1.1' </span><span class="s0">| </span><span class="s3">'1.2' </span><span class="s0">| </span><span class="s3">'next' </span><span class="s0">| </span><span class="s2">null</span><span class="s1">, </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">SchemaOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">void</span><span class="s1">;</span>
    <span class="s4">/** A plain JavaScript representation of the document `contents`. */</span>
    <span class="s1">toJS(</span><span class="s2">opt</span><span class="s0">?: </span><span class="s2">ToJSOptions </span><span class="s0">&amp; </span><span class="s1">{</span>
        <span class="s1">[</span><span class="s2">ignored</span><span class="s0">: </span><span class="s2">string</span><span class="s1">]</span><span class="s0">: </span><span class="s2">unknown</span><span class="s1">;</span>
    <span class="s1">})</span><span class="s0">: </span><span class="s2">any</span><span class="s1">;</span>
    <span class="s4">/**</span>
     <span class="s4">* A JSON representation of the document `contents`. 
     * 
     * </span><span class="s0">@param </span><span class="s2">jsonArg </span><span class="s4">Used by `JSON.stringify` to indicate the array index or 
     *   property name. 
     */</span>
    <span class="s1">toJSON(</span><span class="s2">jsonArg</span><span class="s0">?: </span><span class="s2">string </span><span class="s0">| </span><span class="s2">null</span><span class="s1">, </span><span class="s2">onAnchor</span><span class="s0">?: </span><span class="s2">ToJSOptions</span><span class="s1">[</span><span class="s3">'onAnchor'</span><span class="s1">])</span><span class="s0">: </span><span class="s2">any</span><span class="s1">;</span>
    <span class="s4">/** A YAML representation of the document. */</span>
    <span class="s1">toString(</span><span class="s2">options</span><span class="s0">?: </span><span class="s2">ToStringOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">string</span><span class="s1">;</span>
<span class="s1">}</span>
</pre>
</body>
</html>
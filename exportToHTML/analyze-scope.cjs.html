<html>
<head>
<title>analyze-scope.cjs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #a9b7c6;}
.s3 { color: #ffc66d;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb; font-style: italic;}
.s6 { color: #9876aa; font-style: italic;}
.s7 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
analyze-scope.cjs</font>
</center></td></tr></table>
<pre><span class="s0">function </span><span class="s1">_classPrivateFieldInitSpec(</span><span class="s2">obj</span><span class="s1">, </span><span class="s2">privateMap</span><span class="s1">, </span><span class="s2">value</span><span class="s1">) { </span><span class="s3">_checkPrivateRedeclaration</span><span class="s1">(</span><span class="s2">obj</span><span class="s1">, </span><span class="s2">privateMap</span><span class="s1">); </span><span class="s2">privateMap</span><span class="s1">.</span><span class="s3">set</span><span class="s1">(</span><span class="s2">obj</span><span class="s1">, </span><span class="s2">value</span><span class="s1">); }</span>
<span class="s0">function </span><span class="s1">_checkPrivateRedeclaration(</span><span class="s2">obj</span><span class="s1">, </span><span class="s2">privateCollection</span><span class="s1">) { </span><span class="s0">if </span><span class="s1">(</span><span class="s2">privateCollection</span><span class="s1">.</span><span class="s3">has</span><span class="s1">(</span><span class="s2">obj</span><span class="s1">)) { </span><span class="s0">throw new </span><span class="s3">TypeError</span><span class="s1">(</span><span class="s4">&quot;Cannot initialize the same private elements twice on an object&quot;</span><span class="s1">); } }</span>
<span class="s0">function </span><span class="s1">_classPrivateFieldGet(</span><span class="s2">receiver</span><span class="s1">, </span><span class="s2">privateMap</span><span class="s1">) { </span><span class="s0">var </span><span class="s1">descriptor </span><span class="s0">= </span><span class="s3">_classExtractFieldDescriptor</span><span class="s1">(</span><span class="s2">receiver</span><span class="s1">, </span><span class="s2">privateMap</span><span class="s1">, </span><span class="s4">&quot;get&quot;</span><span class="s1">); </span><span class="s0">return </span><span class="s3">_classApplyDescriptorGet</span><span class="s1">(</span><span class="s2">receiver</span><span class="s1">, </span><span class="s2">descriptor</span><span class="s1">); }</span>
<span class="s0">function </span><span class="s1">_classApplyDescriptorGet(</span><span class="s2">receiver</span><span class="s1">, </span><span class="s2">descriptor</span><span class="s1">) { </span><span class="s0">if </span><span class="s1">(</span><span class="s2">descriptor</span><span class="s1">.</span><span class="s2">get</span><span class="s1">) { </span><span class="s0">return </span><span class="s2">descriptor</span><span class="s1">.</span><span class="s2">get</span><span class="s1">.</span><span class="s3">call</span><span class="s1">(</span><span class="s2">receiver</span><span class="s1">); } </span><span class="s0">return </span><span class="s2">descriptor</span><span class="s1">.</span><span class="s2">value</span><span class="s1">; }</span>
<span class="s0">function </span><span class="s1">_classPrivateFieldSet(</span><span class="s2">receiver</span><span class="s1">, </span><span class="s2">privateMap</span><span class="s1">, </span><span class="s2">value</span><span class="s1">) { </span><span class="s0">var </span><span class="s1">descriptor </span><span class="s0">= </span><span class="s3">_classExtractFieldDescriptor</span><span class="s1">(</span><span class="s2">receiver</span><span class="s1">, </span><span class="s2">privateMap</span><span class="s1">, </span><span class="s4">&quot;set&quot;</span><span class="s1">); </span><span class="s3">_classApplyDescriptorSet</span><span class="s1">(</span><span class="s2">receiver</span><span class="s1">, </span><span class="s2">descriptor</span><span class="s1">, </span><span class="s2">value</span><span class="s1">); </span><span class="s0">return </span><span class="s2">value</span><span class="s1">; }</span>
<span class="s0">function </span><span class="s1">_classExtractFieldDescriptor(</span><span class="s2">receiver</span><span class="s1">, </span><span class="s2">privateMap</span><span class="s1">, </span><span class="s2">action</span><span class="s1">) { </span><span class="s0">if </span><span class="s1">(</span><span class="s0">!</span><span class="s2">privateMap</span><span class="s1">.</span><span class="s3">has</span><span class="s1">(</span><span class="s2">receiver</span><span class="s1">)) { </span><span class="s0">throw new </span><span class="s3">TypeError</span><span class="s1">(</span><span class="s4">&quot;attempted to &quot; </span><span class="s0">+ </span><span class="s2">action </span><span class="s0">+ </span><span class="s4">&quot; private field on non-instance&quot;</span><span class="s1">); } </span><span class="s0">return </span><span class="s2">privateMap</span><span class="s1">.</span><span class="s3">get</span><span class="s1">(</span><span class="s2">receiver</span><span class="s1">); }</span>
<span class="s0">function </span><span class="s1">_classApplyDescriptorSet(</span><span class="s2">receiver</span><span class="s1">, </span><span class="s2">descriptor</span><span class="s1">, </span><span class="s2">value</span><span class="s1">) { </span><span class="s0">if </span><span class="s1">(</span><span class="s2">descriptor</span><span class="s1">.</span><span class="s2">set</span><span class="s1">) { </span><span class="s2">descriptor</span><span class="s1">.</span><span class="s2">set</span><span class="s1">.</span><span class="s3">call</span><span class="s1">(</span><span class="s2">receiver</span><span class="s1">, </span><span class="s2">value</span><span class="s1">); } </span><span class="s0">else </span><span class="s1">{ </span><span class="s0">if </span><span class="s1">(</span><span class="s0">!</span><span class="s2">descriptor</span><span class="s1">.</span><span class="s2">writable</span><span class="s1">) { </span><span class="s0">throw new </span><span class="s3">TypeError</span><span class="s1">(</span><span class="s4">&quot;attempted to set read only private field&quot;</span><span class="s1">); } </span><span class="s2">descriptor</span><span class="s1">.</span><span class="s2">value </span><span class="s0">= </span><span class="s2">value</span><span class="s1">; } }</span>
<span class="s0">const </span><span class="s1">{</span>
  <span class="s1">Definition,</span>
  <span class="s2">PatternVisitor</span><span class="s1">: OriginalPatternVisitor,</span>
  <span class="s2">Referencer</span><span class="s1">: OriginalReferencer,</span>
  <span class="s1">Scope,</span>
  <span class="s1">ScopeManager</span>
<span class="s1">} </span><span class="s0">= </span><span class="s3">require</span><span class="s1">(</span><span class="s4">&quot;@nicolo-ribaudo/eslint-scope-5-internals&quot;</span><span class="s1">);</span>
<span class="s0">const </span><span class="s1">{</span>
  <span class="s2">getKeys</span><span class="s1">: fallback</span>
<span class="s1">} = require(&quot;eslint-visitor-keys&quot;); 
let visitorKeysMap; 
function getVisitorValues(nodeType, client) {</span>
  <span class="s1">if (visitorKeysMap) return visitorKeysMap[nodeType]; 
  const {</span>
    <span class="s1">FLOW_FLIPPED_ALIAS_KEYS,</span>
    <span class="s1">VISITOR_KEYS</span>
  <span class="s1">} </span><span class="s0">= </span><span class="s2">client</span><span class="s1">.</span><span class="s3">getTypesInfo</span><span class="s1">(); 
  const flowFlippedAliasKeys </span><span class="s0">= </span><span class="s2">FLOW_FLIPPED_ALIAS_KEYS</span><span class="s1">.</span><span class="s3">concat</span><span class="s1">([</span><span class="s4">&quot;ArrayPattern&quot;</span><span class="s1">, </span><span class="s4">&quot;ClassDeclaration&quot;</span><span class="s1">, </span><span class="s4">&quot;ClassExpression&quot;</span><span class="s1">, </span><span class="s4">&quot;FunctionDeclaration&quot;</span><span class="s1">, </span><span class="s4">&quot;FunctionExpression&quot;</span><span class="s1">, </span><span class="s4">&quot;Identifier&quot;</span><span class="s1">, </span><span class="s4">&quot;ObjectPattern&quot;</span><span class="s1">, </span><span class="s4">&quot;RestElement&quot;</span><span class="s1">]); 
  visitorKeysMap </span><span class="s0">= </span><span class="s2">Object</span><span class="s1">.</span><span class="s3">entries</span><span class="s1">(</span><span class="s2">VISITOR_KEYS</span><span class="s1">).</span><span class="s3">reduce</span><span class="s1">((</span><span class="s2">acc</span><span class="s1">, [</span><span class="s2">key</span><span class="s1">, </span><span class="s2">value</span><span class="s1">]) </span><span class="s0">=&gt; </span><span class="s1">{</span>
    <span class="s0">if </span><span class="s1">(</span><span class="s0">!</span><span class="s2">flowFlippedAliasKeys</span><span class="s1">.</span><span class="s3">includes</span><span class="s1">(</span><span class="s2">value</span><span class="s1">)) {</span>
      <span class="s2">acc</span><span class="s1">[</span><span class="s2">key</span><span class="s1">] </span><span class="s0">= </span><span class="s2">value</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s2">acc</span><span class="s1">;</span>
  <span class="s1">}, {}); 
  return visitorKeysMap[nodeType]; 
}</span>
<span class="s1">const propertyTypes </span><span class="s0">= </span><span class="s1">{</span>
  <span class="s1">callProperties: {</span>
    <span class="s1">type: </span><span class="s4">&quot;loop&quot;</span><span class="s1">,</span>
    <span class="s1">values: [</span><span class="s4">&quot;value&quot;</span><span class="s1">]</span>
  <span class="s1">},</span>
  <span class="s1">indexers: {</span>
    <span class="s1">type: </span><span class="s4">&quot;loop&quot;</span><span class="s1">,</span>
    <span class="s1">values: [</span><span class="s4">&quot;key&quot;</span><span class="s1">, </span><span class="s4">&quot;value&quot;</span><span class="s1">]</span>
  <span class="s1">},</span>
  <span class="s1">properties: {</span>
    <span class="s1">type: </span><span class="s4">&quot;loop&quot;</span><span class="s1">,</span>
    <span class="s1">values: [</span><span class="s4">&quot;argument&quot;</span><span class="s1">, </span><span class="s4">&quot;value&quot;</span><span class="s1">]</span>
  <span class="s1">},</span>
  <span class="s1">types: {</span>
    <span class="s1">type: </span><span class="s4">&quot;loop&quot;</span>
  <span class="s1">},</span>
  <span class="s1">params: {</span>
    <span class="s1">type: </span><span class="s4">&quot;loop&quot;</span>
  <span class="s1">},</span>
  <span class="s1">argument: {</span>
    <span class="s1">type: </span><span class="s4">&quot;single&quot;</span>
  <span class="s1">},</span>
  <span class="s1">elementType: {</span>
    <span class="s1">type: </span><span class="s4">&quot;single&quot;</span>
  <span class="s1">},</span>
  <span class="s1">qualification: {</span>
    <span class="s1">type: </span><span class="s4">&quot;single&quot;</span>
  <span class="s1">},</span>
  <span class="s1">rest: {</span>
    <span class="s1">type: </span><span class="s4">&quot;single&quot;</span>
  <span class="s1">},</span>
  <span class="s1">returnType: {</span>
    <span class="s1">type: </span><span class="s4">&quot;single&quot;</span>
  <span class="s1">},</span>
  <span class="s1">typeAnnotation: {</span>
    <span class="s1">type: </span><span class="s4">&quot;typeAnnotation&quot;</span>
  <span class="s1">},</span>
  <span class="s1">typeParameters: {</span>
    <span class="s1">type: </span><span class="s4">&quot;typeParameters&quot;</span>
  <span class="s1">},</span>
  <span class="s1">id: {</span>
    <span class="s1">type: </span><span class="s4">&quot;id&quot;</span>
  <span class="s1">}</span>
<span class="s1">}; 
class PatternVisitor extends OriginalPatternVisitor {</span>
  <span class="s1">ArrayPattern(node) {</span>
    <span class="s1">node.elements.forEach(this.visit, this); 
  }</span>
  <span class="s1">ObjectPattern(node) {</span>
    <span class="s1">node.properties.forEach(this.visit, this); 
  }</span>
<span class="s1">}</span>
<span class="s1">var _client </span><span class="s0">= new </span><span class="s3">WeakMap</span><span class="s1">(); 
class Referencer extends OriginalReferencer {</span>
  <span class="s1">constructor(options, scopeManager, client) {</span>
    <span class="s1">super(options, scopeManager); 
    _classPrivateFieldInitSpec(this, _client, {</span>
      <span class="s2">writable</span><span class="s1">: true,</span>
      <span class="s2">value</span><span class="s1">: void </span><span class="s5">0</span>
    <span class="s1">}); 
    _classPrivateFieldSet(this, _client, client); 
  }</span>
  <span class="s1">visitPattern(node, options, callback) {</span>
    <span class="s1">if (!node) {</span>
      <span class="s1">return; 
    }</span>
    <span class="s1">this._checkIdentifierOrVisit(node.typeAnnotation); 
    if (node.type === &quot;AssignmentPattern&quot;) {</span>
      <span class="s1">this._checkIdentifierOrVisit(node.left.typeAnnotation); 
    }</span>
    <span class="s1">if (typeof options === &quot;function&quot;) {</span>
      <span class="s1">callback </span><span class="s0">= </span><span class="s2">options</span><span class="s1">; 
      options </span><span class="s0">= </span><span class="s1">{</span>
        <span class="s1">processRightHandNodes: </span><span class="s6">false</span>
      <span class="s1">}; 
    }</span>
    <span class="s1">const visitor </span><span class="s0">= new </span><span class="s3">PatternVisitor</span><span class="s1">(</span><span class="s2">this</span><span class="s1">.</span><span class="s2">options</span><span class="s1">, </span><span class="s2">node</span><span class="s1">, </span><span class="s2">callback</span><span class="s1">); 
    visitor.visit(node); 
    if (options.processRightHandNodes) {</span>
      <span class="s1">visitor.rightHandNodes.forEach(this.visit, this); 
    }</span>
  <span class="s1">}</span>
  <span class="s1">visitClass(node) {</span>
    <span class="s1">this._visitArray(node.decorators); 
    const typeParamScope </span><span class="s0">= </span><span class="s2">this</span><span class="s1">.</span><span class="s3">_nestTypeParamScope</span><span class="s1">(</span><span class="s2">node</span><span class="s1">); 
    this._visitTypeAnnotation(node.implements); 
    this._visitTypeAnnotation(node.superTypeParameters &amp;&amp; node.superTypeParameters.params); 
    super.visitClass(node); 
    if (typeParamScope) {</span>
      <span class="s1">this.close(node); 
    }</span>
  <span class="s1">}</span>
  <span class="s1">visitFunction(node) {</span>
    <span class="s1">const typeParamScope </span><span class="s0">= </span><span class="s2">this</span><span class="s1">.</span><span class="s3">_nestTypeParamScope</span><span class="s1">(</span><span class="s2">node</span><span class="s1">); 
    this._checkIdentifierOrVisit(node.returnType); 
    super.visitFunction(node); 
    if (typeParamScope) {</span>
      <span class="s1">this.close(node); 
    }</span>
  <span class="s1">}</span>
  <span class="s1">visitProperty(node) {</span>
    <span class="s1">var _node$value; 
    if (((_node$value </span><span class="s0">= </span><span class="s2">node</span><span class="s1">.</span><span class="s2">value</span><span class="s1">) == null ? void </span><span class="s5">0 </span><span class="s1">: _node$value.type) === </span><span class="s4">&quot;TypeCastExpression&quot;</span><span class="s1">) {</span>
      <span class="s1">this._visitTypeAnnotation(node.value); 
    }</span>
    <span class="s1">this._visitArray(node.decorators); 
    super.visitProperty(node); 
  }</span>
  <span class="s1">InterfaceDeclaration(node) {</span>
    <span class="s1">this._createScopeVariable(node, node.id); 
    const typeParamScope </span><span class="s0">= </span><span class="s2">this</span><span class="s1">.</span><span class="s3">_nestTypeParamScope</span><span class="s1">(</span><span class="s2">node</span><span class="s1">); 
    this._visitArray(node.extends); 
    this.visit(node.body); 
    if (typeParamScope) {</span>
      <span class="s1">this.close(node); 
    }</span>
  <span class="s1">}</span>
  <span class="s1">TypeAlias(node) {</span>
    <span class="s1">this._createScopeVariable(node, node.id); 
    const typeParamScope </span><span class="s0">= </span><span class="s2">this</span><span class="s1">.</span><span class="s3">_nestTypeParamScope</span><span class="s1">(</span><span class="s2">node</span><span class="s1">); 
    this.visit(node.right); 
    if (typeParamScope) {</span>
      <span class="s1">this.close(node); 
    }</span>
  <span class="s1">}</span>
  <span class="s1">ClassProperty(node) {</span>
    <span class="s1">this._visitClassProperty(node); 
  }</span>
  <span class="s1">ClassPrivateProperty(node) {</span>
    <span class="s1">this._visitClassProperty(node); 
  }</span>
  <span class="s1">PropertyDefinition(node) {</span>
    <span class="s1">this._visitClassProperty(node); 
  }</span>
  <span class="s1">ClassPrivateMethod(node) {</span>
    <span class="s1">super.MethodDefinition(node); 
  }</span>
  <span class="s1">DeclareModule(node) {</span>
    <span class="s1">this._visitDeclareX(node); 
  }</span>
  <span class="s1">DeclareFunction(node) {</span>
    <span class="s1">this._visitDeclareX(node); 
  }</span>
  <span class="s1">DeclareVariable(node) {</span>
    <span class="s1">this._visitDeclareX(node); 
  }</span>
  <span class="s1">DeclareClass(node) {</span>
    <span class="s1">this._visitDeclareX(node); 
  }</span>
  <span class="s1">OptionalMemberExpression(node) {</span>
    <span class="s1">super.MemberExpression(node); 
  }</span>
  <span class="s1">_visitClassProperty(node) {</span>
    <span class="s1">this._visitTypeAnnotation(node.typeAnnotation); 
    this.visitProperty(node); 
  }</span>
  <span class="s1">_visitDeclareX(node) {</span>
    <span class="s1">if (node.id) {</span>
      <span class="s1">this._createScopeVariable(node, node.id); 
    }</span>
    <span class="s1">const typeParamScope </span><span class="s0">= </span><span class="s2">this</span><span class="s1">.</span><span class="s3">_nestTypeParamScope</span><span class="s1">(</span><span class="s2">node</span><span class="s1">); 
    if (typeParamScope) {</span>
      <span class="s1">this.close(node); 
    }</span>
  <span class="s1">}</span>
  <span class="s1">_createScopeVariable(node, name) {</span>
    <span class="s1">this.currentScope().variableScope.__define(name, new Definition(&quot;Variable&quot;, name, node, null, null, null)); 
  }</span>
  <span class="s1">_nestTypeParamScope(node) {</span>
    <span class="s1">if (!node.typeParameters) {</span>
      <span class="s1">return null; 
    }</span>
    <span class="s1">const parentScope </span><span class="s0">= </span><span class="s2">this</span><span class="s1">.</span><span class="s2">scopeManager</span><span class="s1">.</span><span class="s2">__currentScope</span><span class="s1">; 
    const scope </span><span class="s0">= new </span><span class="s3">Scope</span><span class="s1">(</span><span class="s2">this</span><span class="s1">.</span><span class="s2">scopeManager</span><span class="s1">, </span><span class="s4">&quot;type-parameters&quot;</span><span class="s1">, </span><span class="s2">parentScope</span><span class="s1">, </span><span class="s2">node</span><span class="s1">, </span><span class="s6">false</span><span class="s1">); 
    this.scopeManager.__nestScope(scope); 
    for (let j </span><span class="s0">= </span><span class="s5">0</span><span class="s1">; j &lt; node.typeParameters.params.length; j++) {</span>
      <span class="s1">const name </span><span class="s0">= </span><span class="s2">node</span><span class="s1">.</span><span class="s2">typeParameters</span><span class="s1">.</span><span class="s2">params</span><span class="s1">[</span><span class="s2">j</span><span class="s1">]; 
      scope.__define(name, new Definition(&quot;TypeParameter&quot;, name, name)); 
      if (name.typeAnnotation) {</span>
        <span class="s1">this._checkIdentifierOrVisit(name); 
      }</span>
    <span class="s1">}</span>
    <span class="s1">scope.__define </span><span class="s0">= function </span><span class="s1">() {</span>
      <span class="s0">return </span><span class="s2">parentScope</span><span class="s1">.</span><span class="s2">__define</span><span class="s1">.</span><span class="s3">apply</span><span class="s1">(</span><span class="s2">parentScope</span><span class="s1">, </span><span class="s2">arguments</span><span class="s1">);</span>
    <span class="s1">}; 
    return scope; 
  }</span>
  <span class="s1">_visitTypeAnnotation(node) {</span>
    <span class="s1">if (!node) {</span>
      <span class="s1">return; 
    }</span>
    <span class="s1">if (Array.isArray(node)) {</span>
      <span class="s1">node.forEach(this._visitTypeAnnotation, this); 
      return; 
    }</span>
    <span class="s1">const visitorValues </span><span class="s0">= </span><span class="s3">getVisitorValues</span><span class="s1">(</span><span class="s2">node</span><span class="s1">.</span><span class="s2">type</span><span class="s1">, </span><span class="s3">_classPrivateFieldGet</span><span class="s1">(</span><span class="s2">this</span><span class="s1">, </span><span class="s2">_client</span><span class="s1">)); 
    if (!visitorValues) {</span>
      <span class="s1">return; 
    }</span>
    <span class="s1">for (let i </span><span class="s0">= </span><span class="s5">0</span><span class="s1">; i &lt; visitorValues.length; i++) {</span>
      <span class="s1">const visitorValue </span><span class="s0">= </span><span class="s2">visitorValues</span><span class="s1">[</span><span class="s2">i</span><span class="s1">]; 
      const propertyType </span><span class="s0">= </span><span class="s2">propertyTypes</span><span class="s1">[</span><span class="s2">visitorValue</span><span class="s1">]; 
      const nodeProperty </span><span class="s0">= </span><span class="s2">node</span><span class="s1">[</span><span class="s2">visitorValue</span><span class="s1">]; 
      if (propertyType == null || nodeProperty == null) {</span>
        <span class="s1">continue; 
      }</span>
      <span class="s1">if (propertyType.type === &quot;loop&quot;) {</span>
        <span class="s1">for (let j </span><span class="s0">= </span><span class="s5">0</span><span class="s1">; j &lt; nodeProperty.length; j++) {</span>
          <span class="s1">if (Array.isArray(propertyType.values)) {</span>
            <span class="s1">for (let k </span><span class="s0">= </span><span class="s5">0</span><span class="s1">; k &lt; propertyType.values.length; k++) {</span>
              <span class="s1">const loopPropertyNode </span><span class="s0">= </span><span class="s2">nodeProperty</span><span class="s1">[</span><span class="s2">j</span><span class="s1">][</span><span class="s2">propertyType</span><span class="s1">.</span><span class="s2">values</span><span class="s1">[</span><span class="s2">k</span><span class="s1">]]; 
              if (loopPropertyNode) {</span>
                <span class="s1">this._checkIdentifierOrVisit(loopPropertyNode); 
              }</span>
            <span class="s1">}</span>
          <span class="s1">} else {</span>
            <span class="s1">this._checkIdentifierOrVisit(nodeProperty[j]); 
          }</span>
        <span class="s1">}</span>
      <span class="s1">} else if (propertyType.type === &quot;single&quot;) {</span>
        <span class="s1">this._checkIdentifierOrVisit(nodeProperty); 
      } else if (propertyType.type === &quot;typeAnnotation&quot;) {</span>
        <span class="s1">this._visitTypeAnnotation(node.typeAnnotation); 
      } else if (propertyType.type === &quot;typeParameters&quot;) {</span>
        <span class="s1">for (let l </span><span class="s0">= </span><span class="s5">0</span><span class="s1">; l &lt; node.typeParameters.params.length; l++) {</span>
          <span class="s1">this._checkIdentifierOrVisit(node.typeParameters.params[l]); 
        }</span>
      <span class="s1">} else if (propertyType.type === &quot;id&quot;) {</span>
        <span class="s1">if (node.id.type === &quot;Identifier&quot;) {</span>
          <span class="s1">this._checkIdentifierOrVisit(node.id); 
        } else {</span>
          <span class="s1">this._visitTypeAnnotation(node.id); 
        }</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">_checkIdentifierOrVisit(node) {</span>
    <span class="s1">if (node != null &amp;&amp; node.typeAnnotation) {</span>
      <span class="s1">this._visitTypeAnnotation(node.typeAnnotation); 
    } else if ((node == null ? void </span><span class="s5">0 </span><span class="s1">: node.type) === </span><span class="s4">&quot;Identifier&quot;</span><span class="s1">) {</span>
      <span class="s1">this.visit(node); 
    } else {</span>
      <span class="s1">this._visitTypeAnnotation(node); 
    }</span>
  <span class="s1">}</span>
  <span class="s1">_visitArray(nodeList) {</span>
    <span class="s1">if (nodeList) {</span>
      <span class="s1">for (const node of nodeList) {</span>
        <span class="s1">this.visit(node); 
      }</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">module.exports </span><span class="s0">= function </span><span class="s1">analyzeScope(</span><span class="s2">ast</span><span class="s1">, </span><span class="s2">parserOptions</span><span class="s1">, </span><span class="s2">client</span><span class="s1">) {</span>
  <span class="s0">var </span><span class="s1">_parserOptions$ecmaFe;</span>
  <span class="s0">const </span><span class="s1">options </span><span class="s0">= </span><span class="s1">{</span>
    <span class="s1">ignoreEval: </span><span class="s6">true</span><span class="s1">,</span>
    <span class="s1">optimistic: </span><span class="s6">false</span><span class="s1">,</span>
    <span class="s1">directive: </span><span class="s6">false</span><span class="s1">,</span>
    <span class="s1">nodejsScope: </span><span class="s2">ast</span><span class="s1">.</span><span class="s2">sourceType </span><span class="s0">=== </span><span class="s4">&quot;script&quot; </span><span class="s0">&amp;&amp; </span><span class="s1">((</span><span class="s2">_parserOptions$ecmaFe </span><span class="s0">= </span><span class="s2">parserOptions</span><span class="s1">.</span><span class="s2">ecmaFeatures</span><span class="s1">) </span><span class="s0">== </span><span class="s6">null </span><span class="s0">? void </span><span class="s5">0 </span><span class="s0">: </span><span class="s2">_parserOptions$ecmaFe</span><span class="s1">.</span><span class="s2">globalReturn</span><span class="s1">) </span><span class="s0">=== </span><span class="s6">true</span><span class="s1">,</span>
    <span class="s1">impliedStrict: </span><span class="s6">false</span><span class="s1">,</span>
    <span class="s1">sourceType: </span><span class="s2">ast</span><span class="s1">.</span><span class="s2">sourceType</span><span class="s1">,</span>
    <span class="s1">ecmaVersion: </span><span class="s2">parserOptions</span><span class="s1">.</span><span class="s2">ecmaVersion</span><span class="s1">,</span>
    <span class="s2">fallback</span>
  <span class="s1">};</span>
  <span class="s2">options</span><span class="s1">.</span><span class="s2">childVisitorKeys </span><span class="s0">= </span><span class="s2">client</span><span class="s1">.</span><span class="s3">getVisitorKeys</span><span class="s1">();</span>
  <span class="s0">const </span><span class="s1">scopeManager </span><span class="s0">= new </span><span class="s3">ScopeManager</span><span class="s1">(</span><span class="s2">options</span><span class="s1">);</span>
  <span class="s0">const </span><span class="s1">referencer </span><span class="s0">= new </span><span class="s3">Referencer</span><span class="s1">(</span><span class="s2">options</span><span class="s1">, </span><span class="s2">scopeManager</span><span class="s1">, </span><span class="s2">client</span><span class="s1">);</span>
  <span class="s2">referencer</span><span class="s1">.</span><span class="s3">visit</span><span class="s1">(</span><span class="s2">ast</span><span class="s1">);</span>
  <span class="s0">return </span><span class="s2">scopeManager</span><span class="s1">;</span>
<span class="s1">}; 
</span>
<span class="s7">//# sourceMappingURL=analyze-scope.cjs.map</span>
</pre>
</body>
</html>
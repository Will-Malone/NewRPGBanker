<html>
<head>
<title>Card.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6a8759;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
Card.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>

<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
  <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s1">exports.getIsModalPresentation = exports.</span><span class="s2">default </span><span class="s1">= </span><span class="s2">void </span><span class="s3">0</span><span class="s1">;</span>
<span class="s2">var </span><span class="s1">_color = _interopRequireDefault(require(</span><span class="s0">&quot;color&quot;</span><span class="s1">));</span>
<span class="s2">var </span><span class="s1">React = _interopRequireWildcard(require(</span><span class="s0">&quot;react&quot;</span><span class="s1">));</span>
<span class="s2">var </span><span class="s1">_reactNative = require(</span><span class="s0">&quot;react-native&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_CardStyleInterpolators = require(</span><span class="s0">&quot;../../TransitionConfigs/CardStyleInterpolators&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_CardAnimationContext = _interopRequireDefault(require(</span><span class="s0">&quot;../../utils/CardAnimationContext&quot;</span><span class="s1">));</span>
<span class="s2">var </span><span class="s1">_getDistanceForDirection = _interopRequireDefault(require(</span><span class="s0">&quot;../../utils/getDistanceForDirection&quot;</span><span class="s1">));</span>
<span class="s2">var </span><span class="s1">_getInvertedMultiplier = _interopRequireDefault(require(</span><span class="s0">&quot;../../utils/getInvertedMultiplier&quot;</span><span class="s1">));</span>
<span class="s2">var </span><span class="s1">_memoize = _interopRequireDefault(require(</span><span class="s0">&quot;../../utils/memoize&quot;</span><span class="s1">));</span>
<span class="s2">var </span><span class="s1">_GestureHandler = require(</span><span class="s0">&quot;../GestureHandler&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_ModalStatusBarManager = _interopRequireDefault(require(</span><span class="s0">&quot;../ModalStatusBarManager&quot;</span><span class="s1">));</span>
<span class="s2">var </span><span class="s1">_CardSheet = _interopRequireDefault(require(</span><span class="s0">&quot;./CardSheet&quot;</span><span class="s1">));</span>
<span class="s2">function </span><span class="s1">_getRequireWildcardCache(nodeInterop) { </span><span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">WeakMap !== </span><span class="s0">&quot;function&quot;</span><span class="s1">) </span><span class="s2">return null</span><span class="s1">; </span><span class="s2">var </span><span class="s1">cacheBabelInterop = </span><span class="s2">new </span><span class="s1">WeakMap(); </span><span class="s2">var </span><span class="s1">cacheNodeInterop = </span><span class="s2">new </span><span class="s1">WeakMap(); </span><span class="s2">return </span><span class="s1">(_getRequireWildcardCache = </span><span class="s2">function </span><span class="s1">(nodeInterop) { </span><span class="s2">return </span><span class="s1">nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }</span>
<span class="s2">function </span><span class="s1">_interopRequireWildcard(obj, nodeInterop) { </span><span class="s2">if </span><span class="s1">(!nodeInterop &amp;&amp; obj &amp;&amp; obj.__esModule) { </span><span class="s2">return </span><span class="s1">obj; } </span><span class="s2">if </span><span class="s1">(obj === </span><span class="s2">null </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">obj !== </span><span class="s0">&quot;object&quot; </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">obj !== </span><span class="s0">&quot;function&quot;</span><span class="s1">) { </span><span class="s2">return </span><span class="s1">{ </span><span class="s2">default</span><span class="s1">: obj }; } </span><span class="s2">var </span><span class="s1">cache = _getRequireWildcardCache(nodeInterop); </span><span class="s2">if </span><span class="s1">(cache &amp;&amp; cache.has(obj)) { </span><span class="s2">return </span><span class="s1">cache.get(obj); } </span><span class="s2">var </span><span class="s1">newObj = {}; </span><span class="s2">var </span><span class="s1">hasPropertyDescriptor = Object.defineProperty &amp;&amp; Object.getOwnPropertyDescriptor; </span><span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">key </span><span class="s2">in </span><span class="s1">obj) { </span><span class="s2">if </span><span class="s1">(key !== </span><span class="s0">&quot;default&quot; </span><span class="s1">&amp;&amp; Object.prototype.hasOwnProperty.call(obj, key)) { </span><span class="s2">var </span><span class="s1">desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : </span><span class="s2">null</span><span class="s1">; </span><span class="s2">if </span><span class="s1">(desc &amp;&amp; (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } </span><span class="s2">else </span><span class="s1">{ newObj[key] = obj[key]; } } } newObj.</span><span class="s2">default </span><span class="s1">= obj; </span><span class="s2">if </span><span class="s1">(cache) { cache.set(obj, newObj); } </span><span class="s2">return </span><span class="s1">newObj; }</span>
<span class="s2">function </span><span class="s1">_interopRequireDefault(obj) { </span><span class="s2">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : { </span><span class="s2">default</span><span class="s1">: obj }; }</span>
<span class="s2">function </span><span class="s1">_extends() { _extends = Object.assign ? Object.assign.bind() : </span><span class="s2">function </span><span class="s1">(target) { </span><span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s3">1</span><span class="s1">; i &lt; arguments.length; i++) { </span><span class="s2">var </span><span class="s1">source = arguments[i]; </span><span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">key </span><span class="s2">in </span><span class="s1">source) { </span><span class="s2">if </span><span class="s1">(Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } </span><span class="s2">return </span><span class="s1">target; }; </span><span class="s2">return </span><span class="s1">_extends.apply(</span><span class="s2">this</span><span class="s1">, arguments); }</span>
<span class="s1">const GESTURE_VELOCITY_IMPACT = </span><span class="s3">0.3</span><span class="s1">;</span>
<span class="s1">const TRUE = </span><span class="s3">1</span><span class="s1">;</span>
<span class="s1">const FALSE = </span><span class="s3">0</span><span class="s1">;</span>

<span class="s4">/** 
 * The distance of touch start from the edge of the screen where the gesture will be recognized 
 */</span>
<span class="s1">const GESTURE_RESPONSE_DISTANCE_HORIZONTAL = </span><span class="s3">50</span><span class="s1">;</span>
<span class="s1">const GESTURE_RESPONSE_DISTANCE_VERTICAL = </span><span class="s3">135</span><span class="s1">;</span>
<span class="s1">const useNativeDriver = _reactNative.Platform.OS !== </span><span class="s0">'web'</span><span class="s1">;</span>
<span class="s1">const hasOpacityStyle = style =&gt; {</span>
  <span class="s2">if </span><span class="s1">(style) {</span>
    <span class="s1">const flattenedStyle = _reactNative.StyleSheet.flatten(style);</span>
    <span class="s2">return </span><span class="s1">flattenedStyle.opacity != </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">return false</span><span class="s1">;</span>
<span class="s1">};</span>
<span class="s1">class Card extends React.Component {</span>
  <span class="s1">static defaultProps = {</span>
    <span class="s1">shadowEnabled: </span><span class="s2">false</span><span class="s1">,</span>
    <span class="s1">gestureEnabled: </span><span class="s2">true</span><span class="s1">,</span>
    <span class="s1">gestureVelocityImpact: GESTURE_VELOCITY_IMPACT,</span>
    <span class="s1">overlay: _ref =&gt; {</span>
      <span class="s1">let {</span>
        <span class="s1">style</span>
      <span class="s1">} = _ref;</span>
      <span class="s2">return </span><span class="s1">style ? </span><span class="s4">/*#__PURE__*/</span><span class="s1">React.createElement(_reactNative.Animated.View, {</span>
        <span class="s1">pointerEvents: </span><span class="s0">&quot;none&quot;</span><span class="s1">,</span>
        <span class="s1">style: [styles.overlay, style]</span>
      <span class="s1">}) : </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">};</span>
  <span class="s1">componentDidMount() {</span>
    <span class="s2">this</span><span class="s1">.animate({</span>
      <span class="s1">closing: </span><span class="s2">this</span><span class="s1">.props.closing</span>
    <span class="s1">});</span>
    <span class="s2">this</span><span class="s1">.isCurrentlyMounted = </span><span class="s2">true</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s1">componentDidUpdate(prevProps) {</span>
    <span class="s1">const {</span>
      <span class="s1">layout,</span>
      <span class="s1">gestureDirection,</span>
      <span class="s1">closing</span>
    <span class="s1">} = </span><span class="s2">this</span><span class="s1">.props;</span>
    <span class="s1">const {</span>
      <span class="s1">width,</span>
      <span class="s1">height</span>
    <span class="s1">} = layout;</span>
    <span class="s2">if </span><span class="s1">(width !== prevProps.layout.width) {</span>
      <span class="s2">this</span><span class="s1">.layout.width.setValue(width);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(height !== prevProps.layout.height) {</span>
      <span class="s2">this</span><span class="s1">.layout.height.setValue(height);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(gestureDirection !== prevProps.gestureDirection) {</span>
      <span class="s2">this</span><span class="s1">.inverted.setValue((</span><span class="s3">0</span><span class="s1">, _getInvertedMultiplier.</span><span class="s2">default</span><span class="s1">)(gestureDirection));</span>
    <span class="s1">}</span>
    <span class="s1">const toValue = </span><span class="s2">this</span><span class="s1">.getAnimateToValue(</span><span class="s2">this</span><span class="s1">.props);</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.getAnimateToValue(prevProps) !== toValue || </span><span class="s2">this</span><span class="s1">.lastToValue !== toValue) {</span>
      <span class="s4">// We need to trigger the animation when route was closed</span>
      <span class="s4">// Thr route might have been closed by a `POP` action or by a gesture</span>
      <span class="s4">// When route was closed due to a gesture, the animation would've happened already</span>
      <span class="s4">// It's still important to trigger the animation so that `onClose` is called</span>
      <span class="s4">// If `onClose` is not called, cleanup step won't be performed for gestures</span>
      <span class="s2">this</span><span class="s1">.animate({</span>
        <span class="s1">closing</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">componentWillUnmount() {</span>
    <span class="s2">this</span><span class="s1">.props.gesture.stopAnimation();</span>
    <span class="s2">this</span><span class="s1">.isCurrentlyMounted = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s2">this</span><span class="s1">.handleEndInteraction();</span>
  <span class="s1">}</span>
  <span class="s1">isCurrentlyMounted = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s1">isClosing = </span><span class="s2">new </span><span class="s1">_reactNative.Animated.Value(FALSE);</span>
  <span class="s1">inverted = </span><span class="s2">new </span><span class="s1">_reactNative.Animated.Value((</span><span class="s3">0</span><span class="s1">, _getInvertedMultiplier.</span><span class="s2">default</span><span class="s1">)(</span><span class="s2">this</span><span class="s1">.props.gestureDirection));</span>
  <span class="s1">layout = {</span>
    <span class="s1">width: </span><span class="s2">new </span><span class="s1">_reactNative.Animated.Value(</span><span class="s2">this</span><span class="s1">.props.layout.width),</span>
    <span class="s1">height: </span><span class="s2">new </span><span class="s1">_reactNative.Animated.Value(</span><span class="s2">this</span><span class="s1">.props.layout.height)</span>
  <span class="s1">};</span>
  <span class="s1">isSwiping = </span><span class="s2">new </span><span class="s1">_reactNative.Animated.Value(FALSE);</span>
  <span class="s1">animate = _ref2 =&gt; {</span>
    <span class="s1">let {</span>
      <span class="s1">closing,</span>
      <span class="s1">velocity</span>
    <span class="s1">} = _ref2;</span>
    <span class="s1">const {</span>
      <span class="s1">gesture,</span>
      <span class="s1">transitionSpec,</span>
      <span class="s1">onOpen,</span>
      <span class="s1">onClose,</span>
      <span class="s1">onTransition</span>
    <span class="s1">} = </span><span class="s2">this</span><span class="s1">.props;</span>
    <span class="s1">const toValue = </span><span class="s2">this</span><span class="s1">.getAnimateToValue({</span>
      <span class="s1">...</span><span class="s2">this</span><span class="s1">.props,</span>
      <span class="s1">closing</span>
    <span class="s1">});</span>
    <span class="s2">this</span><span class="s1">.lastToValue = toValue;</span>
    <span class="s2">this</span><span class="s1">.isClosing.setValue(closing ? TRUE : FALSE);</span>
    <span class="s1">const spec = closing ? transitionSpec.close : transitionSpec.open;</span>
    <span class="s1">const animation = spec.animation === </span><span class="s0">'spring' </span><span class="s1">? _reactNative.Animated.spring : _reactNative.Animated.timing;</span>
    <span class="s2">this</span><span class="s1">.setPointerEventsEnabled(!closing);</span>
    <span class="s2">this</span><span class="s1">.handleStartInteraction();</span>
    <span class="s1">clearTimeout(</span><span class="s2">this</span><span class="s1">.pendingGestureCallback);</span>
    <span class="s1">onTransition === </span><span class="s2">null </span><span class="s1">|| onTransition === </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: onTransition({</span>
      <span class="s1">closing,</span>
      <span class="s1">gesture: velocity !== undefined</span>
    <span class="s1">});</span>
    <span class="s1">animation(gesture, {</span>
      <span class="s1">...spec.config,</span>
      <span class="s1">velocity,</span>
      <span class="s1">toValue,</span>
      <span class="s1">useNativeDriver,</span>
      <span class="s1">isInteraction: </span><span class="s2">false</span>
    <span class="s1">}).start(_ref3 =&gt; {</span>
      <span class="s1">let {</span>
        <span class="s1">finished</span>
      <span class="s1">} = _ref3;</span>
      <span class="s2">this</span><span class="s1">.handleEndInteraction();</span>
      <span class="s1">clearTimeout(</span><span class="s2">this</span><span class="s1">.pendingGestureCallback);</span>
      <span class="s2">if </span><span class="s1">(finished) {</span>
        <span class="s2">if </span><span class="s1">(closing) {</span>
          <span class="s1">onClose();</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">onOpen();</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isCurrentlyMounted) {</span>
          <span class="s4">// Make sure to re-open screen if it wasn't removed</span>
          <span class="s2">this</span><span class="s1">.forceUpdate();</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">});</span>
  <span class="s1">};</span>
  <span class="s1">getAnimateToValue = _ref4 =&gt; {</span>
    <span class="s1">let {</span>
      <span class="s1">closing,</span>
      <span class="s1">layout,</span>
      <span class="s1">gestureDirection</span>
    <span class="s1">} = _ref4;</span>
    <span class="s2">if </span><span class="s1">(!closing) {</span>
      <span class="s2">return </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _getDistanceForDirection.</span><span class="s2">default</span><span class="s1">)(layout, gestureDirection);</span>
  <span class="s1">};</span>
  <span class="s1">setPointerEventsEnabled = enabled =&gt; {</span>
    <span class="s2">var </span><span class="s1">_this$ref$current;</span>
    <span class="s1">const pointerEvents = enabled ? </span><span class="s0">'box-none' </span><span class="s1">: </span><span class="s0">'none'</span><span class="s1">;</span>
    <span class="s1">(_this$ref$current = </span><span class="s2">this</span><span class="s1">.ref.current) === </span><span class="s2">null </span><span class="s1">|| _this$ref$current === </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _this$ref$current.setPointerEvents(pointerEvents);</span>
  <span class="s1">};</span>
  <span class="s1">handleStartInteraction = () =&gt; {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.interactionHandle === undefined) {</span>
      <span class="s2">this</span><span class="s1">.interactionHandle = _reactNative.InteractionManager.createInteractionHandle();</span>
    <span class="s1">}</span>
  <span class="s1">};</span>
  <span class="s1">handleEndInteraction = () =&gt; {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.interactionHandle !== undefined) {</span>
      <span class="s1">_reactNative.InteractionManager.clearInteractionHandle(</span><span class="s2">this</span><span class="s1">.interactionHandle);</span>
      <span class="s2">this</span><span class="s1">.interactionHandle = undefined;</span>
    <span class="s1">}</span>
  <span class="s1">};</span>
  <span class="s1">handleGestureStateChange = _ref5 =&gt; {</span>
    <span class="s1">let {</span>
      <span class="s1">nativeEvent</span>
    <span class="s1">} = _ref5;</span>
    <span class="s1">const {</span>
      <span class="s1">layout,</span>
      <span class="s1">onClose,</span>
      <span class="s1">onGestureBegin,</span>
      <span class="s1">onGestureCanceled,</span>
      <span class="s1">onGestureEnd,</span>
      <span class="s1">gestureDirection,</span>
      <span class="s1">gestureVelocityImpact</span>
    <span class="s1">} = </span><span class="s2">this</span><span class="s1">.props;</span>
    <span class="s2">switch </span><span class="s1">(nativeEvent.state) {</span>
      <span class="s2">case </span><span class="s1">_GestureHandler.GestureState.ACTIVE:</span>
        <span class="s2">this</span><span class="s1">.isSwiping.setValue(TRUE);</span>
        <span class="s2">this</span><span class="s1">.handleStartInteraction();</span>
        <span class="s1">onGestureBegin === </span><span class="s2">null </span><span class="s1">|| onGestureBegin === </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: onGestureBegin();</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s2">case </span><span class="s1">_GestureHandler.GestureState.CANCELLED:</span>
        <span class="s1">{</span>
          <span class="s2">this</span><span class="s1">.isSwiping.setValue(FALSE);</span>
          <span class="s2">this</span><span class="s1">.handleEndInteraction();</span>
          <span class="s1">const velocity = gestureDirection === </span><span class="s0">'vertical' </span><span class="s1">|| gestureDirection === </span><span class="s0">'vertical-inverted' </span><span class="s1">? nativeEvent.velocityY : nativeEvent.velocityX;</span>
          <span class="s2">this</span><span class="s1">.animate({</span>
            <span class="s1">closing: </span><span class="s2">this</span><span class="s1">.props.closing,</span>
            <span class="s1">velocity</span>
          <span class="s1">});</span>
          <span class="s1">onGestureCanceled === </span><span class="s2">null </span><span class="s1">|| onGestureCanceled === </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: onGestureCanceled();</span>
          <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s2">case </span><span class="s1">_GestureHandler.GestureState.END:</span>
        <span class="s1">{</span>
          <span class="s2">this</span><span class="s1">.isSwiping.setValue(FALSE);</span>
          <span class="s1">let distance;</span>
          <span class="s1">let translation;</span>
          <span class="s1">let velocity;</span>
          <span class="s2">if </span><span class="s1">(gestureDirection === </span><span class="s0">'vertical' </span><span class="s1">|| gestureDirection === </span><span class="s0">'vertical-inverted'</span><span class="s1">) {</span>
            <span class="s1">distance = layout.height;</span>
            <span class="s1">translation = nativeEvent.translationY;</span>
            <span class="s1">velocity = nativeEvent.velocityY;</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">distance = layout.width;</span>
            <span class="s1">translation = nativeEvent.translationX;</span>
            <span class="s1">velocity = nativeEvent.velocityX;</span>
          <span class="s1">}</span>
          <span class="s1">const closing = (translation + velocity * gestureVelocityImpact) * (</span><span class="s3">0</span><span class="s1">, _getInvertedMultiplier.</span><span class="s2">default</span><span class="s1">)(gestureDirection) &gt; distance / </span><span class="s3">2 </span><span class="s1">? velocity !== </span><span class="s3">0 </span><span class="s1">|| translation !== </span><span class="s3">0 </span><span class="s1">: </span><span class="s2">this</span><span class="s1">.props.closing;</span>
          <span class="s2">this</span><span class="s1">.animate({</span>
            <span class="s1">closing,</span>
            <span class="s1">velocity</span>
          <span class="s1">});</span>
          <span class="s2">if </span><span class="s1">(closing) {</span>
            <span class="s4">// We call onClose with a delay to make sure that the animation has already started</span>
            <span class="s4">// This will make sure that the state update caused by this doesn't affect start of animation</span>
            <span class="s2">this</span><span class="s1">.pendingGestureCallback = setTimeout(() =&gt; {</span>
              <span class="s1">onClose();</span>

              <span class="s4">// Trigger an update after we dispatch the action to remove the screen</span>
              <span class="s4">// This will make sure that we check if the screen didn't get removed so we can cancel the animation</span>
              <span class="s2">this</span><span class="s1">.forceUpdate();</span>
            <span class="s1">}, </span><span class="s3">32</span><span class="s1">);</span>
          <span class="s1">}</span>
          <span class="s1">onGestureEnd === </span><span class="s2">null </span><span class="s1">|| onGestureEnd === </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: onGestureEnd();</span>
          <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s4">// Memoize this to avoid extra work on re-render</span>
  <span class="s1">getInterpolatedStyle = (</span><span class="s3">0</span><span class="s1">, _memoize.</span><span class="s2">default</span><span class="s1">)((styleInterpolator, animation) =&gt; styleInterpolator(animation));</span>

  <span class="s4">// Keep track of the animation context when deps changes.</span>
  <span class="s1">getCardAnimation = (</span><span class="s3">0</span><span class="s1">, _memoize.</span><span class="s2">default</span><span class="s1">)((interpolationIndex, current, next, layout, insetTop, insetRight, insetBottom, insetLeft) =&gt; ({</span>
    <span class="s1">index: interpolationIndex,</span>
    <span class="s1">current: {</span>
      <span class="s1">progress: current</span>
    <span class="s1">},</span>
    <span class="s1">next: next &amp;&amp; {</span>
      <span class="s1">progress: next</span>
    <span class="s1">},</span>
    <span class="s1">closing: </span><span class="s2">this</span><span class="s1">.isClosing,</span>
    <span class="s1">swiping: </span><span class="s2">this</span><span class="s1">.isSwiping,</span>
    <span class="s1">inverted: </span><span class="s2">this</span><span class="s1">.inverted,</span>
    <span class="s1">layouts: {</span>
      <span class="s1">screen: layout</span>
    <span class="s1">},</span>
    <span class="s1">insets: {</span>
      <span class="s1">top: insetTop,</span>
      <span class="s1">right: insetRight,</span>
      <span class="s1">bottom: insetBottom,</span>
      <span class="s1">left: insetLeft</span>
    <span class="s1">}</span>
  <span class="s1">}));</span>
  <span class="s1">gestureActivationCriteria() {</span>
    <span class="s1">const {</span>
      <span class="s1">layout,</span>
      <span class="s1">gestureDirection,</span>
      <span class="s1">gestureResponseDistance</span>
    <span class="s1">} = </span><span class="s2">this</span><span class="s1">.props;</span>
    <span class="s1">const enableTrackpadTwoFingerGesture = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">const distance = gestureResponseDistance !== undefined ? gestureResponseDistance : gestureDirection === </span><span class="s0">'vertical' </span><span class="s1">|| gestureDirection === </span><span class="s0">'vertical-inverted' </span><span class="s1">? GESTURE_RESPONSE_DISTANCE_VERTICAL : GESTURE_RESPONSE_DISTANCE_HORIZONTAL;</span>
    <span class="s2">if </span><span class="s1">(gestureDirection === </span><span class="s0">'vertical'</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">maxDeltaX: </span><span class="s3">15</span><span class="s1">,</span>
        <span class="s1">minOffsetY: </span><span class="s3">5</span><span class="s1">,</span>
        <span class="s1">hitSlop: {</span>
          <span class="s1">bottom: -layout.height + distance</span>
        <span class="s1">},</span>
        <span class="s1">enableTrackpadTwoFingerGesture</span>
      <span class="s1">};</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(gestureDirection === </span><span class="s0">'vertical-inverted'</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">maxDeltaX: </span><span class="s3">15</span><span class="s1">,</span>
        <span class="s1">minOffsetY: -</span><span class="s3">5</span><span class="s1">,</span>
        <span class="s1">hitSlop: {</span>
          <span class="s1">top: -layout.height + distance</span>
        <span class="s1">},</span>
        <span class="s1">enableTrackpadTwoFingerGesture</span>
      <span class="s1">};</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">const hitSlop = -layout.width + distance;</span>
      <span class="s1">const invertedMultiplier = (</span><span class="s3">0</span><span class="s1">, _getInvertedMultiplier.</span><span class="s2">default</span><span class="s1">)(gestureDirection);</span>
      <span class="s2">if </span><span class="s1">(invertedMultiplier === </span><span class="s3">1</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">{</span>
          <span class="s1">minOffsetX: </span><span class="s3">5</span><span class="s1">,</span>
          <span class="s1">maxDeltaY: </span><span class="s3">20</span><span class="s1">,</span>
          <span class="s1">hitSlop: {</span>
            <span class="s1">right: hitSlop</span>
          <span class="s1">},</span>
          <span class="s1">enableTrackpadTwoFingerGesture</span>
        <span class="s1">};</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">return </span><span class="s1">{</span>
          <span class="s1">minOffsetX: -</span><span class="s3">5</span><span class="s1">,</span>
          <span class="s1">maxDeltaY: </span><span class="s3">20</span><span class="s1">,</span>
          <span class="s1">hitSlop: {</span>
            <span class="s1">left: hitSlop</span>
          <span class="s1">},</span>
          <span class="s1">enableTrackpadTwoFingerGesture</span>
        <span class="s1">};</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">ref = </span><span class="s4">/*#__PURE__*/</span><span class="s1">React.createRef();</span>
  <span class="s1">render() {</span>
    <span class="s1">const {</span>
      <span class="s1">styleInterpolator,</span>
      <span class="s1">interpolationIndex,</span>
      <span class="s1">current,</span>
      <span class="s1">gesture,</span>
      <span class="s1">next,</span>
      <span class="s1">layout,</span>
      <span class="s1">insets,</span>
      <span class="s1">overlay,</span>
      <span class="s1">overlayEnabled,</span>
      <span class="s1">shadowEnabled,</span>
      <span class="s1">gestureEnabled,</span>
      <span class="s1">gestureDirection,</span>
      <span class="s1">pageOverflowEnabled,</span>
      <span class="s1">headerDarkContent,</span>
      <span class="s1">children,</span>
      <span class="s1">containerStyle: customContainerStyle,</span>
      <span class="s1">contentStyle,</span>
      <span class="s1">...rest</span>
    <span class="s1">} = </span><span class="s2">this</span><span class="s1">.props;</span>
    <span class="s1">const interpolationProps = </span><span class="s2">this</span><span class="s1">.getCardAnimation(interpolationIndex, current, next, layout, insets.top, insets.right, insets.bottom, insets.left);</span>
    <span class="s1">const interpolatedStyle = </span><span class="s2">this</span><span class="s1">.getInterpolatedStyle(styleInterpolator, interpolationProps);</span>
    <span class="s1">const {</span>
      <span class="s1">containerStyle,</span>
      <span class="s1">cardStyle,</span>
      <span class="s1">overlayStyle,</span>
      <span class="s1">shadowStyle</span>
    <span class="s1">} = interpolatedStyle;</span>
    <span class="s1">const handleGestureEvent = gestureEnabled ? _reactNative.Animated.event([{</span>
      <span class="s1">nativeEvent: gestureDirection === </span><span class="s0">'vertical' </span><span class="s1">|| gestureDirection === </span><span class="s0">'vertical-inverted' </span><span class="s1">? {</span>
        <span class="s1">translationY: gesture</span>
      <span class="s1">} : {</span>
        <span class="s1">translationX: gesture</span>
      <span class="s1">}</span>
    <span class="s1">}], {</span>
      <span class="s1">useNativeDriver</span>
    <span class="s1">}) : undefined;</span>
    <span class="s1">const {</span>
      <span class="s1">backgroundColor</span>
    <span class="s1">} = _reactNative.StyleSheet.flatten(contentStyle || {});</span>
    <span class="s1">const isTransparent = </span><span class="s2">typeof </span><span class="s1">backgroundColor === </span><span class="s0">'string' </span><span class="s1">? (</span><span class="s3">0</span><span class="s1">, _color.</span><span class="s2">default</span><span class="s1">)(backgroundColor).alpha() === </span><span class="s3">0 </span><span class="s1">: </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s2">return </span><span class="s4">/*#__PURE__*/</span><span class="s1">React.createElement(_CardAnimationContext.</span><span class="s2">default</span><span class="s1">.Provider, {</span>
      <span class="s1">value: interpolationProps</span>
    <span class="s1">},</span>
    <span class="s4">// StatusBar messes with translucent status bar on Android</span>
    <span class="s4">// So we should only enable it on iOS</span>
    <span class="s1">_reactNative.Platform.OS === </span><span class="s0">'ios' </span><span class="s1">&amp;&amp; overlayEnabled &amp;&amp; next &amp;&amp; getIsModalPresentation(styleInterpolator) ? </span><span class="s4">/*#__PURE__*/</span><span class="s1">React.createElement(_ModalStatusBarManager.</span><span class="s2">default</span><span class="s1">, {</span>
      <span class="s1">dark: headerDarkContent,</span>
      <span class="s1">layout: layout,</span>
      <span class="s1">insets: insets,</span>
      <span class="s1">style: cardStyle</span>
    <span class="s1">}) : </span><span class="s2">null</span><span class="s1">, </span><span class="s4">/*#__PURE__*/</span><span class="s1">React.createElement(_reactNative.Animated.View, {</span>
      <span class="s1">style: {</span>
        <span class="s4">// This is a dummy style that doesn't actually change anything visually.</span>
        <span class="s4">// Animated needs the animated value to be used somewhere, otherwise things don't update properly.</span>
        <span class="s4">// If we disable animations and hide header, it could end up making the value unused.</span>
        <span class="s4">// So we have this dummy style that will always be used regardless of what else changed.</span>
        <span class="s1">opacity: current</span>
      <span class="s1">}</span>
      <span class="s4">// Make sure that this view isn't removed. If this view is removed, our style with animated value won't apply</span>
      <span class="s1">,</span>
      <span class="s1">collapsable: </span><span class="s2">false</span>
    <span class="s1">}), </span><span class="s4">/*#__PURE__*/</span><span class="s1">React.createElement(_reactNative.View, _extends({</span>
      <span class="s1">pointerEvents: </span><span class="s0">&quot;box-none&quot;</span>
    <span class="s1">}, rest), overlayEnabled ? </span><span class="s4">/*#__PURE__*/</span><span class="s1">React.createElement(_reactNative.View, {</span>
      <span class="s1">pointerEvents: </span><span class="s0">&quot;box-none&quot;</span><span class="s1">,</span>
      <span class="s1">style: _reactNative.StyleSheet.absoluteFill</span>
    <span class="s1">}, overlay({</span>
      <span class="s1">style: overlayStyle</span>
    <span class="s1">})) : </span><span class="s2">null</span><span class="s1">, </span><span class="s4">/*#__PURE__*/</span><span class="s1">React.createElement(_reactNative.Animated.View, {</span>
      <span class="s1">style: [styles.container, containerStyle, customContainerStyle],</span>
      <span class="s1">pointerEvents: </span><span class="s0">&quot;box-none&quot;</span>
    <span class="s1">}, </span><span class="s4">/*#__PURE__*/</span><span class="s1">React.createElement(_GestureHandler.PanGestureHandler, _extends({</span>
      <span class="s1">enabled: layout.width !== </span><span class="s3">0 </span><span class="s1">&amp;&amp; gestureEnabled,</span>
      <span class="s1">onGestureEvent: handleGestureEvent,</span>
      <span class="s1">onHandlerStateChange: </span><span class="s2">this</span><span class="s1">.handleGestureStateChange</span>
    <span class="s1">}, </span><span class="s2">this</span><span class="s1">.gestureActivationCriteria()), </span><span class="s4">/*#__PURE__*/</span><span class="s1">React.createElement(_reactNative.Animated.View, {</span>
      <span class="s1">needsOffscreenAlphaCompositing: hasOpacityStyle(cardStyle),</span>
      <span class="s1">style: [styles.container, cardStyle]</span>
    <span class="s1">}, shadowEnabled &amp;&amp; shadowStyle &amp;&amp; !isTransparent ? </span><span class="s4">/*#__PURE__*/</span><span class="s1">React.createElement(_reactNative.Animated.View, {</span>
      <span class="s1">style: [styles.shadow, gestureDirection === </span><span class="s0">'horizontal' </span><span class="s1">? [styles.shadowHorizontal, styles.shadowLeft] : gestureDirection === </span><span class="s0">'horizontal-inverted' </span><span class="s1">? [styles.shadowHorizontal, styles.shadowRight] : gestureDirection === </span><span class="s0">'vertical' </span><span class="s1">? [styles.shadowVertical, styles.shadowTop] : [styles.shadowVertical, styles.shadowBottom], {</span>
        <span class="s1">backgroundColor</span>
      <span class="s1">}, shadowStyle],</span>
      <span class="s1">pointerEvents: </span><span class="s0">&quot;none&quot;</span>
    <span class="s1">}) : </span><span class="s2">null</span><span class="s1">, </span><span class="s4">/*#__PURE__*/</span><span class="s1">React.createElement(_CardSheet.</span><span class="s2">default</span><span class="s1">, {</span>
      <span class="s1">ref: </span><span class="s2">this</span><span class="s1">.ref,</span>
      <span class="s1">enabled: pageOverflowEnabled,</span>
      <span class="s1">layout: layout,</span>
      <span class="s1">style: contentStyle</span>
    <span class="s1">}, children))))));</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">exports.</span><span class="s2">default </span><span class="s1">= Card;</span>
<span class="s1">const getIsModalPresentation = cardStyleInterpolator =&gt; {</span>
  <span class="s2">return </span><span class="s1">cardStyleInterpolator === _CardStyleInterpolators.forModalPresentationIOS ||</span>
  <span class="s4">// Handle custom modal presentation interpolators as well</span>
  <span class="s1">cardStyleInterpolator.name === </span><span class="s0">'forModalPresentationIOS'</span><span class="s1">;</span>
<span class="s1">};</span>
<span class="s1">exports.getIsModalPresentation = getIsModalPresentation;</span>
<span class="s1">const styles = _reactNative.StyleSheet.create({</span>
  <span class="s1">container: {</span>
    <span class="s1">flex: </span><span class="s3">1</span>
  <span class="s1">},</span>
  <span class="s1">overlay: {</span>
    <span class="s1">flex: </span><span class="s3">1</span><span class="s1">,</span>
    <span class="s1">backgroundColor: </span><span class="s0">'#000'</span>
  <span class="s1">},</span>
  <span class="s1">shadow: {</span>
    <span class="s1">position: </span><span class="s0">'absolute'</span><span class="s1">,</span>
    <span class="s1">shadowRadius: </span><span class="s3">5</span><span class="s1">,</span>
    <span class="s1">shadowColor: </span><span class="s0">'#000'</span><span class="s1">,</span>
    <span class="s1">shadowOpacity: </span><span class="s3">0.3</span>
  <span class="s1">},</span>
  <span class="s1">shadowHorizontal: {</span>
    <span class="s1">top: </span><span class="s3">0</span><span class="s1">,</span>
    <span class="s1">bottom: </span><span class="s3">0</span><span class="s1">,</span>
    <span class="s1">width: </span><span class="s3">3</span><span class="s1">,</span>
    <span class="s1">shadowOffset: {</span>
      <span class="s1">width: -</span><span class="s3">1</span><span class="s1">,</span>
      <span class="s1">height: </span><span class="s3">1</span>
    <span class="s1">}</span>
  <span class="s1">},</span>
  <span class="s1">shadowLeft: {</span>
    <span class="s1">left: </span><span class="s3">0</span>
  <span class="s1">},</span>
  <span class="s1">shadowRight: {</span>
    <span class="s1">right: </span><span class="s3">0</span>
  <span class="s1">},</span>
  <span class="s1">shadowVertical: {</span>
    <span class="s1">left: </span><span class="s3">0</span><span class="s1">,</span>
    <span class="s1">right: </span><span class="s3">0</span><span class="s1">,</span>
    <span class="s1">height: </span><span class="s3">3</span><span class="s1">,</span>
    <span class="s1">shadowOffset: {</span>
      <span class="s1">width: </span><span class="s3">1</span><span class="s1">,</span>
      <span class="s1">height: -</span><span class="s3">1</span>
    <span class="s1">}</span>
  <span class="s1">},</span>
  <span class="s1">shadowTop: {</span>
    <span class="s1">top: </span><span class="s3">0</span>
  <span class="s1">},</span>
  <span class="s1">shadowBottom: {</span>
    <span class="s1">bottom: </span><span class="s3">0</span>
  <span class="s1">}</span>
<span class="s1">});</span>
<span class="s4">//# sourceMappingURL=Card.js.map</span></pre>
</body>
</html>
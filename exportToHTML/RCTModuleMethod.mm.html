<html>
<head>
<title>RCTModuleMethod.mm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #bbb529;}
.s3 { color: #6a8759;}
.s4 { color: #cc7832;}
.s5 { color: #6897bb;}
.s6 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
RCTModuleMethod.mm</font>
</center></td></tr></table>
<pre><span class="s0">/* 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>

<span class="s2">#import </span><span class="s3">&quot;RCTModuleMethod.h&quot;</span>

<span class="s2">#import </span><span class="s3">&lt;objc/message.h&gt;</span>

<span class="s2">#import </span><span class="s3">&quot;RCTAssert.h&quot;</span>
<span class="s2">#import </span><span class="s3">&quot;RCTBridge+Private.h&quot;</span>
<span class="s2">#import </span><span class="s3">&quot;RCTBridge.h&quot;</span>
<span class="s2">#import </span><span class="s3">&quot;RCTConvert.h&quot;</span>
<span class="s2">#import </span><span class="s3">&quot;RCTCxxConvert.h&quot;</span>
<span class="s2">#import </span><span class="s3">&quot;RCTLog.h&quot;</span>
<span class="s2">#import </span><span class="s3">&quot;RCTManagedPointer.h&quot;</span>
<span class="s2">#import </span><span class="s3">&quot;RCTParserUtils.h&quot;</span>
<span class="s2">#import </span><span class="s3">&quot;RCTProfile.h&quot;</span>
<span class="s2">#import </span><span class="s3">&quot;RCTUtils.h&quot;</span>

<span class="s4">typedef </span><span class="s1">BOOL (^RCTArgumentBlock)(RCTBridge *</span><span class="s4">, </span><span class="s1">NSUInteger</span><span class="s4">, </span><span class="s1">id)</span><span class="s4">;</span>

<span class="s0">/** 
 * Get the converter function for the specified type 
 */</span>
<span class="s4">static </span><span class="s1">SEL selectorForType(NSString *type)</span>
<span class="s1">{</span>
  <span class="s4">const char </span><span class="s1">*input = type.UTF8String</span><span class="s4">;</span>
  <span class="s4">return </span><span class="s1">NSSelectorFromString([RCTParseType(&amp;input) stringByAppendingString:</span><span class="s4">@</span><span class="s3">&quot;:&quot;</span><span class="s1">])</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">@implementation </span><span class="s1">RCTMethodArgument</span>

<span class="s1">- (instancetype)initWithType:(NSString *)type nullability:(RCTNullability)nullability unused:(BOOL)unused</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(self = [super init]) {</span>
    <span class="s1">_type = [type copy]</span><span class="s4">;</span>
    <span class="s1">_nullability = nullability</span><span class="s4">;</span>
    <span class="s1">_unused = unused</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">return </span><span class="s1">self</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">@end</span>

<span class="s4">@implementation </span><span class="s1">RCTModuleMethod {</span>
  <span class="s1">Class _moduleClass</span><span class="s4">;</span>
  <span class="s4">const </span><span class="s1">RCTMethodInfo *_methodInfo</span><span class="s4">;</span>
  <span class="s1">NSString *_JSMethodName</span><span class="s4">;</span>

  <span class="s1">SEL _selector</span><span class="s4">;</span>
  <span class="s1">NSInvocation *_invocation</span><span class="s4">;</span>
  <span class="s1">NSArray&lt;RCTArgumentBlock&gt; *_argumentBlocks</span><span class="s4">;</span>
  <span class="s1">NSMutableArray *_retainedObjects</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">static void </span><span class="s1">RCTLogArgumentError(RCTModuleMethod *method</span><span class="s4">, </span><span class="s1">NSUInteger index</span><span class="s4">, </span><span class="s1">id valueOrType</span><span class="s4">, const char </span><span class="s1">*issue)</span>
<span class="s1">{</span>
  <span class="s1">RCTLogError(</span>
      <span class="s4">@</span><span class="s3">&quot;Argument %tu (%@) of %@.%s %s&quot;</span><span class="s4">,</span>
      <span class="s1">index</span><span class="s4">,</span>
      <span class="s1">valueOrType</span><span class="s4">,</span>
      <span class="s1">RCTBridgeModuleNameForClass(method-&gt;_moduleClass)</span><span class="s4">,</span>
      <span class="s1">method.JSMethodName</span><span class="s4">,</span>
      <span class="s1">issue)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">RCT_NOT_IMPLEMENTED(-(instancetype)init)</span>

<span class="s1">RCT_EXTERN_C_BEGIN</span>

<span class="s0">// returns YES if the selector ends in a colon (indicating that there is at</span>
<span class="s0">// least one argument, and maybe more selector parts) or NO if it doesn't.</span>
<span class="s4">static </span><span class="s1">BOOL RCTParseSelectorPart(</span><span class="s4">const char </span><span class="s1">**input</span><span class="s4">, </span><span class="s1">NSMutableString *</span><span class="s4">selector</span><span class="s1">)</span>
<span class="s1">{</span>
  <span class="s1">NSString *selectorPart</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(RCTParseSelectorIdentifier(input</span><span class="s4">, </span><span class="s1">&amp;selectorPart)) {</span>
    <span class="s1">[</span><span class="s4">selector </span><span class="s1">appendString:selectorPart]</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s1">RCTSkipWhitespace(input)</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(RCTReadChar(input</span><span class="s4">, </span><span class="s3">':'</span><span class="s1">)) {</span>
    <span class="s1">[</span><span class="s4">selector </span><span class="s1">appendString:</span><span class="s4">@</span><span class="s3">&quot;:&quot;</span><span class="s1">]</span><span class="s4">;</span>
    <span class="s1">RCTSkipWhitespace(input)</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">YES</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">return </span><span class="s1">NO</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">static </span><span class="s1">BOOL RCTParseUnused(</span><span class="s4">const char </span><span class="s1">**input)</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">RCTReadString(input</span><span class="s4">, </span><span class="s3">&quot;__attribute__((unused))&quot;</span><span class="s1">) || RCTReadString(input</span><span class="s4">, </span><span class="s3">&quot;__attribute__((__unused__))&quot;</span><span class="s1">) ||</span>
      <span class="s1">RCTReadString(input</span><span class="s4">, </span><span class="s3">&quot;__unused&quot;</span><span class="s1">) || RCTReadString(input</span><span class="s4">, </span><span class="s3">&quot;[[maybe_unused]]&quot;</span><span class="s1">)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">static </span><span class="s1">RCTNullability RCTParseNullability(</span><span class="s4">const char </span><span class="s1">**input)</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(RCTReadString(input</span><span class="s4">, </span><span class="s3">&quot;nullable&quot;</span><span class="s1">)) {</span>
    <span class="s4">return </span><span class="s1">RCTNullable</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else if </span><span class="s1">(RCTReadString(input</span><span class="s4">, </span><span class="s3">&quot;nonnull&quot;</span><span class="s1">)) {</span>
    <span class="s4">return </span><span class="s1">RCTNonnullable</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">return </span><span class="s1">RCTNullabilityUnspecified</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">static </span><span class="s1">RCTNullability RCTParseNullabilityPostfix(</span><span class="s4">const char </span><span class="s1">**input)</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(RCTReadString(input</span><span class="s4">, </span><span class="s3">&quot;_Nullable&quot;</span><span class="s1">) || RCTReadString(input</span><span class="s4">, </span><span class="s3">&quot;__nullable&quot;</span><span class="s1">)) {</span>
    <span class="s4">return </span><span class="s1">RCTNullable</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else if </span><span class="s1">(RCTReadString(input</span><span class="s4">, </span><span class="s3">&quot;_Nonnull&quot;</span><span class="s1">) || RCTReadString(input</span><span class="s4">, </span><span class="s3">&quot;__nonnull&quot;</span><span class="s1">)) {</span>
    <span class="s4">return </span><span class="s1">RCTNonnullable</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">return </span><span class="s1">RCTNullabilityUnspecified</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s0">// returns YES if execution is safe to proceed (enqueue callback invocation), NO if callback has already been invoked</span>
<span class="s2">#if </span><span class="s1">RCT_DEBUG</span>
<span class="s4">static </span><span class="s1">BOOL checkCallbackMultipleInvocations(BOOL *didInvoke)</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(*didInvoke) {</span>
    <span class="s1">RCTFatal(RCTErrorWithMessage(</span>
        <span class="s4">@</span><span class="s3">&quot;Illegal callback invocation from native module. This callback type only permits a single invocation from native code.&quot;</span><span class="s1">))</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">NO</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s1">*didInvoke = YES</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">YES</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">#endif</span>

<span class="s1">NSString *RCTParseMethodSignature(</span><span class="s4">const char </span><span class="s1">*input</span><span class="s4">, </span><span class="s1">NSArray&lt;RCTMethodArgument *&gt; **arguments)</span>
<span class="s1">{</span>
  <span class="s1">RCTSkipWhitespace(&amp;input)</span><span class="s4">;</span>

  <span class="s1">NSMutableArray *args</span><span class="s4">;</span>
  <span class="s1">NSMutableString *</span><span class="s4">selector </span><span class="s1">= [NSMutableString </span><span class="s4">new</span><span class="s1">]</span><span class="s4">;</span>
  <span class="s4">while </span><span class="s1">(RCTParseSelectorPart(&amp;input</span><span class="s4">, selector</span><span class="s1">)) {</span>
    <span class="s4">if </span><span class="s1">(!args) {</span>
      <span class="s1">args = [NSMutableArray </span><span class="s4">new</span><span class="s1">]</span><span class="s4">;</span>
    <span class="s1">}</span>

    <span class="s0">// Parse type</span>
    <span class="s4">if </span><span class="s1">(RCTReadChar(&amp;input</span><span class="s4">, </span><span class="s3">'('</span><span class="s1">)) {</span>
      <span class="s1">RCTSkipWhitespace(&amp;input)</span><span class="s4">;</span>

      <span class="s0">// 5 cases that both nullable and __unused exist</span>
      <span class="s0">// 1: foo:(nullable __unused id)foo 2: foo:(nullable id __unused)foo</span>
      <span class="s0">// 3: foo:(__unused id _Nullable)foo 4: foo:(id __unused _Nullable)foo</span>
      <span class="s0">// 5: foo:(id _Nullable __unused)foo</span>
      <span class="s1">RCTNullability nullability = RCTParseNullability(&amp;input)</span><span class="s4">;</span>
      <span class="s1">RCTSkipWhitespace(&amp;input)</span><span class="s4">;</span>

      <span class="s1">BOOL unused = RCTParseUnused(&amp;input)</span><span class="s4">;</span>
      <span class="s1">RCTSkipWhitespace(&amp;input)</span><span class="s4">;</span>

      <span class="s1">NSString *type = RCTParseType(&amp;input)</span><span class="s4">;</span>
      <span class="s1">RCTSkipWhitespace(&amp;input)</span><span class="s4">;</span>

      <span class="s4">if </span><span class="s1">(nullability == RCTNullabilityUnspecified) {</span>
        <span class="s1">nullability = RCTParseNullabilityPostfix(&amp;input)</span><span class="s4">;</span>
        <span class="s1">RCTSkipWhitespace(&amp;input)</span><span class="s4">;</span>
        <span class="s4">if </span><span class="s1">(!unused) {</span>
          <span class="s1">unused = RCTParseUnused(&amp;input)</span><span class="s4">;</span>
          <span class="s1">RCTSkipWhitespace(&amp;input)</span><span class="s4">;</span>
          <span class="s4">if </span><span class="s1">(unused &amp;&amp; nullability == RCTNullabilityUnspecified) {</span>
            <span class="s1">nullability = RCTParseNullabilityPostfix(&amp;input)</span><span class="s4">;</span>
            <span class="s1">RCTSkipWhitespace(&amp;input)</span><span class="s4">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s4">else if </span><span class="s1">(!unused) {</span>
        <span class="s1">unused = RCTParseUnused(&amp;input)</span><span class="s4">;</span>
        <span class="s1">RCTSkipWhitespace(&amp;input)</span><span class="s4">;</span>
      <span class="s1">}</span>
      <span class="s1">[args addObject:[[RCTMethodArgument alloc] initWithType:type nullability:nullability unused:unused]]</span><span class="s4">;</span>
      <span class="s1">RCTSkipWhitespace(&amp;input)</span><span class="s4">;</span>
      <span class="s1">RCTReadChar(&amp;input</span><span class="s4">, </span><span class="s3">')'</span><span class="s1">)</span><span class="s4">;</span>
      <span class="s1">RCTSkipWhitespace(&amp;input)</span><span class="s4">;</span>
    <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
      <span class="s0">// Type defaults to id if unspecified</span>
      <span class="s1">[args addObject:[[RCTMethodArgument alloc] initWithType:</span><span class="s4">@</span><span class="s3">&quot;id&quot; </span><span class="s1">nullability:RCTNullable unused:NO]]</span><span class="s4">;</span>
    <span class="s1">}</span>

    <span class="s0">// Argument name</span>
    <span class="s1">RCTParseArgumentIdentifier(&amp;input</span><span class="s4">, </span><span class="s1">NULL)</span><span class="s4">;</span>
    <span class="s1">RCTSkipWhitespace(&amp;input)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">*arguments = [args copy]</span><span class="s4">;</span>
  <span class="s4">return selector;</span>
<span class="s1">}</span>

<span class="s1">RCT_EXTERN_C_END</span>

<span class="s1">- (instancetype)initWithExportedMethod:(</span><span class="s4">const </span><span class="s1">RCTMethodInfo *)exportedMethod moduleClass:(Class)moduleClass</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(self = [super init]) {</span>
    <span class="s1">_moduleClass = moduleClass</span><span class="s4">;</span>
    <span class="s1">_methodInfo = exportedMethod</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">return </span><span class="s1">self</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)processMethodSignature</span>
<span class="s1">{</span>
  <span class="s1">NSArray&lt;RCTMethodArgument *&gt; *arguments</span><span class="s4">;</span>
  <span class="s1">_selector = NSSelectorFromString(RCTParseMethodSignature(_methodInfo-&gt;objcName</span><span class="s4">, </span><span class="s1">&amp;arguments))</span><span class="s4">;</span>
  <span class="s1">RCTAssert(_selector</span><span class="s4">, @</span><span class="s3">&quot;%s is not a valid selector&quot;</span><span class="s4">, </span><span class="s1">_methodInfo-&gt;objcName)</span><span class="s4">;</span>

  <span class="s0">// Create method invocation</span>
  <span class="s1">NSMethodSignature *methodSignature = [_moduleClass instanceMethodSignatureForSelector:_selector]</span><span class="s4">;</span>
  <span class="s1">RCTAssert(methodSignature</span><span class="s4">, @</span><span class="s3">&quot;%s is not a recognized Objective-C method.&quot;</span><span class="s4">, </span><span class="s1">sel_getName(_selector))</span><span class="s4">;</span>
  <span class="s1">NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:methodSignature]</span><span class="s4">;</span>
  <span class="s1">invocation.</span><span class="s4">selector </span><span class="s1">= _selector</span><span class="s4">;</span>
  <span class="s1">_invocation = invocation</span><span class="s4">;</span>
  <span class="s1">NSMutableArray *retainedObjects = [NSMutableArray array]</span><span class="s4">;</span>
  <span class="s1">_retainedObjects = retainedObjects</span><span class="s4">;</span>

  <span class="s0">// Process arguments</span>
  <span class="s1">NSUInteger numberOfArguments = methodSignature.numberOfArguments</span><span class="s4">;</span>
  <span class="s1">NSMutableArray&lt;RCTArgumentBlock&gt; *argumentBlocks = [[NSMutableArray alloc] initWithCapacity:numberOfArguments - </span><span class="s5">2</span><span class="s1">]</span><span class="s4">;</span>

<span class="s2">#if </span><span class="s1">RCT_DEBUG</span>
  <span class="s4">__weak </span><span class="s1">RCTModuleMethod *weakSelf = self</span><span class="s4">;</span>
<span class="s2">#endif</span>

<span class="s2">#define </span><span class="s1">RCT_RETAINED_ARG_BLOCK(_logic)                                                         \ 
  [argumentBlocks addObject:^(__unused </span><span class="s4">__weak </span><span class="s1">RCTBridge * bridge</span><span class="s4">, </span><span class="s1">NSUInteger index</span><span class="s4">, </span><span class="s1">id json) { \ 
    _logic [invocation setArgument:&amp;value atIndex:(index) + </span><span class="s5">2</span><span class="s1">]</span><span class="s4">;                                </span><span class="s1">\ 
    </span><span class="s4">if </span><span class="s1">(value) {                                                                               \ 
      [retainedObjects addObject:value]</span><span class="s4">;                                                       </span><span class="s1">\ 
    }                                                                                          \ 
    </span><span class="s4">return </span><span class="s1">YES</span><span class="s4">;                                                                                </span><span class="s1">\ 
  }]</span>

<span class="s2">#define </span><span class="s1">__PRIMITIVE_CASE(_type</span><span class="s4">, </span><span class="s1">_nullable)                                                \ 
  {                                                                                       \ 
    isNullableType = _nullable</span><span class="s4">;                                                           </span><span class="s1">\ 
    _type (*convert)(id</span><span class="s4">, </span><span class="s1">SEL</span><span class="s4">, </span><span class="s1">id) = (</span><span class="s4">__typeof__</span><span class="s1">(convert))objc_msgSend</span><span class="s4">;                    </span><span class="s1">\ 
    [argumentBlocks addObject:^(__unused RCTBridge * bridge</span><span class="s4">, </span><span class="s1">NSUInteger index</span><span class="s4">, </span><span class="s1">id json) { \ 
      _type value = convert([RCTConvert </span><span class="s4">class</span><span class="s1">]</span><span class="s4">, selector, </span><span class="s1">json)</span><span class="s4">;                          </span><span class="s1">\ 
      [invocation setArgument:&amp;value atIndex:(index) + </span><span class="s5">2</span><span class="s1">]</span><span class="s4">;                                </span><span class="s1">\ 
      </span><span class="s4">return </span><span class="s1">YES</span><span class="s4">;                                                                         </span><span class="s1">\ 
    }]</span><span class="s4">;                                                                                   </span><span class="s1">\ 
    </span><span class="s4">break;                                                                                </span><span class="s1">\ 
  }</span>

<span class="s2">#define </span><span class="s1">PRIMITIVE_CASE(_type) __PRIMITIVE_CASE(_type</span><span class="s4">, </span><span class="s1">NO)</span>
<span class="s2">#define </span><span class="s1">NULLABLE_PRIMITIVE_CASE(_type) __PRIMITIVE_CASE(_type</span><span class="s4">, </span><span class="s1">YES)</span>

<span class="s0">// Explicitly copy the block</span>
<span class="s2">#define </span><span class="s1">__COPY_BLOCK(block...)         \ 
  id value = [block copy]</span><span class="s4">;             </span><span class="s1">\ 
  </span><span class="s4">if </span><span class="s1">(value) {                         \ 
    [retainedObjects addObject:value]</span><span class="s4">; </span><span class="s1">\ 
  }</span>

<span class="s2">#if </span><span class="s1">RCT_DEBUG</span>
<span class="s2">#define </span><span class="s1">BLOCK_CASE(_block_args</span><span class="s4">, </span><span class="s1">_block)                                        \ 
  RCT_RETAINED_ARG_BLOCK(</span><span class="s4">if </span><span class="s1">(json &amp;&amp; ![json isKindOfClass:[NSNumber </span><span class="s4">class</span><span class="s1">]]) { \ 
    RCTLogArgumentError(weakSelf</span><span class="s4">, </span><span class="s1">index</span><span class="s4">, </span><span class="s1">json</span><span class="s4">, </span><span class="s3">&quot;should be a function&quot;</span><span class="s1">)</span><span class="s4">;        </span><span class="s1">\ 
    </span><span class="s4">return </span><span class="s1">NO</span><span class="s4">;                                                                 </span><span class="s1">\ 
  } __block BOOL didInvoke = NO</span><span class="s4">;                                               </span><span class="s1">\ 
                         __COPY_BLOCK(^_block_args {                           \ 
                           </span><span class="s4">if </span><span class="s1">(checkCallbackMultipleInvocations(&amp;didInvoke))   \ 
                             _block                                            \ 
                         })</span><span class="s4">;</span><span class="s1">)</span>
<span class="s2">#else</span>
<span class="s2">#define </span><span class="s1">BLOCK_CASE(_block_args</span><span class="s4">, </span><span class="s1">_block)             \ 
  RCT_RETAINED_ARG_BLOCK(__COPY_BLOCK(^_block_args{ \ 
      _block})</span><span class="s4">;</span><span class="s1">)</span>
<span class="s2">#endif</span>

  <span class="s4">for </span><span class="s1">(NSUInteger i = </span><span class="s5">2</span><span class="s4">; </span><span class="s1">i &lt; numberOfArguments</span><span class="s4">; </span><span class="s1">i++) {</span>
    <span class="s4">const char </span><span class="s1">*objcType = [methodSignature getArgumentTypeAtIndex:i]</span><span class="s4">;</span>
    <span class="s1">BOOL isNullableType = NO</span><span class="s4">;</span>
    <span class="s1">RCTMethodArgument *argument = arguments[i - </span><span class="s5">2</span><span class="s1">]</span><span class="s4">;</span>
    <span class="s1">NSString *typeName = argument.type</span><span class="s4">;</span>
    <span class="s1">SEL </span><span class="s4">selector </span><span class="s1">= selectorForType(typeName)</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">([RCTConvert respondsToSelector:</span><span class="s4">selector</span><span class="s1">]) {</span>
      <span class="s4">switch </span><span class="s1">(objcType[</span><span class="s5">0</span><span class="s1">]) {</span>
        <span class="s0">// Primitives</span>
        <span class="s4">case </span><span class="s1">_C_CHR:</span>
          <span class="s1">PRIMITIVE_CASE(</span><span class="s4">char</span><span class="s1">)</span>
        <span class="s4">case </span><span class="s1">_C_UCHR:</span>
          <span class="s1">PRIMITIVE_CASE(</span><span class="s4">unsigned char</span><span class="s1">)</span>
        <span class="s4">case </span><span class="s1">_C_SHT:</span>
          <span class="s1">PRIMITIVE_CASE(</span><span class="s4">short</span><span class="s1">)</span>
        <span class="s4">case </span><span class="s1">_C_USHT:</span>
          <span class="s1">PRIMITIVE_CASE(</span><span class="s4">unsigned short</span><span class="s1">)</span>
        <span class="s4">case </span><span class="s1">_C_INT:</span>
          <span class="s1">PRIMITIVE_CASE(</span><span class="s4">int</span><span class="s1">)</span>
        <span class="s4">case </span><span class="s1">_C_UINT:</span>
          <span class="s1">PRIMITIVE_CASE(</span><span class="s4">unsigned int</span><span class="s1">)</span>
        <span class="s4">case </span><span class="s1">_C_LNG:</span>
          <span class="s1">PRIMITIVE_CASE(</span><span class="s4">long</span><span class="s1">)</span>
        <span class="s4">case </span><span class="s1">_C_ULNG:</span>
          <span class="s1">PRIMITIVE_CASE(</span><span class="s4">unsigned long</span><span class="s1">)</span>
        <span class="s4">case </span><span class="s1">_C_LNG_LNG:</span>
          <span class="s1">PRIMITIVE_CASE(</span><span class="s4">long long</span><span class="s1">)</span>
        <span class="s4">case </span><span class="s1">_C_ULNG_LNG:</span>
          <span class="s1">PRIMITIVE_CASE(</span><span class="s4">unsigned long long</span><span class="s1">)</span>
        <span class="s4">case </span><span class="s1">_C_FLT:</span>
          <span class="s1">PRIMITIVE_CASE(</span><span class="s4">float</span><span class="s1">)</span>
        <span class="s4">case </span><span class="s1">_C_DBL:</span>
          <span class="s1">PRIMITIVE_CASE(</span><span class="s4">double</span><span class="s1">)</span>
        <span class="s4">case </span><span class="s1">_C_BOOL:</span>
          <span class="s1">PRIMITIVE_CASE(BOOL)</span>
        <span class="s4">case </span><span class="s1">_C_SEL:</span>
          <span class="s1">NULLABLE_PRIMITIVE_CASE(SEL)</span>
        <span class="s4">case </span><span class="s1">_C_CHARPTR:</span>
          <span class="s1">NULLABLE_PRIMITIVE_CASE(</span><span class="s4">const char </span><span class="s1">*)</span>
        <span class="s4">case </span><span class="s1">_C_PTR:</span>
          <span class="s1">NULLABLE_PRIMITIVE_CASE(</span><span class="s4">void </span><span class="s1">*)</span>

        <span class="s4">case </span><span class="s1">_C_ID: {</span>
          <span class="s1">isNullableType = YES</span><span class="s4">;</span>
          <span class="s1">id (*convert)(id</span><span class="s4">, </span><span class="s1">SEL</span><span class="s4">, </span><span class="s1">id) = (</span><span class="s4">__typeof__</span><span class="s1">(convert))objc_msgSend</span><span class="s4">;</span>
          <span class="s1">RCT_RETAINED_ARG_BLOCK(id value = convert([RCTConvert </span><span class="s4">class</span><span class="s1">]</span><span class="s4">, selector, </span><span class="s1">json)</span><span class="s4">;</span><span class="s1">)</span><span class="s4">;</span>
          <span class="s4">break;</span>
        <span class="s1">}</span>

        <span class="s4">case </span><span class="s1">_C_STRUCT_B: {</span>
          <span class="s1">NSMethodSignature *typeSignature = [RCTConvert methodSignatureForSelector:</span><span class="s4">selector</span><span class="s1">]</span><span class="s4">;</span>
          <span class="s1">NSInvocation *typeInvocation = [NSInvocation invocationWithMethodSignature:typeSignature]</span><span class="s4">;</span>
          <span class="s1">typeInvocation.</span><span class="s4">selector </span><span class="s1">= </span><span class="s4">selector;</span>
          <span class="s1">typeInvocation.target = [RCTConvert </span><span class="s4">class</span><span class="s1">]</span><span class="s4">;</span>

          <span class="s1">[argumentBlocks addObject:^(__unused RCTBridge *bridge</span><span class="s4">, </span><span class="s1">NSUInteger index</span><span class="s4">, </span><span class="s1">id json) {</span>
            <span class="s4">void </span><span class="s1">*returnValue = malloc(typeSignature.methodReturnLength)</span><span class="s4">;</span>
            <span class="s4">if </span><span class="s1">(!returnValue) {</span>
              <span class="s0">// CWE - 391 : Unchecked error condition</span>
              <span class="s0">// https://www.cvedetails.com/cwe-details/391/Unchecked-Error-Condition.html</span>
              <span class="s0">// https://eli.thegreenplace.net/2009/10/30/handling-out-of-memory-conditions-in-c</span>
              <span class="s1">abort()</span><span class="s4">;</span>
            <span class="s1">}</span>
            <span class="s1">[typeInvocation setArgument:&amp;json atIndex:</span><span class="s5">2</span><span class="s1">]</span><span class="s4">;</span>
            <span class="s1">[typeInvocation invoke]</span><span class="s4">;</span>
            <span class="s1">[typeInvocation getReturnValue:returnValue]</span><span class="s4">;</span>
            <span class="s1">[invocation setArgument:returnValue atIndex:index + </span><span class="s5">2</span><span class="s1">]</span><span class="s4">;</span>
            <span class="s1">free(returnValue)</span><span class="s4">;</span>
            <span class="s4">return </span><span class="s1">YES</span><span class="s4">;</span>
          <span class="s1">}]</span><span class="s4">;</span>
          <span class="s4">break;</span>
        <span class="s1">}</span>

        <span class="s4">default</span><span class="s1">: {</span>
          <span class="s4">static const char </span><span class="s1">*blockType = </span><span class="s4">@encode</span><span class="s1">(</span><span class="s4">__typeof__</span><span class="s1">(^{</span>
          <span class="s1">}))</span><span class="s4">;</span>
          <span class="s4">if </span><span class="s1">(!strcmp(objcType</span><span class="s4">, </span><span class="s1">blockType)) {</span>
            <span class="s1">BLOCK_CASE((NSArray * args)</span><span class="s4">, </span><span class="s1">{ [bridge enqueueCallback:json args:args]</span><span class="s4">; </span><span class="s1">})</span><span class="s4">;</span>
          <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
            <span class="s1">RCTLogError(</span><span class="s4">@</span><span class="s3">&quot;Unsupported argument type '%@' in method %@.&quot;</span><span class="s4">, </span><span class="s1">typeName</span><span class="s4">, </span><span class="s1">[self methodName])</span><span class="s4">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s4">else if </span><span class="s1">([typeName isEqualToString:</span><span class="s4">@</span><span class="s3">&quot;RCTResponseSenderBlock&quot;</span><span class="s1">]) {</span>
      <span class="s1">BLOCK_CASE((NSArray * args)</span><span class="s4">, </span><span class="s1">{ [bridge enqueueCallback:json args:args]</span><span class="s4">; </span><span class="s1">})</span><span class="s4">;</span>
    <span class="s1">} </span><span class="s4">else if </span><span class="s1">([typeName isEqualToString:</span><span class="s4">@</span><span class="s3">&quot;RCTResponseErrorBlock&quot;</span><span class="s1">]) {</span>
      <span class="s1">BLOCK_CASE((NSError * error)</span><span class="s4">, </span><span class="s1">{ [bridge enqueueCallback:json args:</span><span class="s4">@</span><span class="s1">[ RCTJSErrorFromNSError(error) ]]</span><span class="s4">; </span><span class="s1">})</span><span class="s4">;</span>
    <span class="s1">} </span><span class="s4">else if </span><span class="s1">([typeName isEqualToString:</span><span class="s4">@</span><span class="s3">&quot;RCTPromiseResolveBlock&quot;</span><span class="s1">]) {</span>
      <span class="s1">RCTAssert(</span>
          <span class="s1">i == numberOfArguments - </span><span class="s5">2</span><span class="s4">,</span>
          <span class="s4">@</span><span class="s3">&quot;The RCTPromiseResolveBlock must be the second to last parameter in %@&quot;</span><span class="s4">,</span>
          <span class="s1">[self methodName])</span><span class="s4">;</span>
      <span class="s1">BLOCK_CASE((id result)</span><span class="s4">, </span><span class="s1">{ [bridge enqueueCallback:json args:result ? </span><span class="s4">@</span><span class="s1">[ result ] : </span><span class="s4">@</span><span class="s1">[]]</span><span class="s4">; </span><span class="s1">})</span><span class="s4">;</span>
    <span class="s1">} </span><span class="s4">else if </span><span class="s1">([typeName isEqualToString:</span><span class="s4">@</span><span class="s3">&quot;RCTPromiseRejectBlock&quot;</span><span class="s1">]) {</span>
      <span class="s1">RCTAssert(</span>
          <span class="s1">i == numberOfArguments - </span><span class="s5">1</span><span class="s4">, @</span><span class="s3">&quot;The RCTPromiseRejectBlock must be the last parameter in %@&quot;</span><span class="s4">, </span><span class="s1">[self methodName])</span><span class="s4">;</span>
      <span class="s1">BLOCK_CASE((NSString * code</span><span class="s4">, </span><span class="s1">NSString * message</span><span class="s4">, </span><span class="s1">NSError * error)</span><span class="s4">, </span><span class="s1">{</span>
        <span class="s1">NSDictionary *errorJSON = RCTJSErrorFromCodeMessageAndNSError(code</span><span class="s4">, </span><span class="s1">message</span><span class="s4">, </span><span class="s1">error)</span><span class="s4">;</span>
        <span class="s1">[bridge enqueueCallback:json args:</span><span class="s4">@</span><span class="s1">[ errorJSON ]]</span><span class="s4">;</span>
      <span class="s1">})</span><span class="s4">;</span>
    <span class="s1">} </span><span class="s4">else if </span><span class="s1">([typeName hasPrefix:</span><span class="s4">@</span><span class="s3">&quot;JS::&quot;</span><span class="s1">]) {</span>
      <span class="s1">NSString *selectorNameForCxxType =</span>
          <span class="s1">[[typeName stringByReplacingOccurrencesOfString:</span><span class="s4">@</span><span class="s3">&quot;::&quot; </span><span class="s1">withString:</span><span class="s4">@</span><span class="s3">&quot;_&quot;</span><span class="s1">] stringByAppendingString:</span><span class="s4">@</span><span class="s3">&quot;:&quot;</span><span class="s1">]</span><span class="s4">;</span>
      <span class="s4">selector </span><span class="s1">= NSSelectorFromString(selectorNameForCxxType)</span><span class="s4">;</span>

      <span class="s1">[argumentBlocks addObject:^(__unused RCTBridge *bridge</span><span class="s4">, </span><span class="s1">NSUInteger index</span><span class="s4">, </span><span class="s1">id json) {</span>
        <span class="s1">RCTManagedPointer *(*convert)(id</span><span class="s4">, </span><span class="s1">SEL</span><span class="s4">, </span><span class="s1">id) = (</span><span class="s4">__typeof__</span><span class="s1">(convert))objc_msgSend</span><span class="s4">;</span>
        <span class="s1">RCTManagedPointer *box = convert([RCTCxxConvert </span><span class="s4">class</span><span class="s1">]</span><span class="s4">, selector, </span><span class="s1">json)</span><span class="s4">;</span>

        <span class="s4">void </span><span class="s1">*pointer = box.voidPointer</span><span class="s4">;</span>
        <span class="s1">[invocation setArgument:&amp;pointer atIndex:index + </span><span class="s5">2</span><span class="s1">]</span><span class="s4">;</span>
        <span class="s1">[retainedObjects addObject:box]</span><span class="s4">;</span>

        <span class="s4">return </span><span class="s1">YES</span><span class="s4">;</span>
      <span class="s1">}]</span><span class="s4">;</span>
    <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
      <span class="s0">// Unknown argument type</span>
      <span class="s1">RCTLogError(</span>
          <span class="s4">@</span><span class="s3">&quot;Unknown argument type '%@' in method %@. Extend RCTConvert to support this type.&quot;</span><span class="s4">,</span>
          <span class="s1">typeName</span><span class="s4">,</span>
          <span class="s1">[self methodName])</span><span class="s4">;</span>
    <span class="s1">}</span>

<span class="s2">#if </span><span class="s1">RCT_DEBUG</span>
    <span class="s1">RCTNullability nullability = argument.nullability</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">(!isNullableType) {</span>
      <span class="s4">if </span><span class="s1">(nullability == RCTNullable) {</span>
        <span class="s1">RCTLogArgumentError(</span>
            <span class="s1">weakSelf</span><span class="s4">,</span>
            <span class="s1">i - </span><span class="s5">2</span><span class="s4">,</span>
            <span class="s1">typeName</span><span class="s4">,</span>
            <span class="s3">&quot;is marked as &quot;</span>
            <span class="s3">&quot;nullable, but is not a nullable type.&quot;</span><span class="s1">)</span><span class="s4">;</span>
      <span class="s1">}</span>
      <span class="s1">nullability = RCTNonnullable</span><span class="s4">;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Special case - Numbers are not nullable in Android, so we 
     * don't support this for now. In future we may allow it. 
     */</span>
    <span class="s4">if </span><span class="s1">([typeName isEqualToString:</span><span class="s4">@</span><span class="s3">&quot;NSNumber&quot;</span><span class="s1">]) {</span>
      <span class="s1">BOOL unspecified = (nullability == RCTNullabilityUnspecified)</span><span class="s4">;</span>
      <span class="s4">if </span><span class="s1">(!argument.unused &amp;&amp; (nullability == RCTNullable || unspecified)) {</span>
        <span class="s1">RCTLogArgumentError(</span>
            <span class="s1">weakSelf</span><span class="s4">,</span>
            <span class="s1">i - </span><span class="s5">2</span><span class="s4">,</span>
            <span class="s1">typeName</span><span class="s4">,</span>
            <span class="s1">[unspecified ? </span><span class="s4">@</span><span class="s3">&quot;has unspecified nullability&quot; </span><span class="s1">: </span><span class="s4">@</span><span class="s3">&quot;is marked as nullable&quot;</span>
                <span class="s1">stringByAppendingString:</span><span class="s4">@</span><span class="s3">&quot; but React requires that all NSNumber &quot;</span>
                                         <span class="s3">&quot;arguments are explicitly marked as `nonnull` to ensure &quot;</span>
                                         <span class="s3">&quot;compatibility with Android.&quot;</span><span class="s1">]</span>
                <span class="s1">.UTF8String)</span><span class="s4">;</span>
      <span class="s1">}</span>
      <span class="s1">nullability = RCTNonnullable</span><span class="s4">;</span>
    <span class="s1">}</span>

    <span class="s4">if </span><span class="s1">(nullability == RCTNonnullable) {</span>
      <span class="s1">RCTArgumentBlock oldBlock = argumentBlocks[i - </span><span class="s5">2</span><span class="s1">]</span><span class="s4">;</span>
      <span class="s1">argumentBlocks[i - </span><span class="s5">2</span><span class="s1">] = ^(RCTBridge *bridge</span><span class="s4">, </span><span class="s1">NSUInteger index</span><span class="s4">, </span><span class="s1">id json) {</span>
        <span class="s4">if </span><span class="s1">(json != nil) {</span>
          <span class="s4">if </span><span class="s1">(!oldBlock(bridge</span><span class="s4">, </span><span class="s1">index</span><span class="s4">, </span><span class="s1">json)) {</span>
            <span class="s4">return </span><span class="s1">NO</span><span class="s4">;</span>
          <span class="s1">}</span>
          <span class="s4">if </span><span class="s1">(isNullableType) {</span>
            <span class="s0">// Check converted value wasn't null either, as method probably</span>
            <span class="s0">// won't gracefully handle a nil value for a nonull argument</span>
            <span class="s4">void </span><span class="s1">*value</span><span class="s4">;</span>
            <span class="s1">[invocation getArgument:&amp;value atIndex:index + </span><span class="s5">2</span><span class="s1">]</span><span class="s4">;</span>
            <span class="s4">if </span><span class="s1">(value == NULL) {</span>
              <span class="s4">return </span><span class="s1">NO</span><span class="s4">;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
          <span class="s4">return </span><span class="s1">YES</span><span class="s4">;</span>
        <span class="s1">}</span>
        <span class="s1">RCTLogArgumentError(weakSelf</span><span class="s4">, </span><span class="s1">index</span><span class="s4">, </span><span class="s1">typeName</span><span class="s4">, </span><span class="s3">&quot;must not be null&quot;</span><span class="s1">)</span><span class="s4">;</span>
        <span class="s4">return </span><span class="s1">NO</span><span class="s4">;</span>
      <span class="s1">}</span><span class="s4">;</span>
    <span class="s1">}</span>
<span class="s2">#endif</span>
  <span class="s1">}</span>

<span class="s2">#if </span><span class="s1">RCT_DEBUG</span>
  <span class="s4">const char </span><span class="s1">*objcType = _invocation.methodSignature.methodReturnType</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(_methodInfo-&gt;isSync &amp;&amp; objcType[</span><span class="s5">0</span><span class="s1">] != _C_ID) {</span>
    <span class="s1">RCTLogError(</span>
        <span class="s4">@</span><span class="s3">&quot;Return type of %@.%s should be (id) as the method is </span><span class="s4">\&quot;</span><span class="s3">sync</span><span class="s4">\&quot;</span><span class="s3">&quot;</span><span class="s4">,</span>
        <span class="s1">RCTBridgeModuleNameForClass(_moduleClass)</span><span class="s4">,</span>
        <span class="s1">self.JSMethodName)</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s2">#endif</span>

  <span class="s1">_argumentBlocks = argumentBlocks</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (SEL)</span><span class="s4">selector</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(_selector == NULL) {</span>
    <span class="s1">RCT_PROFILE_BEGIN_EVENT(</span>
        <span class="s1">RCTProfileTagAlways</span><span class="s4">,</span>
        <span class="s4">@</span><span class="s3">&quot;&quot;</span><span class="s4">,</span>
        <span class="s1">(</span><span class="s4">@</span><span class="s1">{</span><span class="s4">@</span><span class="s3">&quot;module&quot; </span><span class="s1">: NSStringFromClass(_moduleClass)</span><span class="s4">, @</span><span class="s3">&quot;method&quot; </span><span class="s1">: </span><span class="s4">@</span><span class="s1">(_methodInfo-&gt;objcName)}))</span><span class="s4">;</span>
    <span class="s1">[self processMethodSignature]</span><span class="s4">;</span>
    <span class="s1">RCT_PROFILE_END_EVENT(RCTProfileTagAlways</span><span class="s4">, @</span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">return </span><span class="s1">_selector</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">const char </span><span class="s1">*)JSMethodName</span>
<span class="s1">{</span>
  <span class="s1">NSString *methodName = _JSMethodName</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(!methodName) {</span>
    <span class="s4">const char </span><span class="s1">*jsName = _methodInfo-&gt;jsName</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">(jsName &amp;&amp; strlen(jsName) &gt; </span><span class="s5">0</span><span class="s1">) {</span>
      <span class="s1">methodName = </span><span class="s4">@</span><span class="s1">(jsName)</span><span class="s4">;</span>
    <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
      <span class="s1">methodName = </span><span class="s4">@</span><span class="s1">(_methodInfo-&gt;objcName)</span><span class="s4">;</span>
      <span class="s1">NSRange colonRange = [methodName rangeOfString:</span><span class="s4">@</span><span class="s3">&quot;:&quot;</span><span class="s1">]</span><span class="s4">;</span>
      <span class="s4">if </span><span class="s1">(colonRange.location != NSNotFound) {</span>
        <span class="s1">methodName = [methodName substringToIndex:colonRange.location]</span><span class="s4">;</span>
      <span class="s1">}</span>
      <span class="s1">methodName = [methodName stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]]</span><span class="s4">;</span>
      <span class="s1">RCTAssert(</span>
          <span class="s1">methodName.length</span><span class="s4">,</span>
          <span class="s4">@</span><span class="s3">&quot;%s is not a valid JS function name, please&quot;</span>
           <span class="s3">&quot; supply an alternative using RCT_REMAP_METHOD()&quot;</span><span class="s4">,</span>
          <span class="s1">_methodInfo-&gt;objcName)</span><span class="s4">;</span>
    <span class="s1">}</span>
    <span class="s1">_JSMethodName = methodName</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">return </span><span class="s1">methodName.UTF8String</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (RCTFunctionType)functionType</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(strstr(_methodInfo-&gt;objcName</span><span class="s4">, </span><span class="s3">&quot;RCTPromise&quot;</span><span class="s1">) != NULL) {</span>
    <span class="s1">RCTAssert(!_methodInfo-&gt;isSync</span><span class="s4">, @</span><span class="s3">&quot;Promises cannot be used in sync functions&quot;</span><span class="s1">)</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">RCTFunctionTypePromise</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else if </span><span class="s1">(_methodInfo-&gt;isSync) {</span>
    <span class="s4">return </span><span class="s1">RCTFunctionTypeSync</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s4">return </span><span class="s1">RCTFunctionTypeNormal</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (id)invokeWithBridge:(RCTBridge *)bridge module:(id)module arguments:(NSArray *)arguments</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(_argumentBlocks == nil) {</span>
    <span class="s1">[self processMethodSignature]</span><span class="s4">;</span>
  <span class="s1">}</span>

<span class="s2">#if </span><span class="s1">RCT_DEBUG</span>
  <span class="s0">// Sanity check</span>
  <span class="s1">RCTAssert([module </span><span class="s4">class</span><span class="s1">] == _moduleClass</span><span class="s4">, @</span><span class="s3">&quot;Attempted to invoke method </span><span class="s6">\</span>
            <span class="s3">%@ on a module of class %@&quot;</span><span class="s4">, </span><span class="s1">[self methodName]</span><span class="s4">, </span><span class="s1">[module </span><span class="s4">class</span><span class="s1">])</span><span class="s4">;</span>

  <span class="s0">// Safety check</span>
  <span class="s4">if </span><span class="s1">(arguments.count != _argumentBlocks.count) {</span>
    <span class="s1">NSInteger actualCount = arguments.count</span><span class="s4">;</span>
    <span class="s1">NSInteger expectedCount = _argumentBlocks.count</span><span class="s4">;</span>

    <span class="s0">// Subtract the implicit Promise resolver and rejecter functions for implementations of async functions</span>
    <span class="s4">if </span><span class="s1">(self.functionType == RCTFunctionTypePromise) {</span>
      <span class="s1">actualCount -= </span><span class="s5">2</span><span class="s4">;</span>
      <span class="s1">expectedCount -= </span><span class="s5">2</span><span class="s4">;</span>
    <span class="s1">}</span>

    <span class="s1">RCTLogError(</span>
        <span class="s4">@</span><span class="s3">&quot;%@.%s was called with %lld arguments but expects %lld arguments. &quot;</span>
        <span class="s4">@</span><span class="s3">&quot;If you haven</span><span class="s4">\'</span><span class="s3">t changed this method yourself, this usually means that &quot;</span>
        <span class="s4">@</span><span class="s3">&quot;your versions of the native code and JavaScript code are out of sync. &quot;</span>
        <span class="s4">@</span><span class="s3">&quot;Updating both should make this error go away.&quot;</span><span class="s4">,</span>
        <span class="s1">RCTBridgeModuleNameForClass(_moduleClass)</span><span class="s4">,</span>
        <span class="s1">self.JSMethodName</span><span class="s4">,</span>
        <span class="s1">(</span><span class="s4">long long</span><span class="s1">)actualCount</span><span class="s4">,</span>
        <span class="s1">(</span><span class="s4">long long</span><span class="s1">)expectedCount)</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">nil</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s2">#endif</span>

  <span class="s0">// Set arguments</span>
  <span class="s1">NSUInteger index = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s4">for </span><span class="s1">(id json in arguments) {</span>
    <span class="s1">RCTArgumentBlock block = _argumentBlocks[index]</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">(!block(bridge</span><span class="s4">, </span><span class="s1">index</span><span class="s4">, </span><span class="s1">RCTNilIfNull(json))) {</span>
      <span class="s0">// Invalid argument, abort</span>
      <span class="s1">RCTLogArgumentError(self</span><span class="s4">, </span><span class="s1">index</span><span class="s4">, </span><span class="s1">json</span><span class="s4">, </span><span class="s3">&quot;could not be processed. Aborting method call.&quot;</span><span class="s1">)</span><span class="s4">;</span>
      <span class="s4">return </span><span class="s1">nil</span><span class="s4">;</span>
    <span class="s1">}</span>
    <span class="s1">index++</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">// Invoke method</span>
<span class="s2">#ifdef </span><span class="s1">RCT_MAIN_THREAD_WATCH_DOG_THRESHOLD</span>
  <span class="s4">if </span><span class="s1">(RCTIsMainQueue()) {</span>
    <span class="s1">CFTimeInterval start = CACurrentMediaTime()</span><span class="s4">;</span>
    <span class="s1">[_invocation invokeWithTarget:module]</span><span class="s4">;</span>
    <span class="s1">CFTimeInterval duration = CACurrentMediaTime() - start</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">(duration &gt; RCT_MAIN_THREAD_WATCH_DOG_THRESHOLD) {</span>
      <span class="s1">RCTLogWarn(</span>
          <span class="s4">@</span><span class="s3">&quot;Main Thread Watchdog: Invocation of %@ blocked the main thread for %dms. &quot;</span>
           <span class="s3">&quot;Consider using background-threaded modules and asynchronous calls &quot;</span>
           <span class="s3">&quot;to spend less time on the main thread and keep the app's UI responsive.&quot;</span><span class="s4">,</span>
          <span class="s1">[self methodName]</span><span class="s4">,</span>
          <span class="s1">(</span><span class="s4">int</span><span class="s1">)(duration * </span><span class="s5">1000</span><span class="s1">))</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s1">[_invocation invokeWithTarget:module]</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s2">#else</span>
  <span class="s1">[_invocation invokeWithTarget:module]</span><span class="s4">;</span>
<span class="s2">#endif</span>

  <span class="s1">[_retainedObjects removeAllObjects]</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(_methodInfo-&gt;isSync) {</span>
    <span class="s4">void </span><span class="s1">*returnValue</span><span class="s4">;</span>
    <span class="s1">[_invocation getReturnValue:&amp;returnValue]</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">(</span><span class="s4">__bridge </span><span class="s1">id)returnValue</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">return </span><span class="s1">nil</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (NSString *)methodName</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(!_selector) {</span>
    <span class="s1">[self processMethodSignature]</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">return </span><span class="s1">[NSString stringWithFormat:</span><span class="s4">@</span><span class="s3">&quot;-[%@ %s]&quot;</span><span class="s4">, </span><span class="s1">_moduleClass</span><span class="s4">, </span><span class="s1">sel_getName(_selector)]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (NSString *)description</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">[NSString stringWithFormat:</span><span class="s4">@</span><span class="s3">&quot;&lt;%@: %p; exports %@ as %s(); type: %s&gt;&quot;</span><span class="s4">,</span>
                                    <span class="s1">[self </span><span class="s4">class</span><span class="s1">]</span><span class="s4">,</span>
                                    <span class="s1">self</span><span class="s4">,</span>
                                    <span class="s1">[self methodName]</span><span class="s4">,</span>
                                    <span class="s1">self.JSMethodName</span><span class="s4">,</span>
                                    <span class="s1">RCTFunctionDescriptorFromType(self.functionType)]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">@end</span>
</pre>
</body>
</html>
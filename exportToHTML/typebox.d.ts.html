<html>
<head>
<title>typebox.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #a9b7c6;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb; font-style: italic;}
.s5 { color: #808080;}
.s6 { color: #9876aa; font-style: italic;}
.s7 { color: #ffc66d;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
typebox.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">export declare const </span><span class="s1">Modifier</span><span class="s0">: </span><span class="s2">unique symbol</span><span class="s1">;</span>
<span class="s0">export declare const </span><span class="s1">Hint</span><span class="s0">: </span><span class="s2">unique symbol</span><span class="s1">;</span>
<span class="s0">export declare const </span><span class="s1">Kind</span><span class="s0">: </span><span class="s2">unique symbol</span><span class="s1">;</span>
<span class="s0">export declare const </span><span class="s1">PatternBoolean </span><span class="s0">= </span><span class="s3">&quot;(true|false)&quot;</span><span class="s1">;</span>
<span class="s0">export declare const </span><span class="s1">PatternNumber </span><span class="s0">= </span><span class="s3">&quot;(0|[1-9][0-9]*)&quot;</span><span class="s1">;</span>
<span class="s0">export declare const </span><span class="s1">PatternString </span><span class="s0">= </span><span class="s3">&quot;(.*)&quot;</span><span class="s1">;</span>
<span class="s0">export declare const </span><span class="s1">PatternBooleanExact</span><span class="s0">: </span><span class="s2">string</span><span class="s1">;</span>
<span class="s0">export declare const </span><span class="s1">PatternNumberExact</span><span class="s0">: </span><span class="s2">string</span><span class="s1">;</span>
<span class="s0">export declare const </span><span class="s1">PatternStringExact</span><span class="s0">: </span><span class="s2">string</span><span class="s1">;</span>
<span class="s0">export type </span><span class="s2">TupleToIntersect</span><span class="s1">&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">any</span><span class="s1">[]&gt; </span><span class="s0">= </span><span class="s2">T </span><span class="s0">extends </span><span class="s1">[</span><span class="s0">infer </span><span class="s2">I</span><span class="s1">] </span><span class="s0">? </span><span class="s2">I </span><span class="s0">: </span><span class="s2">T </span><span class="s0">extends </span><span class="s1">[</span><span class="s0">infer </span><span class="s2">I</span><span class="s1">, </span><span class="s0">...infer </span><span class="s2">R</span><span class="s1">] </span><span class="s0">? </span><span class="s2">I </span><span class="s0">&amp; </span><span class="s2">TupleToIntersect</span><span class="s1">&lt;</span><span class="s2">R</span><span class="s1">&gt; </span><span class="s0">: </span><span class="s2">never</span><span class="s1">;</span>
<span class="s0">export type </span><span class="s2">TupleToUnion</span><span class="s1">&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">any</span><span class="s1">[]&gt; </span><span class="s0">= </span><span class="s1">{</span>
    <span class="s1">[</span><span class="s2">K </span><span class="s0">in keyof </span><span class="s2">T</span><span class="s1">]</span><span class="s0">: </span><span class="s2">T</span><span class="s1">[</span><span class="s2">K</span><span class="s1">];</span>
<span class="s1">}[</span><span class="s2">number</span><span class="s1">];</span>
<span class="s0">export type </span><span class="s2">UnionToIntersect</span><span class="s1">&lt;</span><span class="s2">U</span><span class="s1">&gt; </span><span class="s0">= </span><span class="s1">(</span><span class="s2">U </span><span class="s0">extends </span><span class="s2">unknown </span><span class="s0">? </span><span class="s1">(</span><span class="s2">arg</span><span class="s0">: </span><span class="s2">U</span><span class="s1">) </span><span class="s0">=&gt; </span><span class="s4">0 </span><span class="s0">: </span><span class="s2">never</span><span class="s1">) </span><span class="s0">extends </span><span class="s1">(</span><span class="s2">arg</span><span class="s0">: infer </span><span class="s2">I</span><span class="s1">) </span><span class="s0">=&gt; </span><span class="s4">0 </span><span class="s0">? </span><span class="s2">I </span><span class="s0">: </span><span class="s2">never</span><span class="s1">;</span>
<span class="s0">export type </span><span class="s2">UnionLast</span><span class="s1">&lt;</span><span class="s2">U</span><span class="s1">&gt; </span><span class="s0">= </span><span class="s2">UnionToIntersect</span><span class="s1">&lt;</span><span class="s2">U </span><span class="s0">extends </span><span class="s2">unknown </span><span class="s0">? </span><span class="s1">(</span><span class="s2">x</span><span class="s0">: </span><span class="s2">U</span><span class="s1">) </span><span class="s0">=&gt; </span><span class="s4">0 </span><span class="s0">: </span><span class="s2">never</span><span class="s1">&gt; </span><span class="s0">extends </span><span class="s1">(</span><span class="s2">x</span><span class="s0">: infer </span><span class="s2">L</span><span class="s1">) </span><span class="s0">=&gt; </span><span class="s4">0 </span><span class="s0">? </span><span class="s2">L </span><span class="s0">: </span><span class="s2">never</span><span class="s1">;</span>
<span class="s0">export type </span><span class="s2">UnionToTuple</span><span class="s1">&lt;</span><span class="s2">U</span><span class="s1">, </span><span class="s2">L </span><span class="s0">= </span><span class="s2">UnionLast</span><span class="s1">&lt;</span><span class="s2">U</span><span class="s1">&gt;&gt; </span><span class="s0">= </span><span class="s1">[</span><span class="s2">U</span><span class="s1">] </span><span class="s0">extends </span><span class="s1">[</span><span class="s2">never</span><span class="s1">] </span><span class="s0">? </span><span class="s1">[] </span><span class="s0">: </span><span class="s1">[</span><span class="s0">...</span><span class="s2">UnionToTuple</span><span class="s1">&lt;</span><span class="s2">Exclude</span><span class="s1">&lt;</span><span class="s2">U</span><span class="s1">, </span><span class="s2">L</span><span class="s1">&gt;&gt;, </span><span class="s2">L</span><span class="s1">];</span>
<span class="s0">export type </span><span class="s2">Assert</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">, </span><span class="s2">E</span><span class="s1">&gt; </span><span class="s0">= </span><span class="s2">T </span><span class="s0">extends </span><span class="s2">E </span><span class="s0">? </span><span class="s2">T </span><span class="s0">: </span><span class="s2">never</span><span class="s1">;</span>
<span class="s0">export type </span><span class="s2">Evaluate</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt; </span><span class="s0">= </span><span class="s2">T </span><span class="s0">extends infer </span><span class="s2">O </span><span class="s0">? </span><span class="s1">{</span>
    <span class="s1">[</span><span class="s2">K </span><span class="s0">in keyof </span><span class="s2">O</span><span class="s1">]</span><span class="s0">: </span><span class="s2">O</span><span class="s1">[</span><span class="s2">K</span><span class="s1">];</span>
<span class="s1">} </span><span class="s0">: </span><span class="s2">never</span><span class="s1">;</span>
<span class="s0">export type </span><span class="s2">Ensure</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt; </span><span class="s0">= </span><span class="s2">T </span><span class="s0">extends infer </span><span class="s2">U </span><span class="s0">? </span><span class="s2">U </span><span class="s0">: </span><span class="s2">never</span><span class="s1">;</span>
<span class="s0">export type </span><span class="s2">TModifier </span><span class="s0">= </span><span class="s2">TReadonlyOptional</span><span class="s1">&lt;</span><span class="s2">TSchema</span><span class="s1">&gt; </span><span class="s0">| </span><span class="s2">TOptional</span><span class="s1">&lt;</span><span class="s2">TSchema</span><span class="s1">&gt; </span><span class="s0">| </span><span class="s2">TReadonly</span><span class="s1">&lt;</span><span class="s2">TSchema</span><span class="s1">&gt;;</span>
<span class="s0">export type </span><span class="s2">TReadonly</span><span class="s1">&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">&gt; </span><span class="s0">= </span><span class="s2">T </span><span class="s0">&amp; </span><span class="s1">{</span>
    <span class="s1">[</span><span class="s2">Modifier</span><span class="s1">]</span><span class="s0">: </span><span class="s3">'Readonly'</span><span class="s1">;</span>
<span class="s1">};</span>
<span class="s0">export type </span><span class="s2">TOptional</span><span class="s1">&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">&gt; </span><span class="s0">= </span><span class="s2">T </span><span class="s0">&amp; </span><span class="s1">{</span>
    <span class="s1">[</span><span class="s2">Modifier</span><span class="s1">]</span><span class="s0">: </span><span class="s3">'Optional'</span><span class="s1">;</span>
<span class="s1">};</span>
<span class="s0">export type </span><span class="s2">TReadonlyOptional</span><span class="s1">&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">&gt; </span><span class="s0">= </span><span class="s2">T </span><span class="s0">&amp; </span><span class="s1">{</span>
    <span class="s1">[</span><span class="s2">Modifier</span><span class="s1">]</span><span class="s0">: </span><span class="s3">'ReadonlyOptional'</span><span class="s1">;</span>
<span class="s1">};</span>
<span class="s0">export interface </span><span class="s2">SchemaOptions </span><span class="s1">{</span>
    <span class="s1">$schema</span><span class="s0">?: </span><span class="s2">string</span><span class="s1">;</span>
    <span class="s5">/** Id for this schema */</span>
    <span class="s1">$id</span><span class="s0">?: </span><span class="s2">string</span><span class="s1">;</span>
    <span class="s5">/** Title of this schema */</span>
    <span class="s1">title</span><span class="s0">?: </span><span class="s2">string</span><span class="s1">;</span>
    <span class="s5">/** Description of this schema */</span>
    <span class="s1">description</span><span class="s0">?: </span><span class="s2">string</span><span class="s1">;</span>
    <span class="s5">/** Default value for this schema */</span>
    <span class="s1">default</span><span class="s0">?: </span><span class="s2">any</span><span class="s1">;</span>
    <span class="s5">/** Example values matching this schema */</span>
    <span class="s1">examples</span><span class="s0">?: </span><span class="s2">any</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s2">prop</span><span class="s0">: </span><span class="s2">string</span><span class="s1">]</span><span class="s0">: </span><span class="s2">any</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s0">export interface </span><span class="s2">TKind </span><span class="s1">{</span>
    <span class="s1">[</span><span class="s2">Kind</span><span class="s1">]</span><span class="s0">: </span><span class="s2">string</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s0">export interface </span><span class="s2">TSchema </span><span class="s0">extends </span><span class="s2">SchemaOptions</span><span class="s1">, </span><span class="s2">TKind </span><span class="s1">{</span>
    <span class="s1">[</span><span class="s2">Modifier</span><span class="s1">]</span><span class="s0">?: </span><span class="s2">string</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s2">Hint</span><span class="s1">]</span><span class="s0">?: </span><span class="s2">string</span><span class="s1">;</span>
    <span class="s1">params</span><span class="s0">: </span><span class="s2">unknown</span><span class="s1">[];</span>
    <span class="s1">static</span><span class="s0">: </span><span class="s2">unknown</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s0">export type </span><span class="s2">TAnySchema </span><span class="s0">= </span><span class="s2">TSchema </span><span class="s0">| </span><span class="s2">TAny </span><span class="s0">| </span><span class="s2">TArray </span><span class="s0">| </span><span class="s2">TBigInt </span><span class="s0">| </span><span class="s2">TBoolean </span><span class="s0">| </span><span class="s2">TConstructor </span><span class="s0">| </span><span class="s2">TDate </span><span class="s0">| </span><span class="s2">TEnum </span><span class="s0">| </span><span class="s2">TFunction </span><span class="s0">| </span><span class="s2">TInteger </span><span class="s0">| </span><span class="s2">TIntersect </span><span class="s0">| </span><span class="s2">TLiteral </span><span class="s0">| </span><span class="s2">TNot </span><span class="s0">| </span><span class="s2">TNull </span><span class="s0">| </span><span class="s2">TNumber </span><span class="s0">| </span><span class="s2">TObject </span><span class="s0">| </span><span class="s2">TPromise </span><span class="s0">| </span><span class="s2">TRecord </span><span class="s0">| </span><span class="s2">TRef </span><span class="s0">| </span><span class="s2">TString </span><span class="s0">| </span><span class="s2">TSymbol </span><span class="s0">| </span><span class="s2">TTemplateLiteral </span><span class="s0">| </span><span class="s2">TThis </span><span class="s0">| </span><span class="s2">TTuple </span><span class="s0">| </span><span class="s2">TUndefined </span><span class="s0">| </span><span class="s2">TUnion </span><span class="s0">| </span><span class="s2">TUint8Array </span><span class="s0">| </span><span class="s2">TUnknown </span><span class="s0">| </span><span class="s2">TVoid</span><span class="s1">;</span>
<span class="s0">export type </span><span class="s2">TNumeric </span><span class="s0">= </span><span class="s2">TInteger </span><span class="s0">| </span><span class="s2">TNumber</span><span class="s1">;</span>
<span class="s0">export interface </span><span class="s2">NumericOptions</span><span class="s1">&lt;</span><span class="s2">N </span><span class="s0">extends </span><span class="s2">number </span><span class="s0">| </span><span class="s2">bigint</span><span class="s1">&gt; </span><span class="s0">extends </span><span class="s2">SchemaOptions </span><span class="s1">{</span>
    <span class="s1">exclusiveMaximum</span><span class="s0">?: </span><span class="s2">N</span><span class="s1">;</span>
    <span class="s1">exclusiveMinimum</span><span class="s0">?: </span><span class="s2">N</span><span class="s1">;</span>
    <span class="s1">maximum</span><span class="s0">?: </span><span class="s2">N</span><span class="s1">;</span>
    <span class="s1">minimum</span><span class="s0">?: </span><span class="s2">N</span><span class="s1">;</span>
    <span class="s1">multipleOf</span><span class="s0">?: </span><span class="s2">N</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s0">export interface </span><span class="s2">TAny </span><span class="s0">extends </span><span class="s2">TSchema </span><span class="s1">{</span>
    <span class="s1">[</span><span class="s2">Kind</span><span class="s1">]</span><span class="s0">: </span><span class="s3">'Any'</span><span class="s1">;</span>
    <span class="s1">static</span><span class="s0">: </span><span class="s2">any</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s0">export interface </span><span class="s2">ArrayOptions </span><span class="s0">extends </span><span class="s2">SchemaOptions </span><span class="s1">{</span>
    <span class="s1">uniqueItems</span><span class="s0">?: </span><span class="s2">boolean</span><span class="s1">;</span>
    <span class="s1">minItems</span><span class="s0">?: </span><span class="s2">number</span><span class="s1">;</span>
    <span class="s1">maxItems</span><span class="s0">?: </span><span class="s2">number</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s0">export interface </span><span class="s2">TArray</span><span class="s1">&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TSchema </span><span class="s0">= </span><span class="s2">TSchema</span><span class="s1">&gt; </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">, </span><span class="s2">ArrayOptions </span><span class="s1">{</span>
    <span class="s1">[</span><span class="s2">Kind</span><span class="s1">]</span><span class="s0">: </span><span class="s3">'Array'</span><span class="s1">;</span>
    <span class="s1">static</span><span class="s0">: </span><span class="s2">Static</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">, </span><span class="s2">this</span><span class="s1">[</span><span class="s3">'params'</span><span class="s1">]&gt;[];</span>
    <span class="s1">type</span><span class="s0">: </span><span class="s3">'array'</span><span class="s1">;</span>
    <span class="s1">items</span><span class="s0">: </span><span class="s2">T</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s0">export interface </span><span class="s2">TBigInt </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">, </span><span class="s2">NumericOptions</span><span class="s1">&lt;</span><span class="s2">bigint</span><span class="s1">&gt; {</span>
    <span class="s1">[</span><span class="s2">Kind</span><span class="s1">]</span><span class="s0">: </span><span class="s3">'BigInt'</span><span class="s1">;</span>
    <span class="s1">static</span><span class="s0">: </span><span class="s2">bigint</span><span class="s1">;</span>
    <span class="s1">type</span><span class="s0">: </span><span class="s3">'null'</span><span class="s1">;</span>
    <span class="s1">typeOf</span><span class="s0">: </span><span class="s3">'BigInt'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s0">export interface </span><span class="s2">TBoolean </span><span class="s0">extends </span><span class="s2">TSchema </span><span class="s1">{</span>
    <span class="s1">[</span><span class="s2">Kind</span><span class="s1">]</span><span class="s0">: </span><span class="s3">'Boolean'</span><span class="s1">;</span>
    <span class="s1">static</span><span class="s0">: </span><span class="s2">boolean</span><span class="s1">;</span>
    <span class="s1">type</span><span class="s0">: </span><span class="s3">'boolean'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s0">export type </span><span class="s2">TConstructorParameters</span><span class="s1">&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TConstructor</span><span class="s1">&lt;</span><span class="s2">TSchema</span><span class="s1">[], </span><span class="s2">TSchema</span><span class="s1">&gt;&gt; </span><span class="s0">= </span><span class="s2">TTuple</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">[</span><span class="s3">'parameters'</span><span class="s1">]&gt;;</span>
<span class="s0">export type </span><span class="s2">TInstanceType</span><span class="s1">&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TConstructor</span><span class="s1">&lt;</span><span class="s2">TSchema</span><span class="s1">[], </span><span class="s2">TSchema</span><span class="s1">&gt;&gt; </span><span class="s0">= </span><span class="s2">T</span><span class="s1">[</span><span class="s3">'returns'</span><span class="s1">];</span>
<span class="s0">export type </span><span class="s2">TCompositeEvaluateArray</span><span class="s1">&lt;</span><span class="s2">T </span><span class="s0">extends readonly </span><span class="s2">TSchema</span><span class="s1">[], </span><span class="s2">P </span><span class="s0">extends </span><span class="s2">unknown</span><span class="s1">[]&gt; </span><span class="s0">= </span><span class="s1">{</span>
    <span class="s1">[</span><span class="s2">K </span><span class="s0">in keyof </span><span class="s2">T</span><span class="s1">]</span><span class="s0">: </span><span class="s2">T</span><span class="s1">[</span><span class="s2">K</span><span class="s1">] </span><span class="s0">extends </span><span class="s2">TSchema </span><span class="s0">? </span><span class="s2">Static</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">[</span><span class="s2">K</span><span class="s1">], </span><span class="s2">P</span><span class="s1">&gt; </span><span class="s0">: </span><span class="s2">never</span><span class="s1">;</span>
<span class="s1">};</span>
<span class="s0">export type </span><span class="s2">TCompositeArray</span><span class="s1">&lt;</span><span class="s2">T </span><span class="s0">extends readonly </span><span class="s2">TObject</span><span class="s1">[]&gt; </span><span class="s0">= </span><span class="s1">{</span>
    <span class="s1">[</span><span class="s2">K </span><span class="s0">in keyof </span><span class="s2">T</span><span class="s1">]</span><span class="s0">: </span><span class="s2">T</span><span class="s1">[</span><span class="s2">K</span><span class="s1">] </span><span class="s0">extends </span><span class="s2">TObject</span><span class="s1">&lt;</span><span class="s0">infer </span><span class="s2">P</span><span class="s1">&gt; </span><span class="s0">? </span><span class="s2">P </span><span class="s0">: </span><span class="s1">{};</span>
<span class="s1">};</span>
<span class="s0">export type </span><span class="s2">TCompositeProperties</span><span class="s1">&lt;</span><span class="s2">I </span><span class="s0">extends </span><span class="s2">unknown</span><span class="s1">, </span><span class="s2">T </span><span class="s0">extends readonly </span><span class="s2">any</span><span class="s1">[]&gt; </span><span class="s0">= </span><span class="s2">Evaluate</span><span class="s1">&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s1">[</span><span class="s0">infer </span><span class="s2">A</span><span class="s1">, </span><span class="s0">...infer </span><span class="s2">B</span><span class="s1">] </span><span class="s0">? </span><span class="s2">TCompositeProperties</span><span class="s1">&lt;</span><span class="s2">I </span><span class="s0">&amp; </span><span class="s2">A</span><span class="s1">, </span><span class="s2">B</span><span class="s1">&gt; </span><span class="s0">: </span><span class="s2">I </span><span class="s0">extends </span><span class="s2">object </span><span class="s0">? </span><span class="s2">I </span><span class="s0">: </span><span class="s1">{}&gt;;</span>
<span class="s0">export interface </span><span class="s2">TComposite</span><span class="s1">&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TObject</span><span class="s1">[] </span><span class="s0">= </span><span class="s2">TObject</span><span class="s1">[]&gt; </span><span class="s0">extends </span><span class="s2">TObject </span><span class="s1">{</span>
    <span class="s1">[</span><span class="s2">Hint</span><span class="s1">]</span><span class="s0">: </span><span class="s3">'Composite'</span><span class="s1">;</span>
    <span class="s1">static</span><span class="s0">: </span><span class="s2">Evaluate</span><span class="s1">&lt;</span><span class="s2">TCompositeProperties</span><span class="s1">&lt;</span><span class="s2">unknown</span><span class="s1">, </span><span class="s2">TCompositeEvaluateArray</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">, </span><span class="s2">this</span><span class="s1">[</span><span class="s3">'params'</span><span class="s1">]&gt;&gt;&gt;;</span>
    <span class="s1">properties</span><span class="s0">: </span><span class="s2">TCompositeProperties</span><span class="s1">&lt;</span><span class="s2">unknown</span><span class="s1">, </span><span class="s2">TCompositeArray</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt;&gt;;</span>
<span class="s1">}</span>
<span class="s0">export type </span><span class="s2">TConstructorParameterArray</span><span class="s1">&lt;</span><span class="s2">T </span><span class="s0">extends readonly </span><span class="s2">TSchema</span><span class="s1">[], </span><span class="s2">P </span><span class="s0">extends </span><span class="s2">unknown</span><span class="s1">[]&gt; </span><span class="s0">= </span><span class="s1">[</span><span class="s0">...</span><span class="s1">{</span>
    <span class="s1">[</span><span class="s2">K </span><span class="s0">in keyof </span><span class="s2">T</span><span class="s1">]</span><span class="s0">: </span><span class="s2">Static</span><span class="s1">&lt;</span><span class="s2">Assert</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">[</span><span class="s2">K</span><span class="s1">], </span><span class="s2">TSchema</span><span class="s1">&gt;, </span><span class="s2">P</span><span class="s1">&gt;;</span>
<span class="s1">}];</span>
<span class="s0">export interface </span><span class="s2">TConstructor</span><span class="s1">&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">[] </span><span class="s0">= </span><span class="s2">TSchema</span><span class="s1">[], </span><span class="s2">U </span><span class="s0">extends </span><span class="s2">TSchema </span><span class="s0">= </span><span class="s2">TSchema</span><span class="s1">&gt; </span><span class="s0">extends </span><span class="s2">TSchema </span><span class="s1">{</span>
    <span class="s1">[</span><span class="s2">Kind</span><span class="s1">]</span><span class="s0">: </span><span class="s3">'Constructor'</span><span class="s1">;</span>
    <span class="s1">static</span><span class="s0">: new </span><span class="s1">(</span><span class="s0">...</span><span class="s2">param</span><span class="s0">: </span><span class="s2">TConstructorParameterArray</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">, </span><span class="s2">this</span><span class="s1">[</span><span class="s3">'params'</span><span class="s1">]&gt;) </span><span class="s0">=&gt; </span><span class="s2">Static</span><span class="s1">&lt;</span><span class="s2">U</span><span class="s1">, </span><span class="s2">this</span><span class="s1">[</span><span class="s3">'params'</span><span class="s1">]&gt;;</span>
    <span class="s1">type</span><span class="s0">: </span><span class="s3">'object'</span><span class="s1">;</span>
    <span class="s1">instanceOf</span><span class="s0">: </span><span class="s3">'Constructor'</span><span class="s1">;</span>
    <span class="s1">parameters</span><span class="s0">: </span><span class="s2">T</span><span class="s1">;</span>
    <span class="s1">returns</span><span class="s0">: </span><span class="s2">U</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s0">export interface </span><span class="s2">DateOptions </span><span class="s0">extends </span><span class="s2">SchemaOptions </span><span class="s1">{</span>
    <span class="s1">exclusiveMaximumTimestamp</span><span class="s0">?: </span><span class="s2">number</span><span class="s1">;</span>
    <span class="s1">exclusiveMinimumTimestamp</span><span class="s0">?: </span><span class="s2">number</span><span class="s1">;</span>
    <span class="s1">maximumTimestamp</span><span class="s0">?: </span><span class="s2">number</span><span class="s1">;</span>
    <span class="s1">minimumTimestamp</span><span class="s0">?: </span><span class="s2">number</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s0">export interface </span><span class="s2">TDate </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">, </span><span class="s2">DateOptions </span><span class="s1">{</span>
    <span class="s1">[</span><span class="s2">Kind</span><span class="s1">]</span><span class="s0">: </span><span class="s3">'Date'</span><span class="s1">;</span>
    <span class="s1">static</span><span class="s0">: </span><span class="s2">Date</span><span class="s1">;</span>
    <span class="s1">type</span><span class="s0">: </span><span class="s3">'object'</span><span class="s1">;</span>
    <span class="s1">instanceOf</span><span class="s0">: </span><span class="s3">'Date'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s0">export interface </span><span class="s2">TEnumOption</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt; {</span>
    <span class="s1">type</span><span class="s0">: </span><span class="s3">'number' </span><span class="s0">| </span><span class="s3">'string'</span><span class="s1">;</span>
    <span class="s1">const</span><span class="s0">: </span><span class="s2">T</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s0">export interface </span><span class="s2">TEnum</span><span class="s1">&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">Record</span><span class="s1">&lt;</span><span class="s2">string</span><span class="s1">, </span><span class="s2">string </span><span class="s0">| </span><span class="s2">number</span><span class="s1">&gt; </span><span class="s0">= </span><span class="s2">Record</span><span class="s1">&lt;</span><span class="s2">string</span><span class="s1">, </span><span class="s2">string </span><span class="s0">| </span><span class="s2">number</span><span class="s1">&gt;&gt; </span><span class="s0">extends </span><span class="s2">TSchema </span><span class="s1">{</span>
    <span class="s1">[</span><span class="s2">Kind</span><span class="s1">]</span><span class="s0">: </span><span class="s3">'Union'</span><span class="s1">;</span>
    <span class="s1">static</span><span class="s0">: </span><span class="s2">T</span><span class="s1">[</span><span class="s0">keyof </span><span class="s2">T</span><span class="s1">];</span>
    <span class="s1">anyOf</span><span class="s0">: </span><span class="s2">TLiteral</span><span class="s1">&lt;</span><span class="s2">string </span><span class="s0">| </span><span class="s2">number</span><span class="s1">&gt;[];</span>
<span class="s1">}</span>
<span class="s0">export type </span><span class="s2">TExtends</span><span class="s1">&lt;</span><span class="s2">L </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">, </span><span class="s2">R </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">, </span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">, </span><span class="s2">U </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">&gt; </span><span class="s0">= </span><span class="s1">(</span><span class="s2">Static</span><span class="s1">&lt;</span><span class="s2">L</span><span class="s1">&gt; </span><span class="s0">extends </span><span class="s2">Static</span><span class="s1">&lt;</span><span class="s2">R</span><span class="s1">&gt; </span><span class="s0">? </span><span class="s2">T </span><span class="s0">: </span><span class="s2">U</span><span class="s1">) </span><span class="s0">extends infer </span><span class="s2">O </span><span class="s0">? </span><span class="s2">UnionToTuple</span><span class="s1">&lt;</span><span class="s2">O</span><span class="s1">&gt; </span><span class="s0">extends </span><span class="s1">[</span><span class="s0">infer </span><span class="s2">X</span><span class="s1">, </span><span class="s0">infer </span><span class="s2">Y</span><span class="s1">] </span><span class="s0">? </span><span class="s2">TUnion</span><span class="s1">&lt;[</span><span class="s2">Assert</span><span class="s1">&lt;</span><span class="s2">X</span><span class="s1">, </span><span class="s2">TSchema</span><span class="s1">&gt;, </span><span class="s2">Assert</span><span class="s1">&lt;</span><span class="s2">Y</span><span class="s1">, </span><span class="s2">TSchema</span><span class="s1">&gt;]&gt; </span><span class="s0">: </span><span class="s2">Assert</span><span class="s1">&lt;</span><span class="s2">O</span><span class="s1">, </span><span class="s2">TSchema</span><span class="s1">&gt; </span><span class="s0">: </span><span class="s2">never</span><span class="s1">;</span>
<span class="s0">export type </span><span class="s2">TExcludeTemplateLiteralResult</span><span class="s1">&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">string</span><span class="s1">&gt; </span><span class="s0">= </span><span class="s2">TUnionResult</span><span class="s1">&lt;</span><span class="s2">Assert</span><span class="s1">&lt;</span><span class="s2">UnionToTuple</span><span class="s1">&lt;{</span>
    <span class="s1">[</span><span class="s2">K </span><span class="s0">in </span><span class="s2">T</span><span class="s1">]</span><span class="s0">: </span><span class="s2">TLiteral</span><span class="s1">&lt;</span><span class="s2">K</span><span class="s1">&gt;;</span>
<span class="s1">}[</span><span class="s2">T</span><span class="s1">]&gt;, </span><span class="s2">TSchema</span><span class="s1">[]&gt;&gt;;</span>
<span class="s0">export type </span><span class="s2">TExcludeTemplateLiteral</span><span class="s1">&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TTemplateLiteral</span><span class="s1">, </span><span class="s2">U </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">&gt; </span><span class="s0">= </span><span class="s2">Exclude</span><span class="s1">&lt;</span><span class="s2">Static</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt;, </span><span class="s2">Static</span><span class="s1">&lt;</span><span class="s2">U</span><span class="s1">&gt;&gt; </span><span class="s0">extends infer </span><span class="s2">S </span><span class="s0">? </span><span class="s2">TExcludeTemplateLiteralResult</span><span class="s1">&lt;</span><span class="s2">Assert</span><span class="s1">&lt;</span><span class="s2">S</span><span class="s1">, </span><span class="s2">string</span><span class="s1">&gt;&gt; </span><span class="s0">: </span><span class="s2">never</span><span class="s1">;</span>
<span class="s0">export type </span><span class="s2">TExcludeArray</span><span class="s1">&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">[], </span><span class="s2">U </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">&gt; </span><span class="s0">= </span><span class="s2">Assert</span><span class="s1">&lt;</span><span class="s2">UnionToTuple</span><span class="s1">&lt;{</span>
    <span class="s1">[</span><span class="s2">K </span><span class="s0">in keyof </span><span class="s2">T</span><span class="s1">]</span><span class="s0">: </span><span class="s2">Static</span><span class="s1">&lt;</span><span class="s2">Assert</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">[</span><span class="s2">K</span><span class="s1">], </span><span class="s2">TSchema</span><span class="s1">&gt;&gt; </span><span class="s0">extends </span><span class="s2">Static</span><span class="s1">&lt;</span><span class="s2">U</span><span class="s1">&gt; </span><span class="s0">? </span><span class="s2">never </span><span class="s0">: </span><span class="s2">T</span><span class="s1">[</span><span class="s2">K</span><span class="s1">];</span>
<span class="s1">}[</span><span class="s2">number</span><span class="s1">]&gt;, </span><span class="s2">TSchema</span><span class="s1">[]&gt; </span><span class="s0">extends infer </span><span class="s2">R </span><span class="s0">? </span><span class="s2">TUnionResult</span><span class="s1">&lt;</span><span class="s2">Assert</span><span class="s1">&lt;</span><span class="s2">R</span><span class="s1">, </span><span class="s2">TSchema</span><span class="s1">[]&gt;&gt; </span><span class="s0">: </span><span class="s2">never</span><span class="s1">;</span>
<span class="s0">export type </span><span class="s2">TExclude</span><span class="s1">&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">, </span><span class="s2">U </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">&gt; </span><span class="s0">= </span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TTemplateLiteral </span><span class="s0">? </span><span class="s2">TExcludeTemplateLiteral</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">, </span><span class="s2">U</span><span class="s1">&gt; </span><span class="s0">: </span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TUnion</span><span class="s1">&lt;</span><span class="s0">infer </span><span class="s2">S</span><span class="s1">&gt; </span><span class="s0">? </span><span class="s2">TExcludeArray</span><span class="s1">&lt;</span><span class="s2">S</span><span class="s1">, </span><span class="s2">U</span><span class="s1">&gt; </span><span class="s0">: </span><span class="s2">T </span><span class="s0">extends </span><span class="s2">U </span><span class="s0">? </span><span class="s2">TNever </span><span class="s0">: </span><span class="s2">T</span><span class="s1">;</span>
<span class="s0">export type </span><span class="s2">TExtractTemplateLiteralResult</span><span class="s1">&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">string</span><span class="s1">&gt; </span><span class="s0">= </span><span class="s2">TUnionResult</span><span class="s1">&lt;</span><span class="s2">Assert</span><span class="s1">&lt;</span><span class="s2">UnionToTuple</span><span class="s1">&lt;{</span>
    <span class="s1">[</span><span class="s2">K </span><span class="s0">in </span><span class="s2">T</span><span class="s1">]</span><span class="s0">: </span><span class="s2">TLiteral</span><span class="s1">&lt;</span><span class="s2">K</span><span class="s1">&gt;;</span>
<span class="s1">}[</span><span class="s2">T</span><span class="s1">]&gt;, </span><span class="s2">TSchema</span><span class="s1">[]&gt;&gt;;</span>
<span class="s0">export type </span><span class="s2">TExtractTemplateLiteral</span><span class="s1">&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TTemplateLiteral</span><span class="s1">, </span><span class="s2">U </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">&gt; </span><span class="s0">= </span><span class="s2">Extract</span><span class="s1">&lt;</span><span class="s2">Static</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt;, </span><span class="s2">Static</span><span class="s1">&lt;</span><span class="s2">U</span><span class="s1">&gt;&gt; </span><span class="s0">extends infer </span><span class="s2">S </span><span class="s0">? </span><span class="s2">TExtractTemplateLiteralResult</span><span class="s1">&lt;</span><span class="s2">Assert</span><span class="s1">&lt;</span><span class="s2">S</span><span class="s1">, </span><span class="s2">string</span><span class="s1">&gt;&gt; </span><span class="s0">: </span><span class="s2">never</span><span class="s1">;</span>
<span class="s0">export type </span><span class="s2">TExtractArray</span><span class="s1">&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">[], </span><span class="s2">U </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">&gt; </span><span class="s0">= </span><span class="s2">Assert</span><span class="s1">&lt;</span><span class="s2">UnionToTuple</span><span class="s1">&lt;{</span>
    <span class="s1">[</span><span class="s2">K </span><span class="s0">in keyof </span><span class="s2">T</span><span class="s1">]</span><span class="s0">: </span><span class="s2">Static</span><span class="s1">&lt;</span><span class="s2">Assert</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">[</span><span class="s2">K</span><span class="s1">], </span><span class="s2">TSchema</span><span class="s1">&gt;&gt; </span><span class="s0">extends </span><span class="s2">Static</span><span class="s1">&lt;</span><span class="s2">U</span><span class="s1">&gt; </span><span class="s0">? </span><span class="s2">T</span><span class="s1">[</span><span class="s2">K</span><span class="s1">] </span><span class="s0">: </span><span class="s2">never</span><span class="s1">;</span>
<span class="s1">}[</span><span class="s2">number</span><span class="s1">]&gt;, </span><span class="s2">TSchema</span><span class="s1">[]&gt; </span><span class="s0">extends infer </span><span class="s2">R </span><span class="s0">? </span><span class="s2">TUnionResult</span><span class="s1">&lt;</span><span class="s2">Assert</span><span class="s1">&lt;</span><span class="s2">R</span><span class="s1">, </span><span class="s2">TSchema</span><span class="s1">[]&gt;&gt; </span><span class="s0">: </span><span class="s2">never</span><span class="s1">;</span>
<span class="s0">export type </span><span class="s2">TExtract</span><span class="s1">&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">, </span><span class="s2">U </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">&gt; </span><span class="s0">= </span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TTemplateLiteral </span><span class="s0">? </span><span class="s2">TExtractTemplateLiteral</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">, </span><span class="s2">U</span><span class="s1">&gt; </span><span class="s0">: </span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TUnion</span><span class="s1">&lt;</span><span class="s0">infer </span><span class="s2">S</span><span class="s1">&gt; </span><span class="s0">? </span><span class="s2">TExtractArray</span><span class="s1">&lt;</span><span class="s2">S</span><span class="s1">, </span><span class="s2">U</span><span class="s1">&gt; </span><span class="s0">: </span><span class="s2">T </span><span class="s0">extends </span><span class="s2">U </span><span class="s0">? </span><span class="s2">T </span><span class="s0">: </span><span class="s2">T</span><span class="s1">;</span>
<span class="s0">export type </span><span class="s2">TFunctionParameters</span><span class="s1">&lt;</span><span class="s2">T </span><span class="s0">extends readonly </span><span class="s2">TSchema</span><span class="s1">[], </span><span class="s2">P </span><span class="s0">extends </span><span class="s2">unknown</span><span class="s1">[]&gt; </span><span class="s0">= </span><span class="s1">[</span><span class="s0">...</span><span class="s1">{</span>
    <span class="s1">[</span><span class="s2">K </span><span class="s0">in keyof </span><span class="s2">T</span><span class="s1">]</span><span class="s0">: </span><span class="s2">Static</span><span class="s1">&lt;</span><span class="s2">Assert</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">[</span><span class="s2">K</span><span class="s1">], </span><span class="s2">TSchema</span><span class="s1">&gt;, </span><span class="s2">P</span><span class="s1">&gt;;</span>
<span class="s1">}];</span>
<span class="s0">export interface </span><span class="s2">TFunction</span><span class="s1">&lt;</span><span class="s2">T </span><span class="s0">extends readonly </span><span class="s2">TSchema</span><span class="s1">[] </span><span class="s0">= </span><span class="s2">TSchema</span><span class="s1">[], </span><span class="s2">U </span><span class="s0">extends </span><span class="s2">TSchema </span><span class="s0">= </span><span class="s2">TSchema</span><span class="s1">&gt; </span><span class="s0">extends </span><span class="s2">TSchema </span><span class="s1">{</span>
    <span class="s1">[</span><span class="s2">Kind</span><span class="s1">]</span><span class="s0">: </span><span class="s3">'Function'</span><span class="s1">;</span>
    <span class="s1">static</span><span class="s0">: </span><span class="s1">(</span><span class="s0">...</span><span class="s2">param</span><span class="s0">: </span><span class="s2">TFunctionParameters</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">, </span><span class="s2">this</span><span class="s1">[</span><span class="s3">'params'</span><span class="s1">]&gt;) </span><span class="s0">=&gt; </span><span class="s2">Static</span><span class="s1">&lt;</span><span class="s2">U</span><span class="s1">, </span><span class="s2">this</span><span class="s1">[</span><span class="s3">'params'</span><span class="s1">]&gt;;</span>
    <span class="s1">type</span><span class="s0">: </span><span class="s3">'object'</span><span class="s1">;</span>
    <span class="s1">instanceOf</span><span class="s0">: </span><span class="s3">'Function'</span><span class="s1">;</span>
    <span class="s1">parameters</span><span class="s0">: </span><span class="s2">T</span><span class="s1">;</span>
    <span class="s1">returns</span><span class="s0">: </span><span class="s2">U</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s0">export interface </span><span class="s2">TInteger </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">, </span><span class="s2">NumericOptions</span><span class="s1">&lt;</span><span class="s2">number</span><span class="s1">&gt; {</span>
    <span class="s1">[</span><span class="s2">Kind</span><span class="s1">]</span><span class="s0">: </span><span class="s3">'Integer'</span><span class="s1">;</span>
    <span class="s1">static</span><span class="s0">: </span><span class="s2">number</span><span class="s1">;</span>
    <span class="s1">type</span><span class="s0">: </span><span class="s3">'integer'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s0">export type </span><span class="s2">TUnevaluatedProperties </span><span class="s0">= </span><span class="s2">undefined </span><span class="s0">| </span><span class="s2">TSchema </span><span class="s0">| </span><span class="s2">boolean</span><span class="s1">;</span>
<span class="s0">export interface </span><span class="s2">IntersectOptions </span><span class="s0">extends </span><span class="s2">SchemaOptions </span><span class="s1">{</span>
    <span class="s1">unevaluatedProperties</span><span class="s0">?: </span><span class="s2">TUnevaluatedProperties</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s0">export interface </span><span class="s2">TIntersect</span><span class="s1">&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">[] </span><span class="s0">= </span><span class="s2">TSchema</span><span class="s1">[]&gt; </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">, </span><span class="s2">IntersectOptions </span><span class="s1">{</span>
    <span class="s1">[</span><span class="s2">Kind</span><span class="s1">]</span><span class="s0">: </span><span class="s3">'Intersect'</span><span class="s1">;</span>
    <span class="s1">static</span><span class="s0">: </span><span class="s2">TupleToIntersect</span><span class="s1">&lt;{</span>
        <span class="s1">[</span><span class="s2">K </span><span class="s0">in keyof </span><span class="s2">T</span><span class="s1">]</span><span class="s0">: </span><span class="s2">Static</span><span class="s1">&lt;</span><span class="s2">Assert</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">[</span><span class="s2">K</span><span class="s1">], </span><span class="s2">TSchema</span><span class="s1">&gt;, </span><span class="s2">this</span><span class="s1">[</span><span class="s3">'params'</span><span class="s1">]&gt;;</span>
    <span class="s1">}&gt;;</span>
    <span class="s1">type</span><span class="s0">?: </span><span class="s3">'object'</span><span class="s1">;</span>
    <span class="s1">allOf</span><span class="s0">: </span><span class="s1">[</span><span class="s0">...</span><span class="s2">T</span><span class="s1">];</span>
<span class="s1">}</span>
<span class="s0">export type </span><span class="s2">TKeyOfTuple</span><span class="s1">&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">&gt; </span><span class="s0">= </span><span class="s1">{</span>
    <span class="s1">[</span><span class="s2">K </span><span class="s0">in keyof </span><span class="s2">Static</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt;]</span><span class="s0">: </span><span class="s2">TLiteral</span><span class="s1">&lt;</span><span class="s2">Assert</span><span class="s1">&lt;</span><span class="s2">K</span><span class="s1">, </span><span class="s2">TLiteralValue</span><span class="s1">&gt;&gt;;</span>
<span class="s1">} </span><span class="s0">extends infer </span><span class="s2">U </span><span class="s0">? </span><span class="s2">UnionToTuple</span><span class="s1">&lt;</span><span class="s2">Exclude</span><span class="s1">&lt;{</span>
    <span class="s1">[</span><span class="s2">K </span><span class="s0">in keyof </span><span class="s2">U</span><span class="s1">]</span><span class="s0">: </span><span class="s2">U</span><span class="s1">[</span><span class="s2">K</span><span class="s1">];</span>
<span class="s1">}[</span><span class="s0">keyof </span><span class="s2">U</span><span class="s1">], </span><span class="s2">undefined</span><span class="s1">&gt;&gt; </span><span class="s0">: </span><span class="s2">never</span><span class="s1">;</span>
<span class="s0">export type </span><span class="s2">TKeyOf</span><span class="s1">&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TSchema </span><span class="s0">= </span><span class="s2">TSchema</span><span class="s1">&gt; </span><span class="s0">= </span><span class="s1">(</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TRecursive</span><span class="s1">&lt;</span><span class="s0">infer </span><span class="s2">S</span><span class="s1">&gt; </span><span class="s0">? </span><span class="s2">TKeyOfTuple</span><span class="s1">&lt;</span><span class="s2">S</span><span class="s1">&gt; </span><span class="s0">: </span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TComposite </span><span class="s0">? </span><span class="s2">TKeyOfTuple</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt; </span><span class="s0">: </span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TIntersect </span><span class="s0">? </span><span class="s2">TKeyOfTuple</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt; </span><span class="s0">: </span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TUnion </span><span class="s0">? </span><span class="s2">TKeyOfTuple</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt; </span><span class="s0">: </span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TObject </span><span class="s0">? </span><span class="s2">TKeyOfTuple</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt; </span><span class="s0">: </span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TRecord</span><span class="s1">&lt;</span><span class="s0">infer </span><span class="s2">K</span><span class="s1">&gt; </span><span class="s0">? </span><span class="s1">[</span><span class="s2">K</span><span class="s1">] </span><span class="s0">: </span><span class="s1">[</span>
<span class="s1">]) </span><span class="s0">extends infer </span><span class="s2">R </span><span class="s0">? </span><span class="s2">TUnionResult</span><span class="s1">&lt;</span><span class="s2">Assert</span><span class="s1">&lt;</span><span class="s2">R</span><span class="s1">, </span><span class="s2">TSchema</span><span class="s1">[]&gt;&gt; </span><span class="s0">: </span><span class="s2">never</span><span class="s1">;</span>
<span class="s0">export type </span><span class="s2">TLiteralValue </span><span class="s0">= </span><span class="s2">string </span><span class="s0">| </span><span class="s2">number </span><span class="s0">| </span><span class="s2">boolean</span><span class="s1">;</span>
<span class="s0">export interface </span><span class="s2">TLiteral</span><span class="s1">&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TLiteralValue </span><span class="s0">= </span><span class="s2">TLiteralValue</span><span class="s1">&gt; </span><span class="s0">extends </span><span class="s2">TSchema </span><span class="s1">{</span>
    <span class="s1">[</span><span class="s2">Kind</span><span class="s1">]</span><span class="s0">: </span><span class="s3">'Literal'</span><span class="s1">;</span>
    <span class="s1">static</span><span class="s0">: </span><span class="s2">T</span><span class="s1">;</span>
    <span class="s1">const</span><span class="s0">: </span><span class="s2">T</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s0">export interface </span><span class="s2">TNever </span><span class="s0">extends </span><span class="s2">TSchema </span><span class="s1">{</span>
    <span class="s1">[</span><span class="s2">Kind</span><span class="s1">]</span><span class="s0">: </span><span class="s3">'Never'</span><span class="s1">;</span>
    <span class="s1">static</span><span class="s0">: </span><span class="s2">never</span><span class="s1">;</span>
    <span class="s1">not</span><span class="s0">: </span><span class="s1">{};</span>
<span class="s1">}</span>
<span class="s0">export interface </span><span class="s2">TNot</span><span class="s1">&lt;</span><span class="s2">Not </span><span class="s0">extends </span><span class="s2">TSchema </span><span class="s0">= </span><span class="s2">TSchema</span><span class="s1">, </span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TSchema </span><span class="s0">= </span><span class="s2">TSchema</span><span class="s1">&gt; </span><span class="s0">extends </span><span class="s2">TSchema </span><span class="s1">{</span>
    <span class="s1">[</span><span class="s2">Kind</span><span class="s1">]</span><span class="s0">: </span><span class="s3">'Not'</span><span class="s1">;</span>
    <span class="s1">static</span><span class="s0">: </span><span class="s2">Static</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt;;</span>
    <span class="s1">allOf</span><span class="s0">: </span><span class="s1">[{</span>
        <span class="s1">not</span><span class="s0">: </span><span class="s2">Not</span><span class="s1">;</span>
    <span class="s1">}, </span><span class="s2">T</span><span class="s1">]; 
} 
</span><span class="s2">export interface TNull extends TSchema </span><span class="s1">{</span>
    <span class="s1">[</span><span class="s2">Kind</span><span class="s1">]: </span><span class="s3">'Null'</span><span class="s1">;</span>
    <span class="s2">static</span><span class="s1">: </span><span class="s6">null</span><span class="s1">;</span>
    <span class="s2">type</span><span class="s1">: </span><span class="s3">'null'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export interface TNumber extends </span><span class="s1">TSchema, </span><span class="s2">NumericOptions</span><span class="s0">&lt;</span><span class="s2">number</span><span class="s0">&gt; </span><span class="s1">{</span>
    <span class="s1">[</span><span class="s2">Kind</span><span class="s1">]: </span><span class="s3">'Number'</span><span class="s1">; 
    </span><span class="s2">static</span><span class="s1">: </span><span class="s2">number</span><span class="s1">; 
    </span><span class="s2">type</span><span class="s1">: </span><span class="s3">'number'</span><span class="s1">; 
}</span>
<span class="s2">export type ReadonlyOptionalPropertyKeys</span><span class="s0">&lt;</span><span class="s2">T extends TProperties</span><span class="s0">&gt; = </span><span class="s1">{</span>
    <span class="s1">[</span><span class="s2">K </span><span class="s0">in </span><span class="s2">keyof T</span><span class="s1">]: </span><span class="s2">T</span><span class="s1">[</span><span class="s2">K</span><span class="s1">] </span><span class="s2">extends TReadonlyOptional</span><span class="s0">&lt;</span><span class="s2">TSchema</span><span class="s0">&gt; ? </span><span class="s2">K </span><span class="s0">: </span><span class="s2">never</span><span class="s1">; 
}[</span><span class="s2">keyof T</span><span class="s1">];</span>
<span class="s2">export type ReadonlyPropertyKeys</span><span class="s0">&lt;</span><span class="s2">T extends TProperties</span><span class="s0">&gt; = </span><span class="s1">{</span>
    <span class="s1">[</span><span class="s2">K </span><span class="s0">in </span><span class="s2">keyof T</span><span class="s1">]: </span><span class="s2">T</span><span class="s1">[</span><span class="s2">K</span><span class="s1">] </span><span class="s2">extends TReadonly</span><span class="s0">&lt;</span><span class="s2">TSchema</span><span class="s0">&gt; ? </span><span class="s2">K </span><span class="s0">: </span><span class="s2">never</span><span class="s1">; 
}[</span><span class="s2">keyof T</span><span class="s1">];</span>
<span class="s2">export type OptionalPropertyKeys</span><span class="s0">&lt;</span><span class="s2">T extends TProperties</span><span class="s0">&gt; = </span><span class="s1">{</span>
    <span class="s1">[</span><span class="s2">K </span><span class="s0">in </span><span class="s2">keyof T</span><span class="s1">]: </span><span class="s2">T</span><span class="s1">[</span><span class="s2">K</span><span class="s1">] </span><span class="s2">extends TOptional</span><span class="s0">&lt;</span><span class="s2">TSchema</span><span class="s0">&gt; ? </span><span class="s2">K </span><span class="s0">: </span><span class="s2">never</span><span class="s1">; 
}[</span><span class="s2">keyof T</span><span class="s1">];</span>
<span class="s2">export type RequiredPropertyKeys</span><span class="s0">&lt;</span><span class="s2">T extends TProperties</span><span class="s0">&gt; = </span><span class="s2">keyof Omit</span><span class="s0">&lt;</span><span class="s2">T</span><span class="s1">, </span><span class="s2">ReadonlyOptionalPropertyKeys</span><span class="s0">&lt;</span><span class="s2">T</span><span class="s0">&gt; | </span><span class="s2">ReadonlyPropertyKeys</span><span class="s0">&lt;</span><span class="s2">T</span><span class="s0">&gt; | </span><span class="s2">OptionalPropertyKeys</span><span class="s0">&lt;</span><span class="s2">T</span><span class="s0">&gt;&gt;</span><span class="s1">;</span>
<span class="s2">export type PropertiesReducer</span><span class="s0">&lt;</span><span class="s2">T extends </span><span class="s1">TProperties, </span><span class="s2">R extends Record</span><span class="s0">&lt;</span><span class="s2">keyof </span><span class="s1">any, </span><span class="s2">unknown</span><span class="s0">&gt;&gt; = </span><span class="s2">Evaluate</span><span class="s0">&lt;</span><span class="s1">(</span><span class="s2">Readonly</span><span class="s0">&lt;</span><span class="s2">Partial</span><span class="s0">&lt;</span><span class="s2">Pick</span><span class="s0">&lt;</span><span class="s2">R</span><span class="s1">, </span><span class="s2">ReadonlyOptionalPropertyKeys</span><span class="s0">&lt;</span><span class="s2">T</span><span class="s0">&gt;&gt;&gt;&gt; &amp; </span><span class="s2">Readonly</span><span class="s0">&lt;</span><span class="s2">Pick</span><span class="s0">&lt;</span><span class="s2">R</span><span class="s1">, </span><span class="s2">ReadonlyPropertyKeys</span><span class="s0">&lt;</span><span class="s2">T</span><span class="s0">&gt;&gt;&gt; &amp; </span><span class="s2">Partial</span><span class="s0">&lt;</span><span class="s2">Pick</span><span class="s0">&lt;</span><span class="s2">R</span><span class="s1">, </span><span class="s2">OptionalPropertyKeys</span><span class="s0">&lt;</span><span class="s2">T</span><span class="s0">&gt;&gt;&gt; &amp; </span><span class="s2">Required</span><span class="s0">&lt;</span><span class="s2">Pick</span><span class="s0">&lt;</span><span class="s2">R</span><span class="s1">, </span><span class="s2">RequiredPropertyKeys</span><span class="s0">&lt;</span><span class="s2">T</span><span class="s0">&gt;&gt;&gt;</span><span class="s1">)</span><span class="s0">&gt;</span><span class="s1">;</span>
<span class="s2">export type PropertiesReduce</span><span class="s0">&lt;</span><span class="s2">T extends </span><span class="s1">TProperties, </span><span class="s2">P extends unknown</span><span class="s1">[]</span><span class="s0">&gt; = </span><span class="s2">PropertiesReducer</span><span class="s0">&lt;</span><span class="s2">T</span><span class="s1">, {</span>
    <span class="s1">[</span><span class="s2">K </span><span class="s0">in </span><span class="s2">keyof T</span><span class="s1">]: </span><span class="s2">Static</span><span class="s0">&lt;</span><span class="s2">T</span><span class="s1">[</span><span class="s2">K</span><span class="s1">], P&gt;; 
}</span><span class="s0">&gt;</span><span class="s1">;</span>
<span class="s2">export type </span><span class="s1">TProperties </span><span class="s0">= </span><span class="s2">Record</span><span class="s0">&lt;</span><span class="s2">keyof any</span><span class="s1">, </span><span class="s2">TSchema</span><span class="s0">&gt;</span><span class="s1">;</span>
<span class="s2">export type ObjectProperties</span><span class="s0">&lt;</span><span class="s2">T</span><span class="s0">&gt; = </span><span class="s2">T extends TObject</span><span class="s0">&lt;</span><span class="s2">infer U</span><span class="s0">&gt; ? </span><span class="s2">U </span><span class="s0">: </span><span class="s2">never</span><span class="s1">;</span>
<span class="s2">export type ObjectPropertyKeys</span><span class="s0">&lt;</span><span class="s2">T</span><span class="s0">&gt; = </span><span class="s2">T extends TObject</span><span class="s0">&lt;</span><span class="s2">infer U</span><span class="s0">&gt; ? </span><span class="s2">keyof U </span><span class="s0">: </span><span class="s2">never</span><span class="s1">;</span>
<span class="s2">export type </span><span class="s1">TAdditionalProperties </span><span class="s0">= </span><span class="s6">undefined </span><span class="s0">| </span><span class="s2">TSchema </span><span class="s0">| </span><span class="s2">boolean</span><span class="s1">;</span>
<span class="s2">export interface ObjectOptions extends SchemaOptions </span><span class="s1">{</span>
    <span class="s2">additionalProperties</span><span class="s0">?: </span><span class="s2">TAdditionalProperties</span><span class="s1">;</span>
    <span class="s2">minProperties</span><span class="s0">?: </span><span class="s2">number</span><span class="s1">;</span>
    <span class="s2">maxProperties</span><span class="s0">?: </span><span class="s2">number</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export interface TObject</span><span class="s0">&lt;</span><span class="s2">T extends </span><span class="s1">TProperties </span><span class="s0">= </span><span class="s2">TProperties</span><span class="s0">&gt; </span><span class="s2">extends TSchema</span><span class="s1">, </span><span class="s2">ObjectOptions </span><span class="s1">{</span>
    <span class="s1">[</span><span class="s2">Kind</span><span class="s1">]: </span><span class="s3">'Object'</span><span class="s1">;</span>
    <span class="s2">static</span><span class="s1">: </span><span class="s2">PropertiesReduce</span><span class="s0">&lt;</span><span class="s2">T</span><span class="s1">, </span><span class="s2">this</span><span class="s1">[</span><span class="s3">'params'</span><span class="s1">]</span><span class="s0">&gt;</span><span class="s1">;</span>
    <span class="s2">additionalProperties</span><span class="s0">?: </span><span class="s2">TAdditionalProperties</span><span class="s1">;</span>
    <span class="s2">type</span><span class="s1">: </span><span class="s3">'object'</span><span class="s1">;</span>
    <span class="s2">properties</span><span class="s1">: </span><span class="s2">T</span><span class="s1">;</span>
    <span class="s2">required</span><span class="s0">?: </span><span class="s2">string</span><span class="s1">[];</span>
<span class="s1">}</span>
<span class="s2">export type TOmitArray</span><span class="s0">&lt;</span><span class="s2">T extends TSchema</span><span class="s1">[], </span><span class="s2">K extends keyof any</span><span class="s0">&gt; = </span><span class="s7">Assert</span><span class="s1">&lt;{</span>
    <span class="s1">[</span><span class="s2">K2 </span><span class="s0">in keyof </span><span class="s2">T</span><span class="s1">]</span><span class="s0">: </span><span class="s2">TOmit</span><span class="s1">&lt;</span><span class="s2">Assert</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">[</span><span class="s2">K2</span><span class="s1">], </span><span class="s2">TSchema</span><span class="s1">&gt;, </span><span class="s2">K</span><span class="s1">&gt;;</span>
<span class="s1">}, </span><span class="s2">TSchema</span><span class="s1">[]&gt;;</span>
<span class="s2">export type TOmitProperties</span><span class="s0">&lt;</span><span class="s2">T extends </span><span class="s1">TProperties, </span><span class="s2">K extends keyof any</span><span class="s0">&gt; = </span><span class="s2">Evaluate</span><span class="s0">&lt;</span><span class="s2">Assert</span><span class="s0">&lt;</span><span class="s2">Omit</span><span class="s0">&lt;</span><span class="s2">T</span><span class="s1">, </span><span class="s2">K</span><span class="s0">&gt;</span><span class="s1">, </span><span class="s2">TProperties</span><span class="s0">&gt;&gt;</span><span class="s1">;</span>
<span class="s2">export type TOmit</span><span class="s0">&lt;</span><span class="s2">T extends </span><span class="s1">TSchema </span><span class="s0">= </span><span class="s2">TSchema</span><span class="s1">, </span><span class="s2">K extends keyof </span><span class="s1">any </span><span class="s0">= </span><span class="s2">keyof any</span><span class="s0">&gt; = </span><span class="s2">T extends TRecursive</span><span class="s0">&lt;</span><span class="s2">infer S</span><span class="s0">&gt; ? </span><span class="s2">TRecursive</span><span class="s0">&lt;</span><span class="s2">TOmit</span><span class="s0">&lt;</span><span class="s2">S</span><span class="s1">, </span><span class="s2">K</span><span class="s0">&gt;&gt; : </span><span class="s2">T extends TComposite</span><span class="s0">&lt;</span><span class="s2">infer S</span><span class="s0">&gt; ? </span><span class="s2">TComposite</span><span class="s0">&lt;</span><span class="s2">TOmitArray</span><span class="s0">&lt;</span><span class="s2">S</span><span class="s1">, </span><span class="s2">K</span><span class="s0">&gt;&gt; : </span><span class="s2">T extends TIntersect</span><span class="s0">&lt;</span><span class="s2">infer S</span><span class="s0">&gt; ? </span><span class="s2">TIntersect</span><span class="s0">&lt;</span><span class="s2">TOmitArray</span><span class="s0">&lt;</span><span class="s2">S</span><span class="s1">, </span><span class="s2">K</span><span class="s0">&gt;&gt; : </span><span class="s2">T extends TUnion</span><span class="s0">&lt;</span><span class="s2">infer S</span><span class="s0">&gt; ? </span><span class="s2">TUnion</span><span class="s0">&lt;</span><span class="s2">TOmitArray</span><span class="s0">&lt;</span><span class="s2">S</span><span class="s1">, </span><span class="s2">K</span><span class="s0">&gt;&gt; : </span><span class="s2">T extends TObject</span><span class="s0">&lt;</span><span class="s2">infer S</span><span class="s0">&gt; ? </span><span class="s2">TObject</span><span class="s0">&lt;</span><span class="s2">TOmitProperties</span><span class="s0">&lt;</span><span class="s2">S</span><span class="s1">, </span><span class="s2">K</span><span class="s0">&gt;&gt; : </span><span class="s2">T</span><span class="s1">;</span>
<span class="s2">export type TParameters</span><span class="s0">&lt;</span><span class="s2">T extends TFunction</span><span class="s0">&gt; = </span><span class="s2">TTuple</span><span class="s0">&lt;</span><span class="s2">T</span><span class="s1">[</span><span class="s3">'parameters'</span><span class="s1">]</span><span class="s0">&gt;</span><span class="s1">;</span>
<span class="s2">export type TPartialObjectArray</span><span class="s0">&lt;</span><span class="s2">T extends TObject</span><span class="s1">[]</span><span class="s0">&gt; = </span><span class="s7">Assert</span><span class="s1">&lt;{</span>
    <span class="s1">[</span><span class="s2">K </span><span class="s0">in keyof </span><span class="s2">T</span><span class="s1">]</span><span class="s0">: </span><span class="s2">TPartial</span><span class="s1">&lt;</span><span class="s2">Assert</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">[</span><span class="s2">K</span><span class="s1">], </span><span class="s2">TObject</span><span class="s1">&gt;&gt;;</span>
<span class="s1">}, </span><span class="s2">TObject</span><span class="s1">[]&gt;;</span>
<span class="s2">export type TPartialArray</span><span class="s0">&lt;</span><span class="s2">T extends TSchema</span><span class="s1">[]</span><span class="s0">&gt; = </span><span class="s7">Assert</span><span class="s1">&lt;{</span>
    <span class="s1">[</span><span class="s2">K </span><span class="s0">in keyof </span><span class="s2">T</span><span class="s1">]</span><span class="s0">: </span><span class="s2">TPartial</span><span class="s1">&lt;</span><span class="s2">Assert</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">[</span><span class="s2">K</span><span class="s1">], </span><span class="s2">TSchema</span><span class="s1">&gt;&gt;;</span>
<span class="s1">}, </span><span class="s2">TSchema</span><span class="s1">[]&gt;;</span>
<span class="s2">export type TPartialProperties</span><span class="s0">&lt;</span><span class="s2">T extends TProperties</span><span class="s0">&gt; = </span><span class="s2">Evaluate</span><span class="s0">&lt;</span><span class="s7">Assert</span><span class="s1">&lt;{</span>
    <span class="s1">[</span><span class="s2">K </span><span class="s0">in keyof </span><span class="s2">T</span><span class="s1">]</span><span class="s0">: </span><span class="s2">T</span><span class="s1">[</span><span class="s2">K</span><span class="s1">] </span><span class="s0">extends </span><span class="s2">TReadonlyOptional</span><span class="s1">&lt;</span><span class="s0">infer </span><span class="s2">U</span><span class="s1">&gt; </span><span class="s0">? </span><span class="s2">TReadonlyOptional</span><span class="s1">&lt;</span><span class="s2">U</span><span class="s1">&gt; </span><span class="s0">: </span><span class="s2">T</span><span class="s1">[</span><span class="s2">K</span><span class="s1">] </span><span class="s0">extends </span><span class="s2">TReadonly</span><span class="s1">&lt;</span><span class="s0">infer </span><span class="s2">U</span><span class="s1">&gt; </span><span class="s0">? </span><span class="s2">TReadonlyOptional</span><span class="s1">&lt;</span><span class="s2">U</span><span class="s1">&gt; </span><span class="s0">: </span><span class="s2">T</span><span class="s1">[</span><span class="s2">K</span><span class="s1">] </span><span class="s0">extends </span><span class="s2">TOptional</span><span class="s1">&lt;</span><span class="s0">infer </span><span class="s2">U</span><span class="s1">&gt; </span><span class="s0">? </span><span class="s2">TOptional</span><span class="s1">&lt;</span><span class="s2">U</span><span class="s1">&gt; </span><span class="s0">: </span><span class="s2">TOptional</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">[</span><span class="s2">K</span><span class="s1">]&gt;;</span>
<span class="s1">}, </span><span class="s2">TProperties</span><span class="s1">&gt;</span><span class="s0">&gt;</span><span class="s1">;</span>
<span class="s2">export type TPartial</span><span class="s0">&lt;</span><span class="s2">T extends TSchema</span><span class="s0">&gt; = </span><span class="s2">T extends TRecursive</span><span class="s0">&lt;</span><span class="s2">infer S</span><span class="s0">&gt; ? </span><span class="s2">TRecursive</span><span class="s0">&lt;</span><span class="s2">TPartial</span><span class="s0">&lt;</span><span class="s2">S</span><span class="s0">&gt;&gt; : </span><span class="s2">T extends TComposite</span><span class="s0">&lt;</span><span class="s2">infer S</span><span class="s0">&gt; ? </span><span class="s2">TComposite</span><span class="s0">&lt;</span><span class="s2">TPartialArray</span><span class="s0">&lt;</span><span class="s2">S</span><span class="s0">&gt;&gt; : </span><span class="s2">T extends TIntersect</span><span class="s0">&lt;</span><span class="s2">infer S</span><span class="s0">&gt; ? </span><span class="s2">TIntersect</span><span class="s0">&lt;</span><span class="s2">TPartialArray</span><span class="s0">&lt;</span><span class="s2">S</span><span class="s0">&gt;&gt; : </span><span class="s2">T extends TUnion</span><span class="s0">&lt;</span><span class="s2">infer S</span><span class="s0">&gt; ? </span><span class="s2">TUnion</span><span class="s0">&lt;</span><span class="s2">TPartialArray</span><span class="s0">&lt;</span><span class="s2">S</span><span class="s0">&gt;&gt; : </span><span class="s2">T extends TObject</span><span class="s0">&lt;</span><span class="s2">infer S</span><span class="s0">&gt; ? </span><span class="s2">TObject</span><span class="s0">&lt;</span><span class="s2">TPartialProperties</span><span class="s0">&lt;</span><span class="s2">S</span><span class="s0">&gt;&gt; : </span><span class="s2">T</span><span class="s1">;</span>
<span class="s2">export type TPickArray</span><span class="s0">&lt;</span><span class="s2">T extends TSchema</span><span class="s1">[], </span><span class="s2">K extends keyof any</span><span class="s0">&gt; = </span><span class="s1">{</span>
    <span class="s1">[</span><span class="s2">K2 </span><span class="s0">in </span><span class="s2">keyof T</span><span class="s1">]: </span><span class="s2">TPick</span><span class="s0">&lt;</span><span class="s2">Assert</span><span class="s0">&lt;</span><span class="s2">T</span><span class="s1">[</span><span class="s2">K2</span><span class="s1">], TSchema&gt;, K&gt;; 
};</span>
<span class="s2">export type TPickProperties</span><span class="s0">&lt;</span><span class="s2">T extends </span><span class="s1">TProperties, </span><span class="s2">K extends keyof any</span><span class="s0">&gt; = </span><span class="s2">Pick</span><span class="s0">&lt;</span><span class="s2">T</span><span class="s1">, </span><span class="s2">Assert</span><span class="s0">&lt;</span><span class="s2">Extract</span><span class="s0">&lt;</span><span class="s1">K, </span><span class="s2">keyof T</span><span class="s0">&gt;</span><span class="s1">, </span><span class="s2">keyof T</span><span class="s0">&gt;&gt; </span><span class="s2">extends infer </span><span class="s1">R </span><span class="s0">? </span><span class="s1">({</span>
    <span class="s1">[</span><span class="s2">K </span><span class="s0">in </span><span class="s2">keyof R</span><span class="s1">]: </span><span class="s2">Assert</span><span class="s1">&lt;</span><span class="s2">R</span><span class="s1">[</span><span class="s2">K</span><span class="s1">], </span><span class="s2">TSchema</span><span class="s1">&gt; </span><span class="s2">extends TSchema </span><span class="s1">? </span><span class="s2">R</span><span class="s1">[</span><span class="s2">K</span><span class="s1">] : </span><span class="s2">never</span><span class="s1">; 
}) </span><span class="s0">: </span><span class="s2">never</span><span class="s1">;</span>
<span class="s2">export type TPick</span><span class="s0">&lt;</span><span class="s2">T extends </span><span class="s1">TSchema </span><span class="s0">= </span><span class="s2">TSchema</span><span class="s1">, </span><span class="s2">K extends keyof </span><span class="s1">any </span><span class="s0">= </span><span class="s2">keyof any</span><span class="s0">&gt; = </span><span class="s2">T extends TRecursive</span><span class="s0">&lt;</span><span class="s2">infer S</span><span class="s0">&gt; ? </span><span class="s2">TRecursive</span><span class="s0">&lt;</span><span class="s2">TPick</span><span class="s0">&lt;</span><span class="s2">S</span><span class="s1">, </span><span class="s2">K</span><span class="s0">&gt;&gt; : </span><span class="s2">T extends TComposite</span><span class="s0">&lt;</span><span class="s2">infer S</span><span class="s0">&gt; ? </span><span class="s2">TComposite</span><span class="s0">&lt;</span><span class="s2">TPickArray</span><span class="s0">&lt;</span><span class="s2">S</span><span class="s1">, </span><span class="s2">K</span><span class="s0">&gt;&gt; : </span><span class="s2">T extends TIntersect</span><span class="s0">&lt;</span><span class="s2">infer S</span><span class="s0">&gt; ? </span><span class="s2">TIntersect</span><span class="s0">&lt;</span><span class="s2">TPickArray</span><span class="s0">&lt;</span><span class="s2">S</span><span class="s1">, </span><span class="s2">K</span><span class="s0">&gt;&gt; : </span><span class="s2">T extends TUnion</span><span class="s0">&lt;</span><span class="s2">infer S</span><span class="s0">&gt; ? </span><span class="s2">TUnion</span><span class="s0">&lt;</span><span class="s2">TPickArray</span><span class="s0">&lt;</span><span class="s2">S</span><span class="s1">, </span><span class="s2">K</span><span class="s0">&gt;&gt; : </span><span class="s2">T extends TObject</span><span class="s0">&lt;</span><span class="s2">infer S</span><span class="s0">&gt; ? </span><span class="s2">TObject</span><span class="s0">&lt;</span><span class="s2">TPickProperties</span><span class="s0">&lt;</span><span class="s2">S</span><span class="s1">, </span><span class="s2">K</span><span class="s0">&gt;&gt; : </span><span class="s2">T</span><span class="s1">;</span>
<span class="s2">export interface TPromise</span><span class="s0">&lt;</span><span class="s2">T extends </span><span class="s1">TSchema </span><span class="s0">= </span><span class="s2">TSchema</span><span class="s0">&gt; </span><span class="s2">extends TSchema </span><span class="s1">{</span>
    <span class="s1">[</span><span class="s2">Kind</span><span class="s1">]: </span><span class="s3">'Promise'</span><span class="s1">; 
    </span><span class="s2">static</span><span class="s1">: Promise</span><span class="s0">&lt;</span><span class="s2">Static</span><span class="s0">&lt;</span><span class="s2">T</span><span class="s1">, this[</span><span class="s3">'params'</span><span class="s1">]&gt;&gt;; 
    type: </span><span class="s3">'object'</span><span class="s1">; 
    </span><span class="s2">instanceOf</span><span class="s1">: </span><span class="s3">'Promise'</span><span class="s1">; 
    </span><span class="s2">item</span><span class="s1">: </span><span class="s2">TSchema</span><span class="s1">; 
}</span>
<span class="s2">export type RecordTemplateLiteralObjectType</span><span class="s0">&lt;</span><span class="s2">K extends </span><span class="s1">TTemplateLiteral, </span><span class="s2">T extends TSchema</span><span class="s0">&gt; = </span><span class="s2">Ensure</span><span class="s0">&lt;</span><span class="s2">TObject</span><span class="s0">&lt;</span><span class="s7">Evaluate</span><span class="s1">&lt;{</span>
    <span class="s1">[</span><span class="s2">_ </span><span class="s0">in </span><span class="s2">Static</span><span class="s1">&lt;</span><span class="s2">K</span><span class="s1">&gt;]</span><span class="s0">: </span><span class="s2">T</span><span class="s1">;</span>
<span class="s1">}&gt;</span><span class="s0">&gt;&gt;</span><span class="s1">;</span>
<span class="s2">export type RecordTemplateLiteralType</span><span class="s0">&lt;</span><span class="s2">K extends </span><span class="s1">TTemplateLiteral, </span><span class="s2">T extends TSchema</span><span class="s0">&gt; = </span><span class="s2">IsTemplateLiteralFinite</span><span class="s0">&lt;</span><span class="s2">K</span><span class="s0">&gt; </span><span class="s2">extends </span><span class="s6">true </span><span class="s0">? </span><span class="s2">RecordTemplateLiteralObjectType</span><span class="s0">&lt;</span><span class="s2">K</span><span class="s1">, </span><span class="s2">T</span><span class="s0">&gt; : </span><span class="s2">TRecord</span><span class="s0">&lt;</span><span class="s2">K</span><span class="s1">, </span><span class="s2">T</span><span class="s0">&gt;</span><span class="s1">;</span>
<span class="s2">export type RecordUnionLiteralType</span><span class="s0">&lt;</span><span class="s2">K extends TUnion</span><span class="s0">&lt;</span><span class="s2">TLiteral</span><span class="s0">&lt;</span><span class="s2">string </span><span class="s0">| </span><span class="s2">number</span><span class="s0">&gt;</span><span class="s1">[]</span><span class="s0">&gt;</span><span class="s1">, </span><span class="s2">T extends TSchema</span><span class="s0">&gt; = </span><span class="s2">Static</span><span class="s0">&lt;</span><span class="s2">K</span><span class="s0">&gt; </span><span class="s2">extends string </span><span class="s0">? </span><span class="s2">Ensure</span><span class="s0">&lt;</span><span class="s7">TObject</span><span class="s1">&lt;{</span>
    <span class="s1">[</span><span class="s2">X </span><span class="s0">in </span><span class="s2">Static</span><span class="s1">&lt;</span><span class="s2">K</span><span class="s1">&gt;]</span><span class="s0">: </span><span class="s2">T</span><span class="s1">;</span>
<span class="s1">}&gt;</span><span class="s0">&gt; : </span><span class="s2">never</span><span class="s1">;</span>
<span class="s2">export type RecordLiteralType</span><span class="s0">&lt;</span><span class="s2">K extends TLiteral</span><span class="s0">&lt;</span><span class="s2">string </span><span class="s0">| </span><span class="s2">number</span><span class="s0">&gt;</span><span class="s1">, </span><span class="s2">T extends TSchema</span><span class="s0">&gt; = </span><span class="s2">Ensure</span><span class="s0">&lt;</span><span class="s7">TObject</span><span class="s1">&lt;{</span>
    <span class="s1">[</span><span class="s2">K2 </span><span class="s0">in </span><span class="s2">K</span><span class="s1">[</span><span class="s3">'const'</span><span class="s1">]]</span><span class="s0">: </span><span class="s2">T</span><span class="s1">;</span>
<span class="s1">}&gt;</span><span class="s0">&gt;</span><span class="s1">;</span>
<span class="s2">export type RecordNumberType</span><span class="s0">&lt;</span><span class="s2">K extends TInteger </span><span class="s0">| </span><span class="s1">TNumber, </span><span class="s2">T extends TSchema</span><span class="s0">&gt; = </span><span class="s2">Ensure</span><span class="s0">&lt;</span><span class="s2">TRecord</span><span class="s0">&lt;</span><span class="s2">K</span><span class="s1">, </span><span class="s2">T</span><span class="s0">&gt;&gt;</span><span class="s1">;</span>
<span class="s2">export type RecordStringType</span><span class="s0">&lt;</span><span class="s2">K extends </span><span class="s1">TString, </span><span class="s2">T extends TSchema</span><span class="s0">&gt; = </span><span class="s2">Ensure</span><span class="s0">&lt;</span><span class="s2">TRecord</span><span class="s0">&lt;</span><span class="s2">K</span><span class="s1">, </span><span class="s2">T</span><span class="s0">&gt;&gt;</span><span class="s1">;</span>
<span class="s2">export type </span><span class="s1">RecordKey </span><span class="s0">= </span><span class="s2">TUnion</span><span class="s0">&lt;</span><span class="s2">TLiteral</span><span class="s0">&lt;</span><span class="s2">string </span><span class="s0">| </span><span class="s2">number</span><span class="s0">&gt;</span><span class="s1">[]</span><span class="s0">&gt; | </span><span class="s2">TLiteral</span><span class="s0">&lt;</span><span class="s2">string </span><span class="s0">| </span><span class="s2">number</span><span class="s0">&gt; | </span><span class="s2">TTemplateLiteral </span><span class="s0">| </span><span class="s2">TInteger </span><span class="s0">| </span><span class="s2">TNumber </span><span class="s0">| </span><span class="s2">TString</span><span class="s1">;</span>
<span class="s2">export interface TRecord</span><span class="s0">&lt;</span><span class="s2">K extends </span><span class="s1">RecordKey </span><span class="s0">= </span><span class="s2">RecordKey</span><span class="s1">, </span><span class="s2">T extends </span><span class="s1">TSchema </span><span class="s0">= </span><span class="s2">TSchema</span><span class="s0">&gt; </span><span class="s2">extends TSchema </span><span class="s1">{</span>
    <span class="s1">[</span><span class="s2">Kind</span><span class="s1">]: </span><span class="s3">'Record'</span><span class="s1">; 
    </span><span class="s2">static</span><span class="s1">: </span><span class="s2">Record</span><span class="s0">&lt;</span><span class="s2">Static</span><span class="s0">&lt;</span><span class="s2">K</span><span class="s0">&gt;</span><span class="s1">, Static&lt;</span><span class="s2">T</span><span class="s1">, this[</span><span class="s3">'params'</span><span class="s1">]&gt;&gt;; 
    type: </span><span class="s3">'object'</span><span class="s1">; 
    </span><span class="s2">patternProperties</span><span class="s1">: {</span>
        <span class="s1">[</span><span class="s2">pattern</span><span class="s1">: </span><span class="s2">string</span><span class="s1">]: </span><span class="s2">T</span><span class="s1">; 
    }; 
    </span><span class="s2">additionalProperties</span><span class="s1">: </span><span class="s6">false</span><span class="s1">; 
}</span>
<span class="s2">export interface TThis extends TSchema </span><span class="s1">{</span>
    <span class="s1">[</span><span class="s2">Kind</span><span class="s1">]: </span><span class="s3">'This'</span><span class="s1">;</span>
    <span class="s2">static</span><span class="s1">: </span><span class="s2">this</span><span class="s1">[</span><span class="s3">'params'</span><span class="s1">][</span><span class="s4">0</span><span class="s1">];</span>
    <span class="s2">$ref</span><span class="s1">: </span><span class="s2">string</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export type TRecursiveReduce</span><span class="s0">&lt;</span><span class="s2">T extends TSchema</span><span class="s0">&gt; = </span><span class="s2">Static</span><span class="s0">&lt;</span><span class="s2">T</span><span class="s1">, [</span><span class="s2">TRecursiveReduce</span><span class="s0">&lt;</span><span class="s2">T</span><span class="s0">&gt;</span><span class="s1">]</span><span class="s0">&gt;</span><span class="s1">;</span>
<span class="s2">export interface TRecursive</span><span class="s0">&lt;</span><span class="s2">T extends TSchema</span><span class="s0">&gt; </span><span class="s2">extends TSchema </span><span class="s1">{</span>
    <span class="s1">[</span><span class="s2">Hint</span><span class="s1">]: </span><span class="s3">'Recursive'</span><span class="s1">;</span>
    <span class="s2">static</span><span class="s1">: </span><span class="s2">TRecursiveReduce</span><span class="s0">&lt;</span><span class="s2">T</span><span class="s0">&gt;</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export interface TRef</span><span class="s0">&lt;</span><span class="s2">T extends </span><span class="s1">TSchema </span><span class="s0">= </span><span class="s2">TSchema</span><span class="s0">&gt; </span><span class="s2">extends TSchema </span><span class="s1">{</span>
    <span class="s1">[</span><span class="s2">Kind</span><span class="s1">]: </span><span class="s3">'Ref'</span><span class="s1">; 
    </span><span class="s2">static</span><span class="s1">: </span><span class="s2">Static</span><span class="s0">&lt;</span><span class="s2">T</span><span class="s1">, this[</span><span class="s3">'params'</span><span class="s1">]&gt;; 
    $ref: </span><span class="s2">string</span><span class="s1">; 
}</span>
<span class="s2">export type TReturnType</span><span class="s0">&lt;</span><span class="s2">T extends TFunction</span><span class="s0">&gt; = </span><span class="s2">T</span><span class="s1">[</span><span class="s3">'returns'</span><span class="s1">];</span>
<span class="s2">export type TRequiredArray</span><span class="s0">&lt;</span><span class="s2">T extends TSchema</span><span class="s1">[]</span><span class="s0">&gt; = </span><span class="s7">Assert</span><span class="s1">&lt;{</span>
    <span class="s1">[</span><span class="s2">K </span><span class="s0">in keyof </span><span class="s2">T</span><span class="s1">]</span><span class="s0">: </span><span class="s2">TRequired</span><span class="s1">&lt;</span><span class="s2">Assert</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">[</span><span class="s2">K</span><span class="s1">], </span><span class="s2">TSchema</span><span class="s1">&gt;&gt;;</span>
<span class="s1">}, </span><span class="s2">TSchema</span><span class="s1">[]&gt;;</span>
<span class="s2">export type TRequiredProperties</span><span class="s0">&lt;</span><span class="s2">T extends TProperties</span><span class="s0">&gt; = </span><span class="s2">Evaluate</span><span class="s0">&lt;</span><span class="s7">Assert</span><span class="s1">&lt;{</span>
    <span class="s1">[</span><span class="s2">K </span><span class="s0">in keyof </span><span class="s2">T</span><span class="s1">]</span><span class="s0">: </span><span class="s2">T</span><span class="s1">[</span><span class="s2">K</span><span class="s1">] </span><span class="s0">extends </span><span class="s2">TReadonlyOptional</span><span class="s1">&lt;</span><span class="s0">infer </span><span class="s2">U</span><span class="s1">&gt; </span><span class="s0">? </span><span class="s2">TReadonly</span><span class="s1">&lt;</span><span class="s2">U</span><span class="s1">&gt; </span><span class="s0">: </span><span class="s2">T</span><span class="s1">[</span><span class="s2">K</span><span class="s1">] </span><span class="s0">extends </span><span class="s2">TReadonly</span><span class="s1">&lt;</span><span class="s0">infer </span><span class="s2">U</span><span class="s1">&gt; </span><span class="s0">? </span><span class="s2">TReadonly</span><span class="s1">&lt;</span><span class="s2">U</span><span class="s1">&gt; </span><span class="s0">: </span><span class="s2">T</span><span class="s1">[</span><span class="s2">K</span><span class="s1">] </span><span class="s0">extends </span><span class="s2">TOptional</span><span class="s1">&lt;</span><span class="s0">infer </span><span class="s2">U</span><span class="s1">&gt; </span><span class="s0">? </span><span class="s2">U </span><span class="s0">: </span><span class="s2">T</span><span class="s1">[</span><span class="s2">K</span><span class="s1">];</span>
<span class="s1">}, </span><span class="s2">TProperties</span><span class="s1">&gt;</span><span class="s0">&gt;</span><span class="s1">;</span>
<span class="s2">export type TRequired</span><span class="s0">&lt;</span><span class="s2">T extends TSchema</span><span class="s0">&gt; = </span><span class="s2">T extends TRecursive</span><span class="s0">&lt;</span><span class="s2">infer S</span><span class="s0">&gt; ? </span><span class="s2">TRecursive</span><span class="s0">&lt;</span><span class="s2">TRequired</span><span class="s0">&lt;</span><span class="s2">S</span><span class="s0">&gt;&gt; : </span><span class="s2">T extends TComposite</span><span class="s0">&lt;</span><span class="s2">infer S</span><span class="s0">&gt; ? </span><span class="s2">TComposite</span><span class="s0">&lt;</span><span class="s2">TRequiredArray</span><span class="s0">&lt;</span><span class="s2">S</span><span class="s0">&gt;&gt; : </span><span class="s2">T extends TIntersect</span><span class="s0">&lt;</span><span class="s2">infer S</span><span class="s0">&gt; ? </span><span class="s2">TIntersect</span><span class="s0">&lt;</span><span class="s2">TRequiredArray</span><span class="s0">&lt;</span><span class="s2">S</span><span class="s0">&gt;&gt; : </span><span class="s2">T extends TUnion</span><span class="s0">&lt;</span><span class="s2">infer S</span><span class="s0">&gt; ? </span><span class="s2">TUnion</span><span class="s0">&lt;</span><span class="s2">TRequiredArray</span><span class="s0">&lt;</span><span class="s2">S</span><span class="s0">&gt;&gt; : </span><span class="s2">T extends TObject</span><span class="s0">&lt;</span><span class="s2">infer S</span><span class="s0">&gt; ? </span><span class="s2">TObject</span><span class="s0">&lt;</span><span class="s2">TRequiredProperties</span><span class="s0">&lt;</span><span class="s2">S</span><span class="s0">&gt;&gt; : </span><span class="s2">T</span><span class="s1">;</span>
<span class="s2">export type </span><span class="s1">StringFormatOption </span><span class="s0">= </span><span class="s3">'date-time' </span><span class="s0">| </span><span class="s3">'time' </span><span class="s0">| </span><span class="s3">'date' </span><span class="s0">| </span><span class="s3">'email' </span><span class="s0">| </span><span class="s3">'idn-email' </span><span class="s0">| </span><span class="s3">'hostname' </span><span class="s0">| </span><span class="s3">'idn-hostname' </span><span class="s0">| </span><span class="s3">'ipv4' </span><span class="s0">| </span><span class="s3">'ipv6' </span><span class="s0">| </span><span class="s3">'uri' </span><span class="s0">| </span><span class="s3">'uri-reference' </span><span class="s0">| </span><span class="s3">'iri' </span><span class="s0">| </span><span class="s3">'uuid' </span><span class="s0">| </span><span class="s3">'iri-reference' </span><span class="s0">| </span><span class="s3">'uri-template' </span><span class="s0">| </span><span class="s3">'json-pointer' </span><span class="s0">| </span><span class="s3">'relative-json-pointer' </span><span class="s0">| </span><span class="s3">'regex'</span><span class="s1">;</span>
<span class="s2">export interface StringOptions</span><span class="s0">&lt;</span><span class="s2">Format extends string</span><span class="s0">&gt; </span><span class="s2">extends SchemaOptions </span><span class="s1">{</span>
    <span class="s2">minLength</span><span class="s0">?: </span><span class="s2">number</span><span class="s1">;</span>
    <span class="s2">maxLength</span><span class="s0">?: </span><span class="s2">number</span><span class="s1">;</span>
    <span class="s2">pattern</span><span class="s0">?: </span><span class="s2">string</span><span class="s1">;</span>
    <span class="s2">format</span><span class="s0">?: </span><span class="s2">Format</span><span class="s1">;</span>
    <span class="s2">contentEncoding</span><span class="s0">?: </span><span class="s3">'7bit' </span><span class="s0">| </span><span class="s3">'8bit' </span><span class="s0">| </span><span class="s3">'binary' </span><span class="s0">| </span><span class="s3">'quoted-printable' </span><span class="s0">| </span><span class="s3">'base64'</span><span class="s1">;</span>
    <span class="s2">contentMediaType</span><span class="s0">?: </span><span class="s2">string</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export interface TString</span><span class="s0">&lt;</span><span class="s2">Format extends </span><span class="s1">string </span><span class="s0">= </span><span class="s2">string</span><span class="s0">&gt; </span><span class="s2">extends TSchema</span><span class="s1">, </span><span class="s2">StringOptions</span><span class="s0">&lt;</span><span class="s2">Format</span><span class="s0">&gt; </span><span class="s1">{</span>
    <span class="s1">[</span><span class="s2">Kind</span><span class="s1">]: </span><span class="s3">'String'</span><span class="s1">; 
    </span><span class="s2">static</span><span class="s1">: </span><span class="s2">string</span><span class="s1">; 
    </span><span class="s2">type</span><span class="s1">: </span><span class="s3">'string'</span><span class="s1">; 
}</span>
<span class="s2">export type </span><span class="s1">SymbolValue </span><span class="s0">= </span><span class="s2">string </span><span class="s0">| </span><span class="s2">number </span><span class="s0">| </span><span class="s6">undefined</span><span class="s1">;</span>
<span class="s2">export interface TSymbol extends </span><span class="s1">TSchema, </span><span class="s2">SchemaOptions </span><span class="s1">{</span>
    <span class="s1">[</span><span class="s2">Kind</span><span class="s1">]: </span><span class="s3">'Symbol'</span><span class="s1">;</span>
    <span class="s2">static</span><span class="s1">: </span><span class="s2">symbol</span><span class="s1">;</span>
    <span class="s2">type</span><span class="s1">: </span><span class="s3">'null'</span><span class="s1">;</span>
    <span class="s2">typeOf</span><span class="s1">: </span><span class="s3">'Symbol'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export type IsTemplateLiteralFiniteCheck</span><span class="s0">&lt;</span><span class="s2">T</span><span class="s0">&gt; = </span><span class="s2">T extends TTemplateLiteral</span><span class="s0">&lt;</span><span class="s2">infer U</span><span class="s0">&gt; ? </span><span class="s2">IsTemplateLiteralFiniteArray</span><span class="s0">&lt;</span><span class="s2">Assert</span><span class="s0">&lt;</span><span class="s2">U</span><span class="s1">, </span><span class="s2">TTemplateLiteralKind</span><span class="s1">[]</span><span class="s0">&gt;&gt; : </span><span class="s2">T extends TUnion</span><span class="s0">&lt;</span><span class="s2">infer U</span><span class="s0">&gt; ? </span><span class="s2">IsTemplateLiteralFiniteArray</span><span class="s0">&lt;</span><span class="s2">Assert</span><span class="s0">&lt;</span><span class="s2">U</span><span class="s1">, </span><span class="s2">TTemplateLiteralKind</span><span class="s1">[]</span><span class="s0">&gt;&gt; : </span><span class="s2">T extends TString </span><span class="s0">? </span><span class="s6">false </span><span class="s0">: </span><span class="s2">T extends TBoolean </span><span class="s0">? </span><span class="s6">false </span><span class="s0">: </span><span class="s2">T extends TNumber </span><span class="s0">? </span><span class="s6">false </span><span class="s0">: </span><span class="s2">T extends TInteger </span><span class="s0">? </span><span class="s6">false </span><span class="s0">: </span><span class="s2">T extends TBigInt </span><span class="s0">? </span><span class="s6">false </span><span class="s0">: </span><span class="s2">T extends TLiteral </span><span class="s0">? </span><span class="s6">true </span><span class="s0">: </span><span class="s6">false</span><span class="s1">;</span>
<span class="s2">export type IsTemplateLiteralFiniteArray</span><span class="s0">&lt;</span><span class="s2">T extends TTemplateLiteralKind</span><span class="s1">[]</span><span class="s0">&gt; = </span><span class="s2">T extends </span><span class="s1">[</span><span class="s2">infer L</span><span class="s1">, </span><span class="s0">...</span><span class="s2">infer R</span><span class="s1">] </span><span class="s0">? </span><span class="s2">IsTemplateLiteralFiniteCheck</span><span class="s0">&lt;</span><span class="s2">L</span><span class="s0">&gt; </span><span class="s2">extends </span><span class="s6">false </span><span class="s0">? </span><span class="s6">false </span><span class="s0">: </span><span class="s2">IsTemplateLiteralFiniteArray</span><span class="s0">&lt;</span><span class="s2">Assert</span><span class="s0">&lt;</span><span class="s2">R</span><span class="s1">, </span><span class="s2">TTemplateLiteralKind</span><span class="s1">[]</span><span class="s0">&gt;&gt; : </span><span class="s2">T extends </span><span class="s1">[</span><span class="s2">infer L</span><span class="s1">] </span><span class="s0">? </span><span class="s2">IsTemplateLiteralFiniteCheck</span><span class="s0">&lt;</span><span class="s2">L</span><span class="s0">&gt; </span><span class="s2">extends </span><span class="s6">false </span><span class="s0">? </span><span class="s6">false </span><span class="s0">: </span><span class="s6">true </span><span class="s0">: </span><span class="s6">true</span><span class="s1">;</span>
<span class="s2">export type IsTemplateLiteralFinite</span><span class="s0">&lt;</span><span class="s2">T</span><span class="s0">&gt; = </span><span class="s2">T extends TTemplateLiteral</span><span class="s0">&lt;</span><span class="s2">infer U</span><span class="s0">&gt; ? </span><span class="s2">IsTemplateLiteralFiniteArray</span><span class="s0">&lt;</span><span class="s2">U</span><span class="s0">&gt; : </span><span class="s6">false</span><span class="s1">;</span>
<span class="s2">export type </span><span class="s1">TTemplateLiteralKind </span><span class="s0">= </span><span class="s2">TUnion </span><span class="s0">| </span><span class="s2">TLiteral </span><span class="s0">| </span><span class="s2">TInteger </span><span class="s0">| </span><span class="s2">TTemplateLiteral </span><span class="s0">| </span><span class="s2">TNumber </span><span class="s0">| </span><span class="s2">TBigInt </span><span class="s0">| </span><span class="s2">TString </span><span class="s0">| </span><span class="s2">TBoolean </span><span class="s0">| </span><span class="s2">TNever</span><span class="s1">;</span>
<span class="s2">export type TTemplateLiteralConst</span><span class="s0">&lt;</span><span class="s1">T, </span><span class="s2">Acc extends string</span><span class="s0">&gt; = </span><span class="s2">T extends TUnion</span><span class="s0">&lt;</span><span class="s2">infer U</span><span class="s0">&gt; ? </span><span class="s1">{</span>
    <span class="s1">[</span><span class="s2">K </span><span class="s0">in </span><span class="s2">keyof U</span><span class="s1">]: </span><span class="s2">TTemplateLiteralUnion</span><span class="s0">&lt;</span><span class="s2">Assert</span><span class="s0">&lt;</span><span class="s1">[</span><span class="s2">U</span><span class="s1">[</span><span class="s2">K</span><span class="s1">]], TTemplateLiteralKind[]&gt;, Acc&gt;; 
}[</span><span class="s2">number</span><span class="s1">] : </span><span class="s2">T extends TTemplateLiteral </span><span class="s0">? </span><span class="s3">`${</span><span class="s2">Static</span><span class="s0">&lt;</span><span class="s2">T</span><span class="s0">&gt;</span><span class="s3">}` </span><span class="s0">: </span><span class="s2">T extends TLiteral</span><span class="s0">&lt;</span><span class="s2">infer U</span><span class="s0">&gt; ? </span><span class="s3">`${</span><span class="s2">U</span><span class="s3">}` </span><span class="s0">: </span><span class="s2">T extends TString </span><span class="s0">? </span><span class="s3">`${</span><span class="s2">string</span><span class="s3">}` </span><span class="s0">: </span><span class="s2">T extends TNumber </span><span class="s0">? </span><span class="s3">`${</span><span class="s2">number</span><span class="s3">}` </span><span class="s0">: </span><span class="s2">T extends TBigInt </span><span class="s0">? </span><span class="s3">`${</span><span class="s2">bigint</span><span class="s3">}` </span><span class="s0">: </span><span class="s2">T extends TBoolean </span><span class="s0">? </span><span class="s3">`${</span><span class="s2">boolean</span><span class="s3">}` </span><span class="s0">: </span><span class="s2">never</span><span class="s1">; 
</span><span class="s2">export type TTemplateLiteralUnion</span><span class="s0">&lt;</span><span class="s2">T extends TTemplateLiteralKind</span><span class="s1">[], Acc extends </span><span class="s2">string </span><span class="s0">= </span><span class="s3">''</span><span class="s0">&gt; = </span><span class="s2">T extends </span><span class="s1">[</span><span class="s2">infer L</span><span class="s1">, </span><span class="s0">...</span><span class="s2">infer R</span><span class="s1">] </span><span class="s0">? </span><span class="s3">`${</span><span class="s2">TTemplateLiteralConst</span><span class="s0">&lt;</span><span class="s2">L</span><span class="s3">, </span><span class="s2">Acc</span><span class="s0">&gt;</span><span class="s3">}${</span><span class="s2">TTemplateLiteralUnion</span><span class="s0">&lt;</span><span class="s2">Assert</span><span class="s0">&lt;</span><span class="s2">R</span><span class="s3">, </span><span class="s2">TTemplateLiteralKind</span><span class="s3">[]</span><span class="s0">&gt;</span><span class="s3">, </span><span class="s2">Acc</span><span class="s0">&gt;</span><span class="s3">}` </span><span class="s0">: </span><span class="s2">T extends </span><span class="s1">[</span><span class="s2">infer L</span><span class="s1">] </span><span class="s0">? </span><span class="s3">`${</span><span class="s2">TTemplateLiteralConst</span><span class="s0">&lt;</span><span class="s2">L</span><span class="s3">, </span><span class="s2">Acc</span><span class="s0">&gt;</span><span class="s3">}${</span><span class="s2">Acc</span><span class="s3">}` </span><span class="s0">: </span><span class="s2">Acc</span><span class="s1">;</span>
<span class="s1">export interface TTemplateLiteral&lt;T extends TTemplateLiteralKind[] = TTemplateLiteralKind[]&gt; extends TSchema { 
    [</span><span class="s2">Kind</span><span class="s1">]: </span><span class="s3">'TemplateLiteral'</span><span class="s1">; 
    </span><span class="s2">static</span><span class="s1">: </span><span class="s2">TTemplateLiteralUnion</span><span class="s0">&lt;</span><span class="s2">T</span><span class="s0">&gt;</span><span class="s1">; 
    </span><span class="s2">type</span><span class="s1">: </span><span class="s3">'string'</span><span class="s1">; 
    </span><span class="s2">pattern</span><span class="s1">: </span><span class="s2">string</span><span class="s1">; 
}</span>
<span class="s2">export type TTupleIntoArray</span><span class="s0">&lt;</span><span class="s2">T extends TTuple</span><span class="s0">&lt;</span><span class="s2">TSchema</span><span class="s1">[]</span><span class="s0">&gt;&gt; = </span><span class="s2">T extends TTuple</span><span class="s0">&lt;</span><span class="s2">infer R</span><span class="s0">&gt; ? </span><span class="s2">Assert</span><span class="s0">&lt;</span><span class="s2">R</span><span class="s1">, </span><span class="s2">TSchema</span><span class="s1">[]</span><span class="s0">&gt; : </span><span class="s2">never</span><span class="s1">; 
</span><span class="s2">export interface TTuple</span><span class="s0">&lt;</span><span class="s2">T extends TSchema</span><span class="s1">[] </span><span class="s0">= </span><span class="s2">TSchema</span><span class="s1">[]</span><span class="s0">&gt; </span><span class="s2">extends TSchema </span><span class="s1">{</span>
    <span class="s1">[</span><span class="s2">Kind</span><span class="s1">]: </span><span class="s3">'Tuple'</span><span class="s1">; 
    </span><span class="s2">static</span><span class="s1">: {</span>
        <span class="s1">[</span><span class="s2">K </span><span class="s0">in </span><span class="s2">keyof T</span><span class="s1">]: </span><span class="s2">T</span><span class="s1">[</span><span class="s2">K</span><span class="s1">] </span><span class="s2">extends TSchema </span><span class="s0">? </span><span class="s2">Static</span><span class="s0">&lt;</span><span class="s2">T</span><span class="s1">[</span><span class="s2">K</span><span class="s1">], </span><span class="s2">this</span><span class="s1">[</span><span class="s3">'params'</span><span class="s1">]</span><span class="s0">&gt; : </span><span class="s2">T</span><span class="s1">[</span><span class="s2">K</span><span class="s1">]; 
    }; 
    </span><span class="s2">type</span><span class="s1">: </span><span class="s3">'array'</span><span class="s1">; 
    </span><span class="s2">items</span><span class="s0">?: </span><span class="s2">T</span><span class="s1">; 
    </span><span class="s2">additionalItems</span><span class="s0">?: </span><span class="s6">false</span><span class="s1">; 
    </span><span class="s2">minItems</span><span class="s1">: </span><span class="s2">number</span><span class="s1">; 
    </span><span class="s2">maxItems</span><span class="s1">: </span><span class="s2">number</span><span class="s1">; 
}</span>
<span class="s2">export interface TUndefined extends TSchema </span><span class="s1">{</span>
    <span class="s1">[</span><span class="s2">Kind</span><span class="s1">]: </span><span class="s3">'Undefined'</span><span class="s1">; 
    </span><span class="s2">static</span><span class="s1">: </span><span class="s6">undefined</span><span class="s1">; 
    </span><span class="s2">type</span><span class="s1">: </span><span class="s3">'null'</span><span class="s1">; 
    </span><span class="s2">typeOf</span><span class="s1">: </span><span class="s3">'Undefined'</span><span class="s1">; 
}</span>
<span class="s2">export type TUnionOfLiteralArray</span><span class="s0">&lt;</span><span class="s2">T extends TLiteral</span><span class="s0">&lt;</span><span class="s2">string</span><span class="s0">&gt;</span><span class="s1">[]</span><span class="s0">&gt; = </span><span class="s1">{</span>
    <span class="s1">[</span><span class="s2">K </span><span class="s0">in </span><span class="s2">keyof T</span><span class="s1">]: </span><span class="s2">Assert</span><span class="s0">&lt;</span><span class="s2">T</span><span class="s1">[</span><span class="s2">K</span><span class="s1">], TLiteral&gt;[</span><span class="s3">'const'</span><span class="s1">]; 
}[</span><span class="s2">number</span><span class="s1">]; 
export type TUnionOfLiteral&lt;T extends TUnion&lt;TLiteral&lt;string&gt;[]&gt;&gt; = TUnionOfLiteralArray&lt;T[</span><span class="s3">'anyOf'</span><span class="s1">]&gt;; 
export type TUnionResult&lt;T extends TSchema[]&gt; = T extends [] ? TNever : </span><span class="s2">T extends </span><span class="s1">[</span><span class="s2">infer S</span><span class="s1">] </span><span class="s0">? </span><span class="s2">S </span><span class="s0">: </span><span class="s2">TUnion</span><span class="s0">&lt;</span><span class="s2">T</span><span class="s0">&gt;</span><span class="s1">; 
</span><span class="s2">export type TUnionTemplateLiteral</span><span class="s0">&lt;</span><span class="s2">T extends TTemplateLiteral</span><span class="s1">, S extends </span><span class="s2">string </span><span class="s0">= </span><span class="s2">Static</span><span class="s0">&lt;</span><span class="s2">T</span><span class="s0">&gt;&gt; = </span><span class="s2">Ensure</span><span class="s0">&lt;</span><span class="s2">TUnionResult</span><span class="s0">&lt;</span><span class="s2">Assert</span><span class="s0">&lt;</span><span class="s7">UnionToTuple</span><span class="s1">&lt;{</span>
    <span class="s1">[</span><span class="s2">K </span><span class="s0">in </span><span class="s2">S</span><span class="s1">]</span><span class="s0">: </span><span class="s2">TLiteral</span><span class="s1">&lt;</span><span class="s2">K</span><span class="s1">&gt;;</span>
<span class="s1">}[</span><span class="s2">S</span><span class="s1">]&gt;, TLiteral[]&gt;&gt;&gt;; 
export interface TUnion&lt;T extends TSchema[] = TSchema[]&gt; extends TSchema { 
    [</span><span class="s2">Kind</span><span class="s1">]: </span><span class="s3">'Union'</span><span class="s1">; 
    </span><span class="s2">static</span><span class="s1">: {</span>
        <span class="s1">[</span><span class="s2">K </span><span class="s0">in </span><span class="s2">keyof T</span><span class="s1">]: </span><span class="s2">T</span><span class="s1">[</span><span class="s2">K</span><span class="s1">] </span><span class="s2">extends TSchema </span><span class="s0">? </span><span class="s2">Static</span><span class="s0">&lt;</span><span class="s2">T</span><span class="s1">[</span><span class="s2">K</span><span class="s1">], </span><span class="s2">this</span><span class="s1">[</span><span class="s3">'params'</span><span class="s1">]</span><span class="s0">&gt; : </span><span class="s2">never</span><span class="s1">; 
    }[</span><span class="s2">number</span><span class="s1">]; 
    </span><span class="s2">anyOf</span><span class="s1">: </span><span class="s2">T</span><span class="s1">; 
}</span>
<span class="s2">export interface Uint8ArrayOptions extends SchemaOptions </span><span class="s1">{</span>
    <span class="s1">maxByteLength?: </span><span class="s2">number</span><span class="s1">; 
    </span><span class="s2">minByteLength</span><span class="s0">?: </span><span class="s2">number</span><span class="s1">; 
} 
export interface TUint8Array extends </span><span class="s2">TSchema</span><span class="s1">, Uint8ArrayOptions { 
    [</span><span class="s2">Kind</span><span class="s1">]: </span><span class="s3">'Uint8Array'</span><span class="s1">; 
    </span><span class="s2">static</span><span class="s1">: </span><span class="s2">Uint8Array</span><span class="s1">; 
    </span><span class="s2">instanceOf</span><span class="s1">: </span><span class="s3">'Uint8Array'</span><span class="s1">; 
    </span><span class="s2">type</span><span class="s1">: </span><span class="s3">'object'</span><span class="s1">; 
}</span>
<span class="s2">export interface TUnknown extends TSchema </span><span class="s1">{</span>
    <span class="s1">[</span><span class="s2">Kind</span><span class="s1">]: </span><span class="s3">'Unknown'</span><span class="s1">; 
    </span><span class="s2">static</span><span class="s1">: </span><span class="s2">unknown</span><span class="s1">; 
}</span>
<span class="s2">export interface UnsafeOptions extends SchemaOptions </span><span class="s1">{</span>
    <span class="s1">[</span><span class="s2">Kind</span><span class="s1">]?: </span><span class="s2">string</span><span class="s1">; 
}</span>
<span class="s2">export interface TUnsafe</span><span class="s0">&lt;</span><span class="s2">T</span><span class="s0">&gt; </span><span class="s2">extends TSchema </span><span class="s1">{</span>
    <span class="s1">[</span><span class="s2">Kind</span><span class="s1">]: </span><span class="s2">string</span><span class="s1">; 
    </span><span class="s2">static</span><span class="s1">: </span><span class="s2">T</span><span class="s1">; 
}</span>
<span class="s2">export interface TVoid extends TSchema </span><span class="s1">{</span>
    <span class="s1">[</span><span class="s2">Kind</span><span class="s1">]: </span><span class="s3">'Void'</span><span class="s1">; 
    </span><span class="s2">static</span><span class="s1">: </span><span class="s0">void</span><span class="s1">; 
    </span><span class="s2">type</span><span class="s1">: </span><span class="s3">'null'</span><span class="s1">; 
    </span><span class="s2">typeOf</span><span class="s1">: </span><span class="s3">'Void'</span><span class="s1">; 
}</span>
<span class="s5">/** Creates a TypeScript static type from a TypeBox type */</span>
<span class="s2">export type Static</span><span class="s0">&lt;</span><span class="s2">T extends TSchema</span><span class="s1">, </span><span class="s2">P extends unknown</span><span class="s1">[] </span><span class="s0">= </span><span class="s1">[]</span><span class="s0">&gt; = </span><span class="s1">(</span><span class="s2">T </span><span class="s0">&amp; </span><span class="s1">{</span>
    <span class="s1">params: </span><span class="s2">P</span><span class="s1">; 
})[</span><span class="s3">'static'</span><span class="s1">]; 
</span><span class="s2">export type TypeRegistryValidationFunction</span><span class="s0">&lt;</span><span class="s2">TSchema</span><span class="s0">&gt; = </span><span class="s1">(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">TSchema</span><span class="s1">, </span><span class="s2">value</span><span class="s0">: </span><span class="s2">unknown</span><span class="s1">) </span><span class="s0">=&gt; </span><span class="s2">boolean</span><span class="s1">; 
</span><span class="s5">/** A registry for user defined types */</span>
<span class="s2">export declare namespace TypeRegistry </span><span class="s1">{</span>
    <span class="s5">/** Returns the entries in this registry */</span>
    <span class="s1">function Entries()</span><span class="s0">: </span><span class="s2">Map</span><span class="s1">&lt;</span><span class="s2">string</span><span class="s1">, </span><span class="s2">TypeRegistryValidationFunction</span><span class="s1">&lt;</span><span class="s2">any</span><span class="s1">&gt;&gt;; 
    </span><span class="s5">/** Clears all user defined types */</span>
    <span class="s1">function Clear()</span><span class="s0">: </span><span class="s2">void</span><span class="s1">; 
    </span><span class="s5">/** Returns true if this registry contains this kind */</span>
    <span class="s1">function Has(</span><span class="s2">kind</span><span class="s0">: </span><span class="s2">string</span><span class="s1">)</span><span class="s0">: </span><span class="s2">boolean</span><span class="s1">; 
    </span><span class="s5">/** Sets a validation function for a user defined type */</span>
    <span class="s1">function Set&lt;</span><span class="s2">TSchema </span><span class="s0">= </span><span class="s2">unknown</span><span class="s1">&gt;(</span><span class="s2">kind</span><span class="s0">: </span><span class="s2">string</span><span class="s1">, </span><span class="s2">func</span><span class="s0">: </span><span class="s2">TypeRegistryValidationFunction</span><span class="s1">&lt;</span><span class="s2">TSchema</span><span class="s1">&gt;)</span><span class="s0">: </span><span class="s2">void</span><span class="s1">; 
    </span><span class="s5">/** Gets a custom validation function for a user defined type */</span>
    <span class="s1">function Get(</span><span class="s2">kind</span><span class="s0">: </span><span class="s2">string</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TypeRegistryValidationFunction</span><span class="s1">&lt;</span><span class="s2">any</span><span class="s1">&gt; </span><span class="s0">| </span><span class="s2">undefined</span><span class="s1">; 
}</span>
<span class="s2">export type </span><span class="s7">FormatRegistryValidationFunction </span><span class="s0">= </span><span class="s1">(</span><span class="s2">value</span><span class="s0">: </span><span class="s2">string</span><span class="s1">) </span><span class="s0">=&gt; </span><span class="s2">boolean</span><span class="s1">; 
</span><span class="s5">/** A registry for user defined string formats */</span>
<span class="s2">export declare namespace FormatRegistry </span><span class="s1">{</span>
    <span class="s5">/** Returns the entries in this registry */</span>
    <span class="s1">function Entries()</span><span class="s0">: </span><span class="s2">Map</span><span class="s1">&lt;</span><span class="s2">string</span><span class="s1">, </span><span class="s2">FormatRegistryValidationFunction</span><span class="s1">&gt;; 
    </span><span class="s5">/** Clears all user defined string formats */</span>
    <span class="s1">function Clear()</span><span class="s0">: </span><span class="s2">void</span><span class="s1">; 
    </span><span class="s5">/** Returns true if the user defined string format exists */</span>
    <span class="s1">function Has(</span><span class="s2">format</span><span class="s0">: </span><span class="s2">string</span><span class="s1">)</span><span class="s0">: </span><span class="s2">boolean</span><span class="s1">; 
    </span><span class="s5">/** Sets a validation function for a user defined string format */</span>
    <span class="s1">function Set(</span><span class="s2">format</span><span class="s0">: </span><span class="s2">string</span><span class="s1">, </span><span class="s2">func</span><span class="s0">: </span><span class="s2">FormatRegistryValidationFunction</span><span class="s1">)</span><span class="s0">: </span><span class="s2">void</span><span class="s1">; 
    </span><span class="s5">/** Gets a validation function for a user defined string format */</span>
    <span class="s1">function Get(</span><span class="s2">format</span><span class="s0">: </span><span class="s2">string</span><span class="s1">)</span><span class="s0">: </span><span class="s2">FormatRegistryValidationFunction </span><span class="s0">| </span><span class="s2">undefined</span><span class="s1">; 
}</span>
<span class="s2">export declare </span><span class="s0">class </span><span class="s2">TypeGuardUnknownTypeError </span><span class="s0">extends </span><span class="s2">Error </span><span class="s1">{</span>
    <span class="s0">readonly </span><span class="s1">schema</span><span class="s0">: </span><span class="s2">unknown</span><span class="s1">;</span>
    <span class="s0">constructor</span><span class="s1">(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">unknown</span><span class="s1">);</span>
<span class="s1">}</span>
<span class="s5">/** Provides functions to test if JavaScript values are TypeBox types */</span>
<span class="s2">export declare namespace TypeGuard </span><span class="s1">{</span>
    <span class="s5">/** Returns true if the given schema is TAny */</span>
    <span class="s1">function TAny(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">unknown</span><span class="s1">)</span><span class="s0">: </span><span class="s2">schema </span><span class="s0">is </span><span class="s2">TAny</span><span class="s1">; 
    </span><span class="s5">/** Returns true if the given schema is TArray */</span>
    <span class="s1">function TArray(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">unknown</span><span class="s1">)</span><span class="s0">: </span><span class="s2">schema </span><span class="s0">is </span><span class="s2">TArray</span><span class="s1">; 
    </span><span class="s5">/** Returns true if the given schema is TBigInt */</span>
    <span class="s1">function TBigInt(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">unknown</span><span class="s1">)</span><span class="s0">: </span><span class="s2">schema </span><span class="s0">is </span><span class="s2">TBigInt</span><span class="s1">; 
    </span><span class="s5">/** Returns true if the given schema is TBoolean */</span>
    <span class="s1">function TBoolean(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">unknown</span><span class="s1">)</span><span class="s0">: </span><span class="s2">schema </span><span class="s0">is </span><span class="s2">TBoolean</span><span class="s1">; 
    </span><span class="s5">/** Returns true if the given schema is TConstructor */</span>
    <span class="s1">function TConstructor(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">unknown</span><span class="s1">)</span><span class="s0">: </span><span class="s2">schema </span><span class="s0">is </span><span class="s2">TConstructor</span><span class="s1">; 
    </span><span class="s5">/** Returns true if the given schema is TDate */</span>
    <span class="s1">function TDate(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">unknown</span><span class="s1">)</span><span class="s0">: </span><span class="s2">schema </span><span class="s0">is </span><span class="s2">TDate</span><span class="s1">; 
    </span><span class="s5">/** Returns true if the given schema is TFunction */</span>
    <span class="s1">function TFunction(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">unknown</span><span class="s1">)</span><span class="s0">: </span><span class="s2">schema </span><span class="s0">is </span><span class="s2">TFunction</span><span class="s1">; 
    </span><span class="s5">/** Returns true if the given schema is TInteger */</span>
    <span class="s1">function TInteger(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">unknown</span><span class="s1">)</span><span class="s0">: </span><span class="s2">schema </span><span class="s0">is </span><span class="s2">TInteger</span><span class="s1">; 
    </span><span class="s5">/** Returns true if the given schema is TIntersect */</span>
    <span class="s1">function TIntersect(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">unknown</span><span class="s1">)</span><span class="s0">: </span><span class="s2">schema </span><span class="s0">is </span><span class="s2">TIntersect</span><span class="s1">; 
    </span><span class="s5">/** Returns true if the given schema is TKind */</span>
    <span class="s1">function TKind(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">unknown</span><span class="s1">)</span><span class="s0">: </span><span class="s2">schema </span><span class="s0">is </span><span class="s2">Record</span><span class="s1">&lt;</span><span class="s0">typeof </span><span class="s2">Kind </span><span class="s0">| </span><span class="s2">string</span><span class="s1">, </span><span class="s2">unknown</span><span class="s1">&gt;; 
    </span><span class="s5">/** Returns true if the given schema is TLiteral */</span>
    <span class="s1">function TLiteral(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">unknown</span><span class="s1">)</span><span class="s0">: </span><span class="s2">schema </span><span class="s0">is </span><span class="s2">TLiteral</span><span class="s1">; 
    </span><span class="s5">/** Returns true if the given schema is TNever */</span>
    <span class="s1">function TNever(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">unknown</span><span class="s1">)</span><span class="s0">: </span><span class="s2">schema </span><span class="s0">is </span><span class="s2">TNever</span><span class="s1">; 
    </span><span class="s5">/** Returns true if the given schema is TNot */</span>
    <span class="s1">function TNot(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">unknown</span><span class="s1">)</span><span class="s0">: </span><span class="s2">schema </span><span class="s0">is </span><span class="s2">TNot</span><span class="s1">; 
    </span><span class="s5">/** Returns true if the given schema is TNull */</span>
    <span class="s1">function TNull(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">unknown</span><span class="s1">)</span><span class="s0">: </span><span class="s2">schema </span><span class="s0">is </span><span class="s2">TNull</span><span class="s1">; 
    </span><span class="s5">/** Returns true if the given schema is TNumber */</span>
    <span class="s1">function TNumber(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">unknown</span><span class="s1">)</span><span class="s0">: </span><span class="s2">schema </span><span class="s0">is </span><span class="s2">TNumber</span><span class="s1">; 
    </span><span class="s5">/** Returns true if the given schema is TObject */</span>
    <span class="s1">function TObject(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">unknown</span><span class="s1">)</span><span class="s0">: </span><span class="s2">schema </span><span class="s0">is </span><span class="s2">TObject</span><span class="s1">; 
    </span><span class="s5">/** Returns true if the given schema is TPromise */</span>
    <span class="s1">function TPromise(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">unknown</span><span class="s1">)</span><span class="s0">: </span><span class="s2">schema </span><span class="s0">is </span><span class="s2">TPromise</span><span class="s1">; 
    </span><span class="s5">/** Returns true if the given schema is TRecord */</span>
    <span class="s1">function TRecord(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">unknown</span><span class="s1">)</span><span class="s0">: </span><span class="s2">schema </span><span class="s0">is </span><span class="s2">TRecord</span><span class="s1">; 
    </span><span class="s5">/** Returns true if the given schema is TRef */</span>
    <span class="s1">function TRef(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">unknown</span><span class="s1">)</span><span class="s0">: </span><span class="s2">schema </span><span class="s0">is </span><span class="s2">TRef</span><span class="s1">; 
    </span><span class="s5">/** Returns true if the given schema is TString */</span>
    <span class="s1">function TString(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">unknown</span><span class="s1">)</span><span class="s0">: </span><span class="s2">schema </span><span class="s0">is </span><span class="s2">TString</span><span class="s1">; 
    </span><span class="s5">/** Returns true if the given schema is TSymbol */</span>
    <span class="s1">function TSymbol(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">unknown</span><span class="s1">)</span><span class="s0">: </span><span class="s2">schema </span><span class="s0">is </span><span class="s2">TSymbol</span><span class="s1">; 
    </span><span class="s5">/** Returns true if the given schema is TTemplateLiteral */</span>
    <span class="s1">function TTemplateLiteral(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">unknown</span><span class="s1">)</span><span class="s0">: </span><span class="s2">schema </span><span class="s0">is </span><span class="s2">TTemplateLiteral</span><span class="s1">; 
    </span><span class="s5">/** Returns true if the given schema is TThis */</span>
    <span class="s1">function TThis(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">unknown</span><span class="s1">)</span><span class="s0">: </span><span class="s2">schema </span><span class="s0">is </span><span class="s2">TThis</span><span class="s1">; 
    </span><span class="s5">/** Returns true if the given schema is TTuple */</span>
    <span class="s1">function TTuple(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">unknown</span><span class="s1">)</span><span class="s0">: </span><span class="s2">schema </span><span class="s0">is </span><span class="s2">TTuple</span><span class="s1">; 
    </span><span class="s5">/** Returns true if the given schema is TUndefined */</span>
    <span class="s1">function TUndefined(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">unknown</span><span class="s1">)</span><span class="s0">: </span><span class="s2">schema </span><span class="s0">is </span><span class="s2">TUndefined</span><span class="s1">; 
    </span><span class="s5">/** Returns true if the given schema is TUnion */</span>
    <span class="s1">function TUnion(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">unknown</span><span class="s1">)</span><span class="s0">: </span><span class="s2">schema </span><span class="s0">is </span><span class="s2">TUnion</span><span class="s1">; 
    </span><span class="s5">/** Returns true if the given schema is TUnion&lt;Literal&lt;string&gt;[]&gt; */</span>
    <span class="s1">function TUnionLiteral(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">unknown</span><span class="s1">)</span><span class="s0">: </span><span class="s2">schema </span><span class="s0">is </span><span class="s2">TUnion</span><span class="s1">&lt;</span><span class="s2">TLiteral</span><span class="s1">&lt;</span><span class="s2">string</span><span class="s1">&gt;[]&gt;; 
    </span><span class="s5">/** Returns true if the given schema is TUint8Array */</span>
    <span class="s1">function TUint8Array(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">unknown</span><span class="s1">)</span><span class="s0">: </span><span class="s2">schema </span><span class="s0">is </span><span class="s2">TUint8Array</span><span class="s1">; 
    </span><span class="s5">/** Returns true if the given schema is TUnknown */</span>
    <span class="s1">function TUnknown(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">unknown</span><span class="s1">)</span><span class="s0">: </span><span class="s2">schema </span><span class="s0">is </span><span class="s2">TUnknown</span><span class="s1">; 
    </span><span class="s5">/** Returns true if the given schema is a raw TUnsafe */</span>
    <span class="s1">function TUnsafe(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">unknown</span><span class="s1">)</span><span class="s0">: </span><span class="s2">schema </span><span class="s0">is </span><span class="s2">TUnsafe</span><span class="s1">&lt;</span><span class="s2">unknown</span><span class="s1">&gt;; 
    </span><span class="s5">/** Returns true if the given schema is TVoid */</span>
    <span class="s1">function TVoid(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">unknown</span><span class="s1">)</span><span class="s0">: </span><span class="s2">schema </span><span class="s0">is </span><span class="s2">TVoid</span><span class="s1">; 
    </span><span class="s5">/** Returns true if this schema has the ReadonlyOptional modifier */</span>
    <span class="s1">function TReadonlyOptional&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">&gt;(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">T</span><span class="s1">)</span><span class="s0">: </span><span class="s2">schema </span><span class="s0">is </span><span class="s2">TReadonlyOptional</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt;; 
    </span><span class="s5">/** Returns true if this schema has the Readonly modifier */</span>
    <span class="s1">function TReadonly&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">&gt;(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">T</span><span class="s1">)</span><span class="s0">: </span><span class="s2">schema </span><span class="s0">is </span><span class="s2">TReadonly</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt;; 
    </span><span class="s5">/** Returns true if this schema has the Optional modifier */</span>
    <span class="s1">function TOptional&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">&gt;(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">T</span><span class="s1">)</span><span class="s0">: </span><span class="s2">schema </span><span class="s0">is </span><span class="s2">TOptional</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt;; 
    </span><span class="s5">/** Returns true if the given schema is TSchema */</span>
    <span class="s1">function TSchema(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">unknown</span><span class="s1">)</span><span class="s0">: </span><span class="s2">schema </span><span class="s0">is </span><span class="s2">TSchema</span><span class="s1">; 
}</span>
<span class="s5">/** Fast undefined check used for properties of type undefined */</span>
<span class="s2">export declare namespace ExtendsUndefined </span><span class="s1">{</span>
    <span class="s1">function Check(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">TSchema</span><span class="s1">)</span><span class="s0">: </span><span class="s2">boolean</span><span class="s1">; 
}</span>
<span class="s2">export declare enum TypeExtendsResult </span><span class="s1">{</span>
    <span class="s2">Union </span><span class="s0">= </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s2">True </span><span class="s0">= </span><span class="s4">1</span><span class="s1">,</span>
    <span class="s2">False </span><span class="s0">= </span><span class="s4">2</span>
<span class="s1">}</span>
<span class="s2">export declare namespace TypeExtends </span><span class="s1">{</span>
    <span class="s1">function Extends(</span><span class="s2">left</span><span class="s0">: </span><span class="s2">TSchema</span><span class="s1">, </span><span class="s2">right</span><span class="s0">: </span><span class="s2">TSchema</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TypeExtendsResult</span><span class="s1">; 
}</span>
<span class="s5">/** Specialized Clone for Types */</span>
<span class="s2">export declare namespace TypeClone </span><span class="s1">{</span>
    <span class="s5">/** Clones a type. */</span>
    <span class="s1">function Clone&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">&gt;(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">T</span><span class="s1">, </span><span class="s2">options</span><span class="s0">: </span><span class="s2">SchemaOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">T</span><span class="s1">; 
}</span>
<span class="s2">export declare namespace ObjectMap </span><span class="s1">{</span>
    <span class="s1">function Map&lt;</span><span class="s2">T </span><span class="s0">= </span><span class="s2">TSchema</span><span class="s1">&gt;(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">TSchema</span><span class="s1">, </span><span class="s7">callback</span><span class="s0">: </span><span class="s1">(</span><span class="s2">object</span><span class="s0">: </span><span class="s2">TObject</span><span class="s1">) </span><span class="s0">=&gt; </span><span class="s2">TObject</span><span class="s1">, </span><span class="s2">options</span><span class="s0">: </span><span class="s2">SchemaOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">T</span><span class="s1">; 
}</span>
<span class="s2">export declare namespace KeyResolver </span><span class="s1">{</span>
    <span class="s1">function Resolve&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">&gt;(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">T</span><span class="s1">)</span><span class="s0">: </span><span class="s2">string</span><span class="s1">[]; 
}</span>
<span class="s2">export declare namespace TemplateLiteralPattern </span><span class="s1">{</span>
    <span class="s1">function Create(</span><span class="s2">kinds</span><span class="s0">: </span><span class="s2">TTemplateLiteralKind</span><span class="s1">[])</span><span class="s0">: </span><span class="s2">string</span><span class="s1">; 
}</span>
<span class="s2">export declare namespace TemplateLiteralResolver </span><span class="s1">{</span>
    <span class="s1">function Resolve(</span><span class="s2">template</span><span class="s0">: </span><span class="s2">TTemplateLiteral</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TString </span><span class="s0">| </span><span class="s2">TUnion </span><span class="s0">| </span><span class="s2">TLiteral</span><span class="s1">; 
}</span>
<span class="s2">export declare </span><span class="s0">class </span><span class="s2">TemplateLiteralParserError </span><span class="s0">extends </span><span class="s2">Error </span><span class="s1">{</span>
    <span class="s0">constructor</span><span class="s1">(</span><span class="s2">message</span><span class="s0">: </span><span class="s2">string</span><span class="s1">);</span>
<span class="s1">}</span>
<span class="s2">export declare namespace TemplateLiteralParser </span><span class="s1">{</span>
    <span class="s1">type </span><span class="s2">Expression </span><span class="s0">= </span><span class="s2">And </span><span class="s0">| </span><span class="s2">Or </span><span class="s0">| </span><span class="s2">Const</span><span class="s1">;</span>
    <span class="s1">type </span><span class="s2">Const </span><span class="s0">= </span><span class="s1">{</span>
        <span class="s1">type: </span><span class="s3">'const'</span><span class="s1">; 
        </span><span class="s2">const</span><span class="s1">: </span><span class="s2">string</span><span class="s1">; 
    };</span>
    <span class="s1">type </span><span class="s2">And </span><span class="s0">= </span><span class="s1">{</span>
        <span class="s1">type: </span><span class="s3">'and'</span><span class="s1">; 
        </span><span class="s2">expr</span><span class="s1">: </span><span class="s2">Expression</span><span class="s1">[]; 
    };</span>
    <span class="s1">type </span><span class="s2">Or </span><span class="s0">= </span><span class="s1">{</span>
        <span class="s1">type: </span><span class="s3">'or'</span><span class="s1">; 
        </span><span class="s2">expr</span><span class="s1">: </span><span class="s2">Expression</span><span class="s1">[]; 
    };</span>
    <span class="s5">/** Parses a pattern and returns an expression tree */</span>
    <span class="s1">function Parse(</span><span class="s2">pattern</span><span class="s0">: </span><span class="s2">string</span><span class="s1">)</span><span class="s0">: </span><span class="s2">Expression</span><span class="s1">; 
    </span><span class="s5">/** Parses a pattern and strips forward and trailing ^ and $ */</span>
    <span class="s1">function ParseExact(</span><span class="s2">pattern</span><span class="s0">: </span><span class="s2">string</span><span class="s1">)</span><span class="s0">: </span><span class="s2">Expression</span><span class="s1">; 
}</span>
<span class="s2">export declare namespace TemplateLiteralFinite </span><span class="s1">{</span>
    <span class="s1">function Check(</span><span class="s2">expression</span><span class="s0">: </span><span class="s2">TemplateLiteralParser</span><span class="s1">.</span><span class="s2">Expression</span><span class="s1">)</span><span class="s0">: </span><span class="s2">boolean</span><span class="s1">; 
}</span>
<span class="s2">export declare namespace TemplateLiteralGenerator </span><span class="s1">{</span>
    <span class="s1">function Generate(</span><span class="s2">expression</span><span class="s0">: </span><span class="s2">TemplateLiteralParser</span><span class="s1">.</span><span class="s2">Expression</span><span class="s1">)</span><span class="s0">: </span><span class="s2">IterableIterator</span><span class="s1">&lt;</span><span class="s2">string</span><span class="s1">&gt;; 
}</span>
<span class="s2">export declare </span><span class="s0">class </span><span class="s2">TypeBuilder </span><span class="s1">{</span>
    <span class="s5">/** `[Utility]` Creates a schema without `static` and `params` types */</span>
    <span class="s0">protected </span><span class="s1">Create&lt;</span><span class="s2">T</span><span class="s1">&gt;(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">Omit</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">, </span><span class="s3">'static' </span><span class="s0">| </span><span class="s3">'params'</span><span class="s1">&gt;)</span><span class="s0">: </span><span class="s2">T</span><span class="s1">;</span>
    <span class="s5">/** `[Standard]` Omits compositing symbols from this schema */</span>
    <span class="s1">Strict&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">&gt;(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">T</span><span class="s1">)</span><span class="s0">: </span><span class="s2">T</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare </span><span class="s0">class </span><span class="s2">StandardTypeBuilder </span><span class="s0">extends </span><span class="s2">TypeBuilder </span><span class="s1">{</span>
    <span class="s5">/** `[Modifier]` Creates a Optional property */</span>
    <span class="s1">Optional&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">&gt;(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">T</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TOptional</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt;;</span>
    <span class="s5">/** `[Modifier]` Creates a ReadonlyOptional property */</span>
    <span class="s1">ReadonlyOptional&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">&gt;(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">T</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TReadonlyOptional</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt;;</span>
    <span class="s5">/** `[Modifier]` Creates a Readonly object or property */</span>
    <span class="s1">Readonly&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">&gt;(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">T</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TReadonly</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt;;</span>
    <span class="s5">/** `[Standard]` Creates an Any type */</span>
    <span class="s1">Any(</span><span class="s2">options</span><span class="s0">?: </span><span class="s2">SchemaOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TAny</span><span class="s1">;</span>
    <span class="s5">/** `[Standard]` Creates an Array type */</span>
    <span class="s1">Array&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">&gt;(</span><span class="s2">items</span><span class="s0">: </span><span class="s2">T</span><span class="s1">, </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">ArrayOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TArray</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt;;</span>
    <span class="s5">/** `[Standard]` Creates a Boolean type */</span>
    <span class="s1">Boolean(</span><span class="s2">options</span><span class="s0">?: </span><span class="s2">SchemaOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TBoolean</span><span class="s1">;</span>
    <span class="s5">/** `[Standard]` Creates a Composite object type. */</span>
    <span class="s1">Composite&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TObject</span><span class="s1">[]&gt;(</span><span class="s2">objects</span><span class="s0">: </span><span class="s1">[</span><span class="s0">...</span><span class="s2">T</span><span class="s1">], </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">ObjectOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TComposite</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt;;</span>
    <span class="s5">/** `[Standard]` Creates a Enum type */</span>
    <span class="s1">Enum&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">Record</span><span class="s1">&lt;</span><span class="s2">string</span><span class="s1">, </span><span class="s2">string </span><span class="s0">| </span><span class="s2">number</span><span class="s1">&gt;&gt;(</span><span class="s2">item</span><span class="s0">: </span><span class="s2">T</span><span class="s1">, </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">SchemaOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TEnum</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt;;</span>
    <span class="s5">/** `[Standard]` A conditional type expression that will return the true type if the left type extends the right */</span>
    <span class="s1">Extends&lt;</span><span class="s2">L </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">, </span><span class="s2">R </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">, </span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">, </span><span class="s2">U </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">&gt;(</span><span class="s2">left</span><span class="s0">: </span><span class="s2">L</span><span class="s1">, </span><span class="s2">right</span><span class="s0">: </span><span class="s2">R</span><span class="s1">, </span><span class="s2">trueType</span><span class="s0">: </span><span class="s2">T</span><span class="s1">, </span><span class="s2">falseType</span><span class="s0">: </span><span class="s2">U</span><span class="s1">, </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">SchemaOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TExtends</span><span class="s1">&lt;</span><span class="s2">L</span><span class="s1">, </span><span class="s2">R</span><span class="s1">, </span><span class="s2">T</span><span class="s1">, </span><span class="s2">U</span><span class="s1">&gt;;</span>
    <span class="s5">/** `[Standard]` Excludes from the left type any type that is not assignable to the right */</span>
    <span class="s1">Exclude&lt;</span><span class="s2">L </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">, </span><span class="s2">R </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">&gt;(</span><span class="s2">left</span><span class="s0">: </span><span class="s2">L</span><span class="s1">, </span><span class="s2">right</span><span class="s0">: </span><span class="s2">R</span><span class="s1">, </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">SchemaOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TExclude</span><span class="s1">&lt;</span><span class="s2">L</span><span class="s1">, </span><span class="s2">R</span><span class="s1">&gt;;</span>
    <span class="s5">/** `[Standard]` Extracts from the left type any type that is assignable to the right */</span>
    <span class="s1">Extract&lt;</span><span class="s2">L </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">, </span><span class="s2">R </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">&gt;(</span><span class="s2">left</span><span class="s0">: </span><span class="s2">L</span><span class="s1">, </span><span class="s2">right</span><span class="s0">: </span><span class="s2">R</span><span class="s1">, </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">SchemaOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TExtract</span><span class="s1">&lt;</span><span class="s2">L</span><span class="s1">, </span><span class="s2">R</span><span class="s1">&gt;;</span>
    <span class="s5">/** `[Standard]` Creates an Integer type */</span>
    <span class="s1">Integer(</span><span class="s2">options</span><span class="s0">?: </span><span class="s2">NumericOptions</span><span class="s1">&lt;</span><span class="s2">number</span><span class="s1">&gt;)</span><span class="s0">: </span><span class="s2">TInteger</span><span class="s1">;</span>
    <span class="s5">/** `[Standard]` Creates a Intersect type */</span>
    <span class="s1">Intersect(</span><span class="s2">allOf</span><span class="s0">: </span><span class="s1">[], </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">SchemaOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TNever</span><span class="s1">;</span>
    <span class="s5">/** `[Standard]` Creates a Intersect type */</span>
    <span class="s1">Intersect&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s1">[</span><span class="s2">TSchema</span><span class="s1">]&gt;(</span><span class="s2">allOf</span><span class="s0">: </span><span class="s1">[</span><span class="s0">...</span><span class="s2">T</span><span class="s1">], </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">SchemaOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">T</span><span class="s1">[</span><span class="s4">0</span><span class="s1">];</span>
    <span class="s1">Intersect&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">[]&gt;(</span><span class="s2">allOf</span><span class="s0">: </span><span class="s1">[</span><span class="s0">...</span><span class="s2">T</span><span class="s1">], </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">IntersectOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TIntersect</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt;;</span>
    <span class="s5">/** `[Standard]` Creates a KeyOf type */</span>
    <span class="s1">KeyOf&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">&gt;(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">T</span><span class="s1">, </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">SchemaOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TKeyOf</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt;;</span>
    <span class="s5">/** `[Standard]` Creates a Literal type */</span>
    <span class="s1">Literal&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TLiteralValue</span><span class="s1">&gt;(</span><span class="s2">value</span><span class="s0">: </span><span class="s2">T</span><span class="s1">, </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">SchemaOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TLiteral</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt;;</span>
    <span class="s5">/** `[Standard]` Creates a Never type */</span>
    <span class="s1">Never(</span><span class="s2">options</span><span class="s0">?: </span><span class="s2">SchemaOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TNever</span><span class="s1">;</span>
    <span class="s5">/** `[Standard]` Creates a Not type. The first argument is the disallowed type, the second is the allowed. */</span>
    <span class="s1">Not&lt;</span><span class="s2">N </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">, </span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">&gt;(</span><span class="s2">not</span><span class="s0">: </span><span class="s2">N</span><span class="s1">, </span><span class="s2">schema</span><span class="s0">: </span><span class="s2">T</span><span class="s1">, </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">SchemaOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TNot</span><span class="s1">&lt;</span><span class="s2">N</span><span class="s1">, </span><span class="s2">T</span><span class="s1">&gt;;</span>
    <span class="s5">/** `[Standard]` Creates a Null type */</span>
    <span class="s1">Null(</span><span class="s2">options</span><span class="s0">?: </span><span class="s2">SchemaOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TNull</span><span class="s1">;</span>
    <span class="s5">/** `[Standard]` Creates a Number type */</span>
    <span class="s1">Number(</span><span class="s2">options</span><span class="s0">?: </span><span class="s2">NumericOptions</span><span class="s1">&lt;</span><span class="s2">number</span><span class="s1">&gt;)</span><span class="s0">: </span><span class="s2">TNumber</span><span class="s1">;</span>
    <span class="s5">/** `[Standard]` Creates an Object type */</span>
    <span class="s1">Object&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TProperties</span><span class="s1">&gt;(</span><span class="s2">properties</span><span class="s0">: </span><span class="s2">T</span><span class="s1">, </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">ObjectOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TObject</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt;;</span>
    <span class="s5">/** `[Standard]` Creates a mapped type whose keys are omitted from the given type */</span>
    <span class="s1">Omit&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">, </span><span class="s2">K </span><span class="s0">extends </span><span class="s1">(</span><span class="s0">keyof </span><span class="s2">Static</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt;)[]&gt;(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">T</span><span class="s1">, </span><span class="s2">keys</span><span class="s0">: readonly </span><span class="s1">[</span><span class="s0">...</span><span class="s2">K</span><span class="s1">], </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">SchemaOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TOmit</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">, </span><span class="s2">K</span><span class="s1">[</span><span class="s2">number</span><span class="s1">]&gt;;</span>
    <span class="s5">/** `[Standard]` Creates a mapped type whose keys are omitted from the given type */</span>
    <span class="s1">Omit&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">, </span><span class="s2">K </span><span class="s0">extends </span><span class="s2">TUnion</span><span class="s1">&lt;</span><span class="s2">TLiteral</span><span class="s1">&lt;</span><span class="s2">string</span><span class="s1">&gt;[]&gt;&gt;(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">T</span><span class="s1">, </span><span class="s2">keys</span><span class="s0">: </span><span class="s2">K</span><span class="s1">, </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">SchemaOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TOmit</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">, </span><span class="s2">TUnionOfLiteral</span><span class="s1">&lt;</span><span class="s2">K</span><span class="s1">&gt;&gt;;</span>
    <span class="s5">/** `[Standard]` Creates a mapped type whose keys are omitted from the given type */</span>
    <span class="s1">Omit&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">, </span><span class="s2">K </span><span class="s0">extends </span><span class="s2">TLiteral</span><span class="s1">&lt;</span><span class="s2">string</span><span class="s1">&gt;&gt;(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">T</span><span class="s1">, </span><span class="s2">key</span><span class="s0">: </span><span class="s2">K</span><span class="s1">, </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">SchemaOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TOmit</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">, </span><span class="s2">K</span><span class="s1">[</span><span class="s3">'const'</span><span class="s1">]&gt;;</span>
    <span class="s5">/** `[Standard]` Creates a mapped type whose keys are omitted from the given type */</span>
    <span class="s1">Omit&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">, </span><span class="s2">K </span><span class="s0">extends </span><span class="s2">TNever</span><span class="s1">&gt;(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">T</span><span class="s1">, </span><span class="s2">key</span><span class="s0">: </span><span class="s2">K</span><span class="s1">, </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">SchemaOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TOmit</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">, </span><span class="s2">never</span><span class="s1">&gt;;</span>
    <span class="s5">/** `[Standard]` Creates a mapped type where all properties are Optional */</span>
    <span class="s1">Partial&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">&gt;(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">T</span><span class="s1">, </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">ObjectOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TPartial</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt;;</span>
    <span class="s5">/** `[Standard]` Creates a mapped type whose keys are picked from the given type */</span>
    <span class="s1">Pick&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">, </span><span class="s2">K </span><span class="s0">extends </span><span class="s1">(</span><span class="s0">keyof </span><span class="s2">Static</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt;)[]&gt;(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">T</span><span class="s1">, </span><span class="s2">keys</span><span class="s0">: readonly </span><span class="s1">[</span><span class="s0">...</span><span class="s2">K</span><span class="s1">], </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">SchemaOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TPick</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">, </span><span class="s2">K</span><span class="s1">[</span><span class="s2">number</span><span class="s1">]&gt;;</span>
    <span class="s5">/** `[Standard]` Creates a mapped type whose keys are picked from the given type */</span>
    <span class="s1">Pick&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">, </span><span class="s2">K </span><span class="s0">extends </span><span class="s2">TUnion</span><span class="s1">&lt;</span><span class="s2">TLiteral</span><span class="s1">&lt;</span><span class="s2">string</span><span class="s1">&gt;[]&gt;&gt;(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">T</span><span class="s1">, </span><span class="s2">keys</span><span class="s0">: </span><span class="s2">K</span><span class="s1">, </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">SchemaOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TPick</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">, </span><span class="s2">TUnionOfLiteral</span><span class="s1">&lt;</span><span class="s2">K</span><span class="s1">&gt;&gt;;</span>
    <span class="s5">/** `[Standard]` Creates a mapped type whose keys are picked from the given type */</span>
    <span class="s1">Pick&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">, </span><span class="s2">K </span><span class="s0">extends </span><span class="s2">TLiteral</span><span class="s1">&lt;</span><span class="s2">string</span><span class="s1">&gt;&gt;(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">T</span><span class="s1">, </span><span class="s2">key</span><span class="s0">: </span><span class="s2">K</span><span class="s1">, </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">SchemaOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TPick</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">, </span><span class="s2">K</span><span class="s1">[</span><span class="s3">'const'</span><span class="s1">]&gt;;</span>
    <span class="s5">/** `[Standard]` Creates a mapped type whose keys are picked from the given type */</span>
    <span class="s1">Pick&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">, </span><span class="s2">K </span><span class="s0">extends </span><span class="s2">TNever</span><span class="s1">&gt;(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">T</span><span class="s1">, </span><span class="s2">key</span><span class="s0">: </span><span class="s2">K</span><span class="s1">, </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">SchemaOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TPick</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">, </span><span class="s2">never</span><span class="s1">&gt;;</span>
    <span class="s5">/** `[Standard]` Creates a Record type */</span>
    <span class="s1">Record&lt;</span><span class="s2">K </span><span class="s0">extends </span><span class="s2">TUnion</span><span class="s1">&lt;</span><span class="s2">TLiteral</span><span class="s1">&lt;</span><span class="s2">string </span><span class="s0">| </span><span class="s2">number</span><span class="s1">&gt;[]&gt;, </span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">&gt;(</span><span class="s2">key</span><span class="s0">: </span><span class="s2">K</span><span class="s1">, </span><span class="s2">schema</span><span class="s0">: </span><span class="s2">T</span><span class="s1">, </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">ObjectOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">RecordUnionLiteralType</span><span class="s1">&lt;</span><span class="s2">K</span><span class="s1">, </span><span class="s2">T</span><span class="s1">&gt;;</span>
    <span class="s5">/** `[Standard]` Creates a Record type */</span>
    <span class="s1">Record&lt;</span><span class="s2">K </span><span class="s0">extends </span><span class="s2">TLiteral</span><span class="s1">&lt;</span><span class="s2">string </span><span class="s0">| </span><span class="s2">number</span><span class="s1">&gt;, </span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">&gt;(</span><span class="s2">key</span><span class="s0">: </span><span class="s2">K</span><span class="s1">, </span><span class="s2">schema</span><span class="s0">: </span><span class="s2">T</span><span class="s1">, </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">ObjectOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">RecordLiteralType</span><span class="s1">&lt;</span><span class="s2">K</span><span class="s1">, </span><span class="s2">T</span><span class="s1">&gt;;</span>
    <span class="s5">/** `[Standard]` Creates a Record type */</span>
    <span class="s1">Record&lt;</span><span class="s2">K </span><span class="s0">extends </span><span class="s2">TTemplateLiteral</span><span class="s1">, </span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">&gt;(</span><span class="s2">key</span><span class="s0">: </span><span class="s2">K</span><span class="s1">, </span><span class="s2">schema</span><span class="s0">: </span><span class="s2">T</span><span class="s1">, </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">ObjectOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">RecordTemplateLiteralType</span><span class="s1">&lt;</span><span class="s2">K</span><span class="s1">, </span><span class="s2">T</span><span class="s1">&gt;;</span>
    <span class="s5">/** `[Standard]` Creates a Record type */</span>
    <span class="s1">Record&lt;</span><span class="s2">K </span><span class="s0">extends </span><span class="s2">TInteger </span><span class="s0">| </span><span class="s2">TNumber</span><span class="s1">, </span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">&gt;(</span><span class="s2">key</span><span class="s0">: </span><span class="s2">K</span><span class="s1">, </span><span class="s2">schema</span><span class="s0">: </span><span class="s2">T</span><span class="s1">, </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">ObjectOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">RecordNumberType</span><span class="s1">&lt;</span><span class="s2">K</span><span class="s1">, </span><span class="s2">T</span><span class="s1">&gt;;</span>
    <span class="s5">/** `[Standard]` Creates a Record type */</span>
    <span class="s1">Record&lt;</span><span class="s2">K </span><span class="s0">extends </span><span class="s2">TString</span><span class="s1">, </span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">&gt;(</span><span class="s2">key</span><span class="s0">: </span><span class="s2">K</span><span class="s1">, </span><span class="s2">schema</span><span class="s0">: </span><span class="s2">T</span><span class="s1">, </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">ObjectOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">RecordStringType</span><span class="s1">&lt;</span><span class="s2">K</span><span class="s1">, </span><span class="s2">T</span><span class="s1">&gt;;</span>
    <span class="s5">/** `[Standard]` Creates a Recursive type */</span>
    <span class="s1">Recursive&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">&gt;(</span><span class="s7">callback</span><span class="s0">: </span><span class="s1">(</span><span class="s2">thisType</span><span class="s0">: </span><span class="s2">TThis</span><span class="s1">) </span><span class="s0">=&gt; </span><span class="s2">T</span><span class="s1">, </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">SchemaOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TRecursive</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt;;</span>
    <span class="s5">/** `[Standard]` Creates a Ref type. The referenced type must contain a $id */</span>
    <span class="s1">Ref&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">&gt;(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">T</span><span class="s1">, </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">SchemaOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TRef</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt;;</span>
    <span class="s5">/** `[Standard]` Creates a mapped type where all properties are Required */</span>
    <span class="s1">Required&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">&gt;(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">T</span><span class="s1">, </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">SchemaOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TRequired</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt;;</span>
    <span class="s5">/** `[Standard]` Creates a String type */</span>
    <span class="s1">String&lt;</span><span class="s2">Format </span><span class="s0">extends </span><span class="s2">string</span><span class="s1">&gt;(</span><span class="s2">options</span><span class="s0">?: </span><span class="s2">StringOptions</span><span class="s1">&lt;</span><span class="s2">StringFormatOption </span><span class="s0">| </span><span class="s2">Format</span><span class="s1">&gt;)</span><span class="s0">: </span><span class="s2">TString</span><span class="s1">&lt;</span><span class="s2">Format</span><span class="s1">&gt;;</span>
    <span class="s5">/** `[Standard]` Creates a template literal type */</span>
    <span class="s1">TemplateLiteral&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TTemplateLiteralKind</span><span class="s1">[]&gt;(</span><span class="s2">kinds</span><span class="s0">: </span><span class="s1">[</span><span class="s0">...</span><span class="s2">T</span><span class="s1">], </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">SchemaOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TTemplateLiteral</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt;;</span>
    <span class="s5">/** `[Standard]` Creates a Tuple type */</span>
    <span class="s1">Tuple&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">[]&gt;(</span><span class="s2">items</span><span class="s0">: </span><span class="s1">[</span><span class="s0">...</span><span class="s2">T</span><span class="s1">], </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">SchemaOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TTuple</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt;;</span>
    <span class="s5">/** `[Standard]` Creates a Union type */</span>
    <span class="s1">Union(</span><span class="s2">anyOf</span><span class="s0">: </span><span class="s1">[], </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">SchemaOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TNever</span><span class="s1">;</span>
    <span class="s5">/** `[Standard]` Creates a Union type */</span>
    <span class="s1">Union&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s1">[</span><span class="s2">TSchema</span><span class="s1">]&gt;(</span><span class="s2">anyOf</span><span class="s0">: </span><span class="s1">[</span><span class="s0">...</span><span class="s2">T</span><span class="s1">], </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">SchemaOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">T</span><span class="s1">[</span><span class="s4">0</span><span class="s1">];</span>
    <span class="s5">/** `[Standard]` Creates a Union type */</span>
    <span class="s1">Union&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">[]&gt;(</span><span class="s2">anyOf</span><span class="s0">: </span><span class="s1">[</span><span class="s0">...</span><span class="s2">T</span><span class="s1">], </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">SchemaOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TUnion</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt;;</span>
    <span class="s5">/** `[Experimental]` Remaps a TemplateLiteral into a Union representation. This function is known to cause TS compiler crashes for finite templates with large generation counts. Use with caution. */</span>
    <span class="s1">Union&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TTemplateLiteral</span><span class="s1">&gt;(</span><span class="s2">template</span><span class="s0">: </span><span class="s2">T</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TUnionTemplateLiteral</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt;;</span>
    <span class="s5">/** `[Standard]` Creates an Unknown type */</span>
    <span class="s1">Unknown(</span><span class="s2">options</span><span class="s0">?: </span><span class="s2">SchemaOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TUnknown</span><span class="s1">;</span>
    <span class="s5">/** `[Standard]` Creates a Unsafe type that infers for the generic argument */</span>
    <span class="s1">Unsafe&lt;</span><span class="s2">T</span><span class="s1">&gt;(</span><span class="s2">options</span><span class="s0">?: </span><span class="s2">UnsafeOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TUnsafe</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt;;</span>
<span class="s1">}</span>
<span class="s2">export declare </span><span class="s0">class </span><span class="s2">ExtendedTypeBuilder </span><span class="s0">extends </span><span class="s2">StandardTypeBuilder </span><span class="s1">{</span>
    <span class="s5">/** `[Extended]` Creates a BigInt type */</span>
    <span class="s1">BigInt(</span><span class="s2">options</span><span class="s0">?: </span><span class="s2">NumericOptions</span><span class="s1">&lt;</span><span class="s2">bigint</span><span class="s1">&gt;)</span><span class="s0">: </span><span class="s2">TBigInt</span><span class="s1">;</span>
    <span class="s5">/** `[Extended]` Extracts the ConstructorParameters from the given Constructor type */</span>
    <span class="s1">ConstructorParameters&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TConstructor</span><span class="s1">&lt;</span><span class="s2">any</span><span class="s1">[], </span><span class="s2">any</span><span class="s1">&gt;&gt;(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">T</span><span class="s1">, </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">SchemaOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TConstructorParameters</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt;;</span>
    <span class="s5">/** `[Extended]` Creates a Constructor type */</span>
    <span class="s1">Constructor&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TTuple</span><span class="s1">&lt;</span><span class="s2">TSchema</span><span class="s1">[]&gt;, </span><span class="s2">U </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">&gt;(</span><span class="s2">parameters</span><span class="s0">: </span><span class="s2">T</span><span class="s1">, </span><span class="s2">returns</span><span class="s0">: </span><span class="s2">U</span><span class="s1">, </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">SchemaOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TConstructor</span><span class="s1">&lt;</span><span class="s2">TTupleIntoArray</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt;, </span><span class="s2">U</span><span class="s1">&gt;;</span>
    <span class="s5">/** `[Extended]` Creates a Constructor type */</span>
    <span class="s1">Constructor&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">[], </span><span class="s2">U </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">&gt;(</span><span class="s2">parameters</span><span class="s0">: </span><span class="s1">[</span><span class="s0">...</span><span class="s2">T</span><span class="s1">], </span><span class="s2">returns</span><span class="s0">: </span><span class="s2">U</span><span class="s1">, </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">SchemaOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TConstructor</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">, </span><span class="s2">U</span><span class="s1">&gt;;</span>
    <span class="s5">/** `[Extended]` Creates a Date type */</span>
    <span class="s1">Date(</span><span class="s2">options</span><span class="s0">?: </span><span class="s2">DateOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TDate</span><span class="s1">;</span>
    <span class="s5">/** `[Extended]` Creates a Function type */</span>
    <span class="s1">Function&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TTuple</span><span class="s1">&lt;</span><span class="s2">TSchema</span><span class="s1">[]&gt;, </span><span class="s2">U </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">&gt;(</span><span class="s2">parameters</span><span class="s0">: </span><span class="s2">T</span><span class="s1">, </span><span class="s2">returns</span><span class="s0">: </span><span class="s2">U</span><span class="s1">, </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">SchemaOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TFunction</span><span class="s1">&lt;</span><span class="s2">TTupleIntoArray</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt;, </span><span class="s2">U</span><span class="s1">&gt;;</span>
    <span class="s5">/** `[Extended]` Creates a Function type */</span>
    <span class="s1">Function&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">[], </span><span class="s2">U </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">&gt;(</span><span class="s2">parameters</span><span class="s0">: </span><span class="s1">[</span><span class="s0">...</span><span class="s2">T</span><span class="s1">], </span><span class="s2">returns</span><span class="s0">: </span><span class="s2">U</span><span class="s1">, </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">SchemaOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TFunction</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">, </span><span class="s2">U</span><span class="s1">&gt;;</span>
    <span class="s5">/** `[Extended]` Extracts the InstanceType from the given Constructor */</span>
    <span class="s1">InstanceType&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TConstructor</span><span class="s1">&lt;</span><span class="s2">any</span><span class="s1">[], </span><span class="s2">any</span><span class="s1">&gt;&gt;(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">T</span><span class="s1">, </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">SchemaOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TInstanceType</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt;;</span>
    <span class="s5">/** `[Extended]` Extracts the Parameters from the given Function type */</span>
    <span class="s1">Parameters&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TFunction</span><span class="s1">&lt;</span><span class="s2">any</span><span class="s1">[], </span><span class="s2">any</span><span class="s1">&gt;&gt;(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">T</span><span class="s1">, </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">SchemaOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TParameters</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt;;</span>
    <span class="s5">/** `[Extended]` Creates a Promise type */</span>
    <span class="s1">Promise&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TSchema</span><span class="s1">&gt;(</span><span class="s2">item</span><span class="s0">: </span><span class="s2">T</span><span class="s1">, </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">SchemaOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TPromise</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt;;</span>
    <span class="s5">/** `[Extended]` Creates a regular expression type */</span>
    <span class="s1">RegEx(</span><span class="s2">regex</span><span class="s0">: </span><span class="s2">RegExp</span><span class="s1">, </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">SchemaOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TString</span><span class="s1">;</span>
    <span class="s5">/** `[Extended]` Extracts the ReturnType from the given Function */</span>
    <span class="s1">ReturnType&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">TFunction</span><span class="s1">&lt;</span><span class="s2">any</span><span class="s1">[], </span><span class="s2">any</span><span class="s1">&gt;&gt;(</span><span class="s2">schema</span><span class="s0">: </span><span class="s2">T</span><span class="s1">, </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">SchemaOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TReturnType</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt;;</span>
    <span class="s5">/** `[Extended]` Creates a Symbol type */</span>
    <span class="s1">Symbol(</span><span class="s2">options</span><span class="s0">?: </span><span class="s2">SchemaOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TSymbol</span><span class="s1">;</span>
    <span class="s5">/** `[Extended]` Creates a Undefined type */</span>
    <span class="s1">Undefined(</span><span class="s2">options</span><span class="s0">?: </span><span class="s2">SchemaOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TUndefined</span><span class="s1">;</span>
    <span class="s5">/** `[Extended]` Creates a Uint8Array type */</span>
    <span class="s1">Uint8Array(</span><span class="s2">options</span><span class="s0">?: </span><span class="s2">Uint8ArrayOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TUint8Array</span><span class="s1">;</span>
    <span class="s5">/** `[Extended]` Creates a Void type */</span>
    <span class="s1">Void(</span><span class="s2">options</span><span class="s0">?: </span><span class="s2">SchemaOptions</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TVoid</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s5">/** JSON Schema TypeBuilder with Static Resolution for TypeScript */</span>
<span class="s2">export declare const StandardType</span><span class="s0">: </span><span class="s2">StandardTypeBuilder</span><span class="s1">;</span>
<span class="s5">/** JSON Schema TypeBuilder with Static Resolution for TypeScript */</span>
<span class="s2">export </span><span class="s0">declare </span><span class="s2">const </span><span class="s1">Type</span><span class="s0">: </span><span class="s2">ExtendedTypeBuilder</span><span class="s1">;</span>
</pre>
</body>
</html>
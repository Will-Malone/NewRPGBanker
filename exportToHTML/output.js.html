<html>
<head>
<title>output.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
.s5 { color: #4646f1;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
output.js</font>
</center></td></tr></table>
<pre><span class="s0">/*********************************************************************** 
 
  A JavaScript tokenizer / parser / beautifier / compressor. 
  https://github.com/mishoo/UglifyJS2 
 
  -------------------------------- (C) --------------------------------- 
 
                           Author: Mihai Bazon 
                         &lt;mihai.bazon@gmail.com&gt; 
                       http://mihai.bazon.net/blog 
 
  Distributed under the BSD license: 
 
    Copyright 2012 (c) Mihai Bazon &lt;mihai.bazon@gmail.com&gt; 
 
    Redistribution and use in source and binary forms, with or without 
    modification, are permitted provided that the following conditions 
    are met: 
 
        * Redistributions of source code must retain the above 
          copyright notice, this list of conditions and the following 
          disclaimer. 
 
        * Redistributions in binary form must reproduce the above 
          copyright notice, this list of conditions and the following 
          disclaimer in the documentation and/or other materials 
          provided with the distribution. 
 
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY 
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE 
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, 
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF 
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
    SUCH DAMAGE. 
 
 ***********************************************************************/</span>

<span class="s2">&quot;use strict&quot;</span><span class="s1">;</span>

<span class="s3">var </span><span class="s1">EXPECT_DIRECTIVE = /^$|[;{][\s\n]*$/;</span>

<span class="s3">function </span><span class="s1">is_some_comments(comment) {</span>
    <span class="s0">// multiline comment</span>
    <span class="s3">return </span><span class="s1">comment.type == </span><span class="s2">&quot;comment2&quot; </span><span class="s1">&amp;&amp; /@preserve|@license|@cc_on/i.test(comment.value);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">OutputStream(options) {</span>

    <span class="s3">var </span><span class="s1">readonly = !options;</span>
    <span class="s1">options = defaults(options, {</span>
        <span class="s1">ascii_only       : </span><span class="s3">false</span><span class="s1">,</span>
        <span class="s1">beautify         : </span><span class="s3">false</span><span class="s1">,</span>
        <span class="s1">bracketize       : </span><span class="s3">false</span><span class="s1">,</span>
        <span class="s1">comments         : </span><span class="s3">false</span><span class="s1">,</span>
        <span class="s1">ecma             : </span><span class="s4">5</span><span class="s1">,</span>
        <span class="s1">ie8              : </span><span class="s3">false</span><span class="s1">,</span>
        <span class="s1">indent_level     : </span><span class="s4">4</span><span class="s1">,</span>
        <span class="s1">indent_start     : </span><span class="s4">0</span><span class="s1">,</span>
        <span class="s1">inline_script    : </span><span class="s3">true</span><span class="s1">,</span>
        <span class="s1">keep_quoted_props: </span><span class="s3">false</span><span class="s1">,</span>
        <span class="s1">max_line_len     : </span><span class="s3">false</span><span class="s1">,</span>
        <span class="s1">preamble         : </span><span class="s3">null</span><span class="s1">,</span>
        <span class="s1">preserve_line    : </span><span class="s3">false</span><span class="s1">,</span>
        <span class="s1">quote_keys       : </span><span class="s3">false</span><span class="s1">,</span>
        <span class="s1">quote_style      : </span><span class="s4">0</span><span class="s1">,</span>
        <span class="s1">safari10         : </span><span class="s3">false</span><span class="s1">,</span>
        <span class="s1">semicolons       : </span><span class="s3">true</span><span class="s1">,</span>
        <span class="s1">shebang          : </span><span class="s3">true</span><span class="s1">,</span>
        <span class="s1">shorthand        : undefined,</span>
        <span class="s1">source_map       : </span><span class="s3">null</span><span class="s1">,</span>
        <span class="s1">webkit           : </span><span class="s3">false</span><span class="s1">,</span>
        <span class="s1">width            : </span><span class="s4">80</span><span class="s1">,</span>
        <span class="s1">wrap_iife        : </span><span class="s3">false</span><span class="s1">,</span>
    <span class="s1">}, </span><span class="s3">true</span><span class="s1">);</span>

    <span class="s3">if </span><span class="s1">(options.shorthand === undefined)</span>
        <span class="s1">options.shorthand = options.ecma &gt; </span><span class="s4">5</span><span class="s1">;</span>

    <span class="s0">// Convert comment option to RegExp if neccessary and set up comments filter</span>
    <span class="s3">var </span><span class="s1">comment_filter = return_false; </span><span class="s0">// Default case, throw all comments away</span>
    <span class="s3">if </span><span class="s1">(options.comments) {</span>
        <span class="s3">var </span><span class="s1">comments = options.comments;</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">options.comments === </span><span class="s2">&quot;string&quot; </span><span class="s1">&amp;&amp; /^\/.*\/[a-zA-Z]*$/.test(options.comments)) {</span>
            <span class="s3">var </span><span class="s1">regex_pos = options.comments.lastIndexOf(</span><span class="s2">&quot;/&quot;</span><span class="s1">);</span>
            <span class="s1">comments = </span><span class="s3">new </span><span class="s1">RegExp(</span>
                <span class="s1">options.comments.substr(</span><span class="s4">1</span><span class="s1">, regex_pos - </span><span class="s4">1</span><span class="s1">),</span>
                <span class="s1">options.comments.substr(regex_pos + </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(comments </span><span class="s3">instanceof </span><span class="s1">RegExp) {</span>
            <span class="s1">comment_filter = </span><span class="s3">function</span><span class="s1">(comment) {</span>
                <span class="s3">return </span><span class="s1">comment.type != </span><span class="s2">&quot;comment5&quot; </span><span class="s1">&amp;&amp; comments.test(comment.value);</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
        <span class="s3">else if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">comments === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
            <span class="s1">comment_filter = </span><span class="s3">function</span><span class="s1">(comment) {</span>
                <span class="s3">return </span><span class="s1">comment.type != </span><span class="s2">&quot;comment5&quot; </span><span class="s1">&amp;&amp; comments(</span><span class="s3">this</span><span class="s1">, comment);</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
        <span class="s3">else if </span><span class="s1">(comments === </span><span class="s2">&quot;some&quot;</span><span class="s1">) {</span>
            <span class="s1">comment_filter = is_some_comments;</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{ </span><span class="s0">// NOTE includes &quot;all&quot; option</span>
            <span class="s1">comment_filter = return_true;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">indentation = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">current_col = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">current_line = </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">current_pos = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">OUTPUT = </span><span class="s2">&quot;&quot;</span><span class="s1">;</span>

    <span class="s3">var </span><span class="s1">to_utf8 = options.ascii_only ? </span><span class="s3">function</span><span class="s1">(str, identifier) {</span>
        <span class="s3">if </span><span class="s1">(options.ecma &gt;= </span><span class="s4">6</span><span class="s1">) {</span>
            <span class="s1">str = str.replace(/[\ud800-\udbff][\udc00-\udfff]/g, </span><span class="s3">function</span><span class="s1">(ch) {</span>
                <span class="s3">var </span><span class="s1">code = get_full_char_code(ch, </span><span class="s4">0</span><span class="s1">).toString(</span><span class="s4">16</span><span class="s1">);</span>
                <span class="s3">return </span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">u{&quot; </span><span class="s1">+ code + </span><span class="s2">&quot;}&quot;</span><span class="s1">;</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">str.replace(/[\u0000-\u001f\u007f-\uffff]/g, </span><span class="s3">function</span><span class="s1">(ch) {</span>
            <span class="s3">var </span><span class="s1">code = ch.charCodeAt(</span><span class="s4">0</span><span class="s1">).toString(</span><span class="s4">16</span><span class="s1">);</span>
            <span class="s3">if </span><span class="s1">(code.length &lt;= </span><span class="s4">2 </span><span class="s1">&amp;&amp; !identifier) {</span>
                <span class="s3">while </span><span class="s1">(code.length &lt; </span><span class="s4">2</span><span class="s1">) code = </span><span class="s2">&quot;0&quot; </span><span class="s1">+ code;</span>
                <span class="s3">return </span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">x&quot; </span><span class="s1">+ code;</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s3">while </span><span class="s1">(code.length &lt; </span><span class="s4">4</span><span class="s1">) code = </span><span class="s2">&quot;0&quot; </span><span class="s1">+ code;</span>
                <span class="s3">return </span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">u&quot; </span><span class="s1">+ code;</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
    <span class="s1">} : </span><span class="s3">function</span><span class="s1">(str) {</span>
        <span class="s3">var </span><span class="s1">s = </span><span class="s2">&quot;&quot;</span><span class="s1">;</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">, len = str.length; i &lt; len; i++) {</span>
            <span class="s3">if </span><span class="s1">(is_surrogate_pair_head(str[i]) &amp;&amp; !is_surrogate_pair_tail(str[i + </span><span class="s4">1</span><span class="s1">])</span>
                <span class="s1">|| is_surrogate_pair_tail(str[i]) &amp;&amp; !is_surrogate_pair_head(str[i - </span><span class="s4">1</span><span class="s1">])) {</span>
                <span class="s1">s += </span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">u&quot; </span><span class="s1">+ str.charCodeAt(i).toString(</span><span class="s4">16</span><span class="s1">);</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s1">s += str[i];</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">s;</span>
    <span class="s1">};</span>

    <span class="s3">function </span><span class="s1">make_string(str, quote) {</span>
        <span class="s3">var </span><span class="s1">dq = </span><span class="s4">0</span><span class="s1">, sq = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">str = str.replace(/[\\\b\f\n\r\v\t\x22\x27\u2028\u2029\</span><span class="s4">0</span><span class="s1">\ufeff]/g,</span>
          <span class="s3">function</span><span class="s1">(s, i){</span>
            <span class="s3">switch </span><span class="s1">(s) {</span>
              <span class="s3">case </span><span class="s2">'&quot;'</span><span class="s1">: ++dq; </span><span class="s3">return </span><span class="s2">'&quot;'</span><span class="s1">;</span>
              <span class="s3">case </span><span class="s2">&quot;'&quot;</span><span class="s1">: ++sq; </span><span class="s3">return </span><span class="s2">&quot;'&quot;</span><span class="s1">;</span>
              <span class="s3">case </span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">&quot;</span><span class="s1">: </span><span class="s3">return </span><span class="s2">&quot;</span><span class="s5">\\\\</span><span class="s2">&quot;</span><span class="s1">;</span>
              <span class="s3">case </span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot;</span><span class="s1">: </span><span class="s3">return </span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">n&quot;</span><span class="s1">;</span>
              <span class="s3">case </span><span class="s2">&quot;</span><span class="s5">\r</span><span class="s2">&quot;</span><span class="s1">: </span><span class="s3">return </span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">r&quot;</span><span class="s1">;</span>
              <span class="s3">case </span><span class="s2">&quot;</span><span class="s5">\t</span><span class="s2">&quot;</span><span class="s1">: </span><span class="s3">return </span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">t&quot;</span><span class="s1">;</span>
              <span class="s3">case </span><span class="s2">&quot;</span><span class="s5">\b</span><span class="s2">&quot;</span><span class="s1">: </span><span class="s3">return </span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">b&quot;</span><span class="s1">;</span>
              <span class="s3">case </span><span class="s2">&quot;</span><span class="s5">\f</span><span class="s2">&quot;</span><span class="s1">: </span><span class="s3">return </span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">f&quot;</span><span class="s1">;</span>
              <span class="s3">case </span><span class="s2">&quot;</span><span class="s5">\x</span><span class="s2">0B&quot;</span><span class="s1">: </span><span class="s3">return </span><span class="s1">options.ie8 ? </span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">x0B&quot; </span><span class="s1">: </span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">v&quot;</span><span class="s1">;</span>
              <span class="s3">case </span><span class="s2">&quot;</span><span class="s5">\u2028</span><span class="s2">&quot;</span><span class="s1">: </span><span class="s3">return </span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">u2028&quot;</span><span class="s1">;</span>
              <span class="s3">case </span><span class="s2">&quot;</span><span class="s5">\u2029</span><span class="s2">&quot;</span><span class="s1">: </span><span class="s3">return </span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">u2029&quot;</span><span class="s1">;</span>
              <span class="s3">case </span><span class="s2">&quot;</span><span class="s5">\ufeff</span><span class="s2">&quot;</span><span class="s1">: </span><span class="s3">return </span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">ufeff&quot;</span><span class="s1">;</span>
              <span class="s3">case </span><span class="s2">&quot;</span><span class="s5">\0</span><span class="s2">&quot;</span><span class="s1">:</span>
                  <span class="s3">return </span><span class="s1">/[</span><span class="s4">0</span><span class="s1">-</span><span class="s4">9</span><span class="s1">]/.test(get_full_char(str, i+</span><span class="s4">1</span><span class="s1">)) ? </span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">x00&quot; </span><span class="s1">: </span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">0&quot;</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">return </span><span class="s1">s;</span>
        <span class="s1">});</span>
        <span class="s3">function </span><span class="s1">quote_single() {</span>
            <span class="s3">return </span><span class="s2">&quot;'&quot; </span><span class="s1">+ str.replace(/\x27/g, </span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">'&quot;</span><span class="s1">) + </span><span class="s2">&quot;'&quot;</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">function </span><span class="s1">quote_double() {</span>
            <span class="s3">return </span><span class="s2">'&quot;' </span><span class="s1">+ str.replace(/\x22/g, </span><span class="s2">'</span><span class="s5">\\</span><span class="s2">&quot;'</span><span class="s1">) + </span><span class="s2">'&quot;'</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">function </span><span class="s1">quote_template() {</span>
            <span class="s3">return </span><span class="s2">'`' </span><span class="s1">+ str.replace(/`/g, </span><span class="s2">'</span><span class="s5">\\</span><span class="s2">`'</span><span class="s1">) + </span><span class="s2">'`'</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">str = to_utf8(str);</span>
        <span class="s3">if </span><span class="s1">(quote === </span><span class="s2">&quot;`&quot;</span><span class="s1">) </span><span class="s3">return </span><span class="s1">quote_template();</span>
        <span class="s3">switch </span><span class="s1">(options.quote_style) {</span>
          <span class="s3">case </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">quote_single();</span>
          <span class="s3">case </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">quote_double();</span>
          <span class="s3">case </span><span class="s4">3</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">quote == </span><span class="s2">&quot;'&quot; </span><span class="s1">? quote_single() : quote_double();</span>
          <span class="s3">default</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">dq &gt; sq ? quote_single() : quote_double();</span>
        <span class="s1">}</span>
    <span class="s1">};</span>

    <span class="s3">function </span><span class="s1">encode_string(str, quote) {</span>
        <span class="s3">var </span><span class="s1">ret = make_string(str, quote);</span>
        <span class="s3">if </span><span class="s1">(options.inline_script) {</span>
            <span class="s1">ret = ret.replace(/&lt;\x2fscript([&gt;\/\t\n\f\r ])/gi, </span><span class="s2">&quot;&lt;</span><span class="s5">\\</span><span class="s2">/script$1&quot;</span><span class="s1">);</span>
            <span class="s1">ret = ret.replace(/\x3c!--/g, </span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">x3c!--&quot;</span><span class="s1">);</span>
            <span class="s1">ret = ret.replace(/--\x3e/g, </span><span class="s2">&quot;--</span><span class="s5">\\</span><span class="s2">x3e&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">ret;</span>
    <span class="s1">};</span>

    <span class="s3">function </span><span class="s1">make_name(name) {</span>
        <span class="s1">name = name.toString();</span>
        <span class="s1">name = to_utf8(name, </span><span class="s3">true</span><span class="s1">);</span>
        <span class="s3">return </span><span class="s1">name;</span>
    <span class="s1">};</span>

    <span class="s3">function </span><span class="s1">make_indent(back) {</span>
        <span class="s3">return </span><span class="s1">repeat_string(</span><span class="s2">&quot; &quot;</span><span class="s1">, options.indent_start + indentation - back * options.indent_level);</span>
    <span class="s1">};</span>

    <span class="s0">/* -----[ beautification/minification ]----- */</span>

    <span class="s3">var </span><span class="s1">might_need_space = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">might_need_semicolon = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">might_add_newline = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">need_newline_indented = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">need_space = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">newline_insert = -</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">last = </span><span class="s2">&quot;&quot;</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">mapping_token, mapping_name, mappings = options.source_map &amp;&amp; [];</span>

    <span class="s3">var </span><span class="s1">do_add_mapping = mappings ? </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s1">mappings.forEach(</span><span class="s3">function</span><span class="s1">(mapping) {</span>
            <span class="s3">try </span><span class="s1">{</span>
                <span class="s1">options.source_map.add(</span>
                    <span class="s1">mapping.token.file,</span>
                    <span class="s1">mapping.line, mapping.col,</span>
                    <span class="s1">mapping.token.line, mapping.token.col,</span>
                    <span class="s1">!mapping.name &amp;&amp; mapping.token.type == </span><span class="s2">&quot;name&quot; </span><span class="s1">? mapping.token.value : mapping.name</span>
                <span class="s1">);</span>
            <span class="s1">} </span><span class="s3">catch</span><span class="s1">(ex) {</span>
                <span class="s1">AST_Node.warn(</span><span class="s2">&quot;Couldn't figure out mapping for {file}:{line},{col} → {cline},{ccol} [{name}]&quot;</span><span class="s1">, {</span>
                    <span class="s1">file: mapping.token.file,</span>
                    <span class="s1">line: mapping.token.line,</span>
                    <span class="s1">col: mapping.token.col,</span>
                    <span class="s1">cline: mapping.line,</span>
                    <span class="s1">ccol: mapping.col,</span>
                    <span class="s1">name: mapping.name || </span><span class="s2">&quot;&quot;</span>
                <span class="s1">})</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
        <span class="s1">mappings = [];</span>
    <span class="s1">} : noop;</span>

    <span class="s3">var </span><span class="s1">ensure_line_len = options.max_line_len ? </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">if </span><span class="s1">(current_col &gt; options.max_line_len) {</span>
            <span class="s3">if </span><span class="s1">(might_add_newline) {</span>
                <span class="s3">var </span><span class="s1">left = OUTPUT.slice(</span><span class="s4">0</span><span class="s1">, might_add_newline);</span>
                <span class="s3">var </span><span class="s1">right = OUTPUT.slice(might_add_newline);</span>
                <span class="s3">if </span><span class="s1">(mappings) {</span>
                    <span class="s3">var </span><span class="s1">delta = right.length - current_col;</span>
                    <span class="s1">mappings.forEach(</span><span class="s3">function</span><span class="s1">(mapping) {</span>
                        <span class="s1">mapping.line++;</span>
                        <span class="s1">mapping.col += delta;</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s1">OUTPUT = left + </span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot; </span><span class="s1">+ right;</span>
                <span class="s1">current_line++;</span>
                <span class="s1">current_pos++;</span>
                <span class="s1">current_col = right.length;</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(current_col &gt; options.max_line_len) {</span>
                <span class="s1">AST_Node.warn(</span><span class="s2">&quot;Output exceeds {max_line_len} characters&quot;</span><span class="s1">, options);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(might_add_newline) {</span>
            <span class="s1">might_add_newline = </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s1">do_add_mapping();</span>
        <span class="s1">}</span>
    <span class="s1">} : noop;</span>

    <span class="s3">var </span><span class="s1">requireSemicolonChars = makePredicate(</span><span class="s2">&quot;( [ + * / - , . `&quot;</span><span class="s1">);</span>

    <span class="s3">function </span><span class="s1">print(str) {</span>
        <span class="s1">str = String(str);</span>
        <span class="s3">var </span><span class="s1">ch = get_full_char(str, </span><span class="s4">0</span><span class="s1">);</span>
        <span class="s3">var </span><span class="s1">prev = get_full_char(last, last.length - </span><span class="s4">1</span><span class="s1">);</span>
        <span class="s3">if </span><span class="s1">(need_newline_indented &amp;&amp; ch) {</span>
            <span class="s1">need_newline_indented = </span><span class="s3">false</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(ch != </span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot;</span><span class="s1">) {</span>
                <span class="s1">print(</span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot;</span><span class="s1">);</span>
                <span class="s1">indent();</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(need_space &amp;&amp; ch) {</span>
            <span class="s1">need_space = </span><span class="s3">false</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(!/[\s;})]/.test(ch)) {</span>
                <span class="s1">space();</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">newline_insert = -</span><span class="s4">1</span><span class="s1">;</span>
        <span class="s3">var </span><span class="s1">prev = last.charAt(last.length - </span><span class="s4">1</span><span class="s1">);</span>
        <span class="s3">if </span><span class="s1">(might_need_semicolon) {</span>
            <span class="s1">might_need_semicolon = </span><span class="s3">false</span><span class="s1">;</span>

            <span class="s3">if </span><span class="s1">(prev == </span><span class="s2">&quot;:&quot; </span><span class="s1">&amp;&amp; ch == </span><span class="s2">&quot;}&quot; </span><span class="s1">|| (!ch || </span><span class="s2">&quot;;}&quot;</span><span class="s1">.indexOf(ch) &lt; </span><span class="s4">0</span><span class="s1">) &amp;&amp; prev != </span><span class="s2">&quot;;&quot;</span><span class="s1">) {</span>
                <span class="s3">if </span><span class="s1">(options.semicolons || requireSemicolonChars(ch)) {</span>
                    <span class="s1">OUTPUT += </span><span class="s2">&quot;;&quot;</span><span class="s1">;</span>
                    <span class="s1">current_col++;</span>
                    <span class="s1">current_pos++;</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s1">ensure_line_len();</span>
                    <span class="s1">OUTPUT += </span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot;</span><span class="s1">;</span>
                    <span class="s1">current_pos++;</span>
                    <span class="s1">current_line++;</span>
                    <span class="s1">current_col = </span><span class="s4">0</span><span class="s1">;</span>

                    <span class="s3">if </span><span class="s1">(/^\s+$/.test(str)) {</span>
                        <span class="s0">// reset the semicolon flag, since we didn't print one</span>
                        <span class="s0">// now and might still have to later</span>
                        <span class="s1">might_need_semicolon = </span><span class="s3">true</span><span class="s1">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>

                <span class="s3">if </span><span class="s1">(!options.beautify)</span>
                    <span class="s1">might_need_space = </span><span class="s3">false</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(!options.beautify &amp;&amp; options.preserve_line &amp;&amp; stack[stack.length - </span><span class="s4">1</span><span class="s1">]) {</span>
            <span class="s3">var </span><span class="s1">target_line = stack[stack.length - </span><span class="s4">1</span><span class="s1">].start.line;</span>
            <span class="s3">while </span><span class="s1">(current_line &lt; target_line) {</span>
                <span class="s1">ensure_line_len();</span>
                <span class="s1">OUTPUT += </span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot;</span><span class="s1">;</span>
                <span class="s1">current_pos++;</span>
                <span class="s1">current_line++;</span>
                <span class="s1">current_col = </span><span class="s4">0</span><span class="s1">;</span>
                <span class="s1">might_need_space = </span><span class="s3">false</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(might_need_space) {</span>
            <span class="s3">if </span><span class="s1">((is_identifier_char(prev)</span>
                    <span class="s1">&amp;&amp; (is_identifier_char(ch) || ch == </span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">&quot;</span><span class="s1">))</span>
                <span class="s1">|| (ch == </span><span class="s2">&quot;/&quot; </span><span class="s1">&amp;&amp; ch == prev)</span>
                <span class="s1">|| ((ch == </span><span class="s2">&quot;+&quot; </span><span class="s1">|| ch == </span><span class="s2">&quot;-&quot;</span><span class="s1">) &amp;&amp; ch == last))</span>
            <span class="s1">{</span>
                <span class="s1">OUTPUT += </span><span class="s2">&quot; &quot;</span><span class="s1">;</span>
                <span class="s1">current_col++;</span>
                <span class="s1">current_pos++;</span>
            <span class="s1">}</span>
            <span class="s1">might_need_space = </span><span class="s3">false</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(mapping_token) {</span>
            <span class="s1">mappings.push({</span>
                <span class="s1">token: mapping_token,</span>
                <span class="s1">name: mapping_name,</span>
                <span class="s1">line: current_line,</span>
                <span class="s1">col: current_col</span>
            <span class="s1">});</span>
            <span class="s1">mapping_token = </span><span class="s3">false</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(!might_add_newline) do_add_mapping();</span>
        <span class="s1">}</span>

        <span class="s1">OUTPUT += str;</span>
        <span class="s1">current_pos += str.length;</span>
        <span class="s3">var </span><span class="s1">a = str.split(/\r?\n/), n = a.length - </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s1">current_line += n;</span>
        <span class="s1">current_col += a[</span><span class="s4">0</span><span class="s1">].length;</span>
        <span class="s3">if </span><span class="s1">(n &gt; </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s1">ensure_line_len();</span>
            <span class="s1">current_col = a[n].length;</span>
        <span class="s1">}</span>
        <span class="s1">last = str;</span>
    <span class="s1">};</span>

    <span class="s3">var </span><span class="s1">star = </span><span class="s3">function</span><span class="s1">(){</span>
        <span class="s1">print(</span><span class="s2">&quot;*&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">space = options.beautify ? </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s1">print(</span><span class="s2">&quot; &quot;</span><span class="s1">);</span>
    <span class="s1">} : </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s1">might_need_space = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">};</span>

    <span class="s3">var </span><span class="s1">indent = options.beautify ? </span><span class="s3">function</span><span class="s1">(half) {</span>
        <span class="s3">if </span><span class="s1">(options.beautify) {</span>
            <span class="s1">print(make_indent(half ? </span><span class="s4">0.5 </span><span class="s1">: </span><span class="s4">0</span><span class="s1">));</span>
        <span class="s1">}</span>
    <span class="s1">} : noop;</span>

    <span class="s3">var </span><span class="s1">with_indent = options.beautify ? </span><span class="s3">function</span><span class="s1">(col, cont) {</span>
        <span class="s3">if </span><span class="s1">(col === </span><span class="s3">true</span><span class="s1">) col = next_indent();</span>
        <span class="s3">var </span><span class="s1">save_indentation = indentation;</span>
        <span class="s1">indentation = col;</span>
        <span class="s3">var </span><span class="s1">ret = cont();</span>
        <span class="s1">indentation = save_indentation;</span>
        <span class="s3">return </span><span class="s1">ret;</span>
    <span class="s1">} : </span><span class="s3">function</span><span class="s1">(col, cont) { </span><span class="s3">return </span><span class="s1">cont() };</span>

    <span class="s3">var </span><span class="s1">newline = options.beautify ? </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">if </span><span class="s1">(newline_insert &lt; </span><span class="s4">0</span><span class="s1">) </span><span class="s3">return </span><span class="s1">print(</span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot;</span><span class="s1">);</span>
        <span class="s3">if </span><span class="s1">(OUTPUT[newline_insert] != </span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot;</span><span class="s1">) {</span>
            <span class="s1">OUTPUT = OUTPUT.slice(</span><span class="s4">0</span><span class="s1">, newline_insert) + </span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot; </span><span class="s1">+ OUTPUT.slice(newline_insert);</span>
            <span class="s1">current_pos++;</span>
            <span class="s1">current_line++;</span>
        <span class="s1">}</span>
        <span class="s1">newline_insert++;</span>
    <span class="s1">} : options.max_line_len ? </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s1">ensure_line_len();</span>
        <span class="s1">might_add_newline = OUTPUT.length;</span>
    <span class="s1">} : noop;</span>

    <span class="s3">var </span><span class="s1">semicolon = options.beautify ? </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s1">print(</span><span class="s2">&quot;;&quot;</span><span class="s1">);</span>
    <span class="s1">} : </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s1">might_need_semicolon = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">};</span>

    <span class="s3">function </span><span class="s1">force_semicolon() {</span>
        <span class="s1">might_need_semicolon = </span><span class="s3">false</span><span class="s1">;</span>
        <span class="s1">print(</span><span class="s2">&quot;;&quot;</span><span class="s1">);</span>
    <span class="s1">};</span>

    <span class="s3">function </span><span class="s1">next_indent() {</span>
        <span class="s3">return </span><span class="s1">indentation + options.indent_level;</span>
    <span class="s1">};</span>

    <span class="s3">function </span><span class="s1">with_block(cont) {</span>
        <span class="s3">var </span><span class="s1">ret;</span>
        <span class="s1">print(</span><span class="s2">&quot;{&quot;</span><span class="s1">);</span>
        <span class="s1">newline();</span>
        <span class="s1">with_indent(next_indent(), </span><span class="s3">function</span><span class="s1">(){</span>
            <span class="s1">ret = cont();</span>
        <span class="s1">});</span>
        <span class="s1">indent();</span>
        <span class="s1">print(</span><span class="s2">&quot;}&quot;</span><span class="s1">);</span>
        <span class="s3">return </span><span class="s1">ret;</span>
    <span class="s1">};</span>

    <span class="s3">function </span><span class="s1">with_parens(cont) {</span>
        <span class="s1">print(</span><span class="s2">&quot;(&quot;</span><span class="s1">);</span>
        <span class="s0">//XXX: still nice to have that for argument lists</span>
        <span class="s0">//var ret = with_indent(current_col, cont);</span>
        <span class="s3">var </span><span class="s1">ret = cont();</span>
        <span class="s1">print(</span><span class="s2">&quot;)&quot;</span><span class="s1">);</span>
        <span class="s3">return </span><span class="s1">ret;</span>
    <span class="s1">};</span>

    <span class="s3">function </span><span class="s1">with_square(cont) {</span>
        <span class="s1">print(</span><span class="s2">&quot;[&quot;</span><span class="s1">);</span>
        <span class="s0">//var ret = with_indent(current_col, cont);</span>
        <span class="s3">var </span><span class="s1">ret = cont();</span>
        <span class="s1">print(</span><span class="s2">&quot;]&quot;</span><span class="s1">);</span>
        <span class="s3">return </span><span class="s1">ret;</span>
    <span class="s1">};</span>

    <span class="s3">function </span><span class="s1">comma() {</span>
        <span class="s1">print(</span><span class="s2">&quot;,&quot;</span><span class="s1">);</span>
        <span class="s1">space();</span>
    <span class="s1">};</span>

    <span class="s3">function </span><span class="s1">colon() {</span>
        <span class="s1">print(</span><span class="s2">&quot;:&quot;</span><span class="s1">);</span>
        <span class="s1">space();</span>
    <span class="s1">};</span>

    <span class="s3">var </span><span class="s1">add_mapping = mappings ? </span><span class="s3">function</span><span class="s1">(token, name) {</span>
        <span class="s1">mapping_token = token;</span>
        <span class="s1">mapping_name = name;</span>
    <span class="s1">} : noop;</span>

    <span class="s3">function </span><span class="s1">get() {</span>
        <span class="s3">if </span><span class="s1">(might_add_newline) {</span>
            <span class="s1">ensure_line_len();</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">OUTPUT;</span>
    <span class="s1">};</span>

    <span class="s3">function </span><span class="s1">has_nlb() {</span>
        <span class="s3">var </span><span class="s1">index = OUTPUT.lastIndexOf(</span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot;</span><span class="s1">);</span>
        <span class="s3">return </span><span class="s1">/^ *$/.test(OUTPUT.slice(index + </span><span class="s4">1</span><span class="s1">));</span>
    <span class="s1">}</span>

    <span class="s3">function </span><span class="s1">prepend_comments(node) {</span>
        <span class="s3">var </span><span class="s1">self = </span><span class="s3">this</span><span class="s1">;</span>
        <span class="s3">var </span><span class="s1">start = node.start;</span>
        <span class="s3">if </span><span class="s1">(!start) </span><span class="s3">return</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s1">(start.comments_before &amp;&amp; start.comments_before._dumped === self) </span><span class="s3">return</span><span class="s1">;</span>
        <span class="s3">var </span><span class="s1">comments = start.comments_before;</span>
        <span class="s3">if </span><span class="s1">(!comments) {</span>
            <span class="s1">comments = start.comments_before = [];</span>
        <span class="s1">}</span>
        <span class="s1">comments._dumped = self;</span>

        <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Exit &amp;&amp; node.value) {</span>
            <span class="s3">var </span><span class="s1">tw = </span><span class="s3">new </span><span class="s1">TreeWalker(</span><span class="s3">function</span><span class="s1">(node) {</span>
                <span class="s3">var </span><span class="s1">parent = tw.parent();</span>
                <span class="s3">if </span><span class="s1">(parent </span><span class="s3">instanceof </span><span class="s1">AST_Exit</span>
                    <span class="s1">|| parent </span><span class="s3">instanceof </span><span class="s1">AST_Binary &amp;&amp; parent.left === node</span>
                    <span class="s1">|| parent.TYPE == </span><span class="s2">&quot;Call&quot; </span><span class="s1">&amp;&amp; parent.expression === node</span>
                    <span class="s1">|| parent </span><span class="s3">instanceof </span><span class="s1">AST_Conditional &amp;&amp; parent.condition === node</span>
                    <span class="s1">|| parent </span><span class="s3">instanceof </span><span class="s1">AST_Dot &amp;&amp; parent.expression === node</span>
                    <span class="s1">|| parent </span><span class="s3">instanceof </span><span class="s1">AST_Sequence &amp;&amp; parent.expressions[</span><span class="s4">0</span><span class="s1">] === node</span>
                    <span class="s1">|| parent </span><span class="s3">instanceof </span><span class="s1">AST_Sub &amp;&amp; parent.expression === node</span>
                    <span class="s1">|| parent </span><span class="s3">instanceof </span><span class="s1">AST_UnaryPostfix) {</span>
                    <span class="s3">if </span><span class="s1">(!node.start) </span><span class="s3">return</span><span class="s1">;</span>
                    <span class="s3">var </span><span class="s1">text = node.start.comments_before;</span>
                    <span class="s3">if </span><span class="s1">(text &amp;&amp; text._dumped !== self) {</span>
                        <span class="s1">text._dumped = self;</span>
                        <span class="s1">comments = comments.concat(text);</span>
                    <span class="s1">}</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s3">return true</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
            <span class="s1">tw.push(node);</span>
            <span class="s1">node.value.walk(tw);</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(current_pos == </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s3">if </span><span class="s1">(comments.length &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; options.shebang &amp;&amp; comments[</span><span class="s4">0</span><span class="s1">].type == </span><span class="s2">&quot;comment5&quot;</span><span class="s1">) {</span>
                <span class="s1">print(</span><span class="s2">&quot;#!&quot; </span><span class="s1">+ comments.shift().value + </span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot;</span><span class="s1">);</span>
                <span class="s1">indent();</span>
            <span class="s1">}</span>
            <span class="s3">var </span><span class="s1">preamble = options.preamble;</span>
            <span class="s3">if </span><span class="s1">(preamble) {</span>
                <span class="s1">print(preamble.replace(/\r\n?|[\n\u2028\u2029]|\s*$/g, </span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot;</span><span class="s1">));</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s1">comments = comments.filter(comment_filter, node);</span>
        <span class="s3">if </span><span class="s1">(comments.length == </span><span class="s4">0</span><span class="s1">) </span><span class="s3">return</span><span class="s1">;</span>
        <span class="s3">var </span><span class="s1">last_nlb = has_nlb();</span>
        <span class="s1">comments.forEach(</span><span class="s3">function</span><span class="s1">(c, i) {</span>
            <span class="s3">if </span><span class="s1">(!last_nlb) {</span>
                <span class="s3">if </span><span class="s1">(c.nlb) {</span>
                    <span class="s1">print(</span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot;</span><span class="s1">);</span>
                    <span class="s1">indent();</span>
                    <span class="s1">last_nlb = </span><span class="s3">true</span><span class="s1">;</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(i &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                    <span class="s1">space();</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(/comment[</span><span class="s4">134</span><span class="s1">]/.test(c.type)) {</span>
                <span class="s1">print(</span><span class="s2">&quot;//&quot; </span><span class="s1">+ c.value.replace(/[@#]__PURE__/g, </span><span class="s2">' '</span><span class="s1">) + </span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot;</span><span class="s1">);</span>
                <span class="s1">indent();</span>
                <span class="s1">last_nlb = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(c.type == </span><span class="s2">&quot;comment2&quot;</span><span class="s1">) {</span>
                <span class="s1">print(</span><span class="s2">&quot;/*&quot; </span><span class="s1">+ c.value.replace(/[@#]__PURE__/g, </span><span class="s2">' '</span><span class="s1">) + </span><span class="s2">&quot;*/&quot;</span><span class="s1">);</span>
                <span class="s1">last_nlb = </span><span class="s3">false</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
        <span class="s3">if </span><span class="s1">(!last_nlb) {</span>
            <span class="s3">if </span><span class="s1">(start.nlb) {</span>
                <span class="s1">print(</span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot;</span><span class="s1">);</span>
                <span class="s1">indent();</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s1">space();</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">function </span><span class="s1">append_comments(node, tail) {</span>
        <span class="s3">var </span><span class="s1">self = </span><span class="s3">this</span><span class="s1">;</span>
        <span class="s3">var </span><span class="s1">token = node.end;</span>
        <span class="s3">if </span><span class="s1">(!token) </span><span class="s3">return</span><span class="s1">;</span>
        <span class="s3">var </span><span class="s1">comments = token[tail ? </span><span class="s2">&quot;comments_before&quot; </span><span class="s1">: </span><span class="s2">&quot;comments_after&quot;</span><span class="s1">];</span>
        <span class="s3">if </span><span class="s1">(!comments || comments._dumped === self) </span><span class="s3">return</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s1">(!(node </span><span class="s3">instanceof </span><span class="s1">AST_Statement || all(comments, </span><span class="s3">function</span><span class="s1">(c) {</span>
            <span class="s3">return </span><span class="s1">!/comment[</span><span class="s4">134</span><span class="s1">]/.test(c.type);</span>
        <span class="s1">}))) </span><span class="s3">return</span><span class="s1">;</span>
        <span class="s1">comments._dumped = self;</span>
        <span class="s3">var </span><span class="s1">insert = OUTPUT.length;</span>
        <span class="s1">comments.filter(comment_filter, node).forEach(</span><span class="s3">function</span><span class="s1">(c, i) {</span>
            <span class="s1">need_space = </span><span class="s3">false</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(need_newline_indented) {</span>
                <span class="s1">print(</span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot;</span><span class="s1">);</span>
                <span class="s1">indent();</span>
                <span class="s1">need_newline_indented = </span><span class="s3">false</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(c.nlb &amp;&amp; (i &gt; </span><span class="s4">0 </span><span class="s1">|| !has_nlb())) {</span>
                <span class="s1">print(</span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot;</span><span class="s1">);</span>
                <span class="s1">indent();</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(i &gt; </span><span class="s4">0 </span><span class="s1">|| !tail) {</span>
                <span class="s1">space();</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(/comment[</span><span class="s4">134</span><span class="s1">]/.test(c.type)) {</span>
                <span class="s1">print(</span><span class="s2">&quot;//&quot; </span><span class="s1">+ c.value.replace(/[@#]__PURE__/g, </span><span class="s2">' '</span><span class="s1">));</span>
                <span class="s1">need_newline_indented = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(c.type == </span><span class="s2">&quot;comment2&quot;</span><span class="s1">) {</span>
                <span class="s1">print(</span><span class="s2">&quot;/*&quot; </span><span class="s1">+ c.value.replace(/[@#]__PURE__/g, </span><span class="s2">' '</span><span class="s1">) + </span><span class="s2">&quot;*/&quot;</span><span class="s1">);</span>
                <span class="s1">need_space = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
        <span class="s3">if </span><span class="s1">(OUTPUT.length &gt; insert) newline_insert = insert;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">stack = [];</span>
    <span class="s3">return </span><span class="s1">{</span>
        <span class="s1">get             : get,</span>
        <span class="s1">toString        : get,</span>
        <span class="s1">indent          : indent,</span>
        <span class="s1">indentation     : </span><span class="s3">function</span><span class="s1">() { </span><span class="s3">return </span><span class="s1">indentation },</span>
        <span class="s1">current_width   : </span><span class="s3">function</span><span class="s1">() { </span><span class="s3">return </span><span class="s1">current_col - indentation },</span>
        <span class="s1">should_break    : </span><span class="s3">function</span><span class="s1">() { </span><span class="s3">return </span><span class="s1">options.width &amp;&amp; </span><span class="s3">this</span><span class="s1">.current_width() &gt;= options.width },</span>
        <span class="s1">newline         : newline,</span>
        <span class="s1">print           : print,</span>
        <span class="s1">star            : star,</span>
        <span class="s1">space           : space,</span>
        <span class="s1">comma           : comma,</span>
        <span class="s1">colon           : colon,</span>
        <span class="s1">last            : </span><span class="s3">function</span><span class="s1">() { </span><span class="s3">return </span><span class="s1">last },</span>
        <span class="s1">semicolon       : semicolon,</span>
        <span class="s1">force_semicolon : force_semicolon,</span>
        <span class="s1">to_utf8         : to_utf8,</span>
        <span class="s1">print_name      : </span><span class="s3">function</span><span class="s1">(name) { print(make_name(name)) },</span>
        <span class="s1">print_string    : </span><span class="s3">function</span><span class="s1">(str, quote, escape_directive) {</span>
            <span class="s3">var </span><span class="s1">encoded = encode_string(str, quote);</span>
            <span class="s3">if </span><span class="s1">(escape_directive === </span><span class="s3">true </span><span class="s1">&amp;&amp; encoded.indexOf(</span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">&quot;</span><span class="s1">) === -</span><span class="s4">1</span><span class="s1">) {</span>
                <span class="s0">// Insert semicolons to break directive prologue</span>
                <span class="s3">if </span><span class="s1">(!EXPECT_DIRECTIVE.test(OUTPUT)) {</span>
                    <span class="s1">force_semicolon();</span>
                <span class="s1">}</span>
                <span class="s1">force_semicolon();</span>
            <span class="s1">}</span>
            <span class="s1">print(encoded);</span>
        <span class="s1">},</span>
        <span class="s1">print_template_string_chars: </span><span class="s3">function</span><span class="s1">(str) {</span>
            <span class="s3">var </span><span class="s1">encoded = encode_string(str, </span><span class="s2">'`'</span><span class="s1">).replace(/\${/g, </span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">${&quot;</span><span class="s1">);</span>
            <span class="s3">return </span><span class="s1">print(encoded.substr(</span><span class="s4">1</span><span class="s1">, encoded.length - </span><span class="s4">2</span><span class="s1">));</span>
        <span class="s1">},</span>
        <span class="s1">encode_string   : encode_string,</span>
        <span class="s1">next_indent     : next_indent,</span>
        <span class="s1">with_indent     : with_indent,</span>
        <span class="s1">with_block      : with_block,</span>
        <span class="s1">with_parens     : with_parens,</span>
        <span class="s1">with_square     : with_square,</span>
        <span class="s1">add_mapping     : add_mapping,</span>
        <span class="s1">option          : </span><span class="s3">function</span><span class="s1">(opt) { </span><span class="s3">return </span><span class="s1">options[opt] },</span>
        <span class="s1">prepend_comments: readonly ? noop : prepend_comments,</span>
        <span class="s1">append_comments : readonly || comment_filter === return_false ? noop : append_comments,</span>
        <span class="s1">line            : </span><span class="s3">function</span><span class="s1">() { </span><span class="s3">return </span><span class="s1">current_line },</span>
        <span class="s1">col             : </span><span class="s3">function</span><span class="s1">() { </span><span class="s3">return </span><span class="s1">current_col },</span>
        <span class="s1">pos             : </span><span class="s3">function</span><span class="s1">() { </span><span class="s3">return </span><span class="s1">current_pos },</span>
        <span class="s1">push_node       : </span><span class="s3">function</span><span class="s1">(node) { stack.push(node) },</span>
        <span class="s1">pop_node        : </span><span class="s3">function</span><span class="s1">() { </span><span class="s3">return </span><span class="s1">stack.pop() },</span>
        <span class="s1">parent          : </span><span class="s3">function</span><span class="s1">(n) {</span>
            <span class="s3">return </span><span class="s1">stack[stack.length - </span><span class="s4">2 </span><span class="s1">- (n || </span><span class="s4">0</span><span class="s1">)];</span>
        <span class="s1">}</span>
    <span class="s1">};</span>

<span class="s1">};</span>

<span class="s0">/* -----[ code generators ]----- */</span>

<span class="s1">(</span><span class="s3">function</span><span class="s1">(){</span>

    <span class="s0">/* -----[ utils ]----- */</span>

    <span class="s3">function </span><span class="s1">DEFPRINT(nodetype, generator) {</span>
        <span class="s1">nodetype.DEFMETHOD(</span><span class="s2">&quot;_codegen&quot;</span><span class="s1">, generator);</span>
    <span class="s1">};</span>

    <span class="s3">var </span><span class="s1">in_directive = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">active_scope = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">use_asm = </span><span class="s3">null</span><span class="s1">;</span>

    <span class="s1">AST_Node.DEFMETHOD(</span><span class="s2">&quot;print&quot;</span><span class="s1">, </span><span class="s3">function</span><span class="s1">(stream, force_parens){</span>
        <span class="s3">var </span><span class="s1">self = </span><span class="s3">this</span><span class="s1">, generator = self._codegen;</span>
        <span class="s3">if </span><span class="s1">(self </span><span class="s3">instanceof </span><span class="s1">AST_Scope) {</span>
            <span class="s1">active_scope = self;</span>
        <span class="s1">}</span>
        <span class="s3">else if </span><span class="s1">(!use_asm &amp;&amp; self </span><span class="s3">instanceof </span><span class="s1">AST_Directive &amp;&amp; self.value == </span><span class="s2">&quot;use asm&quot;</span><span class="s1">) {</span>
            <span class="s1">use_asm = active_scope;</span>
        <span class="s1">}</span>
        <span class="s3">function </span><span class="s1">doit() {</span>
            <span class="s1">stream.prepend_comments(self);</span>
            <span class="s1">self.add_source_map(stream);</span>
            <span class="s1">generator(self, stream);</span>
            <span class="s1">stream.append_comments(self);</span>
        <span class="s1">}</span>
        <span class="s1">stream.push_node(self);</span>
        <span class="s3">if </span><span class="s1">(force_parens || self.needs_parens(stream)) {</span>
            <span class="s1">stream.with_parens(doit);</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">doit();</span>
        <span class="s1">}</span>
        <span class="s1">stream.pop_node();</span>
        <span class="s3">if </span><span class="s1">(self === use_asm) {</span>
            <span class="s1">use_asm = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s1">AST_Node.DEFMETHOD(</span><span class="s2">&quot;_print&quot;</span><span class="s1">, AST_Node.prototype.print);</span>

    <span class="s1">AST_Node.DEFMETHOD(</span><span class="s2">&quot;print_to_string&quot;</span><span class="s1">, </span><span class="s3">function</span><span class="s1">(options){</span>
        <span class="s3">var </span><span class="s1">s = OutputStream(options);</span>
        <span class="s3">this</span><span class="s1">.print(s);</span>
        <span class="s3">return </span><span class="s1">s.get();</span>
    <span class="s1">});</span>

    <span class="s0">/* -----[ PARENTHESES ]----- */</span>

    <span class="s3">function </span><span class="s1">PARENS(nodetype, func) {</span>
        <span class="s3">if </span><span class="s1">(Array.isArray(nodetype)) {</span>
            <span class="s1">nodetype.forEach(</span><span class="s3">function</span><span class="s1">(nodetype){</span>
                <span class="s1">PARENS(nodetype, func);</span>
            <span class="s1">});</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">nodetype.DEFMETHOD(</span><span class="s2">&quot;needs_parens&quot;</span><span class="s1">, func);</span>
        <span class="s1">}</span>
    <span class="s1">};</span>

    <span class="s1">PARENS(AST_Node, return_false);</span>

    <span class="s0">// a function expression needs parens around it when it's provably</span>
    <span class="s0">// the first token to appear in a statement.</span>
    <span class="s1">PARENS(AST_Function, </span><span class="s3">function</span><span class="s1">(output){</span>
        <span class="s3">if </span><span class="s1">(first_in_statement(output)) {</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(output.option(</span><span class="s2">'webkit'</span><span class="s1">)) {</span>
            <span class="s3">var </span><span class="s1">p = output.parent();</span>
            <span class="s3">if </span><span class="s1">(p </span><span class="s3">instanceof </span><span class="s1">AST_PropAccess &amp;&amp; p.expression === </span><span class="s3">this</span><span class="s1">) {</span>
                <span class="s3">return true</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(output.option(</span><span class="s2">'wrap_iife'</span><span class="s1">)) {</span>
            <span class="s3">var </span><span class="s1">p = output.parent();</span>
            <span class="s3">return </span><span class="s1">p </span><span class="s3">instanceof </span><span class="s1">AST_Call &amp;&amp; p.expression === </span><span class="s3">this</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">});</span>

    <span class="s1">PARENS(AST_Arrow, </span><span class="s3">function</span><span class="s1">(output){</span>
        <span class="s3">var </span><span class="s1">p = output.parent();</span>
        <span class="s3">return </span><span class="s1">p </span><span class="s3">instanceof </span><span class="s1">AST_PropAccess &amp;&amp; p.expression === </span><span class="s3">this</span><span class="s1">;</span>
    <span class="s1">});</span>

    <span class="s0">// same goes for an object literal, because otherwise it would be</span>
    <span class="s0">// interpreted as a block of code.</span>
    <span class="s1">PARENS([ AST_ClassExpression, AST_Object ], first_in_statement);</span>

    <span class="s1">PARENS(AST_Unary, </span><span class="s3">function</span><span class="s1">(output){</span>
        <span class="s3">var </span><span class="s1">p = output.parent();</span>
        <span class="s3">return </span><span class="s1">p </span><span class="s3">instanceof </span><span class="s1">AST_PropAccess &amp;&amp; p.expression === </span><span class="s3">this</span>
            <span class="s1">|| p </span><span class="s3">instanceof </span><span class="s1">AST_Call &amp;&amp; p.expression === </span><span class="s3">this</span>
            <span class="s1">|| p </span><span class="s3">instanceof </span><span class="s1">AST_Binary</span>
                <span class="s1">&amp;&amp; p.operator === </span><span class="s2">&quot;**&quot;</span>
                <span class="s1">&amp;&amp; </span><span class="s3">this instanceof </span><span class="s1">AST_UnaryPrefix</span>
                <span class="s1">&amp;&amp; p.left === </span><span class="s3">this</span>
                <span class="s1">&amp;&amp; </span><span class="s3">this</span><span class="s1">.operator !== </span><span class="s2">&quot;++&quot;</span>
                <span class="s1">&amp;&amp; </span><span class="s3">this</span><span class="s1">.operator !== </span><span class="s2">&quot;--&quot;</span><span class="s1">;</span>
    <span class="s1">});</span>

    <span class="s1">PARENS(AST_Await, </span><span class="s3">function</span><span class="s1">(output){</span>
        <span class="s3">var </span><span class="s1">p = output.parent();</span>
        <span class="s3">return </span><span class="s1">p </span><span class="s3">instanceof </span><span class="s1">AST_PropAccess &amp;&amp; p.expression === </span><span class="s3">this</span>
            <span class="s1">|| p </span><span class="s3">instanceof </span><span class="s1">AST_Call &amp;&amp; p.expression === </span><span class="s3">this</span>
            <span class="s1">|| output.option(</span><span class="s2">&quot;safari10&quot;</span><span class="s1">) &amp;&amp; p </span><span class="s3">instanceof </span><span class="s1">AST_UnaryPrefix;</span>
    <span class="s1">});</span>

    <span class="s1">PARENS(AST_Sequence, </span><span class="s3">function</span><span class="s1">(output){</span>
        <span class="s3">var </span><span class="s1">p = output.parent();</span>
        <span class="s3">return </span><span class="s1">p </span><span class="s3">instanceof </span><span class="s1">AST_Call                          </span><span class="s0">// (foo, bar)() or foo(1, (2, 3), 4)</span>
            <span class="s1">|| p </span><span class="s3">instanceof </span><span class="s1">AST_Unary                         </span><span class="s0">// !(foo, bar, baz)</span>
            <span class="s1">|| p </span><span class="s3">instanceof </span><span class="s1">AST_Binary                        </span><span class="s0">// 1 + (2, 3) + 4 ==&gt; 8</span>
            <span class="s1">|| p </span><span class="s3">instanceof </span><span class="s1">AST_VarDef                        </span><span class="s0">// var a = (1, 2), b = a + a; ==&gt; b == 4</span>
            <span class="s1">|| p </span><span class="s3">instanceof </span><span class="s1">AST_PropAccess                    </span><span class="s0">// (1, {foo:2}).foo or (1, {foo:2})[&quot;foo&quot;] ==&gt; 2</span>
            <span class="s1">|| p </span><span class="s3">instanceof </span><span class="s1">AST_Array                         </span><span class="s0">// [ 1, (2, 3), 4 ] ==&gt; [ 1, 3, 4 ]</span>
            <span class="s1">|| p </span><span class="s3">instanceof </span><span class="s1">AST_ObjectProperty                </span><span class="s0">// { foo: (1, 2) }.foo ==&gt; 2</span>
            <span class="s1">|| p </span><span class="s3">instanceof </span><span class="s1">AST_Conditional                   </span><span class="s0">/* (false, true) ? (a = 10, b = 20) : (c = 30) 
                                                               * ==&gt; 20 (side effect, set a := 10 and b := 20) */</span>
            <span class="s1">|| p </span><span class="s3">instanceof </span><span class="s1">AST_Arrow                         </span><span class="s0">// x =&gt; (x, x)</span>
            <span class="s1">|| p </span><span class="s3">instanceof </span><span class="s1">AST_DefaultAssign                 </span><span class="s0">// x =&gt; (x = (0, function(){}))</span>
            <span class="s1">|| p </span><span class="s3">instanceof </span><span class="s1">AST_Expansion                     </span><span class="s0">// [...(a, b)]</span>
            <span class="s1">|| p </span><span class="s3">instanceof </span><span class="s1">AST_ForOf &amp;&amp; </span><span class="s3">this </span><span class="s1">=== p.object    </span><span class="s0">// for (e of (foo, bar)) {}</span>
            <span class="s1">|| p </span><span class="s3">instanceof </span><span class="s1">AST_Yield                         </span><span class="s0">// yield (foo, bar)</span>
        <span class="s1">;</span>
    <span class="s1">});</span>

    <span class="s1">PARENS(AST_Binary, </span><span class="s3">function</span><span class="s1">(output){</span>
        <span class="s3">var </span><span class="s1">p = output.parent();</span>
        <span class="s0">// (foo &amp;&amp; bar)()</span>
        <span class="s3">if </span><span class="s1">(p </span><span class="s3">instanceof </span><span class="s1">AST_Call &amp;&amp; p.expression === </span><span class="s3">this</span><span class="s1">)</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s0">// typeof (foo &amp;&amp; bar)</span>
        <span class="s3">if </span><span class="s1">(p </span><span class="s3">instanceof </span><span class="s1">AST_Unary)</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s0">// (foo &amp;&amp; bar)[&quot;prop&quot;], (foo &amp;&amp; bar).prop</span>
        <span class="s3">if </span><span class="s1">(p </span><span class="s3">instanceof </span><span class="s1">AST_PropAccess &amp;&amp; p.expression === </span><span class="s3">this</span><span class="s1">)</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s0">// this deals with precedence: 3 * (2 + 1)</span>
        <span class="s3">if </span><span class="s1">(p </span><span class="s3">instanceof </span><span class="s1">AST_Binary) {</span>
            <span class="s3">var </span><span class="s1">po = p.operator, pp = PRECEDENCE[po];</span>
            <span class="s3">var </span><span class="s1">so = </span><span class="s3">this</span><span class="s1">.operator, sp = PRECEDENCE[so];</span>
            <span class="s3">if </span><span class="s1">(pp &gt; sp</span>
                <span class="s1">|| (pp == sp</span>
                    <span class="s1">&amp;&amp; </span><span class="s3">this </span><span class="s1">=== p.right)) {</span>
                <span class="s3">return true</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">});</span>

    <span class="s1">PARENS(AST_Yield, </span><span class="s3">function</span><span class="s1">(output){</span>
        <span class="s3">var </span><span class="s1">p = output.parent();</span>
        <span class="s0">// (yield 1) + (yield 2)</span>
        <span class="s0">// a = yield 3</span>
        <span class="s3">if </span><span class="s1">(p </span><span class="s3">instanceof </span><span class="s1">AST_Binary &amp;&amp; p.operator !== </span><span class="s2">&quot;=&quot;</span><span class="s1">)</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s0">// (yield 1)()</span>
        <span class="s0">// new (yield 1)()</span>
        <span class="s3">if </span><span class="s1">(p </span><span class="s3">instanceof </span><span class="s1">AST_Call &amp;&amp; p.expression === </span><span class="s3">this</span><span class="s1">)</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s0">// (yield 1) ? yield 2 : yield 3</span>
        <span class="s3">if </span><span class="s1">(p </span><span class="s3">instanceof </span><span class="s1">AST_Conditional &amp;&amp; p.condition === </span><span class="s3">this</span><span class="s1">)</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s0">// -(yield 4)</span>
        <span class="s3">if </span><span class="s1">(p </span><span class="s3">instanceof </span><span class="s1">AST_Unary)</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s0">// (yield x).foo</span>
        <span class="s0">// (yield x)['foo']</span>
        <span class="s3">if </span><span class="s1">(p </span><span class="s3">instanceof </span><span class="s1">AST_PropAccess &amp;&amp; p.expression === </span><span class="s3">this</span><span class="s1">)</span>
            <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">});</span>

    <span class="s1">PARENS(AST_PropAccess, </span><span class="s3">function</span><span class="s1">(output){</span>
        <span class="s3">var </span><span class="s1">p = output.parent();</span>
        <span class="s3">if </span><span class="s1">(p </span><span class="s3">instanceof </span><span class="s1">AST_New &amp;&amp; p.expression === </span><span class="s3">this</span><span class="s1">) {</span>
            <span class="s0">// i.e. new (foo.bar().baz)</span>
            <span class="s0">//</span>
            <span class="s0">// if there's one call into this subtree, then we need</span>
            <span class="s0">// parens around it too, otherwise the call will be</span>
            <span class="s0">// interpreted as passing the arguments to the upper New</span>
            <span class="s0">// expression.</span>
            <span class="s3">var </span><span class="s1">parens = </span><span class="s3">false</span><span class="s1">;</span>
            <span class="s3">this</span><span class="s1">.walk(</span><span class="s3">new </span><span class="s1">TreeWalker(</span><span class="s3">function</span><span class="s1">(node) {</span>
                <span class="s3">if </span><span class="s1">(parens || node </span><span class="s3">instanceof </span><span class="s1">AST_Scope) </span><span class="s3">return true</span><span class="s1">;</span>
                <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Call) {</span>
                    <span class="s1">parens = </span><span class="s3">true</span><span class="s1">;</span>
                    <span class="s3">return true</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}));</span>
            <span class="s3">return </span><span class="s1">parens;</span>
        <span class="s1">}</span>
    <span class="s1">});</span>

    <span class="s1">PARENS(AST_Call, </span><span class="s3">function</span><span class="s1">(output){</span>
        <span class="s3">var </span><span class="s1">p = output.parent(), p1;</span>
        <span class="s3">if </span><span class="s1">(p </span><span class="s3">instanceof </span><span class="s1">AST_New &amp;&amp; p.expression === </span><span class="s3">this</span><span class="s1">)</span>
            <span class="s3">return true</span><span class="s1">;</span>

        <span class="s0">// workaround for Safari bug.</span>
        <span class="s0">// https://bugs.webkit.org/show_bug.cgi?id=123506</span>
        <span class="s3">return this</span><span class="s1">.expression </span><span class="s3">instanceof </span><span class="s1">AST_Function</span>
            <span class="s1">&amp;&amp; p </span><span class="s3">instanceof </span><span class="s1">AST_PropAccess</span>
            <span class="s1">&amp;&amp; p.expression === </span><span class="s3">this</span>
            <span class="s1">&amp;&amp; (p1 = output.parent(</span><span class="s4">1</span><span class="s1">)) </span><span class="s3">instanceof </span><span class="s1">AST_Assign</span>
            <span class="s1">&amp;&amp; p1.left === p;</span>
    <span class="s1">});</span>

    <span class="s1">PARENS(AST_New, </span><span class="s3">function</span><span class="s1">(output){</span>
        <span class="s3">var </span><span class="s1">p = output.parent();</span>
        <span class="s3">if </span><span class="s1">(!need_constructor_parens(</span><span class="s3">this</span><span class="s1">, output)</span>
            <span class="s1">&amp;&amp; (p </span><span class="s3">instanceof </span><span class="s1">AST_PropAccess </span><span class="s0">// (new Date).getTime(), (new Date)[&quot;getTime&quot;]()</span>
                <span class="s1">|| p </span><span class="s3">instanceof </span><span class="s1">AST_Call &amp;&amp; p.expression === </span><span class="s3">this</span><span class="s1">)) </span><span class="s0">// (new foo)(bar)</span>
            <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">});</span>

    <span class="s1">PARENS(AST_Number, </span><span class="s3">function</span><span class="s1">(output){</span>
        <span class="s3">var </span><span class="s1">p = output.parent();</span>
        <span class="s3">if </span><span class="s1">(p </span><span class="s3">instanceof </span><span class="s1">AST_PropAccess &amp;&amp; p.expression === </span><span class="s3">this</span><span class="s1">) {</span>
            <span class="s3">var </span><span class="s1">value = </span><span class="s3">this</span><span class="s1">.getValue();</span>
            <span class="s3">if </span><span class="s1">(value &lt; </span><span class="s4">0 </span><span class="s1">|| /^</span><span class="s4">0</span><span class="s1">/.test(make_num(value))) {</span>
                <span class="s3">return true</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">});</span>

    <span class="s1">PARENS([ AST_Assign, AST_Conditional ], </span><span class="s3">function</span><span class="s1">(output){</span>
        <span class="s3">var </span><span class="s1">p = output.parent();</span>
        <span class="s0">// !(a = false) → true</span>
        <span class="s3">if </span><span class="s1">(p </span><span class="s3">instanceof </span><span class="s1">AST_Unary)</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s0">// 1 + (a = 2) + 3 → 6, side effect setting a = 2</span>
        <span class="s3">if </span><span class="s1">(p </span><span class="s3">instanceof </span><span class="s1">AST_Binary &amp;&amp; !(p </span><span class="s3">instanceof </span><span class="s1">AST_Assign))</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s0">// (a = func)() —or— new (a = Object)()</span>
        <span class="s3">if </span><span class="s1">(p </span><span class="s3">instanceof </span><span class="s1">AST_Call &amp;&amp; p.expression === </span><span class="s3">this</span><span class="s1">)</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s0">// (a = foo) ? bar : baz</span>
        <span class="s3">if </span><span class="s1">(p </span><span class="s3">instanceof </span><span class="s1">AST_Conditional &amp;&amp; p.condition === </span><span class="s3">this</span><span class="s1">)</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s0">// (a = foo)[&quot;prop&quot;] —or— (a = foo).prop</span>
        <span class="s3">if </span><span class="s1">(p </span><span class="s3">instanceof </span><span class="s1">AST_PropAccess &amp;&amp; p.expression === </span><span class="s3">this</span><span class="s1">)</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s0">// ({a, b} = {a: 1, b: 2}), a destructuring assignment</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">this instanceof </span><span class="s1">AST_Assign &amp;&amp; </span><span class="s3">this</span><span class="s1">.left </span><span class="s3">instanceof </span><span class="s1">AST_Destructuring &amp;&amp; </span><span class="s3">this</span><span class="s1">.left.is_array === </span><span class="s3">false</span><span class="s1">)</span>
            <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">});</span>

    <span class="s0">/* -----[ PRINTERS ]----- */</span>

    <span class="s1">DEFPRINT(AST_Directive, </span><span class="s3">function</span><span class="s1">(self, output){</span>
        <span class="s1">output.print_string(self.value, self.quote);</span>
        <span class="s1">output.semicolon();</span>
    <span class="s1">});</span>

    <span class="s1">DEFPRINT(AST_Expansion, </span><span class="s3">function </span><span class="s1">(self, output) {</span>
        <span class="s1">output.print(</span><span class="s2">'...'</span><span class="s1">);</span>
        <span class="s1">self.expression.print(output);</span>
    <span class="s1">});</span>

    <span class="s1">DEFPRINT(AST_Destructuring, </span><span class="s3">function </span><span class="s1">(self, output) {</span>
        <span class="s1">output.print(self.is_array ? </span><span class="s2">&quot;[&quot; </span><span class="s1">: </span><span class="s2">&quot;{&quot;</span><span class="s1">);</span>
        <span class="s3">var </span><span class="s1">len = self.names.length;</span>
        <span class="s1">self.names.forEach(</span><span class="s3">function </span><span class="s1">(name, i) {</span>
            <span class="s3">if </span><span class="s1">(i &gt; </span><span class="s4">0</span><span class="s1">) output.comma();</span>
            <span class="s1">name.print(output);</span>
            <span class="s0">// If the final element is a hole, we need to make sure it</span>
            <span class="s0">// doesn't look like a trailing comma, by inserting an actual</span>
            <span class="s0">// trailing comma.</span>
            <span class="s3">if </span><span class="s1">(i == len - </span><span class="s4">1 </span><span class="s1">&amp;&amp; name </span><span class="s3">instanceof </span><span class="s1">AST_Hole) output.comma();</span>
        <span class="s1">});</span>
        <span class="s1">output.print(self.is_array ? </span><span class="s2">&quot;]&quot; </span><span class="s1">: </span><span class="s2">&quot;}&quot;</span><span class="s1">);</span>
    <span class="s1">});</span>

    <span class="s1">DEFPRINT(AST_Debugger, </span><span class="s3">function</span><span class="s1">(self, output){</span>
        <span class="s1">output.print(</span><span class="s2">&quot;debugger&quot;</span><span class="s1">);</span>
        <span class="s1">output.semicolon();</span>
    <span class="s1">});</span>

    <span class="s0">/* -----[ statements ]----- */</span>

    <span class="s3">function </span><span class="s1">display_body(body, is_toplevel, output, allow_directives) {</span>
        <span class="s3">var </span><span class="s1">last = body.length - </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s1">in_directive = allow_directives;</span>
        <span class="s1">body.forEach(</span><span class="s3">function</span><span class="s1">(stmt, i){</span>
            <span class="s3">if </span><span class="s1">(in_directive === </span><span class="s3">true </span><span class="s1">&amp;&amp; !(stmt </span><span class="s3">instanceof </span><span class="s1">AST_Directive ||</span>
                <span class="s1">stmt </span><span class="s3">instanceof </span><span class="s1">AST_EmptyStatement ||</span>
                <span class="s1">(stmt </span><span class="s3">instanceof </span><span class="s1">AST_SimpleStatement &amp;&amp; stmt.body </span><span class="s3">instanceof </span><span class="s1">AST_String)</span>
            <span class="s1">)) {</span>
                <span class="s1">in_directive = </span><span class="s3">false</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(!(stmt </span><span class="s3">instanceof </span><span class="s1">AST_EmptyStatement)) {</span>
                <span class="s1">output.indent();</span>
                <span class="s1">stmt.print(output);</span>
                <span class="s3">if </span><span class="s1">(!(i == last &amp;&amp; is_toplevel)) {</span>
                    <span class="s1">output.newline();</span>
                    <span class="s3">if </span><span class="s1">(is_toplevel) output.newline();</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(in_directive === </span><span class="s3">true </span><span class="s1">&amp;&amp;</span>
                <span class="s1">stmt </span><span class="s3">instanceof </span><span class="s1">AST_SimpleStatement &amp;&amp;</span>
                <span class="s1">stmt.body </span><span class="s3">instanceof </span><span class="s1">AST_String</span>
            <span class="s1">) {</span>
                <span class="s1">in_directive = </span><span class="s3">false</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
        <span class="s1">in_directive = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">};</span>

    <span class="s1">AST_StatementWithBody.DEFMETHOD(</span><span class="s2">&quot;_do_print_body&quot;</span><span class="s1">, </span><span class="s3">function</span><span class="s1">(output){</span>
        <span class="s1">force_statement(</span><span class="s3">this</span><span class="s1">.body, output);</span>
    <span class="s1">});</span>

    <span class="s1">DEFPRINT(AST_Statement, </span><span class="s3">function</span><span class="s1">(self, output){</span>
        <span class="s1">self.body.print(output);</span>
        <span class="s1">output.semicolon();</span>
    <span class="s1">});</span>
    <span class="s1">DEFPRINT(AST_Toplevel, </span><span class="s3">function</span><span class="s1">(self, output){</span>
        <span class="s1">display_body(self.body, </span><span class="s3">true</span><span class="s1">, output, </span><span class="s3">true</span><span class="s1">);</span>
        <span class="s1">output.print(</span><span class="s2">&quot;&quot;</span><span class="s1">);</span>
    <span class="s1">});</span>
    <span class="s1">DEFPRINT(AST_LabeledStatement, </span><span class="s3">function</span><span class="s1">(self, output){</span>
        <span class="s1">self.label.print(output);</span>
        <span class="s1">output.colon();</span>
        <span class="s1">self.body.print(output);</span>
    <span class="s1">});</span>
    <span class="s1">DEFPRINT(AST_SimpleStatement, </span><span class="s3">function</span><span class="s1">(self, output){</span>
        <span class="s1">self.body.print(output);</span>
        <span class="s1">output.semicolon();</span>
    <span class="s1">});</span>
    <span class="s3">function </span><span class="s1">print_bracketed(self, output, allow_directives) {</span>
        <span class="s3">if </span><span class="s1">(self.body.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s1">output.with_block(</span><span class="s3">function</span><span class="s1">() {</span>
                <span class="s1">display_body(self.body, </span><span class="s3">false</span><span class="s1">, output, allow_directives);</span>
            <span class="s1">});</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">output.print(</span><span class="s2">&quot;{&quot;</span><span class="s1">);</span>
            <span class="s1">output.with_indent(output.next_indent(), </span><span class="s3">function</span><span class="s1">() {</span>
                <span class="s1">output.append_comments(self, </span><span class="s3">true</span><span class="s1">);</span>
            <span class="s1">});</span>
            <span class="s1">output.print(</span><span class="s2">&quot;}&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">};</span>
    <span class="s1">DEFPRINT(AST_BlockStatement, </span><span class="s3">function</span><span class="s1">(self, output){</span>
        <span class="s1">print_bracketed(self, output);</span>
    <span class="s1">});</span>
    <span class="s1">DEFPRINT(AST_EmptyStatement, </span><span class="s3">function</span><span class="s1">(self, output){</span>
        <span class="s1">output.semicolon();</span>
    <span class="s1">});</span>
    <span class="s1">DEFPRINT(AST_Do, </span><span class="s3">function</span><span class="s1">(self, output){</span>
        <span class="s1">output.print(</span><span class="s2">&quot;do&quot;</span><span class="s1">);</span>
        <span class="s1">output.space();</span>
        <span class="s1">make_block(self.body, output);</span>
        <span class="s1">output.space();</span>
        <span class="s1">output.print(</span><span class="s2">&quot;while&quot;</span><span class="s1">);</span>
        <span class="s1">output.space();</span>
        <span class="s1">output.with_parens(</span><span class="s3">function</span><span class="s1">(){</span>
            <span class="s1">self.condition.print(output);</span>
        <span class="s1">});</span>
        <span class="s1">output.semicolon();</span>
    <span class="s1">});</span>
    <span class="s1">DEFPRINT(AST_While, </span><span class="s3">function</span><span class="s1">(self, output){</span>
        <span class="s1">output.print(</span><span class="s2">&quot;while&quot;</span><span class="s1">);</span>
        <span class="s1">output.space();</span>
        <span class="s1">output.with_parens(</span><span class="s3">function</span><span class="s1">(){</span>
            <span class="s1">self.condition.print(output);</span>
        <span class="s1">});</span>
        <span class="s1">output.space();</span>
        <span class="s1">self._do_print_body(output);</span>
    <span class="s1">});</span>
    <span class="s1">DEFPRINT(AST_For, </span><span class="s3">function</span><span class="s1">(self, output){</span>
        <span class="s1">output.print(</span><span class="s2">&quot;for&quot;</span><span class="s1">);</span>
        <span class="s1">output.space();</span>
        <span class="s1">output.with_parens(</span><span class="s3">function</span><span class="s1">(){</span>
            <span class="s3">if </span><span class="s1">(self.init) {</span>
                <span class="s3">if </span><span class="s1">(self.init </span><span class="s3">instanceof </span><span class="s1">AST_Definitions) {</span>
                    <span class="s1">self.init.print(output);</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s1">parenthesize_for_noin(self.init, output, </span><span class="s3">true</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s1">output.print(</span><span class="s2">&quot;;&quot;</span><span class="s1">);</span>
                <span class="s1">output.space();</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s1">output.print(</span><span class="s2">&quot;;&quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(self.condition) {</span>
                <span class="s1">self.condition.print(output);</span>
                <span class="s1">output.print(</span><span class="s2">&quot;;&quot;</span><span class="s1">);</span>
                <span class="s1">output.space();</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s1">output.print(</span><span class="s2">&quot;;&quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(self.step) {</span>
                <span class="s1">self.step.print(output);</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
        <span class="s1">output.space();</span>
        <span class="s1">self._do_print_body(output);</span>
    <span class="s1">});</span>
    <span class="s1">DEFPRINT(AST_ForIn, </span><span class="s3">function</span><span class="s1">(self, output){</span>
        <span class="s1">output.print(</span><span class="s2">&quot;for&quot;</span><span class="s1">);</span>
        <span class="s1">output.space();</span>
        <span class="s1">output.with_parens(</span><span class="s3">function</span><span class="s1">(){</span>
            <span class="s1">self.init.print(output);</span>
            <span class="s1">output.space();</span>
            <span class="s1">output.print(self </span><span class="s3">instanceof </span><span class="s1">AST_ForOf ? </span><span class="s2">&quot;of&quot; </span><span class="s1">: </span><span class="s2">&quot;in&quot;</span><span class="s1">);</span>
            <span class="s1">output.space();</span>
            <span class="s1">self.object.print(output);</span>
        <span class="s1">});</span>
        <span class="s1">output.space();</span>
        <span class="s1">self._do_print_body(output);</span>
    <span class="s1">});</span>
    <span class="s1">DEFPRINT(AST_With, </span><span class="s3">function</span><span class="s1">(self, output){</span>
        <span class="s1">output.print(</span><span class="s2">&quot;with&quot;</span><span class="s1">);</span>
        <span class="s1">output.space();</span>
        <span class="s1">output.with_parens(</span><span class="s3">function</span><span class="s1">(){</span>
            <span class="s1">self.expression.print(output);</span>
        <span class="s1">});</span>
        <span class="s1">output.space();</span>
        <span class="s1">self._do_print_body(output);</span>
    <span class="s1">});</span>

    <span class="s0">/* -----[ functions ]----- */</span>
    <span class="s1">AST_Lambda.DEFMETHOD(</span><span class="s2">&quot;_do_print&quot;</span><span class="s1">, </span><span class="s3">function</span><span class="s1">(output, nokeyword){</span>
        <span class="s3">var </span><span class="s1">self = </span><span class="s3">this</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s1">(!nokeyword) {</span>
            <span class="s3">if </span><span class="s1">(self.async) {</span>
                <span class="s1">output.print(</span><span class="s2">&quot;async&quot;</span><span class="s1">);</span>
                <span class="s1">output.space();</span>
            <span class="s1">}</span>
            <span class="s1">output.print(</span><span class="s2">&quot;function&quot;</span><span class="s1">);</span>
            <span class="s3">if </span><span class="s1">(self.is_generator) {</span>
                <span class="s1">output.star();</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(self.name) {</span>
                <span class="s1">output.space();</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(self.name </span><span class="s3">instanceof </span><span class="s1">AST_Symbol) {</span>
            <span class="s1">self.name.print(output);</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(nokeyword &amp;&amp; self.name </span><span class="s3">instanceof </span><span class="s1">AST_Node) {</span>
            <span class="s1">output.with_square(</span><span class="s3">function</span><span class="s1">() {</span>
                <span class="s1">self.name.print(output); </span><span class="s0">// Computed method name</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s1">output.with_parens(</span><span class="s3">function</span><span class="s1">(){</span>
            <span class="s1">self.argnames.forEach(</span><span class="s3">function</span><span class="s1">(arg, i){</span>
                <span class="s3">if </span><span class="s1">(i) output.comma();</span>
                <span class="s1">arg.print(output);</span>
            <span class="s1">});</span>
        <span class="s1">});</span>
        <span class="s1">output.space();</span>
        <span class="s1">print_bracketed(self, output, </span><span class="s3">true</span><span class="s1">);</span>
    <span class="s1">});</span>
    <span class="s1">DEFPRINT(AST_Lambda, </span><span class="s3">function</span><span class="s1">(self, output){</span>
        <span class="s1">self._do_print(output);</span>
    <span class="s1">});</span>

    <span class="s1">DEFPRINT(AST_PrefixedTemplateString, </span><span class="s3">function</span><span class="s1">(self, output) {</span>
        <span class="s1">self.prefix.print(output);</span>
        <span class="s1">self.template_string.print(output);</span>
    <span class="s1">});</span>
    <span class="s1">DEFPRINT(AST_TemplateString, </span><span class="s3">function</span><span class="s1">(self, output) {</span>
        <span class="s3">var </span><span class="s1">is_tagged = output.parent() </span><span class="s3">instanceof </span><span class="s1">AST_PrefixedTemplateString;</span>

        <span class="s1">output.print(</span><span class="s2">&quot;`&quot;</span><span class="s1">);</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; self.segments.length; i++) {</span>
            <span class="s3">if </span><span class="s1">(!(self.segments[i] </span><span class="s3">instanceof </span><span class="s1">AST_TemplateSegment)) {</span>
                <span class="s1">output.print(</span><span class="s2">&quot;${&quot;</span><span class="s1">);</span>
                <span class="s1">self.segments[i].print(output);</span>
                <span class="s1">output.print(</span><span class="s2">&quot;}&quot;</span><span class="s1">);</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(is_tagged) {</span>
                <span class="s1">output.print(self.segments[i].raw);</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s1">output.print_template_string_chars(self.segments[i].value);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">output.print(</span><span class="s2">&quot;`&quot;</span><span class="s1">);</span>
    <span class="s1">});</span>

    <span class="s1">AST_Arrow.DEFMETHOD(</span><span class="s2">&quot;_do_print&quot;</span><span class="s1">, </span><span class="s3">function</span><span class="s1">(output){</span>
        <span class="s3">var </span><span class="s1">self = </span><span class="s3">this</span><span class="s1">;</span>
        <span class="s3">var </span><span class="s1">parent = output.parent();</span>
        <span class="s3">var </span><span class="s1">needs_parens = parent </span><span class="s3">instanceof </span><span class="s1">AST_Binary ||</span>
            <span class="s1">parent </span><span class="s3">instanceof </span><span class="s1">AST_Unary ||</span>
            <span class="s1">(parent </span><span class="s3">instanceof </span><span class="s1">AST_Call &amp;&amp; self === parent.expression);</span>
        <span class="s3">if </span><span class="s1">(needs_parens) { output.print(</span><span class="s2">&quot;(&quot;</span><span class="s1">) }</span>
        <span class="s3">if </span><span class="s1">(self.async) {</span>
            <span class="s1">output.print(</span><span class="s2">&quot;async&quot;</span><span class="s1">);</span>
            <span class="s1">output.space();</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(self.argnames.length === </span><span class="s4">1 </span><span class="s1">&amp;&amp; self.argnames[</span><span class="s4">0</span><span class="s1">] </span><span class="s3">instanceof </span><span class="s1">AST_Symbol) {</span>
            <span class="s1">self.argnames[</span><span class="s4">0</span><span class="s1">].print(output);</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">output.with_parens(</span><span class="s3">function</span><span class="s1">(){</span>
                <span class="s1">self.argnames.forEach(</span><span class="s3">function</span><span class="s1">(arg, i){</span>
                    <span class="s3">if </span><span class="s1">(i) output.comma();</span>
                    <span class="s1">arg.print(output);</span>
                <span class="s1">});</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s1">output.space();</span>
        <span class="s1">output.print(</span><span class="s2">'=&gt;'</span><span class="s1">);</span>
        <span class="s1">output.space();</span>
        <span class="s3">if </span><span class="s1">(self.body </span><span class="s3">instanceof </span><span class="s1">AST_Node) {</span>
            <span class="s1">self.body.print(output);</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">print_bracketed(self, output);</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(needs_parens) { output.print(</span><span class="s2">&quot;)&quot;</span><span class="s1">) }</span>
    <span class="s1">});</span>

    <span class="s0">/* -----[ exits ]----- */</span>
    <span class="s1">AST_Exit.DEFMETHOD(</span><span class="s2">&quot;_do_print&quot;</span><span class="s1">, </span><span class="s3">function</span><span class="s1">(output, kind){</span>
        <span class="s1">output.print(kind);</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.value) {</span>
            <span class="s1">output.space();</span>
            <span class="s3">this</span><span class="s1">.value.print(output);</span>
        <span class="s1">}</span>
        <span class="s1">output.semicolon();</span>
    <span class="s1">});</span>
    <span class="s1">DEFPRINT(AST_Return, </span><span class="s3">function</span><span class="s1">(self, output){</span>
        <span class="s1">self._do_print(output, </span><span class="s2">&quot;return&quot;</span><span class="s1">);</span>
    <span class="s1">});</span>
    <span class="s1">DEFPRINT(AST_Throw, </span><span class="s3">function</span><span class="s1">(self, output){</span>
        <span class="s1">self._do_print(output, </span><span class="s2">&quot;throw&quot;</span><span class="s1">);</span>
    <span class="s1">});</span>

    <span class="s0">/* -----[ yield ]----- */</span>

    <span class="s1">DEFPRINT(AST_Yield, </span><span class="s3">function</span><span class="s1">(self, output){</span>
        <span class="s3">var </span><span class="s1">star = self.is_star ? </span><span class="s2">&quot;*&quot; </span><span class="s1">: </span><span class="s2">&quot;&quot;</span><span class="s1">;</span>
        <span class="s1">output.print(</span><span class="s2">&quot;yield&quot; </span><span class="s1">+ star);</span>
        <span class="s3">if </span><span class="s1">(self.expression) {</span>
            <span class="s1">output.space();</span>
            <span class="s1">self.expression.print(output);</span>
        <span class="s1">}</span>
    <span class="s1">});</span>

    <span class="s1">DEFPRINT(AST_Await, </span><span class="s3">function</span><span class="s1">(self, output){</span>
        <span class="s1">output.print(</span><span class="s2">&quot;await&quot;</span><span class="s1">);</span>
        <span class="s1">output.space();</span>
        <span class="s3">var </span><span class="s1">e = self.expression;</span>
        <span class="s3">var </span><span class="s1">parens = !(</span>
               <span class="s1">e </span><span class="s3">instanceof </span><span class="s1">AST_Call</span>
            <span class="s1">|| e </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef</span>
            <span class="s1">|| e </span><span class="s3">instanceof </span><span class="s1">AST_PropAccess</span>
            <span class="s1">|| e </span><span class="s3">instanceof </span><span class="s1">AST_Unary</span>
            <span class="s1">|| e </span><span class="s3">instanceof </span><span class="s1">AST_Constant</span>
        <span class="s1">);</span>
        <span class="s3">if </span><span class="s1">(parens) output.print(</span><span class="s2">&quot;(&quot;</span><span class="s1">);</span>
        <span class="s1">self.expression.print(output);</span>
        <span class="s3">if </span><span class="s1">(parens) output.print(</span><span class="s2">&quot;)&quot;</span><span class="s1">);</span>
    <span class="s1">});</span>

    <span class="s0">/* -----[ loop control ]----- */</span>
    <span class="s1">AST_LoopControl.DEFMETHOD(</span><span class="s2">&quot;_do_print&quot;</span><span class="s1">, </span><span class="s3">function</span><span class="s1">(output, kind){</span>
        <span class="s1">output.print(kind);</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.label) {</span>
            <span class="s1">output.space();</span>
            <span class="s3">this</span><span class="s1">.label.print(output);</span>
        <span class="s1">}</span>
        <span class="s1">output.semicolon();</span>
    <span class="s1">});</span>
    <span class="s1">DEFPRINT(AST_Break, </span><span class="s3">function</span><span class="s1">(self, output){</span>
        <span class="s1">self._do_print(output, </span><span class="s2">&quot;break&quot;</span><span class="s1">);</span>
    <span class="s1">});</span>
    <span class="s1">DEFPRINT(AST_Continue, </span><span class="s3">function</span><span class="s1">(self, output){</span>
        <span class="s1">self._do_print(output, </span><span class="s2">&quot;continue&quot;</span><span class="s1">);</span>
    <span class="s1">});</span>

    <span class="s0">/* -----[ if ]----- */</span>
    <span class="s3">function </span><span class="s1">make_then(self, output) {</span>
        <span class="s3">var </span><span class="s1">b = self.body;</span>
        <span class="s3">if </span><span class="s1">(output.option(</span><span class="s2">&quot;bracketize&quot;</span><span class="s1">)</span>
            <span class="s1">|| output.option(</span><span class="s2">&quot;ie8&quot;</span><span class="s1">) &amp;&amp; b </span><span class="s3">instanceof </span><span class="s1">AST_Do)</span>
            <span class="s3">return </span><span class="s1">make_block(b, output);</span>
        <span class="s0">// The squeezer replaces &quot;block&quot;-s that contain only a single</span>
        <span class="s0">// statement with the statement itself; technically, the AST</span>
        <span class="s0">// is correct, but this can create problems when we output an</span>
        <span class="s0">// IF having an ELSE clause where the THEN clause ends in an</span>
        <span class="s0">// IF *without* an ELSE block (then the outer ELSE would refer</span>
        <span class="s0">// to the inner IF).  This function checks for this case and</span>
        <span class="s0">// adds the block brackets if needed.</span>
        <span class="s3">if </span><span class="s1">(!b) </span><span class="s3">return </span><span class="s1">output.force_semicolon();</span>
        <span class="s3">while </span><span class="s1">(</span><span class="s3">true</span><span class="s1">) {</span>
            <span class="s3">if </span><span class="s1">(b </span><span class="s3">instanceof </span><span class="s1">AST_If) {</span>
                <span class="s3">if </span><span class="s1">(!b.alternative) {</span>
                    <span class="s1">make_block(self.body, output);</span>
                    <span class="s3">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s1">b = b.alternative;</span>
            <span class="s1">}</span>
            <span class="s3">else if </span><span class="s1">(b </span><span class="s3">instanceof </span><span class="s1">AST_StatementWithBody) {</span>
                <span class="s1">b = b.body;</span>
            <span class="s1">}</span>
            <span class="s3">else break</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">force_statement(self.body, output);</span>
    <span class="s1">};</span>
    <span class="s1">DEFPRINT(AST_If, </span><span class="s3">function</span><span class="s1">(self, output){</span>
        <span class="s1">output.print(</span><span class="s2">&quot;if&quot;</span><span class="s1">);</span>
        <span class="s1">output.space();</span>
        <span class="s1">output.with_parens(</span><span class="s3">function</span><span class="s1">(){</span>
            <span class="s1">self.condition.print(output);</span>
        <span class="s1">});</span>
        <span class="s1">output.space();</span>
        <span class="s3">if </span><span class="s1">(self.alternative) {</span>
            <span class="s1">make_then(self, output);</span>
            <span class="s1">output.space();</span>
            <span class="s1">output.print(</span><span class="s2">&quot;else&quot;</span><span class="s1">);</span>
            <span class="s1">output.space();</span>
            <span class="s3">if </span><span class="s1">(self.alternative </span><span class="s3">instanceof </span><span class="s1">AST_If)</span>
                <span class="s1">self.alternative.print(output);</span>
            <span class="s3">else</span>
                <span class="s1">force_statement(self.alternative, output);</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">self._do_print_body(output);</span>
        <span class="s1">}</span>
    <span class="s1">});</span>

    <span class="s0">/* -----[ switch ]----- */</span>
    <span class="s1">DEFPRINT(AST_Switch, </span><span class="s3">function</span><span class="s1">(self, output){</span>
        <span class="s1">output.print(</span><span class="s2">&quot;switch&quot;</span><span class="s1">);</span>
        <span class="s1">output.space();</span>
        <span class="s1">output.with_parens(</span><span class="s3">function</span><span class="s1">(){</span>
            <span class="s1">self.expression.print(output);</span>
        <span class="s1">});</span>
        <span class="s1">output.space();</span>
        <span class="s3">var </span><span class="s1">last = self.body.length - </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s1">(last &lt; </span><span class="s4">0</span><span class="s1">) output.print(</span><span class="s2">&quot;{}&quot;</span><span class="s1">);</span>
        <span class="s3">else </span><span class="s1">output.with_block(</span><span class="s3">function</span><span class="s1">(){</span>
            <span class="s1">self.body.forEach(</span><span class="s3">function</span><span class="s1">(branch, i){</span>
                <span class="s1">output.indent(</span><span class="s3">true</span><span class="s1">);</span>
                <span class="s1">branch.print(output);</span>
                <span class="s3">if </span><span class="s1">(i &lt; last &amp;&amp; branch.body.length &gt; </span><span class="s4">0</span><span class="s1">)</span>
                    <span class="s1">output.newline();</span>
            <span class="s1">});</span>
        <span class="s1">});</span>
    <span class="s1">});</span>
    <span class="s1">AST_SwitchBranch.DEFMETHOD(</span><span class="s2">&quot;_do_print_body&quot;</span><span class="s1">, </span><span class="s3">function</span><span class="s1">(output){</span>
        <span class="s1">output.newline();</span>
        <span class="s3">this</span><span class="s1">.body.forEach(</span><span class="s3">function</span><span class="s1">(stmt){</span>
            <span class="s1">output.indent();</span>
            <span class="s1">stmt.print(output);</span>
            <span class="s1">output.newline();</span>
        <span class="s1">});</span>
    <span class="s1">});</span>
    <span class="s1">DEFPRINT(AST_Default, </span><span class="s3">function</span><span class="s1">(self, output){</span>
        <span class="s1">output.print(</span><span class="s2">&quot;default:&quot;</span><span class="s1">);</span>
        <span class="s1">self._do_print_body(output);</span>
    <span class="s1">});</span>
    <span class="s1">DEFPRINT(AST_Case, </span><span class="s3">function</span><span class="s1">(self, output){</span>
        <span class="s1">output.print(</span><span class="s2">&quot;case&quot;</span><span class="s1">);</span>
        <span class="s1">output.space();</span>
        <span class="s1">self.expression.print(output);</span>
        <span class="s1">output.print(</span><span class="s2">&quot;:&quot;</span><span class="s1">);</span>
        <span class="s1">self._do_print_body(output);</span>
    <span class="s1">});</span>

    <span class="s0">/* -----[ exceptions ]----- */</span>
    <span class="s1">DEFPRINT(AST_Try, </span><span class="s3">function</span><span class="s1">(self, output){</span>
        <span class="s1">output.print(</span><span class="s2">&quot;try&quot;</span><span class="s1">);</span>
        <span class="s1">output.space();</span>
        <span class="s1">print_bracketed(self, output);</span>
        <span class="s3">if </span><span class="s1">(self.bcatch) {</span>
            <span class="s1">output.space();</span>
            <span class="s1">self.bcatch.print(output);</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(self.bfinally) {</span>
            <span class="s1">output.space();</span>
            <span class="s1">self.bfinally.print(output);</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s1">DEFPRINT(AST_Catch, </span><span class="s3">function</span><span class="s1">(self, output){</span>
        <span class="s1">output.print(</span><span class="s2">&quot;catch&quot;</span><span class="s1">);</span>
        <span class="s1">output.space();</span>
        <span class="s1">output.with_parens(</span><span class="s3">function</span><span class="s1">(){</span>
            <span class="s1">self.argname.print(output);</span>
        <span class="s1">});</span>
        <span class="s1">output.space();</span>
        <span class="s1">print_bracketed(self, output);</span>
    <span class="s1">});</span>
    <span class="s1">DEFPRINT(AST_Finally, </span><span class="s3">function</span><span class="s1">(self, output){</span>
        <span class="s1">output.print(</span><span class="s2">&quot;finally&quot;</span><span class="s1">);</span>
        <span class="s1">output.space();</span>
        <span class="s1">print_bracketed(self, output);</span>
    <span class="s1">});</span>

    <span class="s0">/* -----[ var/const ]----- */</span>
    <span class="s1">AST_Definitions.DEFMETHOD(</span><span class="s2">&quot;_do_print&quot;</span><span class="s1">, </span><span class="s3">function</span><span class="s1">(output, kind){</span>
        <span class="s1">output.print(kind);</span>
        <span class="s1">output.space();</span>
        <span class="s3">this</span><span class="s1">.definitions.forEach(</span><span class="s3">function</span><span class="s1">(def, i){</span>
            <span class="s3">if </span><span class="s1">(i) output.comma();</span>
            <span class="s1">def.print(output);</span>
        <span class="s1">});</span>
        <span class="s3">var </span><span class="s1">p = output.parent();</span>
        <span class="s3">var </span><span class="s1">in_for = p </span><span class="s3">instanceof </span><span class="s1">AST_For || p </span><span class="s3">instanceof </span><span class="s1">AST_ForIn;</span>
        <span class="s3">var </span><span class="s1">avoid_semicolon = in_for &amp;&amp; p.init === </span><span class="s3">this</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s1">(!avoid_semicolon)</span>
            <span class="s1">output.semicolon();</span>
    <span class="s1">});</span>
    <span class="s1">DEFPRINT(AST_Let, </span><span class="s3">function</span><span class="s1">(self, output){</span>
        <span class="s1">self._do_print(output, </span><span class="s2">&quot;let&quot;</span><span class="s1">);</span>
    <span class="s1">});</span>
    <span class="s1">DEFPRINT(AST_Var, </span><span class="s3">function</span><span class="s1">(self, output){</span>
        <span class="s1">self._do_print(output, </span><span class="s2">&quot;var&quot;</span><span class="s1">);</span>
    <span class="s1">});</span>
    <span class="s1">DEFPRINT(AST_Const, </span><span class="s3">function</span><span class="s1">(self, output){</span>
        <span class="s1">self._do_print(output, </span><span class="s2">&quot;const&quot;</span><span class="s1">);</span>
    <span class="s1">});</span>
    <span class="s1">DEFPRINT(AST_Import, </span><span class="s3">function</span><span class="s1">(self, output) {</span>
        <span class="s1">output.print(</span><span class="s2">&quot;import&quot;</span><span class="s1">);</span>
        <span class="s1">output.space();</span>
        <span class="s3">if </span><span class="s1">(self.imported_name) {</span>
            <span class="s1">self.imported_name.print(output);</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(self.imported_name &amp;&amp; self.imported_names) {</span>
            <span class="s1">output.print(</span><span class="s2">&quot;,&quot;</span><span class="s1">);</span>
            <span class="s1">output.space();</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(self.imported_names) {</span>
            <span class="s3">if </span><span class="s1">(self.imported_names.length === </span><span class="s4">1 </span><span class="s1">&amp;&amp; self.imported_names[</span><span class="s4">0</span><span class="s1">].foreign_name.name === </span><span class="s2">&quot;*&quot;</span><span class="s1">) {</span>
                <span class="s1">self.imported_names[</span><span class="s4">0</span><span class="s1">].print(output);</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s1">output.print(</span><span class="s2">&quot;{&quot;</span><span class="s1">);</span>
                <span class="s1">self.imported_names.forEach(</span><span class="s3">function </span><span class="s1">(name_import, i) {</span>
                    <span class="s1">output.space();</span>
                    <span class="s1">name_import.print(output);</span>
                    <span class="s3">if </span><span class="s1">(i &lt; self.imported_names.length - </span><span class="s4">1</span><span class="s1">) {</span>
                        <span class="s1">output.print(</span><span class="s2">&quot;,&quot;</span><span class="s1">);</span>
                    <span class="s1">}</span>
                <span class="s1">});</span>
                <span class="s1">output.space();</span>
                <span class="s1">output.print(</span><span class="s2">&quot;}&quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(self.imported_name || self.imported_names) {</span>
            <span class="s1">output.space();</span>
            <span class="s1">output.print(</span><span class="s2">&quot;from&quot;</span><span class="s1">)</span>
            <span class="s1">output.space();</span>
        <span class="s1">}</span>
        <span class="s1">self.module_name.print(output);</span>
        <span class="s1">output.semicolon();</span>
    <span class="s1">});</span>

    <span class="s1">DEFPRINT(AST_NameMapping, </span><span class="s3">function</span><span class="s1">(self, output) {</span>
        <span class="s3">var </span><span class="s1">is_import = output.parent() </span><span class="s3">instanceof </span><span class="s1">AST_Import;</span>
        <span class="s3">var </span><span class="s1">definition = self.name.definition();</span>
        <span class="s3">var </span><span class="s1">names_are_different =</span>
            <span class="s1">(definition &amp;&amp; definition.mangled_name || self.name.name) !==</span>
            <span class="s1">self.foreign_name.name;</span>
        <span class="s3">if </span><span class="s1">(names_are_different) {</span>
            <span class="s3">if </span><span class="s1">(is_import) {</span>
                <span class="s1">output.print(self.foreign_name.name);</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s1">self.name.print(output);</span>
            <span class="s1">}</span>
            <span class="s1">output.space();</span>
            <span class="s1">output.print(</span><span class="s2">&quot;as&quot;</span><span class="s1">);</span>
            <span class="s1">output.space();</span>
            <span class="s3">if </span><span class="s1">(is_import) {</span>
                <span class="s1">self.name.print(output);</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s1">output.print(self.foreign_name.name);</span>
            <span class="s1">}</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">self.name.print(output);</span>
        <span class="s1">}</span>
    <span class="s1">});</span>

    <span class="s1">DEFPRINT(AST_Export, </span><span class="s3">function</span><span class="s1">(self, output) {</span>
        <span class="s1">output.print(</span><span class="s2">&quot;export&quot;</span><span class="s1">);</span>
        <span class="s1">output.space();</span>
        <span class="s3">if </span><span class="s1">(self.is_default) {</span>
            <span class="s1">output.print(</span><span class="s2">&quot;default&quot;</span><span class="s1">);</span>
            <span class="s1">output.space();</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(self.exported_names) {</span>
            <span class="s3">if </span><span class="s1">(self.exported_names.length === </span><span class="s4">1 </span><span class="s1">&amp;&amp; self.exported_names[</span><span class="s4">0</span><span class="s1">].name.name === </span><span class="s2">&quot;*&quot;</span><span class="s1">) {</span>
                <span class="s1">self.exported_names[</span><span class="s4">0</span><span class="s1">].print(output);</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s1">output.print(</span><span class="s2">&quot;{&quot;</span><span class="s1">);</span>
                <span class="s1">self.exported_names.forEach(</span><span class="s3">function</span><span class="s1">(name_export, i) {</span>
                    <span class="s1">output.space();</span>
                    <span class="s1">name_export.print(output);</span>
                    <span class="s3">if </span><span class="s1">(i &lt; self.exported_names.length - </span><span class="s4">1</span><span class="s1">) {</span>
                        <span class="s1">output.print(</span><span class="s2">&quot;,&quot;</span><span class="s1">);</span>
                    <span class="s1">}</span>
                <span class="s1">});</span>
                <span class="s1">output.space();</span>
                <span class="s1">output.print(</span><span class="s2">&quot;}&quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">else if </span><span class="s1">(self.exported_value) {</span>
            <span class="s1">self.exported_value.print(output);</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(self.exported_definition) {</span>
            <span class="s1">self.exported_definition.print(output);</span>
            <span class="s3">if </span><span class="s1">(self.exported_definition </span><span class="s3">instanceof </span><span class="s1">AST_Definitions) </span><span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(self.module_name) {</span>
            <span class="s1">output.space();</span>
            <span class="s1">output.print(</span><span class="s2">&quot;from&quot;</span><span class="s1">);</span>
            <span class="s1">output.space();</span>
            <span class="s1">self.module_name.print(output);</span>
        <span class="s1">}</span>
        <span class="s1">output.semicolon();</span>
    <span class="s1">});</span>

    <span class="s3">function </span><span class="s1">parenthesize_for_noin(node, output, noin) {</span>
        <span class="s3">var </span><span class="s1">parens = </span><span class="s3">false</span><span class="s1">;</span>
        <span class="s0">// need to take some precautions here:</span>
        <span class="s0">//    https://github.com/mishoo/UglifyJS2/issues/60</span>
        <span class="s3">if </span><span class="s1">(noin) node.walk(</span><span class="s3">new </span><span class="s1">TreeWalker(</span><span class="s3">function</span><span class="s1">(node) {</span>
            <span class="s3">if </span><span class="s1">(parens || node </span><span class="s3">instanceof </span><span class="s1">AST_Scope) </span><span class="s3">return true</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Binary &amp;&amp; node.operator == </span><span class="s2">&quot;in&quot;</span><span class="s1">) {</span>
                <span class="s1">parens = </span><span class="s3">true</span><span class="s1">;</span>
                <span class="s3">return true</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}));</span>
        <span class="s1">node.print(output, parens);</span>
    <span class="s1">};</span>

    <span class="s1">DEFPRINT(AST_VarDef, </span><span class="s3">function</span><span class="s1">(self, output){</span>
        <span class="s1">self.name.print(output);</span>
        <span class="s3">if </span><span class="s1">(self.value) {</span>
            <span class="s1">output.space();</span>
            <span class="s1">output.print(</span><span class="s2">&quot;=&quot;</span><span class="s1">);</span>
            <span class="s1">output.space();</span>
            <span class="s3">var </span><span class="s1">p = output.parent(</span><span class="s4">1</span><span class="s1">);</span>
            <span class="s3">var </span><span class="s1">noin = p </span><span class="s3">instanceof </span><span class="s1">AST_For || p </span><span class="s3">instanceof </span><span class="s1">AST_ForIn;</span>
            <span class="s1">parenthesize_for_noin(self.value, output, noin);</span>
        <span class="s1">}</span>
    <span class="s1">});</span>

    <span class="s0">/* -----[ other expressions ]----- */</span>
    <span class="s1">DEFPRINT(AST_Call, </span><span class="s3">function</span><span class="s1">(self, output){</span>
        <span class="s1">self.expression.print(output);</span>
        <span class="s3">if </span><span class="s1">(self </span><span class="s3">instanceof </span><span class="s1">AST_New &amp;&amp; !need_constructor_parens(self, output))</span>
            <span class="s3">return</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s1">(self.expression </span><span class="s3">instanceof </span><span class="s1">AST_Call || self.expression </span><span class="s3">instanceof </span><span class="s1">AST_Lambda) {</span>
            <span class="s1">output.add_mapping(self.start);</span>
        <span class="s1">}</span>
        <span class="s1">output.with_parens(</span><span class="s3">function</span><span class="s1">(){</span>
            <span class="s1">self.args.forEach(</span><span class="s3">function</span><span class="s1">(expr, i){</span>
                <span class="s3">if </span><span class="s1">(i) output.comma();</span>
                <span class="s1">expr.print(output);</span>
            <span class="s1">});</span>
        <span class="s1">});</span>
    <span class="s1">});</span>
    <span class="s1">DEFPRINT(AST_New, </span><span class="s3">function</span><span class="s1">(self, output){</span>
        <span class="s1">output.print(</span><span class="s2">&quot;new&quot;</span><span class="s1">);</span>
        <span class="s1">output.space();</span>
        <span class="s1">AST_Call.prototype._codegen(self, output);</span>
    <span class="s1">});</span>

    <span class="s1">AST_Sequence.DEFMETHOD(</span><span class="s2">&quot;_do_print&quot;</span><span class="s1">, </span><span class="s3">function</span><span class="s1">(output){</span>
        <span class="s3">this</span><span class="s1">.expressions.forEach(</span><span class="s3">function</span><span class="s1">(node, index) {</span>
            <span class="s3">if </span><span class="s1">(index &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s1">output.comma();</span>
                <span class="s3">if </span><span class="s1">(output.should_break()) {</span>
                    <span class="s1">output.newline();</span>
                    <span class="s1">output.indent();</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">node.print(output);</span>
        <span class="s1">});</span>
    <span class="s1">});</span>
    <span class="s1">DEFPRINT(AST_Sequence, </span><span class="s3">function</span><span class="s1">(self, output){</span>
        <span class="s1">self._do_print(output);</span>
        <span class="s0">// var p = output.parent();</span>
        <span class="s0">// if (p instanceof AST_Statement) {</span>
        <span class="s0">//     output.with_indent(output.next_indent(), function(){</span>
        <span class="s0">//         self._do_print(output);</span>
        <span class="s0">//     });</span>
        <span class="s0">// } else {</span>
        <span class="s0">//     self._do_print(output);</span>
        <span class="s0">// }</span>
    <span class="s1">});</span>
    <span class="s1">DEFPRINT(AST_Dot, </span><span class="s3">function</span><span class="s1">(self, output){</span>
        <span class="s3">var </span><span class="s1">expr = self.expression;</span>
        <span class="s1">expr.print(output);</span>
        <span class="s3">var </span><span class="s1">prop = self.property;</span>
        <span class="s3">if </span><span class="s1">(output.option(</span><span class="s2">&quot;ie8&quot;</span><span class="s1">) &amp;&amp; RESERVED_WORDS(prop)) {</span>
            <span class="s1">output.print(</span><span class="s2">&quot;[&quot;</span><span class="s1">);</span>
            <span class="s1">output.add_mapping(self.end);</span>
            <span class="s1">output.print_string(prop);</span>
            <span class="s1">output.print(</span><span class="s2">&quot;]&quot;</span><span class="s1">);</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s3">if </span><span class="s1">(expr </span><span class="s3">instanceof </span><span class="s1">AST_Number &amp;&amp; expr.getValue() &gt;= </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s3">if </span><span class="s1">(!/[xa-f.)]/i.test(output.last())) {</span>
                    <span class="s1">output.print(</span><span class="s2">&quot;.&quot;</span><span class="s1">);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">output.print(</span><span class="s2">&quot;.&quot;</span><span class="s1">);</span>
            <span class="s0">// the name after dot would be mapped about here.</span>
            <span class="s1">output.add_mapping(self.end);</span>
            <span class="s1">output.print_name(prop);</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s1">DEFPRINT(AST_Sub, </span><span class="s3">function</span><span class="s1">(self, output){</span>
        <span class="s1">self.expression.print(output);</span>
        <span class="s1">output.print(</span><span class="s2">&quot;[&quot;</span><span class="s1">);</span>
        <span class="s1">self.property.print(output);</span>
        <span class="s1">output.print(</span><span class="s2">&quot;]&quot;</span><span class="s1">);</span>
    <span class="s1">});</span>
    <span class="s1">DEFPRINT(AST_UnaryPrefix, </span><span class="s3">function</span><span class="s1">(self, output){</span>
        <span class="s3">var </span><span class="s1">op = self.operator;</span>
        <span class="s1">output.print(op);</span>
        <span class="s3">if </span><span class="s1">(/^[a-z]/i.test(op)</span>
            <span class="s1">|| (/[+-]$/.test(op)</span>
                <span class="s1">&amp;&amp; self.expression </span><span class="s3">instanceof </span><span class="s1">AST_UnaryPrefix</span>
                <span class="s1">&amp;&amp; /^[+-]/.test(self.expression.operator))) {</span>
            <span class="s1">output.space();</span>
        <span class="s1">}</span>
        <span class="s1">self.expression.print(output);</span>
    <span class="s1">});</span>
    <span class="s1">DEFPRINT(AST_UnaryPostfix, </span><span class="s3">function</span><span class="s1">(self, output){</span>
        <span class="s1">self.expression.print(output);</span>
        <span class="s1">output.print(self.operator);</span>
    <span class="s1">});</span>
    <span class="s1">DEFPRINT(AST_Binary, </span><span class="s3">function</span><span class="s1">(self, output){</span>
        <span class="s3">var </span><span class="s1">op = self.operator;</span>
        <span class="s1">self.left.print(output);</span>
        <span class="s3">if </span><span class="s1">(op[</span><span class="s4">0</span><span class="s1">] == </span><span class="s2">&quot;&gt;&quot; </span><span class="s0">/* &quot;&gt;&gt;&quot; &quot;&gt;&gt;&gt;&quot; &quot;&gt;&quot; &quot;&gt;=&quot; */</span>
            <span class="s1">&amp;&amp; self.left </span><span class="s3">instanceof </span><span class="s1">AST_UnaryPostfix</span>
            <span class="s1">&amp;&amp; self.left.operator == </span><span class="s2">&quot;--&quot;</span><span class="s1">) {</span>
            <span class="s0">// space is mandatory to avoid outputting --&gt;</span>
            <span class="s1">output.print(</span><span class="s2">&quot; &quot;</span><span class="s1">);</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s0">// the space is optional depending on &quot;beautify&quot;</span>
            <span class="s1">output.space();</span>
        <span class="s1">}</span>
        <span class="s1">output.print(op);</span>
        <span class="s3">if </span><span class="s1">((op == </span><span class="s2">&quot;&lt;&quot; </span><span class="s1">|| op == </span><span class="s2">&quot;&lt;&lt;&quot;</span><span class="s1">)</span>
            <span class="s1">&amp;&amp; self.right </span><span class="s3">instanceof </span><span class="s1">AST_UnaryPrefix</span>
            <span class="s1">&amp;&amp; self.right.operator == </span><span class="s2">&quot;!&quot;</span>
            <span class="s1">&amp;&amp; self.right.expression </span><span class="s3">instanceof </span><span class="s1">AST_UnaryPrefix</span>
            <span class="s1">&amp;&amp; self.right.expression.operator == </span><span class="s2">&quot;--&quot;</span><span class="s1">) {</span>
            <span class="s0">// space is mandatory to avoid outputting &lt;!--</span>
            <span class="s1">output.print(</span><span class="s2">&quot; &quot;</span><span class="s1">);</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s0">// the space is optional depending on &quot;beautify&quot;</span>
            <span class="s1">output.space();</span>
        <span class="s1">}</span>
        <span class="s1">self.right.print(output);</span>
    <span class="s1">});</span>
    <span class="s1">DEFPRINT(AST_Conditional, </span><span class="s3">function</span><span class="s1">(self, output){</span>
        <span class="s1">self.condition.print(output);</span>
        <span class="s1">output.space();</span>
        <span class="s1">output.print(</span><span class="s2">&quot;?&quot;</span><span class="s1">);</span>
        <span class="s1">output.space();</span>
        <span class="s1">self.consequent.print(output);</span>
        <span class="s1">output.space();</span>
        <span class="s1">output.colon();</span>
        <span class="s1">self.alternative.print(output);</span>
    <span class="s1">});</span>

    <span class="s0">/* -----[ literals ]----- */</span>
    <span class="s1">DEFPRINT(AST_Array, </span><span class="s3">function</span><span class="s1">(self, output){</span>
        <span class="s1">output.with_square(</span><span class="s3">function</span><span class="s1">(){</span>
            <span class="s3">var </span><span class="s1">a = self.elements, len = a.length;</span>
            <span class="s3">if </span><span class="s1">(len &gt; </span><span class="s4">0</span><span class="s1">) output.space();</span>
            <span class="s1">a.forEach(</span><span class="s3">function</span><span class="s1">(exp, i){</span>
                <span class="s3">if </span><span class="s1">(i) output.comma();</span>
                <span class="s1">exp.print(output);</span>
                <span class="s0">// If the final element is a hole, we need to make sure it</span>
                <span class="s0">// doesn't look like a trailing comma, by inserting an actual</span>
                <span class="s0">// trailing comma.</span>
                <span class="s3">if </span><span class="s1">(i === len - </span><span class="s4">1 </span><span class="s1">&amp;&amp; exp </span><span class="s3">instanceof </span><span class="s1">AST_Hole)</span>
                  <span class="s1">output.comma();</span>
            <span class="s1">});</span>
            <span class="s3">if </span><span class="s1">(len &gt; </span><span class="s4">0</span><span class="s1">) output.space();</span>
        <span class="s1">});</span>
    <span class="s1">});</span>
    <span class="s1">DEFPRINT(AST_Object, </span><span class="s3">function</span><span class="s1">(self, output){</span>
        <span class="s3">if </span><span class="s1">(self.properties.length &gt; </span><span class="s4">0</span><span class="s1">) output.with_block(</span><span class="s3">function</span><span class="s1">(){</span>
            <span class="s1">self.properties.forEach(</span><span class="s3">function</span><span class="s1">(prop, i){</span>
                <span class="s3">if </span><span class="s1">(i) {</span>
                    <span class="s1">output.print(</span><span class="s2">&quot;,&quot;</span><span class="s1">);</span>
                    <span class="s1">output.newline();</span>
                <span class="s1">}</span>
                <span class="s1">output.indent();</span>
                <span class="s1">prop.print(output);</span>
            <span class="s1">});</span>
            <span class="s1">output.newline();</span>
        <span class="s1">});</span>
        <span class="s3">else </span><span class="s1">output.print(</span><span class="s2">&quot;{}&quot;</span><span class="s1">);</span>
    <span class="s1">});</span>
    <span class="s1">DEFPRINT(AST_Class, </span><span class="s3">function</span><span class="s1">(self, output){</span>
        <span class="s1">output.print(</span><span class="s2">&quot;class&quot;</span><span class="s1">);</span>
        <span class="s1">output.space();</span>
        <span class="s3">if </span><span class="s1">(self.name) {</span>
            <span class="s1">self.name.print(output);</span>
            <span class="s1">output.space();</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(self.extends) {</span>
            <span class="s3">var </span><span class="s1">parens = (</span>
                   <span class="s1">!(self.extends </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef)</span>
                <span class="s1">&amp;&amp; !(self.extends </span><span class="s3">instanceof </span><span class="s1">AST_PropAccess)</span>
                <span class="s1">&amp;&amp; !(self.extends </span><span class="s3">instanceof </span><span class="s1">AST_ClassExpression)</span>
                <span class="s1">&amp;&amp; !(self.extends </span><span class="s3">instanceof </span><span class="s1">AST_Function)</span>
            <span class="s1">);</span>
            <span class="s1">output.print(</span><span class="s2">&quot;extends&quot;</span><span class="s1">);</span>
            <span class="s3">if </span><span class="s1">(parens) {</span>
                <span class="s1">output.print(</span><span class="s2">&quot;(&quot;</span><span class="s1">);</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s1">output.space();</span>
            <span class="s1">}</span>
            <span class="s1">self.extends.print(output);</span>
            <span class="s3">if </span><span class="s1">(parens) {</span>
                <span class="s1">output.print(</span><span class="s2">&quot;)&quot;</span><span class="s1">);</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s1">output.space();</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(self.properties.length &gt; </span><span class="s4">0</span><span class="s1">) output.with_block(</span><span class="s3">function</span><span class="s1">(){</span>
            <span class="s1">self.properties.forEach(</span><span class="s3">function</span><span class="s1">(prop, i){</span>
                <span class="s3">if </span><span class="s1">(i) {</span>
                    <span class="s1">output.newline();</span>
                <span class="s1">}</span>
                <span class="s1">output.indent();</span>
                <span class="s1">prop.print(output);</span>
            <span class="s1">});</span>
            <span class="s1">output.newline();</span>
        <span class="s1">});</span>
        <span class="s3">else </span><span class="s1">output.print(</span><span class="s2">&quot;{}&quot;</span><span class="s1">);</span>
    <span class="s1">});</span>
    <span class="s1">DEFPRINT(AST_NewTarget, </span><span class="s3">function</span><span class="s1">(self, output) {</span>
        <span class="s1">output.print(</span><span class="s2">&quot;new.target&quot;</span><span class="s1">);</span>
    <span class="s1">});</span>

    <span class="s3">function </span><span class="s1">print_property_name(key, quote, output) {</span>
        <span class="s3">if </span><span class="s1">(output.option(</span><span class="s2">&quot;quote_keys&quot;</span><span class="s1">)) {</span>
            <span class="s1">output.print_string(key);</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s2">&quot;&quot; </span><span class="s1">+ +key == key &amp;&amp; key &gt;= </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s1">output.print(make_num(key));</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(RESERVED_WORDS(key) ? !output.option(</span><span class="s2">&quot;ie8&quot;</span><span class="s1">) : is_identifier_string(key)) {</span>
            <span class="s3">if </span><span class="s1">(quote &amp;&amp; output.option(</span><span class="s2">&quot;keep_quoted_props&quot;</span><span class="s1">)) {</span>
                <span class="s1">output.print_string(key, quote);</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s1">output.print_name(key);</span>
            <span class="s1">}</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">output.print_string(key, quote);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">DEFPRINT(AST_ObjectKeyVal, </span><span class="s3">function</span><span class="s1">(self, output){</span>
        <span class="s3">function </span><span class="s1">get_name(self) {</span>
            <span class="s3">var </span><span class="s1">def = self.definition();</span>
            <span class="s3">return </span><span class="s1">def ? def.mangled_name || def.name : self.name;</span>
        <span class="s1">}</span>

        <span class="s3">var </span><span class="s1">allowShortHand = output.option(</span><span class="s2">&quot;shorthand&quot;</span><span class="s1">);</span>
        <span class="s3">if </span><span class="s1">(allowShortHand &amp;&amp;</span>
            <span class="s1">self.value </span><span class="s3">instanceof </span><span class="s1">AST_Symbol &amp;&amp;</span>
            <span class="s1">is_identifier_string(self.key) &amp;&amp;</span>
            <span class="s1">get_name(self.value) === self.key &amp;&amp;</span>
            <span class="s1">is_identifier(self.key)</span>
        <span class="s1">) {</span>
            <span class="s1">print_property_name(self.key, self.quote, output);</span>

        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(allowShortHand &amp;&amp;</span>
            <span class="s1">self.value </span><span class="s3">instanceof </span><span class="s1">AST_DefaultAssign &amp;&amp;</span>
            <span class="s1">self.value.left </span><span class="s3">instanceof </span><span class="s1">AST_Symbol &amp;&amp;</span>
            <span class="s1">is_identifier_string(self.key) &amp;&amp;</span>
            <span class="s1">get_name(self.value.left) === self.key</span>
        <span class="s1">) {</span>
            <span class="s1">print_property_name(self.key, self.quote, output);</span>
            <span class="s1">output.space();</span>
            <span class="s1">output.print(</span><span class="s2">&quot;=&quot;</span><span class="s1">);</span>
            <span class="s1">output.space();</span>
            <span class="s1">self.value.right.print(output);</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s3">if </span><span class="s1">(!(self.key </span><span class="s3">instanceof </span><span class="s1">AST_Node)) {</span>
                <span class="s1">print_property_name(self.key, self.quote, output);</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s1">output.with_square(</span><span class="s3">function</span><span class="s1">() {</span>
                    <span class="s1">self.key.print(output);</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s1">output.colon();</span>
            <span class="s1">self.value.print(output);</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s1">AST_ObjectProperty.DEFMETHOD(</span><span class="s2">&quot;_print_getter_setter&quot;</span><span class="s1">, </span><span class="s3">function</span><span class="s1">(type, output) {</span>
        <span class="s3">var </span><span class="s1">self = </span><span class="s3">this</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s1">(self.static) {</span>
            <span class="s1">output.print(</span><span class="s2">&quot;static&quot;</span><span class="s1">);</span>
            <span class="s1">output.space();</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(type) {</span>
            <span class="s1">output.print(type);</span>
            <span class="s1">output.space();</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(self.key </span><span class="s3">instanceof </span><span class="s1">AST_SymbolMethod) {</span>
            <span class="s1">print_property_name(self.key.name, self.quote, output);</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">output.with_square(</span><span class="s3">function</span><span class="s1">() {</span>
                <span class="s1">self.key.print(output);</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s1">self.value._do_print(output, </span><span class="s3">true</span><span class="s1">);</span>
    <span class="s1">});</span>
    <span class="s1">DEFPRINT(AST_ObjectSetter, </span><span class="s3">function</span><span class="s1">(self, output){</span>
        <span class="s1">self._print_getter_setter(</span><span class="s2">&quot;set&quot;</span><span class="s1">, output);</span>
    <span class="s1">});</span>
    <span class="s1">DEFPRINT(AST_ObjectGetter, </span><span class="s3">function</span><span class="s1">(self, output){</span>
        <span class="s1">self._print_getter_setter(</span><span class="s2">&quot;get&quot;</span><span class="s1">, output);</span>
    <span class="s1">});</span>
    <span class="s1">DEFPRINT(AST_ConciseMethod, </span><span class="s3">function</span><span class="s1">(self, output){</span>
        <span class="s1">self._print_getter_setter(self.is_generator &amp;&amp; </span><span class="s2">&quot;*&quot; </span><span class="s1">|| self.async &amp;&amp; </span><span class="s2">&quot;async&quot;</span><span class="s1">, output);</span>
    <span class="s1">});</span>
    <span class="s1">AST_Symbol.DEFMETHOD(</span><span class="s2">&quot;_do_print&quot;</span><span class="s1">, </span><span class="s3">function</span><span class="s1">(output){</span>
        <span class="s3">var </span><span class="s1">def = </span><span class="s3">this</span><span class="s1">.definition();</span>
        <span class="s1">output.print_name(def ? def.mangled_name || def.name : </span><span class="s3">this</span><span class="s1">.name);</span>
    <span class="s1">});</span>
    <span class="s1">DEFPRINT(AST_Symbol, </span><span class="s3">function </span><span class="s1">(self, output) {</span>
        <span class="s1">self._do_print(output);</span>
    <span class="s1">});</span>
    <span class="s1">DEFPRINT(AST_Hole, noop);</span>
    <span class="s1">DEFPRINT(AST_This, </span><span class="s3">function</span><span class="s1">(self, output){</span>
        <span class="s1">output.print(</span><span class="s2">&quot;this&quot;</span><span class="s1">);</span>
    <span class="s1">});</span>
    <span class="s1">DEFPRINT(AST_Super, </span><span class="s3">function</span><span class="s1">(self, output){</span>
        <span class="s1">output.print(</span><span class="s2">&quot;super&quot;</span><span class="s1">);</span>
    <span class="s1">});</span>
    <span class="s1">DEFPRINT(AST_Constant, </span><span class="s3">function</span><span class="s1">(self, output){</span>
        <span class="s1">output.print(self.getValue());</span>
    <span class="s1">});</span>
    <span class="s1">DEFPRINT(AST_String, </span><span class="s3">function</span><span class="s1">(self, output){</span>
        <span class="s1">output.print_string(self.getValue(), self.quote, in_directive);</span>
    <span class="s1">});</span>
    <span class="s1">DEFPRINT(AST_Number, </span><span class="s3">function</span><span class="s1">(self, output){</span>
        <span class="s3">if </span><span class="s1">(use_asm &amp;&amp; self.start &amp;&amp; self.start.raw != </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s1">output.print(self.start.raw);</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">output.print(make_num(self.getValue()));</span>
        <span class="s1">}</span>
    <span class="s1">});</span>

    <span class="s1">DEFPRINT(AST_RegExp, </span><span class="s3">function</span><span class="s1">(self, output){</span>
        <span class="s3">var </span><span class="s1">regexp = self.getValue();</span>
        <span class="s3">var </span><span class="s1">str = regexp.toString();</span>
        <span class="s3">if </span><span class="s1">(regexp.raw_source) {</span>
            <span class="s1">str = </span><span class="s2">&quot;/&quot; </span><span class="s1">+ regexp.raw_source + str.slice(str.lastIndexOf(</span><span class="s2">&quot;/&quot;</span><span class="s1">));</span>
        <span class="s1">}</span>
        <span class="s1">str = output.to_utf8(str);</span>
        <span class="s1">output.print(str);</span>
        <span class="s3">var </span><span class="s1">p = output.parent();</span>
        <span class="s3">if </span><span class="s1">(p </span><span class="s3">instanceof </span><span class="s1">AST_Binary &amp;&amp; /^</span><span class="s3">in</span><span class="s1">/.test(p.operator) &amp;&amp; p.left === self)</span>
            <span class="s1">output.print(</span><span class="s2">&quot; &quot;</span><span class="s1">);</span>
    <span class="s1">});</span>

    <span class="s3">function </span><span class="s1">force_statement(stat, output) {</span>
        <span class="s3">if </span><span class="s1">(output.option(</span><span class="s2">&quot;bracketize&quot;</span><span class="s1">)) {</span>
            <span class="s1">make_block(stat, output);</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s3">if </span><span class="s1">(!stat || stat </span><span class="s3">instanceof </span><span class="s1">AST_EmptyStatement)</span>
                <span class="s1">output.force_semicolon();</span>
            <span class="s3">else</span>
                <span class="s1">stat.print(output);</span>
        <span class="s1">}</span>
    <span class="s1">};</span>

    <span class="s0">// self should be AST_New.  decide if we want to show parens or not.</span>
    <span class="s3">function </span><span class="s1">need_constructor_parens(self, output) {</span>
        <span class="s0">// Always print parentheses with arguments</span>
        <span class="s3">if </span><span class="s1">(self.args.length &gt; </span><span class="s4">0</span><span class="s1">) </span><span class="s3">return true</span><span class="s1">;</span>

        <span class="s3">return </span><span class="s1">output.option(</span><span class="s2">&quot;beautify&quot;</span><span class="s1">);</span>
    <span class="s1">};</span>

    <span class="s3">function </span><span class="s1">best_of(a) {</span>
        <span class="s3">var </span><span class="s1">best = a[</span><span class="s4">0</span><span class="s1">], len = best.length;</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">1</span><span class="s1">; i &lt; a.length; ++i) {</span>
            <span class="s3">if </span><span class="s1">(a[i].length &lt; len) {</span>
                <span class="s1">best = a[i];</span>
                <span class="s1">len = best.length;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">best;</span>
    <span class="s1">};</span>

    <span class="s3">function </span><span class="s1">make_num(num) {</span>
        <span class="s3">var </span><span class="s1">str = num.toString(</span><span class="s4">10</span><span class="s1">), a = [ str.replace(/^</span><span class="s4">0</span><span class="s1">\./, </span><span class="s2">&quot;.&quot;</span><span class="s1">).replace(</span><span class="s2">'e+'</span><span class="s1">, </span><span class="s2">'e'</span><span class="s1">) ], m;</span>
        <span class="s3">if </span><span class="s1">(Math.floor(num) === num) {</span>
            <span class="s3">if </span><span class="s1">(num &gt;= </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s1">a.push(</span><span class="s2">&quot;0x&quot; </span><span class="s1">+ num.toString(</span><span class="s4">16</span><span class="s1">).toLowerCase(), </span><span class="s0">// probably pointless</span>
                       <span class="s2">&quot;0&quot; </span><span class="s1">+ num.toString(</span><span class="s4">8</span><span class="s1">)); </span><span class="s0">// same.</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s1">a.push(</span><span class="s2">&quot;-0x&quot; </span><span class="s1">+ (-num).toString(</span><span class="s4">16</span><span class="s1">).toLowerCase(), </span><span class="s0">// probably pointless</span>
                       <span class="s2">&quot;-0&quot; </span><span class="s1">+ (-num).toString(</span><span class="s4">8</span><span class="s1">)); </span><span class="s0">// same.</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">((m = /^(.*?)(</span><span class="s4">0</span><span class="s1">+)$/.exec(num))) {</span>
                <span class="s1">a.push(m[</span><span class="s4">1</span><span class="s1">] + </span><span class="s2">&quot;e&quot; </span><span class="s1">+ m[</span><span class="s4">2</span><span class="s1">].length);</span>
            <span class="s1">}</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">((m = /^</span><span class="s4">0</span><span class="s1">?\.(</span><span class="s4">0</span><span class="s1">+)(.*)$/.exec(num))) {</span>
            <span class="s1">a.push(m[</span><span class="s4">2</span><span class="s1">] + </span><span class="s2">&quot;e-&quot; </span><span class="s1">+ (m[</span><span class="s4">1</span><span class="s1">].length + m[</span><span class="s4">2</span><span class="s1">].length),</span>
                   <span class="s1">str.substr(str.indexOf(</span><span class="s2">&quot;.&quot;</span><span class="s1">)));</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">best_of(a);</span>
    <span class="s1">};</span>

    <span class="s3">function </span><span class="s1">make_block(stmt, output) {</span>
        <span class="s3">if </span><span class="s1">(!stmt || stmt </span><span class="s3">instanceof </span><span class="s1">AST_EmptyStatement)</span>
            <span class="s1">output.print(</span><span class="s2">&quot;{}&quot;</span><span class="s1">);</span>
        <span class="s3">else if </span><span class="s1">(stmt </span><span class="s3">instanceof </span><span class="s1">AST_BlockStatement)</span>
            <span class="s1">stmt.print(output);</span>
        <span class="s3">else </span><span class="s1">output.with_block(</span><span class="s3">function</span><span class="s1">(){</span>
            <span class="s1">output.indent();</span>
            <span class="s1">stmt.print(output);</span>
            <span class="s1">output.newline();</span>
        <span class="s1">});</span>
    <span class="s1">};</span>

    <span class="s0">/* -----[ source map generators ]----- */</span>

    <span class="s3">function </span><span class="s1">DEFMAP(nodetype, generator) {</span>
        <span class="s1">nodetype.DEFMETHOD(</span><span class="s2">&quot;add_source_map&quot;</span><span class="s1">, </span><span class="s3">function</span><span class="s1">(stream){</span>
            <span class="s1">generator(</span><span class="s3">this</span><span class="s1">, stream);</span>
        <span class="s1">});</span>
    <span class="s1">};</span>

    <span class="s0">// We could easily add info for ALL nodes, but it seems to me that</span>
    <span class="s0">// would be quite wasteful, hence this noop in the base class.</span>
    <span class="s1">DEFMAP(AST_Node, noop);</span>

    <span class="s3">function </span><span class="s1">basic_sourcemap_gen(self, output) {</span>
        <span class="s1">output.add_mapping(self.start);</span>
    <span class="s1">};</span>

    <span class="s0">// XXX: I'm not exactly sure if we need it for all of these nodes,</span>
    <span class="s0">// or if we should add even more.</span>

    <span class="s1">DEFMAP(AST_Directive, basic_sourcemap_gen);</span>
    <span class="s1">DEFMAP(AST_Debugger, basic_sourcemap_gen);</span>
    <span class="s1">DEFMAP(AST_Symbol, basic_sourcemap_gen);</span>
    <span class="s1">DEFMAP(AST_Jump, basic_sourcemap_gen);</span>
    <span class="s1">DEFMAP(AST_StatementWithBody, basic_sourcemap_gen);</span>
    <span class="s1">DEFMAP(AST_LabeledStatement, noop); </span><span class="s0">// since the label symbol will mark it</span>
    <span class="s1">DEFMAP(AST_Lambda, basic_sourcemap_gen);</span>
    <span class="s1">DEFMAP(AST_Switch, basic_sourcemap_gen);</span>
    <span class="s1">DEFMAP(AST_SwitchBranch, basic_sourcemap_gen);</span>
    <span class="s1">DEFMAP(AST_BlockStatement, basic_sourcemap_gen);</span>
    <span class="s1">DEFMAP(AST_Toplevel, noop);</span>
    <span class="s1">DEFMAP(AST_New, basic_sourcemap_gen);</span>
    <span class="s1">DEFMAP(AST_Try, basic_sourcemap_gen);</span>
    <span class="s1">DEFMAP(AST_Catch, basic_sourcemap_gen);</span>
    <span class="s1">DEFMAP(AST_Finally, basic_sourcemap_gen);</span>
    <span class="s1">DEFMAP(AST_Definitions, basic_sourcemap_gen);</span>
    <span class="s1">DEFMAP(AST_Constant, basic_sourcemap_gen);</span>
    <span class="s1">DEFMAP(AST_ObjectSetter, </span><span class="s3">function</span><span class="s1">(self, output){</span>
        <span class="s1">output.add_mapping(self.start, self.key.name);</span>
    <span class="s1">});</span>
    <span class="s1">DEFMAP(AST_ObjectGetter, </span><span class="s3">function</span><span class="s1">(self, output){</span>
        <span class="s1">output.add_mapping(self.start, self.key.name);</span>
    <span class="s1">});</span>
    <span class="s1">DEFMAP(AST_ObjectProperty, </span><span class="s3">function</span><span class="s1">(self, output){</span>
        <span class="s1">output.add_mapping(self.start, self.key);</span>
    <span class="s1">});</span>

<span class="s1">})();</span>
</pre>
</body>
</html>
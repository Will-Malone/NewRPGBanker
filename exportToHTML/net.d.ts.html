<html>
<head>
<title>net.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #a9b7c6;}
.s4 { color: #6a8759;}
.s5 { color: #9876aa; font-style: italic;}
.s6 { color: #ffc66d;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
net.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* &gt; Stability: 2 - Stable 
 * 
 * The `node:net` module provides an asynchronous network API for creating stream-based 
 * TCP or `IPC` servers (</span><span class="s1">{</span><span class="s2">@link </span><span class="s1">createServer}</span><span class="s0">) and clients 
 * (</span><span class="s1">{</span><span class="s2">@link </span><span class="s1">createConnection}</span><span class="s0">). 
 * 
 * It can be accessed using: 
 * 
 * ```js 
 * const net = require('node:net'); 
 * ``` 
 * </span><span class="s2">@see </span><span class="s1">[source](https:</span><span class="s0">//github.com/nodejs/node/blob/v20.2.0/lib/net.js) 
 */</span>
<span class="s2">declare module </span><span class="s4">'net' </span><span class="s3">{</span>
    <span class="s2">import </span><span class="s5">* </span><span class="s2">as </span><span class="s1">stream </span><span class="s2">from </span><span class="s4">'node:stream'</span><span class="s3">;</span>
    <span class="s2">import </span><span class="s3">{ </span><span class="s1">Abortable</span><span class="s3">, </span><span class="s1">EventEmitter </span><span class="s3">} </span><span class="s2">from </span><span class="s4">'node:events'</span><span class="s3">;</span>
    <span class="s2">import </span><span class="s5">* </span><span class="s2">as </span><span class="s1">dns </span><span class="s2">from </span><span class="s4">'node:dns'</span><span class="s3">;</span>
    <span class="s2">type </span><span class="s1">LookupFunction </span><span class="s2">= </span><span class="s3">(</span><span class="s1">hostname</span><span class="s2">: </span><span class="s1">string</span><span class="s3">, </span><span class="s1">options</span><span class="s2">: </span><span class="s1">dns</span><span class="s3">.</span><span class="s1">LookupAllOptions</span><span class="s3">, </span><span class="s6">callback</span><span class="s2">: </span><span class="s3">(</span><span class="s1">err</span><span class="s2">: </span><span class="s1">NodeJS</span><span class="s3">.</span><span class="s1">ErrnoException </span><span class="s2">| </span><span class="s1">null</span><span class="s3">, </span><span class="s1">addresses</span><span class="s2">: </span><span class="s1">dns</span><span class="s3">.</span><span class="s1">LookupAddress</span><span class="s3">[]) </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">) </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">;</span>
    <span class="s2">interface </span><span class="s1">AddressInfo </span><span class="s3">{</span>
        <span class="s3">address</span><span class="s2">: </span><span class="s1">string</span><span class="s3">;</span>
        <span class="s3">family</span><span class="s2">: </span><span class="s1">string</span><span class="s3">;</span>
        <span class="s3">port</span><span class="s2">: </span><span class="s1">number</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s2">interface </span><span class="s1">SocketConstructorOpts </span><span class="s3">{</span>
        <span class="s3">fd</span><span class="s2">?: </span><span class="s1">number </span><span class="s2">| </span><span class="s1">undefined</span><span class="s3">;</span>
        <span class="s3">allowHalfOpen</span><span class="s2">?: </span><span class="s1">boolean </span><span class="s2">| </span><span class="s1">undefined</span><span class="s3">;</span>
        <span class="s3">readable</span><span class="s2">?: </span><span class="s1">boolean </span><span class="s2">| </span><span class="s1">undefined</span><span class="s3">;</span>
        <span class="s3">writable</span><span class="s2">?: </span><span class="s1">boolean </span><span class="s2">| </span><span class="s1">undefined</span><span class="s3">;</span>
        <span class="s3">signal</span><span class="s2">?: </span><span class="s1">AbortSignal</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s2">interface </span><span class="s1">OnReadOpts </span><span class="s3">{</span>
        <span class="s3">buffer</span><span class="s2">: </span><span class="s1">Uint8Array </span><span class="s2">| </span><span class="s3">(() </span><span class="s2">=&gt; </span><span class="s1">Uint8Array</span><span class="s3">);</span>
        <span class="s0">/**</span>
         <span class="s0">* This function is called for every chunk of incoming data. 
         * Two arguments are passed to it: the number of bytes written to buffer and a reference to buffer. 
         * Return false from this function to implicitly pause() the socket. 
         */</span>
        <span class="s3">callback(</span><span class="s1">bytesWritten</span><span class="s2">: </span><span class="s1">number</span><span class="s3">, </span><span class="s1">buf</span><span class="s2">: </span><span class="s1">Uint8Array</span><span class="s3">)</span><span class="s2">: </span><span class="s1">boolean</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s2">interface </span><span class="s1">ConnectOpts </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* If specified, incoming data is stored in a single buffer and passed to the supplied callback when data arrives on the socket. 
         * Note: this will cause the streaming functionality to not provide any data, however events like 'error', 'end', and 'close' will 
         * still be emitted as normal and methods like pause() and resume() will also behave as expected. 
         */</span>
        <span class="s3">onread</span><span class="s2">?: </span><span class="s1">OnReadOpts </span><span class="s2">| </span><span class="s1">undefined</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s2">interface </span><span class="s1">TcpSocketConnectOpts </span><span class="s2">extends </span><span class="s1">ConnectOpts </span><span class="s3">{</span>
        <span class="s3">port</span><span class="s2">: </span><span class="s1">number</span><span class="s3">;</span>
        <span class="s3">host</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">undefined</span><span class="s3">;</span>
        <span class="s3">localAddress</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">undefined</span><span class="s3">;</span>
        <span class="s3">localPort</span><span class="s2">?: </span><span class="s1">number </span><span class="s2">| </span><span class="s1">undefined</span><span class="s3">;</span>
        <span class="s3">hints</span><span class="s2">?: </span><span class="s1">number </span><span class="s2">| </span><span class="s1">undefined</span><span class="s3">;</span>
        <span class="s3">family</span><span class="s2">?: </span><span class="s1">number </span><span class="s2">| </span><span class="s1">undefined</span><span class="s3">;</span>
        <span class="s3">lookup</span><span class="s2">?: </span><span class="s1">LookupFunction </span><span class="s2">| </span><span class="s1">undefined</span><span class="s3">;</span>
        <span class="s3">noDelay</span><span class="s2">?: </span><span class="s1">boolean </span><span class="s2">| </span><span class="s1">undefined</span><span class="s3">;</span>
        <span class="s3">keepAlive</span><span class="s2">?: </span><span class="s1">boolean </span><span class="s2">| </span><span class="s1">undefined</span><span class="s3">;</span>
        <span class="s3">keepAliveInitialDelay</span><span class="s2">?: </span><span class="s1">number </span><span class="s2">| </span><span class="s1">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@since </span><span class="s0">v18.13.0 
         */</span>
        <span class="s3">autoSelectFamily</span><span class="s2">?: </span><span class="s1">boolean </span><span class="s2">| </span><span class="s1">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@since </span><span class="s0">v18.13.0 
         */</span>
        <span class="s3">autoSelectFamilyAttemptTimeout</span><span class="s2">?: </span><span class="s1">number </span><span class="s2">| </span><span class="s1">undefined</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s2">interface </span><span class="s1">IpcSocketConnectOpts </span><span class="s2">extends </span><span class="s1">ConnectOpts </span><span class="s3">{</span>
        <span class="s3">path</span><span class="s2">: </span><span class="s1">string</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s2">type </span><span class="s1">SocketConnectOpts </span><span class="s2">= </span><span class="s1">TcpSocketConnectOpts </span><span class="s2">| </span><span class="s1">IpcSocketConnectOpts</span><span class="s3">;</span>
    <span class="s2">type </span><span class="s1">SocketReadyState </span><span class="s2">= </span><span class="s4">'opening' </span><span class="s2">| </span><span class="s4">'open' </span><span class="s2">| </span><span class="s4">'readOnly' </span><span class="s2">| </span><span class="s4">'writeOnly' </span><span class="s2">| </span><span class="s4">'closed'</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* This class is an abstraction of a TCP socket or a streaming `IPC` endpoint 
     * (uses named pipes on Windows, and Unix domain sockets otherwise). It is also 
     * an `EventEmitter`. 
     * 
     * A `net.Socket` can be created by the user and used directly to interact with 
     * a server. For example, it is returned by </span><span class="s1">{</span><span class="s2">@link </span><span class="s1">createConnection}</span><span class="s0">, 
     * so the user can use it to talk to the server. 
     * 
     * It can also be created by Node.js and passed to the user when a connection 
     * is received. For example, it is passed to the listeners of a `'connection'` event emitted on a </span><span class="s1">{</span><span class="s2">@link </span><span class="s1">Server}</span><span class="s0">, so the user can use 
     * it to interact with the client. 
     * </span><span class="s2">@since </span><span class="s0">v0.3.4 
     */</span>
    <span class="s2">class </span><span class="s1">Socket </span><span class="s2">extends </span><span class="s1">stream</span><span class="s3">.</span><span class="s1">Duplex </span><span class="s3">{</span>
        <span class="s2">constructor</span><span class="s3">(</span><span class="s1">options</span><span class="s2">?: </span><span class="s1">SocketConstructorOpts</span><span class="s3">);</span>
        <span class="s0">/**</span>
         <span class="s0">* Sends data on the socket. The second parameter specifies the encoding in the 
         * case of a string. It defaults to UTF8 encoding. 
         * 
         * Returns `true` if the entire data was flushed successfully to the kernel 
         * buffer. Returns `false` if all or part of the data was queued in user memory.`'drain'` will be emitted when the buffer is again free. 
         * 
         * The optional `callback` parameter will be executed when the data is finally 
         * written out, which may not be immediately. 
         * 
         * See `Writable` stream `write()` method for more 
         * information. 
         * </span><span class="s2">@since </span><span class="s0">v0.1.90 
         * </span><span class="s2">@param </span><span class="s0">[encoding='utf8'] Only used when data is `string`. 
         */</span>
        <span class="s3">write(</span><span class="s1">buffer</span><span class="s2">: </span><span class="s1">Uint8Array </span><span class="s2">| </span><span class="s1">string</span><span class="s3">, </span><span class="s6">cb</span><span class="s2">?: </span><span class="s3">(</span><span class="s1">err</span><span class="s2">?: </span><span class="s1">Error</span><span class="s3">) </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">boolean</span><span class="s3">;</span>
        <span class="s3">write(</span><span class="s1">str</span><span class="s2">: </span><span class="s1">Uint8Array </span><span class="s2">| </span><span class="s1">string</span><span class="s3">, </span><span class="s1">encoding</span><span class="s2">?: </span><span class="s1">BufferEncoding</span><span class="s3">, </span><span class="s6">cb</span><span class="s2">?: </span><span class="s3">(</span><span class="s1">err</span><span class="s2">?: </span><span class="s1">Error</span><span class="s3">) </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">boolean</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Initiate a connection on a given socket. 
         * 
         * Possible signatures: 
         * 
         * * `socket.connect(options[, connectListener])` 
         * * `socket.connect(path[, connectListener])` for `IPC` connections. 
         * * `socket.connect(port[, host][, connectListener])` for TCP connections. 
         * * Returns: `net.Socket` The socket itself. 
         * 
         * This function is asynchronous. When the connection is established, the `'connect'` event will be emitted. If there is a problem connecting, 
         * instead of a `'connect'` event, an `'error'` event will be emitted with 
         * the error passed to the `'error'` listener. 
         * The last parameter `connectListener`, if supplied, will be added as a listener 
         * for the `'connect'` event **once**. 
         * 
         * This function should only be used for reconnecting a socket after`'close'` has been emitted or otherwise it may lead to undefined 
         * behavior. 
         */</span>
        <span class="s3">connect(</span><span class="s1">options</span><span class="s2">: </span><span class="s1">SocketConnectOpts</span><span class="s3">, </span><span class="s6">connectionListener</span><span class="s2">?: </span><span class="s3">() </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">connect(</span><span class="s1">port</span><span class="s2">: </span><span class="s1">number</span><span class="s3">, </span><span class="s1">host</span><span class="s2">: </span><span class="s1">string</span><span class="s3">, </span><span class="s6">connectionListener</span><span class="s2">?: </span><span class="s3">() </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">connect(</span><span class="s1">port</span><span class="s2">: </span><span class="s1">number</span><span class="s3">, </span><span class="s6">connectionListener</span><span class="s2">?: </span><span class="s3">() </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">connect(</span><span class="s1">path</span><span class="s2">: </span><span class="s1">string</span><span class="s3">, </span><span class="s6">connectionListener</span><span class="s2">?: </span><span class="s3">() </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Set the encoding for the socket as a `Readable Stream`. See `readable.setEncoding()` for more information. 
         * </span><span class="s2">@since </span><span class="s0">v0.1.90 
         * </span><span class="s2">@return </span><span class="s0">The socket itself. 
         */</span>
        <span class="s3">setEncoding(</span><span class="s1">encoding</span><span class="s2">?: </span><span class="s1">BufferEncoding</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Pauses the reading of data. That is, `'data'` events will not be emitted. 
         * Useful to throttle back an upload. 
         * </span><span class="s2">@return </span><span class="s0">The socket itself. 
         */</span>
        <span class="s3">pause()</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Close the TCP connection by sending an RST packet and destroy the stream. 
         * If this TCP socket is in connecting status, it will send an RST packet and destroy this TCP socket once it is connected. 
         * Otherwise, it will call `socket.destroy` with an `ERR_SOCKET_CLOSED` Error. 
         * If this is not a TCP socket (for example, a pipe), calling this method will immediately throw an `ERR_INVALID_HANDLE_TYPE` Error. 
         * </span><span class="s2">@since </span><span class="s0">v18.3.0, v16.17.0 
         */</span>
        <span class="s3">resetAndDestroy()</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Resumes reading after a call to `socket.pause()`. 
         * </span><span class="s2">@return </span><span class="s0">The socket itself. 
         */</span>
        <span class="s3">resume()</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Sets the socket to timeout after `timeout` milliseconds of inactivity on 
         * the socket. By default `net.Socket` do not have a timeout. 
         * 
         * When an idle timeout is triggered the socket will receive a `'timeout'` event but the connection will not be severed. The user must manually call `socket.end()` or `socket.destroy()` to 
         * end the connection. 
         * 
         * ```js 
         * socket.setTimeout(3000); 
         * socket.on('timeout', () =&gt; { 
         *   console.log('socket timeout'); 
         *   socket.end(); 
         * }); 
         * ``` 
         * 
         * If `timeout` is 0, then the existing idle timeout is disabled. 
         * 
         * The optional `callback` parameter will be added as a one-time listener for the `'timeout'` event. 
         * </span><span class="s2">@since </span><span class="s0">v0.1.90 
         * </span><span class="s2">@return </span><span class="s0">The socket itself. 
         */</span>
        <span class="s3">setTimeout(</span><span class="s1">timeout</span><span class="s2">: </span><span class="s1">number</span><span class="s3">, </span><span class="s6">callback</span><span class="s2">?: </span><span class="s3">() </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Enable/disable the use of Nagle's algorithm. 
         * 
         * When a TCP connection is created, it will have Nagle's algorithm enabled. 
         * 
         * Nagle's algorithm delays data before it is sent via the network. It attempts 
         * to optimize throughput at the expense of latency. 
         * 
         * Passing `true` for `noDelay` or not passing an argument will disable Nagle's 
         * algorithm for the socket. Passing `false` for `noDelay` will enable Nagle's 
         * algorithm. 
         * </span><span class="s2">@since </span><span class="s0">v0.1.90 
         * </span><span class="s2">@param </span><span class="s0">[noDelay=true] 
         * </span><span class="s2">@return </span><span class="s0">The socket itself. 
         */</span>
        <span class="s3">setNoDelay(</span><span class="s1">noDelay</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Enable/disable keep-alive functionality, and optionally set the initial 
         * delay before the first keepalive probe is sent on an idle socket. 
         * 
         * Set `initialDelay` (in milliseconds) to set the delay between the last 
         * data packet received and the first keepalive probe. Setting `0` for`initialDelay` will leave the value unchanged from the default 
         * (or previous) setting. 
         * 
         * Enabling the keep-alive functionality will set the following socket options: 
         * 
         * * `SO_KEEPALIVE=1` 
         * * `TCP_KEEPIDLE=initialDelay` 
         * * `TCP_KEEPCNT=10` 
         * * `TCP_KEEPINTVL=1` 
         * </span><span class="s2">@since </span><span class="s0">v0.1.92 
         * </span><span class="s2">@param </span><span class="s0">[enable=false] 
         * </span><span class="s2">@param </span><span class="s0">[initialDelay=0] 
         * </span><span class="s2">@return </span><span class="s0">The socket itself. 
         */</span>
        <span class="s3">setKeepAlive(</span><span class="s1">enable</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s3">, </span><span class="s1">initialDelay</span><span class="s2">?: </span><span class="s1">number</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns the bound `address`, the address `family` name and `port` of the 
         * socket as reported by the operating system:`{ port: 12346, family: 'IPv4', address: '127.0.0.1' }` 
         * </span><span class="s2">@since </span><span class="s0">v0.1.90 
         */</span>
        <span class="s3">address()</span><span class="s2">: </span><span class="s1">AddressInfo </span><span class="s2">| </span><span class="s3">{};</span>
        <span class="s0">/**</span>
         <span class="s0">* Calling `unref()` on a socket will allow the program to exit if this is the only 
         * active socket in the event system. If the socket is already `unref`ed calling`unref()` again will have no effect. 
         * </span><span class="s2">@since </span><span class="s0">v0.9.1 
         * </span><span class="s2">@return </span><span class="s0">The socket itself. 
         */</span>
        <span class="s3">unref()</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Opposite of `unref()`, calling `ref()` on a previously `unref`ed socket will _not_ let the program exit if it's the only socket left (the default behavior). 
         * If the socket is `ref`ed calling `ref` again will have no effect. 
         * </span><span class="s2">@since </span><span class="s0">v0.9.1 
         * </span><span class="s2">@return </span><span class="s0">The socket itself. 
         */</span>
        <span class="s3">ref()</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This property shows the number of characters buffered for writing. The buffer 
         * may contain strings whose length after encoding is not yet known. So this number 
         * is only an approximation of the number of bytes in the buffer. 
         * 
         * `net.Socket` has the property that `socket.write()` always works. This is to 
         * help users get up and running quickly. The computer cannot always keep up 
         * with the amount of data that is written to a socket. The network connection 
         * simply might be too slow. Node.js will internally queue up the data written to a 
         * socket and send it out over the wire when it is possible. 
         * 
         * The consequence of this internal buffering is that memory may grow. 
         * Users who experience large or growing `bufferSize` should attempt to 
         * &quot;throttle&quot; the data flows in their program with `socket.pause()` and `socket.resume()`. 
         * </span><span class="s2">@since </span><span class="s0">v0.3.8 
         * </span><span class="s2">@deprecated </span><span class="s0">Since v14.6.0 - Use `writableLength` instead. 
         */</span>
        <span class="s2">readonly </span><span class="s3">bufferSize</span><span class="s2">: </span><span class="s1">number</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The amount of received bytes. 
         * </span><span class="s2">@since </span><span class="s0">v0.5.3 
         */</span>
        <span class="s2">readonly </span><span class="s3">bytesRead</span><span class="s2">: </span><span class="s1">number</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The amount of bytes sent. 
         * </span><span class="s2">@since </span><span class="s0">v0.5.3 
         */</span>
        <span class="s2">readonly </span><span class="s3">bytesWritten</span><span class="s2">: </span><span class="s1">number</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If `true`,`socket.connect(options[, connectListener])` was 
         * called and has not yet finished. It will stay `true` until the socket becomes 
         * connected, then it is set to `false` and the `'connect'` event is emitted. Note 
         * that the `socket.connect(options[, connectListener])` callback is a listener for the `'connect'` event. 
         * </span><span class="s2">@since </span><span class="s0">v6.1.0 
         */</span>
        <span class="s2">readonly </span><span class="s3">connecting</span><span class="s2">: </span><span class="s1">boolean</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This is `true` if the socket is not connected yet, either because `.connect()`has not yet been called or because it is still in the process of connecting 
         * (see `socket.connecting`). 
         * </span><span class="s2">@since </span><span class="s0">v11.2.0, v10.16.0 
         */</span>
        <span class="s2">readonly </span><span class="s3">pending</span><span class="s2">: </span><span class="s1">boolean</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* See `writable.destroyed` for further details. 
         */</span>
        <span class="s2">readonly </span><span class="s3">destroyed</span><span class="s2">: </span><span class="s1">boolean</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The string representation of the local IP address the remote client is 
         * connecting on. For example, in a server listening on `'0.0.0.0'`, if a client 
         * connects on `'192.168.1.1'`, the value of `socket.localAddress` would be`'192.168.1.1'`. 
         * </span><span class="s2">@since </span><span class="s0">v0.9.6 
         */</span>
        <span class="s2">readonly </span><span class="s3">localAddress</span><span class="s2">?: </span><span class="s1">string</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The numeric representation of the local port. For example, `80` or `21`. 
         * </span><span class="s2">@since </span><span class="s0">v0.9.6 
         */</span>
        <span class="s2">readonly </span><span class="s3">localPort</span><span class="s2">?: </span><span class="s1">number</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The string representation of the local IP family. `'IPv4'` or `'IPv6'`. 
         * </span><span class="s2">@since </span><span class="s0">v18.8.0, v16.18.0 
         */</span>
        <span class="s2">readonly </span><span class="s3">localFamily</span><span class="s2">?: </span><span class="s1">string</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This property represents the state of the connection as a string. 
         * 
         * * If the stream is connecting `socket.readyState` is `opening`. 
         * * If the stream is readable and writable, it is `open`. 
         * * If the stream is readable and not writable, it is `readOnly`. 
         * * If the stream is not readable and writable, it is `writeOnly`. 
         * </span><span class="s2">@since </span><span class="s0">v0.5.0 
         */</span>
        <span class="s2">readonly </span><span class="s3">readyState</span><span class="s2">: </span><span class="s1">SocketReadyState</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The string representation of the remote IP address. For example,`'74.125.127.100'` or `'2001:4860:a005::68'`. Value may be `undefined` if 
         * the socket is destroyed (for example, if the client disconnected). 
         * </span><span class="s2">@since </span><span class="s0">v0.5.10 
         */</span>
        <span class="s2">readonly </span><span class="s3">remoteAddress</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The string representation of the remote IP family. `'IPv4'` or `'IPv6'`. Value may be `undefined` if 
         * the socket is destroyed (for example, if the client disconnected). 
         * </span><span class="s2">@since </span><span class="s0">v0.11.14 
         */</span>
        <span class="s2">readonly </span><span class="s3">remoteFamily</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The numeric representation of the remote port. For example, `80` or `21`. Value may be `undefined` if 
         * the socket is destroyed (for example, if the client disconnected). 
         * </span><span class="s2">@since </span><span class="s0">v0.5.10 
         */</span>
        <span class="s2">readonly </span><span class="s3">remotePort</span><span class="s2">?: </span><span class="s1">number </span><span class="s2">| </span><span class="s1">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The socket timeout in milliseconds as set by `socket.setTimeout()`. 
         * It is `undefined` if a timeout has not been set. 
         * </span><span class="s2">@since </span><span class="s0">v10.7.0 
         */</span>
        <span class="s2">readonly </span><span class="s3">timeout</span><span class="s2">?: </span><span class="s1">number </span><span class="s2">| </span><span class="s1">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Half-closes the socket. i.e., it sends a FIN packet. It is possible the 
         * server will still send some data. 
         * 
         * See `writable.end()` for further details. 
         * </span><span class="s2">@since </span><span class="s0">v0.1.90 
         * </span><span class="s2">@param </span><span class="s0">[encoding='utf8'] Only used when data is `string`. 
         * </span><span class="s2">@param </span><span class="s1">callback </span><span class="s0">Optional callback for when the socket is finished. 
         * </span><span class="s2">@return </span><span class="s0">The socket itself. 
         */</span>
        <span class="s3">end(</span><span class="s6">callback</span><span class="s2">?: </span><span class="s3">() </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">end(</span><span class="s1">buffer</span><span class="s2">: </span><span class="s1">Uint8Array </span><span class="s2">| </span><span class="s1">string</span><span class="s3">, </span><span class="s6">callback</span><span class="s2">?: </span><span class="s3">() </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">end(</span><span class="s1">str</span><span class="s2">: </span><span class="s1">Uint8Array </span><span class="s2">| </span><span class="s1">string</span><span class="s3">, </span><span class="s1">encoding</span><span class="s2">?: </span><span class="s1">BufferEncoding</span><span class="s3">, </span><span class="s6">callback</span><span class="s2">?: </span><span class="s3">() </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* events.EventEmitter 
         *   1. close 
         *   2. connect 
         *   3. data 
         *   4. drain 
         *   5. end 
         *   6. error 
         *   7. lookup 
         *   8. ready 
         *   9. timeout 
         */</span>
        <span class="s3">addListener(</span><span class="s1">event</span><span class="s2">: </span><span class="s1">string</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">(</span><span class="s2">...</span><span class="s1">args</span><span class="s2">: </span><span class="s1">any</span><span class="s3">[]) </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">addListener(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'close'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">(</span><span class="s1">hadError</span><span class="s2">: </span><span class="s1">boolean</span><span class="s3">) </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">addListener(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'connect'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">() </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">addListener(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'data'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">(</span><span class="s1">data</span><span class="s2">: </span><span class="s1">Buffer</span><span class="s3">) </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">addListener(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'drain'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">() </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">addListener(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'end'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">() </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">addListener(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'error'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">(</span><span class="s1">err</span><span class="s2">: </span><span class="s1">Error</span><span class="s3">) </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">addListener(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'lookup'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">(</span><span class="s1">err</span><span class="s2">: </span><span class="s1">Error</span><span class="s3">, </span><span class="s1">address</span><span class="s2">: </span><span class="s1">string</span><span class="s3">, </span><span class="s1">family</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">number</span><span class="s3">, </span><span class="s1">host</span><span class="s2">: </span><span class="s1">string</span><span class="s3">) </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">addListener(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'ready'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">() </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">addListener(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'timeout'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">() </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">emit(</span><span class="s1">event</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">symbol</span><span class="s3">, </span><span class="s2">...</span><span class="s1">args</span><span class="s2">: </span><span class="s1">any</span><span class="s3">[])</span><span class="s2">: </span><span class="s1">boolean</span><span class="s3">;</span>
        <span class="s3">emit(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'close'</span><span class="s3">, </span><span class="s1">hadError</span><span class="s2">: </span><span class="s1">boolean</span><span class="s3">)</span><span class="s2">: </span><span class="s1">boolean</span><span class="s3">;</span>
        <span class="s3">emit(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'connect'</span><span class="s3">)</span><span class="s2">: </span><span class="s1">boolean</span><span class="s3">;</span>
        <span class="s3">emit(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'data'</span><span class="s3">, </span><span class="s1">data</span><span class="s2">: </span><span class="s1">Buffer</span><span class="s3">)</span><span class="s2">: </span><span class="s1">boolean</span><span class="s3">;</span>
        <span class="s3">emit(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'drain'</span><span class="s3">)</span><span class="s2">: </span><span class="s1">boolean</span><span class="s3">;</span>
        <span class="s3">emit(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'end'</span><span class="s3">)</span><span class="s2">: </span><span class="s1">boolean</span><span class="s3">;</span>
        <span class="s3">emit(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'error'</span><span class="s3">, </span><span class="s1">err</span><span class="s2">: </span><span class="s1">Error</span><span class="s3">)</span><span class="s2">: </span><span class="s1">boolean</span><span class="s3">;</span>
        <span class="s3">emit(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'lookup'</span><span class="s3">, </span><span class="s1">err</span><span class="s2">: </span><span class="s1">Error</span><span class="s3">, </span><span class="s1">address</span><span class="s2">: </span><span class="s1">string</span><span class="s3">, </span><span class="s1">family</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">number</span><span class="s3">, </span><span class="s1">host</span><span class="s2">: </span><span class="s1">string</span><span class="s3">)</span><span class="s2">: </span><span class="s1">boolean</span><span class="s3">;</span>
        <span class="s3">emit(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'ready'</span><span class="s3">)</span><span class="s2">: </span><span class="s1">boolean</span><span class="s3">;</span>
        <span class="s3">emit(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'timeout'</span><span class="s3">)</span><span class="s2">: </span><span class="s1">boolean</span><span class="s3">;</span>
        <span class="s3">on(</span><span class="s1">event</span><span class="s2">: </span><span class="s1">string</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">(</span><span class="s2">...</span><span class="s1">args</span><span class="s2">: </span><span class="s1">any</span><span class="s3">[]) </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">on(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'close'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">(</span><span class="s1">hadError</span><span class="s2">: </span><span class="s1">boolean</span><span class="s3">) </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">on(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'connect'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">() </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">on(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'data'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">(</span><span class="s1">data</span><span class="s2">: </span><span class="s1">Buffer</span><span class="s3">) </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">on(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'drain'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">() </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">on(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'end'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">() </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">on(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'error'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">(</span><span class="s1">err</span><span class="s2">: </span><span class="s1">Error</span><span class="s3">) </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">on(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'lookup'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">(</span><span class="s1">err</span><span class="s2">: </span><span class="s1">Error</span><span class="s3">, </span><span class="s1">address</span><span class="s2">: </span><span class="s1">string</span><span class="s3">, </span><span class="s1">family</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">number</span><span class="s3">, </span><span class="s1">host</span><span class="s2">: </span><span class="s1">string</span><span class="s3">) </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">on(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'ready'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">() </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">on(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'timeout'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">() </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">once(</span><span class="s1">event</span><span class="s2">: </span><span class="s1">string</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">(</span><span class="s2">...</span><span class="s1">args</span><span class="s2">: </span><span class="s1">any</span><span class="s3">[]) </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">once(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'close'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">(</span><span class="s1">hadError</span><span class="s2">: </span><span class="s1">boolean</span><span class="s3">) </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">once(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'connect'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">() </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">once(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'data'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">(</span><span class="s1">data</span><span class="s2">: </span><span class="s1">Buffer</span><span class="s3">) </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">once(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'drain'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">() </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">once(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'end'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">() </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">once(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'error'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">(</span><span class="s1">err</span><span class="s2">: </span><span class="s1">Error</span><span class="s3">) </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">once(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'lookup'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">(</span><span class="s1">err</span><span class="s2">: </span><span class="s1">Error</span><span class="s3">, </span><span class="s1">address</span><span class="s2">: </span><span class="s1">string</span><span class="s3">, </span><span class="s1">family</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">number</span><span class="s3">, </span><span class="s1">host</span><span class="s2">: </span><span class="s1">string</span><span class="s3">) </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">once(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'ready'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">() </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">once(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'timeout'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">() </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">prependListener(</span><span class="s1">event</span><span class="s2">: </span><span class="s1">string</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">(</span><span class="s2">...</span><span class="s1">args</span><span class="s2">: </span><span class="s1">any</span><span class="s3">[]) </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">prependListener(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'close'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">(</span><span class="s1">hadError</span><span class="s2">: </span><span class="s1">boolean</span><span class="s3">) </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">prependListener(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'connect'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">() </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">prependListener(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'data'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">(</span><span class="s1">data</span><span class="s2">: </span><span class="s1">Buffer</span><span class="s3">) </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">prependListener(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'drain'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">() </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">prependListener(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'end'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">() </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">prependListener(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'error'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">(</span><span class="s1">err</span><span class="s2">: </span><span class="s1">Error</span><span class="s3">) </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">prependListener(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'lookup'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">(</span><span class="s1">err</span><span class="s2">: </span><span class="s1">Error</span><span class="s3">, </span><span class="s1">address</span><span class="s2">: </span><span class="s1">string</span><span class="s3">, </span><span class="s1">family</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">number</span><span class="s3">, </span><span class="s1">host</span><span class="s2">: </span><span class="s1">string</span><span class="s3">) </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">prependListener(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'ready'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">() </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">prependListener(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'timeout'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">() </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">prependOnceListener(</span><span class="s1">event</span><span class="s2">: </span><span class="s1">string</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">(</span><span class="s2">...</span><span class="s1">args</span><span class="s2">: </span><span class="s1">any</span><span class="s3">[]) </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">prependOnceListener(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'close'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">(</span><span class="s1">hadError</span><span class="s2">: </span><span class="s1">boolean</span><span class="s3">) </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">prependOnceListener(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'connect'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">() </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">prependOnceListener(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'data'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">(</span><span class="s1">data</span><span class="s2">: </span><span class="s1">Buffer</span><span class="s3">) </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">prependOnceListener(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'drain'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">() </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">prependOnceListener(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'end'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">() </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">prependOnceListener(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'error'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">(</span><span class="s1">err</span><span class="s2">: </span><span class="s1">Error</span><span class="s3">) </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">prependOnceListener(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'lookup'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">(</span><span class="s1">err</span><span class="s2">: </span><span class="s1">Error</span><span class="s3">, </span><span class="s1">address</span><span class="s2">: </span><span class="s1">string</span><span class="s3">, </span><span class="s1">family</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">number</span><span class="s3">, </span><span class="s1">host</span><span class="s2">: </span><span class="s1">string</span><span class="s3">) </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">prependOnceListener(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'ready'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">() </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">prependOnceListener(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'timeout'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">() </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s2">interface </span><span class="s1">ListenOptions </span><span class="s2">extends </span><span class="s1">Abortable </span><span class="s3">{</span>
        <span class="s3">port</span><span class="s2">?: </span><span class="s1">number </span><span class="s2">| </span><span class="s1">undefined</span><span class="s3">;</span>
        <span class="s3">host</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">undefined</span><span class="s3">;</span>
        <span class="s3">backlog</span><span class="s2">?: </span><span class="s1">number </span><span class="s2">| </span><span class="s1">undefined</span><span class="s3">;</span>
        <span class="s3">path</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">undefined</span><span class="s3">;</span>
        <span class="s3">exclusive</span><span class="s2">?: </span><span class="s1">boolean </span><span class="s2">| </span><span class="s1">undefined</span><span class="s3">;</span>
        <span class="s3">readableAll</span><span class="s2">?: </span><span class="s1">boolean </span><span class="s2">| </span><span class="s1">undefined</span><span class="s3">;</span>
        <span class="s3">writableAll</span><span class="s2">?: </span><span class="s1">boolean </span><span class="s2">| </span><span class="s1">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@default </span><span class="s1">false</span>
         <span class="s0">*/</span>
        <span class="s3">ipv6Only</span><span class="s2">?: </span><span class="s1">boolean </span><span class="s2">| </span><span class="s1">undefined</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s2">interface </span><span class="s1">ServerOpts </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Indicates whether half-opened TCP connections are allowed. 
         * </span><span class="s2">@default </span><span class="s1">false</span>
         <span class="s0">*/</span>
        <span class="s3">allowHalfOpen</span><span class="s2">?: </span><span class="s1">boolean </span><span class="s2">| </span><span class="s1">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Indicates whether the socket should be paused on incoming connections. 
         * </span><span class="s2">@default </span><span class="s1">false</span>
         <span class="s0">*/</span>
        <span class="s3">pauseOnConnect</span><span class="s2">?: </span><span class="s1">boolean </span><span class="s2">| </span><span class="s1">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If set to `true`, it disables the use of Nagle's algorithm immediately after a new incoming connection is received. 
         * </span><span class="s2">@default </span><span class="s1">false</span>
         <span class="s0">* </span><span class="s2">@since </span><span class="s0">v16.5.0 
         */</span>
        <span class="s3">noDelay</span><span class="s2">?: </span><span class="s1">boolean </span><span class="s2">| </span><span class="s1">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If set to `true`, it enables keep-alive functionality on the socket immediately after a new incoming connection is received, 
         * similarly on what is done in `socket.setKeepAlive([enable][, initialDelay])`. 
         * </span><span class="s2">@default </span><span class="s1">false</span>
         <span class="s0">* </span><span class="s2">@since </span><span class="s0">v16.5.0 
         */</span>
        <span class="s3">keepAlive</span><span class="s2">?: </span><span class="s1">boolean </span><span class="s2">| </span><span class="s1">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If set to a positive number, it sets the initial delay before the first keepalive probe is sent on an idle socket. 
         * </span><span class="s2">@default </span><span class="s1">0</span>
         <span class="s0">* </span><span class="s2">@since </span><span class="s0">v16.5.0 
         */</span>
        <span class="s3">keepAliveInitialDelay</span><span class="s2">?: </span><span class="s1">number </span><span class="s2">| </span><span class="s1">undefined</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s2">interface </span><span class="s1">DropArgument </span><span class="s3">{</span>
        <span class="s3">localAddress</span><span class="s2">?: </span><span class="s1">string</span><span class="s3">;</span>
        <span class="s3">localPort</span><span class="s2">?: </span><span class="s1">number</span><span class="s3">;</span>
        <span class="s3">localFamily</span><span class="s2">?: </span><span class="s1">string</span><span class="s3">;</span>
        <span class="s3">remoteAddress</span><span class="s2">?: </span><span class="s1">string</span><span class="s3">;</span>
        <span class="s3">remotePort</span><span class="s2">?: </span><span class="s1">number</span><span class="s3">;</span>
        <span class="s3">remoteFamily</span><span class="s2">?: </span><span class="s1">string</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s0">/**</span>
     <span class="s0">* This class is used to create a TCP or `IPC` server. 
     * </span><span class="s2">@since </span><span class="s0">v0.1.90 
     */</span>
    <span class="s2">class </span><span class="s1">Server </span><span class="s2">extends </span><span class="s1">EventEmitter </span><span class="s3">{</span>
        <span class="s2">constructor</span><span class="s3">(</span><span class="s6">connectionListener</span><span class="s2">?: </span><span class="s3">(</span><span class="s1">socket</span><span class="s2">: </span><span class="s1">Socket</span><span class="s3">) </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">);</span>
        <span class="s2">constructor</span><span class="s3">(</span><span class="s1">options</span><span class="s2">?: </span><span class="s1">ServerOpts</span><span class="s3">, </span><span class="s6">connectionListener</span><span class="s2">?: </span><span class="s3">(</span><span class="s1">socket</span><span class="s2">: </span><span class="s1">Socket</span><span class="s3">) </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">);</span>
        <span class="s0">/**</span>
         <span class="s0">* Start a server listening for connections. A `net.Server` can be a TCP or 
         * an `IPC` server depending on what it listens to. 
         * 
         * Possible signatures: 
         * 
         * * `server.listen(handle[, backlog][, callback])` 
         * * `server.listen(options[, callback])` 
         * * `server.listen(path[, backlog][, callback])` for `IPC` servers 
         * * `server.listen([port[, host[, backlog]]][, callback])` for TCP servers 
         * 
         * This function is asynchronous. When the server starts listening, the `'listening'` event will be emitted. The last parameter `callback`will be added as a listener for the `'listening'` 
         * event. 
         * 
         * All `listen()` methods can take a `backlog` parameter to specify the maximum 
         * length of the queue of pending connections. The actual length will be determined 
         * by the OS through sysctl settings such as `tcp_max_syn_backlog` and `somaxconn`on Linux. The default value of this parameter is 511 (not 512). 
         * 
         * All </span><span class="s1">{</span><span class="s2">@link </span><span class="s1">Socket} </span><span class="s0">are set to `SO_REUSEADDR` (see [`socket(7)`](https://man7.org/linux/man-pages/man7/socket.7.html) for 
         * details). 
         * 
         * The `server.listen()` method can be called again if and only if there was an 
         * error during the first `server.listen()` call or `server.close()` has been 
         * called. Otherwise, an `ERR_SERVER_ALREADY_LISTEN` error will be thrown. 
         * 
         * One of the most common errors raised when listening is `EADDRINUSE`. 
         * This happens when another server is already listening on the requested`port`/`path`/`handle`. One way to handle this would be to retry 
         * after a certain amount of time: 
         * 
         * ```js 
         * server.on('error', (e) =&gt; { 
         *   if (e.code === 'EADDRINUSE') { 
         *     console.error('Address in use, retrying...'); 
         *     setTimeout(() =&gt; { 
         *       server.close(); 
         *       server.listen(PORT, HOST); 
         *     }, 1000); 
         *   } 
         * }); 
         * ``` 
         */</span>
        <span class="s3">listen(</span><span class="s1">port</span><span class="s2">?: </span><span class="s1">number</span><span class="s3">, </span><span class="s1">hostname</span><span class="s2">?: </span><span class="s1">string</span><span class="s3">, </span><span class="s1">backlog</span><span class="s2">?: </span><span class="s1">number</span><span class="s3">, </span><span class="s6">listeningListener</span><span class="s2">?: </span><span class="s3">() </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">listen(</span><span class="s1">port</span><span class="s2">?: </span><span class="s1">number</span><span class="s3">, </span><span class="s1">hostname</span><span class="s2">?: </span><span class="s1">string</span><span class="s3">, </span><span class="s6">listeningListener</span><span class="s2">?: </span><span class="s3">() </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">listen(</span><span class="s1">port</span><span class="s2">?: </span><span class="s1">number</span><span class="s3">, </span><span class="s1">backlog</span><span class="s2">?: </span><span class="s1">number</span><span class="s3">, </span><span class="s6">listeningListener</span><span class="s2">?: </span><span class="s3">() </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">listen(</span><span class="s1">port</span><span class="s2">?: </span><span class="s1">number</span><span class="s3">, </span><span class="s6">listeningListener</span><span class="s2">?: </span><span class="s3">() </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">listen(</span><span class="s1">path</span><span class="s2">: </span><span class="s1">string</span><span class="s3">, </span><span class="s1">backlog</span><span class="s2">?: </span><span class="s1">number</span><span class="s3">, </span><span class="s6">listeningListener</span><span class="s2">?: </span><span class="s3">() </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">listen(</span><span class="s1">path</span><span class="s2">: </span><span class="s1">string</span><span class="s3">, </span><span class="s6">listeningListener</span><span class="s2">?: </span><span class="s3">() </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">listen(</span><span class="s1">options</span><span class="s2">: </span><span class="s1">ListenOptions</span><span class="s3">, </span><span class="s6">listeningListener</span><span class="s2">?: </span><span class="s3">() </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">listen(</span><span class="s1">handle</span><span class="s2">: </span><span class="s1">any</span><span class="s3">, </span><span class="s1">backlog</span><span class="s2">?: </span><span class="s1">number</span><span class="s3">, </span><span class="s6">listeningListener</span><span class="s2">?: </span><span class="s3">() </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">listen(</span><span class="s1">handle</span><span class="s2">: </span><span class="s1">any</span><span class="s3">, </span><span class="s6">listeningListener</span><span class="s2">?: </span><span class="s3">() </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Stops the server from accepting new connections and keeps existing 
         * connections. This function is asynchronous, the server is finally closed 
         * when all connections are ended and the server emits a `'close'` event. 
         * The optional `callback` will be called once the `'close'` event occurs. Unlike 
         * that event, it will be called with an `Error` as its only argument if the server 
         * was not open when it was closed. 
         * </span><span class="s2">@since </span><span class="s0">v0.1.90 
         * </span><span class="s2">@param </span><span class="s1">callback </span><span class="s0">Called when the server is closed. 
         */</span>
        <span class="s3">close(</span><span class="s6">callback</span><span class="s2">?: </span><span class="s3">(</span><span class="s1">err</span><span class="s2">?: </span><span class="s1">Error</span><span class="s3">) </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns the bound `address`, the address `family` name, and `port` of the server 
         * as reported by the operating system if listening on an IP socket 
         * (useful to find which port was assigned when getting an OS-assigned address):`{ port: 12346, family: 'IPv4', address: '127.0.0.1' }`. 
         * 
         * For a server listening on a pipe or Unix domain socket, the name is returned 
         * as a string. 
         * 
         * ```js 
         * const server = net.createServer((socket) =&gt; { 
         *   socket.end('goodbye\n'); 
         * }).on('error', (err) =&gt; { 
         *   // Handle errors here. 
         *   throw err; 
         * }); 
         * 
         * // Grab an arbitrary unused port. 
         * server.listen(() =&gt; { 
         *   console.log('opened server on', server.address()); 
         * }); 
         * ``` 
         * 
         * `server.address()` returns `null` before the `'listening'` event has been 
         * emitted or after calling `server.close()`. 
         * </span><span class="s2">@since </span><span class="s0">v0.1.90 
         */</span>
        <span class="s3">address()</span><span class="s2">: </span><span class="s1">AddressInfo </span><span class="s2">| </span><span class="s1">string </span><span class="s2">| </span><span class="s1">null</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Asynchronously get the number of concurrent connections on the server. Works 
         * when sockets were sent to forks. 
         * 
         * Callback should take two arguments `err` and `count`. 
         * </span><span class="s2">@since </span><span class="s0">v0.9.7 
         */</span>
        <span class="s3">getConnections(</span><span class="s6">cb</span><span class="s2">: </span><span class="s3">(</span><span class="s1">error</span><span class="s2">: </span><span class="s1">Error </span><span class="s2">| </span><span class="s1">null</span><span class="s3">, </span><span class="s1">count</span><span class="s2">: </span><span class="s1">number</span><span class="s3">) </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">void</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Opposite of `unref()`, calling `ref()` on a previously `unref`ed server will _not_ let the program exit if it's the only server left (the default behavior). 
         * If the server is `ref`ed calling `ref()` again will have no effect. 
         * </span><span class="s2">@since </span><span class="s0">v0.9.1 
         */</span>
        <span class="s3">ref()</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Calling `unref()` on a server will allow the program to exit if this is the only 
         * active server in the event system. If the server is already `unref`ed calling`unref()` again will have no effect. 
         * </span><span class="s2">@since </span><span class="s0">v0.9.1 
         */</span>
        <span class="s3">unref()</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Set this property to reject connections when the server's connection count gets 
         * high. 
         * 
         * It is not recommended to use this option once a socket has been sent to a child 
         * with `child_process.fork()`. 
         * </span><span class="s2">@since </span><span class="s0">v0.2.0 
         */</span>
        <span class="s3">maxConnections</span><span class="s2">: </span><span class="s1">number</span><span class="s3">;</span>
        <span class="s3">connections</span><span class="s2">: </span><span class="s1">number</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Indicates whether or not the server is listening for connections. 
         * </span><span class="s2">@since </span><span class="s0">v5.7.0 
         */</span>
        <span class="s3">listening</span><span class="s2">: </span><span class="s1">boolean</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* events.EventEmitter 
         *   1. close 
         *   2. connection 
         *   3. error 
         *   4. listening 
         *   5. drop 
         */</span>
        <span class="s3">addListener(</span><span class="s1">event</span><span class="s2">: </span><span class="s1">string</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">(</span><span class="s2">...</span><span class="s1">args</span><span class="s2">: </span><span class="s1">any</span><span class="s3">[]) </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">addListener(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'close'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">() </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">addListener(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'connection'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">(</span><span class="s1">socket</span><span class="s2">: </span><span class="s1">Socket</span><span class="s3">) </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">addListener(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'error'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">(</span><span class="s1">err</span><span class="s2">: </span><span class="s1">Error</span><span class="s3">) </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">addListener(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'listening'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">() </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">addListener(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'drop'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">(</span><span class="s1">data</span><span class="s2">?: </span><span class="s1">DropArgument</span><span class="s3">) </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">emit(</span><span class="s1">event</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">symbol</span><span class="s3">, </span><span class="s2">...</span><span class="s1">args</span><span class="s2">: </span><span class="s1">any</span><span class="s3">[])</span><span class="s2">: </span><span class="s1">boolean</span><span class="s3">;</span>
        <span class="s3">emit(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'close'</span><span class="s3">)</span><span class="s2">: </span><span class="s1">boolean</span><span class="s3">;</span>
        <span class="s3">emit(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'connection'</span><span class="s3">, </span><span class="s1">socket</span><span class="s2">: </span><span class="s1">Socket</span><span class="s3">)</span><span class="s2">: </span><span class="s1">boolean</span><span class="s3">;</span>
        <span class="s3">emit(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'error'</span><span class="s3">, </span><span class="s1">err</span><span class="s2">: </span><span class="s1">Error</span><span class="s3">)</span><span class="s2">: </span><span class="s1">boolean</span><span class="s3">;</span>
        <span class="s3">emit(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'listening'</span><span class="s3">)</span><span class="s2">: </span><span class="s1">boolean</span><span class="s3">;</span>
        <span class="s3">emit(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'drop'</span><span class="s3">, </span><span class="s1">data</span><span class="s2">?: </span><span class="s1">DropArgument</span><span class="s3">)</span><span class="s2">: </span><span class="s1">boolean</span><span class="s3">;</span>
        <span class="s3">on(</span><span class="s1">event</span><span class="s2">: </span><span class="s1">string</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">(</span><span class="s2">...</span><span class="s1">args</span><span class="s2">: </span><span class="s1">any</span><span class="s3">[]) </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">on(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'close'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">() </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">on(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'connection'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">(</span><span class="s1">socket</span><span class="s2">: </span><span class="s1">Socket</span><span class="s3">) </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">on(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'error'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">(</span><span class="s1">err</span><span class="s2">: </span><span class="s1">Error</span><span class="s3">) </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">on(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'listening'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">() </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">on(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'drop'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">(</span><span class="s1">data</span><span class="s2">?: </span><span class="s1">DropArgument</span><span class="s3">) </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">once(</span><span class="s1">event</span><span class="s2">: </span><span class="s1">string</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">(</span><span class="s2">...</span><span class="s1">args</span><span class="s2">: </span><span class="s1">any</span><span class="s3">[]) </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">once(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'close'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">() </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">once(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'connection'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">(</span><span class="s1">socket</span><span class="s2">: </span><span class="s1">Socket</span><span class="s3">) </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">once(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'error'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">(</span><span class="s1">err</span><span class="s2">: </span><span class="s1">Error</span><span class="s3">) </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">once(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'listening'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">() </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">once(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'drop'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">(</span><span class="s1">data</span><span class="s2">?: </span><span class="s1">DropArgument</span><span class="s3">) </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">prependListener(</span><span class="s1">event</span><span class="s2">: </span><span class="s1">string</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">(</span><span class="s2">...</span><span class="s1">args</span><span class="s2">: </span><span class="s1">any</span><span class="s3">[]) </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">prependListener(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'close'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">() </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">prependListener(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'connection'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">(</span><span class="s1">socket</span><span class="s2">: </span><span class="s1">Socket</span><span class="s3">) </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">prependListener(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'error'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">(</span><span class="s1">err</span><span class="s2">: </span><span class="s1">Error</span><span class="s3">) </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">prependListener(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'listening'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">() </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">prependListener(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'drop'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">(</span><span class="s1">data</span><span class="s2">?: </span><span class="s1">DropArgument</span><span class="s3">) </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">prependOnceListener(</span><span class="s1">event</span><span class="s2">: </span><span class="s1">string</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">(</span><span class="s2">...</span><span class="s1">args</span><span class="s2">: </span><span class="s1">any</span><span class="s3">[]) </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">prependOnceListener(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'close'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">() </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">prependOnceListener(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'connection'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">(</span><span class="s1">socket</span><span class="s2">: </span><span class="s1">Socket</span><span class="s3">) </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">prependOnceListener(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'error'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">(</span><span class="s1">err</span><span class="s2">: </span><span class="s1">Error</span><span class="s3">) </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">prependOnceListener(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'listening'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">() </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
        <span class="s3">prependOnceListener(</span><span class="s1">event</span><span class="s2">: </span><span class="s4">'drop'</span><span class="s3">, </span><span class="s6">listener</span><span class="s2">: </span><span class="s3">(</span><span class="s1">data</span><span class="s2">?: </span><span class="s1">DropArgument</span><span class="s3">) </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">this</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s2">type </span><span class="s1">IPVersion </span><span class="s2">= </span><span class="s4">'ipv4' </span><span class="s2">| </span><span class="s4">'ipv6'</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The `BlockList` object can be used with some network APIs to specify rules for 
     * disabling inbound or outbound access to specific IP addresses, IP ranges, or 
     * IP subnets. 
     * </span><span class="s2">@since </span><span class="s0">v15.0.0, v14.18.0 
     */</span>
    <span class="s2">class </span><span class="s1">BlockList </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Adds a rule to block the given IP address. 
         * </span><span class="s2">@since </span><span class="s0">v15.0.0, v14.18.0 
         * </span><span class="s2">@param </span><span class="s1">address </span><span class="s0">An IPv4 or IPv6 address. 
         * </span><span class="s2">@param </span><span class="s0">[type='ipv4'] Either `'ipv4'` or `'ipv6'`. 
         */</span>
        <span class="s3">addAddress(</span><span class="s1">address</span><span class="s2">: </span><span class="s1">string</span><span class="s3">, </span><span class="s1">type</span><span class="s2">?: </span><span class="s1">IPVersion</span><span class="s3">)</span><span class="s2">: </span><span class="s1">void</span><span class="s3">;</span>
        <span class="s3">addAddress(</span><span class="s1">address</span><span class="s2">: </span><span class="s1">SocketAddress</span><span class="s3">)</span><span class="s2">: </span><span class="s1">void</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Adds a rule to block a range of IP addresses from `start` (inclusive) to`end` (inclusive). 
         * </span><span class="s2">@since </span><span class="s0">v15.0.0, v14.18.0 
         * </span><span class="s2">@param </span><span class="s1">start </span><span class="s0">The starting IPv4 or IPv6 address in the range. 
         * </span><span class="s2">@param </span><span class="s1">end </span><span class="s0">The ending IPv4 or IPv6 address in the range. 
         * </span><span class="s2">@param </span><span class="s0">[type='ipv4'] Either `'ipv4'` or `'ipv6'`. 
         */</span>
        <span class="s3">addRange(</span><span class="s1">start</span><span class="s2">: </span><span class="s1">string</span><span class="s3">, </span><span class="s1">end</span><span class="s2">: </span><span class="s1">string</span><span class="s3">, </span><span class="s1">type</span><span class="s2">?: </span><span class="s1">IPVersion</span><span class="s3">)</span><span class="s2">: </span><span class="s1">void</span><span class="s3">;</span>
        <span class="s3">addRange(</span><span class="s1">start</span><span class="s2">: </span><span class="s1">SocketAddress</span><span class="s3">, </span><span class="s1">end</span><span class="s2">: </span><span class="s1">SocketAddress</span><span class="s3">)</span><span class="s2">: </span><span class="s1">void</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Adds a rule to block a range of IP addresses specified as a subnet mask. 
         * </span><span class="s2">@since </span><span class="s0">v15.0.0, v14.18.0 
         * </span><span class="s2">@param </span><span class="s1">net </span><span class="s0">The network IPv4 or IPv6 address. 
         * </span><span class="s2">@param </span><span class="s1">prefix </span><span class="s0">The number of CIDR prefix bits. For IPv4, this must be a value between `0` and `32`. For IPv6, this must be between `0` and `128`. 
         * </span><span class="s2">@param </span><span class="s0">[type='ipv4'] Either `'ipv4'` or `'ipv6'`. 
         */</span>
        <span class="s3">addSubnet(</span><span class="s1">net</span><span class="s2">: </span><span class="s1">SocketAddress</span><span class="s3">, </span><span class="s1">prefix</span><span class="s2">: </span><span class="s1">number</span><span class="s3">)</span><span class="s2">: </span><span class="s1">void</span><span class="s3">;</span>
        <span class="s3">addSubnet(</span><span class="s1">net</span><span class="s2">: </span><span class="s1">string</span><span class="s3">, </span><span class="s1">prefix</span><span class="s2">: </span><span class="s1">number</span><span class="s3">, </span><span class="s1">type</span><span class="s2">?: </span><span class="s1">IPVersion</span><span class="s3">)</span><span class="s2">: </span><span class="s1">void</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns `true` if the given IP address matches any of the rules added to the`BlockList`. 
         * 
         * ```js 
         * const blockList = new net.BlockList(); 
         * blockList.addAddress('123.123.123.123'); 
         * blockList.addRange('10.0.0.1', '10.0.0.10'); 
         * blockList.addSubnet('8592:757c:efae:4e45::', 64, 'ipv6'); 
         * 
         * console.log(blockList.check('123.123.123.123'));  // Prints: true 
         * console.log(blockList.check('10.0.0.3'));  // Prints: true 
         * console.log(blockList.check('222.111.111.222'));  // Prints: false 
         * 
         * // IPv6 notation for IPv4 addresses works: 
         * console.log(blockList.check('::ffff:7b7b:7b7b', 'ipv6')); // Prints: true 
         * console.log(blockList.check('::ffff:123.123.123.123', 'ipv6')); // Prints: true 
         * ``` 
         * </span><span class="s2">@since </span><span class="s0">v15.0.0, v14.18.0 
         * </span><span class="s2">@param </span><span class="s1">address </span><span class="s0">The IP address to check 
         * </span><span class="s2">@param </span><span class="s0">[type='ipv4'] Either `'ipv4'` or `'ipv6'`. 
         */</span>
        <span class="s3">check(</span><span class="s1">address</span><span class="s2">: </span><span class="s1">SocketAddress</span><span class="s3">)</span><span class="s2">: </span><span class="s1">boolean</span><span class="s3">;</span>
        <span class="s3">check(</span><span class="s1">address</span><span class="s2">: </span><span class="s1">string</span><span class="s3">, </span><span class="s1">type</span><span class="s2">?: </span><span class="s1">IPVersion</span><span class="s3">)</span><span class="s2">: </span><span class="s1">boolean</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s2">interface </span><span class="s1">TcpNetConnectOpts </span><span class="s2">extends </span><span class="s1">TcpSocketConnectOpts</span><span class="s3">, </span><span class="s1">SocketConstructorOpts </span><span class="s3">{</span>
        <span class="s3">timeout</span><span class="s2">?: </span><span class="s1">number </span><span class="s2">| </span><span class="s1">undefined</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s2">interface </span><span class="s1">IpcNetConnectOpts </span><span class="s2">extends </span><span class="s1">IpcSocketConnectOpts</span><span class="s3">, </span><span class="s1">SocketConstructorOpts </span><span class="s3">{</span>
        <span class="s3">timeout</span><span class="s2">?: </span><span class="s1">number </span><span class="s2">| </span><span class="s1">undefined</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s2">type </span><span class="s1">NetConnectOpts </span><span class="s2">= </span><span class="s1">TcpNetConnectOpts </span><span class="s2">| </span><span class="s1">IpcNetConnectOpts</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Creates a new TCP or `IPC` server. 
     * 
     * If `allowHalfOpen` is set to `true`, when the other end of the socket 
     * signals the end of transmission, the server will only send back the end of 
     * transmission when `socket.end()` is explicitly called. For example, in the 
     * context of TCP, when a FIN packed is received, a FIN packed is sent 
     * back only when `socket.end()` is explicitly called. Until then the 
     * connection is half-closed (non-readable but still writable). See `'end'` event and [RFC 1122](https://tools.ietf.org/html/rfc1122) (section 4.2.2.13) for more information. 
     * 
     * If `pauseOnConnect` is set to `true`, then the socket associated with each 
     * incoming connection will be paused, and no data will be read from its handle. 
     * This allows connections to be passed between processes without any data being 
     * read by the original process. To begin reading data from a paused socket, call `socket.resume()`. 
     * 
     * The server can be a TCP server or an `IPC` server, depending on what it `listen()` to. 
     * 
     * Here is an example of a TCP echo server which listens for connections 
     * on port 8124: 
     * 
     * ```js 
     * const net = require('node:net'); 
     * const server = net.createServer((c) =&gt; { 
     *   // 'connection' listener. 
     *   console.log('client connected'); 
     *   c.on('end', () =&gt; { 
     *     console.log('client disconnected'); 
     *   }); 
     *   c.write('hello\r\n'); 
     *   c.pipe(c); 
     * }); 
     * server.on('error', (err) =&gt; { 
     *   throw err; 
     * }); 
     * server.listen(8124, () =&gt; { 
     *   console.log('server bound'); 
     * }); 
     * ``` 
     * 
     * Test this by using `telnet`: 
     * 
     * ```bash 
     * telnet localhost 8124 
     * ``` 
     * 
     * To listen on the socket `/tmp/echo.sock`: 
     * 
     * ```js 
     * server.listen('/tmp/echo.sock', () =&gt; { 
     *   console.log('server bound'); 
     * }); 
     * ``` 
     * 
     * Use `nc` to connect to a Unix domain socket server: 
     * 
     * ```bash 
     * nc -U /tmp/echo.sock 
     * ``` 
     * </span><span class="s2">@since </span><span class="s0">v0.5.0 
     * </span><span class="s2">@param </span><span class="s1">connectionListener </span><span class="s0">Automatically set as a listener for the </span><span class="s1">{</span><span class="s2">@link </span><span class="s1">'connection'} </span><span class="s0">event. 
     */</span>
    <span class="s2">function </span><span class="s3">createServer(</span><span class="s6">connectionListener</span><span class="s2">?: </span><span class="s3">(</span><span class="s1">socket</span><span class="s2">: </span><span class="s1">Socket</span><span class="s3">) </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">Server</span><span class="s3">;</span>
    <span class="s2">function </span><span class="s3">createServer(</span><span class="s1">options</span><span class="s2">?: </span><span class="s1">ServerOpts</span><span class="s3">, </span><span class="s6">connectionListener</span><span class="s2">?: </span><span class="s3">(</span><span class="s1">socket</span><span class="s2">: </span><span class="s1">Socket</span><span class="s3">) </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">Server</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Aliases to </span><span class="s1">{</span><span class="s2">@link </span><span class="s1">createConnection}</span><span class="s0">. 
     * 
     * Possible signatures: 
     * 
     * * </span><span class="s1">{</span><span class="s2">@link </span><span class="s1">connect}</span>
     <span class="s0">* * </span><span class="s1">{</span><span class="s2">@link </span><span class="s1">connect} </span><span class="s0">for `IPC` connections. 
     * * </span><span class="s1">{</span><span class="s2">@link </span><span class="s1">connect} </span><span class="s0">for TCP connections. 
     */</span>
    <span class="s2">function </span><span class="s3">connect(</span><span class="s1">options</span><span class="s2">: </span><span class="s1">NetConnectOpts</span><span class="s3">, </span><span class="s6">connectionListener</span><span class="s2">?: </span><span class="s3">() </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">Socket</span><span class="s3">;</span>
    <span class="s2">function </span><span class="s3">connect(</span><span class="s1">port</span><span class="s2">: </span><span class="s1">number</span><span class="s3">, </span><span class="s1">host</span><span class="s2">?: </span><span class="s1">string</span><span class="s3">, </span><span class="s6">connectionListener</span><span class="s2">?: </span><span class="s3">() </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">Socket</span><span class="s3">;</span>
    <span class="s2">function </span><span class="s3">connect(</span><span class="s1">path</span><span class="s2">: </span><span class="s1">string</span><span class="s3">, </span><span class="s6">connectionListener</span><span class="s2">?: </span><span class="s3">() </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">Socket</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* A factory function, which creates a new </span><span class="s1">{</span><span class="s2">@link </span><span class="s1">Socket}</span><span class="s0">, 
     * immediately initiates connection with `socket.connect()`, 
     * then returns the `net.Socket` that starts the connection. 
     * 
     * When the connection is established, a `'connect'` event will be emitted 
     * on the returned socket. The last parameter `connectListener`, if supplied, 
     * will be added as a listener for the `'connect'` event **once**. 
     * 
     * Possible signatures: 
     * 
     * * </span><span class="s1">{</span><span class="s2">@link </span><span class="s1">createConnection}</span>
     <span class="s0">* * </span><span class="s1">{</span><span class="s2">@link </span><span class="s1">createConnection} </span><span class="s0">for `IPC` connections. 
     * * </span><span class="s1">{</span><span class="s2">@link </span><span class="s1">createConnection} </span><span class="s0">for TCP connections. 
     * 
     * The </span><span class="s1">{</span><span class="s2">@link </span><span class="s1">connect} </span><span class="s0">function is an alias to this function. 
     */</span>
    <span class="s2">function </span><span class="s3">createConnection(</span><span class="s1">options</span><span class="s2">: </span><span class="s1">NetConnectOpts</span><span class="s3">, </span><span class="s6">connectionListener</span><span class="s2">?: </span><span class="s3">() </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">Socket</span><span class="s3">;</span>
    <span class="s2">function </span><span class="s3">createConnection(</span><span class="s1">port</span><span class="s2">: </span><span class="s1">number</span><span class="s3">, </span><span class="s1">host</span><span class="s2">?: </span><span class="s1">string</span><span class="s3">, </span><span class="s6">connectionListener</span><span class="s2">?: </span><span class="s3">() </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">Socket</span><span class="s3">;</span>
    <span class="s2">function </span><span class="s3">createConnection(</span><span class="s1">path</span><span class="s2">: </span><span class="s1">string</span><span class="s3">, </span><span class="s6">connectionListener</span><span class="s2">?: </span><span class="s3">() </span><span class="s2">=&gt; </span><span class="s1">void</span><span class="s3">)</span><span class="s2">: </span><span class="s1">Socket</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Returns `6` if `input` is an IPv6 address. Returns `4` if `input` is an IPv4 
     * address in [dot-decimal notation](https://en.wikipedia.org/wiki/Dot-decimal_notation) with no leading zeroes. Otherwise, returns`0`. 
     * 
     * ```js 
     * net.isIP('::1'); // returns 6 
     * net.isIP('127.0.0.1'); // returns 4 
     * net.isIP('127.000.000.001'); // returns 0 
     * net.isIP('127.0.0.1/24'); // returns 0 
     * net.isIP('fhqwhgads'); // returns 0 
     * ``` 
     * </span><span class="s2">@since </span><span class="s0">v0.3.0 
     */</span>
    <span class="s2">function </span><span class="s3">isIP(</span><span class="s1">input</span><span class="s2">: </span><span class="s1">string</span><span class="s3">)</span><span class="s2">: </span><span class="s1">number</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Returns `true` if `input` is an IPv4 address in [dot-decimal notation](https://en.wikipedia.org/wiki/Dot-decimal_notation) with no 
     * leading zeroes. Otherwise, returns `false`. 
     * 
     * ```js 
     * net.isIPv4('127.0.0.1'); // returns true 
     * net.isIPv4('127.000.000.001'); // returns false 
     * net.isIPv4('127.0.0.1/24'); // returns false 
     * net.isIPv4('fhqwhgads'); // returns false 
     * ``` 
     * </span><span class="s2">@since </span><span class="s0">v0.3.0 
     */</span>
    <span class="s2">function </span><span class="s3">isIPv4(</span><span class="s1">input</span><span class="s2">: </span><span class="s1">string</span><span class="s3">)</span><span class="s2">: </span><span class="s1">boolean</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Returns `true` if `input` is an IPv6 address. Otherwise, returns `false`. 
     * 
     * ```js 
     * net.isIPv6('::1'); // returns true 
     * net.isIPv6('fhqwhgads'); // returns false 
     * ``` 
     * </span><span class="s2">@since </span><span class="s0">v0.3.0 
     */</span>
    <span class="s2">function </span><span class="s3">isIPv6(</span><span class="s1">input</span><span class="s2">: </span><span class="s1">string</span><span class="s3">)</span><span class="s2">: </span><span class="s1">boolean</span><span class="s3">;</span>
    <span class="s2">interface </span><span class="s1">SocketAddressInitOptions </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* The network address as either an IPv4 or IPv6 string. 
         * </span><span class="s2">@default </span><span class="s1">127.0.0.1</span>
         <span class="s0">*/</span>
        <span class="s3">address</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@default </span><span class="s1">`'ipv4'`</span>
         <span class="s0">*/</span>
        <span class="s3">family</span><span class="s2">?: </span><span class="s1">IPVersion </span><span class="s2">| </span><span class="s1">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* An IPv6 flow-label used only if `family` is `'ipv6'`. 
         * </span><span class="s2">@default </span><span class="s1">0</span>
         <span class="s0">*/</span>
        <span class="s3">flowlabel</span><span class="s2">?: </span><span class="s1">number </span><span class="s2">| </span><span class="s1">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* An IP port. 
         * </span><span class="s2">@default </span><span class="s1">0</span>
         <span class="s0">*/</span>
        <span class="s3">port</span><span class="s2">?: </span><span class="s1">number </span><span class="s2">| </span><span class="s1">undefined</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s0">/**</span>
     <span class="s0">* </span><span class="s2">@since </span><span class="s0">v15.14.0, v14.18.0 
     */</span>
    <span class="s2">class </span><span class="s1">SocketAddress </span><span class="s3">{</span>
        <span class="s2">constructor</span><span class="s3">(</span><span class="s1">options</span><span class="s2">: </span><span class="s1">SocketAddressInitOptions</span><span class="s3">);</span>
        <span class="s0">/**</span>
         <span class="s0">* Either \`'ipv4'\` or \`'ipv6'\`. 
         * </span><span class="s2">@since </span><span class="s0">v15.14.0, v14.18.0 
         */</span>
        <span class="s2">readonly </span><span class="s3">address</span><span class="s2">: </span><span class="s1">string</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Either \`'ipv4'\` or \`'ipv6'\`. 
         * </span><span class="s2">@since </span><span class="s0">v15.14.0, v14.18.0 
         */</span>
        <span class="s2">readonly </span><span class="s3">family</span><span class="s2">: </span><span class="s1">IPVersion</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@since </span><span class="s0">v15.14.0, v14.18.0 
         */</span>
        <span class="s2">readonly </span><span class="s3">port</span><span class="s2">: </span><span class="s1">number</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@since </span><span class="s0">v15.14.0, v14.18.0 
         */</span>
        <span class="s2">readonly </span><span class="s3">flowlabel</span><span class="s2">: </span><span class="s1">number</span><span class="s3">;</span>
    <span class="s3">}</span>
<span class="s3">}</span>
<span class="s2">declare module </span><span class="s4">'node:net' </span><span class="s3">{</span>
    <span class="s2">export </span><span class="s5">* </span><span class="s2">from </span><span class="s4">'net'</span><span class="s3">;</span>
<span class="s3">}</span>
</pre>
</body>
</html>
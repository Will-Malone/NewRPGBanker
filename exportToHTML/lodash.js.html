<html>
<head>
<title>lodash.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #4646f1;}
.s6 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
lodash.js</font>
</center></td></tr></table>
<pre><span class="s0">/** 
 * @license 
 * Lodash &lt;https://lodash.com/&gt; 
 * Copyright OpenJS Foundation and other contributors &lt;https://openjsf.org/&gt; 
 * Released under MIT license &lt;https://lodash.com/license&gt; 
 * Based on Underscore.js 1.8.3 &lt;http://underscorejs.org/LICENSE&gt; 
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters &amp; Editors 
 */</span>
<span class="s1">;(</span><span class="s2">function</span><span class="s1">() {</span>

  <span class="s0">/** Used as a safe reference for `undefined` in pre-ES5 environments. */</span>
  <span class="s2">var </span><span class="s1">undefined;</span>

  <span class="s0">/** Used as the semantic version number. */</span>
  <span class="s2">var </span><span class="s1">VERSION = </span><span class="s3">'4.17.21'</span><span class="s1">;</span>

  <span class="s0">/** Used as the size to enable large array optimizations. */</span>
  <span class="s2">var </span><span class="s1">LARGE_ARRAY_SIZE = </span><span class="s4">200</span><span class="s1">;</span>

  <span class="s0">/** Error message constants. */</span>
  <span class="s2">var </span><span class="s1">CORE_ERROR_TEXT = </span><span class="s3">'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.'</span><span class="s1">,</span>
      <span class="s1">FUNC_ERROR_TEXT = </span><span class="s3">'Expected a function'</span><span class="s1">,</span>
      <span class="s1">INVALID_TEMPL_VAR_ERROR_TEXT = </span><span class="s3">'Invalid `variable` option passed into `_.template`'</span><span class="s1">;</span>

  <span class="s0">/** Used to stand-in for `undefined` hash values. */</span>
  <span class="s2">var </span><span class="s1">HASH_UNDEFINED = </span><span class="s3">'__lodash_hash_undefined__'</span><span class="s1">;</span>

  <span class="s0">/** Used as the maximum memoize cache size. */</span>
  <span class="s2">var </span><span class="s1">MAX_MEMOIZE_SIZE = </span><span class="s4">500</span><span class="s1">;</span>

  <span class="s0">/** Used as the internal argument placeholder. */</span>
  <span class="s2">var </span><span class="s1">PLACEHOLDER = </span><span class="s3">'__lodash_placeholder__'</span><span class="s1">;</span>

  <span class="s0">/** Used to compose bitmasks for cloning. */</span>
  <span class="s2">var </span><span class="s1">CLONE_DEEP_FLAG = </span><span class="s4">1</span><span class="s1">,</span>
      <span class="s1">CLONE_FLAT_FLAG = </span><span class="s4">2</span><span class="s1">,</span>
      <span class="s1">CLONE_SYMBOLS_FLAG = </span><span class="s4">4</span><span class="s1">;</span>

  <span class="s0">/** Used to compose bitmasks for value comparisons. */</span>
  <span class="s2">var </span><span class="s1">COMPARE_PARTIAL_FLAG = </span><span class="s4">1</span><span class="s1">,</span>
      <span class="s1">COMPARE_UNORDERED_FLAG = </span><span class="s4">2</span><span class="s1">;</span>

  <span class="s0">/** Used to compose bitmasks for function metadata. */</span>
  <span class="s2">var </span><span class="s1">WRAP_BIND_FLAG = </span><span class="s4">1</span><span class="s1">,</span>
      <span class="s1">WRAP_BIND_KEY_FLAG = </span><span class="s4">2</span><span class="s1">,</span>
      <span class="s1">WRAP_CURRY_BOUND_FLAG = </span><span class="s4">4</span><span class="s1">,</span>
      <span class="s1">WRAP_CURRY_FLAG = </span><span class="s4">8</span><span class="s1">,</span>
      <span class="s1">WRAP_CURRY_RIGHT_FLAG = </span><span class="s4">16</span><span class="s1">,</span>
      <span class="s1">WRAP_PARTIAL_FLAG = </span><span class="s4">32</span><span class="s1">,</span>
      <span class="s1">WRAP_PARTIAL_RIGHT_FLAG = </span><span class="s4">64</span><span class="s1">,</span>
      <span class="s1">WRAP_ARY_FLAG = </span><span class="s4">128</span><span class="s1">,</span>
      <span class="s1">WRAP_REARG_FLAG = </span><span class="s4">256</span><span class="s1">,</span>
      <span class="s1">WRAP_FLIP_FLAG = </span><span class="s4">512</span><span class="s1">;</span>

  <span class="s0">/** Used as default options for `_.truncate`. */</span>
  <span class="s2">var </span><span class="s1">DEFAULT_TRUNC_LENGTH = </span><span class="s4">30</span><span class="s1">,</span>
      <span class="s1">DEFAULT_TRUNC_OMISSION = </span><span class="s3">'...'</span><span class="s1">;</span>

  <span class="s0">/** Used to detect hot functions by number of calls within a span of milliseconds. */</span>
  <span class="s2">var </span><span class="s1">HOT_COUNT = </span><span class="s4">800</span><span class="s1">,</span>
      <span class="s1">HOT_SPAN = </span><span class="s4">16</span><span class="s1">;</span>

  <span class="s0">/** Used to indicate the type of lazy iteratees. */</span>
  <span class="s2">var </span><span class="s1">LAZY_FILTER_FLAG = </span><span class="s4">1</span><span class="s1">,</span>
      <span class="s1">LAZY_MAP_FLAG = </span><span class="s4">2</span><span class="s1">,</span>
      <span class="s1">LAZY_WHILE_FLAG = </span><span class="s4">3</span><span class="s1">;</span>

  <span class="s0">/** Used as references for various `Number` constants. */</span>
  <span class="s2">var </span><span class="s1">INFINITY = </span><span class="s4">1 </span><span class="s1">/ </span><span class="s4">0</span><span class="s1">,</span>
      <span class="s1">MAX_SAFE_INTEGER = </span><span class="s4">9007199254740991</span><span class="s1">,</span>
      <span class="s1">MAX_INTEGER = </span><span class="s4">1</span><span class="s1">.</span><span class="s4">7976931348623157</span><span class="s1">e+</span><span class="s4">308</span><span class="s1">,</span>
      <span class="s1">NAN = </span><span class="s4">0 </span><span class="s1">/ </span><span class="s4">0</span><span class="s1">;</span>

  <span class="s0">/** Used as references for the maximum length and index of an array. */</span>
  <span class="s2">var </span><span class="s1">MAX_ARRAY_LENGTH = </span><span class="s4">4294967295</span><span class="s1">,</span>
      <span class="s1">MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - </span><span class="s4">1</span><span class="s1">,</span>
      <span class="s1">HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH &gt;&gt;&gt; </span><span class="s4">1</span><span class="s1">;</span>

  <span class="s0">/** Used to associate wrap methods with their bit flags. */</span>
  <span class="s2">var </span><span class="s1">wrapFlags = [</span>
    <span class="s1">[</span><span class="s3">'ary'</span><span class="s1">, WRAP_ARY_FLAG],</span>
    <span class="s1">[</span><span class="s3">'bind'</span><span class="s1">, WRAP_BIND_FLAG],</span>
    <span class="s1">[</span><span class="s3">'bindKey'</span><span class="s1">, WRAP_BIND_KEY_FLAG],</span>
    <span class="s1">[</span><span class="s3">'curry'</span><span class="s1">, WRAP_CURRY_FLAG],</span>
    <span class="s1">[</span><span class="s3">'curryRight'</span><span class="s1">, WRAP_CURRY_RIGHT_FLAG],</span>
    <span class="s1">[</span><span class="s3">'flip'</span><span class="s1">, WRAP_FLIP_FLAG],</span>
    <span class="s1">[</span><span class="s3">'partial'</span><span class="s1">, WRAP_PARTIAL_FLAG],</span>
    <span class="s1">[</span><span class="s3">'partialRight'</span><span class="s1">, WRAP_PARTIAL_RIGHT_FLAG],</span>
    <span class="s1">[</span><span class="s3">'rearg'</span><span class="s1">, WRAP_REARG_FLAG]</span>
  <span class="s1">];</span>

  <span class="s0">/** `Object#toString` result references. */</span>
  <span class="s2">var </span><span class="s1">argsTag = </span><span class="s3">'[object Arguments]'</span><span class="s1">,</span>
      <span class="s1">arrayTag = </span><span class="s3">'[object Array]'</span><span class="s1">,</span>
      <span class="s1">asyncTag = </span><span class="s3">'[object AsyncFunction]'</span><span class="s1">,</span>
      <span class="s1">boolTag = </span><span class="s3">'[object Boolean]'</span><span class="s1">,</span>
      <span class="s1">dateTag = </span><span class="s3">'[object Date]'</span><span class="s1">,</span>
      <span class="s1">domExcTag = </span><span class="s3">'[object DOMException]'</span><span class="s1">,</span>
      <span class="s1">errorTag = </span><span class="s3">'[object Error]'</span><span class="s1">,</span>
      <span class="s1">funcTag = </span><span class="s3">'[object Function]'</span><span class="s1">,</span>
      <span class="s1">genTag = </span><span class="s3">'[object GeneratorFunction]'</span><span class="s1">,</span>
      <span class="s1">mapTag = </span><span class="s3">'[object Map]'</span><span class="s1">,</span>
      <span class="s1">numberTag = </span><span class="s3">'[object Number]'</span><span class="s1">,</span>
      <span class="s1">nullTag = </span><span class="s3">'[object Null]'</span><span class="s1">,</span>
      <span class="s1">objectTag = </span><span class="s3">'[object Object]'</span><span class="s1">,</span>
      <span class="s1">promiseTag = </span><span class="s3">'[object Promise]'</span><span class="s1">,</span>
      <span class="s1">proxyTag = </span><span class="s3">'[object Proxy]'</span><span class="s1">,</span>
      <span class="s1">regexpTag = </span><span class="s3">'[object RegExp]'</span><span class="s1">,</span>
      <span class="s1">setTag = </span><span class="s3">'[object Set]'</span><span class="s1">,</span>
      <span class="s1">stringTag = </span><span class="s3">'[object String]'</span><span class="s1">,</span>
      <span class="s1">symbolTag = </span><span class="s3">'[object Symbol]'</span><span class="s1">,</span>
      <span class="s1">undefinedTag = </span><span class="s3">'[object Undefined]'</span><span class="s1">,</span>
      <span class="s1">weakMapTag = </span><span class="s3">'[object WeakMap]'</span><span class="s1">,</span>
      <span class="s1">weakSetTag = </span><span class="s3">'[object WeakSet]'</span><span class="s1">;</span>

  <span class="s2">var </span><span class="s1">arrayBufferTag = </span><span class="s3">'[object ArrayBuffer]'</span><span class="s1">,</span>
      <span class="s1">dataViewTag = </span><span class="s3">'[object DataView]'</span><span class="s1">,</span>
      <span class="s1">float32Tag = </span><span class="s3">'[object Float32Array]'</span><span class="s1">,</span>
      <span class="s1">float64Tag = </span><span class="s3">'[object Float64Array]'</span><span class="s1">,</span>
      <span class="s1">int8Tag = </span><span class="s3">'[object Int8Array]'</span><span class="s1">,</span>
      <span class="s1">int16Tag = </span><span class="s3">'[object Int16Array]'</span><span class="s1">,</span>
      <span class="s1">int32Tag = </span><span class="s3">'[object Int32Array]'</span><span class="s1">,</span>
      <span class="s1">uint8Tag = </span><span class="s3">'[object Uint8Array]'</span><span class="s1">,</span>
      <span class="s1">uint8ClampedTag = </span><span class="s3">'[object Uint8ClampedArray]'</span><span class="s1">,</span>
      <span class="s1">uint16Tag = </span><span class="s3">'[object Uint16Array]'</span><span class="s1">,</span>
      <span class="s1">uint32Tag = </span><span class="s3">'[object Uint32Array]'</span><span class="s1">;</span>

  <span class="s0">/** Used to match empty string literals in compiled template source. */</span>
  <span class="s2">var </span><span class="s1">reEmptyStringLeading = /\b__p \+= </span><span class="s3">''</span><span class="s1">;/g,</span>
      <span class="s1">reEmptyStringMiddle = /\b(__p \+=) </span><span class="s3">'' </span><span class="s1">\+/g,</span>
      <span class="s1">reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n</span><span class="s3">''</span><span class="s1">;/g;</span>

  <span class="s0">/** Used to match HTML entities and HTML characters. */</span>
  <span class="s2">var </span><span class="s1">reEscapedHtml = /&amp;(?:amp|lt|gt|quot|#</span><span class="s4">39</span><span class="s1">);/g,</span>
      <span class="s1">reUnescapedHtml = /[&amp;&lt;&gt;</span><span class="s3">&quot;']/g,</span>
      <span class="s1">reHasEscapedHtml = RegExp(reEscapedHtml.source),</span>
      <span class="s1">reHasUnescapedHtml = RegExp(reUnescapedHtml.source);</span>

  <span class="s0">/** Used to match template delimiters. */</span>
  <span class="s2">var </span><span class="s1">reEscape = /&lt;%-([\s\S]+?)%&gt;/g,</span>
      <span class="s1">reEvaluate = /&lt;%([\s\S]+?)%&gt;/g,</span>
      <span class="s1">reInterpolate = /&lt;%=([\s\S]+?)%&gt;/g;</span>

  <span class="s0">/** Used to match property names within property paths. */</span>
  <span class="s2">var </span><span class="s1">reIsDeepProp = /\.|\[(?:[^[\]]*|([</span><span class="s3">&quot;'])(?:(?!</span><span class="s5">\1</span><span class="s3">)[^</span><span class="s5">\\</span><span class="s3">]|</span><span class="s5">\\</span><span class="s3">.)*?</span><span class="s5">\1</span><span class="s3">)</span><span class="s6">\]</span><span class="s3">/,</span>
      <span class="s1">reIsPlainProp = /^\w*$/,</span>
      <span class="s1">rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|([</span><span class="s3">&quot;'])((?:(?!</span><span class="s5">\2</span><span class="s3">)[^</span><span class="s5">\\</span><span class="s3">]|</span><span class="s5">\\</span><span class="s3">.)*?)</span><span class="s5">\2</span><span class="s3">)</span><span class="s6">\]</span><span class="s3">|(?=(?:</span><span class="s6">\.</span><span class="s3">|</span><span class="s6">\[\]</span><span class="s3">)(?:</span><span class="s6">\.</span><span class="s3">|</span><span class="s6">\[\]</span><span class="s3">|$))/g;</span>

  <span class="s0">/** 
   * Used to match `RegExp` 
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns). 
   */</span>
  <span class="s2">var </span><span class="s1">reRegExpChar = /[\\^$.*+?()[\]{}|]/g,</span>
      <span class="s1">reHasRegExpChar = RegExp(reRegExpChar.source);</span>

  <span class="s0">/** Used to match leading whitespace. */</span>
  <span class="s2">var </span><span class="s1">reTrimStart = /^\s+/;</span>

  <span class="s0">/** Used to match a single whitespace character. */</span>
  <span class="s2">var </span><span class="s1">reWhitespace = /\s/;</span>

  <span class="s0">/** Used to match wrap detail comments. */</span>
  <span class="s2">var </span><span class="s1">reWrapComment = /\{(?:\n\/\* \[wrapped </span><span class="s2">with </span><span class="s1">.+\] \*\/)?\n?/,</span>
      <span class="s1">reWrapDetails = /\{\n\/\* \[wrapped </span><span class="s2">with </span><span class="s1">(.+)\] \*/,</span>
      <span class="s1">reSplitDetails = /,? &amp; /;</span>

  <span class="s0">/** Used to match words composed of alphanumeric characters. */</span>
  <span class="s2">var </span><span class="s1">reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;</span>

  <span class="s0">/** 
   * Used to validate the `validate` option in `_.template` variable. 
   * 
   * Forbids characters which could potentially change the meaning of the function argument definition: 
   * - &quot;(),&quot; (modification of function parameters) 
   * - &quot;=&quot; (default value) 
   * - &quot;[]{}&quot; (destructuring of function parameters) 
   * - &quot;/&quot; (beginning of a comment) 
   * - whitespace 
   */</span>
  <span class="s2">var </span><span class="s1">reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;</span>

  <span class="s0">/** Used to match backslashes in property paths. */</span>
  <span class="s2">var </span><span class="s1">reEscapeChar = /\\(\\)?/g;</span>

  <span class="s0">/** 
   * Used to match 
   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components). 
   */</span>
  <span class="s2">var </span><span class="s1">reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;</span>

  <span class="s0">/** Used to match `RegExp` flags from their coerced string values. */</span>
  <span class="s2">var </span><span class="s1">reFlags = /\w*$/;</span>

  <span class="s0">/** Used to detect bad signed hexadecimal string values. */</span>
  <span class="s2">var </span><span class="s1">reIsBadHex = /^[-+]</span><span class="s4">0</span><span class="s1">x[</span><span class="s4">0</span><span class="s1">-</span><span class="s4">9</span><span class="s1">a-f]+$/i;</span>

  <span class="s0">/** Used to detect binary string values. */</span>
  <span class="s2">var </span><span class="s1">reIsBinary = /^</span><span class="s4">0</span><span class="s1">b[</span><span class="s4">01</span><span class="s1">]+$/i;</span>

  <span class="s0">/** Used to detect host constructors (Safari). */</span>
  <span class="s2">var </span><span class="s1">reIsHostCtor = /^\[object .+?Constructor\]$/;</span>

  <span class="s0">/** Used to detect octal string values. */</span>
  <span class="s2">var </span><span class="s1">reIsOctal = /^</span><span class="s4">0</span><span class="s1">o[</span><span class="s4">0</span><span class="s1">-</span><span class="s4">7</span><span class="s1">]+$/i;</span>

  <span class="s0">/** Used to detect unsigned integer values. */</span>
  <span class="s2">var </span><span class="s1">reIsUint = /^(?:</span><span class="s4">0</span><span class="s1">|[</span><span class="s4">1</span><span class="s1">-</span><span class="s4">9</span><span class="s1">]\d*)$/;</span>

  <span class="s0">/** Used to match Latin Unicode letters (excluding mathematical operators). */</span>
  <span class="s2">var </span><span class="s1">reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;</span>

  <span class="s0">/** Used to ensure capturing order of template delimiters. */</span>
  <span class="s2">var </span><span class="s1">reNoMatch = /($^)/;</span>

  <span class="s0">/** Used to match unescaped characters in compiled string literals. */</span>
  <span class="s2">var </span><span class="s1">reUnescapedString = /[</span><span class="s3">'</span><span class="s5">\n\r\u2028\u2029\\</span><span class="s3">]/g;</span>

  <span class="s0">/** Used to compose unicode character classes. */</span>
  <span class="s2">var </span><span class="s1">rsAstralRange = </span><span class="s3">'</span><span class="s5">\\</span><span class="s3">ud800-</span><span class="s5">\\</span><span class="s3">udfff'</span><span class="s1">,</span>
      <span class="s1">rsComboMarksRange = </span><span class="s3">'</span><span class="s5">\\</span><span class="s3">u0300-</span><span class="s5">\\</span><span class="s3">u036f'</span><span class="s1">,</span>
      <span class="s1">reComboHalfMarksRange = </span><span class="s3">'</span><span class="s5">\\</span><span class="s3">ufe20-</span><span class="s5">\\</span><span class="s3">ufe2f'</span><span class="s1">,</span>
      <span class="s1">rsComboSymbolsRange = </span><span class="s3">'</span><span class="s5">\\</span><span class="s3">u20d0-</span><span class="s5">\\</span><span class="s3">u20ff'</span><span class="s1">,</span>
      <span class="s1">rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,</span>
      <span class="s1">rsDingbatRange = </span><span class="s3">'</span><span class="s5">\\</span><span class="s3">u2700-</span><span class="s5">\\</span><span class="s3">u27bf'</span><span class="s1">,</span>
      <span class="s1">rsLowerRange = </span><span class="s3">'a-z</span><span class="s5">\\</span><span class="s3">xdf-</span><span class="s5">\\</span><span class="s3">xf6</span><span class="s5">\\</span><span class="s3">xf8-</span><span class="s5">\\</span><span class="s3">xff'</span><span class="s1">,</span>
      <span class="s1">rsMathOpRange = </span><span class="s3">'</span><span class="s5">\\</span><span class="s3">xac</span><span class="s5">\\</span><span class="s3">xb1</span><span class="s5">\\</span><span class="s3">xd7</span><span class="s5">\\</span><span class="s3">xf7'</span><span class="s1">,</span>
      <span class="s1">rsNonCharRange = </span><span class="s3">'</span><span class="s5">\\</span><span class="s3">x00-</span><span class="s5">\\</span><span class="s3">x2f</span><span class="s5">\\</span><span class="s3">x3a-</span><span class="s5">\\</span><span class="s3">x40</span><span class="s5">\\</span><span class="s3">x5b-</span><span class="s5">\\</span><span class="s3">x60</span><span class="s5">\\</span><span class="s3">x7b-</span><span class="s5">\\</span><span class="s3">xbf'</span><span class="s1">,</span>
      <span class="s1">rsPunctuationRange = </span><span class="s3">'</span><span class="s5">\\</span><span class="s3">u2000-</span><span class="s5">\\</span><span class="s3">u206f'</span><span class="s1">,</span>
      <span class="s1">rsSpaceRange = </span><span class="s3">' </span><span class="s5">\\</span><span class="s3">t</span><span class="s5">\\</span><span class="s3">x0b</span><span class="s5">\\</span><span class="s3">f</span><span class="s5">\\</span><span class="s3">xa0</span><span class="s5">\\</span><span class="s3">ufeff</span><span class="s5">\\</span><span class="s3">n</span><span class="s5">\\</span><span class="s3">r</span><span class="s5">\\</span><span class="s3">u2028</span><span class="s5">\\</span><span class="s3">u2029</span><span class="s5">\\</span><span class="s3">u1680</span><span class="s5">\\</span><span class="s3">u180e</span><span class="s5">\\</span><span class="s3">u2000</span><span class="s5">\\</span><span class="s3">u2001</span><span class="s5">\\</span><span class="s3">u2002</span><span class="s5">\\</span><span class="s3">u2003</span><span class="s5">\\</span><span class="s3">u2004</span><span class="s5">\\</span><span class="s3">u2005</span><span class="s5">\\</span><span class="s3">u2006</span><span class="s5">\\</span><span class="s3">u2007</span><span class="s5">\\</span><span class="s3">u2008</span><span class="s5">\\</span><span class="s3">u2009</span><span class="s5">\\</span><span class="s3">u200a</span><span class="s5">\\</span><span class="s3">u202f</span><span class="s5">\\</span><span class="s3">u205f</span><span class="s5">\\</span><span class="s3">u3000'</span><span class="s1">,</span>
      <span class="s1">rsUpperRange = </span><span class="s3">'A-Z</span><span class="s5">\\</span><span class="s3">xc0-</span><span class="s5">\\</span><span class="s3">xd6</span><span class="s5">\\</span><span class="s3">xd8-</span><span class="s5">\\</span><span class="s3">xde'</span><span class="s1">,</span>
      <span class="s1">rsVarRange = </span><span class="s3">'</span><span class="s5">\\</span><span class="s3">ufe0e</span><span class="s5">\\</span><span class="s3">ufe0f'</span><span class="s1">,</span>
      <span class="s1">rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;</span>

  <span class="s0">/** Used to compose unicode capture groups. */</span>
  <span class="s2">var </span><span class="s1">rsApos = </span><span class="s3">&quot;['</span><span class="s5">\u2019</span><span class="s3">]&quot;</span><span class="s1">,</span>
      <span class="s1">rsAstral = </span><span class="s3">'[' </span><span class="s1">+ rsAstralRange + </span><span class="s3">']'</span><span class="s1">,</span>
      <span class="s1">rsBreak = </span><span class="s3">'[' </span><span class="s1">+ rsBreakRange + </span><span class="s3">']'</span><span class="s1">,</span>
      <span class="s1">rsCombo = </span><span class="s3">'[' </span><span class="s1">+ rsComboRange + </span><span class="s3">']'</span><span class="s1">,</span>
      <span class="s1">rsDigits = </span><span class="s3">'</span><span class="s5">\\</span><span class="s3">d+'</span><span class="s1">,</span>
      <span class="s1">rsDingbat = </span><span class="s3">'[' </span><span class="s1">+ rsDingbatRange + </span><span class="s3">']'</span><span class="s1">,</span>
      <span class="s1">rsLower = </span><span class="s3">'[' </span><span class="s1">+ rsLowerRange + </span><span class="s3">']'</span><span class="s1">,</span>
      <span class="s1">rsMisc = </span><span class="s3">'[^' </span><span class="s1">+ rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + </span><span class="s3">']'</span><span class="s1">,</span>
      <span class="s1">rsFitz = </span><span class="s3">'</span><span class="s5">\\</span><span class="s3">ud83c[</span><span class="s5">\\</span><span class="s3">udffb-</span><span class="s5">\\</span><span class="s3">udfff]'</span><span class="s1">,</span>
      <span class="s1">rsModifier = </span><span class="s3">'(?:' </span><span class="s1">+ rsCombo + </span><span class="s3">'|' </span><span class="s1">+ rsFitz + </span><span class="s3">')'</span><span class="s1">,</span>
      <span class="s1">rsNonAstral = </span><span class="s3">'[^' </span><span class="s1">+ rsAstralRange + </span><span class="s3">']'</span><span class="s1">,</span>
      <span class="s1">rsRegional = </span><span class="s3">'(?:</span><span class="s5">\\</span><span class="s3">ud83c[</span><span class="s5">\\</span><span class="s3">udde6-</span><span class="s5">\\</span><span class="s3">uddff]){2}'</span><span class="s1">,</span>
      <span class="s1">rsSurrPair = </span><span class="s3">'[</span><span class="s5">\\</span><span class="s3">ud800-</span><span class="s5">\\</span><span class="s3">udbff][</span><span class="s5">\\</span><span class="s3">udc00-</span><span class="s5">\\</span><span class="s3">udfff]'</span><span class="s1">,</span>
      <span class="s1">rsUpper = </span><span class="s3">'[' </span><span class="s1">+ rsUpperRange + </span><span class="s3">']'</span><span class="s1">,</span>
      <span class="s1">rsZWJ = </span><span class="s3">'</span><span class="s5">\\</span><span class="s3">u200d'</span><span class="s1">;</span>

  <span class="s0">/** Used to compose unicode regexes. */</span>
  <span class="s2">var </span><span class="s1">rsMiscLower = </span><span class="s3">'(?:' </span><span class="s1">+ rsLower + </span><span class="s3">'|' </span><span class="s1">+ rsMisc + </span><span class="s3">')'</span><span class="s1">,</span>
      <span class="s1">rsMiscUpper = </span><span class="s3">'(?:' </span><span class="s1">+ rsUpper + </span><span class="s3">'|' </span><span class="s1">+ rsMisc + </span><span class="s3">')'</span><span class="s1">,</span>
      <span class="s1">rsOptContrLower = </span><span class="s3">'(?:' </span><span class="s1">+ rsApos + </span><span class="s3">'(?:d|ll|m|re|s|t|ve))?'</span><span class="s1">,</span>
      <span class="s1">rsOptContrUpper = </span><span class="s3">'(?:' </span><span class="s1">+ rsApos + </span><span class="s3">'(?:D|LL|M|RE|S|T|VE))?'</span><span class="s1">,</span>
      <span class="s1">reOptMod = rsModifier + </span><span class="s3">'?'</span><span class="s1">,</span>
      <span class="s1">rsOptVar = </span><span class="s3">'[' </span><span class="s1">+ rsVarRange + </span><span class="s3">']?'</span><span class="s1">,</span>
      <span class="s1">rsOptJoin = </span><span class="s3">'(?:' </span><span class="s1">+ rsZWJ + </span><span class="s3">'(?:' </span><span class="s1">+ [rsNonAstral, rsRegional, rsSurrPair].join(</span><span class="s3">'|'</span><span class="s1">) + </span><span class="s3">')' </span><span class="s1">+ rsOptVar + reOptMod + </span><span class="s3">')*'</span><span class="s1">,</span>
      <span class="s1">rsOrdLower = </span><span class="s3">'</span><span class="s5">\\</span><span class="s3">d*(?:1st|2nd|3rd|(?![123])</span><span class="s5">\\</span><span class="s3">dth)(?=</span><span class="s5">\\</span><span class="s3">b|[A-Z_])'</span><span class="s1">,</span>
      <span class="s1">rsOrdUpper = </span><span class="s3">'</span><span class="s5">\\</span><span class="s3">d*(?:1ST|2ND|3RD|(?![123])</span><span class="s5">\\</span><span class="s3">dTH)(?=</span><span class="s5">\\</span><span class="s3">b|[a-z_])'</span><span class="s1">,</span>
      <span class="s1">rsSeq = rsOptVar + reOptMod + rsOptJoin,</span>
      <span class="s1">rsEmoji = </span><span class="s3">'(?:' </span><span class="s1">+ [rsDingbat, rsRegional, rsSurrPair].join(</span><span class="s3">'|'</span><span class="s1">) + </span><span class="s3">')' </span><span class="s1">+ rsSeq,</span>
      <span class="s1">rsSymbol = </span><span class="s3">'(?:' </span><span class="s1">+ [rsNonAstral + rsCombo + </span><span class="s3">'?'</span><span class="s1">, rsCombo, rsRegional, rsSurrPair, rsAstral].join(</span><span class="s3">'|'</span><span class="s1">) + </span><span class="s3">')'</span><span class="s1">;</span>

  <span class="s0">/** Used to match apostrophes. */</span>
  <span class="s2">var </span><span class="s1">reApos = RegExp(rsApos, </span><span class="s3">'g'</span><span class="s1">);</span>

  <span class="s0">/** 
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and 
   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols). 
   */</span>
  <span class="s2">var </span><span class="s1">reComboMark = RegExp(rsCombo, </span><span class="s3">'g'</span><span class="s1">);</span>

  <span class="s0">/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */</span>
  <span class="s2">var </span><span class="s1">reUnicode = RegExp(rsFitz + </span><span class="s3">'(?=' </span><span class="s1">+ rsFitz + </span><span class="s3">')|' </span><span class="s1">+ rsSymbol + rsSeq, </span><span class="s3">'g'</span><span class="s1">);</span>

  <span class="s0">/** Used to match complex or compound words. */</span>
  <span class="s2">var </span><span class="s1">reUnicodeWord = RegExp([</span>
    <span class="s1">rsUpper + </span><span class="s3">'?' </span><span class="s1">+ rsLower + </span><span class="s3">'+' </span><span class="s1">+ rsOptContrLower + </span><span class="s3">'(?=' </span><span class="s1">+ [rsBreak, rsUpper, </span><span class="s3">'$'</span><span class="s1">].join(</span><span class="s3">'|'</span><span class="s1">) + </span><span class="s3">')'</span><span class="s1">,</span>
    <span class="s1">rsMiscUpper + </span><span class="s3">'+' </span><span class="s1">+ rsOptContrUpper + </span><span class="s3">'(?=' </span><span class="s1">+ [rsBreak, rsUpper + rsMiscLower, </span><span class="s3">'$'</span><span class="s1">].join(</span><span class="s3">'|'</span><span class="s1">) + </span><span class="s3">')'</span><span class="s1">,</span>
    <span class="s1">rsUpper + </span><span class="s3">'?' </span><span class="s1">+ rsMiscLower + </span><span class="s3">'+' </span><span class="s1">+ rsOptContrLower,</span>
    <span class="s1">rsUpper + </span><span class="s3">'+' </span><span class="s1">+ rsOptContrUpper,</span>
    <span class="s1">rsOrdUpper,</span>
    <span class="s1">rsOrdLower,</span>
    <span class="s1">rsDigits,</span>
    <span class="s1">rsEmoji</span>
  <span class="s1">].join(</span><span class="s3">'|'</span><span class="s1">), </span><span class="s3">'g'</span><span class="s1">);</span>

  <span class="s0">/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */</span>
  <span class="s2">var </span><span class="s1">reHasUnicode = RegExp(</span><span class="s3">'[' </span><span class="s1">+ rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + </span><span class="s3">']'</span><span class="s1">);</span>

  <span class="s0">/** Used to detect strings that need a more robust regexp to match words. */</span>
  <span class="s2">var </span><span class="s1">reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{</span><span class="s4">2</span><span class="s1">}[a-z]|[</span><span class="s4">0</span><span class="s1">-</span><span class="s4">9</span><span class="s1">][a-zA-Z]|[a-zA-Z][</span><span class="s4">0</span><span class="s1">-</span><span class="s4">9</span><span class="s1">]|[^a-zA-Z0-9 ]/;</span>

  <span class="s0">/** Used to assign default `context` object properties. */</span>
  <span class="s2">var </span><span class="s1">contextProps = [</span>
    <span class="s3">'Array'</span><span class="s1">, </span><span class="s3">'Buffer'</span><span class="s1">, </span><span class="s3">'DataView'</span><span class="s1">, </span><span class="s3">'Date'</span><span class="s1">, </span><span class="s3">'Error'</span><span class="s1">, </span><span class="s3">'Float32Array'</span><span class="s1">, </span><span class="s3">'Float64Array'</span><span class="s1">,</span>
    <span class="s3">'Function'</span><span class="s1">, </span><span class="s3">'Int8Array'</span><span class="s1">, </span><span class="s3">'Int16Array'</span><span class="s1">, </span><span class="s3">'Int32Array'</span><span class="s1">, </span><span class="s3">'Map'</span><span class="s1">, </span><span class="s3">'Math'</span><span class="s1">, </span><span class="s3">'Object'</span><span class="s1">,</span>
    <span class="s3">'Promise'</span><span class="s1">, </span><span class="s3">'RegExp'</span><span class="s1">, </span><span class="s3">'Set'</span><span class="s1">, </span><span class="s3">'String'</span><span class="s1">, </span><span class="s3">'Symbol'</span><span class="s1">, </span><span class="s3">'TypeError'</span><span class="s1">, </span><span class="s3">'Uint8Array'</span><span class="s1">,</span>
    <span class="s3">'Uint8ClampedArray'</span><span class="s1">, </span><span class="s3">'Uint16Array'</span><span class="s1">, </span><span class="s3">'Uint32Array'</span><span class="s1">, </span><span class="s3">'WeakMap'</span><span class="s1">,</span>
    <span class="s3">'_'</span><span class="s1">, </span><span class="s3">'clearTimeout'</span><span class="s1">, </span><span class="s3">'isFinite'</span><span class="s1">, </span><span class="s3">'parseInt'</span><span class="s1">, </span><span class="s3">'setTimeout'</span>
  <span class="s1">];</span>

  <span class="s0">/** Used to make template sourceURLs easier to identify. */</span>
  <span class="s2">var </span><span class="s1">templateCounter = -</span><span class="s4">1</span><span class="s1">;</span>

  <span class="s0">/** Used to identify `toStringTag` values of typed arrays. */</span>
  <span class="s2">var </span><span class="s1">typedArrayTags = {};</span>
  <span class="s1">typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =</span>
  <span class="s1">typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =</span>
  <span class="s1">typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =</span>
  <span class="s1">typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =</span>
  <span class="s1">typedArrayTags[uint32Tag] = </span><span class="s2">true</span><span class="s1">;</span>
  <span class="s1">typedArrayTags[argsTag] = typedArrayTags[arrayTag] =</span>
  <span class="s1">typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =</span>
  <span class="s1">typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =</span>
  <span class="s1">typedArrayTags[errorTag] = typedArrayTags[funcTag] =</span>
  <span class="s1">typedArrayTags[mapTag] = typedArrayTags[numberTag] =</span>
  <span class="s1">typedArrayTags[objectTag] = typedArrayTags[regexpTag] =</span>
  <span class="s1">typedArrayTags[setTag] = typedArrayTags[stringTag] =</span>
  <span class="s1">typedArrayTags[weakMapTag] = </span><span class="s2">false</span><span class="s1">;</span>

  <span class="s0">/** Used to identify `toStringTag` values supported by `_.clone`. */</span>
  <span class="s2">var </span><span class="s1">cloneableTags = {};</span>
  <span class="s1">cloneableTags[argsTag] = cloneableTags[arrayTag] =</span>
  <span class="s1">cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =</span>
  <span class="s1">cloneableTags[boolTag] = cloneableTags[dateTag] =</span>
  <span class="s1">cloneableTags[float32Tag] = cloneableTags[float64Tag] =</span>
  <span class="s1">cloneableTags[int8Tag] = cloneableTags[int16Tag] =</span>
  <span class="s1">cloneableTags[int32Tag] = cloneableTags[mapTag] =</span>
  <span class="s1">cloneableTags[numberTag] = cloneableTags[objectTag] =</span>
  <span class="s1">cloneableTags[regexpTag] = cloneableTags[setTag] =</span>
  <span class="s1">cloneableTags[stringTag] = cloneableTags[symbolTag] =</span>
  <span class="s1">cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =</span>
  <span class="s1">cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = </span><span class="s2">true</span><span class="s1">;</span>
  <span class="s1">cloneableTags[errorTag] = cloneableTags[funcTag] =</span>
  <span class="s1">cloneableTags[weakMapTag] = </span><span class="s2">false</span><span class="s1">;</span>

  <span class="s0">/** Used to map Latin Unicode letters to basic Latin letters. */</span>
  <span class="s2">var </span><span class="s1">deburredLetters = {</span>
    <span class="s0">// Latin-1 Supplement block.</span>
    <span class="s3">'</span><span class="s5">\x</span><span class="s3">c0'</span><span class="s1">: </span><span class="s3">'A'</span><span class="s1">,  </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">c1'</span><span class="s1">: </span><span class="s3">'A'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">c2'</span><span class="s1">: </span><span class="s3">'A'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">c3'</span><span class="s1">: </span><span class="s3">'A'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">c4'</span><span class="s1">: </span><span class="s3">'A'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">c5'</span><span class="s1">: </span><span class="s3">'A'</span><span class="s1">,</span>
    <span class="s3">'</span><span class="s5">\x</span><span class="s3">e0'</span><span class="s1">: </span><span class="s3">'a'</span><span class="s1">,  </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">e1'</span><span class="s1">: </span><span class="s3">'a'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">e2'</span><span class="s1">: </span><span class="s3">'a'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">e3'</span><span class="s1">: </span><span class="s3">'a'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">e4'</span><span class="s1">: </span><span class="s3">'a'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">e5'</span><span class="s1">: </span><span class="s3">'a'</span><span class="s1">,</span>
    <span class="s3">'</span><span class="s5">\x</span><span class="s3">c7'</span><span class="s1">: </span><span class="s3">'C'</span><span class="s1">,  </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">e7'</span><span class="s1">: </span><span class="s3">'c'</span><span class="s1">,</span>
    <span class="s3">'</span><span class="s5">\x</span><span class="s3">d0'</span><span class="s1">: </span><span class="s3">'D'</span><span class="s1">,  </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">f0'</span><span class="s1">: </span><span class="s3">'d'</span><span class="s1">,</span>
    <span class="s3">'</span><span class="s5">\x</span><span class="s3">c8'</span><span class="s1">: </span><span class="s3">'E'</span><span class="s1">,  </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">c9'</span><span class="s1">: </span><span class="s3">'E'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">ca'</span><span class="s1">: </span><span class="s3">'E'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">cb'</span><span class="s1">: </span><span class="s3">'E'</span><span class="s1">,</span>
    <span class="s3">'</span><span class="s5">\x</span><span class="s3">e8'</span><span class="s1">: </span><span class="s3">'e'</span><span class="s1">,  </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">e9'</span><span class="s1">: </span><span class="s3">'e'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">ea'</span><span class="s1">: </span><span class="s3">'e'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">eb'</span><span class="s1">: </span><span class="s3">'e'</span><span class="s1">,</span>
    <span class="s3">'</span><span class="s5">\x</span><span class="s3">cc'</span><span class="s1">: </span><span class="s3">'I'</span><span class="s1">,  </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">cd'</span><span class="s1">: </span><span class="s3">'I'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">ce'</span><span class="s1">: </span><span class="s3">'I'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">cf'</span><span class="s1">: </span><span class="s3">'I'</span><span class="s1">,</span>
    <span class="s3">'</span><span class="s5">\x</span><span class="s3">ec'</span><span class="s1">: </span><span class="s3">'i'</span><span class="s1">,  </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">ed'</span><span class="s1">: </span><span class="s3">'i'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">ee'</span><span class="s1">: </span><span class="s3">'i'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">ef'</span><span class="s1">: </span><span class="s3">'i'</span><span class="s1">,</span>
    <span class="s3">'</span><span class="s5">\x</span><span class="s3">d1'</span><span class="s1">: </span><span class="s3">'N'</span><span class="s1">,  </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">f1'</span><span class="s1">: </span><span class="s3">'n'</span><span class="s1">,</span>
    <span class="s3">'</span><span class="s5">\x</span><span class="s3">d2'</span><span class="s1">: </span><span class="s3">'O'</span><span class="s1">,  </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">d3'</span><span class="s1">: </span><span class="s3">'O'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">d4'</span><span class="s1">: </span><span class="s3">'O'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">d5'</span><span class="s1">: </span><span class="s3">'O'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">d6'</span><span class="s1">: </span><span class="s3">'O'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">d8'</span><span class="s1">: </span><span class="s3">'O'</span><span class="s1">,</span>
    <span class="s3">'</span><span class="s5">\x</span><span class="s3">f2'</span><span class="s1">: </span><span class="s3">'o'</span><span class="s1">,  </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">f3'</span><span class="s1">: </span><span class="s3">'o'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">f4'</span><span class="s1">: </span><span class="s3">'o'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">f5'</span><span class="s1">: </span><span class="s3">'o'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">f6'</span><span class="s1">: </span><span class="s3">'o'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">f8'</span><span class="s1">: </span><span class="s3">'o'</span><span class="s1">,</span>
    <span class="s3">'</span><span class="s5">\x</span><span class="s3">d9'</span><span class="s1">: </span><span class="s3">'U'</span><span class="s1">,  </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">da'</span><span class="s1">: </span><span class="s3">'U'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">db'</span><span class="s1">: </span><span class="s3">'U'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">dc'</span><span class="s1">: </span><span class="s3">'U'</span><span class="s1">,</span>
    <span class="s3">'</span><span class="s5">\x</span><span class="s3">f9'</span><span class="s1">: </span><span class="s3">'u'</span><span class="s1">,  </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">fa'</span><span class="s1">: </span><span class="s3">'u'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">fb'</span><span class="s1">: </span><span class="s3">'u'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">fc'</span><span class="s1">: </span><span class="s3">'u'</span><span class="s1">,</span>
    <span class="s3">'</span><span class="s5">\x</span><span class="s3">dd'</span><span class="s1">: </span><span class="s3">'Y'</span><span class="s1">,  </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">fd'</span><span class="s1">: </span><span class="s3">'y'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">ff'</span><span class="s1">: </span><span class="s3">'y'</span><span class="s1">,</span>
    <span class="s3">'</span><span class="s5">\x</span><span class="s3">c6'</span><span class="s1">: </span><span class="s3">'Ae'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">e6'</span><span class="s1">: </span><span class="s3">'ae'</span><span class="s1">,</span>
    <span class="s3">'</span><span class="s5">\x</span><span class="s3">de'</span><span class="s1">: </span><span class="s3">'Th'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">fe'</span><span class="s1">: </span><span class="s3">'th'</span><span class="s1">,</span>
    <span class="s3">'</span><span class="s5">\x</span><span class="s3">df'</span><span class="s1">: </span><span class="s3">'ss'</span><span class="s1">,</span>
    <span class="s0">// Latin Extended-A block.</span>
    <span class="s3">'</span><span class="s5">\u0100</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'A'</span><span class="s1">,  </span><span class="s3">'</span><span class="s5">\u0102</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'A'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u0104</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'A'</span><span class="s1">,</span>
    <span class="s3">'</span><span class="s5">\u0101</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'a'</span><span class="s1">,  </span><span class="s3">'</span><span class="s5">\u0103</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'a'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u0105</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'a'</span><span class="s1">,</span>
    <span class="s3">'</span><span class="s5">\u0106</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'C'</span><span class="s1">,  </span><span class="s3">'</span><span class="s5">\u0108</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'C'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u010a</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'C'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u010c</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'C'</span><span class="s1">,</span>
    <span class="s3">'</span><span class="s5">\u0107</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'c'</span><span class="s1">,  </span><span class="s3">'</span><span class="s5">\u0109</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'c'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u010b</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'c'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u010d</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'c'</span><span class="s1">,</span>
    <span class="s3">'</span><span class="s5">\u010e</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'D'</span><span class="s1">,  </span><span class="s3">'</span><span class="s5">\u0110</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'D'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u010f</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'d'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u0111</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'d'</span><span class="s1">,</span>
    <span class="s3">'</span><span class="s5">\u0112</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'E'</span><span class="s1">,  </span><span class="s3">'</span><span class="s5">\u0114</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'E'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u0116</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'E'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u0118</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'E'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u011a</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'E'</span><span class="s1">,</span>
    <span class="s3">'</span><span class="s5">\u0113</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'e'</span><span class="s1">,  </span><span class="s3">'</span><span class="s5">\u0115</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'e'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u0117</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'e'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u0119</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'e'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u011b</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'e'</span><span class="s1">,</span>
    <span class="s3">'</span><span class="s5">\u011c</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'G'</span><span class="s1">,  </span><span class="s3">'</span><span class="s5">\u011e</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'G'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u0120</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'G'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u0122</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'G'</span><span class="s1">,</span>
    <span class="s3">'</span><span class="s5">\u011d</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'g'</span><span class="s1">,  </span><span class="s3">'</span><span class="s5">\u011f</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'g'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u0121</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'g'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u0123</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'g'</span><span class="s1">,</span>
    <span class="s3">'</span><span class="s5">\u0124</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'H'</span><span class="s1">,  </span><span class="s3">'</span><span class="s5">\u0126</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'H'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u0125</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'h'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u0127</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'h'</span><span class="s1">,</span>
    <span class="s3">'</span><span class="s5">\u0128</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'I'</span><span class="s1">,  </span><span class="s3">'</span><span class="s5">\u012a</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'I'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u012c</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'I'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u012e</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'I'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u0130</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'I'</span><span class="s1">,</span>
    <span class="s3">'</span><span class="s5">\u0129</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'i'</span><span class="s1">,  </span><span class="s3">'</span><span class="s5">\u012b</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'i'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u012d</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'i'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u012f</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'i'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u0131</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'i'</span><span class="s1">,</span>
    <span class="s3">'</span><span class="s5">\u0134</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'J'</span><span class="s1">,  </span><span class="s3">'</span><span class="s5">\u0135</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'j'</span><span class="s1">,</span>
    <span class="s3">'</span><span class="s5">\u0136</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'K'</span><span class="s1">,  </span><span class="s3">'</span><span class="s5">\u0137</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'k'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u0138</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'k'</span><span class="s1">,</span>
    <span class="s3">'</span><span class="s5">\u0139</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'L'</span><span class="s1">,  </span><span class="s3">'</span><span class="s5">\u013b</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'L'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u013d</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'L'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u013f</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'L'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u0141</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'L'</span><span class="s1">,</span>
    <span class="s3">'</span><span class="s5">\u013a</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'l'</span><span class="s1">,  </span><span class="s3">'</span><span class="s5">\u013c</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'l'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u013e</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'l'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u0140</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'l'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u0142</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'l'</span><span class="s1">,</span>
    <span class="s3">'</span><span class="s5">\u0143</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'N'</span><span class="s1">,  </span><span class="s3">'</span><span class="s5">\u0145</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'N'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u0147</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'N'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u014a</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'N'</span><span class="s1">,</span>
    <span class="s3">'</span><span class="s5">\u0144</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'n'</span><span class="s1">,  </span><span class="s3">'</span><span class="s5">\u0146</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'n'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u0148</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'n'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u014b</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'n'</span><span class="s1">,</span>
    <span class="s3">'</span><span class="s5">\u014c</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'O'</span><span class="s1">,  </span><span class="s3">'</span><span class="s5">\u014e</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'O'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u0150</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'O'</span><span class="s1">,</span>
    <span class="s3">'</span><span class="s5">\u014d</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'o'</span><span class="s1">,  </span><span class="s3">'</span><span class="s5">\u014f</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'o'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u0151</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'o'</span><span class="s1">,</span>
    <span class="s3">'</span><span class="s5">\u0154</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'R'</span><span class="s1">,  </span><span class="s3">'</span><span class="s5">\u0156</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'R'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u0158</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'R'</span><span class="s1">,</span>
    <span class="s3">'</span><span class="s5">\u0155</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'r'</span><span class="s1">,  </span><span class="s3">'</span><span class="s5">\u0157</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'r'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u0159</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'r'</span><span class="s1">,</span>
    <span class="s3">'</span><span class="s5">\u015a</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'S'</span><span class="s1">,  </span><span class="s3">'</span><span class="s5">\u015c</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'S'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u015e</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'S'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u0160</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'S'</span><span class="s1">,</span>
    <span class="s3">'</span><span class="s5">\u015b</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'s'</span><span class="s1">,  </span><span class="s3">'</span><span class="s5">\u015d</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'s'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u015f</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'s'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u0161</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'s'</span><span class="s1">,</span>
    <span class="s3">'</span><span class="s5">\u0162</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'T'</span><span class="s1">,  </span><span class="s3">'</span><span class="s5">\u0164</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'T'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u0166</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'T'</span><span class="s1">,</span>
    <span class="s3">'</span><span class="s5">\u0163</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'t'</span><span class="s1">,  </span><span class="s3">'</span><span class="s5">\u0165</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'t'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u0167</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'t'</span><span class="s1">,</span>
    <span class="s3">'</span><span class="s5">\u0168</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'U'</span><span class="s1">,  </span><span class="s3">'</span><span class="s5">\u016a</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'U'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u016c</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'U'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u016e</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'U'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u0170</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'U'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u0172</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'U'</span><span class="s1">,</span>
    <span class="s3">'</span><span class="s5">\u0169</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'u'</span><span class="s1">,  </span><span class="s3">'</span><span class="s5">\u016b</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'u'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u016d</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'u'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u016f</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'u'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u0171</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'u'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u0173</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'u'</span><span class="s1">,</span>
    <span class="s3">'</span><span class="s5">\u0174</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'W'</span><span class="s1">,  </span><span class="s3">'</span><span class="s5">\u0175</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'w'</span><span class="s1">,</span>
    <span class="s3">'</span><span class="s5">\u0176</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'Y'</span><span class="s1">,  </span><span class="s3">'</span><span class="s5">\u0177</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'y'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u0178</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'Y'</span><span class="s1">,</span>
    <span class="s3">'</span><span class="s5">\u0179</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'Z'</span><span class="s1">,  </span><span class="s3">'</span><span class="s5">\u017b</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'Z'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u017d</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'Z'</span><span class="s1">,</span>
    <span class="s3">'</span><span class="s5">\u017a</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'z'</span><span class="s1">,  </span><span class="s3">'</span><span class="s5">\u017c</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'z'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u017e</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'z'</span><span class="s1">,</span>
    <span class="s3">'</span><span class="s5">\u0132</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'IJ'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u0133</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'ij'</span><span class="s1">,</span>
    <span class="s3">'</span><span class="s5">\u0152</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'Oe'</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u0153</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'oe'</span><span class="s1">,</span>
    <span class="s3">'</span><span class="s5">\u0149</span><span class="s3">'</span><span class="s1">: </span><span class="s3">&quot;'n&quot;</span><span class="s1">, </span><span class="s3">'</span><span class="s5">\u017f</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'s'</span>
  <span class="s1">};</span>

  <span class="s0">/** Used to map characters to HTML entities. */</span>
  <span class="s2">var </span><span class="s1">htmlEscapes = {</span>
    <span class="s3">'&amp;'</span><span class="s1">: </span><span class="s3">'&amp;amp;'</span><span class="s1">,</span>
    <span class="s3">'&lt;'</span><span class="s1">: </span><span class="s3">'&amp;lt;'</span><span class="s1">,</span>
    <span class="s3">'&gt;'</span><span class="s1">: </span><span class="s3">'&amp;gt;'</span><span class="s1">,</span>
    <span class="s3">'&quot;'</span><span class="s1">: </span><span class="s3">'&amp;quot;'</span><span class="s1">,</span>
    <span class="s3">&quot;'&quot;</span><span class="s1">: </span><span class="s3">'&amp;#39;'</span>
  <span class="s1">};</span>

  <span class="s0">/** Used to map HTML entities to characters. */</span>
  <span class="s2">var </span><span class="s1">htmlUnescapes = {</span>
    <span class="s3">'&amp;amp;'</span><span class="s1">: </span><span class="s3">'&amp;'</span><span class="s1">,</span>
    <span class="s3">'&amp;lt;'</span><span class="s1">: </span><span class="s3">'&lt;'</span><span class="s1">,</span>
    <span class="s3">'&amp;gt;'</span><span class="s1">: </span><span class="s3">'&gt;'</span><span class="s1">,</span>
    <span class="s3">'&amp;quot;'</span><span class="s1">: </span><span class="s3">'&quot;'</span><span class="s1">,</span>
    <span class="s3">'&amp;#39;'</span><span class="s1">: </span><span class="s3">&quot;'&quot;</span>
  <span class="s1">};</span>

  <span class="s0">/** Used to escape characters for inclusion in compiled string literals. */</span>
  <span class="s2">var </span><span class="s1">stringEscapes = {</span>
    <span class="s3">'</span><span class="s5">\\</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'</span><span class="s5">\\</span><span class="s3">'</span><span class="s1">,</span>
    <span class="s3">&quot;'&quot;</span><span class="s1">: </span><span class="s3">&quot;'&quot;</span><span class="s1">,</span>
    <span class="s3">'</span><span class="s5">\n</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'n'</span><span class="s1">,</span>
    <span class="s3">'</span><span class="s5">\r</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'r'</span><span class="s1">,</span>
    <span class="s3">'</span><span class="s5">\u2028</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'u2028'</span><span class="s1">,</span>
    <span class="s3">'</span><span class="s5">\u2029</span><span class="s3">'</span><span class="s1">: </span><span class="s3">'u2029'</span>
  <span class="s1">};</span>

  <span class="s0">/** Built-in method references without a dependency on `root`. */</span>
  <span class="s2">var </span><span class="s1">freeParseFloat = parseFloat,</span>
      <span class="s1">freeParseInt = parseInt;</span>

  <span class="s0">/** Detect free variable `global` from Node.js. */</span>
  <span class="s2">var </span><span class="s1">freeGlobal = </span><span class="s2">typeof </span><span class="s1">global == </span><span class="s3">'object' </span><span class="s1">&amp;&amp; global &amp;&amp; global.Object === Object &amp;&amp; global;</span>

  <span class="s0">/** Detect free variable `self`. */</span>
  <span class="s2">var </span><span class="s1">freeSelf = </span><span class="s2">typeof </span><span class="s1">self == </span><span class="s3">'object' </span><span class="s1">&amp;&amp; self &amp;&amp; self.Object === Object &amp;&amp; self;</span>

  <span class="s0">/** Used as a reference to the global object. */</span>
  <span class="s2">var </span><span class="s1">root = freeGlobal || freeSelf || Function(</span><span class="s3">'return this'</span><span class="s1">)();</span>

  <span class="s0">/** Detect free variable `exports`. */</span>
  <span class="s2">var </span><span class="s1">freeExports = </span><span class="s2">typeof </span><span class="s1">exports == </span><span class="s3">'object' </span><span class="s1">&amp;&amp; exports &amp;&amp; !exports.nodeType &amp;&amp; exports;</span>

  <span class="s0">/** Detect free variable `module`. */</span>
  <span class="s2">var </span><span class="s1">freeModule = freeExports &amp;&amp; </span><span class="s2">typeof </span><span class="s1">module == </span><span class="s3">'object' </span><span class="s1">&amp;&amp; module &amp;&amp; !module.nodeType &amp;&amp; module;</span>

  <span class="s0">/** Detect the popular CommonJS extension `module.exports`. */</span>
  <span class="s2">var </span><span class="s1">moduleExports = freeModule &amp;&amp; freeModule.exports === freeExports;</span>

  <span class="s0">/** Detect free variable `process` from Node.js. */</span>
  <span class="s2">var </span><span class="s1">freeProcess = moduleExports &amp;&amp; freeGlobal.process;</span>

  <span class="s0">/** Used to access faster Node.js helpers. */</span>
  <span class="s2">var </span><span class="s1">nodeUtil = (</span><span class="s2">function</span><span class="s1">() {</span>
    <span class="s2">try </span><span class="s1">{</span>
      <span class="s0">// Use `util.types` for Node.js 10+.</span>
      <span class="s2">var </span><span class="s1">types = freeModule &amp;&amp; freeModule.require &amp;&amp; freeModule.require(</span><span class="s3">'util'</span><span class="s1">).types;</span>

      <span class="s2">if </span><span class="s1">(types) {</span>
        <span class="s2">return </span><span class="s1">types;</span>
      <span class="s1">}</span>

      <span class="s0">// Legacy `process.binding('util')` for Node.js &lt; 10.</span>
      <span class="s2">return </span><span class="s1">freeProcess &amp;&amp; freeProcess.binding &amp;&amp; freeProcess.binding(</span><span class="s3">'util'</span><span class="s1">);</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(e) {}</span>
  <span class="s1">}());</span>

  <span class="s0">/* Node.js helper references. */</span>
  <span class="s2">var </span><span class="s1">nodeIsArrayBuffer = nodeUtil &amp;&amp; nodeUtil.isArrayBuffer,</span>
      <span class="s1">nodeIsDate = nodeUtil &amp;&amp; nodeUtil.isDate,</span>
      <span class="s1">nodeIsMap = nodeUtil &amp;&amp; nodeUtil.isMap,</span>
      <span class="s1">nodeIsRegExp = nodeUtil &amp;&amp; nodeUtil.isRegExp,</span>
      <span class="s1">nodeIsSet = nodeUtil &amp;&amp; nodeUtil.isSet,</span>
      <span class="s1">nodeIsTypedArray = nodeUtil &amp;&amp; nodeUtil.isTypedArray;</span>

  <span class="s0">/*--------------------------------------------------------------------------*/</span>

  <span class="s0">/** 
   * A faster alternative to `Function#apply`, this function invokes `func` 
   * with the `this` binding of `thisArg` and the arguments of `args`. 
   * 
   * @private 
   * @param {Function} func The function to invoke. 
   * @param {*} thisArg The `this` binding of `func`. 
   * @param {Array} args The arguments to invoke `func` with. 
   * @returns {*} Returns the result of `func`. 
   */</span>
  <span class="s2">function </span><span class="s1">apply(func, thisArg, args) {</span>
    <span class="s2">switch </span><span class="s1">(args.length) {</span>
      <span class="s2">case </span><span class="s4">0</span><span class="s1">: </span><span class="s2">return </span><span class="s1">func.call(thisArg);</span>
      <span class="s2">case </span><span class="s4">1</span><span class="s1">: </span><span class="s2">return </span><span class="s1">func.call(thisArg, args[</span><span class="s4">0</span><span class="s1">]);</span>
      <span class="s2">case </span><span class="s4">2</span><span class="s1">: </span><span class="s2">return </span><span class="s1">func.call(thisArg, args[</span><span class="s4">0</span><span class="s1">], args[</span><span class="s4">1</span><span class="s1">]);</span>
      <span class="s2">case </span><span class="s4">3</span><span class="s1">: </span><span class="s2">return </span><span class="s1">func.call(thisArg, args[</span><span class="s4">0</span><span class="s1">], args[</span><span class="s4">1</span><span class="s1">], args[</span><span class="s4">2</span><span class="s1">]);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">func.apply(thisArg, args);</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * A specialized version of `baseAggregator` for arrays. 
   * 
   * @private 
   * @param {Array} [array] The array to iterate over. 
   * @param {Function} setter The function to set `accumulator` values. 
   * @param {Function} iteratee The iteratee to transform keys. 
   * @param {Object} accumulator The initial aggregated object. 
   * @returns {Function} Returns `accumulator`. 
   */</span>
  <span class="s2">function </span><span class="s1">arrayAggregator(array, setter, iteratee, accumulator) {</span>
    <span class="s2">var </span><span class="s1">index = -</span><span class="s4">1</span><span class="s1">,</span>
        <span class="s1">length = array == </span><span class="s2">null </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: array.length;</span>

    <span class="s2">while </span><span class="s1">(++index &lt; length) {</span>
      <span class="s2">var </span><span class="s1">value = array[index];</span>
      <span class="s1">setter(accumulator, value, iteratee(value), array);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">accumulator;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * A specialized version of `_.forEach` for arrays without support for 
   * iteratee shorthands. 
   * 
   * @private 
   * @param {Array} [array] The array to iterate over. 
   * @param {Function} iteratee The function invoked per iteration. 
   * @returns {Array} Returns `array`. 
   */</span>
  <span class="s2">function </span><span class="s1">arrayEach(array, iteratee) {</span>
    <span class="s2">var </span><span class="s1">index = -</span><span class="s4">1</span><span class="s1">,</span>
        <span class="s1">length = array == </span><span class="s2">null </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: array.length;</span>

    <span class="s2">while </span><span class="s1">(++index &lt; length) {</span>
      <span class="s2">if </span><span class="s1">(iteratee(array[index], index, array) === </span><span class="s2">false</span><span class="s1">) {</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">array;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * A specialized version of `_.forEachRight` for arrays without support for 
   * iteratee shorthands. 
   * 
   * @private 
   * @param {Array} [array] The array to iterate over. 
   * @param {Function} iteratee The function invoked per iteration. 
   * @returns {Array} Returns `array`. 
   */</span>
  <span class="s2">function </span><span class="s1">arrayEachRight(array, iteratee) {</span>
    <span class="s2">var </span><span class="s1">length = array == </span><span class="s2">null </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: array.length;</span>

    <span class="s2">while </span><span class="s1">(length--) {</span>
      <span class="s2">if </span><span class="s1">(iteratee(array[length], length, array) === </span><span class="s2">false</span><span class="s1">) {</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">array;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * A specialized version of `_.every` for arrays without support for 
   * iteratee shorthands. 
   * 
   * @private 
   * @param {Array} [array] The array to iterate over. 
   * @param {Function} predicate The function invoked per iteration. 
   * @returns {boolean} Returns `true` if all elements pass the predicate check, 
   *  else `false`. 
   */</span>
  <span class="s2">function </span><span class="s1">arrayEvery(array, predicate) {</span>
    <span class="s2">var </span><span class="s1">index = -</span><span class="s4">1</span><span class="s1">,</span>
        <span class="s1">length = array == </span><span class="s2">null </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: array.length;</span>

    <span class="s2">while </span><span class="s1">(++index &lt; length) {</span>
      <span class="s2">if </span><span class="s1">(!predicate(array[index], index, array)) {</span>
        <span class="s2">return false</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return true</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * A specialized version of `_.filter` for arrays without support for 
   * iteratee shorthands. 
   * 
   * @private 
   * @param {Array} [array] The array to iterate over. 
   * @param {Function} predicate The function invoked per iteration. 
   * @returns {Array} Returns the new filtered array. 
   */</span>
  <span class="s2">function </span><span class="s1">arrayFilter(array, predicate) {</span>
    <span class="s2">var </span><span class="s1">index = -</span><span class="s4">1</span><span class="s1">,</span>
        <span class="s1">length = array == </span><span class="s2">null </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: array.length,</span>
        <span class="s1">resIndex = </span><span class="s4">0</span><span class="s1">,</span>
        <span class="s1">result = [];</span>

    <span class="s2">while </span><span class="s1">(++index &lt; length) {</span>
      <span class="s2">var </span><span class="s1">value = array[index];</span>
      <span class="s2">if </span><span class="s1">(predicate(value, index, array)) {</span>
        <span class="s1">result[resIndex++] = value;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">result;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * A specialized version of `_.includes` for arrays without support for 
   * specifying an index to search from. 
   * 
   * @private 
   * @param {Array} [array] The array to inspect. 
   * @param {*} target The value to search for. 
   * @returns {boolean} Returns `true` if `target` is found, else `false`. 
   */</span>
  <span class="s2">function </span><span class="s1">arrayIncludes(array, value) {</span>
    <span class="s2">var </span><span class="s1">length = array == </span><span class="s2">null </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: array.length;</span>
    <span class="s2">return </span><span class="s1">!!length &amp;&amp; baseIndexOf(array, value, </span><span class="s4">0</span><span class="s1">) &gt; -</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * This function is like `arrayIncludes` except that it accepts a comparator. 
   * 
   * @private 
   * @param {Array} [array] The array to inspect. 
   * @param {*} target The value to search for. 
   * @param {Function} comparator The comparator invoked per element. 
   * @returns {boolean} Returns `true` if `target` is found, else `false`. 
   */</span>
  <span class="s2">function </span><span class="s1">arrayIncludesWith(array, value, comparator) {</span>
    <span class="s2">var </span><span class="s1">index = -</span><span class="s4">1</span><span class="s1">,</span>
        <span class="s1">length = array == </span><span class="s2">null </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: array.length;</span>

    <span class="s2">while </span><span class="s1">(++index &lt; length) {</span>
      <span class="s2">if </span><span class="s1">(comparator(value, array[index])) {</span>
        <span class="s2">return true</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return false</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * A specialized version of `_.map` for arrays without support for iteratee 
   * shorthands. 
   * 
   * @private 
   * @param {Array} [array] The array to iterate over. 
   * @param {Function} iteratee The function invoked per iteration. 
   * @returns {Array} Returns the new mapped array. 
   */</span>
  <span class="s2">function </span><span class="s1">arrayMap(array, iteratee) {</span>
    <span class="s2">var </span><span class="s1">index = -</span><span class="s4">1</span><span class="s1">,</span>
        <span class="s1">length = array == </span><span class="s2">null </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: array.length,</span>
        <span class="s1">result = Array(length);</span>

    <span class="s2">while </span><span class="s1">(++index &lt; length) {</span>
      <span class="s1">result[index] = iteratee(array[index], index, array);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">result;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Appends the elements of `values` to `array`. 
   * 
   * @private 
   * @param {Array} array The array to modify. 
   * @param {Array} values The values to append. 
   * @returns {Array} Returns `array`. 
   */</span>
  <span class="s2">function </span><span class="s1">arrayPush(array, values) {</span>
    <span class="s2">var </span><span class="s1">index = -</span><span class="s4">1</span><span class="s1">,</span>
        <span class="s1">length = values.length,</span>
        <span class="s1">offset = array.length;</span>

    <span class="s2">while </span><span class="s1">(++index &lt; length) {</span>
      <span class="s1">array[offset + index] = values[index];</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">array;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * A specialized version of `_.reduce` for arrays without support for 
   * iteratee shorthands. 
   * 
   * @private 
   * @param {Array} [array] The array to iterate over. 
   * @param {Function} iteratee The function invoked per iteration. 
   * @param {*} [accumulator] The initial value. 
   * @param {boolean} [initAccum] Specify using the first element of `array` as 
   *  the initial value. 
   * @returns {*} Returns the accumulated value. 
   */</span>
  <span class="s2">function </span><span class="s1">arrayReduce(array, iteratee, accumulator, initAccum) {</span>
    <span class="s2">var </span><span class="s1">index = -</span><span class="s4">1</span><span class="s1">,</span>
        <span class="s1">length = array == </span><span class="s2">null </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: array.length;</span>

    <span class="s2">if </span><span class="s1">(initAccum &amp;&amp; length) {</span>
      <span class="s1">accumulator = array[++index];</span>
    <span class="s1">}</span>
    <span class="s2">while </span><span class="s1">(++index &lt; length) {</span>
      <span class="s1">accumulator = iteratee(accumulator, array[index], index, array);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">accumulator;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * A specialized version of `_.reduceRight` for arrays without support for 
   * iteratee shorthands. 
   * 
   * @private 
   * @param {Array} [array] The array to iterate over. 
   * @param {Function} iteratee The function invoked per iteration. 
   * @param {*} [accumulator] The initial value. 
   * @param {boolean} [initAccum] Specify using the last element of `array` as 
   *  the initial value. 
   * @returns {*} Returns the accumulated value. 
   */</span>
  <span class="s2">function </span><span class="s1">arrayReduceRight(array, iteratee, accumulator, initAccum) {</span>
    <span class="s2">var </span><span class="s1">length = array == </span><span class="s2">null </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: array.length;</span>
    <span class="s2">if </span><span class="s1">(initAccum &amp;&amp; length) {</span>
      <span class="s1">accumulator = array[--length];</span>
    <span class="s1">}</span>
    <span class="s2">while </span><span class="s1">(length--) {</span>
      <span class="s1">accumulator = iteratee(accumulator, array[length], length, array);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">accumulator;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * A specialized version of `_.some` for arrays without support for iteratee 
   * shorthands. 
   * 
   * @private 
   * @param {Array} [array] The array to iterate over. 
   * @param {Function} predicate The function invoked per iteration. 
   * @returns {boolean} Returns `true` if any element passes the predicate check, 
   *  else `false`. 
   */</span>
  <span class="s2">function </span><span class="s1">arraySome(array, predicate) {</span>
    <span class="s2">var </span><span class="s1">index = -</span><span class="s4">1</span><span class="s1">,</span>
        <span class="s1">length = array == </span><span class="s2">null </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: array.length;</span>

    <span class="s2">while </span><span class="s1">(++index &lt; length) {</span>
      <span class="s2">if </span><span class="s1">(predicate(array[index], index, array)) {</span>
        <span class="s2">return true</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return false</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Gets the size of an ASCII `string`. 
   * 
   * @private 
   * @param {string} string The string inspect. 
   * @returns {number} Returns the string size. 
   */</span>
  <span class="s2">var </span><span class="s1">asciiSize = baseProperty(</span><span class="s3">'length'</span><span class="s1">);</span>

  <span class="s0">/** 
   * Converts an ASCII `string` to an array. 
   * 
   * @private 
   * @param {string} string The string to convert. 
   * @returns {Array} Returns the converted array. 
   */</span>
  <span class="s2">function </span><span class="s1">asciiToArray(string) {</span>
    <span class="s2">return </span><span class="s1">string.split(</span><span class="s3">''</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Splits an ASCII `string` into an array of its words. 
   * 
   * @private 
   * @param {string} The string to inspect. 
   * @returns {Array} Returns the words of `string`. 
   */</span>
  <span class="s2">function </span><span class="s1">asciiWords(string) {</span>
    <span class="s2">return </span><span class="s1">string.match(reAsciiWord) || [];</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * The base implementation of methods like `_.findKey` and `_.findLastKey`, 
   * without support for iteratee shorthands, which iterates over `collection` 
   * using `eachFunc`. 
   * 
   * @private 
   * @param {Array|Object} collection The collection to inspect. 
   * @param {Function} predicate The function invoked per iteration. 
   * @param {Function} eachFunc The function to iterate over `collection`. 
   * @returns {*} Returns the found element or its key, else `undefined`. 
   */</span>
  <span class="s2">function </span><span class="s1">baseFindKey(collection, predicate, eachFunc) {</span>
    <span class="s2">var </span><span class="s1">result;</span>
    <span class="s1">eachFunc(collection, </span><span class="s2">function</span><span class="s1">(value, key, collection) {</span>
      <span class="s2">if </span><span class="s1">(predicate(value, key, collection)) {</span>
        <span class="s1">result = key;</span>
        <span class="s2">return false</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s2">return </span><span class="s1">result;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * The base implementation of `_.findIndex` and `_.findLastIndex` without 
   * support for iteratee shorthands. 
   * 
   * @private 
   * @param {Array} array The array to inspect. 
   * @param {Function} predicate The function invoked per iteration. 
   * @param {number} fromIndex The index to search from. 
   * @param {boolean} [fromRight] Specify iterating from right to left. 
   * @returns {number} Returns the index of the matched value, else `-1`. 
   */</span>
  <span class="s2">function </span><span class="s1">baseFindIndex(array, predicate, fromIndex, fromRight) {</span>
    <span class="s2">var </span><span class="s1">length = array.length,</span>
        <span class="s1">index = fromIndex + (fromRight ? </span><span class="s4">1 </span><span class="s1">: -</span><span class="s4">1</span><span class="s1">);</span>

    <span class="s2">while </span><span class="s1">((fromRight ? index-- : ++index &lt; length)) {</span>
      <span class="s2">if </span><span class="s1">(predicate(array[index], index, array)) {</span>
        <span class="s2">return </span><span class="s1">index;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">-</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks. 
   * 
   * @private 
   * @param {Array} array The array to inspect. 
   * @param {*} value The value to search for. 
   * @param {number} fromIndex The index to search from. 
   * @returns {number} Returns the index of the matched value, else `-1`. 
   */</span>
  <span class="s2">function </span><span class="s1">baseIndexOf(array, value, fromIndex) {</span>
    <span class="s2">return </span><span class="s1">value === value</span>
      <span class="s1">? strictIndexOf(array, value, fromIndex)</span>
      <span class="s1">: baseFindIndex(array, baseIsNaN, fromIndex);</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * This function is like `baseIndexOf` except that it accepts a comparator. 
   * 
   * @private 
   * @param {Array} array The array to inspect. 
   * @param {*} value The value to search for. 
   * @param {number} fromIndex The index to search from. 
   * @param {Function} comparator The comparator invoked per element. 
   * @returns {number} Returns the index of the matched value, else `-1`. 
   */</span>
  <span class="s2">function </span><span class="s1">baseIndexOfWith(array, value, fromIndex, comparator) {</span>
    <span class="s2">var </span><span class="s1">index = fromIndex - </span><span class="s4">1</span><span class="s1">,</span>
        <span class="s1">length = array.length;</span>

    <span class="s2">while </span><span class="s1">(++index &lt; length) {</span>
      <span class="s2">if </span><span class="s1">(comparator(array[index], value)) {</span>
        <span class="s2">return </span><span class="s1">index;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">-</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * The base implementation of `_.isNaN` without support for number objects. 
   * 
   * @private 
   * @param {*} value The value to check. 
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`. 
   */</span>
  <span class="s2">function </span><span class="s1">baseIsNaN(value) {</span>
    <span class="s2">return </span><span class="s1">value !== value;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * The base implementation of `_.mean` and `_.meanBy` without support for 
   * iteratee shorthands. 
   * 
   * @private 
   * @param {Array} array The array to iterate over. 
   * @param {Function} iteratee The function invoked per iteration. 
   * @returns {number} Returns the mean. 
   */</span>
  <span class="s2">function </span><span class="s1">baseMean(array, iteratee) {</span>
    <span class="s2">var </span><span class="s1">length = array == </span><span class="s2">null </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: array.length;</span>
    <span class="s2">return </span><span class="s1">length ? (baseSum(array, iteratee) / length) : NAN;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * The base implementation of `_.property` without support for deep paths. 
   * 
   * @private 
   * @param {string} key The key of the property to get. 
   * @returns {Function} Returns the new accessor function. 
   */</span>
  <span class="s2">function </span><span class="s1">baseProperty(key) {</span>
    <span class="s2">return function</span><span class="s1">(object) {</span>
      <span class="s2">return </span><span class="s1">object == </span><span class="s2">null </span><span class="s1">? undefined : object[key];</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * The base implementation of `_.propertyOf` without support for deep paths. 
   * 
   * @private 
   * @param {Object} object The object to query. 
   * @returns {Function} Returns the new accessor function. 
   */</span>
  <span class="s2">function </span><span class="s1">basePropertyOf(object) {</span>
    <span class="s2">return function</span><span class="s1">(key) {</span>
      <span class="s2">return </span><span class="s1">object == </span><span class="s2">null </span><span class="s1">? undefined : object[key];</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * The base implementation of `_.reduce` and `_.reduceRight`, without support 
   * for iteratee shorthands, which iterates over `collection` using `eachFunc`. 
   * 
   * @private 
   * @param {Array|Object} collection The collection to iterate over. 
   * @param {Function} iteratee The function invoked per iteration. 
   * @param {*} accumulator The initial value. 
   * @param {boolean} initAccum Specify using the first or last element of 
   *  `collection` as the initial value. 
   * @param {Function} eachFunc The function to iterate over `collection`. 
   * @returns {*} Returns the accumulated value. 
   */</span>
  <span class="s2">function </span><span class="s1">baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {</span>
    <span class="s1">eachFunc(collection, </span><span class="s2">function</span><span class="s1">(value, index, collection) {</span>
      <span class="s1">accumulator = initAccum</span>
        <span class="s1">? (initAccum = </span><span class="s2">false</span><span class="s1">, value)</span>
        <span class="s1">: iteratee(accumulator, value, index, collection);</span>
    <span class="s1">});</span>
    <span class="s2">return </span><span class="s1">accumulator;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * The base implementation of `_.sortBy` which uses `comparer` to define the 
   * sort order of `array` and replaces criteria objects with their corresponding 
   * values. 
   * 
   * @private 
   * @param {Array} array The array to sort. 
   * @param {Function} comparer The function to define sort order. 
   * @returns {Array} Returns `array`. 
   */</span>
  <span class="s2">function </span><span class="s1">baseSortBy(array, comparer) {</span>
    <span class="s2">var </span><span class="s1">length = array.length;</span>

    <span class="s1">array.sort(comparer);</span>
    <span class="s2">while </span><span class="s1">(length--) {</span>
      <span class="s1">array[length] = array[length].value;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">array;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * The base implementation of `_.sum` and `_.sumBy` without support for 
   * iteratee shorthands. 
   * 
   * @private 
   * @param {Array} array The array to iterate over. 
   * @param {Function} iteratee The function invoked per iteration. 
   * @returns {number} Returns the sum. 
   */</span>
  <span class="s2">function </span><span class="s1">baseSum(array, iteratee) {</span>
    <span class="s2">var </span><span class="s1">result,</span>
        <span class="s1">index = -</span><span class="s4">1</span><span class="s1">,</span>
        <span class="s1">length = array.length;</span>

    <span class="s2">while </span><span class="s1">(++index &lt; length) {</span>
      <span class="s2">var </span><span class="s1">current = iteratee(array[index]);</span>
      <span class="s2">if </span><span class="s1">(current !== undefined) {</span>
        <span class="s1">result = result === undefined ? current : (result + current);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">result;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * The base implementation of `_.times` without support for iteratee shorthands 
   * or max array length checks. 
   * 
   * @private 
   * @param {number} n The number of times to invoke `iteratee`. 
   * @param {Function} iteratee The function invoked per iteration. 
   * @returns {Array} Returns the array of results. 
   */</span>
  <span class="s2">function </span><span class="s1">baseTimes(n, iteratee) {</span>
    <span class="s2">var </span><span class="s1">index = -</span><span class="s4">1</span><span class="s1">,</span>
        <span class="s1">result = Array(n);</span>

    <span class="s2">while </span><span class="s1">(++index &lt; n) {</span>
      <span class="s1">result[index] = iteratee(index);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">result;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array 
   * of key-value pairs for `object` corresponding to the property names of `props`. 
   * 
   * @private 
   * @param {Object} object The object to query. 
   * @param {Array} props The property names to get values for. 
   * @returns {Object} Returns the key-value pairs. 
   */</span>
  <span class="s2">function </span><span class="s1">baseToPairs(object, props) {</span>
    <span class="s2">return </span><span class="s1">arrayMap(props, </span><span class="s2">function</span><span class="s1">(key) {</span>
      <span class="s2">return </span><span class="s1">[key, object[key]];</span>
    <span class="s1">});</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * The base implementation of `_.trim`. 
   * 
   * @private 
   * @param {string} string The string to trim. 
   * @returns {string} Returns the trimmed string. 
   */</span>
  <span class="s2">function </span><span class="s1">baseTrim(string) {</span>
    <span class="s2">return </span><span class="s1">string</span>
      <span class="s1">? string.slice(</span><span class="s4">0</span><span class="s1">, trimmedEndIndex(string) + </span><span class="s4">1</span><span class="s1">).replace(reTrimStart, </span><span class="s3">''</span><span class="s1">)</span>
      <span class="s1">: string;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * The base implementation of `_.unary` without support for storing metadata. 
   * 
   * @private 
   * @param {Function} func The function to cap arguments for. 
   * @returns {Function} Returns the new capped function. 
   */</span>
  <span class="s2">function </span><span class="s1">baseUnary(func) {</span>
    <span class="s2">return function</span><span class="s1">(value) {</span>
      <span class="s2">return </span><span class="s1">func(value);</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * The base implementation of `_.values` and `_.valuesIn` which creates an 
   * array of `object` property values corresponding to the property names 
   * of `props`. 
   * 
   * @private 
   * @param {Object} object The object to query. 
   * @param {Array} props The property names to get values for. 
   * @returns {Object} Returns the array of property values. 
   */</span>
  <span class="s2">function </span><span class="s1">baseValues(object, props) {</span>
    <span class="s2">return </span><span class="s1">arrayMap(props, </span><span class="s2">function</span><span class="s1">(key) {</span>
      <span class="s2">return </span><span class="s1">object[key];</span>
    <span class="s1">});</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Checks if a `cache` value for `key` exists. 
   * 
   * @private 
   * @param {Object} cache The cache to query. 
   * @param {string} key The key of the entry to check. 
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`. 
   */</span>
  <span class="s2">function </span><span class="s1">cacheHas(cache, key) {</span>
    <span class="s2">return </span><span class="s1">cache.has(key);</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol 
   * that is not found in the character symbols. 
   * 
   * @private 
   * @param {Array} strSymbols The string symbols to inspect. 
   * @param {Array} chrSymbols The character symbols to find. 
   * @returns {number} Returns the index of the first unmatched string symbol. 
   */</span>
  <span class="s2">function </span><span class="s1">charsStartIndex(strSymbols, chrSymbols) {</span>
    <span class="s2">var </span><span class="s1">index = -</span><span class="s4">1</span><span class="s1">,</span>
        <span class="s1">length = strSymbols.length;</span>

    <span class="s2">while </span><span class="s1">(++index &lt; length &amp;&amp; baseIndexOf(chrSymbols, strSymbols[index], </span><span class="s4">0</span><span class="s1">) &gt; -</span><span class="s4">1</span><span class="s1">) {}</span>
    <span class="s2">return </span><span class="s1">index;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol 
   * that is not found in the character symbols. 
   * 
   * @private 
   * @param {Array} strSymbols The string symbols to inspect. 
   * @param {Array} chrSymbols The character symbols to find. 
   * @returns {number} Returns the index of the last unmatched string symbol. 
   */</span>
  <span class="s2">function </span><span class="s1">charsEndIndex(strSymbols, chrSymbols) {</span>
    <span class="s2">var </span><span class="s1">index = strSymbols.length;</span>

    <span class="s2">while </span><span class="s1">(index-- &amp;&amp; baseIndexOf(chrSymbols, strSymbols[index], </span><span class="s4">0</span><span class="s1">) &gt; -</span><span class="s4">1</span><span class="s1">) {}</span>
    <span class="s2">return </span><span class="s1">index;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Gets the number of `placeholder` occurrences in `array`. 
   * 
   * @private 
   * @param {Array} array The array to inspect. 
   * @param {*} placeholder The placeholder to search for. 
   * @returns {number} Returns the placeholder count. 
   */</span>
  <span class="s2">function </span><span class="s1">countHolders(array, placeholder) {</span>
    <span class="s2">var </span><span class="s1">length = array.length,</span>
        <span class="s1">result = </span><span class="s4">0</span><span class="s1">;</span>

    <span class="s2">while </span><span class="s1">(length--) {</span>
      <span class="s2">if </span><span class="s1">(array[length] === placeholder) {</span>
        <span class="s1">++result;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">result;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A 
   * letters to basic Latin letters. 
   * 
   * @private 
   * @param {string} letter The matched letter to deburr. 
   * @returns {string} Returns the deburred letter. 
   */</span>
  <span class="s2">var </span><span class="s1">deburrLetter = basePropertyOf(deburredLetters);</span>

  <span class="s0">/** 
   * Used by `_.escape` to convert characters to HTML entities. 
   * 
   * @private 
   * @param {string} chr The matched character to escape. 
   * @returns {string} Returns the escaped character. 
   */</span>
  <span class="s2">var </span><span class="s1">escapeHtmlChar = basePropertyOf(htmlEscapes);</span>

  <span class="s0">/** 
   * Used by `_.template` to escape characters for inclusion in compiled string literals. 
   * 
   * @private 
   * @param {string} chr The matched character to escape. 
   * @returns {string} Returns the escaped character. 
   */</span>
  <span class="s2">function </span><span class="s1">escapeStringChar(chr) {</span>
    <span class="s2">return </span><span class="s3">'</span><span class="s5">\\</span><span class="s3">' </span><span class="s1">+ stringEscapes[chr];</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Gets the value at `key` of `object`. 
   * 
   * @private 
   * @param {Object} [object] The object to query. 
   * @param {string} key The key of the property to get. 
   * @returns {*} Returns the property value. 
   */</span>
  <span class="s2">function </span><span class="s1">getValue(object, key) {</span>
    <span class="s2">return </span><span class="s1">object == </span><span class="s2">null </span><span class="s1">? undefined : object[key];</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Checks if `string` contains Unicode symbols. 
   * 
   * @private 
   * @param {string} string The string to inspect. 
   * @returns {boolean} Returns `true` if a symbol is found, else `false`. 
   */</span>
  <span class="s2">function </span><span class="s1">hasUnicode(string) {</span>
    <span class="s2">return </span><span class="s1">reHasUnicode.test(string);</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Checks if `string` contains a word composed of Unicode symbols. 
   * 
   * @private 
   * @param {string} string The string to inspect. 
   * @returns {boolean} Returns `true` if a word is found, else `false`. 
   */</span>
  <span class="s2">function </span><span class="s1">hasUnicodeWord(string) {</span>
    <span class="s2">return </span><span class="s1">reHasUnicodeWord.test(string);</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Converts `iterator` to an array. 
   * 
   * @private 
   * @param {Object} iterator The iterator to convert. 
   * @returns {Array} Returns the converted array. 
   */</span>
  <span class="s2">function </span><span class="s1">iteratorToArray(iterator) {</span>
    <span class="s2">var </span><span class="s1">data,</span>
        <span class="s1">result = [];</span>

    <span class="s2">while </span><span class="s1">(!(data = iterator.next()).done) {</span>
      <span class="s1">result.push(data.value);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">result;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Converts `map` to its key-value pairs. 
   * 
   * @private 
   * @param {Object} map The map to convert. 
   * @returns {Array} Returns the key-value pairs. 
   */</span>
  <span class="s2">function </span><span class="s1">mapToArray(map) {</span>
    <span class="s2">var </span><span class="s1">index = -</span><span class="s4">1</span><span class="s1">,</span>
        <span class="s1">result = Array(map.size);</span>

    <span class="s1">map.forEach(</span><span class="s2">function</span><span class="s1">(value, key) {</span>
      <span class="s1">result[++index] = [key, value];</span>
    <span class="s1">});</span>
    <span class="s2">return </span><span class="s1">result;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Creates a unary function that invokes `func` with its argument transformed. 
   * 
   * @private 
   * @param {Function} func The function to wrap. 
   * @param {Function} transform The argument transform. 
   * @returns {Function} Returns the new function. 
   */</span>
  <span class="s2">function </span><span class="s1">overArg(func, transform) {</span>
    <span class="s2">return function</span><span class="s1">(arg) {</span>
      <span class="s2">return </span><span class="s1">func(transform(arg));</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Replaces all `placeholder` elements in `array` with an internal placeholder 
   * and returns an array of their indexes. 
   * 
   * @private 
   * @param {Array} array The array to modify. 
   * @param {*} placeholder The placeholder to replace. 
   * @returns {Array} Returns the new array of placeholder indexes. 
   */</span>
  <span class="s2">function </span><span class="s1">replaceHolders(array, placeholder) {</span>
    <span class="s2">var </span><span class="s1">index = -</span><span class="s4">1</span><span class="s1">,</span>
        <span class="s1">length = array.length,</span>
        <span class="s1">resIndex = </span><span class="s4">0</span><span class="s1">,</span>
        <span class="s1">result = [];</span>

    <span class="s2">while </span><span class="s1">(++index &lt; length) {</span>
      <span class="s2">var </span><span class="s1">value = array[index];</span>
      <span class="s2">if </span><span class="s1">(value === placeholder || value === PLACEHOLDER) {</span>
        <span class="s1">array[index] = PLACEHOLDER;</span>
        <span class="s1">result[resIndex++] = index;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">result;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Converts `set` to an array of its values. 
   * 
   * @private 
   * @param {Object} set The set to convert. 
   * @returns {Array} Returns the values. 
   */</span>
  <span class="s2">function </span><span class="s1">setToArray(set) {</span>
    <span class="s2">var </span><span class="s1">index = -</span><span class="s4">1</span><span class="s1">,</span>
        <span class="s1">result = Array(set.size);</span>

    <span class="s1">set.forEach(</span><span class="s2">function</span><span class="s1">(value) {</span>
      <span class="s1">result[++index] = value;</span>
    <span class="s1">});</span>
    <span class="s2">return </span><span class="s1">result;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Converts `set` to its value-value pairs. 
   * 
   * @private 
   * @param {Object} set The set to convert. 
   * @returns {Array} Returns the value-value pairs. 
   */</span>
  <span class="s2">function </span><span class="s1">setToPairs(set) {</span>
    <span class="s2">var </span><span class="s1">index = -</span><span class="s4">1</span><span class="s1">,</span>
        <span class="s1">result = Array(set.size);</span>

    <span class="s1">set.forEach(</span><span class="s2">function</span><span class="s1">(value) {</span>
      <span class="s1">result[++index] = [value, value];</span>
    <span class="s1">});</span>
    <span class="s2">return </span><span class="s1">result;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * A specialized version of `_.indexOf` which performs strict equality 
   * comparisons of values, i.e. `===`. 
   * 
   * @private 
   * @param {Array} array The array to inspect. 
   * @param {*} value The value to search for. 
   * @param {number} fromIndex The index to search from. 
   * @returns {number} Returns the index of the matched value, else `-1`. 
   */</span>
  <span class="s2">function </span><span class="s1">strictIndexOf(array, value, fromIndex) {</span>
    <span class="s2">var </span><span class="s1">index = fromIndex - </span><span class="s4">1</span><span class="s1">,</span>
        <span class="s1">length = array.length;</span>

    <span class="s2">while </span><span class="s1">(++index &lt; length) {</span>
      <span class="s2">if </span><span class="s1">(array[index] === value) {</span>
        <span class="s2">return </span><span class="s1">index;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">-</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * A specialized version of `_.lastIndexOf` which performs strict equality 
   * comparisons of values, i.e. `===`. 
   * 
   * @private 
   * @param {Array} array The array to inspect. 
   * @param {*} value The value to search for. 
   * @param {number} fromIndex The index to search from. 
   * @returns {number} Returns the index of the matched value, else `-1`. 
   */</span>
  <span class="s2">function </span><span class="s1">strictLastIndexOf(array, value, fromIndex) {</span>
    <span class="s2">var </span><span class="s1">index = fromIndex + </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s2">while </span><span class="s1">(index--) {</span>
      <span class="s2">if </span><span class="s1">(array[index] === value) {</span>
        <span class="s2">return </span><span class="s1">index;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">index;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Gets the number of symbols in `string`. 
   * 
   * @private 
   * @param {string} string The string to inspect. 
   * @returns {number} Returns the string size. 
   */</span>
  <span class="s2">function </span><span class="s1">stringSize(string) {</span>
    <span class="s2">return </span><span class="s1">hasUnicode(string)</span>
      <span class="s1">? unicodeSize(string)</span>
      <span class="s1">: asciiSize(string);</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Converts `string` to an array. 
   * 
   * @private 
   * @param {string} string The string to convert. 
   * @returns {Array} Returns the converted array. 
   */</span>
  <span class="s2">function </span><span class="s1">stringToArray(string) {</span>
    <span class="s2">return </span><span class="s1">hasUnicode(string)</span>
      <span class="s1">? unicodeToArray(string)</span>
      <span class="s1">: asciiToArray(string);</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace 
   * character of `string`. 
   * 
   * @private 
   * @param {string} string The string to inspect. 
   * @returns {number} Returns the index of the last non-whitespace character. 
   */</span>
  <span class="s2">function </span><span class="s1">trimmedEndIndex(string) {</span>
    <span class="s2">var </span><span class="s1">index = string.length;</span>

    <span class="s2">while </span><span class="s1">(index-- &amp;&amp; reWhitespace.test(string.charAt(index))) {}</span>
    <span class="s2">return </span><span class="s1">index;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Used by `_.unescape` to convert HTML entities to characters. 
   * 
   * @private 
   * @param {string} chr The matched character to unescape. 
   * @returns {string} Returns the unescaped character. 
   */</span>
  <span class="s2">var </span><span class="s1">unescapeHtmlChar = basePropertyOf(htmlUnescapes);</span>

  <span class="s0">/** 
   * Gets the size of a Unicode `string`. 
   * 
   * @private 
   * @param {string} string The string inspect. 
   * @returns {number} Returns the string size. 
   */</span>
  <span class="s2">function </span><span class="s1">unicodeSize(string) {</span>
    <span class="s2">var </span><span class="s1">result = reUnicode.lastIndex = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s2">while </span><span class="s1">(reUnicode.test(string)) {</span>
      <span class="s1">++result;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">result;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Converts a Unicode `string` to an array. 
   * 
   * @private 
   * @param {string} string The string to convert. 
   * @returns {Array} Returns the converted array. 
   */</span>
  <span class="s2">function </span><span class="s1">unicodeToArray(string) {</span>
    <span class="s2">return </span><span class="s1">string.match(reUnicode) || [];</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Splits a Unicode `string` into an array of its words. 
   * 
   * @private 
   * @param {string} The string to inspect. 
   * @returns {Array} Returns the words of `string`. 
   */</span>
  <span class="s2">function </span><span class="s1">unicodeWords(string) {</span>
    <span class="s2">return </span><span class="s1">string.match(reUnicodeWord) || [];</span>
  <span class="s1">}</span>

  <span class="s0">/*--------------------------------------------------------------------------*/</span>

  <span class="s0">/** 
   * Create a new pristine `lodash` function using the `context` object. 
   * 
   * @static 
   * @memberOf _ 
   * @since 1.1.0 
   * @category Util 
   * @param {Object} [context=root] The context object. 
   * @returns {Function} Returns a new `lodash` function. 
   * @example 
   * 
   * _.mixin({ 'foo': _.constant('foo') }); 
   * 
   * var lodash = _.runInContext(); 
   * lodash.mixin({ 'bar': lodash.constant('bar') }); 
   * 
   * _.isFunction(_.foo); 
   * // =&gt; true 
   * _.isFunction(_.bar); 
   * // =&gt; false 
   * 
   * lodash.isFunction(lodash.foo); 
   * // =&gt; false 
   * lodash.isFunction(lodash.bar); 
   * // =&gt; true 
   * 
   * // Create a suped-up `defer` in Node.js. 
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer; 
   */</span>
  <span class="s2">var </span><span class="s1">runInContext = (</span><span class="s2">function </span><span class="s1">runInContext(context) {</span>
    <span class="s1">context = context == </span><span class="s2">null </span><span class="s1">? root : _.defaults(root.Object(), context, _.pick(root, contextProps));</span>

    <span class="s0">/** Built-in constructor references. */</span>
    <span class="s2">var </span><span class="s1">Array = context.Array,</span>
        <span class="s1">Date = context.Date,</span>
        <span class="s1">Error = context.Error,</span>
        <span class="s1">Function = context.Function,</span>
        <span class="s1">Math = context.Math,</span>
        <span class="s1">Object = context.Object,</span>
        <span class="s1">RegExp = context.RegExp,</span>
        <span class="s1">String = context.String,</span>
        <span class="s1">TypeError = context.TypeError;</span>

    <span class="s0">/** Used for built-in method references. */</span>
    <span class="s2">var </span><span class="s1">arrayProto = Array.prototype,</span>
        <span class="s1">funcProto = Function.prototype,</span>
        <span class="s1">objectProto = Object.prototype;</span>

    <span class="s0">/** Used to detect overreaching core-js shims. */</span>
    <span class="s2">var </span><span class="s1">coreJsData = context[</span><span class="s3">'__core-js_shared__'</span><span class="s1">];</span>

    <span class="s0">/** Used to resolve the decompiled source of functions. */</span>
    <span class="s2">var </span><span class="s1">funcToString = funcProto.toString;</span>

    <span class="s0">/** Used to check objects for own properties. */</span>
    <span class="s2">var </span><span class="s1">hasOwnProperty = objectProto.hasOwnProperty;</span>

    <span class="s0">/** Used to generate unique IDs. */</span>
    <span class="s2">var </span><span class="s1">idCounter = </span><span class="s4">0</span><span class="s1">;</span>

    <span class="s0">/** Used to detect methods masquerading as native. */</span>
    <span class="s2">var </span><span class="s1">maskSrcKey = (</span><span class="s2">function</span><span class="s1">() {</span>
      <span class="s2">var </span><span class="s1">uid = /[^.]+$/.exec(coreJsData &amp;&amp; coreJsData.keys &amp;&amp; coreJsData.keys.IE_PROTO || </span><span class="s3">''</span><span class="s1">);</span>
      <span class="s2">return </span><span class="s1">uid ? (</span><span class="s3">'Symbol(src)_1.' </span><span class="s1">+ uid) : </span><span class="s3">''</span><span class="s1">;</span>
    <span class="s1">}());</span>

    <span class="s0">/** 
     * Used to resolve the 
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring) 
     * of values. 
     */</span>
    <span class="s2">var </span><span class="s1">nativeObjectToString = objectProto.toString;</span>

    <span class="s0">/** Used to infer the `Object` constructor. */</span>
    <span class="s2">var </span><span class="s1">objectCtorString = funcToString.call(Object);</span>

    <span class="s0">/** Used to restore the original `_` reference in `_.noConflict`. */</span>
    <span class="s2">var </span><span class="s1">oldDash = root._;</span>

    <span class="s0">/** Used to detect if a method is native. */</span>
    <span class="s2">var </span><span class="s1">reIsNative = RegExp(</span><span class="s3">'^' </span><span class="s1">+</span>
      <span class="s1">funcToString.call(hasOwnProperty).replace(reRegExpChar, </span><span class="s3">'</span><span class="s5">\\</span><span class="s3">$&amp;'</span><span class="s1">)</span>
      <span class="s1">.replace(/hasOwnProperty|(</span><span class="s2">function</span><span class="s1">).*?(?=\\\()| </span><span class="s2">for </span><span class="s1">.+?(?=\\\])/g, </span><span class="s3">'$1.*?'</span><span class="s1">) + </span><span class="s3">'$'</span>
    <span class="s1">);</span>

    <span class="s0">/** Built-in value references. */</span>
    <span class="s2">var </span><span class="s1">Buffer = moduleExports ? context.Buffer : undefined,</span>
        <span class="s1">Symbol = context.Symbol,</span>
        <span class="s1">Uint8Array = context.Uint8Array,</span>
        <span class="s1">allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,</span>
        <span class="s1">getPrototype = overArg(Object.getPrototypeOf, Object),</span>
        <span class="s1">objectCreate = Object.create,</span>
        <span class="s1">propertyIsEnumerable = objectProto.propertyIsEnumerable,</span>
        <span class="s1">splice = arrayProto.splice,</span>
        <span class="s1">spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,</span>
        <span class="s1">symIterator = Symbol ? Symbol.iterator : undefined,</span>
        <span class="s1">symToStringTag = Symbol ? Symbol.toStringTag : undefined;</span>

    <span class="s2">var </span><span class="s1">defineProperty = (</span><span class="s2">function</span><span class="s1">() {</span>
      <span class="s2">try </span><span class="s1">{</span>
        <span class="s2">var </span><span class="s1">func = getNative(Object, </span><span class="s3">'defineProperty'</span><span class="s1">);</span>
        <span class="s1">func({}, </span><span class="s3">''</span><span class="s1">, {});</span>
        <span class="s2">return </span><span class="s1">func;</span>
      <span class="s1">} </span><span class="s2">catch </span><span class="s1">(e) {}</span>
    <span class="s1">}());</span>

    <span class="s0">/** Mocked built-ins. */</span>
    <span class="s2">var </span><span class="s1">ctxClearTimeout = context.clearTimeout !== root.clearTimeout &amp;&amp; context.clearTimeout,</span>
        <span class="s1">ctxNow = Date &amp;&amp; Date.now !== root.Date.now &amp;&amp; Date.now,</span>
        <span class="s1">ctxSetTimeout = context.setTimeout !== root.setTimeout &amp;&amp; context.setTimeout;</span>

    <span class="s0">/* Built-in method references for those with the same name as other `lodash` methods. */</span>
    <span class="s2">var </span><span class="s1">nativeCeil = Math.ceil,</span>
        <span class="s1">nativeFloor = Math.floor,</span>
        <span class="s1">nativeGetSymbols = Object.getOwnPropertySymbols,</span>
        <span class="s1">nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,</span>
        <span class="s1">nativeIsFinite = context.isFinite,</span>
        <span class="s1">nativeJoin = arrayProto.join,</span>
        <span class="s1">nativeKeys = overArg(Object.keys, Object),</span>
        <span class="s1">nativeMax = Math.max,</span>
        <span class="s1">nativeMin = Math.min,</span>
        <span class="s1">nativeNow = Date.now,</span>
        <span class="s1">nativeParseInt = context.parseInt,</span>
        <span class="s1">nativeRandom = Math.random,</span>
        <span class="s1">nativeReverse = arrayProto.reverse;</span>

    <span class="s0">/* Built-in method references that are verified to be native. */</span>
    <span class="s2">var </span><span class="s1">DataView = getNative(context, </span><span class="s3">'DataView'</span><span class="s1">),</span>
        <span class="s1">Map = getNative(context, </span><span class="s3">'Map'</span><span class="s1">),</span>
        <span class="s1">Promise = getNative(context, </span><span class="s3">'Promise'</span><span class="s1">),</span>
        <span class="s1">Set = getNative(context, </span><span class="s3">'Set'</span><span class="s1">),</span>
        <span class="s1">WeakMap = getNative(context, </span><span class="s3">'WeakMap'</span><span class="s1">),</span>
        <span class="s1">nativeCreate = getNative(Object, </span><span class="s3">'create'</span><span class="s1">);</span>

    <span class="s0">/** Used to store function metadata. */</span>
    <span class="s2">var </span><span class="s1">metaMap = WeakMap &amp;&amp; </span><span class="s2">new </span><span class="s1">WeakMap;</span>

    <span class="s0">/** Used to lookup unminified function names. */</span>
    <span class="s2">var </span><span class="s1">realNames = {};</span>

    <span class="s0">/** Used to detect maps, sets, and weakmaps. */</span>
    <span class="s2">var </span><span class="s1">dataViewCtorString = toSource(DataView),</span>
        <span class="s1">mapCtorString = toSource(Map),</span>
        <span class="s1">promiseCtorString = toSource(Promise),</span>
        <span class="s1">setCtorString = toSource(Set),</span>
        <span class="s1">weakMapCtorString = toSource(WeakMap);</span>

    <span class="s0">/** Used to convert symbols to primitives and strings. */</span>
    <span class="s2">var </span><span class="s1">symbolProto = Symbol ? Symbol.prototype : undefined,</span>
        <span class="s1">symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,</span>
        <span class="s1">symbolToString = symbolProto ? symbolProto.toString : undefined;</span>

    <span class="s0">/*------------------------------------------------------------------------*/</span>

    <span class="s0">/** 
     * Creates a `lodash` object which wraps `value` to enable implicit method 
     * chain sequences. Methods that operate on and return arrays, collections, 
     * and functions can be chained together. Methods that retrieve a single value 
     * or may return a primitive value will automatically end the chain sequence 
     * and return the unwrapped value. Otherwise, the value must be unwrapped 
     * with `_#value`. 
     * 
     * Explicit chain sequences, which must be unwrapped with `_#value`, may be 
     * enabled using `_.chain`. 
     * 
     * The execution of chained methods is lazy, that is, it's deferred until 
     * `_#value` is implicitly or explicitly called. 
     * 
     * Lazy evaluation allows several methods to support shortcut fusion. 
     * Shortcut fusion is an optimization to merge iteratee calls; this avoids 
     * the creation of intermediate arrays and can greatly reduce the number of 
     * iteratee executions. Sections of a chain sequence qualify for shortcut 
     * fusion if the section is applied to an array and iteratees accept only 
     * one argument. The heuristic for whether a section qualifies for shortcut 
     * fusion is subject to change. 
     * 
     * Chaining is supported in custom builds as long as the `_#value` method is 
     * directly or indirectly included in the build. 
     * 
     * In addition to lodash methods, wrappers have `Array` and `String` methods. 
     * 
     * The wrapper `Array` methods are: 
     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift` 
     * 
     * The wrapper `String` methods are: 
     * `replace` and `split` 
     * 
     * The wrapper methods that support shortcut fusion are: 
     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`, 
     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`, 
     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray` 
     * 
     * The chainable wrapper methods are: 
     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`, 
     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`, 
     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`, 
     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`, 
     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`, 
     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`, 
     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`, 
     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`, 
     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`, 
     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`, 
     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`, 
     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`, 
     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`, 
     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`, 
     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`, 
     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`, 
     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`, 
     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`, 
     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`, 
     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`, 
     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`, 
     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`, 
     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`, 
     * `zipObject`, `zipObjectDeep`, and `zipWith` 
     * 
     * The wrapper methods that are **not** chainable by default are: 
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`, 
     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`, 
     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`, 
     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`, 
     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`, 
     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`, 
     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`, 
     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`, 
     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`, 
     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`, 
     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`, 
     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`, 
     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`, 
     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`, 
     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`, 
     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`, 
     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`, 
     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`, 
     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`, 
     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`, 
     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`, 
     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`, 
     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`, 
     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`, 
     * `upperFirst`, `value`, and `words` 
     * 
     * @name _ 
     * @constructor 
     * @category Seq 
     * @param {*} value The value to wrap in a `lodash` instance. 
     * @returns {Object} Returns the new `lodash` wrapper instance. 
     * @example 
     * 
     * function square(n) { 
     *   return n * n; 
     * } 
     * 
     * var wrapped = _([1, 2, 3]); 
     * 
     * // Returns an unwrapped value. 
     * wrapped.reduce(_.add); 
     * // =&gt; 6 
     * 
     * // Returns a wrapped value. 
     * var squares = wrapped.map(square); 
     * 
     * _.isArray(squares); 
     * // =&gt; false 
     * 
     * _.isArray(squares.value()); 
     * // =&gt; true 
     */</span>
    <span class="s2">function </span><span class="s1">lodash(value) {</span>
      <span class="s2">if </span><span class="s1">(isObjectLike(value) &amp;&amp; !isArray(value) &amp;&amp; !(value </span><span class="s2">instanceof </span><span class="s1">LazyWrapper)) {</span>
        <span class="s2">if </span><span class="s1">(value </span><span class="s2">instanceof </span><span class="s1">LodashWrapper) {</span>
          <span class="s2">return </span><span class="s1">value;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(hasOwnProperty.call(value, </span><span class="s3">'__wrapped__'</span><span class="s1">)) {</span>
          <span class="s2">return </span><span class="s1">wrapperClone(value);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">return new </span><span class="s1">LodashWrapper(value);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.create` without support for assigning 
     * properties to the created object. 
     * 
     * @private 
     * @param {Object} proto The object to inherit from. 
     * @returns {Object} Returns the new object. 
     */</span>
    <span class="s2">var </span><span class="s1">baseCreate = (</span><span class="s2">function</span><span class="s1">() {</span>
      <span class="s2">function </span><span class="s1">object() {}</span>
      <span class="s2">return function</span><span class="s1">(proto) {</span>
        <span class="s2">if </span><span class="s1">(!isObject(proto)) {</span>
          <span class="s2">return </span><span class="s1">{};</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(objectCreate) {</span>
          <span class="s2">return </span><span class="s1">objectCreate(proto);</span>
        <span class="s1">}</span>
        <span class="s1">object.prototype = proto;</span>
        <span class="s2">var </span><span class="s1">result = </span><span class="s2">new </span><span class="s1">object;</span>
        <span class="s1">object.prototype = undefined;</span>
        <span class="s2">return </span><span class="s1">result;</span>
      <span class="s1">};</span>
    <span class="s1">}());</span>

    <span class="s0">/** 
     * The function whose prototype chain sequence wrappers inherit from. 
     * 
     * @private 
     */</span>
    <span class="s2">function </span><span class="s1">baseLodash() {</span>
      <span class="s0">// No operation performed.</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base constructor for creating `lodash` wrapper objects. 
     * 
     * @private 
     * @param {*} value The value to wrap. 
     * @param {boolean} [chainAll] Enable explicit method chain sequences. 
     */</span>
    <span class="s2">function </span><span class="s1">LodashWrapper(value, chainAll) {</span>
      <span class="s2">this</span><span class="s1">.__wrapped__ = value;</span>
      <span class="s2">this</span><span class="s1">.__actions__ = [];</span>
      <span class="s2">this</span><span class="s1">.__chain__ = !!chainAll;</span>
      <span class="s2">this</span><span class="s1">.__index__ = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s2">this</span><span class="s1">.__values__ = undefined;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * By default, the template delimiters used by lodash are like those in 
     * embedded Ruby (ERB) as well as ES2015 template strings. Change the 
     * following template settings to use alternative delimiters. 
     * 
     * @static 
     * @memberOf _ 
     * @type {Object} 
     */</span>
    <span class="s1">lodash.templateSettings = {</span>

      <span class="s0">/** 
       * Used to detect `data` property values to be HTML-escaped. 
       * 
       * @memberOf _.templateSettings 
       * @type {RegExp} 
       */</span>
      <span class="s3">'escape'</span><span class="s1">: reEscape,</span>

      <span class="s0">/** 
       * Used to detect code to be evaluated. 
       * 
       * @memberOf _.templateSettings 
       * @type {RegExp} 
       */</span>
      <span class="s3">'evaluate'</span><span class="s1">: reEvaluate,</span>

      <span class="s0">/** 
       * Used to detect `data` property values to inject. 
       * 
       * @memberOf _.templateSettings 
       * @type {RegExp} 
       */</span>
      <span class="s3">'interpolate'</span><span class="s1">: reInterpolate,</span>

      <span class="s0">/** 
       * Used to reference the data object in the template text. 
       * 
       * @memberOf _.templateSettings 
       * @type {string} 
       */</span>
      <span class="s3">'variable'</span><span class="s1">: </span><span class="s3">''</span><span class="s1">,</span>

      <span class="s0">/** 
       * Used to import variables into the compiled template. 
       * 
       * @memberOf _.templateSettings 
       * @type {Object} 
       */</span>
      <span class="s3">'imports'</span><span class="s1">: {</span>

        <span class="s0">/** 
         * A reference to the `lodash` function. 
         * 
         * @memberOf _.templateSettings.imports 
         * @type {Function} 
         */</span>
        <span class="s3">'_'</span><span class="s1">: lodash</span>
      <span class="s1">}</span>
    <span class="s1">};</span>

    <span class="s0">// Ensure wrappers are instances of `baseLodash`.</span>
    <span class="s1">lodash.prototype = baseLodash.prototype;</span>
    <span class="s1">lodash.prototype.constructor = lodash;</span>

    <span class="s1">LodashWrapper.prototype = baseCreate(baseLodash.prototype);</span>
    <span class="s1">LodashWrapper.prototype.constructor = LodashWrapper;</span>

    <span class="s0">/*------------------------------------------------------------------------*/</span>

    <span class="s0">/** 
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation. 
     * 
     * @private 
     * @constructor 
     * @param {*} value The value to wrap. 
     */</span>
    <span class="s2">function </span><span class="s1">LazyWrapper(value) {</span>
      <span class="s2">this</span><span class="s1">.__wrapped__ = value;</span>
      <span class="s2">this</span><span class="s1">.__actions__ = [];</span>
      <span class="s2">this</span><span class="s1">.__dir__ = </span><span class="s4">1</span><span class="s1">;</span>
      <span class="s2">this</span><span class="s1">.__filtered__ = </span><span class="s2">false</span><span class="s1">;</span>
      <span class="s2">this</span><span class="s1">.__iteratees__ = [];</span>
      <span class="s2">this</span><span class="s1">.__takeCount__ = MAX_ARRAY_LENGTH;</span>
      <span class="s2">this</span><span class="s1">.__views__ = [];</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a clone of the lazy wrapper object. 
     * 
     * @private 
     * @name clone 
     * @memberOf LazyWrapper 
     * @returns {Object} Returns the cloned `LazyWrapper` object. 
     */</span>
    <span class="s2">function </span><span class="s1">lazyClone() {</span>
      <span class="s2">var </span><span class="s1">result = </span><span class="s2">new </span><span class="s1">LazyWrapper(</span><span class="s2">this</span><span class="s1">.__wrapped__);</span>
      <span class="s1">result.__actions__ = copyArray(</span><span class="s2">this</span><span class="s1">.__actions__);</span>
      <span class="s1">result.__dir__ = </span><span class="s2">this</span><span class="s1">.__dir__;</span>
      <span class="s1">result.__filtered__ = </span><span class="s2">this</span><span class="s1">.__filtered__;</span>
      <span class="s1">result.__iteratees__ = copyArray(</span><span class="s2">this</span><span class="s1">.__iteratees__);</span>
      <span class="s1">result.__takeCount__ = </span><span class="s2">this</span><span class="s1">.__takeCount__;</span>
      <span class="s1">result.__views__ = copyArray(</span><span class="s2">this</span><span class="s1">.__views__);</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Reverses the direction of lazy iteration. 
     * 
     * @private 
     * @name reverse 
     * @memberOf LazyWrapper 
     * @returns {Object} Returns the new reversed `LazyWrapper` object. 
     */</span>
    <span class="s2">function </span><span class="s1">lazyReverse() {</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.__filtered__) {</span>
        <span class="s2">var </span><span class="s1">result = </span><span class="s2">new </span><span class="s1">LazyWrapper(</span><span class="s2">this</span><span class="s1">);</span>
        <span class="s1">result.__dir__ = -</span><span class="s4">1</span><span class="s1">;</span>
        <span class="s1">result.__filtered__ = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">result = </span><span class="s2">this</span><span class="s1">.clone();</span>
        <span class="s1">result.__dir__ *= -</span><span class="s4">1</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Extracts the unwrapped value from its lazy wrapper. 
     * 
     * @private 
     * @name value 
     * @memberOf LazyWrapper 
     * @returns {*} Returns the unwrapped value. 
     */</span>
    <span class="s2">function </span><span class="s1">lazyValue() {</span>
      <span class="s2">var </span><span class="s1">array = </span><span class="s2">this</span><span class="s1">.__wrapped__.value(),</span>
          <span class="s1">dir = </span><span class="s2">this</span><span class="s1">.__dir__,</span>
          <span class="s1">isArr = isArray(array),</span>
          <span class="s1">isRight = dir &lt; </span><span class="s4">0</span><span class="s1">,</span>
          <span class="s1">arrLength = isArr ? array.length : </span><span class="s4">0</span><span class="s1">,</span>
          <span class="s1">view = getView(</span><span class="s4">0</span><span class="s1">, arrLength, </span><span class="s2">this</span><span class="s1">.__views__),</span>
          <span class="s1">start = view.start,</span>
          <span class="s1">end = view.end,</span>
          <span class="s1">length = end - start,</span>
          <span class="s1">index = isRight ? end : (start - </span><span class="s4">1</span><span class="s1">),</span>
          <span class="s1">iteratees = </span><span class="s2">this</span><span class="s1">.__iteratees__,</span>
          <span class="s1">iterLength = iteratees.length,</span>
          <span class="s1">resIndex = </span><span class="s4">0</span><span class="s1">,</span>
          <span class="s1">takeCount = nativeMin(length, </span><span class="s2">this</span><span class="s1">.__takeCount__);</span>

      <span class="s2">if </span><span class="s1">(!isArr || (!isRight &amp;&amp; arrLength == length &amp;&amp; takeCount == length)) {</span>
        <span class="s2">return </span><span class="s1">baseWrapperValue(array, </span><span class="s2">this</span><span class="s1">.__actions__);</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">result = [];</span>

      <span class="s1">outer:</span>
      <span class="s2">while </span><span class="s1">(length-- &amp;&amp; resIndex &lt; takeCount) {</span>
        <span class="s1">index += dir;</span>

        <span class="s2">var </span><span class="s1">iterIndex = -</span><span class="s4">1</span><span class="s1">,</span>
            <span class="s1">value = array[index];</span>

        <span class="s2">while </span><span class="s1">(++iterIndex &lt; iterLength) {</span>
          <span class="s2">var </span><span class="s1">data = iteratees[iterIndex],</span>
              <span class="s1">iteratee = data.iteratee,</span>
              <span class="s1">type = data.type,</span>
              <span class="s1">computed = iteratee(value);</span>

          <span class="s2">if </span><span class="s1">(type == LAZY_MAP_FLAG) {</span>
            <span class="s1">value = computed;</span>
          <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!computed) {</span>
            <span class="s2">if </span><span class="s1">(type == LAZY_FILTER_FLAG) {</span>
              <span class="s2">continue </span><span class="s1">outer;</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
              <span class="s2">break </span><span class="s1">outer;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">result[resIndex++] = value;</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>

    <span class="s0">// Ensure `LazyWrapper` is an instance of `baseLodash`.</span>
    <span class="s1">LazyWrapper.prototype = baseCreate(baseLodash.prototype);</span>
    <span class="s1">LazyWrapper.prototype.constructor = LazyWrapper;</span>

    <span class="s0">/*------------------------------------------------------------------------*/</span>

    <span class="s0">/** 
     * Creates a hash object. 
     * 
     * @private 
     * @constructor 
     * @param {Array} [entries] The key-value pairs to cache. 
     */</span>
    <span class="s2">function </span><span class="s1">Hash(entries) {</span>
      <span class="s2">var </span><span class="s1">index = -</span><span class="s4">1</span><span class="s1">,</span>
          <span class="s1">length = entries == </span><span class="s2">null </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: entries.length;</span>

      <span class="s2">this</span><span class="s1">.clear();</span>
      <span class="s2">while </span><span class="s1">(++index &lt; length) {</span>
        <span class="s2">var </span><span class="s1">entry = entries[index];</span>
        <span class="s2">this</span><span class="s1">.set(entry[</span><span class="s4">0</span><span class="s1">], entry[</span><span class="s4">1</span><span class="s1">]);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Removes all key-value entries from the hash. 
     * 
     * @private 
     * @name clear 
     * @memberOf Hash 
     */</span>
    <span class="s2">function </span><span class="s1">hashClear() {</span>
      <span class="s2">this</span><span class="s1">.__data__ = nativeCreate ? nativeCreate(</span><span class="s2">null</span><span class="s1">) : {};</span>
      <span class="s2">this</span><span class="s1">.size = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Removes `key` and its value from the hash. 
     * 
     * @private 
     * @name delete 
     * @memberOf Hash 
     * @param {Object} hash The hash to modify. 
     * @param {string} key The key of the value to remove. 
     * @returns {boolean} Returns `true` if the entry was removed, else `false`. 
     */</span>
    <span class="s2">function </span><span class="s1">hashDelete(key) {</span>
      <span class="s2">var </span><span class="s1">result = </span><span class="s2">this</span><span class="s1">.has(key) &amp;&amp; </span><span class="s2">delete this</span><span class="s1">.__data__[key];</span>
      <span class="s2">this</span><span class="s1">.size -= result ? </span><span class="s4">1 </span><span class="s1">: </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Gets the hash value for `key`. 
     * 
     * @private 
     * @name get 
     * @memberOf Hash 
     * @param {string} key The key of the value to get. 
     * @returns {*} Returns the entry value. 
     */</span>
    <span class="s2">function </span><span class="s1">hashGet(key) {</span>
      <span class="s2">var </span><span class="s1">data = </span><span class="s2">this</span><span class="s1">.__data__;</span>
      <span class="s2">if </span><span class="s1">(nativeCreate) {</span>
        <span class="s2">var </span><span class="s1">result = data[key];</span>
        <span class="s2">return </span><span class="s1">result === HASH_UNDEFINED ? undefined : result;</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">hasOwnProperty.call(data, key) ? data[key] : undefined;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Checks if a hash value for `key` exists. 
     * 
     * @private 
     * @name has 
     * @memberOf Hash 
     * @param {string} key The key of the entry to check. 
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`. 
     */</span>
    <span class="s2">function </span><span class="s1">hashHas(key) {</span>
      <span class="s2">var </span><span class="s1">data = </span><span class="s2">this</span><span class="s1">.__data__;</span>
      <span class="s2">return </span><span class="s1">nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Sets the hash `key` to `value`. 
     * 
     * @private 
     * @name set 
     * @memberOf Hash 
     * @param {string} key The key of the value to set. 
     * @param {*} value The value to set. 
     * @returns {Object} Returns the hash instance. 
     */</span>
    <span class="s2">function </span><span class="s1">hashSet(key, value) {</span>
      <span class="s2">var </span><span class="s1">data = </span><span class="s2">this</span><span class="s1">.__data__;</span>
      <span class="s2">this</span><span class="s1">.size += </span><span class="s2">this</span><span class="s1">.has(key) ? </span><span class="s4">0 </span><span class="s1">: </span><span class="s4">1</span><span class="s1">;</span>
      <span class="s1">data[key] = (nativeCreate &amp;&amp; value === undefined) ? HASH_UNDEFINED : value;</span>
      <span class="s2">return this</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">// Add methods to `Hash`.</span>
    <span class="s1">Hash.prototype.clear = hashClear;</span>
    <span class="s1">Hash.prototype[</span><span class="s3">'delete'</span><span class="s1">] = hashDelete;</span>
    <span class="s1">Hash.prototype.get = hashGet;</span>
    <span class="s1">Hash.prototype.has = hashHas;</span>
    <span class="s1">Hash.prototype.set = hashSet;</span>

    <span class="s0">/*------------------------------------------------------------------------*/</span>

    <span class="s0">/** 
     * Creates an list cache object. 
     * 
     * @private 
     * @constructor 
     * @param {Array} [entries] The key-value pairs to cache. 
     */</span>
    <span class="s2">function </span><span class="s1">ListCache(entries) {</span>
      <span class="s2">var </span><span class="s1">index = -</span><span class="s4">1</span><span class="s1">,</span>
          <span class="s1">length = entries == </span><span class="s2">null </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: entries.length;</span>

      <span class="s2">this</span><span class="s1">.clear();</span>
      <span class="s2">while </span><span class="s1">(++index &lt; length) {</span>
        <span class="s2">var </span><span class="s1">entry = entries[index];</span>
        <span class="s2">this</span><span class="s1">.set(entry[</span><span class="s4">0</span><span class="s1">], entry[</span><span class="s4">1</span><span class="s1">]);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Removes all key-value entries from the list cache. 
     * 
     * @private 
     * @name clear 
     * @memberOf ListCache 
     */</span>
    <span class="s2">function </span><span class="s1">listCacheClear() {</span>
      <span class="s2">this</span><span class="s1">.__data__ = [];</span>
      <span class="s2">this</span><span class="s1">.size = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Removes `key` and its value from the list cache. 
     * 
     * @private 
     * @name delete 
     * @memberOf ListCache 
     * @param {string} key The key of the value to remove. 
     * @returns {boolean} Returns `true` if the entry was removed, else `false`. 
     */</span>
    <span class="s2">function </span><span class="s1">listCacheDelete(key) {</span>
      <span class="s2">var </span><span class="s1">data = </span><span class="s2">this</span><span class="s1">.__data__,</span>
          <span class="s1">index = assocIndexOf(data, key);</span>

      <span class="s2">if </span><span class="s1">(index &lt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s2">return false</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">lastIndex = data.length - </span><span class="s4">1</span><span class="s1">;</span>
      <span class="s2">if </span><span class="s1">(index == lastIndex) {</span>
        <span class="s1">data.pop();</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">splice.call(data, index, </span><span class="s4">1</span><span class="s1">);</span>
      <span class="s1">}</span>
      <span class="s1">--</span><span class="s2">this</span><span class="s1">.size;</span>
      <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Gets the list cache value for `key`. 
     * 
     * @private 
     * @name get 
     * @memberOf ListCache 
     * @param {string} key The key of the value to get. 
     * @returns {*} Returns the entry value. 
     */</span>
    <span class="s2">function </span><span class="s1">listCacheGet(key) {</span>
      <span class="s2">var </span><span class="s1">data = </span><span class="s2">this</span><span class="s1">.__data__,</span>
          <span class="s1">index = assocIndexOf(data, key);</span>

      <span class="s2">return </span><span class="s1">index &lt; </span><span class="s4">0 </span><span class="s1">? undefined : data[index][</span><span class="s4">1</span><span class="s1">];</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Checks if a list cache value for `key` exists. 
     * 
     * @private 
     * @name has 
     * @memberOf ListCache 
     * @param {string} key The key of the entry to check. 
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`. 
     */</span>
    <span class="s2">function </span><span class="s1">listCacheHas(key) {</span>
      <span class="s2">return </span><span class="s1">assocIndexOf(</span><span class="s2">this</span><span class="s1">.__data__, key) &gt; -</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Sets the list cache `key` to `value`. 
     * 
     * @private 
     * @name set 
     * @memberOf ListCache 
     * @param {string} key The key of the value to set. 
     * @param {*} value The value to set. 
     * @returns {Object} Returns the list cache instance. 
     */</span>
    <span class="s2">function </span><span class="s1">listCacheSet(key, value) {</span>
      <span class="s2">var </span><span class="s1">data = </span><span class="s2">this</span><span class="s1">.__data__,</span>
          <span class="s1">index = assocIndexOf(data, key);</span>

      <span class="s2">if </span><span class="s1">(index &lt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">++</span><span class="s2">this</span><span class="s1">.size;</span>
        <span class="s1">data.push([key, value]);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">data[index][</span><span class="s4">1</span><span class="s1">] = value;</span>
      <span class="s1">}</span>
      <span class="s2">return this</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">// Add methods to `ListCache`.</span>
    <span class="s1">ListCache.prototype.clear = listCacheClear;</span>
    <span class="s1">ListCache.prototype[</span><span class="s3">'delete'</span><span class="s1">] = listCacheDelete;</span>
    <span class="s1">ListCache.prototype.get = listCacheGet;</span>
    <span class="s1">ListCache.prototype.has = listCacheHas;</span>
    <span class="s1">ListCache.prototype.set = listCacheSet;</span>

    <span class="s0">/*------------------------------------------------------------------------*/</span>

    <span class="s0">/** 
     * Creates a map cache object to store key-value pairs. 
     * 
     * @private 
     * @constructor 
     * @param {Array} [entries] The key-value pairs to cache. 
     */</span>
    <span class="s2">function </span><span class="s1">MapCache(entries) {</span>
      <span class="s2">var </span><span class="s1">index = -</span><span class="s4">1</span><span class="s1">,</span>
          <span class="s1">length = entries == </span><span class="s2">null </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: entries.length;</span>

      <span class="s2">this</span><span class="s1">.clear();</span>
      <span class="s2">while </span><span class="s1">(++index &lt; length) {</span>
        <span class="s2">var </span><span class="s1">entry = entries[index];</span>
        <span class="s2">this</span><span class="s1">.set(entry[</span><span class="s4">0</span><span class="s1">], entry[</span><span class="s4">1</span><span class="s1">]);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Removes all key-value entries from the map. 
     * 
     * @private 
     * @name clear 
     * @memberOf MapCache 
     */</span>
    <span class="s2">function </span><span class="s1">mapCacheClear() {</span>
      <span class="s2">this</span><span class="s1">.size = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s2">this</span><span class="s1">.__data__ = {</span>
        <span class="s3">'hash'</span><span class="s1">: </span><span class="s2">new </span><span class="s1">Hash,</span>
        <span class="s3">'map'</span><span class="s1">: </span><span class="s2">new </span><span class="s1">(Map || ListCache),</span>
        <span class="s3">'string'</span><span class="s1">: </span><span class="s2">new </span><span class="s1">Hash</span>
      <span class="s1">};</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Removes `key` and its value from the map. 
     * 
     * @private 
     * @name delete 
     * @memberOf MapCache 
     * @param {string} key The key of the value to remove. 
     * @returns {boolean} Returns `true` if the entry was removed, else `false`. 
     */</span>
    <span class="s2">function </span><span class="s1">mapCacheDelete(key) {</span>
      <span class="s2">var </span><span class="s1">result = getMapData(</span><span class="s2">this</span><span class="s1">, key)[</span><span class="s3">'delete'</span><span class="s1">](key);</span>
      <span class="s2">this</span><span class="s1">.size -= result ? </span><span class="s4">1 </span><span class="s1">: </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Gets the map value for `key`. 
     * 
     * @private 
     * @name get 
     * @memberOf MapCache 
     * @param {string} key The key of the value to get. 
     * @returns {*} Returns the entry value. 
     */</span>
    <span class="s2">function </span><span class="s1">mapCacheGet(key) {</span>
      <span class="s2">return </span><span class="s1">getMapData(</span><span class="s2">this</span><span class="s1">, key).get(key);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Checks if a map value for `key` exists. 
     * 
     * @private 
     * @name has 
     * @memberOf MapCache 
     * @param {string} key The key of the entry to check. 
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`. 
     */</span>
    <span class="s2">function </span><span class="s1">mapCacheHas(key) {</span>
      <span class="s2">return </span><span class="s1">getMapData(</span><span class="s2">this</span><span class="s1">, key).has(key);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Sets the map `key` to `value`. 
     * 
     * @private 
     * @name set 
     * @memberOf MapCache 
     * @param {string} key The key of the value to set. 
     * @param {*} value The value to set. 
     * @returns {Object} Returns the map cache instance. 
     */</span>
    <span class="s2">function </span><span class="s1">mapCacheSet(key, value) {</span>
      <span class="s2">var </span><span class="s1">data = getMapData(</span><span class="s2">this</span><span class="s1">, key),</span>
          <span class="s1">size = data.size;</span>

      <span class="s1">data.set(key, value);</span>
      <span class="s2">this</span><span class="s1">.size += data.size == size ? </span><span class="s4">0 </span><span class="s1">: </span><span class="s4">1</span><span class="s1">;</span>
      <span class="s2">return this</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">// Add methods to `MapCache`.</span>
    <span class="s1">MapCache.prototype.clear = mapCacheClear;</span>
    <span class="s1">MapCache.prototype[</span><span class="s3">'delete'</span><span class="s1">] = mapCacheDelete;</span>
    <span class="s1">MapCache.prototype.get = mapCacheGet;</span>
    <span class="s1">MapCache.prototype.has = mapCacheHas;</span>
    <span class="s1">MapCache.prototype.set = mapCacheSet;</span>

    <span class="s0">/*------------------------------------------------------------------------*/</span>

    <span class="s0">/** 
     * 
     * Creates an array cache object to store unique values. 
     * 
     * @private 
     * @constructor 
     * @param {Array} [values] The values to cache. 
     */</span>
    <span class="s2">function </span><span class="s1">SetCache(values) {</span>
      <span class="s2">var </span><span class="s1">index = -</span><span class="s4">1</span><span class="s1">,</span>
          <span class="s1">length = values == </span><span class="s2">null </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: values.length;</span>

      <span class="s2">this</span><span class="s1">.__data__ = </span><span class="s2">new </span><span class="s1">MapCache;</span>
      <span class="s2">while </span><span class="s1">(++index &lt; length) {</span>
        <span class="s2">this</span><span class="s1">.add(values[index]);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Adds `value` to the array cache. 
     * 
     * @private 
     * @name add 
     * @memberOf SetCache 
     * @alias push 
     * @param {*} value The value to cache. 
     * @returns {Object} Returns the cache instance. 
     */</span>
    <span class="s2">function </span><span class="s1">setCacheAdd(value) {</span>
      <span class="s2">this</span><span class="s1">.__data__.set(value, HASH_UNDEFINED);</span>
      <span class="s2">return this</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Checks if `value` is in the array cache. 
     * 
     * @private 
     * @name has 
     * @memberOf SetCache 
     * @param {*} value The value to search for. 
     * @returns {number} Returns `true` if `value` is found, else `false`. 
     */</span>
    <span class="s2">function </span><span class="s1">setCacheHas(value) {</span>
      <span class="s2">return this</span><span class="s1">.__data__.has(value);</span>
    <span class="s1">}</span>

    <span class="s0">// Add methods to `SetCache`.</span>
    <span class="s1">SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;</span>
    <span class="s1">SetCache.prototype.has = setCacheHas;</span>

    <span class="s0">/*------------------------------------------------------------------------*/</span>

    <span class="s0">/** 
     * Creates a stack cache object to store key-value pairs. 
     * 
     * @private 
     * @constructor 
     * @param {Array} [entries] The key-value pairs to cache. 
     */</span>
    <span class="s2">function </span><span class="s1">Stack(entries) {</span>
      <span class="s2">var </span><span class="s1">data = </span><span class="s2">this</span><span class="s1">.__data__ = </span><span class="s2">new </span><span class="s1">ListCache(entries);</span>
      <span class="s2">this</span><span class="s1">.size = data.size;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Removes all key-value entries from the stack. 
     * 
     * @private 
     * @name clear 
     * @memberOf Stack 
     */</span>
    <span class="s2">function </span><span class="s1">stackClear() {</span>
      <span class="s2">this</span><span class="s1">.__data__ = </span><span class="s2">new </span><span class="s1">ListCache;</span>
      <span class="s2">this</span><span class="s1">.size = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Removes `key` and its value from the stack. 
     * 
     * @private 
     * @name delete 
     * @memberOf Stack 
     * @param {string} key The key of the value to remove. 
     * @returns {boolean} Returns `true` if the entry was removed, else `false`. 
     */</span>
    <span class="s2">function </span><span class="s1">stackDelete(key) {</span>
      <span class="s2">var </span><span class="s1">data = </span><span class="s2">this</span><span class="s1">.__data__,</span>
          <span class="s1">result = data[</span><span class="s3">'delete'</span><span class="s1">](key);</span>

      <span class="s2">this</span><span class="s1">.size = data.size;</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Gets the stack value for `key`. 
     * 
     * @private 
     * @name get 
     * @memberOf Stack 
     * @param {string} key The key of the value to get. 
     * @returns {*} Returns the entry value. 
     */</span>
    <span class="s2">function </span><span class="s1">stackGet(key) {</span>
      <span class="s2">return this</span><span class="s1">.__data__.get(key);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Checks if a stack value for `key` exists. 
     * 
     * @private 
     * @name has 
     * @memberOf Stack 
     * @param {string} key The key of the entry to check. 
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`. 
     */</span>
    <span class="s2">function </span><span class="s1">stackHas(key) {</span>
      <span class="s2">return this</span><span class="s1">.__data__.has(key);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Sets the stack `key` to `value`. 
     * 
     * @private 
     * @name set 
     * @memberOf Stack 
     * @param {string} key The key of the value to set. 
     * @param {*} value The value to set. 
     * @returns {Object} Returns the stack cache instance. 
     */</span>
    <span class="s2">function </span><span class="s1">stackSet(key, value) {</span>
      <span class="s2">var </span><span class="s1">data = </span><span class="s2">this</span><span class="s1">.__data__;</span>
      <span class="s2">if </span><span class="s1">(data </span><span class="s2">instanceof </span><span class="s1">ListCache) {</span>
        <span class="s2">var </span><span class="s1">pairs = data.__data__;</span>
        <span class="s2">if </span><span class="s1">(!Map || (pairs.length &lt; LARGE_ARRAY_SIZE - </span><span class="s4">1</span><span class="s1">)) {</span>
          <span class="s1">pairs.push([key, value]);</span>
          <span class="s2">this</span><span class="s1">.size = ++data.size;</span>
          <span class="s2">return this</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">data = </span><span class="s2">this</span><span class="s1">.__data__ = </span><span class="s2">new </span><span class="s1">MapCache(pairs);</span>
      <span class="s1">}</span>
      <span class="s1">data.set(key, value);</span>
      <span class="s2">this</span><span class="s1">.size = data.size;</span>
      <span class="s2">return this</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">// Add methods to `Stack`.</span>
    <span class="s1">Stack.prototype.clear = stackClear;</span>
    <span class="s1">Stack.prototype[</span><span class="s3">'delete'</span><span class="s1">] = stackDelete;</span>
    <span class="s1">Stack.prototype.get = stackGet;</span>
    <span class="s1">Stack.prototype.has = stackHas;</span>
    <span class="s1">Stack.prototype.set = stackSet;</span>

    <span class="s0">/*------------------------------------------------------------------------*/</span>

    <span class="s0">/** 
     * Creates an array of the enumerable property names of the array-like `value`. 
     * 
     * @private 
     * @param {*} value The value to query. 
     * @param {boolean} inherited Specify returning inherited property names. 
     * @returns {Array} Returns the array of property names. 
     */</span>
    <span class="s2">function </span><span class="s1">arrayLikeKeys(value, inherited) {</span>
      <span class="s2">var </span><span class="s1">isArr = isArray(value),</span>
          <span class="s1">isArg = !isArr &amp;&amp; isArguments(value),</span>
          <span class="s1">isBuff = !isArr &amp;&amp; !isArg &amp;&amp; isBuffer(value),</span>
          <span class="s1">isType = !isArr &amp;&amp; !isArg &amp;&amp; !isBuff &amp;&amp; isTypedArray(value),</span>
          <span class="s1">skipIndexes = isArr || isArg || isBuff || isType,</span>
          <span class="s1">result = skipIndexes ? baseTimes(value.length, String) : [],</span>
          <span class="s1">length = result.length;</span>

      <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">key </span><span class="s2">in </span><span class="s1">value) {</span>
        <span class="s2">if </span><span class="s1">((inherited || hasOwnProperty.call(value, key)) &amp;&amp;</span>
            <span class="s1">!(skipIndexes &amp;&amp; (</span>
               <span class="s0">// Safari 9 has enumerable `arguments.length` in strict mode.</span>
               <span class="s1">key == </span><span class="s3">'length' </span><span class="s1">||</span>
               <span class="s0">// Node.js 0.10 has enumerable non-index properties on buffers.</span>
               <span class="s1">(isBuff &amp;&amp; (key == </span><span class="s3">'offset' </span><span class="s1">|| key == </span><span class="s3">'parent'</span><span class="s1">)) ||</span>
               <span class="s0">// PhantomJS 2 has enumerable non-index properties on typed arrays.</span>
               <span class="s1">(isType &amp;&amp; (key == </span><span class="s3">'buffer' </span><span class="s1">|| key == </span><span class="s3">'byteLength' </span><span class="s1">|| key == </span><span class="s3">'byteOffset'</span><span class="s1">)) ||</span>
               <span class="s0">// Skip index properties.</span>
               <span class="s1">isIndex(key, length)</span>
            <span class="s1">))) {</span>
          <span class="s1">result.push(key);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * A specialized version of `_.sample` for arrays. 
     * 
     * @private 
     * @param {Array} array The array to sample. 
     * @returns {*} Returns the random element. 
     */</span>
    <span class="s2">function </span><span class="s1">arraySample(array) {</span>
      <span class="s2">var </span><span class="s1">length = array.length;</span>
      <span class="s2">return </span><span class="s1">length ? array[baseRandom(</span><span class="s4">0</span><span class="s1">, length - </span><span class="s4">1</span><span class="s1">)] : undefined;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * A specialized version of `_.sampleSize` for arrays. 
     * 
     * @private 
     * @param {Array} array The array to sample. 
     * @param {number} n The number of elements to sample. 
     * @returns {Array} Returns the random elements. 
     */</span>
    <span class="s2">function </span><span class="s1">arraySampleSize(array, n) {</span>
      <span class="s2">return </span><span class="s1">shuffleSelf(copyArray(array), baseClamp(n, </span><span class="s4">0</span><span class="s1">, array.length));</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * A specialized version of `_.shuffle` for arrays. 
     * 
     * @private 
     * @param {Array} array The array to shuffle. 
     * @returns {Array} Returns the new shuffled array. 
     */</span>
    <span class="s2">function </span><span class="s1">arrayShuffle(array) {</span>
      <span class="s2">return </span><span class="s1">shuffleSelf(copyArray(array));</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * This function is like `assignValue` except that it doesn't assign 
     * `undefined` values. 
     * 
     * @private 
     * @param {Object} object The object to modify. 
     * @param {string} key The key of the property to assign. 
     * @param {*} value The value to assign. 
     */</span>
    <span class="s2">function </span><span class="s1">assignMergeValue(object, key, value) {</span>
      <span class="s2">if </span><span class="s1">((value !== undefined &amp;&amp; !eq(object[key], value)) ||</span>
          <span class="s1">(value === undefined &amp;&amp; !(key </span><span class="s2">in </span><span class="s1">object))) {</span>
        <span class="s1">baseAssignValue(object, key, value);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Assigns `value` to `key` of `object` if the existing value is not equivalent 
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero) 
     * for equality comparisons. 
     * 
     * @private 
     * @param {Object} object The object to modify. 
     * @param {string} key The key of the property to assign. 
     * @param {*} value The value to assign. 
     */</span>
    <span class="s2">function </span><span class="s1">assignValue(object, key, value) {</span>
      <span class="s2">var </span><span class="s1">objValue = object[key];</span>
      <span class="s2">if </span><span class="s1">(!(hasOwnProperty.call(object, key) &amp;&amp; eq(objValue, value)) ||</span>
          <span class="s1">(value === undefined &amp;&amp; !(key </span><span class="s2">in </span><span class="s1">object))) {</span>
        <span class="s1">baseAssignValue(object, key, value);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Gets the index at which the `key` is found in `array` of key-value pairs. 
     * 
     * @private 
     * @param {Array} array The array to inspect. 
     * @param {*} key The key to search for. 
     * @returns {number} Returns the index of the matched value, else `-1`. 
     */</span>
    <span class="s2">function </span><span class="s1">assocIndexOf(array, key) {</span>
      <span class="s2">var </span><span class="s1">length = array.length;</span>
      <span class="s2">while </span><span class="s1">(length--) {</span>
        <span class="s2">if </span><span class="s1">(eq(array[length][</span><span class="s4">0</span><span class="s1">], key)) {</span>
          <span class="s2">return </span><span class="s1">length;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">-</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Aggregates elements of `collection` on `accumulator` with keys transformed 
     * by `iteratee` and values set by `setter`. 
     * 
     * @private 
     * @param {Array|Object} collection The collection to iterate over. 
     * @param {Function} setter The function to set `accumulator` values. 
     * @param {Function} iteratee The iteratee to transform keys. 
     * @param {Object} accumulator The initial aggregated object. 
     * @returns {Function} Returns `accumulator`. 
     */</span>
    <span class="s2">function </span><span class="s1">baseAggregator(collection, setter, iteratee, accumulator) {</span>
      <span class="s1">baseEach(collection, </span><span class="s2">function</span><span class="s1">(value, key, collection) {</span>
        <span class="s1">setter(accumulator, value, iteratee(value), collection);</span>
      <span class="s1">});</span>
      <span class="s2">return </span><span class="s1">accumulator;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.assign` without support for multiple sources 
     * or `customizer` functions. 
     * 
     * @private 
     * @param {Object} object The destination object. 
     * @param {Object} source The source object. 
     * @returns {Object} Returns `object`. 
     */</span>
    <span class="s2">function </span><span class="s1">baseAssign(object, source) {</span>
      <span class="s2">return </span><span class="s1">object &amp;&amp; copyObject(source, keys(source), object);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.assignIn` without support for multiple sources 
     * or `customizer` functions. 
     * 
     * @private 
     * @param {Object} object The destination object. 
     * @param {Object} source The source object. 
     * @returns {Object} Returns `object`. 
     */</span>
    <span class="s2">function </span><span class="s1">baseAssignIn(object, source) {</span>
      <span class="s2">return </span><span class="s1">object &amp;&amp; copyObject(source, keysIn(source), object);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `assignValue` and `assignMergeValue` without 
     * value checks. 
     * 
     * @private 
     * @param {Object} object The object to modify. 
     * @param {string} key The key of the property to assign. 
     * @param {*} value The value to assign. 
     */</span>
    <span class="s2">function </span><span class="s1">baseAssignValue(object, key, value) {</span>
      <span class="s2">if </span><span class="s1">(key == </span><span class="s3">'__proto__' </span><span class="s1">&amp;&amp; defineProperty) {</span>
        <span class="s1">defineProperty(object, key, {</span>
          <span class="s3">'configurable'</span><span class="s1">: </span><span class="s2">true</span><span class="s1">,</span>
          <span class="s3">'enumerable'</span><span class="s1">: </span><span class="s2">true</span><span class="s1">,</span>
          <span class="s3">'value'</span><span class="s1">: value,</span>
          <span class="s3">'writable'</span><span class="s1">: </span><span class="s2">true</span>
        <span class="s1">});</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">object[key] = value;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.at` without support for individual paths. 
     * 
     * @private 
     * @param {Object} object The object to iterate over. 
     * @param {string[]} paths The property paths to pick. 
     * @returns {Array} Returns the picked elements. 
     */</span>
    <span class="s2">function </span><span class="s1">baseAt(object, paths) {</span>
      <span class="s2">var </span><span class="s1">index = -</span><span class="s4">1</span><span class="s1">,</span>
          <span class="s1">length = paths.length,</span>
          <span class="s1">result = Array(length),</span>
          <span class="s1">skip = object == </span><span class="s2">null</span><span class="s1">;</span>

      <span class="s2">while </span><span class="s1">(++index &lt; length) {</span>
        <span class="s1">result[index] = skip ? undefined : get(object, paths[index]);</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.clamp` which doesn't coerce arguments. 
     * 
     * @private 
     * @param {number} number The number to clamp. 
     * @param {number} [lower] The lower bound. 
     * @param {number} upper The upper bound. 
     * @returns {number} Returns the clamped number. 
     */</span>
    <span class="s2">function </span><span class="s1">baseClamp(number, lower, upper) {</span>
      <span class="s2">if </span><span class="s1">(number === number) {</span>
        <span class="s2">if </span><span class="s1">(upper !== undefined) {</span>
          <span class="s1">number = number &lt;= upper ? number : upper;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(lower !== undefined) {</span>
          <span class="s1">number = number &gt;= lower ? number : lower;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">number;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.clone` and `_.cloneDeep` which tracks 
     * traversed objects. 
     * 
     * @private 
     * @param {*} value The value to clone. 
     * @param {boolean} bitmask The bitmask flags. 
     *  1 - Deep clone 
     *  2 - Flatten inherited properties 
     *  4 - Clone symbols 
     * @param {Function} [customizer] The function to customize cloning. 
     * @param {string} [key] The key of `value`. 
     * @param {Object} [object] The parent object of `value`. 
     * @param {Object} [stack] Tracks traversed objects and their clone counterparts. 
     * @returns {*} Returns the cloned value. 
     */</span>
    <span class="s2">function </span><span class="s1">baseClone(value, bitmask, customizer, key, object, stack) {</span>
      <span class="s2">var </span><span class="s1">result,</span>
          <span class="s1">isDeep = bitmask &amp; CLONE_DEEP_FLAG,</span>
          <span class="s1">isFlat = bitmask &amp; CLONE_FLAT_FLAG,</span>
          <span class="s1">isFull = bitmask &amp; CLONE_SYMBOLS_FLAG;</span>

      <span class="s2">if </span><span class="s1">(customizer) {</span>
        <span class="s1">result = object ? customizer(value, key, object, stack) : customizer(value);</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(result !== undefined) {</span>
        <span class="s2">return </span><span class="s1">result;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(!isObject(value)) {</span>
        <span class="s2">return </span><span class="s1">value;</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">isArr = isArray(value);</span>
      <span class="s2">if </span><span class="s1">(isArr) {</span>
        <span class="s1">result = initCloneArray(value);</span>
        <span class="s2">if </span><span class="s1">(!isDeep) {</span>
          <span class="s2">return </span><span class="s1">copyArray(value, result);</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">var </span><span class="s1">tag = getTag(value),</span>
            <span class="s1">isFunc = tag == funcTag || tag == genTag;</span>

        <span class="s2">if </span><span class="s1">(isBuffer(value)) {</span>
          <span class="s2">return </span><span class="s1">cloneBuffer(value, isDeep);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(tag == objectTag || tag == argsTag || (isFunc &amp;&amp; !object)) {</span>
          <span class="s1">result = (isFlat || isFunc) ? {} : initCloneObject(value);</span>
          <span class="s2">if </span><span class="s1">(!isDeep) {</span>
            <span class="s2">return </span><span class="s1">isFlat</span>
              <span class="s1">? copySymbolsIn(value, baseAssignIn(result, value))</span>
              <span class="s1">: copySymbols(value, baseAssign(result, value));</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s2">if </span><span class="s1">(!cloneableTags[tag]) {</span>
            <span class="s2">return </span><span class="s1">object ? value : {};</span>
          <span class="s1">}</span>
          <span class="s1">result = initCloneByTag(value, tag, isDeep);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">// Check for circular references and return its corresponding clone.</span>
      <span class="s1">stack || (stack = </span><span class="s2">new </span><span class="s1">Stack);</span>
      <span class="s2">var </span><span class="s1">stacked = stack.get(value);</span>
      <span class="s2">if </span><span class="s1">(stacked) {</span>
        <span class="s2">return </span><span class="s1">stacked;</span>
      <span class="s1">}</span>
      <span class="s1">stack.set(value, result);</span>

      <span class="s2">if </span><span class="s1">(isSet(value)) {</span>
        <span class="s1">value.forEach(</span><span class="s2">function</span><span class="s1">(subValue) {</span>
          <span class="s1">result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));</span>
        <span class="s1">});</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isMap(value)) {</span>
        <span class="s1">value.forEach(</span><span class="s2">function</span><span class="s1">(subValue, key) {</span>
          <span class="s1">result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));</span>
        <span class="s1">});</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">keysFunc = isFull</span>
        <span class="s1">? (isFlat ? getAllKeysIn : getAllKeys)</span>
        <span class="s1">: (isFlat ? keysIn : keys);</span>

      <span class="s2">var </span><span class="s1">props = isArr ? undefined : keysFunc(value);</span>
      <span class="s1">arrayEach(props || value, </span><span class="s2">function</span><span class="s1">(subValue, key) {</span>
        <span class="s2">if </span><span class="s1">(props) {</span>
          <span class="s1">key = subValue;</span>
          <span class="s1">subValue = value[key];</span>
        <span class="s1">}</span>
        <span class="s0">// Recursively populate clone (susceptible to call stack limits).</span>
        <span class="s1">assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));</span>
      <span class="s1">});</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.conforms` which doesn't clone `source`. 
     * 
     * @private 
     * @param {Object} source The object of property predicates to conform to. 
     * @returns {Function} Returns the new spec function. 
     */</span>
    <span class="s2">function </span><span class="s1">baseConforms(source) {</span>
      <span class="s2">var </span><span class="s1">props = keys(source);</span>
      <span class="s2">return function</span><span class="s1">(object) {</span>
        <span class="s2">return </span><span class="s1">baseConformsTo(object, source, props);</span>
      <span class="s1">};</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.conformsTo` which accepts `props` to check. 
     * 
     * @private 
     * @param {Object} object The object to inspect. 
     * @param {Object} source The object of property predicates to conform to. 
     * @returns {boolean} Returns `true` if `object` conforms, else `false`. 
     */</span>
    <span class="s2">function </span><span class="s1">baseConformsTo(object, source, props) {</span>
      <span class="s2">var </span><span class="s1">length = props.length;</span>
      <span class="s2">if </span><span class="s1">(object == </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">!length;</span>
      <span class="s1">}</span>
      <span class="s1">object = Object(object);</span>
      <span class="s2">while </span><span class="s1">(length--) {</span>
        <span class="s2">var </span><span class="s1">key = props[length],</span>
            <span class="s1">predicate = source[key],</span>
            <span class="s1">value = object[key];</span>

        <span class="s2">if </span><span class="s1">((value === undefined &amp;&amp; !(key </span><span class="s2">in </span><span class="s1">object)) || !predicate(value)) {</span>
          <span class="s2">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.delay` and `_.defer` which accepts `args` 
     * to provide to `func`. 
     * 
     * @private 
     * @param {Function} func The function to delay. 
     * @param {number} wait The number of milliseconds to delay invocation. 
     * @param {Array} args The arguments to provide to `func`. 
     * @returns {number|Object} Returns the timer id or timeout object. 
     */</span>
    <span class="s2">function </span><span class="s1">baseDelay(func, wait, args) {</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">func != </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s2">throw new </span><span class="s1">TypeError(FUNC_ERROR_TEXT);</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">setTimeout(</span><span class="s2">function</span><span class="s1">() { func.apply(undefined, args); }, wait);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of methods like `_.difference` without support 
     * for excluding multiple arrays or iteratee shorthands. 
     * 
     * @private 
     * @param {Array} array The array to inspect. 
     * @param {Array} values The values to exclude. 
     * @param {Function} [iteratee] The iteratee invoked per element. 
     * @param {Function} [comparator] The comparator invoked per element. 
     * @returns {Array} Returns the new array of filtered values. 
     */</span>
    <span class="s2">function </span><span class="s1">baseDifference(array, values, iteratee, comparator) {</span>
      <span class="s2">var </span><span class="s1">index = -</span><span class="s4">1</span><span class="s1">,</span>
          <span class="s1">includes = arrayIncludes,</span>
          <span class="s1">isCommon = </span><span class="s2">true</span><span class="s1">,</span>
          <span class="s1">length = array.length,</span>
          <span class="s1">result = [],</span>
          <span class="s1">valuesLength = values.length;</span>

      <span class="s2">if </span><span class="s1">(!length) {</span>
        <span class="s2">return </span><span class="s1">result;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(iteratee) {</span>
        <span class="s1">values = arrayMap(values, baseUnary(iteratee));</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(comparator) {</span>
        <span class="s1">includes = arrayIncludesWith;</span>
        <span class="s1">isCommon = </span><span class="s2">false</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s2">else if </span><span class="s1">(values.length &gt;= LARGE_ARRAY_SIZE) {</span>
        <span class="s1">includes = cacheHas;</span>
        <span class="s1">isCommon = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s1">values = </span><span class="s2">new </span><span class="s1">SetCache(values);</span>
      <span class="s1">}</span>
      <span class="s1">outer:</span>
      <span class="s2">while </span><span class="s1">(++index &lt; length) {</span>
        <span class="s2">var </span><span class="s1">value = array[index],</span>
            <span class="s1">computed = iteratee == </span><span class="s2">null </span><span class="s1">? value : iteratee(value);</span>

        <span class="s1">value = (comparator || value !== </span><span class="s4">0</span><span class="s1">) ? value : </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(isCommon &amp;&amp; computed === computed) {</span>
          <span class="s2">var </span><span class="s1">valuesIndex = valuesLength;</span>
          <span class="s2">while </span><span class="s1">(valuesIndex--) {</span>
            <span class="s2">if </span><span class="s1">(values[valuesIndex] === computed) {</span>
              <span class="s2">continue </span><span class="s1">outer;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
          <span class="s1">result.push(value);</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(!includes(values, computed, comparator)) {</span>
          <span class="s1">result.push(value);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.forEach` without support for iteratee shorthands. 
     * 
     * @private 
     * @param {Array|Object} collection The collection to iterate over. 
     * @param {Function} iteratee The function invoked per iteration. 
     * @returns {Array|Object} Returns `collection`. 
     */</span>
    <span class="s2">var </span><span class="s1">baseEach = createBaseEach(baseForOwn);</span>

    <span class="s0">/** 
     * The base implementation of `_.forEachRight` without support for iteratee shorthands. 
     * 
     * @private 
     * @param {Array|Object} collection The collection to iterate over. 
     * @param {Function} iteratee The function invoked per iteration. 
     * @returns {Array|Object} Returns `collection`. 
     */</span>
    <span class="s2">var </span><span class="s1">baseEachRight = createBaseEach(baseForOwnRight, </span><span class="s2">true</span><span class="s1">);</span>

    <span class="s0">/** 
     * The base implementation of `_.every` without support for iteratee shorthands. 
     * 
     * @private 
     * @param {Array|Object} collection The collection to iterate over. 
     * @param {Function} predicate The function invoked per iteration. 
     * @returns {boolean} Returns `true` if all elements pass the predicate check, 
     *  else `false` 
     */</span>
    <span class="s2">function </span><span class="s1">baseEvery(collection, predicate) {</span>
      <span class="s2">var </span><span class="s1">result = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s1">baseEach(collection, </span><span class="s2">function</span><span class="s1">(value, index, collection) {</span>
        <span class="s1">result = !!predicate(value, index, collection);</span>
        <span class="s2">return </span><span class="s1">result;</span>
      <span class="s1">});</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of methods like `_.max` and `_.min` which accepts a 
     * `comparator` to determine the extremum value. 
     * 
     * @private 
     * @param {Array} array The array to iterate over. 
     * @param {Function} iteratee The iteratee invoked per iteration. 
     * @param {Function} comparator The comparator used to compare values. 
     * @returns {*} Returns the extremum value. 
     */</span>
    <span class="s2">function </span><span class="s1">baseExtremum(array, iteratee, comparator) {</span>
      <span class="s2">var </span><span class="s1">index = -</span><span class="s4">1</span><span class="s1">,</span>
          <span class="s1">length = array.length;</span>

      <span class="s2">while </span><span class="s1">(++index &lt; length) {</span>
        <span class="s2">var </span><span class="s1">value = array[index],</span>
            <span class="s1">current = iteratee(value);</span>

        <span class="s2">if </span><span class="s1">(current != </span><span class="s2">null </span><span class="s1">&amp;&amp; (computed === undefined</span>
              <span class="s1">? (current === current &amp;&amp; !isSymbol(current))</span>
              <span class="s1">: comparator(current, computed)</span>
            <span class="s1">)) {</span>
          <span class="s2">var </span><span class="s1">computed = current,</span>
              <span class="s1">result = value;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.fill` without an iteratee call guard. 
     * 
     * @private 
     * @param {Array} array The array to fill. 
     * @param {*} value The value to fill `array` with. 
     * @param {number} [start=0] The start position. 
     * @param {number} [end=array.length] The end position. 
     * @returns {Array} Returns `array`. 
     */</span>
    <span class="s2">function </span><span class="s1">baseFill(array, value, start, end) {</span>
      <span class="s2">var </span><span class="s1">length = array.length;</span>

      <span class="s1">start = toInteger(start);</span>
      <span class="s2">if </span><span class="s1">(start &lt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">start = -start &gt; length ? </span><span class="s4">0 </span><span class="s1">: (length + start);</span>
      <span class="s1">}</span>
      <span class="s1">end = (end === undefined || end &gt; length) ? length : toInteger(end);</span>
      <span class="s2">if </span><span class="s1">(end &lt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">end += length;</span>
      <span class="s1">}</span>
      <span class="s1">end = start &gt; end ? </span><span class="s4">0 </span><span class="s1">: toLength(end);</span>
      <span class="s2">while </span><span class="s1">(start &lt; end) {</span>
        <span class="s1">array[start++] = value;</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">array;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.filter` without support for iteratee shorthands. 
     * 
     * @private 
     * @param {Array|Object} collection The collection to iterate over. 
     * @param {Function} predicate The function invoked per iteration. 
     * @returns {Array} Returns the new filtered array. 
     */</span>
    <span class="s2">function </span><span class="s1">baseFilter(collection, predicate) {</span>
      <span class="s2">var </span><span class="s1">result = [];</span>
      <span class="s1">baseEach(collection, </span><span class="s2">function</span><span class="s1">(value, index, collection) {</span>
        <span class="s2">if </span><span class="s1">(predicate(value, index, collection)) {</span>
          <span class="s1">result.push(value);</span>
        <span class="s1">}</span>
      <span class="s1">});</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.flatten` with support for restricting flattening. 
     * 
     * @private 
     * @param {Array} array The array to flatten. 
     * @param {number} depth The maximum recursion depth. 
     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration. 
     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks. 
     * @param {Array} [result=[]] The initial result value. 
     * @returns {Array} Returns the new flattened array. 
     */</span>
    <span class="s2">function </span><span class="s1">baseFlatten(array, depth, predicate, isStrict, result) {</span>
      <span class="s2">var </span><span class="s1">index = -</span><span class="s4">1</span><span class="s1">,</span>
          <span class="s1">length = array.length;</span>

      <span class="s1">predicate || (predicate = isFlattenable);</span>
      <span class="s1">result || (result = []);</span>

      <span class="s2">while </span><span class="s1">(++index &lt; length) {</span>
        <span class="s2">var </span><span class="s1">value = array[index];</span>
        <span class="s2">if </span><span class="s1">(depth &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; predicate(value)) {</span>
          <span class="s2">if </span><span class="s1">(depth &gt; </span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s0">// Recursively flatten arrays (susceptible to call stack limits).</span>
            <span class="s1">baseFlatten(value, depth - </span><span class="s4">1</span><span class="s1">, predicate, isStrict, result);</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">arrayPush(result, value);</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!isStrict) {</span>
          <span class="s1">result[result.length] = value;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `baseForOwn` which iterates over `object` 
     * properties returned by `keysFunc` and invokes `iteratee` for each property. 
     * Iteratee functions may exit iteration early by explicitly returning `false`. 
     * 
     * @private 
     * @param {Object} object The object to iterate over. 
     * @param {Function} iteratee The function invoked per iteration. 
     * @param {Function} keysFunc The function to get the keys of `object`. 
     * @returns {Object} Returns `object`. 
     */</span>
    <span class="s2">var </span><span class="s1">baseFor = createBaseFor();</span>

    <span class="s0">/** 
     * This function is like `baseFor` except that it iterates over properties 
     * in the opposite order. 
     * 
     * @private 
     * @param {Object} object The object to iterate over. 
     * @param {Function} iteratee The function invoked per iteration. 
     * @param {Function} keysFunc The function to get the keys of `object`. 
     * @returns {Object} Returns `object`. 
     */</span>
    <span class="s2">var </span><span class="s1">baseForRight = createBaseFor(</span><span class="s2">true</span><span class="s1">);</span>

    <span class="s0">/** 
     * The base implementation of `_.forOwn` without support for iteratee shorthands. 
     * 
     * @private 
     * @param {Object} object The object to iterate over. 
     * @param {Function} iteratee The function invoked per iteration. 
     * @returns {Object} Returns `object`. 
     */</span>
    <span class="s2">function </span><span class="s1">baseForOwn(object, iteratee) {</span>
      <span class="s2">return </span><span class="s1">object &amp;&amp; baseFor(object, iteratee, keys);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.forOwnRight` without support for iteratee shorthands. 
     * 
     * @private 
     * @param {Object} object The object to iterate over. 
     * @param {Function} iteratee The function invoked per iteration. 
     * @returns {Object} Returns `object`. 
     */</span>
    <span class="s2">function </span><span class="s1">baseForOwnRight(object, iteratee) {</span>
      <span class="s2">return </span><span class="s1">object &amp;&amp; baseForRight(object, iteratee, keys);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.functions` which creates an array of 
     * `object` function property names filtered from `props`. 
     * 
     * @private 
     * @param {Object} object The object to inspect. 
     * @param {Array} props The property names to filter. 
     * @returns {Array} Returns the function names. 
     */</span>
    <span class="s2">function </span><span class="s1">baseFunctions(object, props) {</span>
      <span class="s2">return </span><span class="s1">arrayFilter(props, </span><span class="s2">function</span><span class="s1">(key) {</span>
        <span class="s2">return </span><span class="s1">isFunction(object[key]);</span>
      <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.get` without support for default values. 
     * 
     * @private 
     * @param {Object} object The object to query. 
     * @param {Array|string} path The path of the property to get. 
     * @returns {*} Returns the resolved value. 
     */</span>
    <span class="s2">function </span><span class="s1">baseGet(object, path) {</span>
      <span class="s1">path = castPath(path, object);</span>

      <span class="s2">var </span><span class="s1">index = </span><span class="s4">0</span><span class="s1">,</span>
          <span class="s1">length = path.length;</span>

      <span class="s2">while </span><span class="s1">(object != </span><span class="s2">null </span><span class="s1">&amp;&amp; index &lt; length) {</span>
        <span class="s1">object = object[toKey(path[index++])];</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">(index &amp;&amp; index == length) ? object : undefined;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses 
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and 
     * symbols of `object`. 
     * 
     * @private 
     * @param {Object} object The object to query. 
     * @param {Function} keysFunc The function to get the keys of `object`. 
     * @param {Function} symbolsFunc The function to get the symbols of `object`. 
     * @returns {Array} Returns the array of property names and symbols. 
     */</span>
    <span class="s2">function </span><span class="s1">baseGetAllKeys(object, keysFunc, symbolsFunc) {</span>
      <span class="s2">var </span><span class="s1">result = keysFunc(object);</span>
      <span class="s2">return </span><span class="s1">isArray(object) ? result : arrayPush(result, symbolsFunc(object));</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `getTag` without fallbacks for buggy environments. 
     * 
     * @private 
     * @param {*} value The value to query. 
     * @returns {string} Returns the `toStringTag`. 
     */</span>
    <span class="s2">function </span><span class="s1">baseGetTag(value) {</span>
      <span class="s2">if </span><span class="s1">(value == </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">value === undefined ? undefinedTag : nullTag;</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">(symToStringTag &amp;&amp; symToStringTag </span><span class="s2">in </span><span class="s1">Object(value))</span>
        <span class="s1">? getRawTag(value)</span>
        <span class="s1">: objectToString(value);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.gt` which doesn't coerce arguments. 
     * 
     * @private 
     * @param {*} value The value to compare. 
     * @param {*} other The other value to compare. 
     * @returns {boolean} Returns `true` if `value` is greater than `other`, 
     *  else `false`. 
     */</span>
    <span class="s2">function </span><span class="s1">baseGt(value, other) {</span>
      <span class="s2">return </span><span class="s1">value &gt; other;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.has` without support for deep paths. 
     * 
     * @private 
     * @param {Object} [object] The object to query. 
     * @param {Array|string} key The key to check. 
     * @returns {boolean} Returns `true` if `key` exists, else `false`. 
     */</span>
    <span class="s2">function </span><span class="s1">baseHas(object, key) {</span>
      <span class="s2">return </span><span class="s1">object != </span><span class="s2">null </span><span class="s1">&amp;&amp; hasOwnProperty.call(object, key);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.hasIn` without support for deep paths. 
     * 
     * @private 
     * @param {Object} [object] The object to query. 
     * @param {Array|string} key The key to check. 
     * @returns {boolean} Returns `true` if `key` exists, else `false`. 
     */</span>
    <span class="s2">function </span><span class="s1">baseHasIn(object, key) {</span>
      <span class="s2">return </span><span class="s1">object != </span><span class="s2">null </span><span class="s1">&amp;&amp; key </span><span class="s2">in </span><span class="s1">Object(object);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.inRange` which doesn't coerce arguments. 
     * 
     * @private 
     * @param {number} number The number to check. 
     * @param {number} start The start of the range. 
     * @param {number} end The end of the range. 
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`. 
     */</span>
    <span class="s2">function </span><span class="s1">baseInRange(number, start, end) {</span>
      <span class="s2">return </span><span class="s1">number &gt;= nativeMin(start, end) &amp;&amp; number &lt; nativeMax(start, end);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of methods like `_.intersection`, without support 
     * for iteratee shorthands, that accepts an array of arrays to inspect. 
     * 
     * @private 
     * @param {Array} arrays The arrays to inspect. 
     * @param {Function} [iteratee] The iteratee invoked per element. 
     * @param {Function} [comparator] The comparator invoked per element. 
     * @returns {Array} Returns the new array of shared values. 
     */</span>
    <span class="s2">function </span><span class="s1">baseIntersection(arrays, iteratee, comparator) {</span>
      <span class="s2">var </span><span class="s1">includes = comparator ? arrayIncludesWith : arrayIncludes,</span>
          <span class="s1">length = arrays[</span><span class="s4">0</span><span class="s1">].length,</span>
          <span class="s1">othLength = arrays.length,</span>
          <span class="s1">othIndex = othLength,</span>
          <span class="s1">caches = Array(othLength),</span>
          <span class="s1">maxLength = Infinity,</span>
          <span class="s1">result = [];</span>

      <span class="s2">while </span><span class="s1">(othIndex--) {</span>
        <span class="s2">var </span><span class="s1">array = arrays[othIndex];</span>
        <span class="s2">if </span><span class="s1">(othIndex &amp;&amp; iteratee) {</span>
          <span class="s1">array = arrayMap(array, baseUnary(iteratee));</span>
        <span class="s1">}</span>
        <span class="s1">maxLength = nativeMin(array.length, maxLength);</span>
        <span class="s1">caches[othIndex] = !comparator &amp;&amp; (iteratee || (length &gt;= </span><span class="s4">120 </span><span class="s1">&amp;&amp; array.length &gt;= </span><span class="s4">120</span><span class="s1">))</span>
          <span class="s1">? </span><span class="s2">new </span><span class="s1">SetCache(othIndex &amp;&amp; array)</span>
          <span class="s1">: undefined;</span>
      <span class="s1">}</span>
      <span class="s1">array = arrays[</span><span class="s4">0</span><span class="s1">];</span>

      <span class="s2">var </span><span class="s1">index = -</span><span class="s4">1</span><span class="s1">,</span>
          <span class="s1">seen = caches[</span><span class="s4">0</span><span class="s1">];</span>

      <span class="s1">outer:</span>
      <span class="s2">while </span><span class="s1">(++index &lt; length &amp;&amp; result.length &lt; maxLength) {</span>
        <span class="s2">var </span><span class="s1">value = array[index],</span>
            <span class="s1">computed = iteratee ? iteratee(value) : value;</span>

        <span class="s1">value = (comparator || value !== </span><span class="s4">0</span><span class="s1">) ? value : </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(!(seen</span>
              <span class="s1">? cacheHas(seen, computed)</span>
              <span class="s1">: includes(result, computed, comparator)</span>
            <span class="s1">)) {</span>
          <span class="s1">othIndex = othLength;</span>
          <span class="s2">while </span><span class="s1">(--othIndex) {</span>
            <span class="s2">var </span><span class="s1">cache = caches[othIndex];</span>
            <span class="s2">if </span><span class="s1">(!(cache</span>
                  <span class="s1">? cacheHas(cache, computed)</span>
                  <span class="s1">: includes(arrays[othIndex], computed, comparator))</span>
                <span class="s1">) {</span>
              <span class="s2">continue </span><span class="s1">outer;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
          <span class="s2">if </span><span class="s1">(seen) {</span>
            <span class="s1">seen.push(computed);</span>
          <span class="s1">}</span>
          <span class="s1">result.push(value);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.invert` and `_.invertBy` which inverts 
     * `object` with values transformed by `iteratee` and set by `setter`. 
     * 
     * @private 
     * @param {Object} object The object to iterate over. 
     * @param {Function} setter The function to set `accumulator` values. 
     * @param {Function} iteratee The iteratee to transform values. 
     * @param {Object} accumulator The initial inverted object. 
     * @returns {Function} Returns `accumulator`. 
     */</span>
    <span class="s2">function </span><span class="s1">baseInverter(object, setter, iteratee, accumulator) {</span>
      <span class="s1">baseForOwn(object, </span><span class="s2">function</span><span class="s1">(value, key, object) {</span>
        <span class="s1">setter(accumulator, iteratee(value), key, object);</span>
      <span class="s1">});</span>
      <span class="s2">return </span><span class="s1">accumulator;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.invoke` without support for individual 
     * method arguments. 
     * 
     * @private 
     * @param {Object} object The object to query. 
     * @param {Array|string} path The path of the method to invoke. 
     * @param {Array} args The arguments to invoke the method with. 
     * @returns {*} Returns the result of the invoked method. 
     */</span>
    <span class="s2">function </span><span class="s1">baseInvoke(object, path, args) {</span>
      <span class="s1">path = castPath(path, object);</span>
      <span class="s1">object = parent(object, path);</span>
      <span class="s2">var </span><span class="s1">func = object == </span><span class="s2">null </span><span class="s1">? object : object[toKey(last(path))];</span>
      <span class="s2">return </span><span class="s1">func == </span><span class="s2">null </span><span class="s1">? undefined : apply(func, object, args);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.isArguments`. 
     * 
     * @private 
     * @param {*} value The value to check. 
     * @returns {boolean} Returns `true` if `value` is an `arguments` object, 
     */</span>
    <span class="s2">function </span><span class="s1">baseIsArguments(value) {</span>
      <span class="s2">return </span><span class="s1">isObjectLike(value) &amp;&amp; baseGetTag(value) == argsTag;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.isArrayBuffer` without Node.js optimizations. 
     * 
     * @private 
     * @param {*} value The value to check. 
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`. 
     */</span>
    <span class="s2">function </span><span class="s1">baseIsArrayBuffer(value) {</span>
      <span class="s2">return </span><span class="s1">isObjectLike(value) &amp;&amp; baseGetTag(value) == arrayBufferTag;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.isDate` without Node.js optimizations. 
     * 
     * @private 
     * @param {*} value The value to check. 
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`. 
     */</span>
    <span class="s2">function </span><span class="s1">baseIsDate(value) {</span>
      <span class="s2">return </span><span class="s1">isObjectLike(value) &amp;&amp; baseGetTag(value) == dateTag;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.isEqual` which supports partial comparisons 
     * and tracks traversed objects. 
     * 
     * @private 
     * @param {*} value The value to compare. 
     * @param {*} other The other value to compare. 
     * @param {boolean} bitmask The bitmask flags. 
     *  1 - Unordered comparison 
     *  2 - Partial comparison 
     * @param {Function} [customizer] The function to customize comparisons. 
     * @param {Object} [stack] Tracks traversed `value` and `other` objects. 
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`. 
     */</span>
    <span class="s2">function </span><span class="s1">baseIsEqual(value, other, bitmask, customizer, stack) {</span>
      <span class="s2">if </span><span class="s1">(value === other) {</span>
        <span class="s2">return true</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(value == </span><span class="s2">null </span><span class="s1">|| other == </span><span class="s2">null </span><span class="s1">|| (!isObjectLike(value) &amp;&amp; !isObjectLike(other))) {</span>
        <span class="s2">return </span><span class="s1">value !== value &amp;&amp; other !== other;</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * A specialized version of `baseIsEqual` for arrays and objects which performs 
     * deep comparisons and tracks traversed objects enabling objects with circular 
     * references to be compared. 
     * 
     * @private 
     * @param {Object} object The object to compare. 
     * @param {Object} other The other object to compare. 
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details. 
     * @param {Function} customizer The function to customize comparisons. 
     * @param {Function} equalFunc The function to determine equivalents of values. 
     * @param {Object} [stack] Tracks traversed `object` and `other` objects. 
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`. 
     */</span>
    <span class="s2">function </span><span class="s1">baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {</span>
      <span class="s2">var </span><span class="s1">objIsArr = isArray(object),</span>
          <span class="s1">othIsArr = isArray(other),</span>
          <span class="s1">objTag = objIsArr ? arrayTag : getTag(object),</span>
          <span class="s1">othTag = othIsArr ? arrayTag : getTag(other);</span>

      <span class="s1">objTag = objTag == argsTag ? objectTag : objTag;</span>
      <span class="s1">othTag = othTag == argsTag ? objectTag : othTag;</span>

      <span class="s2">var </span><span class="s1">objIsObj = objTag == objectTag,</span>
          <span class="s1">othIsObj = othTag == objectTag,</span>
          <span class="s1">isSameTag = objTag == othTag;</span>

      <span class="s2">if </span><span class="s1">(isSameTag &amp;&amp; isBuffer(object)) {</span>
        <span class="s2">if </span><span class="s1">(!isBuffer(other)) {</span>
          <span class="s2">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">objIsArr = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">objIsObj = </span><span class="s2">false</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(isSameTag &amp;&amp; !objIsObj) {</span>
        <span class="s1">stack || (stack = </span><span class="s2">new </span><span class="s1">Stack);</span>
        <span class="s2">return </span><span class="s1">(objIsArr || isTypedArray(object))</span>
          <span class="s1">? equalArrays(object, other, bitmask, customizer, equalFunc, stack)</span>
          <span class="s1">: equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(!(bitmask &amp; COMPARE_PARTIAL_FLAG)) {</span>
        <span class="s2">var </span><span class="s1">objIsWrapped = objIsObj &amp;&amp; hasOwnProperty.call(object, </span><span class="s3">'__wrapped__'</span><span class="s1">),</span>
            <span class="s1">othIsWrapped = othIsObj &amp;&amp; hasOwnProperty.call(other, </span><span class="s3">'__wrapped__'</span><span class="s1">);</span>

        <span class="s2">if </span><span class="s1">(objIsWrapped || othIsWrapped) {</span>
          <span class="s2">var </span><span class="s1">objUnwrapped = objIsWrapped ? object.value() : object,</span>
              <span class="s1">othUnwrapped = othIsWrapped ? other.value() : other;</span>

          <span class="s1">stack || (stack = </span><span class="s2">new </span><span class="s1">Stack);</span>
          <span class="s2">return </span><span class="s1">equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(!isSameTag) {</span>
        <span class="s2">return false</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s1">stack || (stack = </span><span class="s2">new </span><span class="s1">Stack);</span>
      <span class="s2">return </span><span class="s1">equalObjects(object, other, bitmask, customizer, equalFunc, stack);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.isMap` without Node.js optimizations. 
     * 
     * @private 
     * @param {*} value The value to check. 
     * @returns {boolean} Returns `true` if `value` is a map, else `false`. 
     */</span>
    <span class="s2">function </span><span class="s1">baseIsMap(value) {</span>
      <span class="s2">return </span><span class="s1">isObjectLike(value) &amp;&amp; getTag(value) == mapTag;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.isMatch` without support for iteratee shorthands. 
     * 
     * @private 
     * @param {Object} object The object to inspect. 
     * @param {Object} source The object of property values to match. 
     * @param {Array} matchData The property names, values, and compare flags to match. 
     * @param {Function} [customizer] The function to customize comparisons. 
     * @returns {boolean} Returns `true` if `object` is a match, else `false`. 
     */</span>
    <span class="s2">function </span><span class="s1">baseIsMatch(object, source, matchData, customizer) {</span>
      <span class="s2">var </span><span class="s1">index = matchData.length,</span>
          <span class="s1">length = index,</span>
          <span class="s1">noCustomizer = !customizer;</span>

      <span class="s2">if </span><span class="s1">(object == </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">!length;</span>
      <span class="s1">}</span>
      <span class="s1">object = Object(object);</span>
      <span class="s2">while </span><span class="s1">(index--) {</span>
        <span class="s2">var </span><span class="s1">data = matchData[index];</span>
        <span class="s2">if </span><span class="s1">((noCustomizer &amp;&amp; data[</span><span class="s4">2</span><span class="s1">])</span>
              <span class="s1">? data[</span><span class="s4">1</span><span class="s1">] !== object[data[</span><span class="s4">0</span><span class="s1">]]</span>
              <span class="s1">: !(data[</span><span class="s4">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">object)</span>
            <span class="s1">) {</span>
          <span class="s2">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">while </span><span class="s1">(++index &lt; length) {</span>
        <span class="s1">data = matchData[index];</span>
        <span class="s2">var </span><span class="s1">key = data[</span><span class="s4">0</span><span class="s1">],</span>
            <span class="s1">objValue = object[key],</span>
            <span class="s1">srcValue = data[</span><span class="s4">1</span><span class="s1">];</span>

        <span class="s2">if </span><span class="s1">(noCustomizer &amp;&amp; data[</span><span class="s4">2</span><span class="s1">]) {</span>
          <span class="s2">if </span><span class="s1">(objValue === undefined &amp;&amp; !(key </span><span class="s2">in </span><span class="s1">object)) {</span>
            <span class="s2">return false</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s2">var </span><span class="s1">stack = </span><span class="s2">new </span><span class="s1">Stack;</span>
          <span class="s2">if </span><span class="s1">(customizer) {</span>
            <span class="s2">var </span><span class="s1">result = customizer(objValue, srcValue, key, object, source, stack);</span>
          <span class="s1">}</span>
          <span class="s2">if </span><span class="s1">(!(result === undefined</span>
                <span class="s1">? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)</span>
                <span class="s1">: result</span>
              <span class="s1">)) {</span>
            <span class="s2">return false</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.isNative` without bad shim checks. 
     * 
     * @private 
     * @param {*} value The value to check. 
     * @returns {boolean} Returns `true` if `value` is a native function, 
     *  else `false`. 
     */</span>
    <span class="s2">function </span><span class="s1">baseIsNative(value) {</span>
      <span class="s2">if </span><span class="s1">(!isObject(value) || isMasked(value)) {</span>
        <span class="s2">return false</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">pattern = isFunction(value) ? reIsNative : reIsHostCtor;</span>
      <span class="s2">return </span><span class="s1">pattern.test(toSource(value));</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.isRegExp` without Node.js optimizations. 
     * 
     * @private 
     * @param {*} value The value to check. 
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`. 
     */</span>
    <span class="s2">function </span><span class="s1">baseIsRegExp(value) {</span>
      <span class="s2">return </span><span class="s1">isObjectLike(value) &amp;&amp; baseGetTag(value) == regexpTag;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.isSet` without Node.js optimizations. 
     * 
     * @private 
     * @param {*} value The value to check. 
     * @returns {boolean} Returns `true` if `value` is a set, else `false`. 
     */</span>
    <span class="s2">function </span><span class="s1">baseIsSet(value) {</span>
      <span class="s2">return </span><span class="s1">isObjectLike(value) &amp;&amp; getTag(value) == setTag;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.isTypedArray` without Node.js optimizations. 
     * 
     * @private 
     * @param {*} value The value to check. 
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`. 
     */</span>
    <span class="s2">function </span><span class="s1">baseIsTypedArray(value) {</span>
      <span class="s2">return </span><span class="s1">isObjectLike(value) &amp;&amp;</span>
        <span class="s1">isLength(value.length) &amp;&amp; !!typedArrayTags[baseGetTag(value)];</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.iteratee`. 
     * 
     * @private 
     * @param {*} [value=_.identity] The value to convert to an iteratee. 
     * @returns {Function} Returns the iteratee. 
     */</span>
    <span class="s2">function </span><span class="s1">baseIteratee(value) {</span>
      <span class="s0">// Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.</span>
      <span class="s0">// See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">value == </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">value;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(value == </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">identity;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">value == </span><span class="s3">'object'</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">isArray(value)</span>
          <span class="s1">? baseMatchesProperty(value[</span><span class="s4">0</span><span class="s1">], value[</span><span class="s4">1</span><span class="s1">])</span>
          <span class="s1">: baseMatches(value);</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">property(value);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense. 
     * 
     * @private 
     * @param {Object} object The object to query. 
     * @returns {Array} Returns the array of property names. 
     */</span>
    <span class="s2">function </span><span class="s1">baseKeys(object) {</span>
      <span class="s2">if </span><span class="s1">(!isPrototype(object)) {</span>
        <span class="s2">return </span><span class="s1">nativeKeys(object);</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">result = [];</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">key </span><span class="s2">in </span><span class="s1">Object(object)) {</span>
        <span class="s2">if </span><span class="s1">(hasOwnProperty.call(object, key) &amp;&amp; key != </span><span class="s3">'constructor'</span><span class="s1">) {</span>
          <span class="s1">result.push(key);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense. 
     * 
     * @private 
     * @param {Object} object The object to query. 
     * @returns {Array} Returns the array of property names. 
     */</span>
    <span class="s2">function </span><span class="s1">baseKeysIn(object) {</span>
      <span class="s2">if </span><span class="s1">(!isObject(object)) {</span>
        <span class="s2">return </span><span class="s1">nativeKeysIn(object);</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">isProto = isPrototype(object),</span>
          <span class="s1">result = [];</span>

      <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">key </span><span class="s2">in </span><span class="s1">object) {</span>
        <span class="s2">if </span><span class="s1">(!(key == </span><span class="s3">'constructor' </span><span class="s1">&amp;&amp; (isProto || !hasOwnProperty.call(object, key)))) {</span>
          <span class="s1">result.push(key);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.lt` which doesn't coerce arguments. 
     * 
     * @private 
     * @param {*} value The value to compare. 
     * @param {*} other The other value to compare. 
     * @returns {boolean} Returns `true` if `value` is less than `other`, 
     *  else `false`. 
     */</span>
    <span class="s2">function </span><span class="s1">baseLt(value, other) {</span>
      <span class="s2">return </span><span class="s1">value &lt; other;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.map` without support for iteratee shorthands. 
     * 
     * @private 
     * @param {Array|Object} collection The collection to iterate over. 
     * @param {Function} iteratee The function invoked per iteration. 
     * @returns {Array} Returns the new mapped array. 
     */</span>
    <span class="s2">function </span><span class="s1">baseMap(collection, iteratee) {</span>
      <span class="s2">var </span><span class="s1">index = -</span><span class="s4">1</span><span class="s1">,</span>
          <span class="s1">result = isArrayLike(collection) ? Array(collection.length) : [];</span>

      <span class="s1">baseEach(collection, </span><span class="s2">function</span><span class="s1">(value, key, collection) {</span>
        <span class="s1">result[++index] = iteratee(value, key, collection);</span>
      <span class="s1">});</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.matches` which doesn't clone `source`. 
     * 
     * @private 
     * @param {Object} source The object of property values to match. 
     * @returns {Function} Returns the new spec function. 
     */</span>
    <span class="s2">function </span><span class="s1">baseMatches(source) {</span>
      <span class="s2">var </span><span class="s1">matchData = getMatchData(source);</span>
      <span class="s2">if </span><span class="s1">(matchData.length == </span><span class="s4">1 </span><span class="s1">&amp;&amp; matchData[</span><span class="s4">0</span><span class="s1">][</span><span class="s4">2</span><span class="s1">]) {</span>
        <span class="s2">return </span><span class="s1">matchesStrictComparable(matchData[</span><span class="s4">0</span><span class="s1">][</span><span class="s4">0</span><span class="s1">], matchData[</span><span class="s4">0</span><span class="s1">][</span><span class="s4">1</span><span class="s1">]);</span>
      <span class="s1">}</span>
      <span class="s2">return function</span><span class="s1">(object) {</span>
        <span class="s2">return </span><span class="s1">object === source || baseIsMatch(object, source, matchData);</span>
      <span class="s1">};</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`. 
     * 
     * @private 
     * @param {string} path The path of the property to get. 
     * @param {*} srcValue The value to match. 
     * @returns {Function} Returns the new spec function. 
     */</span>
    <span class="s2">function </span><span class="s1">baseMatchesProperty(path, srcValue) {</span>
      <span class="s2">if </span><span class="s1">(isKey(path) &amp;&amp; isStrictComparable(srcValue)) {</span>
        <span class="s2">return </span><span class="s1">matchesStrictComparable(toKey(path), srcValue);</span>
      <span class="s1">}</span>
      <span class="s2">return function</span><span class="s1">(object) {</span>
        <span class="s2">var </span><span class="s1">objValue = get(object, path);</span>
        <span class="s2">return </span><span class="s1">(objValue === undefined &amp;&amp; objValue === srcValue)</span>
          <span class="s1">? hasIn(object, path)</span>
          <span class="s1">: baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);</span>
      <span class="s1">};</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.merge` without support for multiple sources. 
     * 
     * @private 
     * @param {Object} object The destination object. 
     * @param {Object} source The source object. 
     * @param {number} srcIndex The index of `source`. 
     * @param {Function} [customizer] The function to customize merged values. 
     * @param {Object} [stack] Tracks traversed source values and their merged 
     *  counterparts. 
     */</span>
    <span class="s2">function </span><span class="s1">baseMerge(object, source, srcIndex, customizer, stack) {</span>
      <span class="s2">if </span><span class="s1">(object === source) {</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s1">baseFor(source, </span><span class="s2">function</span><span class="s1">(srcValue, key) {</span>
        <span class="s1">stack || (stack = </span><span class="s2">new </span><span class="s1">Stack);</span>
        <span class="s2">if </span><span class="s1">(isObject(srcValue)) {</span>
          <span class="s1">baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
          <span class="s2">var </span><span class="s1">newValue = customizer</span>
            <span class="s1">? customizer(safeGet(object, key), srcValue, (key + </span><span class="s3">''</span><span class="s1">), object, source, stack)</span>
            <span class="s1">: undefined;</span>

          <span class="s2">if </span><span class="s1">(newValue === undefined) {</span>
            <span class="s1">newValue = srcValue;</span>
          <span class="s1">}</span>
          <span class="s1">assignMergeValue(object, key, newValue);</span>
        <span class="s1">}</span>
      <span class="s1">}, keysIn);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * A specialized version of `baseMerge` for arrays and objects which performs 
     * deep merges and tracks traversed objects enabling objects with circular 
     * references to be merged. 
     * 
     * @private 
     * @param {Object} object The destination object. 
     * @param {Object} source The source object. 
     * @param {string} key The key of the value to merge. 
     * @param {number} srcIndex The index of `source`. 
     * @param {Function} mergeFunc The function to merge values. 
     * @param {Function} [customizer] The function to customize assigned values. 
     * @param {Object} [stack] Tracks traversed source values and their merged 
     *  counterparts. 
     */</span>
    <span class="s2">function </span><span class="s1">baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {</span>
      <span class="s2">var </span><span class="s1">objValue = safeGet(object, key),</span>
          <span class="s1">srcValue = safeGet(source, key),</span>
          <span class="s1">stacked = stack.get(srcValue);</span>

      <span class="s2">if </span><span class="s1">(stacked) {</span>
        <span class="s1">assignMergeValue(object, key, stacked);</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">newValue = customizer</span>
        <span class="s1">? customizer(objValue, srcValue, (key + </span><span class="s3">''</span><span class="s1">), object, source, stack)</span>
        <span class="s1">: undefined;</span>

      <span class="s2">var </span><span class="s1">isCommon = newValue === undefined;</span>

      <span class="s2">if </span><span class="s1">(isCommon) {</span>
        <span class="s2">var </span><span class="s1">isArr = isArray(srcValue),</span>
            <span class="s1">isBuff = !isArr &amp;&amp; isBuffer(srcValue),</span>
            <span class="s1">isTyped = !isArr &amp;&amp; !isBuff &amp;&amp; isTypedArray(srcValue);</span>

        <span class="s1">newValue = srcValue;</span>
        <span class="s2">if </span><span class="s1">(isArr || isBuff || isTyped) {</span>
          <span class="s2">if </span><span class="s1">(isArray(objValue)) {</span>
            <span class="s1">newValue = objValue;</span>
          <span class="s1">}</span>
          <span class="s2">else if </span><span class="s1">(isArrayLikeObject(objValue)) {</span>
            <span class="s1">newValue = copyArray(objValue);</span>
          <span class="s1">}</span>
          <span class="s2">else if </span><span class="s1">(isBuff) {</span>
            <span class="s1">isCommon = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s1">newValue = cloneBuffer(srcValue, </span><span class="s2">true</span><span class="s1">);</span>
          <span class="s1">}</span>
          <span class="s2">else if </span><span class="s1">(isTyped) {</span>
            <span class="s1">isCommon = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s1">newValue = cloneTypedArray(srcValue, </span><span class="s2">true</span><span class="s1">);</span>
          <span class="s1">}</span>
          <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">newValue = [];</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(isPlainObject(srcValue) || isArguments(srcValue)) {</span>
          <span class="s1">newValue = objValue;</span>
          <span class="s2">if </span><span class="s1">(isArguments(objValue)) {</span>
            <span class="s1">newValue = toPlainObject(objValue);</span>
          <span class="s1">}</span>
          <span class="s2">else if </span><span class="s1">(!isObject(objValue) || isFunction(objValue)) {</span>
            <span class="s1">newValue = initCloneObject(srcValue);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
          <span class="s1">isCommon = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(isCommon) {</span>
        <span class="s0">// Recursively merge objects and arrays (susceptible to call stack limits).</span>
        <span class="s1">stack.set(srcValue, newValue);</span>
        <span class="s1">mergeFunc(newValue, srcValue, srcIndex, customizer, stack);</span>
        <span class="s1">stack[</span><span class="s3">'delete'</span><span class="s1">](srcValue);</span>
      <span class="s1">}</span>
      <span class="s1">assignMergeValue(object, key, newValue);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.nth` which doesn't coerce arguments. 
     * 
     * @private 
     * @param {Array} array The array to query. 
     * @param {number} n The index of the element to return. 
     * @returns {*} Returns the nth element of `array`. 
     */</span>
    <span class="s2">function </span><span class="s1">baseNth(array, n) {</span>
      <span class="s2">var </span><span class="s1">length = array.length;</span>
      <span class="s2">if </span><span class="s1">(!length) {</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s1">n += n &lt; </span><span class="s4">0 </span><span class="s1">? length : </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s2">return </span><span class="s1">isIndex(n, length) ? array[n] : undefined;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.orderBy` without param guards. 
     * 
     * @private 
     * @param {Array|Object} collection The collection to iterate over. 
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by. 
     * @param {string[]} orders The sort orders of `iteratees`. 
     * @returns {Array} Returns the new sorted array. 
     */</span>
    <span class="s2">function </span><span class="s1">baseOrderBy(collection, iteratees, orders) {</span>
      <span class="s2">if </span><span class="s1">(iteratees.length) {</span>
        <span class="s1">iteratees = arrayMap(iteratees, </span><span class="s2">function</span><span class="s1">(iteratee) {</span>
          <span class="s2">if </span><span class="s1">(isArray(iteratee)) {</span>
            <span class="s2">return function</span><span class="s1">(value) {</span>
              <span class="s2">return </span><span class="s1">baseGet(value, iteratee.length === </span><span class="s4">1 </span><span class="s1">? iteratee[</span><span class="s4">0</span><span class="s1">] : iteratee);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
          <span class="s2">return </span><span class="s1">iteratee;</span>
        <span class="s1">});</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">iteratees = [identity];</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">index = -</span><span class="s4">1</span><span class="s1">;</span>
      <span class="s1">iteratees = arrayMap(iteratees, baseUnary(getIteratee()));</span>

      <span class="s2">var </span><span class="s1">result = baseMap(collection, </span><span class="s2">function</span><span class="s1">(value, key, collection) {</span>
        <span class="s2">var </span><span class="s1">criteria = arrayMap(iteratees, </span><span class="s2">function</span><span class="s1">(iteratee) {</span>
          <span class="s2">return </span><span class="s1">iteratee(value);</span>
        <span class="s1">});</span>
        <span class="s2">return </span><span class="s1">{ </span><span class="s3">'criteria'</span><span class="s1">: criteria, </span><span class="s3">'index'</span><span class="s1">: ++index, </span><span class="s3">'value'</span><span class="s1">: value };</span>
      <span class="s1">});</span>

      <span class="s2">return </span><span class="s1">baseSortBy(result, </span><span class="s2">function</span><span class="s1">(object, other) {</span>
        <span class="s2">return </span><span class="s1">compareMultiple(object, other, orders);</span>
      <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.pick` without support for individual 
     * property identifiers. 
     * 
     * @private 
     * @param {Object} object The source object. 
     * @param {string[]} paths The property paths to pick. 
     * @returns {Object} Returns the new object. 
     */</span>
    <span class="s2">function </span><span class="s1">basePick(object, paths) {</span>
      <span class="s2">return </span><span class="s1">basePickBy(object, paths, </span><span class="s2">function</span><span class="s1">(value, path) {</span>
        <span class="s2">return </span><span class="s1">hasIn(object, path);</span>
      <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of  `_.pickBy` without support for iteratee shorthands. 
     * 
     * @private 
     * @param {Object} object The source object. 
     * @param {string[]} paths The property paths to pick. 
     * @param {Function} predicate The function invoked per property. 
     * @returns {Object} Returns the new object. 
     */</span>
    <span class="s2">function </span><span class="s1">basePickBy(object, paths, predicate) {</span>
      <span class="s2">var </span><span class="s1">index = -</span><span class="s4">1</span><span class="s1">,</span>
          <span class="s1">length = paths.length,</span>
          <span class="s1">result = {};</span>

      <span class="s2">while </span><span class="s1">(++index &lt; length) {</span>
        <span class="s2">var </span><span class="s1">path = paths[index],</span>
            <span class="s1">value = baseGet(object, path);</span>

        <span class="s2">if </span><span class="s1">(predicate(value, path)) {</span>
          <span class="s1">baseSet(result, castPath(path, object), value);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * A specialized version of `baseProperty` which supports deep paths. 
     * 
     * @private 
     * @param {Array|string} path The path of the property to get. 
     * @returns {Function} Returns the new accessor function. 
     */</span>
    <span class="s2">function </span><span class="s1">basePropertyDeep(path) {</span>
      <span class="s2">return function</span><span class="s1">(object) {</span>
        <span class="s2">return </span><span class="s1">baseGet(object, path);</span>
      <span class="s1">};</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.pullAllBy` without support for iteratee 
     * shorthands. 
     * 
     * @private 
     * @param {Array} array The array to modify. 
     * @param {Array} values The values to remove. 
     * @param {Function} [iteratee] The iteratee invoked per element. 
     * @param {Function} [comparator] The comparator invoked per element. 
     * @returns {Array} Returns `array`. 
     */</span>
    <span class="s2">function </span><span class="s1">basePullAll(array, values, iteratee, comparator) {</span>
      <span class="s2">var </span><span class="s1">indexOf = comparator ? baseIndexOfWith : baseIndexOf,</span>
          <span class="s1">index = -</span><span class="s4">1</span><span class="s1">,</span>
          <span class="s1">length = values.length,</span>
          <span class="s1">seen = array;</span>

      <span class="s2">if </span><span class="s1">(array === values) {</span>
        <span class="s1">values = copyArray(values);</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(iteratee) {</span>
        <span class="s1">seen = arrayMap(array, baseUnary(iteratee));</span>
      <span class="s1">}</span>
      <span class="s2">while </span><span class="s1">(++index &lt; length) {</span>
        <span class="s2">var </span><span class="s1">fromIndex = </span><span class="s4">0</span><span class="s1">,</span>
            <span class="s1">value = values[index],</span>
            <span class="s1">computed = iteratee ? iteratee(value) : value;</span>

        <span class="s2">while </span><span class="s1">((fromIndex = indexOf(seen, computed, fromIndex, comparator)) &gt; -</span><span class="s4">1</span><span class="s1">) {</span>
          <span class="s2">if </span><span class="s1">(seen !== array) {</span>
            <span class="s1">splice.call(seen, fromIndex, </span><span class="s4">1</span><span class="s1">);</span>
          <span class="s1">}</span>
          <span class="s1">splice.call(array, fromIndex, </span><span class="s4">1</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">array;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.pullAt` without support for individual 
     * indexes or capturing the removed elements. 
     * 
     * @private 
     * @param {Array} array The array to modify. 
     * @param {number[]} indexes The indexes of elements to remove. 
     * @returns {Array} Returns `array`. 
     */</span>
    <span class="s2">function </span><span class="s1">basePullAt(array, indexes) {</span>
      <span class="s2">var </span><span class="s1">length = array ? indexes.length : </span><span class="s4">0</span><span class="s1">,</span>
          <span class="s1">lastIndex = length - </span><span class="s4">1</span><span class="s1">;</span>

      <span class="s2">while </span><span class="s1">(length--) {</span>
        <span class="s2">var </span><span class="s1">index = indexes[length];</span>
        <span class="s2">if </span><span class="s1">(length == lastIndex || index !== previous) {</span>
          <span class="s2">var </span><span class="s1">previous = index;</span>
          <span class="s2">if </span><span class="s1">(isIndex(index)) {</span>
            <span class="s1">splice.call(array, index, </span><span class="s4">1</span><span class="s1">);</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">baseUnset(array, index);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">array;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.random` without support for returning 
     * floating-point numbers. 
     * 
     * @private 
     * @param {number} lower The lower bound. 
     * @param {number} upper The upper bound. 
     * @returns {number} Returns the random number. 
     */</span>
    <span class="s2">function </span><span class="s1">baseRandom(lower, upper) {</span>
      <span class="s2">return </span><span class="s1">lower + nativeFloor(nativeRandom() * (upper - lower + </span><span class="s4">1</span><span class="s1">));</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.range` and `_.rangeRight` which doesn't 
     * coerce arguments. 
     * 
     * @private 
     * @param {number} start The start of the range. 
     * @param {number} end The end of the range. 
     * @param {number} step The value to increment or decrement by. 
     * @param {boolean} [fromRight] Specify iterating from right to left. 
     * @returns {Array} Returns the range of numbers. 
     */</span>
    <span class="s2">function </span><span class="s1">baseRange(start, end, step, fromRight) {</span>
      <span class="s2">var </span><span class="s1">index = -</span><span class="s4">1</span><span class="s1">,</span>
          <span class="s1">length = nativeMax(nativeCeil((end - start) / (step || </span><span class="s4">1</span><span class="s1">)), </span><span class="s4">0</span><span class="s1">),</span>
          <span class="s1">result = Array(length);</span>

      <span class="s2">while </span><span class="s1">(length--) {</span>
        <span class="s1">result[fromRight ? length : ++index] = start;</span>
        <span class="s1">start += step;</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.repeat` which doesn't coerce arguments. 
     * 
     * @private 
     * @param {string} string The string to repeat. 
     * @param {number} n The number of times to repeat the string. 
     * @returns {string} Returns the repeated string. 
     */</span>
    <span class="s2">function </span><span class="s1">baseRepeat(string, n) {</span>
      <span class="s2">var </span><span class="s1">result = </span><span class="s3">''</span><span class="s1">;</span>
      <span class="s2">if </span><span class="s1">(!string || n &lt; </span><span class="s4">1 </span><span class="s1">|| n &gt; MAX_SAFE_INTEGER) {</span>
        <span class="s2">return </span><span class="s1">result;</span>
      <span class="s1">}</span>
      <span class="s0">// Leverage the exponentiation by squaring algorithm for a faster repeat.</span>
      <span class="s0">// See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.</span>
      <span class="s2">do </span><span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(n % </span><span class="s4">2</span><span class="s1">) {</span>
          <span class="s1">result += string;</span>
        <span class="s1">}</span>
        <span class="s1">n = nativeFloor(n / </span><span class="s4">2</span><span class="s1">);</span>
        <span class="s2">if </span><span class="s1">(n) {</span>
          <span class="s1">string += string;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">while </span><span class="s1">(n);</span>

      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.rest` which doesn't validate or coerce arguments. 
     * 
     * @private 
     * @param {Function} func The function to apply a rest parameter to. 
     * @param {number} [start=func.length-1] The start position of the rest parameter. 
     * @returns {Function} Returns the new function. 
     */</span>
    <span class="s2">function </span><span class="s1">baseRest(func, start) {</span>
      <span class="s2">return </span><span class="s1">setToString(overRest(func, start, identity), func + </span><span class="s3">''</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.sample`. 
     * 
     * @private 
     * @param {Array|Object} collection The collection to sample. 
     * @returns {*} Returns the random element. 
     */</span>
    <span class="s2">function </span><span class="s1">baseSample(collection) {</span>
      <span class="s2">return </span><span class="s1">arraySample(values(collection));</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.sampleSize` without param guards. 
     * 
     * @private 
     * @param {Array|Object} collection The collection to sample. 
     * @param {number} n The number of elements to sample. 
     * @returns {Array} Returns the random elements. 
     */</span>
    <span class="s2">function </span><span class="s1">baseSampleSize(collection, n) {</span>
      <span class="s2">var </span><span class="s1">array = values(collection);</span>
      <span class="s2">return </span><span class="s1">shuffleSelf(array, baseClamp(n, </span><span class="s4">0</span><span class="s1">, array.length));</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.set`. 
     * 
     * @private 
     * @param {Object} object The object to modify. 
     * @param {Array|string} path The path of the property to set. 
     * @param {*} value The value to set. 
     * @param {Function} [customizer] The function to customize path creation. 
     * @returns {Object} Returns `object`. 
     */</span>
    <span class="s2">function </span><span class="s1">baseSet(object, path, value, customizer) {</span>
      <span class="s2">if </span><span class="s1">(!isObject(object)) {</span>
        <span class="s2">return </span><span class="s1">object;</span>
      <span class="s1">}</span>
      <span class="s1">path = castPath(path, object);</span>

      <span class="s2">var </span><span class="s1">index = -</span><span class="s4">1</span><span class="s1">,</span>
          <span class="s1">length = path.length,</span>
          <span class="s1">lastIndex = length - </span><span class="s4">1</span><span class="s1">,</span>
          <span class="s1">nested = object;</span>

      <span class="s2">while </span><span class="s1">(nested != </span><span class="s2">null </span><span class="s1">&amp;&amp; ++index &lt; length) {</span>
        <span class="s2">var </span><span class="s1">key = toKey(path[index]),</span>
            <span class="s1">newValue = value;</span>

        <span class="s2">if </span><span class="s1">(key === </span><span class="s3">'__proto__' </span><span class="s1">|| key === </span><span class="s3">'constructor' </span><span class="s1">|| key === </span><span class="s3">'prototype'</span><span class="s1">) {</span>
          <span class="s2">return </span><span class="s1">object;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(index != lastIndex) {</span>
          <span class="s2">var </span><span class="s1">objValue = nested[key];</span>
          <span class="s1">newValue = customizer ? customizer(objValue, key, nested) : undefined;</span>
          <span class="s2">if </span><span class="s1">(newValue === undefined) {</span>
            <span class="s1">newValue = isObject(objValue)</span>
              <span class="s1">? objValue</span>
              <span class="s1">: (isIndex(path[index + </span><span class="s4">1</span><span class="s1">]) ? [] : {});</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">assignValue(nested, key, newValue);</span>
        <span class="s1">nested = nested[key];</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">object;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `setData` without support for hot loop shorting. 
     * 
     * @private 
     * @param {Function} func The function to associate metadata with. 
     * @param {*} data The metadata. 
     * @returns {Function} Returns `func`. 
     */</span>
    <span class="s2">var </span><span class="s1">baseSetData = !metaMap ? identity : </span><span class="s2">function</span><span class="s1">(func, data) {</span>
      <span class="s1">metaMap.set(func, data);</span>
      <span class="s2">return </span><span class="s1">func;</span>
    <span class="s1">};</span>

    <span class="s0">/** 
     * The base implementation of `setToString` without support for hot loop shorting. 
     * 
     * @private 
     * @param {Function} func The function to modify. 
     * @param {Function} string The `toString` result. 
     * @returns {Function} Returns `func`. 
     */</span>
    <span class="s2">var </span><span class="s1">baseSetToString = !defineProperty ? identity : </span><span class="s2">function</span><span class="s1">(func, string) {</span>
      <span class="s2">return </span><span class="s1">defineProperty(func, </span><span class="s3">'toString'</span><span class="s1">, {</span>
        <span class="s3">'configurable'</span><span class="s1">: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s3">'enumerable'</span><span class="s1">: </span><span class="s2">false</span><span class="s1">,</span>
        <span class="s3">'value'</span><span class="s1">: constant(string),</span>
        <span class="s3">'writable'</span><span class="s1">: </span><span class="s2">true</span>
      <span class="s1">});</span>
    <span class="s1">};</span>

    <span class="s0">/** 
     * The base implementation of `_.shuffle`. 
     * 
     * @private 
     * @param {Array|Object} collection The collection to shuffle. 
     * @returns {Array} Returns the new shuffled array. 
     */</span>
    <span class="s2">function </span><span class="s1">baseShuffle(collection) {</span>
      <span class="s2">return </span><span class="s1">shuffleSelf(values(collection));</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.slice` without an iteratee call guard. 
     * 
     * @private 
     * @param {Array} array The array to slice. 
     * @param {number} [start=0] The start position. 
     * @param {number} [end=array.length] The end position. 
     * @returns {Array} Returns the slice of `array`. 
     */</span>
    <span class="s2">function </span><span class="s1">baseSlice(array, start, end) {</span>
      <span class="s2">var </span><span class="s1">index = -</span><span class="s4">1</span><span class="s1">,</span>
          <span class="s1">length = array.length;</span>

      <span class="s2">if </span><span class="s1">(start &lt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">start = -start &gt; length ? </span><span class="s4">0 </span><span class="s1">: (length + start);</span>
      <span class="s1">}</span>
      <span class="s1">end = end &gt; length ? length : end;</span>
      <span class="s2">if </span><span class="s1">(end &lt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">end += length;</span>
      <span class="s1">}</span>
      <span class="s1">length = start &gt; end ? </span><span class="s4">0 </span><span class="s1">: ((end - start) &gt;&gt;&gt; </span><span class="s4">0</span><span class="s1">);</span>
      <span class="s1">start &gt;&gt;&gt;= </span><span class="s4">0</span><span class="s1">;</span>

      <span class="s2">var </span><span class="s1">result = Array(length);</span>
      <span class="s2">while </span><span class="s1">(++index &lt; length) {</span>
        <span class="s1">result[index] = array[index + start];</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.some` without support for iteratee shorthands. 
     * 
     * @private 
     * @param {Array|Object} collection The collection to iterate over. 
     * @param {Function} predicate The function invoked per iteration. 
     * @returns {boolean} Returns `true` if any element passes the predicate check, 
     *  else `false`. 
     */</span>
    <span class="s2">function </span><span class="s1">baseSome(collection, predicate) {</span>
      <span class="s2">var </span><span class="s1">result;</span>

      <span class="s1">baseEach(collection, </span><span class="s2">function</span><span class="s1">(value, index, collection) {</span>
        <span class="s1">result = predicate(value, index, collection);</span>
        <span class="s2">return </span><span class="s1">!result;</span>
      <span class="s1">});</span>
      <span class="s2">return </span><span class="s1">!!result;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which 
     * performs a binary search of `array` to determine the index at which `value` 
     * should be inserted into `array` in order to maintain its sort order. 
     * 
     * @private 
     * @param {Array} array The sorted array to inspect. 
     * @param {*} value The value to evaluate. 
     * @param {boolean} [retHighest] Specify returning the highest qualified index. 
     * @returns {number} Returns the index at which `value` should be inserted 
     *  into `array`. 
     */</span>
    <span class="s2">function </span><span class="s1">baseSortedIndex(array, value, retHighest) {</span>
      <span class="s2">var </span><span class="s1">low = </span><span class="s4">0</span><span class="s1">,</span>
          <span class="s1">high = array == </span><span class="s2">null </span><span class="s1">? low : array.length;</span>

      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">value == </span><span class="s3">'number' </span><span class="s1">&amp;&amp; value === value &amp;&amp; high &lt;= HALF_MAX_ARRAY_LENGTH) {</span>
        <span class="s2">while </span><span class="s1">(low &lt; high) {</span>
          <span class="s2">var </span><span class="s1">mid = (low + high) &gt;&gt;&gt; </span><span class="s4">1</span><span class="s1">,</span>
              <span class="s1">computed = array[mid];</span>

          <span class="s2">if </span><span class="s1">(computed !== </span><span class="s2">null </span><span class="s1">&amp;&amp; !isSymbol(computed) &amp;&amp;</span>
              <span class="s1">(retHighest ? (computed &lt;= value) : (computed &lt; value))) {</span>
            <span class="s1">low = mid + </span><span class="s4">1</span><span class="s1">;</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">high = mid;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">high;</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">baseSortedIndexBy(array, value, identity, retHighest);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy` 
     * which invokes `iteratee` for `value` and each element of `array` to compute 
     * their sort ranking. The iteratee is invoked with one argument; (value). 
     * 
     * @private 
     * @param {Array} array The sorted array to inspect. 
     * @param {*} value The value to evaluate. 
     * @param {Function} iteratee The iteratee invoked per element. 
     * @param {boolean} [retHighest] Specify returning the highest qualified index. 
     * @returns {number} Returns the index at which `value` should be inserted 
     *  into `array`. 
     */</span>
    <span class="s2">function </span><span class="s1">baseSortedIndexBy(array, value, iteratee, retHighest) {</span>
      <span class="s2">var </span><span class="s1">low = </span><span class="s4">0</span><span class="s1">,</span>
          <span class="s1">high = array == </span><span class="s2">null </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: array.length;</span>
      <span class="s2">if </span><span class="s1">(high === </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">value = iteratee(value);</span>
      <span class="s2">var </span><span class="s1">valIsNaN = value !== value,</span>
          <span class="s1">valIsNull = value === </span><span class="s2">null</span><span class="s1">,</span>
          <span class="s1">valIsSymbol = isSymbol(value),</span>
          <span class="s1">valIsUndefined = value === undefined;</span>

      <span class="s2">while </span><span class="s1">(low &lt; high) {</span>
        <span class="s2">var </span><span class="s1">mid = nativeFloor((low + high) / </span><span class="s4">2</span><span class="s1">),</span>
            <span class="s1">computed = iteratee(array[mid]),</span>
            <span class="s1">othIsDefined = computed !== undefined,</span>
            <span class="s1">othIsNull = computed === </span><span class="s2">null</span><span class="s1">,</span>
            <span class="s1">othIsReflexive = computed === computed,</span>
            <span class="s1">othIsSymbol = isSymbol(computed);</span>

        <span class="s2">if </span><span class="s1">(valIsNaN) {</span>
          <span class="s2">var </span><span class="s1">setLow = retHighest || othIsReflexive;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(valIsUndefined) {</span>
          <span class="s1">setLow = othIsReflexive &amp;&amp; (retHighest || othIsDefined);</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(valIsNull) {</span>
          <span class="s1">setLow = othIsReflexive &amp;&amp; othIsDefined &amp;&amp; (retHighest || !othIsNull);</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(valIsSymbol) {</span>
          <span class="s1">setLow = othIsReflexive &amp;&amp; othIsDefined &amp;&amp; !othIsNull &amp;&amp; (retHighest || !othIsSymbol);</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(othIsNull || othIsSymbol) {</span>
          <span class="s1">setLow = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">setLow = retHighest ? (computed &lt;= value) : (computed &lt; value);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(setLow) {</span>
          <span class="s1">low = mid + </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">high = mid;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">nativeMin(high, MAX_ARRAY_INDEX);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without 
     * support for iteratee shorthands. 
     * 
     * @private 
     * @param {Array} array The array to inspect. 
     * @param {Function} [iteratee] The iteratee invoked per element. 
     * @returns {Array} Returns the new duplicate free array. 
     */</span>
    <span class="s2">function </span><span class="s1">baseSortedUniq(array, iteratee) {</span>
      <span class="s2">var </span><span class="s1">index = -</span><span class="s4">1</span><span class="s1">,</span>
          <span class="s1">length = array.length,</span>
          <span class="s1">resIndex = </span><span class="s4">0</span><span class="s1">,</span>
          <span class="s1">result = [];</span>

      <span class="s2">while </span><span class="s1">(++index &lt; length) {</span>
        <span class="s2">var </span><span class="s1">value = array[index],</span>
            <span class="s1">computed = iteratee ? iteratee(value) : value;</span>

        <span class="s2">if </span><span class="s1">(!index || !eq(computed, seen)) {</span>
          <span class="s2">var </span><span class="s1">seen = computed;</span>
          <span class="s1">result[resIndex++] = value === </span><span class="s4">0 </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: value;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.toNumber` which doesn't ensure correct 
     * conversions of binary, hexadecimal, or octal string values. 
     * 
     * @private 
     * @param {*} value The value to process. 
     * @returns {number} Returns the number. 
     */</span>
    <span class="s2">function </span><span class="s1">baseToNumber(value) {</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">value == </span><span class="s3">'number'</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">value;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(isSymbol(value)) {</span>
        <span class="s2">return </span><span class="s1">NAN;</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">+value;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.toString` which doesn't convert nullish 
     * values to empty strings. 
     * 
     * @private 
     * @param {*} value The value to process. 
     * @returns {string} Returns the string. 
     */</span>
    <span class="s2">function </span><span class="s1">baseToString(value) {</span>
      <span class="s0">// Exit early for strings to avoid a performance hit in some environments.</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">value == </span><span class="s3">'string'</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">value;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(isArray(value)) {</span>
        <span class="s0">// Recursively convert values (susceptible to call stack limits).</span>
        <span class="s2">return </span><span class="s1">arrayMap(value, baseToString) + </span><span class="s3">''</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(isSymbol(value)) {</span>
        <span class="s2">return </span><span class="s1">symbolToString ? symbolToString.call(value) : </span><span class="s3">''</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">result = (value + </span><span class="s3">''</span><span class="s1">);</span>
      <span class="s2">return </span><span class="s1">(result == </span><span class="s3">'0' </span><span class="s1">&amp;&amp; (</span><span class="s4">1 </span><span class="s1">/ value) == -INFINITY) ? </span><span class="s3">'-0' </span><span class="s1">: result;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.uniqBy` without support for iteratee shorthands. 
     * 
     * @private 
     * @param {Array} array The array to inspect. 
     * @param {Function} [iteratee] The iteratee invoked per element. 
     * @param {Function} [comparator] The comparator invoked per element. 
     * @returns {Array} Returns the new duplicate free array. 
     */</span>
    <span class="s2">function </span><span class="s1">baseUniq(array, iteratee, comparator) {</span>
      <span class="s2">var </span><span class="s1">index = -</span><span class="s4">1</span><span class="s1">,</span>
          <span class="s1">includes = arrayIncludes,</span>
          <span class="s1">length = array.length,</span>
          <span class="s1">isCommon = </span><span class="s2">true</span><span class="s1">,</span>
          <span class="s1">result = [],</span>
          <span class="s1">seen = result;</span>

      <span class="s2">if </span><span class="s1">(comparator) {</span>
        <span class="s1">isCommon = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s1">includes = arrayIncludesWith;</span>
      <span class="s1">}</span>
      <span class="s2">else if </span><span class="s1">(length &gt;= LARGE_ARRAY_SIZE) {</span>
        <span class="s2">var </span><span class="s1">set = iteratee ? </span><span class="s2">null </span><span class="s1">: createSet(array);</span>
        <span class="s2">if </span><span class="s1">(set) {</span>
          <span class="s2">return </span><span class="s1">setToArray(set);</span>
        <span class="s1">}</span>
        <span class="s1">isCommon = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s1">includes = cacheHas;</span>
        <span class="s1">seen = </span><span class="s2">new </span><span class="s1">SetCache;</span>
      <span class="s1">}</span>
      <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">seen = iteratee ? [] : result;</span>
      <span class="s1">}</span>
      <span class="s1">outer:</span>
      <span class="s2">while </span><span class="s1">(++index &lt; length) {</span>
        <span class="s2">var </span><span class="s1">value = array[index],</span>
            <span class="s1">computed = iteratee ? iteratee(value) : value;</span>

        <span class="s1">value = (comparator || value !== </span><span class="s4">0</span><span class="s1">) ? value : </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(isCommon &amp;&amp; computed === computed) {</span>
          <span class="s2">var </span><span class="s1">seenIndex = seen.length;</span>
          <span class="s2">while </span><span class="s1">(seenIndex--) {</span>
            <span class="s2">if </span><span class="s1">(seen[seenIndex] === computed) {</span>
              <span class="s2">continue </span><span class="s1">outer;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
          <span class="s2">if </span><span class="s1">(iteratee) {</span>
            <span class="s1">seen.push(computed);</span>
          <span class="s1">}</span>
          <span class="s1">result.push(value);</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(!includes(seen, computed, comparator)) {</span>
          <span class="s2">if </span><span class="s1">(seen !== result) {</span>
            <span class="s1">seen.push(computed);</span>
          <span class="s1">}</span>
          <span class="s1">result.push(value);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.unset`. 
     * 
     * @private 
     * @param {Object} object The object to modify. 
     * @param {Array|string} path The property path to unset. 
     * @returns {boolean} Returns `true` if the property is deleted, else `false`. 
     */</span>
    <span class="s2">function </span><span class="s1">baseUnset(object, path) {</span>
      <span class="s1">path = castPath(path, object);</span>
      <span class="s1">object = parent(object, path);</span>
      <span class="s2">return </span><span class="s1">object == </span><span class="s2">null </span><span class="s1">|| </span><span class="s2">delete </span><span class="s1">object[toKey(last(path))];</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `_.update`. 
     * 
     * @private 
     * @param {Object} object The object to modify. 
     * @param {Array|string} path The path of the property to update. 
     * @param {Function} updater The function to produce the updated value. 
     * @param {Function} [customizer] The function to customize path creation. 
     * @returns {Object} Returns `object`. 
     */</span>
    <span class="s2">function </span><span class="s1">baseUpdate(object, path, updater, customizer) {</span>
      <span class="s2">return </span><span class="s1">baseSet(object, path, updater(baseGet(object, path)), customizer);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of methods like `_.dropWhile` and `_.takeWhile` 
     * without support for iteratee shorthands. 
     * 
     * @private 
     * @param {Array} array The array to query. 
     * @param {Function} predicate The function invoked per iteration. 
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them. 
     * @param {boolean} [fromRight] Specify iterating from right to left. 
     * @returns {Array} Returns the slice of `array`. 
     */</span>
    <span class="s2">function </span><span class="s1">baseWhile(array, predicate, isDrop, fromRight) {</span>
      <span class="s2">var </span><span class="s1">length = array.length,</span>
          <span class="s1">index = fromRight ? length : -</span><span class="s4">1</span><span class="s1">;</span>

      <span class="s2">while </span><span class="s1">((fromRight ? index-- : ++index &lt; length) &amp;&amp;</span>
        <span class="s1">predicate(array[index], index, array)) {}</span>

      <span class="s2">return </span><span class="s1">isDrop</span>
        <span class="s1">? baseSlice(array, (fromRight ? </span><span class="s4">0 </span><span class="s1">: index), (fromRight ? index + </span><span class="s4">1 </span><span class="s1">: length))</span>
        <span class="s1">: baseSlice(array, (fromRight ? index + </span><span class="s4">1 </span><span class="s1">: </span><span class="s4">0</span><span class="s1">), (fromRight ? length : index));</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of `wrapperValue` which returns the result of 
     * performing a sequence of actions on the unwrapped `value`, where each 
     * successive action is supplied the return value of the previous. 
     * 
     * @private 
     * @param {*} value The unwrapped value. 
     * @param {Array} actions Actions to perform to resolve the unwrapped value. 
     * @returns {*} Returns the resolved value. 
     */</span>
    <span class="s2">function </span><span class="s1">baseWrapperValue(value, actions) {</span>
      <span class="s2">var </span><span class="s1">result = value;</span>
      <span class="s2">if </span><span class="s1">(result </span><span class="s2">instanceof </span><span class="s1">LazyWrapper) {</span>
        <span class="s1">result = result.value();</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">arrayReduce(actions, </span><span class="s2">function</span><span class="s1">(result, action) {</span>
        <span class="s2">return </span><span class="s1">action.func.apply(action.thisArg, arrayPush([result], action.args));</span>
      <span class="s1">}, result);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The base implementation of methods like `_.xor`, without support for 
     * iteratee shorthands, that accepts an array of arrays to inspect. 
     * 
     * @private 
     * @param {Array} arrays The arrays to inspect. 
     * @param {Function} [iteratee] The iteratee invoked per element. 
     * @param {Function} [comparator] The comparator invoked per element. 
     * @returns {Array} Returns the new array of values. 
     */</span>
    <span class="s2">function </span><span class="s1">baseXor(arrays, iteratee, comparator) {</span>
      <span class="s2">var </span><span class="s1">length = arrays.length;</span>
      <span class="s2">if </span><span class="s1">(length &lt; </span><span class="s4">2</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">length ? baseUniq(arrays[</span><span class="s4">0</span><span class="s1">]) : [];</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">index = -</span><span class="s4">1</span><span class="s1">,</span>
          <span class="s1">result = Array(length);</span>

      <span class="s2">while </span><span class="s1">(++index &lt; length) {</span>
        <span class="s2">var </span><span class="s1">array = arrays[index],</span>
            <span class="s1">othIndex = -</span><span class="s4">1</span><span class="s1">;</span>

        <span class="s2">while </span><span class="s1">(++othIndex &lt; length) {</span>
          <span class="s2">if </span><span class="s1">(othIndex != index) {</span>
            <span class="s1">result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">baseUniq(baseFlatten(result, </span><span class="s4">1</span><span class="s1">), iteratee, comparator);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * This base implementation of `_.zipObject` which assigns values using `assignFunc`. 
     * 
     * @private 
     * @param {Array} props The property identifiers. 
     * @param {Array} values The property values. 
     * @param {Function} assignFunc The function to assign values. 
     * @returns {Object} Returns the new object. 
     */</span>
    <span class="s2">function </span><span class="s1">baseZipObject(props, values, assignFunc) {</span>
      <span class="s2">var </span><span class="s1">index = -</span><span class="s4">1</span><span class="s1">,</span>
          <span class="s1">length = props.length,</span>
          <span class="s1">valsLength = values.length,</span>
          <span class="s1">result = {};</span>

      <span class="s2">while </span><span class="s1">(++index &lt; length) {</span>
        <span class="s2">var </span><span class="s1">value = index &lt; valsLength ? values[index] : undefined;</span>
        <span class="s1">assignFunc(result, props[index], value);</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Casts `value` to an empty array if it's not an array like object. 
     * 
     * @private 
     * @param {*} value The value to inspect. 
     * @returns {Array|Object} Returns the cast array-like object. 
     */</span>
    <span class="s2">function </span><span class="s1">castArrayLikeObject(value) {</span>
      <span class="s2">return </span><span class="s1">isArrayLikeObject(value) ? value : [];</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Casts `value` to `identity` if it's not a function. 
     * 
     * @private 
     * @param {*} value The value to inspect. 
     * @returns {Function} Returns cast function. 
     */</span>
    <span class="s2">function </span><span class="s1">castFunction(value) {</span>
      <span class="s2">return typeof </span><span class="s1">value == </span><span class="s3">'function' </span><span class="s1">? value : identity;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Casts `value` to a path array if it's not one. 
     * 
     * @private 
     * @param {*} value The value to inspect. 
     * @param {Object} [object] The object to query keys on. 
     * @returns {Array} Returns the cast property path array. 
     */</span>
    <span class="s2">function </span><span class="s1">castPath(value, object) {</span>
      <span class="s2">if </span><span class="s1">(isArray(value)) {</span>
        <span class="s2">return </span><span class="s1">value;</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">isKey(value, object) ? [value] : stringToPath(toString(value));</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * A `baseRest` alias which can be replaced with `identity` by module 
     * replacement plugins. 
     * 
     * @private 
     * @type {Function} 
     * @param {Function} func The function to apply a rest parameter to. 
     * @returns {Function} Returns the new function. 
     */</span>
    <span class="s2">var </span><span class="s1">castRest = baseRest;</span>

    <span class="s0">/** 
     * Casts `array` to a slice if it's needed. 
     * 
     * @private 
     * @param {Array} array The array to inspect. 
     * @param {number} start The start position. 
     * @param {number} [end=array.length] The end position. 
     * @returns {Array} Returns the cast slice. 
     */</span>
    <span class="s2">function </span><span class="s1">castSlice(array, start, end) {</span>
      <span class="s2">var </span><span class="s1">length = array.length;</span>
      <span class="s1">end = end === undefined ? length : end;</span>
      <span class="s2">return </span><span class="s1">(!start &amp;&amp; end &gt;= length) ? array : baseSlice(array, start, end);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout). 
     * 
     * @private 
     * @param {number|Object} id The timer id or timeout object of the timer to clear. 
     */</span>
    <span class="s2">var </span><span class="s1">clearTimeout = ctxClearTimeout || </span><span class="s2">function</span><span class="s1">(id) {</span>
      <span class="s2">return </span><span class="s1">root.clearTimeout(id);</span>
    <span class="s1">};</span>

    <span class="s0">/** 
     * Creates a clone of  `buffer`. 
     * 
     * @private 
     * @param {Buffer} buffer The buffer to clone. 
     * @param {boolean} [isDeep] Specify a deep clone. 
     * @returns {Buffer} Returns the cloned buffer. 
     */</span>
    <span class="s2">function </span><span class="s1">cloneBuffer(buffer, isDeep) {</span>
      <span class="s2">if </span><span class="s1">(isDeep) {</span>
        <span class="s2">return </span><span class="s1">buffer.slice();</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">length = buffer.length,</span>
          <span class="s1">result = allocUnsafe ? allocUnsafe(length) : </span><span class="s2">new </span><span class="s1">buffer.constructor(length);</span>

      <span class="s1">buffer.copy(result);</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a clone of `arrayBuffer`. 
     * 
     * @private 
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone. 
     * @returns {ArrayBuffer} Returns the cloned array buffer. 
     */</span>
    <span class="s2">function </span><span class="s1">cloneArrayBuffer(arrayBuffer) {</span>
      <span class="s2">var </span><span class="s1">result = </span><span class="s2">new </span><span class="s1">arrayBuffer.constructor(arrayBuffer.byteLength);</span>
      <span class="s2">new </span><span class="s1">Uint8Array(result).set(</span><span class="s2">new </span><span class="s1">Uint8Array(arrayBuffer));</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a clone of `dataView`. 
     * 
     * @private 
     * @param {Object} dataView The data view to clone. 
     * @param {boolean} [isDeep] Specify a deep clone. 
     * @returns {Object} Returns the cloned data view. 
     */</span>
    <span class="s2">function </span><span class="s1">cloneDataView(dataView, isDeep) {</span>
      <span class="s2">var </span><span class="s1">buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;</span>
      <span class="s2">return new </span><span class="s1">dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a clone of `regexp`. 
     * 
     * @private 
     * @param {Object} regexp The regexp to clone. 
     * @returns {Object} Returns the cloned regexp. 
     */</span>
    <span class="s2">function </span><span class="s1">cloneRegExp(regexp) {</span>
      <span class="s2">var </span><span class="s1">result = </span><span class="s2">new </span><span class="s1">regexp.constructor(regexp.source, reFlags.exec(regexp));</span>
      <span class="s1">result.lastIndex = regexp.lastIndex;</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a clone of the `symbol` object. 
     * 
     * @private 
     * @param {Object} symbol The symbol object to clone. 
     * @returns {Object} Returns the cloned symbol object. 
     */</span>
    <span class="s2">function </span><span class="s1">cloneSymbol(symbol) {</span>
      <span class="s2">return </span><span class="s1">symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a clone of `typedArray`. 
     * 
     * @private 
     * @param {Object} typedArray The typed array to clone. 
     * @param {boolean} [isDeep] Specify a deep clone. 
     * @returns {Object} Returns the cloned typed array. 
     */</span>
    <span class="s2">function </span><span class="s1">cloneTypedArray(typedArray, isDeep) {</span>
      <span class="s2">var </span><span class="s1">buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;</span>
      <span class="s2">return new </span><span class="s1">typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Compares values to sort them in ascending order. 
     * 
     * @private 
     * @param {*} value The value to compare. 
     * @param {*} other The other value to compare. 
     * @returns {number} Returns the sort order indicator for `value`. 
     */</span>
    <span class="s2">function </span><span class="s1">compareAscending(value, other) {</span>
      <span class="s2">if </span><span class="s1">(value !== other) {</span>
        <span class="s2">var </span><span class="s1">valIsDefined = value !== undefined,</span>
            <span class="s1">valIsNull = value === </span><span class="s2">null</span><span class="s1">,</span>
            <span class="s1">valIsReflexive = value === value,</span>
            <span class="s1">valIsSymbol = isSymbol(value);</span>

        <span class="s2">var </span><span class="s1">othIsDefined = other !== undefined,</span>
            <span class="s1">othIsNull = other === </span><span class="s2">null</span><span class="s1">,</span>
            <span class="s1">othIsReflexive = other === other,</span>
            <span class="s1">othIsSymbol = isSymbol(other);</span>

        <span class="s2">if </span><span class="s1">((!othIsNull &amp;&amp; !othIsSymbol &amp;&amp; !valIsSymbol &amp;&amp; value &gt; other) ||</span>
            <span class="s1">(valIsSymbol &amp;&amp; othIsDefined &amp;&amp; othIsReflexive &amp;&amp; !othIsNull &amp;&amp; !othIsSymbol) ||</span>
            <span class="s1">(valIsNull &amp;&amp; othIsDefined &amp;&amp; othIsReflexive) ||</span>
            <span class="s1">(!valIsDefined &amp;&amp; othIsReflexive) ||</span>
            <span class="s1">!valIsReflexive) {</span>
          <span class="s2">return </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">((!valIsNull &amp;&amp; !valIsSymbol &amp;&amp; !othIsSymbol &amp;&amp; value &lt; other) ||</span>
            <span class="s1">(othIsSymbol &amp;&amp; valIsDefined &amp;&amp; valIsReflexive &amp;&amp; !valIsNull &amp;&amp; !valIsSymbol) ||</span>
            <span class="s1">(othIsNull &amp;&amp; valIsDefined &amp;&amp; valIsReflexive) ||</span>
            <span class="s1">(!othIsDefined &amp;&amp; valIsReflexive) ||</span>
            <span class="s1">!othIsReflexive) {</span>
          <span class="s2">return </span><span class="s1">-</span><span class="s4">1</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Used by `_.orderBy` to compare multiple properties of a value to another 
     * and stable sort them. 
     * 
     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise, 
     * specify an order of &quot;desc&quot; for descending or &quot;asc&quot; for ascending sort order 
     * of corresponding values. 
     * 
     * @private 
     * @param {Object} object The object to compare. 
     * @param {Object} other The other object to compare. 
     * @param {boolean[]|string[]} orders The order to sort by for each property. 
     * @returns {number} Returns the sort order indicator for `object`. 
     */</span>
    <span class="s2">function </span><span class="s1">compareMultiple(object, other, orders) {</span>
      <span class="s2">var </span><span class="s1">index = -</span><span class="s4">1</span><span class="s1">,</span>
          <span class="s1">objCriteria = object.criteria,</span>
          <span class="s1">othCriteria = other.criteria,</span>
          <span class="s1">length = objCriteria.length,</span>
          <span class="s1">ordersLength = orders.length;</span>

      <span class="s2">while </span><span class="s1">(++index &lt; length) {</span>
        <span class="s2">var </span><span class="s1">result = compareAscending(objCriteria[index], othCriteria[index]);</span>
        <span class="s2">if </span><span class="s1">(result) {</span>
          <span class="s2">if </span><span class="s1">(index &gt;= ordersLength) {</span>
            <span class="s2">return </span><span class="s1">result;</span>
          <span class="s1">}</span>
          <span class="s2">var </span><span class="s1">order = orders[index];</span>
          <span class="s2">return </span><span class="s1">result * (order == </span><span class="s3">'desc' </span><span class="s1">? -</span><span class="s4">1 </span><span class="s1">: </span><span class="s4">1</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">// Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications</span>
      <span class="s0">// that causes it, under certain circumstances, to provide the same value for</span>
      <span class="s0">// `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247</span>
      <span class="s0">// for more details.</span>
      <span class="s0">//</span>
      <span class="s0">// This also ensures a stable sort in V8 and other engines.</span>
      <span class="s0">// See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.</span>
      <span class="s2">return </span><span class="s1">object.index - other.index;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates an array that is the composition of partially applied arguments, 
     * placeholders, and provided arguments into a single array of arguments. 
     * 
     * @private 
     * @param {Array} args The provided arguments. 
     * @param {Array} partials The arguments to prepend to those provided. 
     * @param {Array} holders The `partials` placeholder indexes. 
     * @params {boolean} [isCurried] Specify composing for a curried function. 
     * @returns {Array} Returns the new array of composed arguments. 
     */</span>
    <span class="s2">function </span><span class="s1">composeArgs(args, partials, holders, isCurried) {</span>
      <span class="s2">var </span><span class="s1">argsIndex = -</span><span class="s4">1</span><span class="s1">,</span>
          <span class="s1">argsLength = args.length,</span>
          <span class="s1">holdersLength = holders.length,</span>
          <span class="s1">leftIndex = -</span><span class="s4">1</span><span class="s1">,</span>
          <span class="s1">leftLength = partials.length,</span>
          <span class="s1">rangeLength = nativeMax(argsLength - holdersLength, </span><span class="s4">0</span><span class="s1">),</span>
          <span class="s1">result = Array(leftLength + rangeLength),</span>
          <span class="s1">isUncurried = !isCurried;</span>

      <span class="s2">while </span><span class="s1">(++leftIndex &lt; leftLength) {</span>
        <span class="s1">result[leftIndex] = partials[leftIndex];</span>
      <span class="s1">}</span>
      <span class="s2">while </span><span class="s1">(++argsIndex &lt; holdersLength) {</span>
        <span class="s2">if </span><span class="s1">(isUncurried || argsIndex &lt; argsLength) {</span>
          <span class="s1">result[holders[argsIndex]] = args[argsIndex];</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">while </span><span class="s1">(rangeLength--) {</span>
        <span class="s1">result[leftIndex++] = args[argsIndex++];</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * This function is like `composeArgs` except that the arguments composition 
     * is tailored for `_.partialRight`. 
     * 
     * @private 
     * @param {Array} args The provided arguments. 
     * @param {Array} partials The arguments to append to those provided. 
     * @param {Array} holders The `partials` placeholder indexes. 
     * @params {boolean} [isCurried] Specify composing for a curried function. 
     * @returns {Array} Returns the new array of composed arguments. 
     */</span>
    <span class="s2">function </span><span class="s1">composeArgsRight(args, partials, holders, isCurried) {</span>
      <span class="s2">var </span><span class="s1">argsIndex = -</span><span class="s4">1</span><span class="s1">,</span>
          <span class="s1">argsLength = args.length,</span>
          <span class="s1">holdersIndex = -</span><span class="s4">1</span><span class="s1">,</span>
          <span class="s1">holdersLength = holders.length,</span>
          <span class="s1">rightIndex = -</span><span class="s4">1</span><span class="s1">,</span>
          <span class="s1">rightLength = partials.length,</span>
          <span class="s1">rangeLength = nativeMax(argsLength - holdersLength, </span><span class="s4">0</span><span class="s1">),</span>
          <span class="s1">result = Array(rangeLength + rightLength),</span>
          <span class="s1">isUncurried = !isCurried;</span>

      <span class="s2">while </span><span class="s1">(++argsIndex &lt; rangeLength) {</span>
        <span class="s1">result[argsIndex] = args[argsIndex];</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">offset = argsIndex;</span>
      <span class="s2">while </span><span class="s1">(++rightIndex &lt; rightLength) {</span>
        <span class="s1">result[offset + rightIndex] = partials[rightIndex];</span>
      <span class="s1">}</span>
      <span class="s2">while </span><span class="s1">(++holdersIndex &lt; holdersLength) {</span>
        <span class="s2">if </span><span class="s1">(isUncurried || argsIndex &lt; argsLength) {</span>
          <span class="s1">result[offset + holders[holdersIndex]] = args[argsIndex++];</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Copies the values of `source` to `array`. 
     * 
     * @private 
     * @param {Array} source The array to copy values from. 
     * @param {Array} [array=[]] The array to copy values to. 
     * @returns {Array} Returns `array`. 
     */</span>
    <span class="s2">function </span><span class="s1">copyArray(source, array) {</span>
      <span class="s2">var </span><span class="s1">index = -</span><span class="s4">1</span><span class="s1">,</span>
          <span class="s1">length = source.length;</span>

      <span class="s1">array || (array = Array(length));</span>
      <span class="s2">while </span><span class="s1">(++index &lt; length) {</span>
        <span class="s1">array[index] = source[index];</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">array;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Copies properties of `source` to `object`. 
     * 
     * @private 
     * @param {Object} source The object to copy properties from. 
     * @param {Array} props The property identifiers to copy. 
     * @param {Object} [object={}] The object to copy properties to. 
     * @param {Function} [customizer] The function to customize copied values. 
     * @returns {Object} Returns `object`. 
     */</span>
    <span class="s2">function </span><span class="s1">copyObject(source, props, object, customizer) {</span>
      <span class="s2">var </span><span class="s1">isNew = !object;</span>
      <span class="s1">object || (object = {});</span>

      <span class="s2">var </span><span class="s1">index = -</span><span class="s4">1</span><span class="s1">,</span>
          <span class="s1">length = props.length;</span>

      <span class="s2">while </span><span class="s1">(++index &lt; length) {</span>
        <span class="s2">var </span><span class="s1">key = props[index];</span>

        <span class="s2">var </span><span class="s1">newValue = customizer</span>
          <span class="s1">? customizer(object[key], source[key], key, object, source)</span>
          <span class="s1">: undefined;</span>

        <span class="s2">if </span><span class="s1">(newValue === undefined) {</span>
          <span class="s1">newValue = source[key];</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(isNew) {</span>
          <span class="s1">baseAssignValue(object, key, newValue);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">assignValue(object, key, newValue);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">object;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Copies own symbols of `source` to `object`. 
     * 
     * @private 
     * @param {Object} source The object to copy symbols from. 
     * @param {Object} [object={}] The object to copy symbols to. 
     * @returns {Object} Returns `object`. 
     */</span>
    <span class="s2">function </span><span class="s1">copySymbols(source, object) {</span>
      <span class="s2">return </span><span class="s1">copyObject(source, getSymbols(source), object);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Copies own and inherited symbols of `source` to `object`. 
     * 
     * @private 
     * @param {Object} source The object to copy symbols from. 
     * @param {Object} [object={}] The object to copy symbols to. 
     * @returns {Object} Returns `object`. 
     */</span>
    <span class="s2">function </span><span class="s1">copySymbolsIn(source, object) {</span>
      <span class="s2">return </span><span class="s1">copyObject(source, getSymbolsIn(source), object);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a function like `_.groupBy`. 
     * 
     * @private 
     * @param {Function} setter The function to set accumulator values. 
     * @param {Function} [initializer] The accumulator object initializer. 
     * @returns {Function} Returns the new aggregator function. 
     */</span>
    <span class="s2">function </span><span class="s1">createAggregator(setter, initializer) {</span>
      <span class="s2">return function</span><span class="s1">(collection, iteratee) {</span>
        <span class="s2">var </span><span class="s1">func = isArray(collection) ? arrayAggregator : baseAggregator,</span>
            <span class="s1">accumulator = initializer ? initializer() : {};</span>

        <span class="s2">return </span><span class="s1">func(collection, setter, getIteratee(iteratee, </span><span class="s4">2</span><span class="s1">), accumulator);</span>
      <span class="s1">};</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a function like `_.assign`. 
     * 
     * @private 
     * @param {Function} assigner The function to assign values. 
     * @returns {Function} Returns the new assigner function. 
     */</span>
    <span class="s2">function </span><span class="s1">createAssigner(assigner) {</span>
      <span class="s2">return </span><span class="s1">baseRest(</span><span class="s2">function</span><span class="s1">(object, sources) {</span>
        <span class="s2">var </span><span class="s1">index = -</span><span class="s4">1</span><span class="s1">,</span>
            <span class="s1">length = sources.length,</span>
            <span class="s1">customizer = length &gt; </span><span class="s4">1 </span><span class="s1">? sources[length - </span><span class="s4">1</span><span class="s1">] : undefined,</span>
            <span class="s1">guard = length &gt; </span><span class="s4">2 </span><span class="s1">? sources[</span><span class="s4">2</span><span class="s1">] : undefined;</span>

        <span class="s1">customizer = (assigner.length &gt; </span><span class="s4">3 </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">customizer == </span><span class="s3">'function'</span><span class="s1">)</span>
          <span class="s1">? (length--, customizer)</span>
          <span class="s1">: undefined;</span>

        <span class="s2">if </span><span class="s1">(guard &amp;&amp; isIterateeCall(sources[</span><span class="s4">0</span><span class="s1">], sources[</span><span class="s4">1</span><span class="s1">], guard)) {</span>
          <span class="s1">customizer = length &lt; </span><span class="s4">3 </span><span class="s1">? undefined : customizer;</span>
          <span class="s1">length = </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">object = Object(object);</span>
        <span class="s2">while </span><span class="s1">(++index &lt; length) {</span>
          <span class="s2">var </span><span class="s1">source = sources[index];</span>
          <span class="s2">if </span><span class="s1">(source) {</span>
            <span class="s1">assigner(object, source, index, customizer);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">object;</span>
      <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a `baseEach` or `baseEachRight` function. 
     * 
     * @private 
     * @param {Function} eachFunc The function to iterate over a collection. 
     * @param {boolean} [fromRight] Specify iterating from right to left. 
     * @returns {Function} Returns the new base function. 
     */</span>
    <span class="s2">function </span><span class="s1">createBaseEach(eachFunc, fromRight) {</span>
      <span class="s2">return function</span><span class="s1">(collection, iteratee) {</span>
        <span class="s2">if </span><span class="s1">(collection == </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s2">return </span><span class="s1">collection;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(!isArrayLike(collection)) {</span>
          <span class="s2">return </span><span class="s1">eachFunc(collection, iteratee);</span>
        <span class="s1">}</span>
        <span class="s2">var </span><span class="s1">length = collection.length,</span>
            <span class="s1">index = fromRight ? length : -</span><span class="s4">1</span><span class="s1">,</span>
            <span class="s1">iterable = Object(collection);</span>

        <span class="s2">while </span><span class="s1">((fromRight ? index-- : ++index &lt; length)) {</span>
          <span class="s2">if </span><span class="s1">(iteratee(iterable[index], index, iterable) === </span><span class="s2">false</span><span class="s1">) {</span>
            <span class="s2">break</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">collection;</span>
      <span class="s1">};</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a base function for methods like `_.forIn` and `_.forOwn`. 
     * 
     * @private 
     * @param {boolean} [fromRight] Specify iterating from right to left. 
     * @returns {Function} Returns the new base function. 
     */</span>
    <span class="s2">function </span><span class="s1">createBaseFor(fromRight) {</span>
      <span class="s2">return function</span><span class="s1">(object, iteratee, keysFunc) {</span>
        <span class="s2">var </span><span class="s1">index = -</span><span class="s4">1</span><span class="s1">,</span>
            <span class="s1">iterable = Object(object),</span>
            <span class="s1">props = keysFunc(object),</span>
            <span class="s1">length = props.length;</span>

        <span class="s2">while </span><span class="s1">(length--) {</span>
          <span class="s2">var </span><span class="s1">key = props[fromRight ? length : ++index];</span>
          <span class="s2">if </span><span class="s1">(iteratee(iterable[key], key, iterable) === </span><span class="s2">false</span><span class="s1">) {</span>
            <span class="s2">break</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">object;</span>
      <span class="s1">};</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a function that wraps `func` to invoke it with the optional `this` 
     * binding of `thisArg`. 
     * 
     * @private 
     * @param {Function} func The function to wrap. 
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details. 
     * @param {*} [thisArg] The `this` binding of `func`. 
     * @returns {Function} Returns the new wrapped function. 
     */</span>
    <span class="s2">function </span><span class="s1">createBind(func, bitmask, thisArg) {</span>
      <span class="s2">var </span><span class="s1">isBind = bitmask &amp; WRAP_BIND_FLAG,</span>
          <span class="s1">Ctor = createCtor(func);</span>

      <span class="s2">function </span><span class="s1">wrapper() {</span>
        <span class="s2">var </span><span class="s1">fn = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this </span><span class="s1">!== root &amp;&amp; </span><span class="s2">this instanceof </span><span class="s1">wrapper) ? Ctor : func;</span>
        <span class="s2">return </span><span class="s1">fn.apply(isBind ? thisArg : </span><span class="s2">this</span><span class="s1">, arguments);</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">wrapper;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a function like `_.lowerFirst`. 
     * 
     * @private 
     * @param {string} methodName The name of the `String` case method to use. 
     * @returns {Function} Returns the new case function. 
     */</span>
    <span class="s2">function </span><span class="s1">createCaseFirst(methodName) {</span>
      <span class="s2">return function</span><span class="s1">(string) {</span>
        <span class="s1">string = toString(string);</span>

        <span class="s2">var </span><span class="s1">strSymbols = hasUnicode(string)</span>
          <span class="s1">? stringToArray(string)</span>
          <span class="s1">: undefined;</span>

        <span class="s2">var </span><span class="s1">chr = strSymbols</span>
          <span class="s1">? strSymbols[</span><span class="s4">0</span><span class="s1">]</span>
          <span class="s1">: string.charAt(</span><span class="s4">0</span><span class="s1">);</span>

        <span class="s2">var </span><span class="s1">trailing = strSymbols</span>
          <span class="s1">? castSlice(strSymbols, </span><span class="s4">1</span><span class="s1">).join(</span><span class="s3">''</span><span class="s1">)</span>
          <span class="s1">: string.slice(</span><span class="s4">1</span><span class="s1">);</span>

        <span class="s2">return </span><span class="s1">chr[methodName]() + trailing;</span>
      <span class="s1">};</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a function like `_.camelCase`. 
     * 
     * @private 
     * @param {Function} callback The function to combine each word. 
     * @returns {Function} Returns the new compounder function. 
     */</span>
    <span class="s2">function </span><span class="s1">createCompounder(callback) {</span>
      <span class="s2">return function</span><span class="s1">(string) {</span>
        <span class="s2">return </span><span class="s1">arrayReduce(words(deburr(string).replace(reApos, </span><span class="s3">''</span><span class="s1">)), callback, </span><span class="s3">''</span><span class="s1">);</span>
      <span class="s1">};</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a function that produces an instance of `Ctor` regardless of 
     * whether it was invoked as part of a `new` expression or by `call` or `apply`. 
     * 
     * @private 
     * @param {Function} Ctor The constructor to wrap. 
     * @returns {Function} Returns the new wrapped function. 
     */</span>
    <span class="s2">function </span><span class="s1">createCtor(Ctor) {</span>
      <span class="s2">return function</span><span class="s1">() {</span>
        <span class="s0">// Use a `switch` statement to work with class constructors. See</span>
        <span class="s0">// http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist</span>
        <span class="s0">// for more details.</span>
        <span class="s2">var </span><span class="s1">args = arguments;</span>
        <span class="s2">switch </span><span class="s1">(args.length) {</span>
          <span class="s2">case </span><span class="s4">0</span><span class="s1">: </span><span class="s2">return new </span><span class="s1">Ctor;</span>
          <span class="s2">case </span><span class="s4">1</span><span class="s1">: </span><span class="s2">return new </span><span class="s1">Ctor(args[</span><span class="s4">0</span><span class="s1">]);</span>
          <span class="s2">case </span><span class="s4">2</span><span class="s1">: </span><span class="s2">return new </span><span class="s1">Ctor(args[</span><span class="s4">0</span><span class="s1">], args[</span><span class="s4">1</span><span class="s1">]);</span>
          <span class="s2">case </span><span class="s4">3</span><span class="s1">: </span><span class="s2">return new </span><span class="s1">Ctor(args[</span><span class="s4">0</span><span class="s1">], args[</span><span class="s4">1</span><span class="s1">], args[</span><span class="s4">2</span><span class="s1">]);</span>
          <span class="s2">case </span><span class="s4">4</span><span class="s1">: </span><span class="s2">return new </span><span class="s1">Ctor(args[</span><span class="s4">0</span><span class="s1">], args[</span><span class="s4">1</span><span class="s1">], args[</span><span class="s4">2</span><span class="s1">], args[</span><span class="s4">3</span><span class="s1">]);</span>
          <span class="s2">case </span><span class="s4">5</span><span class="s1">: </span><span class="s2">return new </span><span class="s1">Ctor(args[</span><span class="s4">0</span><span class="s1">], args[</span><span class="s4">1</span><span class="s1">], args[</span><span class="s4">2</span><span class="s1">], args[</span><span class="s4">3</span><span class="s1">], args[</span><span class="s4">4</span><span class="s1">]);</span>
          <span class="s2">case </span><span class="s4">6</span><span class="s1">: </span><span class="s2">return new </span><span class="s1">Ctor(args[</span><span class="s4">0</span><span class="s1">], args[</span><span class="s4">1</span><span class="s1">], args[</span><span class="s4">2</span><span class="s1">], args[</span><span class="s4">3</span><span class="s1">], args[</span><span class="s4">4</span><span class="s1">], args[</span><span class="s4">5</span><span class="s1">]);</span>
          <span class="s2">case </span><span class="s4">7</span><span class="s1">: </span><span class="s2">return new </span><span class="s1">Ctor(args[</span><span class="s4">0</span><span class="s1">], args[</span><span class="s4">1</span><span class="s1">], args[</span><span class="s4">2</span><span class="s1">], args[</span><span class="s4">3</span><span class="s1">], args[</span><span class="s4">4</span><span class="s1">], args[</span><span class="s4">5</span><span class="s1">], args[</span><span class="s4">6</span><span class="s1">]);</span>
        <span class="s1">}</span>
        <span class="s2">var </span><span class="s1">thisBinding = baseCreate(Ctor.prototype),</span>
            <span class="s1">result = Ctor.apply(thisBinding, args);</span>

        <span class="s0">// Mimic the constructor's `return` behavior.</span>
        <span class="s0">// See https://es5.github.io/#x13.2.2 for more details.</span>
        <span class="s2">return </span><span class="s1">isObject(result) ? result : thisBinding;</span>
      <span class="s1">};</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a function that wraps `func` to enable currying. 
     * 
     * @private 
     * @param {Function} func The function to wrap. 
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details. 
     * @param {number} arity The arity of `func`. 
     * @returns {Function} Returns the new wrapped function. 
     */</span>
    <span class="s2">function </span><span class="s1">createCurry(func, bitmask, arity) {</span>
      <span class="s2">var </span><span class="s1">Ctor = createCtor(func);</span>

      <span class="s2">function </span><span class="s1">wrapper() {</span>
        <span class="s2">var </span><span class="s1">length = arguments.length,</span>
            <span class="s1">args = Array(length),</span>
            <span class="s1">index = length,</span>
            <span class="s1">placeholder = getHolder(wrapper);</span>

        <span class="s2">while </span><span class="s1">(index--) {</span>
          <span class="s1">args[index] = arguments[index];</span>
        <span class="s1">}</span>
        <span class="s2">var </span><span class="s1">holders = (length &lt; </span><span class="s4">3 </span><span class="s1">&amp;&amp; args[</span><span class="s4">0</span><span class="s1">] !== placeholder &amp;&amp; args[length - </span><span class="s4">1</span><span class="s1">] !== placeholder)</span>
          <span class="s1">? []</span>
          <span class="s1">: replaceHolders(args, placeholder);</span>

        <span class="s1">length -= holders.length;</span>
        <span class="s2">if </span><span class="s1">(length &lt; arity) {</span>
          <span class="s2">return </span><span class="s1">createRecurry(</span>
            <span class="s1">func, bitmask, createHybrid, wrapper.placeholder, undefined,</span>
            <span class="s1">args, holders, undefined, undefined, arity - length);</span>
        <span class="s1">}</span>
        <span class="s2">var </span><span class="s1">fn = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this </span><span class="s1">!== root &amp;&amp; </span><span class="s2">this instanceof </span><span class="s1">wrapper) ? Ctor : func;</span>
        <span class="s2">return </span><span class="s1">apply(fn, </span><span class="s2">this</span><span class="s1">, args);</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">wrapper;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a `_.find` or `_.findLast` function. 
     * 
     * @private 
     * @param {Function} findIndexFunc The function to find the collection index. 
     * @returns {Function} Returns the new find function. 
     */</span>
    <span class="s2">function </span><span class="s1">createFind(findIndexFunc) {</span>
      <span class="s2">return function</span><span class="s1">(collection, predicate, fromIndex) {</span>
        <span class="s2">var </span><span class="s1">iterable = Object(collection);</span>
        <span class="s2">if </span><span class="s1">(!isArrayLike(collection)) {</span>
          <span class="s2">var </span><span class="s1">iteratee = getIteratee(predicate, </span><span class="s4">3</span><span class="s1">);</span>
          <span class="s1">collection = keys(collection);</span>
          <span class="s1">predicate = </span><span class="s2">function</span><span class="s1">(key) { </span><span class="s2">return </span><span class="s1">iteratee(iterable[key], key, iterable); };</span>
        <span class="s1">}</span>
        <span class="s2">var </span><span class="s1">index = findIndexFunc(collection, predicate, fromIndex);</span>
        <span class="s2">return </span><span class="s1">index &gt; -</span><span class="s4">1 </span><span class="s1">? iterable[iteratee ? collection[index] : index] : undefined;</span>
      <span class="s1">};</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a `_.flow` or `_.flowRight` function. 
     * 
     * @private 
     * @param {boolean} [fromRight] Specify iterating from right to left. 
     * @returns {Function} Returns the new flow function. 
     */</span>
    <span class="s2">function </span><span class="s1">createFlow(fromRight) {</span>
      <span class="s2">return </span><span class="s1">flatRest(</span><span class="s2">function</span><span class="s1">(funcs) {</span>
        <span class="s2">var </span><span class="s1">length = funcs.length,</span>
            <span class="s1">index = length,</span>
            <span class="s1">prereq = LodashWrapper.prototype.thru;</span>

        <span class="s2">if </span><span class="s1">(fromRight) {</span>
          <span class="s1">funcs.reverse();</span>
        <span class="s1">}</span>
        <span class="s2">while </span><span class="s1">(index--) {</span>
          <span class="s2">var </span><span class="s1">func = funcs[index];</span>
          <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">func != </span><span class="s3">'function'</span><span class="s1">) {</span>
            <span class="s2">throw new </span><span class="s1">TypeError(FUNC_ERROR_TEXT);</span>
          <span class="s1">}</span>
          <span class="s2">if </span><span class="s1">(prereq &amp;&amp; !wrapper &amp;&amp; getFuncName(func) == </span><span class="s3">'wrapper'</span><span class="s1">) {</span>
            <span class="s2">var </span><span class="s1">wrapper = </span><span class="s2">new </span><span class="s1">LodashWrapper([], </span><span class="s2">true</span><span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">index = wrapper ? index : length;</span>
        <span class="s2">while </span><span class="s1">(++index &lt; length) {</span>
          <span class="s1">func = funcs[index];</span>

          <span class="s2">var </span><span class="s1">funcName = getFuncName(func),</span>
              <span class="s1">data = funcName == </span><span class="s3">'wrapper' </span><span class="s1">? getData(func) : undefined;</span>

          <span class="s2">if </span><span class="s1">(data &amp;&amp; isLaziable(data[</span><span class="s4">0</span><span class="s1">]) &amp;&amp;</span>
                <span class="s1">data[</span><span class="s4">1</span><span class="s1">] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &amp;&amp;</span>
                <span class="s1">!data[</span><span class="s4">4</span><span class="s1">].length &amp;&amp; data[</span><span class="s4">9</span><span class="s1">] == </span><span class="s4">1</span>
              <span class="s1">) {</span>
            <span class="s1">wrapper = wrapper[getFuncName(data[</span><span class="s4">0</span><span class="s1">])].apply(wrapper, data[</span><span class="s4">3</span><span class="s1">]);</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">wrapper = (func.length == </span><span class="s4">1 </span><span class="s1">&amp;&amp; isLaziable(func))</span>
              <span class="s1">? wrapper[funcName]()</span>
              <span class="s1">: wrapper.thru(func);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return function</span><span class="s1">() {</span>
          <span class="s2">var </span><span class="s1">args = arguments,</span>
              <span class="s1">value = args[</span><span class="s4">0</span><span class="s1">];</span>

          <span class="s2">if </span><span class="s1">(wrapper &amp;&amp; args.length == </span><span class="s4">1 </span><span class="s1">&amp;&amp; isArray(value)) {</span>
            <span class="s2">return </span><span class="s1">wrapper.plant(value).value();</span>
          <span class="s1">}</span>
          <span class="s2">var </span><span class="s1">index = </span><span class="s4">0</span><span class="s1">,</span>
              <span class="s1">result = length ? funcs[index].apply(</span><span class="s2">this</span><span class="s1">, args) : value;</span>

          <span class="s2">while </span><span class="s1">(++index &lt; length) {</span>
            <span class="s1">result = funcs[index].call(</span><span class="s2">this</span><span class="s1">, result);</span>
          <span class="s1">}</span>
          <span class="s2">return </span><span class="s1">result;</span>
        <span class="s1">};</span>
      <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a function that wraps `func` to invoke it with optional `this` 
     * binding of `thisArg`, partial application, and currying. 
     * 
     * @private 
     * @param {Function|string} func The function or method name to wrap. 
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details. 
     * @param {*} [thisArg] The `this` binding of `func`. 
     * @param {Array} [partials] The arguments to prepend to those provided to 
     *  the new function. 
     * @param {Array} [holders] The `partials` placeholder indexes. 
     * @param {Array} [partialsRight] The arguments to append to those provided 
     *  to the new function. 
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes. 
     * @param {Array} [argPos] The argument positions of the new function. 
     * @param {number} [ary] The arity cap of `func`. 
     * @param {number} [arity] The arity of `func`. 
     * @returns {Function} Returns the new wrapped function. 
     */</span>
    <span class="s2">function </span><span class="s1">createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {</span>
      <span class="s2">var </span><span class="s1">isAry = bitmask &amp; WRAP_ARY_FLAG,</span>
          <span class="s1">isBind = bitmask &amp; WRAP_BIND_FLAG,</span>
          <span class="s1">isBindKey = bitmask &amp; WRAP_BIND_KEY_FLAG,</span>
          <span class="s1">isCurried = bitmask &amp; (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),</span>
          <span class="s1">isFlip = bitmask &amp; WRAP_FLIP_FLAG,</span>
          <span class="s1">Ctor = isBindKey ? undefined : createCtor(func);</span>

      <span class="s2">function </span><span class="s1">wrapper() {</span>
        <span class="s2">var </span><span class="s1">length = arguments.length,</span>
            <span class="s1">args = Array(length),</span>
            <span class="s1">index = length;</span>

        <span class="s2">while </span><span class="s1">(index--) {</span>
          <span class="s1">args[index] = arguments[index];</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(isCurried) {</span>
          <span class="s2">var </span><span class="s1">placeholder = getHolder(wrapper),</span>
              <span class="s1">holdersCount = countHolders(args, placeholder);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(partials) {</span>
          <span class="s1">args = composeArgs(args, partials, holders, isCurried);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(partialsRight) {</span>
          <span class="s1">args = composeArgsRight(args, partialsRight, holdersRight, isCurried);</span>
        <span class="s1">}</span>
        <span class="s1">length -= holdersCount;</span>
        <span class="s2">if </span><span class="s1">(isCurried &amp;&amp; length &lt; arity) {</span>
          <span class="s2">var </span><span class="s1">newHolders = replaceHolders(args, placeholder);</span>
          <span class="s2">return </span><span class="s1">createRecurry(</span>
            <span class="s1">func, bitmask, createHybrid, wrapper.placeholder, thisArg,</span>
            <span class="s1">args, newHolders, argPos, ary, arity - length</span>
          <span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">var </span><span class="s1">thisBinding = isBind ? thisArg : </span><span class="s2">this</span><span class="s1">,</span>
            <span class="s1">fn = isBindKey ? thisBinding[func] : func;</span>

        <span class="s1">length = args.length;</span>
        <span class="s2">if </span><span class="s1">(argPos) {</span>
          <span class="s1">args = reorder(args, argPos);</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isFlip &amp;&amp; length &gt; </span><span class="s4">1</span><span class="s1">) {</span>
          <span class="s1">args.reverse();</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(isAry &amp;&amp; ary &lt; length) {</span>
          <span class="s1">args.length = ary;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this </span><span class="s1">!== root &amp;&amp; </span><span class="s2">this instanceof </span><span class="s1">wrapper) {</span>
          <span class="s1">fn = Ctor || createCtor(fn);</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">fn.apply(thisBinding, args);</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">wrapper;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a function like `_.invertBy`. 
     * 
     * @private 
     * @param {Function} setter The function to set accumulator values. 
     * @param {Function} toIteratee The function to resolve iteratees. 
     * @returns {Function} Returns the new inverter function. 
     */</span>
    <span class="s2">function </span><span class="s1">createInverter(setter, toIteratee) {</span>
      <span class="s2">return function</span><span class="s1">(object, iteratee) {</span>
        <span class="s2">return </span><span class="s1">baseInverter(object, setter, toIteratee(iteratee), {});</span>
      <span class="s1">};</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a function that performs a mathematical operation on two values. 
     * 
     * @private 
     * @param {Function} operator The function to perform the operation. 
     * @param {number} [defaultValue] The value used for `undefined` arguments. 
     * @returns {Function} Returns the new mathematical operation function. 
     */</span>
    <span class="s2">function </span><span class="s1">createMathOperation(operator, defaultValue) {</span>
      <span class="s2">return function</span><span class="s1">(value, other) {</span>
        <span class="s2">var </span><span class="s1">result;</span>
        <span class="s2">if </span><span class="s1">(value === undefined &amp;&amp; other === undefined) {</span>
          <span class="s2">return </span><span class="s1">defaultValue;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(value !== undefined) {</span>
          <span class="s1">result = value;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(other !== undefined) {</span>
          <span class="s2">if </span><span class="s1">(result === undefined) {</span>
            <span class="s2">return </span><span class="s1">other;</span>
          <span class="s1">}</span>
          <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">value == </span><span class="s3">'string' </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">other == </span><span class="s3">'string'</span><span class="s1">) {</span>
            <span class="s1">value = baseToString(value);</span>
            <span class="s1">other = baseToString(other);</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">value = baseToNumber(value);</span>
            <span class="s1">other = baseToNumber(other);</span>
          <span class="s1">}</span>
          <span class="s1">result = operator(value, other);</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">result;</span>
      <span class="s1">};</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a function like `_.over`. 
     * 
     * @private 
     * @param {Function} arrayFunc The function to iterate over iteratees. 
     * @returns {Function} Returns the new over function. 
     */</span>
    <span class="s2">function </span><span class="s1">createOver(arrayFunc) {</span>
      <span class="s2">return </span><span class="s1">flatRest(</span><span class="s2">function</span><span class="s1">(iteratees) {</span>
        <span class="s1">iteratees = arrayMap(iteratees, baseUnary(getIteratee()));</span>
        <span class="s2">return </span><span class="s1">baseRest(</span><span class="s2">function</span><span class="s1">(args) {</span>
          <span class="s2">var </span><span class="s1">thisArg = </span><span class="s2">this</span><span class="s1">;</span>
          <span class="s2">return </span><span class="s1">arrayFunc(iteratees, </span><span class="s2">function</span><span class="s1">(iteratee) {</span>
            <span class="s2">return </span><span class="s1">apply(iteratee, thisArg, args);</span>
          <span class="s1">});</span>
        <span class="s1">});</span>
      <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates the padding for `string` based on `length`. The `chars` string 
     * is truncated if the number of characters exceeds `length`. 
     * 
     * @private 
     * @param {number} length The padding length. 
     * @param {string} [chars=' '] The string used as padding. 
     * @returns {string} Returns the padding for `string`. 
     */</span>
    <span class="s2">function </span><span class="s1">createPadding(length, chars) {</span>
      <span class="s1">chars = chars === undefined ? </span><span class="s3">' ' </span><span class="s1">: baseToString(chars);</span>

      <span class="s2">var </span><span class="s1">charsLength = chars.length;</span>
      <span class="s2">if </span><span class="s1">(charsLength &lt; </span><span class="s4">2</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">charsLength ? baseRepeat(chars, length) : chars;</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));</span>
      <span class="s2">return </span><span class="s1">hasUnicode(chars)</span>
        <span class="s1">? castSlice(stringToArray(result), </span><span class="s4">0</span><span class="s1">, length).join(</span><span class="s3">''</span><span class="s1">)</span>
        <span class="s1">: result.slice(</span><span class="s4">0</span><span class="s1">, length);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a function that wraps `func` to invoke it with the `this` binding 
     * of `thisArg` and `partials` prepended to the arguments it receives. 
     * 
     * @private 
     * @param {Function} func The function to wrap. 
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details. 
     * @param {*} thisArg The `this` binding of `func`. 
     * @param {Array} partials The arguments to prepend to those provided to 
     *  the new function. 
     * @returns {Function} Returns the new wrapped function. 
     */</span>
    <span class="s2">function </span><span class="s1">createPartial(func, bitmask, thisArg, partials) {</span>
      <span class="s2">var </span><span class="s1">isBind = bitmask &amp; WRAP_BIND_FLAG,</span>
          <span class="s1">Ctor = createCtor(func);</span>

      <span class="s2">function </span><span class="s1">wrapper() {</span>
        <span class="s2">var </span><span class="s1">argsIndex = -</span><span class="s4">1</span><span class="s1">,</span>
            <span class="s1">argsLength = arguments.length,</span>
            <span class="s1">leftIndex = -</span><span class="s4">1</span><span class="s1">,</span>
            <span class="s1">leftLength = partials.length,</span>
            <span class="s1">args = Array(leftLength + argsLength),</span>
            <span class="s1">fn = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this </span><span class="s1">!== root &amp;&amp; </span><span class="s2">this instanceof </span><span class="s1">wrapper) ? Ctor : func;</span>

        <span class="s2">while </span><span class="s1">(++leftIndex &lt; leftLength) {</span>
          <span class="s1">args[leftIndex] = partials[leftIndex];</span>
        <span class="s1">}</span>
        <span class="s2">while </span><span class="s1">(argsLength--) {</span>
          <span class="s1">args[leftIndex++] = arguments[++argsIndex];</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">apply(fn, isBind ? thisArg : </span><span class="s2">this</span><span class="s1">, args);</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">wrapper;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a `_.range` or `_.rangeRight` function. 
     * 
     * @private 
     * @param {boolean} [fromRight] Specify iterating from right to left. 
     * @returns {Function} Returns the new range function. 
     */</span>
    <span class="s2">function </span><span class="s1">createRange(fromRight) {</span>
      <span class="s2">return function</span><span class="s1">(start, end, step) {</span>
        <span class="s2">if </span><span class="s1">(step &amp;&amp; </span><span class="s2">typeof </span><span class="s1">step != </span><span class="s3">'number' </span><span class="s1">&amp;&amp; isIterateeCall(start, end, step)) {</span>
          <span class="s1">end = step = undefined;</span>
        <span class="s1">}</span>
        <span class="s0">// Ensure the sign of `-0` is preserved.</span>
        <span class="s1">start = toFinite(start);</span>
        <span class="s2">if </span><span class="s1">(end === undefined) {</span>
          <span class="s1">end = start;</span>
          <span class="s1">start = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">end = toFinite(end);</span>
        <span class="s1">}</span>
        <span class="s1">step = step === undefined ? (start &lt; end ? </span><span class="s4">1 </span><span class="s1">: -</span><span class="s4">1</span><span class="s1">) : toFinite(step);</span>
        <span class="s2">return </span><span class="s1">baseRange(start, end, step, fromRight);</span>
      <span class="s1">};</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a function that performs a relational operation on two values. 
     * 
     * @private 
     * @param {Function} operator The function to perform the operation. 
     * @returns {Function} Returns the new relational operation function. 
     */</span>
    <span class="s2">function </span><span class="s1">createRelationalOperation(operator) {</span>
      <span class="s2">return function</span><span class="s1">(value, other) {</span>
        <span class="s2">if </span><span class="s1">(!(</span><span class="s2">typeof </span><span class="s1">value == </span><span class="s3">'string' </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">other == </span><span class="s3">'string'</span><span class="s1">)) {</span>
          <span class="s1">value = toNumber(value);</span>
          <span class="s1">other = toNumber(other);</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">operator(value, other);</span>
      <span class="s1">};</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a function that wraps `func` to continue currying. 
     * 
     * @private 
     * @param {Function} func The function to wrap. 
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details. 
     * @param {Function} wrapFunc The function to create the `func` wrapper. 
     * @param {*} placeholder The placeholder value. 
     * @param {*} [thisArg] The `this` binding of `func`. 
     * @param {Array} [partials] The arguments to prepend to those provided to 
     *  the new function. 
     * @param {Array} [holders] The `partials` placeholder indexes. 
     * @param {Array} [argPos] The argument positions of the new function. 
     * @param {number} [ary] The arity cap of `func`. 
     * @param {number} [arity] The arity of `func`. 
     * @returns {Function} Returns the new wrapped function. 
     */</span>
    <span class="s2">function </span><span class="s1">createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {</span>
      <span class="s2">var </span><span class="s1">isCurry = bitmask &amp; WRAP_CURRY_FLAG,</span>
          <span class="s1">newHolders = isCurry ? holders : undefined,</span>
          <span class="s1">newHoldersRight = isCurry ? undefined : holders,</span>
          <span class="s1">newPartials = isCurry ? partials : undefined,</span>
          <span class="s1">newPartialsRight = isCurry ? undefined : partials;</span>

      <span class="s1">bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);</span>
      <span class="s1">bitmask &amp;= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);</span>

      <span class="s2">if </span><span class="s1">(!(bitmask &amp; WRAP_CURRY_BOUND_FLAG)) {</span>
        <span class="s1">bitmask &amp;= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">newData = [</span>
        <span class="s1">func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,</span>
        <span class="s1">newHoldersRight, argPos, ary, arity</span>
      <span class="s1">];</span>

      <span class="s2">var </span><span class="s1">result = wrapFunc.apply(undefined, newData);</span>
      <span class="s2">if </span><span class="s1">(isLaziable(func)) {</span>
        <span class="s1">setData(result, newData);</span>
      <span class="s1">}</span>
      <span class="s1">result.placeholder = placeholder;</span>
      <span class="s2">return </span><span class="s1">setWrapToString(result, func, bitmask);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a function like `_.round`. 
     * 
     * @private 
     * @param {string} methodName The name of the `Math` method to use when rounding. 
     * @returns {Function} Returns the new round function. 
     */</span>
    <span class="s2">function </span><span class="s1">createRound(methodName) {</span>
      <span class="s2">var </span><span class="s1">func = Math[methodName];</span>
      <span class="s2">return function</span><span class="s1">(number, precision) {</span>
        <span class="s1">number = toNumber(number);</span>
        <span class="s1">precision = precision == </span><span class="s2">null </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: nativeMin(toInteger(precision), </span><span class="s4">292</span><span class="s1">);</span>
        <span class="s2">if </span><span class="s1">(precision &amp;&amp; nativeIsFinite(number)) {</span>
          <span class="s0">// Shift with exponential notation to avoid floating-point issues.</span>
          <span class="s0">// See [MDN](https://mdn.io/round#Examples) for more details.</span>
          <span class="s2">var </span><span class="s1">pair = (toString(number) + </span><span class="s3">'e'</span><span class="s1">).split(</span><span class="s3">'e'</span><span class="s1">),</span>
              <span class="s1">value = func(pair[</span><span class="s4">0</span><span class="s1">] + </span><span class="s3">'e' </span><span class="s1">+ (+pair[</span><span class="s4">1</span><span class="s1">] + precision));</span>

          <span class="s1">pair = (toString(value) + </span><span class="s3">'e'</span><span class="s1">).split(</span><span class="s3">'e'</span><span class="s1">);</span>
          <span class="s2">return </span><span class="s1">+(pair[</span><span class="s4">0</span><span class="s1">] + </span><span class="s3">'e' </span><span class="s1">+ (+pair[</span><span class="s4">1</span><span class="s1">] - precision));</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">func(number);</span>
      <span class="s1">};</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a set object of `values`. 
     * 
     * @private 
     * @param {Array} values The values to add to the set. 
     * @returns {Object} Returns the new set. 
     */</span>
    <span class="s2">var </span><span class="s1">createSet = !(Set &amp;&amp; (</span><span class="s4">1 </span><span class="s1">/ setToArray(</span><span class="s2">new </span><span class="s1">Set([,-</span><span class="s4">0</span><span class="s1">]))[</span><span class="s4">1</span><span class="s1">]) == INFINITY) ? noop : </span><span class="s2">function</span><span class="s1">(values) {</span>
      <span class="s2">return new </span><span class="s1">Set(values);</span>
    <span class="s1">};</span>

    <span class="s0">/** 
     * Creates a `_.toPairs` or `_.toPairsIn` function. 
     * 
     * @private 
     * @param {Function} keysFunc The function to get the keys of a given object. 
     * @returns {Function} Returns the new pairs function. 
     */</span>
    <span class="s2">function </span><span class="s1">createToPairs(keysFunc) {</span>
      <span class="s2">return function</span><span class="s1">(object) {</span>
        <span class="s2">var </span><span class="s1">tag = getTag(object);</span>
        <span class="s2">if </span><span class="s1">(tag == mapTag) {</span>
          <span class="s2">return </span><span class="s1">mapToArray(object);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(tag == setTag) {</span>
          <span class="s2">return </span><span class="s1">setToPairs(object);</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">baseToPairs(object, keysFunc(object));</span>
      <span class="s1">};</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a function that either curries or invokes `func` with optional 
     * `this` binding and partially applied arguments. 
     * 
     * @private 
     * @param {Function|string} func The function or method name to wrap. 
     * @param {number} bitmask The bitmask flags. 
     *    1 - `_.bind` 
     *    2 - `_.bindKey` 
     *    4 - `_.curry` or `_.curryRight` of a bound function 
     *    8 - `_.curry` 
     *   16 - `_.curryRight` 
     *   32 - `_.partial` 
     *   64 - `_.partialRight` 
     *  128 - `_.rearg` 
     *  256 - `_.ary` 
     *  512 - `_.flip` 
     * @param {*} [thisArg] The `this` binding of `func`. 
     * @param {Array} [partials] The arguments to be partially applied. 
     * @param {Array} [holders] The `partials` placeholder indexes. 
     * @param {Array} [argPos] The argument positions of the new function. 
     * @param {number} [ary] The arity cap of `func`. 
     * @param {number} [arity] The arity of `func`. 
     * @returns {Function} Returns the new wrapped function. 
     */</span>
    <span class="s2">function </span><span class="s1">createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {</span>
      <span class="s2">var </span><span class="s1">isBindKey = bitmask &amp; WRAP_BIND_KEY_FLAG;</span>
      <span class="s2">if </span><span class="s1">(!isBindKey &amp;&amp; </span><span class="s2">typeof </span><span class="s1">func != </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s2">throw new </span><span class="s1">TypeError(FUNC_ERROR_TEXT);</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">length = partials ? partials.length : </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s2">if </span><span class="s1">(!length) {</span>
        <span class="s1">bitmask &amp;= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);</span>
        <span class="s1">partials = holders = undefined;</span>
      <span class="s1">}</span>
      <span class="s1">ary = ary === undefined ? ary : nativeMax(toInteger(ary), </span><span class="s4">0</span><span class="s1">);</span>
      <span class="s1">arity = arity === undefined ? arity : toInteger(arity);</span>
      <span class="s1">length -= holders ? holders.length : </span><span class="s4">0</span><span class="s1">;</span>

      <span class="s2">if </span><span class="s1">(bitmask &amp; WRAP_PARTIAL_RIGHT_FLAG) {</span>
        <span class="s2">var </span><span class="s1">partialsRight = partials,</span>
            <span class="s1">holdersRight = holders;</span>

        <span class="s1">partials = holders = undefined;</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">data = isBindKey ? undefined : getData(func);</span>

      <span class="s2">var </span><span class="s1">newData = [</span>
        <span class="s1">func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,</span>
        <span class="s1">argPos, ary, arity</span>
      <span class="s1">];</span>

      <span class="s2">if </span><span class="s1">(data) {</span>
        <span class="s1">mergeData(newData, data);</span>
      <span class="s1">}</span>
      <span class="s1">func = newData[</span><span class="s4">0</span><span class="s1">];</span>
      <span class="s1">bitmask = newData[</span><span class="s4">1</span><span class="s1">];</span>
      <span class="s1">thisArg = newData[</span><span class="s4">2</span><span class="s1">];</span>
      <span class="s1">partials = newData[</span><span class="s4">3</span><span class="s1">];</span>
      <span class="s1">holders = newData[</span><span class="s4">4</span><span class="s1">];</span>
      <span class="s1">arity = newData[</span><span class="s4">9</span><span class="s1">] = newData[</span><span class="s4">9</span><span class="s1">] === undefined</span>
        <span class="s1">? (isBindKey ? </span><span class="s4">0 </span><span class="s1">: func.length)</span>
        <span class="s1">: nativeMax(newData[</span><span class="s4">9</span><span class="s1">] - length, </span><span class="s4">0</span><span class="s1">);</span>

      <span class="s2">if </span><span class="s1">(!arity &amp;&amp; bitmask &amp; (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {</span>
        <span class="s1">bitmask &amp;= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(!bitmask || bitmask == WRAP_BIND_FLAG) {</span>
        <span class="s2">var </span><span class="s1">result = createBind(func, bitmask, thisArg);</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {</span>
        <span class="s1">result = createCurry(func, bitmask, arity);</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) &amp;&amp; !holders.length) {</span>
        <span class="s1">result = createPartial(func, bitmask, thisArg, partials);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">result = createHybrid.apply(undefined, newData);</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">setter = data ? baseSetData : setData;</span>
      <span class="s2">return </span><span class="s1">setWrapToString(setter(result, newData), func, bitmask);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties 
     * of source objects to the destination object for all destination properties 
     * that resolve to `undefined`. 
     * 
     * @private 
     * @param {*} objValue The destination value. 
     * @param {*} srcValue The source value. 
     * @param {string} key The key of the property to assign. 
     * @param {Object} object The parent object of `objValue`. 
     * @returns {*} Returns the value to assign. 
     */</span>
    <span class="s2">function </span><span class="s1">customDefaultsAssignIn(objValue, srcValue, key, object) {</span>
      <span class="s2">if </span><span class="s1">(objValue === undefined ||</span>
          <span class="s1">(eq(objValue, objectProto[key]) &amp;&amp; !hasOwnProperty.call(object, key))) {</span>
        <span class="s2">return </span><span class="s1">srcValue;</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">objValue;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source 
     * objects into destination objects that are passed thru. 
     * 
     * @private 
     * @param {*} objValue The destination value. 
     * @param {*} srcValue The source value. 
     * @param {string} key The key of the property to merge. 
     * @param {Object} object The parent object of `objValue`. 
     * @param {Object} source The parent object of `srcValue`. 
     * @param {Object} [stack] Tracks traversed source values and their merged 
     *  counterparts. 
     * @returns {*} Returns the value to assign. 
     */</span>
    <span class="s2">function </span><span class="s1">customDefaultsMerge(objValue, srcValue, key, object, source, stack) {</span>
      <span class="s2">if </span><span class="s1">(isObject(objValue) &amp;&amp; isObject(srcValue)) {</span>
        <span class="s0">// Recursively merge objects and arrays (susceptible to call stack limits).</span>
        <span class="s1">stack.set(srcValue, objValue);</span>
        <span class="s1">baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);</span>
        <span class="s1">stack[</span><span class="s3">'delete'</span><span class="s1">](srcValue);</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">objValue;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain 
     * objects. 
     * 
     * @private 
     * @param {*} value The value to inspect. 
     * @param {string} key The key of the property to inspect. 
     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`. 
     */</span>
    <span class="s2">function </span><span class="s1">customOmitClone(value) {</span>
      <span class="s2">return </span><span class="s1">isPlainObject(value) ? undefined : value;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * A specialized version of `baseIsEqualDeep` for arrays with support for 
     * partial deep comparisons. 
     * 
     * @private 
     * @param {Array} array The array to compare. 
     * @param {Array} other The other array to compare. 
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details. 
     * @param {Function} customizer The function to customize comparisons. 
     * @param {Function} equalFunc The function to determine equivalents of values. 
     * @param {Object} stack Tracks traversed `array` and `other` objects. 
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`. 
     */</span>
    <span class="s2">function </span><span class="s1">equalArrays(array, other, bitmask, customizer, equalFunc, stack) {</span>
      <span class="s2">var </span><span class="s1">isPartial = bitmask &amp; COMPARE_PARTIAL_FLAG,</span>
          <span class="s1">arrLength = array.length,</span>
          <span class="s1">othLength = other.length;</span>

      <span class="s2">if </span><span class="s1">(arrLength != othLength &amp;&amp; !(isPartial &amp;&amp; othLength &gt; arrLength)) {</span>
        <span class="s2">return false</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s0">// Check that cyclic values are equal.</span>
      <span class="s2">var </span><span class="s1">arrStacked = stack.get(array);</span>
      <span class="s2">var </span><span class="s1">othStacked = stack.get(other);</span>
      <span class="s2">if </span><span class="s1">(arrStacked &amp;&amp; othStacked) {</span>
        <span class="s2">return </span><span class="s1">arrStacked == other &amp;&amp; othStacked == array;</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">index = -</span><span class="s4">1</span><span class="s1">,</span>
          <span class="s1">result = </span><span class="s2">true</span><span class="s1">,</span>
          <span class="s1">seen = (bitmask &amp; COMPARE_UNORDERED_FLAG) ? </span><span class="s2">new </span><span class="s1">SetCache : undefined;</span>

      <span class="s1">stack.set(array, other);</span>
      <span class="s1">stack.set(other, array);</span>

      <span class="s0">// Ignore non-index properties.</span>
      <span class="s2">while </span><span class="s1">(++index &lt; arrLength) {</span>
        <span class="s2">var </span><span class="s1">arrValue = array[index],</span>
            <span class="s1">othValue = other[index];</span>

        <span class="s2">if </span><span class="s1">(customizer) {</span>
          <span class="s2">var </span><span class="s1">compared = isPartial</span>
            <span class="s1">? customizer(othValue, arrValue, index, other, array, stack)</span>
            <span class="s1">: customizer(arrValue, othValue, index, array, other, stack);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(compared !== undefined) {</span>
          <span class="s2">if </span><span class="s1">(compared) {</span>
            <span class="s2">continue</span><span class="s1">;</span>
          <span class="s1">}</span>
          <span class="s1">result = </span><span class="s2">false</span><span class="s1">;</span>
          <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s0">// Recursively compare arrays (susceptible to call stack limits).</span>
        <span class="s2">if </span><span class="s1">(seen) {</span>
          <span class="s2">if </span><span class="s1">(!arraySome(other, </span><span class="s2">function</span><span class="s1">(othValue, othIndex) {</span>
                <span class="s2">if </span><span class="s1">(!cacheHas(seen, othIndex) &amp;&amp;</span>
                    <span class="s1">(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {</span>
                  <span class="s2">return </span><span class="s1">seen.push(othIndex);</span>
                <span class="s1">}</span>
              <span class="s1">})) {</span>
            <span class="s1">result = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s2">break</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!(</span>
              <span class="s1">arrValue === othValue ||</span>
                <span class="s1">equalFunc(arrValue, othValue, bitmask, customizer, stack)</span>
            <span class="s1">)) {</span>
          <span class="s1">result = </span><span class="s2">false</span><span class="s1">;</span>
          <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s1">stack[</span><span class="s3">'delete'</span><span class="s1">](array);</span>
      <span class="s1">stack[</span><span class="s3">'delete'</span><span class="s1">](other);</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * A specialized version of `baseIsEqualDeep` for comparing objects of 
     * the same `toStringTag`. 
     * 
     * **Note:** This function only supports comparing values with tags of 
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`. 
     * 
     * @private 
     * @param {Object} object The object to compare. 
     * @param {Object} other The other object to compare. 
     * @param {string} tag The `toStringTag` of the objects to compare. 
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details. 
     * @param {Function} customizer The function to customize comparisons. 
     * @param {Function} equalFunc The function to determine equivalents of values. 
     * @param {Object} stack Tracks traversed `object` and `other` objects. 
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`. 
     */</span>
    <span class="s2">function </span><span class="s1">equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {</span>
      <span class="s2">switch </span><span class="s1">(tag) {</span>
        <span class="s2">case </span><span class="s1">dataViewTag:</span>
          <span class="s2">if </span><span class="s1">((object.byteLength != other.byteLength) ||</span>
              <span class="s1">(object.byteOffset != other.byteOffset)) {</span>
            <span class="s2">return false</span><span class="s1">;</span>
          <span class="s1">}</span>
          <span class="s1">object = object.buffer;</span>
          <span class="s1">other = other.buffer;</span>

        <span class="s2">case </span><span class="s1">arrayBufferTag:</span>
          <span class="s2">if </span><span class="s1">((object.byteLength != other.byteLength) ||</span>
              <span class="s1">!equalFunc(</span><span class="s2">new </span><span class="s1">Uint8Array(object), </span><span class="s2">new </span><span class="s1">Uint8Array(other))) {</span>
            <span class="s2">return false</span><span class="s1">;</span>
          <span class="s1">}</span>
          <span class="s2">return true</span><span class="s1">;</span>

        <span class="s2">case </span><span class="s1">boolTag:</span>
        <span class="s2">case </span><span class="s1">dateTag:</span>
        <span class="s2">case </span><span class="s1">numberTag:</span>
          <span class="s0">// Coerce booleans to `1` or `0` and dates to milliseconds.</span>
          <span class="s0">// Invalid dates are coerced to `NaN`.</span>
          <span class="s2">return </span><span class="s1">eq(+object, +other);</span>

        <span class="s2">case </span><span class="s1">errorTag:</span>
          <span class="s2">return </span><span class="s1">object.name == other.name &amp;&amp; object.message == other.message;</span>

        <span class="s2">case </span><span class="s1">regexpTag:</span>
        <span class="s2">case </span><span class="s1">stringTag:</span>
          <span class="s0">// Coerce regexes to strings and treat strings, primitives and objects,</span>
          <span class="s0">// as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring</span>
          <span class="s0">// for more details.</span>
          <span class="s2">return </span><span class="s1">object == (other + </span><span class="s3">''</span><span class="s1">);</span>

        <span class="s2">case </span><span class="s1">mapTag:</span>
          <span class="s2">var </span><span class="s1">convert = mapToArray;</span>

        <span class="s2">case </span><span class="s1">setTag:</span>
          <span class="s2">var </span><span class="s1">isPartial = bitmask &amp; COMPARE_PARTIAL_FLAG;</span>
          <span class="s1">convert || (convert = setToArray);</span>

          <span class="s2">if </span><span class="s1">(object.size != other.size &amp;&amp; !isPartial) {</span>
            <span class="s2">return false</span><span class="s1">;</span>
          <span class="s1">}</span>
          <span class="s0">// Assume cyclic values are equal.</span>
          <span class="s2">var </span><span class="s1">stacked = stack.get(object);</span>
          <span class="s2">if </span><span class="s1">(stacked) {</span>
            <span class="s2">return </span><span class="s1">stacked == other;</span>
          <span class="s1">}</span>
          <span class="s1">bitmask |= COMPARE_UNORDERED_FLAG;</span>

          <span class="s0">// Recursively compare objects (susceptible to call stack limits).</span>
          <span class="s1">stack.set(object, other);</span>
          <span class="s2">var </span><span class="s1">result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);</span>
          <span class="s1">stack[</span><span class="s3">'delete'</span><span class="s1">](object);</span>
          <span class="s2">return </span><span class="s1">result;</span>

        <span class="s2">case </span><span class="s1">symbolTag:</span>
          <span class="s2">if </span><span class="s1">(symbolValueOf) {</span>
            <span class="s2">return </span><span class="s1">symbolValueOf.call(object) == symbolValueOf.call(other);</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * A specialized version of `baseIsEqualDeep` for objects with support for 
     * partial deep comparisons. 
     * 
     * @private 
     * @param {Object} object The object to compare. 
     * @param {Object} other The other object to compare. 
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details. 
     * @param {Function} customizer The function to customize comparisons. 
     * @param {Function} equalFunc The function to determine equivalents of values. 
     * @param {Object} stack Tracks traversed `object` and `other` objects. 
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`. 
     */</span>
    <span class="s2">function </span><span class="s1">equalObjects(object, other, bitmask, customizer, equalFunc, stack) {</span>
      <span class="s2">var </span><span class="s1">isPartial = bitmask &amp; COMPARE_PARTIAL_FLAG,</span>
          <span class="s1">objProps = getAllKeys(object),</span>
          <span class="s1">objLength = objProps.length,</span>
          <span class="s1">othProps = getAllKeys(other),</span>
          <span class="s1">othLength = othProps.length;</span>

      <span class="s2">if </span><span class="s1">(objLength != othLength &amp;&amp; !isPartial) {</span>
        <span class="s2">return false</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">index = objLength;</span>
      <span class="s2">while </span><span class="s1">(index--) {</span>
        <span class="s2">var </span><span class="s1">key = objProps[index];</span>
        <span class="s2">if </span><span class="s1">(!(isPartial ? key </span><span class="s2">in </span><span class="s1">other : hasOwnProperty.call(other, key))) {</span>
          <span class="s2">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">// Check that cyclic values are equal.</span>
      <span class="s2">var </span><span class="s1">objStacked = stack.get(object);</span>
      <span class="s2">var </span><span class="s1">othStacked = stack.get(other);</span>
      <span class="s2">if </span><span class="s1">(objStacked &amp;&amp; othStacked) {</span>
        <span class="s2">return </span><span class="s1">objStacked == other &amp;&amp; othStacked == object;</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">result = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s1">stack.set(object, other);</span>
      <span class="s1">stack.set(other, object);</span>

      <span class="s2">var </span><span class="s1">skipCtor = isPartial;</span>
      <span class="s2">while </span><span class="s1">(++index &lt; objLength) {</span>
        <span class="s1">key = objProps[index];</span>
        <span class="s2">var </span><span class="s1">objValue = object[key],</span>
            <span class="s1">othValue = other[key];</span>

        <span class="s2">if </span><span class="s1">(customizer) {</span>
          <span class="s2">var </span><span class="s1">compared = isPartial</span>
            <span class="s1">? customizer(othValue, objValue, key, other, object, stack)</span>
            <span class="s1">: customizer(objValue, othValue, key, object, other, stack);</span>
        <span class="s1">}</span>
        <span class="s0">// Recursively compare objects (susceptible to call stack limits).</span>
        <span class="s2">if </span><span class="s1">(!(compared === undefined</span>
              <span class="s1">? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))</span>
              <span class="s1">: compared</span>
            <span class="s1">)) {</span>
          <span class="s1">result = </span><span class="s2">false</span><span class="s1">;</span>
          <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">skipCtor || (skipCtor = key == </span><span class="s3">'constructor'</span><span class="s1">);</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(result &amp;&amp; !skipCtor) {</span>
        <span class="s2">var </span><span class="s1">objCtor = object.constructor,</span>
            <span class="s1">othCtor = other.constructor;</span>

        <span class="s0">// Non `Object` object instances with different constructors are not equal.</span>
        <span class="s2">if </span><span class="s1">(objCtor != othCtor &amp;&amp;</span>
            <span class="s1">(</span><span class="s3">'constructor' </span><span class="s2">in </span><span class="s1">object &amp;&amp; </span><span class="s3">'constructor' </span><span class="s2">in </span><span class="s1">other) &amp;&amp;</span>
            <span class="s1">!(</span><span class="s2">typeof </span><span class="s1">objCtor == </span><span class="s3">'function' </span><span class="s1">&amp;&amp; objCtor </span><span class="s2">instanceof </span><span class="s1">objCtor &amp;&amp;</span>
              <span class="s2">typeof </span><span class="s1">othCtor == </span><span class="s3">'function' </span><span class="s1">&amp;&amp; othCtor </span><span class="s2">instanceof </span><span class="s1">othCtor)) {</span>
          <span class="s1">result = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s1">stack[</span><span class="s3">'delete'</span><span class="s1">](object);</span>
      <span class="s1">stack[</span><span class="s3">'delete'</span><span class="s1">](other);</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * A specialized version of `baseRest` which flattens the rest array. 
     * 
     * @private 
     * @param {Function} func The function to apply a rest parameter to. 
     * @returns {Function} Returns the new function. 
     */</span>
    <span class="s2">function </span><span class="s1">flatRest(func) {</span>
      <span class="s2">return </span><span class="s1">setToString(overRest(func, undefined, flatten), func + </span><span class="s3">''</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates an array of own enumerable property names and symbols of `object`. 
     * 
     * @private 
     * @param {Object} object The object to query. 
     * @returns {Array} Returns the array of property names and symbols. 
     */</span>
    <span class="s2">function </span><span class="s1">getAllKeys(object) {</span>
      <span class="s2">return </span><span class="s1">baseGetAllKeys(object, keys, getSymbols);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates an array of own and inherited enumerable property names and 
     * symbols of `object`. 
     * 
     * @private 
     * @param {Object} object The object to query. 
     * @returns {Array} Returns the array of property names and symbols. 
     */</span>
    <span class="s2">function </span><span class="s1">getAllKeysIn(object) {</span>
      <span class="s2">return </span><span class="s1">baseGetAllKeys(object, keysIn, getSymbolsIn);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Gets metadata for `func`. 
     * 
     * @private 
     * @param {Function} func The function to query. 
     * @returns {*} Returns the metadata for `func`. 
     */</span>
    <span class="s2">var </span><span class="s1">getData = !metaMap ? noop : </span><span class="s2">function</span><span class="s1">(func) {</span>
      <span class="s2">return </span><span class="s1">metaMap.get(func);</span>
    <span class="s1">};</span>

    <span class="s0">/** 
     * Gets the name of `func`. 
     * 
     * @private 
     * @param {Function} func The function to query. 
     * @returns {string} Returns the function name. 
     */</span>
    <span class="s2">function </span><span class="s1">getFuncName(func) {</span>
      <span class="s2">var </span><span class="s1">result = (func.name + </span><span class="s3">''</span><span class="s1">),</span>
          <span class="s1">array = realNames[result],</span>
          <span class="s1">length = hasOwnProperty.call(realNames, result) ? array.length : </span><span class="s4">0</span><span class="s1">;</span>

      <span class="s2">while </span><span class="s1">(length--) {</span>
        <span class="s2">var </span><span class="s1">data = array[length],</span>
            <span class="s1">otherFunc = data.func;</span>
        <span class="s2">if </span><span class="s1">(otherFunc == </span><span class="s2">null </span><span class="s1">|| otherFunc == func) {</span>
          <span class="s2">return </span><span class="s1">data.name;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Gets the argument placeholder value for `func`. 
     * 
     * @private 
     * @param {Function} func The function to inspect. 
     * @returns {*} Returns the placeholder value. 
     */</span>
    <span class="s2">function </span><span class="s1">getHolder(func) {</span>
      <span class="s2">var </span><span class="s1">object = hasOwnProperty.call(lodash, </span><span class="s3">'placeholder'</span><span class="s1">) ? lodash : func;</span>
      <span class="s2">return </span><span class="s1">object.placeholder;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Gets the appropriate &quot;iteratee&quot; function. If `_.iteratee` is customized, 
     * this function returns the custom method, otherwise it returns `baseIteratee`. 
     * If arguments are provided, the chosen function is invoked with them and 
     * its result is returned. 
     * 
     * @private 
     * @param {*} [value] The value to convert to an iteratee. 
     * @param {number} [arity] The arity of the created iteratee. 
     * @returns {Function} Returns the chosen function or its result. 
     */</span>
    <span class="s2">function </span><span class="s1">getIteratee() {</span>
      <span class="s2">var </span><span class="s1">result = lodash.iteratee || iteratee;</span>
      <span class="s1">result = result === iteratee ? baseIteratee : result;</span>
      <span class="s2">return </span><span class="s1">arguments.length ? result(arguments[</span><span class="s4">0</span><span class="s1">], arguments[</span><span class="s4">1</span><span class="s1">]) : result;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Gets the data for `map`. 
     * 
     * @private 
     * @param {Object} map The map to query. 
     * @param {string} key The reference key. 
     * @returns {*} Returns the map data. 
     */</span>
    <span class="s2">function </span><span class="s1">getMapData(map, key) {</span>
      <span class="s2">var </span><span class="s1">data = map.__data__;</span>
      <span class="s2">return </span><span class="s1">isKeyable(key)</span>
        <span class="s1">? data[</span><span class="s2">typeof </span><span class="s1">key == </span><span class="s3">'string' </span><span class="s1">? </span><span class="s3">'string' </span><span class="s1">: </span><span class="s3">'hash'</span><span class="s1">]</span>
        <span class="s1">: data.map;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Gets the property names, values, and compare flags of `object`. 
     * 
     * @private 
     * @param {Object} object The object to query. 
     * @returns {Array} Returns the match data of `object`. 
     */</span>
    <span class="s2">function </span><span class="s1">getMatchData(object) {</span>
      <span class="s2">var </span><span class="s1">result = keys(object),</span>
          <span class="s1">length = result.length;</span>

      <span class="s2">while </span><span class="s1">(length--) {</span>
        <span class="s2">var </span><span class="s1">key = result[length],</span>
            <span class="s1">value = object[key];</span>

        <span class="s1">result[length] = [key, value, isStrictComparable(value)];</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Gets the native function at `key` of `object`. 
     * 
     * @private 
     * @param {Object} object The object to query. 
     * @param {string} key The key of the method to get. 
     * @returns {*} Returns the function if it's native, else `undefined`. 
     */</span>
    <span class="s2">function </span><span class="s1">getNative(object, key) {</span>
      <span class="s2">var </span><span class="s1">value = getValue(object, key);</span>
      <span class="s2">return </span><span class="s1">baseIsNative(value) ? value : undefined;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values. 
     * 
     * @private 
     * @param {*} value The value to query. 
     * @returns {string} Returns the raw `toStringTag`. 
     */</span>
    <span class="s2">function </span><span class="s1">getRawTag(value) {</span>
      <span class="s2">var </span><span class="s1">isOwn = hasOwnProperty.call(value, symToStringTag),</span>
          <span class="s1">tag = value[symToStringTag];</span>

      <span class="s2">try </span><span class="s1">{</span>
        <span class="s1">value[symToStringTag] = undefined;</span>
        <span class="s2">var </span><span class="s1">unmasked = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s2">catch </span><span class="s1">(e) {}</span>

      <span class="s2">var </span><span class="s1">result = nativeObjectToString.call(value);</span>
      <span class="s2">if </span><span class="s1">(unmasked) {</span>
        <span class="s2">if </span><span class="s1">(isOwn) {</span>
          <span class="s1">value[symToStringTag] = tag;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s2">delete </span><span class="s1">value[symToStringTag];</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates an array of the own enumerable symbols of `object`. 
     * 
     * @private 
     * @param {Object} object The object to query. 
     * @returns {Array} Returns the array of symbols. 
     */</span>
    <span class="s2">var </span><span class="s1">getSymbols = !nativeGetSymbols ? stubArray : </span><span class="s2">function</span><span class="s1">(object) {</span>
      <span class="s2">if </span><span class="s1">(object == </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">[];</span>
      <span class="s1">}</span>
      <span class="s1">object = Object(object);</span>
      <span class="s2">return </span><span class="s1">arrayFilter(nativeGetSymbols(object), </span><span class="s2">function</span><span class="s1">(symbol) {</span>
        <span class="s2">return </span><span class="s1">propertyIsEnumerable.call(object, symbol);</span>
      <span class="s1">});</span>
    <span class="s1">};</span>

    <span class="s0">/** 
     * Creates an array of the own and inherited enumerable symbols of `object`. 
     * 
     * @private 
     * @param {Object} object The object to query. 
     * @returns {Array} Returns the array of symbols. 
     */</span>
    <span class="s2">var </span><span class="s1">getSymbolsIn = !nativeGetSymbols ? stubArray : </span><span class="s2">function</span><span class="s1">(object) {</span>
      <span class="s2">var </span><span class="s1">result = [];</span>
      <span class="s2">while </span><span class="s1">(object) {</span>
        <span class="s1">arrayPush(result, getSymbols(object));</span>
        <span class="s1">object = getPrototype(object);</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">};</span>

    <span class="s0">/** 
     * Gets the `toStringTag` of `value`. 
     * 
     * @private 
     * @param {*} value The value to query. 
     * @returns {string} Returns the `toStringTag`. 
     */</span>
    <span class="s2">var </span><span class="s1">getTag = baseGetTag;</span>

    <span class="s0">// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js &lt; 6.</span>
    <span class="s2">if </span><span class="s1">((DataView &amp;&amp; getTag(</span><span class="s2">new </span><span class="s1">DataView(</span><span class="s2">new </span><span class="s1">ArrayBuffer(</span><span class="s4">1</span><span class="s1">))) != dataViewTag) ||</span>
        <span class="s1">(Map &amp;&amp; getTag(</span><span class="s2">new </span><span class="s1">Map) != mapTag) ||</span>
        <span class="s1">(Promise &amp;&amp; getTag(Promise.resolve()) != promiseTag) ||</span>
        <span class="s1">(Set &amp;&amp; getTag(</span><span class="s2">new </span><span class="s1">Set) != setTag) ||</span>
        <span class="s1">(WeakMap &amp;&amp; getTag(</span><span class="s2">new </span><span class="s1">WeakMap) != weakMapTag)) {</span>
      <span class="s1">getTag = </span><span class="s2">function</span><span class="s1">(value) {</span>
        <span class="s2">var </span><span class="s1">result = baseGetTag(value),</span>
            <span class="s1">Ctor = result == objectTag ? value.constructor : undefined,</span>
            <span class="s1">ctorString = Ctor ? toSource(Ctor) : </span><span class="s3">''</span><span class="s1">;</span>

        <span class="s2">if </span><span class="s1">(ctorString) {</span>
          <span class="s2">switch </span><span class="s1">(ctorString) {</span>
            <span class="s2">case </span><span class="s1">dataViewCtorString: </span><span class="s2">return </span><span class="s1">dataViewTag;</span>
            <span class="s2">case </span><span class="s1">mapCtorString: </span><span class="s2">return </span><span class="s1">mapTag;</span>
            <span class="s2">case </span><span class="s1">promiseCtorString: </span><span class="s2">return </span><span class="s1">promiseTag;</span>
            <span class="s2">case </span><span class="s1">setCtorString: </span><span class="s2">return </span><span class="s1">setTag;</span>
            <span class="s2">case </span><span class="s1">weakMapCtorString: </span><span class="s2">return </span><span class="s1">weakMapTag;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">result;</span>
      <span class="s1">};</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Gets the view, applying any `transforms` to the `start` and `end` positions. 
     * 
     * @private 
     * @param {number} start The start of the view. 
     * @param {number} end The end of the view. 
     * @param {Array} transforms The transformations to apply to the view. 
     * @returns {Object} Returns an object containing the `start` and `end` 
     *  positions of the view. 
     */</span>
    <span class="s2">function </span><span class="s1">getView(start, end, transforms) {</span>
      <span class="s2">var </span><span class="s1">index = -</span><span class="s4">1</span><span class="s1">,</span>
          <span class="s1">length = transforms.length;</span>

      <span class="s2">while </span><span class="s1">(++index &lt; length) {</span>
        <span class="s2">var </span><span class="s1">data = transforms[index],</span>
            <span class="s1">size = data.size;</span>

        <span class="s2">switch </span><span class="s1">(data.type) {</span>
          <span class="s2">case </span><span class="s3">'drop'</span><span class="s1">:      start += size; </span><span class="s2">break</span><span class="s1">;</span>
          <span class="s2">case </span><span class="s3">'dropRight'</span><span class="s1">: end -= size; </span><span class="s2">break</span><span class="s1">;</span>
          <span class="s2">case </span><span class="s3">'take'</span><span class="s1">:      end = nativeMin(end, start + size); </span><span class="s2">break</span><span class="s1">;</span>
          <span class="s2">case </span><span class="s3">'takeRight'</span><span class="s1">: start = nativeMax(start, end - size); </span><span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">{ </span><span class="s3">'start'</span><span class="s1">: start, </span><span class="s3">'end'</span><span class="s1">: end };</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Extracts wrapper details from the `source` body comment. 
     * 
     * @private 
     * @param {string} source The source to inspect. 
     * @returns {Array} Returns the wrapper details. 
     */</span>
    <span class="s2">function </span><span class="s1">getWrapDetails(source) {</span>
      <span class="s2">var </span><span class="s1">match = source.match(reWrapDetails);</span>
      <span class="s2">return </span><span class="s1">match ? match[</span><span class="s4">1</span><span class="s1">].split(reSplitDetails) : [];</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Checks if `path` exists on `object`. 
     * 
     * @private 
     * @param {Object} object The object to query. 
     * @param {Array|string} path The path to check. 
     * @param {Function} hasFunc The function to check properties. 
     * @returns {boolean} Returns `true` if `path` exists, else `false`. 
     */</span>
    <span class="s2">function </span><span class="s1">hasPath(object, path, hasFunc) {</span>
      <span class="s1">path = castPath(path, object);</span>

      <span class="s2">var </span><span class="s1">index = -</span><span class="s4">1</span><span class="s1">,</span>
          <span class="s1">length = path.length,</span>
          <span class="s1">result = </span><span class="s2">false</span><span class="s1">;</span>

      <span class="s2">while </span><span class="s1">(++index &lt; length) {</span>
        <span class="s2">var </span><span class="s1">key = toKey(path[index]);</span>
        <span class="s2">if </span><span class="s1">(!(result = object != </span><span class="s2">null </span><span class="s1">&amp;&amp; hasFunc(object, key))) {</span>
          <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">object = object[key];</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(result || ++index != length) {</span>
        <span class="s2">return </span><span class="s1">result;</span>
      <span class="s1">}</span>
      <span class="s1">length = object == </span><span class="s2">null </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: object.length;</span>
      <span class="s2">return </span><span class="s1">!!length &amp;&amp; isLength(length) &amp;&amp; isIndex(key, length) &amp;&amp;</span>
        <span class="s1">(isArray(object) || isArguments(object));</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Initializes an array clone. 
     * 
     * @private 
     * @param {Array} array The array to clone. 
     * @returns {Array} Returns the initialized clone. 
     */</span>
    <span class="s2">function </span><span class="s1">initCloneArray(array) {</span>
      <span class="s2">var </span><span class="s1">length = array.length,</span>
          <span class="s1">result = </span><span class="s2">new </span><span class="s1">array.constructor(length);</span>

      <span class="s0">// Add properties assigned by `RegExp#exec`.</span>
      <span class="s2">if </span><span class="s1">(length &amp;&amp; </span><span class="s2">typeof </span><span class="s1">array[</span><span class="s4">0</span><span class="s1">] == </span><span class="s3">'string' </span><span class="s1">&amp;&amp; hasOwnProperty.call(array, </span><span class="s3">'index'</span><span class="s1">)) {</span>
        <span class="s1">result.index = array.index;</span>
        <span class="s1">result.input = array.input;</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Initializes an object clone. 
     * 
     * @private 
     * @param {Object} object The object to clone. 
     * @returns {Object} Returns the initialized clone. 
     */</span>
    <span class="s2">function </span><span class="s1">initCloneObject(object) {</span>
      <span class="s2">return </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">object.constructor == </span><span class="s3">'function' </span><span class="s1">&amp;&amp; !isPrototype(object))</span>
        <span class="s1">? baseCreate(getPrototype(object))</span>
        <span class="s1">: {};</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Initializes an object clone based on its `toStringTag`. 
     * 
     * **Note:** This function only supports cloning values with tags of 
     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`. 
     * 
     * @private 
     * @param {Object} object The object to clone. 
     * @param {string} tag The `toStringTag` of the object to clone. 
     * @param {boolean} [isDeep] Specify a deep clone. 
     * @returns {Object} Returns the initialized clone. 
     */</span>
    <span class="s2">function </span><span class="s1">initCloneByTag(object, tag, isDeep) {</span>
      <span class="s2">var </span><span class="s1">Ctor = object.constructor;</span>
      <span class="s2">switch </span><span class="s1">(tag) {</span>
        <span class="s2">case </span><span class="s1">arrayBufferTag:</span>
          <span class="s2">return </span><span class="s1">cloneArrayBuffer(object);</span>

        <span class="s2">case </span><span class="s1">boolTag:</span>
        <span class="s2">case </span><span class="s1">dateTag:</span>
          <span class="s2">return new </span><span class="s1">Ctor(+object);</span>

        <span class="s2">case </span><span class="s1">dataViewTag:</span>
          <span class="s2">return </span><span class="s1">cloneDataView(object, isDeep);</span>

        <span class="s2">case </span><span class="s1">float32Tag: </span><span class="s2">case </span><span class="s1">float64Tag:</span>
        <span class="s2">case </span><span class="s1">int8Tag: </span><span class="s2">case </span><span class="s1">int16Tag: </span><span class="s2">case </span><span class="s1">int32Tag:</span>
        <span class="s2">case </span><span class="s1">uint8Tag: </span><span class="s2">case </span><span class="s1">uint8ClampedTag: </span><span class="s2">case </span><span class="s1">uint16Tag: </span><span class="s2">case </span><span class="s1">uint32Tag:</span>
          <span class="s2">return </span><span class="s1">cloneTypedArray(object, isDeep);</span>

        <span class="s2">case </span><span class="s1">mapTag:</span>
          <span class="s2">return new </span><span class="s1">Ctor;</span>

        <span class="s2">case </span><span class="s1">numberTag:</span>
        <span class="s2">case </span><span class="s1">stringTag:</span>
          <span class="s2">return new </span><span class="s1">Ctor(object);</span>

        <span class="s2">case </span><span class="s1">regexpTag:</span>
          <span class="s2">return </span><span class="s1">cloneRegExp(object);</span>

        <span class="s2">case </span><span class="s1">setTag:</span>
          <span class="s2">return new </span><span class="s1">Ctor;</span>

        <span class="s2">case </span><span class="s1">symbolTag:</span>
          <span class="s2">return </span><span class="s1">cloneSymbol(object);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Inserts wrapper `details` in a comment at the top of the `source` body. 
     * 
     * @private 
     * @param {string} source The source to modify. 
     * @returns {Array} details The details to insert. 
     * @returns {string} Returns the modified source. 
     */</span>
    <span class="s2">function </span><span class="s1">insertWrapDetails(source, details) {</span>
      <span class="s2">var </span><span class="s1">length = details.length;</span>
      <span class="s2">if </span><span class="s1">(!length) {</span>
        <span class="s2">return </span><span class="s1">source;</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">lastIndex = length - </span><span class="s4">1</span><span class="s1">;</span>
      <span class="s1">details[lastIndex] = (length &gt; </span><span class="s4">1 </span><span class="s1">? </span><span class="s3">'&amp; ' </span><span class="s1">: </span><span class="s3">''</span><span class="s1">) + details[lastIndex];</span>
      <span class="s1">details = details.join(length &gt; </span><span class="s4">2 </span><span class="s1">? </span><span class="s3">', ' </span><span class="s1">: </span><span class="s3">' '</span><span class="s1">);</span>
      <span class="s2">return </span><span class="s1">source.replace(reWrapComment, </span><span class="s3">'{</span><span class="s5">\n</span><span class="s3">/* [wrapped with ' </span><span class="s1">+ details + </span><span class="s3">'] */</span><span class="s5">\n</span><span class="s3">'</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Checks if `value` is a flattenable `arguments` object or array. 
     * 
     * @private 
     * @param {*} value The value to check. 
     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`. 
     */</span>
    <span class="s2">function </span><span class="s1">isFlattenable(value) {</span>
      <span class="s2">return </span><span class="s1">isArray(value) || isArguments(value) ||</span>
        <span class="s1">!!(spreadableSymbol &amp;&amp; value &amp;&amp; value[spreadableSymbol]);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Checks if `value` is a valid array-like index. 
     * 
     * @private 
     * @param {*} value The value to check. 
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index. 
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`. 
     */</span>
    <span class="s2">function </span><span class="s1">isIndex(value, length) {</span>
      <span class="s2">var </span><span class="s1">type = </span><span class="s2">typeof </span><span class="s1">value;</span>
      <span class="s1">length = length == </span><span class="s2">null </span><span class="s1">? MAX_SAFE_INTEGER : length;</span>

      <span class="s2">return </span><span class="s1">!!length &amp;&amp;</span>
        <span class="s1">(type == </span><span class="s3">'number' </span><span class="s1">||</span>
          <span class="s1">(type != </span><span class="s3">'symbol' </span><span class="s1">&amp;&amp; reIsUint.test(value))) &amp;&amp;</span>
            <span class="s1">(value &gt; -</span><span class="s4">1 </span><span class="s1">&amp;&amp; value % </span><span class="s4">1 </span><span class="s1">== </span><span class="s4">0 </span><span class="s1">&amp;&amp; value &lt; length);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Checks if the given arguments are from an iteratee call. 
     * 
     * @private 
     * @param {*} value The potential iteratee value argument. 
     * @param {*} index The potential iteratee index or key argument. 
     * @param {*} object The potential iteratee object argument. 
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call, 
     *  else `false`. 
     */</span>
    <span class="s2">function </span><span class="s1">isIterateeCall(value, index, object) {</span>
      <span class="s2">if </span><span class="s1">(!isObject(object)) {</span>
        <span class="s2">return false</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">type = </span><span class="s2">typeof </span><span class="s1">index;</span>
      <span class="s2">if </span><span class="s1">(type == </span><span class="s3">'number'</span>
            <span class="s1">? (isArrayLike(object) &amp;&amp; isIndex(index, object.length))</span>
            <span class="s1">: (type == </span><span class="s3">'string' </span><span class="s1">&amp;&amp; index </span><span class="s2">in </span><span class="s1">object)</span>
          <span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">eq(object[index], value);</span>
      <span class="s1">}</span>
      <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Checks if `value` is a property name and not a property path. 
     * 
     * @private 
     * @param {*} value The value to check. 
     * @param {Object} [object] The object to query keys on. 
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`. 
     */</span>
    <span class="s2">function </span><span class="s1">isKey(value, object) {</span>
      <span class="s2">if </span><span class="s1">(isArray(value)) {</span>
        <span class="s2">return false</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">type = </span><span class="s2">typeof </span><span class="s1">value;</span>
      <span class="s2">if </span><span class="s1">(type == </span><span class="s3">'number' </span><span class="s1">|| type == </span><span class="s3">'symbol' </span><span class="s1">|| type == </span><span class="s3">'boolean' </span><span class="s1">||</span>
          <span class="s1">value == </span><span class="s2">null </span><span class="s1">|| isSymbol(value)) {</span>
        <span class="s2">return true</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||</span>
        <span class="s1">(object != </span><span class="s2">null </span><span class="s1">&amp;&amp; value </span><span class="s2">in </span><span class="s1">Object(object));</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Checks if `value` is suitable for use as unique object key. 
     * 
     * @private 
     * @param {*} value The value to check. 
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`. 
     */</span>
    <span class="s2">function </span><span class="s1">isKeyable(value) {</span>
      <span class="s2">var </span><span class="s1">type = </span><span class="s2">typeof </span><span class="s1">value;</span>
      <span class="s2">return </span><span class="s1">(type == </span><span class="s3">'string' </span><span class="s1">|| type == </span><span class="s3">'number' </span><span class="s1">|| type == </span><span class="s3">'symbol' </span><span class="s1">|| type == </span><span class="s3">'boolean'</span><span class="s1">)</span>
        <span class="s1">? (value !== </span><span class="s3">'__proto__'</span><span class="s1">)</span>
        <span class="s1">: (value === </span><span class="s2">null</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Checks if `func` has a lazy counterpart. 
     * 
     * @private 
     * @param {Function} func The function to check. 
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart, 
     *  else `false`. 
     */</span>
    <span class="s2">function </span><span class="s1">isLaziable(func) {</span>
      <span class="s2">var </span><span class="s1">funcName = getFuncName(func),</span>
          <span class="s1">other = lodash[funcName];</span>

      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">other != </span><span class="s3">'function' </span><span class="s1">|| !(funcName </span><span class="s2">in </span><span class="s1">LazyWrapper.prototype)) {</span>
        <span class="s2">return false</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(func === other) {</span>
        <span class="s2">return true</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">data = getData(other);</span>
      <span class="s2">return </span><span class="s1">!!data &amp;&amp; func === data[</span><span class="s4">0</span><span class="s1">];</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Checks if `func` has its source masked. 
     * 
     * @private 
     * @param {Function} func The function to check. 
     * @returns {boolean} Returns `true` if `func` is masked, else `false`. 
     */</span>
    <span class="s2">function </span><span class="s1">isMasked(func) {</span>
      <span class="s2">return </span><span class="s1">!!maskSrcKey &amp;&amp; (maskSrcKey </span><span class="s2">in </span><span class="s1">func);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Checks if `func` is capable of being masked. 
     * 
     * @private 
     * @param {*} value The value to check. 
     * @returns {boolean} Returns `true` if `func` is maskable, else `false`. 
     */</span>
    <span class="s2">var </span><span class="s1">isMaskable = coreJsData ? isFunction : stubFalse;</span>

    <span class="s0">/** 
     * Checks if `value` is likely a prototype object. 
     * 
     * @private 
     * @param {*} value The value to check. 
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`. 
     */</span>
    <span class="s2">function </span><span class="s1">isPrototype(value) {</span>
      <span class="s2">var </span><span class="s1">Ctor = value &amp;&amp; value.constructor,</span>
          <span class="s1">proto = (</span><span class="s2">typeof </span><span class="s1">Ctor == </span><span class="s3">'function' </span><span class="s1">&amp;&amp; Ctor.prototype) || objectProto;</span>

      <span class="s2">return </span><span class="s1">value === proto;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`. 
     * 
     * @private 
     * @param {*} value The value to check. 
     * @returns {boolean} Returns `true` if `value` if suitable for strict 
     *  equality comparisons, else `false`. 
     */</span>
    <span class="s2">function </span><span class="s1">isStrictComparable(value) {</span>
      <span class="s2">return </span><span class="s1">value === value &amp;&amp; !isObject(value);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * A specialized version of `matchesProperty` for source values suitable 
     * for strict equality comparisons, i.e. `===`. 
     * 
     * @private 
     * @param {string} key The key of the property to get. 
     * @param {*} srcValue The value to match. 
     * @returns {Function} Returns the new spec function. 
     */</span>
    <span class="s2">function </span><span class="s1">matchesStrictComparable(key, srcValue) {</span>
      <span class="s2">return function</span><span class="s1">(object) {</span>
        <span class="s2">if </span><span class="s1">(object == </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s2">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">object[key] === srcValue &amp;&amp;</span>
          <span class="s1">(srcValue !== undefined || (key </span><span class="s2">in </span><span class="s1">Object(object)));</span>
      <span class="s1">};</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * A specialized version of `_.memoize` which clears the memoized function's 
     * cache when it exceeds `MAX_MEMOIZE_SIZE`. 
     * 
     * @private 
     * @param {Function} func The function to have its output memoized. 
     * @returns {Function} Returns the new memoized function. 
     */</span>
    <span class="s2">function </span><span class="s1">memoizeCapped(func) {</span>
      <span class="s2">var </span><span class="s1">result = memoize(func, </span><span class="s2">function</span><span class="s1">(key) {</span>
        <span class="s2">if </span><span class="s1">(cache.size === MAX_MEMOIZE_SIZE) {</span>
          <span class="s1">cache.clear();</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">key;</span>
      <span class="s1">});</span>

      <span class="s2">var </span><span class="s1">cache = result.cache;</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Merges the function metadata of `source` into `data`. 
     * 
     * Merging metadata reduces the number of wrappers used to invoke a function. 
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial` 
     * may be applied regardless of execution order. Methods like `_.ary` and 
     * `_.rearg` modify function arguments, making the order in which they are 
     * executed important, preventing the merging of metadata. However, we make 
     * an exception for a safe combined case where curried functions have `_.ary` 
     * and or `_.rearg` applied. 
     * 
     * @private 
     * @param {Array} data The destination metadata. 
     * @param {Array} source The source metadata. 
     * @returns {Array} Returns `data`. 
     */</span>
    <span class="s2">function </span><span class="s1">mergeData(data, source) {</span>
      <span class="s2">var </span><span class="s1">bitmask = data[</span><span class="s4">1</span><span class="s1">],</span>
          <span class="s1">srcBitmask = source[</span><span class="s4">1</span><span class="s1">],</span>
          <span class="s1">newBitmask = bitmask | srcBitmask,</span>
          <span class="s1">isCommon = newBitmask &lt; (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);</span>

      <span class="s2">var </span><span class="s1">isCombo =</span>
        <span class="s1">((srcBitmask == WRAP_ARY_FLAG) &amp;&amp; (bitmask == WRAP_CURRY_FLAG)) ||</span>
        <span class="s1">((srcBitmask == WRAP_ARY_FLAG) &amp;&amp; (bitmask == WRAP_REARG_FLAG) &amp;&amp; (data[</span><span class="s4">7</span><span class="s1">].length &lt;= source[</span><span class="s4">8</span><span class="s1">])) ||</span>
        <span class="s1">((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) &amp;&amp; (source[</span><span class="s4">7</span><span class="s1">].length &lt;= source[</span><span class="s4">8</span><span class="s1">]) &amp;&amp; (bitmask == WRAP_CURRY_FLAG));</span>

      <span class="s0">// Exit early if metadata can't be merged.</span>
      <span class="s2">if </span><span class="s1">(!(isCommon || isCombo)) {</span>
        <span class="s2">return </span><span class="s1">data;</span>
      <span class="s1">}</span>
      <span class="s0">// Use source `thisArg` if available.</span>
      <span class="s2">if </span><span class="s1">(srcBitmask &amp; WRAP_BIND_FLAG) {</span>
        <span class="s1">data[</span><span class="s4">2</span><span class="s1">] = source[</span><span class="s4">2</span><span class="s1">];</span>
        <span class="s0">// Set when currying a bound function.</span>
        <span class="s1">newBitmask |= bitmask &amp; WRAP_BIND_FLAG ? </span><span class="s4">0 </span><span class="s1">: WRAP_CURRY_BOUND_FLAG;</span>
      <span class="s1">}</span>
      <span class="s0">// Compose partial arguments.</span>
      <span class="s2">var </span><span class="s1">value = source[</span><span class="s4">3</span><span class="s1">];</span>
      <span class="s2">if </span><span class="s1">(value) {</span>
        <span class="s2">var </span><span class="s1">partials = data[</span><span class="s4">3</span><span class="s1">];</span>
        <span class="s1">data[</span><span class="s4">3</span><span class="s1">] = partials ? composeArgs(partials, value, source[</span><span class="s4">4</span><span class="s1">]) : value;</span>
        <span class="s1">data[</span><span class="s4">4</span><span class="s1">] = partials ? replaceHolders(data[</span><span class="s4">3</span><span class="s1">], PLACEHOLDER) : source[</span><span class="s4">4</span><span class="s1">];</span>
      <span class="s1">}</span>
      <span class="s0">// Compose partial right arguments.</span>
      <span class="s1">value = source[</span><span class="s4">5</span><span class="s1">];</span>
      <span class="s2">if </span><span class="s1">(value) {</span>
        <span class="s1">partials = data[</span><span class="s4">5</span><span class="s1">];</span>
        <span class="s1">data[</span><span class="s4">5</span><span class="s1">] = partials ? composeArgsRight(partials, value, source[</span><span class="s4">6</span><span class="s1">]) : value;</span>
        <span class="s1">data[</span><span class="s4">6</span><span class="s1">] = partials ? replaceHolders(data[</span><span class="s4">5</span><span class="s1">], PLACEHOLDER) : source[</span><span class="s4">6</span><span class="s1">];</span>
      <span class="s1">}</span>
      <span class="s0">// Use source `argPos` if available.</span>
      <span class="s1">value = source[</span><span class="s4">7</span><span class="s1">];</span>
      <span class="s2">if </span><span class="s1">(value) {</span>
        <span class="s1">data[</span><span class="s4">7</span><span class="s1">] = value;</span>
      <span class="s1">}</span>
      <span class="s0">// Use source `ary` if it's smaller.</span>
      <span class="s2">if </span><span class="s1">(srcBitmask &amp; WRAP_ARY_FLAG) {</span>
        <span class="s1">data[</span><span class="s4">8</span><span class="s1">] = data[</span><span class="s4">8</span><span class="s1">] == </span><span class="s2">null </span><span class="s1">? source[</span><span class="s4">8</span><span class="s1">] : nativeMin(data[</span><span class="s4">8</span><span class="s1">], source[</span><span class="s4">8</span><span class="s1">]);</span>
      <span class="s1">}</span>
      <span class="s0">// Use source `arity` if one is not provided.</span>
      <span class="s2">if </span><span class="s1">(data[</span><span class="s4">9</span><span class="s1">] == </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">data[</span><span class="s4">9</span><span class="s1">] = source[</span><span class="s4">9</span><span class="s1">];</span>
      <span class="s1">}</span>
      <span class="s0">// Use source `func` and merge bitmasks.</span>
      <span class="s1">data[</span><span class="s4">0</span><span class="s1">] = source[</span><span class="s4">0</span><span class="s1">];</span>
      <span class="s1">data[</span><span class="s4">1</span><span class="s1">] = newBitmask;</span>

      <span class="s2">return </span><span class="s1">data;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * This function is like 
     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys) 
     * except that it includes inherited enumerable properties. 
     * 
     * @private 
     * @param {Object} object The object to query. 
     * @returns {Array} Returns the array of property names. 
     */</span>
    <span class="s2">function </span><span class="s1">nativeKeysIn(object) {</span>
      <span class="s2">var </span><span class="s1">result = [];</span>
      <span class="s2">if </span><span class="s1">(object != </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">key </span><span class="s2">in </span><span class="s1">Object(object)) {</span>
          <span class="s1">result.push(key);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Converts `value` to a string using `Object.prototype.toString`. 
     * 
     * @private 
     * @param {*} value The value to convert. 
     * @returns {string} Returns the converted string. 
     */</span>
    <span class="s2">function </span><span class="s1">objectToString(value) {</span>
      <span class="s2">return </span><span class="s1">nativeObjectToString.call(value);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * A specialized version of `baseRest` which transforms the rest array. 
     * 
     * @private 
     * @param {Function} func The function to apply a rest parameter to. 
     * @param {number} [start=func.length-1] The start position of the rest parameter. 
     * @param {Function} transform The rest array transform. 
     * @returns {Function} Returns the new function. 
     */</span>
    <span class="s2">function </span><span class="s1">overRest(func, start, transform) {</span>
      <span class="s1">start = nativeMax(start === undefined ? (func.length - </span><span class="s4">1</span><span class="s1">) : start, </span><span class="s4">0</span><span class="s1">);</span>
      <span class="s2">return function</span><span class="s1">() {</span>
        <span class="s2">var </span><span class="s1">args = arguments,</span>
            <span class="s1">index = -</span><span class="s4">1</span><span class="s1">,</span>
            <span class="s1">length = nativeMax(args.length - start, </span><span class="s4">0</span><span class="s1">),</span>
            <span class="s1">array = Array(length);</span>

        <span class="s2">while </span><span class="s1">(++index &lt; length) {</span>
          <span class="s1">array[index] = args[start + index];</span>
        <span class="s1">}</span>
        <span class="s1">index = -</span><span class="s4">1</span><span class="s1">;</span>
        <span class="s2">var </span><span class="s1">otherArgs = Array(start + </span><span class="s4">1</span><span class="s1">);</span>
        <span class="s2">while </span><span class="s1">(++index &lt; start) {</span>
          <span class="s1">otherArgs[index] = args[index];</span>
        <span class="s1">}</span>
        <span class="s1">otherArgs[start] = transform(array);</span>
        <span class="s2">return </span><span class="s1">apply(func, </span><span class="s2">this</span><span class="s1">, otherArgs);</span>
      <span class="s1">};</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Gets the parent value at `path` of `object`. 
     * 
     * @private 
     * @param {Object} object The object to query. 
     * @param {Array} path The path to get the parent value of. 
     * @returns {*} Returns the parent value. 
     */</span>
    <span class="s2">function </span><span class="s1">parent(object, path) {</span>
      <span class="s2">return </span><span class="s1">path.length &lt; </span><span class="s4">2 </span><span class="s1">? object : baseGet(object, baseSlice(path, </span><span class="s4">0</span><span class="s1">, -</span><span class="s4">1</span><span class="s1">));</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Reorder `array` according to the specified indexes where the element at 
     * the first index is assigned as the first element, the element at 
     * the second index is assigned as the second element, and so on. 
     * 
     * @private 
     * @param {Array} array The array to reorder. 
     * @param {Array} indexes The arranged array indexes. 
     * @returns {Array} Returns `array`. 
     */</span>
    <span class="s2">function </span><span class="s1">reorder(array, indexes) {</span>
      <span class="s2">var </span><span class="s1">arrLength = array.length,</span>
          <span class="s1">length = nativeMin(indexes.length, arrLength),</span>
          <span class="s1">oldArray = copyArray(array);</span>

      <span class="s2">while </span><span class="s1">(length--) {</span>
        <span class="s2">var </span><span class="s1">index = indexes[length];</span>
        <span class="s1">array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">array;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Gets the value at `key`, unless `key` is &quot;__proto__&quot; or &quot;constructor&quot;. 
     * 
     * @private 
     * @param {Object} object The object to query. 
     * @param {string} key The key of the property to get. 
     * @returns {*} Returns the property value. 
     */</span>
    <span class="s2">function </span><span class="s1">safeGet(object, key) {</span>
      <span class="s2">if </span><span class="s1">(key === </span><span class="s3">'constructor' </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">object[key] === </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(key == </span><span class="s3">'__proto__'</span><span class="s1">) {</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">return </span><span class="s1">object[key];</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Sets metadata for `func`. 
     * 
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short 
     * period of time, it will trip its breaker and transition to an identity 
     * function to avoid garbage collection pauses in V8. See 
     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070) 
     * for more details. 
     * 
     * @private 
     * @param {Function} func The function to associate metadata with. 
     * @param {*} data The metadata. 
     * @returns {Function} Returns `func`. 
     */</span>
    <span class="s2">var </span><span class="s1">setData = shortOut(baseSetData);</span>

    <span class="s0">/** 
     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout). 
     * 
     * @private 
     * @param {Function} func The function to delay. 
     * @param {number} wait The number of milliseconds to delay invocation. 
     * @returns {number|Object} Returns the timer id or timeout object. 
     */</span>
    <span class="s2">var </span><span class="s1">setTimeout = ctxSetTimeout || </span><span class="s2">function</span><span class="s1">(func, wait) {</span>
      <span class="s2">return </span><span class="s1">root.setTimeout(func, wait);</span>
    <span class="s1">};</span>

    <span class="s0">/** 
     * Sets the `toString` method of `func` to return `string`. 
     * 
     * @private 
     * @param {Function} func The function to modify. 
     * @param {Function} string The `toString` result. 
     * @returns {Function} Returns `func`. 
     */</span>
    <span class="s2">var </span><span class="s1">setToString = shortOut(baseSetToString);</span>

    <span class="s0">/** 
     * Sets the `toString` method of `wrapper` to mimic the source of `reference` 
     * with wrapper details in a comment at the top of the source body. 
     * 
     * @private 
     * @param {Function} wrapper The function to modify. 
     * @param {Function} reference The reference function. 
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details. 
     * @returns {Function} Returns `wrapper`. 
     */</span>
    <span class="s2">function </span><span class="s1">setWrapToString(wrapper, reference, bitmask) {</span>
      <span class="s2">var </span><span class="s1">source = (reference + </span><span class="s3">''</span><span class="s1">);</span>
      <span class="s2">return </span><span class="s1">setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a function that'll short out and invoke `identity` instead 
     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN` 
     * milliseconds. 
     * 
     * @private 
     * @param {Function} func The function to restrict. 
     * @returns {Function} Returns the new shortable function. 
     */</span>
    <span class="s2">function </span><span class="s1">shortOut(func) {</span>
      <span class="s2">var </span><span class="s1">count = </span><span class="s4">0</span><span class="s1">,</span>
          <span class="s1">lastCalled = </span><span class="s4">0</span><span class="s1">;</span>

      <span class="s2">return function</span><span class="s1">() {</span>
        <span class="s2">var </span><span class="s1">stamp = nativeNow(),</span>
            <span class="s1">remaining = HOT_SPAN - (stamp - lastCalled);</span>

        <span class="s1">lastCalled = stamp;</span>
        <span class="s2">if </span><span class="s1">(remaining &gt; </span><span class="s4">0</span><span class="s1">) {</span>
          <span class="s2">if </span><span class="s1">(++count &gt;= HOT_COUNT) {</span>
            <span class="s2">return </span><span class="s1">arguments[</span><span class="s4">0</span><span class="s1">];</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">count = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">func.apply(undefined, arguments);</span>
      <span class="s1">};</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * A specialized version of `_.shuffle` which mutates and sets the size of `array`. 
     * 
     * @private 
     * @param {Array} array The array to shuffle. 
     * @param {number} [size=array.length] The size of `array`. 
     * @returns {Array} Returns `array`. 
     */</span>
    <span class="s2">function </span><span class="s1">shuffleSelf(array, size) {</span>
      <span class="s2">var </span><span class="s1">index = -</span><span class="s4">1</span><span class="s1">,</span>
          <span class="s1">length = array.length,</span>
          <span class="s1">lastIndex = length - </span><span class="s4">1</span><span class="s1">;</span>

      <span class="s1">size = size === undefined ? length : size;</span>
      <span class="s2">while </span><span class="s1">(++index &lt; size) {</span>
        <span class="s2">var </span><span class="s1">rand = baseRandom(index, lastIndex),</span>
            <span class="s1">value = array[rand];</span>

        <span class="s1">array[rand] = array[index];</span>
        <span class="s1">array[index] = value;</span>
      <span class="s1">}</span>
      <span class="s1">array.length = size;</span>
      <span class="s2">return </span><span class="s1">array;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Converts `string` to a property path array. 
     * 
     * @private 
     * @param {string} string The string to convert. 
     * @returns {Array} Returns the property path array. 
     */</span>
    <span class="s2">var </span><span class="s1">stringToPath = memoizeCapped(</span><span class="s2">function</span><span class="s1">(string) {</span>
      <span class="s2">var </span><span class="s1">result = [];</span>
      <span class="s2">if </span><span class="s1">(string.charCodeAt(</span><span class="s4">0</span><span class="s1">) === </span><span class="s4">46 </span><span class="s0">/* . */</span><span class="s1">) {</span>
        <span class="s1">result.push(</span><span class="s3">''</span><span class="s1">);</span>
      <span class="s1">}</span>
      <span class="s1">string.replace(rePropName, </span><span class="s2">function</span><span class="s1">(match, number, quote, subString) {</span>
        <span class="s1">result.push(quote ? subString.replace(reEscapeChar, </span><span class="s3">'$1'</span><span class="s1">) : (number || match));</span>
      <span class="s1">});</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">});</span>

    <span class="s0">/** 
     * Converts `value` to a string key if it's not a string or symbol. 
     * 
     * @private 
     * @param {*} value The value to inspect. 
     * @returns {string|symbol} Returns the key. 
     */</span>
    <span class="s2">function </span><span class="s1">toKey(value) {</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">value == </span><span class="s3">'string' </span><span class="s1">|| isSymbol(value)) {</span>
        <span class="s2">return </span><span class="s1">value;</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">result = (value + </span><span class="s3">''</span><span class="s1">);</span>
      <span class="s2">return </span><span class="s1">(result == </span><span class="s3">'0' </span><span class="s1">&amp;&amp; (</span><span class="s4">1 </span><span class="s1">/ value) == -INFINITY) ? </span><span class="s3">'-0' </span><span class="s1">: result;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Converts `func` to its source code. 
     * 
     * @private 
     * @param {Function} func The function to convert. 
     * @returns {string} Returns the source code. 
     */</span>
    <span class="s2">function </span><span class="s1">toSource(func) {</span>
      <span class="s2">if </span><span class="s1">(func != </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">try </span><span class="s1">{</span>
          <span class="s2">return </span><span class="s1">funcToString.call(func);</span>
        <span class="s1">} </span><span class="s2">catch </span><span class="s1">(e) {}</span>
        <span class="s2">try </span><span class="s1">{</span>
          <span class="s2">return </span><span class="s1">(func + </span><span class="s3">''</span><span class="s1">);</span>
        <span class="s1">} </span><span class="s2">catch </span><span class="s1">(e) {}</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s3">''</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Updates wrapper `details` based on `bitmask` flags. 
     * 
     * @private 
     * @returns {Array} details The details to modify. 
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details. 
     * @returns {Array} Returns `details`. 
     */</span>
    <span class="s2">function </span><span class="s1">updateWrapDetails(details, bitmask) {</span>
      <span class="s1">arrayEach(wrapFlags, </span><span class="s2">function</span><span class="s1">(pair) {</span>
        <span class="s2">var </span><span class="s1">value = </span><span class="s3">'_.' </span><span class="s1">+ pair[</span><span class="s4">0</span><span class="s1">];</span>
        <span class="s2">if </span><span class="s1">((bitmask &amp; pair[</span><span class="s4">1</span><span class="s1">]) &amp;&amp; !arrayIncludes(details, value)) {</span>
          <span class="s1">details.push(value);</span>
        <span class="s1">}</span>
      <span class="s1">});</span>
      <span class="s2">return </span><span class="s1">details.sort();</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a clone of `wrapper`. 
     * 
     * @private 
     * @param {Object} wrapper The wrapper to clone. 
     * @returns {Object} Returns the cloned wrapper. 
     */</span>
    <span class="s2">function </span><span class="s1">wrapperClone(wrapper) {</span>
      <span class="s2">if </span><span class="s1">(wrapper </span><span class="s2">instanceof </span><span class="s1">LazyWrapper) {</span>
        <span class="s2">return </span><span class="s1">wrapper.clone();</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">result = </span><span class="s2">new </span><span class="s1">LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);</span>
      <span class="s1">result.__actions__ = copyArray(wrapper.__actions__);</span>
      <span class="s1">result.__index__  = wrapper.__index__;</span>
      <span class="s1">result.__values__ = wrapper.__values__;</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>

    <span class="s0">/*------------------------------------------------------------------------*/</span>

    <span class="s0">/** 
     * Creates an array of elements split into groups the length of `size`. 
     * If `array` can't be split evenly, the final chunk will be the remaining 
     * elements. 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.0.0 
     * @category Array 
     * @param {Array} array The array to process. 
     * @param {number} [size=1] The length of each chunk 
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`. 
     * @returns {Array} Returns the new array of chunks. 
     * @example 
     * 
     * _.chunk(['a', 'b', 'c', 'd'], 2); 
     * // =&gt; [['a', 'b'], ['c', 'd']] 
     * 
     * _.chunk(['a', 'b', 'c', 'd'], 3); 
     * // =&gt; [['a', 'b', 'c'], ['d']] 
     */</span>
    <span class="s2">function </span><span class="s1">chunk(array, size, guard) {</span>
      <span class="s2">if </span><span class="s1">((guard ? isIterateeCall(array, size, guard) : size === undefined)) {</span>
        <span class="s1">size = </span><span class="s4">1</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">size = nativeMax(toInteger(size), </span><span class="s4">0</span><span class="s1">);</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">length = array == </span><span class="s2">null </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: array.length;</span>
      <span class="s2">if </span><span class="s1">(!length || size &lt; </span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">[];</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">index = </span><span class="s4">0</span><span class="s1">,</span>
          <span class="s1">resIndex = </span><span class="s4">0</span><span class="s1">,</span>
          <span class="s1">result = Array(nativeCeil(length / size));</span>

      <span class="s2">while </span><span class="s1">(index &lt; length) {</span>
        <span class="s1">result[resIndex++] = baseSlice(array, index, (index += size));</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates an array with all falsey values removed. The values `false`, `null`, 
     * `0`, `&quot;&quot;`, `undefined`, and `NaN` are falsey. 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.1.0 
     * @category Array 
     * @param {Array} array The array to compact. 
     * @returns {Array} Returns the new array of filtered values. 
     * @example 
     * 
     * _.compact([0, 1, false, 2, '', 3]); 
     * // =&gt; [1, 2, 3] 
     */</span>
    <span class="s2">function </span><span class="s1">compact(array) {</span>
      <span class="s2">var </span><span class="s1">index = -</span><span class="s4">1</span><span class="s1">,</span>
          <span class="s1">length = array == </span><span class="s2">null </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: array.length,</span>
          <span class="s1">resIndex = </span><span class="s4">0</span><span class="s1">,</span>
          <span class="s1">result = [];</span>

      <span class="s2">while </span><span class="s1">(++index &lt; length) {</span>
        <span class="s2">var </span><span class="s1">value = array[index];</span>
        <span class="s2">if </span><span class="s1">(value) {</span>
          <span class="s1">result[resIndex++] = value;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a new array concatenating `array` with any additional arrays 
     * and/or values. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Array 
     * @param {Array} array The array to concatenate. 
     * @param {...*} [values] The values to concatenate. 
     * @returns {Array} Returns the new concatenated array. 
     * @example 
     * 
     * var array = [1]; 
     * var other = _.concat(array, 2, [3], [[4]]); 
     * 
     * console.log(other); 
     * // =&gt; [1, 2, 3, [4]] 
     * 
     * console.log(array); 
     * // =&gt; [1] 
     */</span>
    <span class="s2">function </span><span class="s1">concat() {</span>
      <span class="s2">var </span><span class="s1">length = arguments.length;</span>
      <span class="s2">if </span><span class="s1">(!length) {</span>
        <span class="s2">return </span><span class="s1">[];</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">args = Array(length - </span><span class="s4">1</span><span class="s1">),</span>
          <span class="s1">array = arguments[</span><span class="s4">0</span><span class="s1">],</span>
          <span class="s1">index = length;</span>

      <span class="s2">while </span><span class="s1">(index--) {</span>
        <span class="s1">args[index - </span><span class="s4">1</span><span class="s1">] = arguments[index];</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, </span><span class="s4">1</span><span class="s1">));</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates an array of `array` values not included in the other given arrays 
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero) 
     * for equality comparisons. The order and references of result values are 
     * determined by the first array. 
     * 
     * **Note:** Unlike `_.pullAll`, this method returns a new array. 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.1.0 
     * @category Array 
     * @param {Array} array The array to inspect. 
     * @param {...Array} [values] The values to exclude. 
     * @returns {Array} Returns the new array of filtered values. 
     * @see _.without, _.xor 
     * @example 
     * 
     * _.difference([2, 1], [2, 3]); 
     * // =&gt; [1] 
     */</span>
    <span class="s2">var </span><span class="s1">difference = baseRest(</span><span class="s2">function</span><span class="s1">(array, values) {</span>
      <span class="s2">return </span><span class="s1">isArrayLikeObject(array)</span>
        <span class="s1">? baseDifference(array, baseFlatten(values, </span><span class="s4">1</span><span class="s1">, isArrayLikeObject, </span><span class="s2">true</span><span class="s1">))</span>
        <span class="s1">: [];</span>
    <span class="s1">});</span>

    <span class="s0">/** 
     * This method is like `_.difference` except that it accepts `iteratee` which 
     * is invoked for each element of `array` and `values` to generate the criterion 
     * by which they're compared. The order and references of result values are 
     * determined by the first array. The iteratee is invoked with one argument: 
     * (value). 
     * 
     * **Note:** Unlike `_.pullAllBy`, this method returns a new array. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Array 
     * @param {Array} array The array to inspect. 
     * @param {...Array} [values] The values to exclude. 
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element. 
     * @returns {Array} Returns the new array of filtered values. 
     * @example 
     * 
     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor); 
     * // =&gt; [1.2] 
     * 
     * // The `_.property` iteratee shorthand. 
     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x'); 
     * // =&gt; [{ 'x': 2 }] 
     */</span>
    <span class="s2">var </span><span class="s1">differenceBy = baseRest(</span><span class="s2">function</span><span class="s1">(array, values) {</span>
      <span class="s2">var </span><span class="s1">iteratee = last(values);</span>
      <span class="s2">if </span><span class="s1">(isArrayLikeObject(iteratee)) {</span>
        <span class="s1">iteratee = undefined;</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">isArrayLikeObject(array)</span>
        <span class="s1">? baseDifference(array, baseFlatten(values, </span><span class="s4">1</span><span class="s1">, isArrayLikeObject, </span><span class="s2">true</span><span class="s1">), getIteratee(iteratee, </span><span class="s4">2</span><span class="s1">))</span>
        <span class="s1">: [];</span>
    <span class="s1">});</span>

    <span class="s0">/** 
     * This method is like `_.difference` except that it accepts `comparator` 
     * which is invoked to compare elements of `array` to `values`. The order and 
     * references of result values are determined by the first array. The comparator 
     * is invoked with two arguments: (arrVal, othVal). 
     * 
     * **Note:** Unlike `_.pullAllWith`, this method returns a new array. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Array 
     * @param {Array} array The array to inspect. 
     * @param {...Array} [values] The values to exclude. 
     * @param {Function} [comparator] The comparator invoked per element. 
     * @returns {Array} Returns the new array of filtered values. 
     * @example 
     * 
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]; 
     * 
     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual); 
     * // =&gt; [{ 'x': 2, 'y': 1 }] 
     */</span>
    <span class="s2">var </span><span class="s1">differenceWith = baseRest(</span><span class="s2">function</span><span class="s1">(array, values) {</span>
      <span class="s2">var </span><span class="s1">comparator = last(values);</span>
      <span class="s2">if </span><span class="s1">(isArrayLikeObject(comparator)) {</span>
        <span class="s1">comparator = undefined;</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">isArrayLikeObject(array)</span>
        <span class="s1">? baseDifference(array, baseFlatten(values, </span><span class="s4">1</span><span class="s1">, isArrayLikeObject, </span><span class="s2">true</span><span class="s1">), undefined, comparator)</span>
        <span class="s1">: [];</span>
    <span class="s1">});</span>

    <span class="s0">/** 
     * Creates a slice of `array` with `n` elements dropped from the beginning. 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.5.0 
     * @category Array 
     * @param {Array} array The array to query. 
     * @param {number} [n=1] The number of elements to drop. 
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`. 
     * @returns {Array} Returns the slice of `array`. 
     * @example 
     * 
     * _.drop([1, 2, 3]); 
     * // =&gt; [2, 3] 
     * 
     * _.drop([1, 2, 3], 2); 
     * // =&gt; [3] 
     * 
     * _.drop([1, 2, 3], 5); 
     * // =&gt; [] 
     * 
     * _.drop([1, 2, 3], 0); 
     * // =&gt; [1, 2, 3] 
     */</span>
    <span class="s2">function </span><span class="s1">drop(array, n, guard) {</span>
      <span class="s2">var </span><span class="s1">length = array == </span><span class="s2">null </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: array.length;</span>
      <span class="s2">if </span><span class="s1">(!length) {</span>
        <span class="s2">return </span><span class="s1">[];</span>
      <span class="s1">}</span>
      <span class="s1">n = (guard || n === undefined) ? </span><span class="s4">1 </span><span class="s1">: toInteger(n);</span>
      <span class="s2">return </span><span class="s1">baseSlice(array, n &lt; </span><span class="s4">0 </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: n, length);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a slice of `array` with `n` elements dropped from the end. 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.0.0 
     * @category Array 
     * @param {Array} array The array to query. 
     * @param {number} [n=1] The number of elements to drop. 
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`. 
     * @returns {Array} Returns the slice of `array`. 
     * @example 
     * 
     * _.dropRight([1, 2, 3]); 
     * // =&gt; [1, 2] 
     * 
     * _.dropRight([1, 2, 3], 2); 
     * // =&gt; [1] 
     * 
     * _.dropRight([1, 2, 3], 5); 
     * // =&gt; [] 
     * 
     * _.dropRight([1, 2, 3], 0); 
     * // =&gt; [1, 2, 3] 
     */</span>
    <span class="s2">function </span><span class="s1">dropRight(array, n, guard) {</span>
      <span class="s2">var </span><span class="s1">length = array == </span><span class="s2">null </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: array.length;</span>
      <span class="s2">if </span><span class="s1">(!length) {</span>
        <span class="s2">return </span><span class="s1">[];</span>
      <span class="s1">}</span>
      <span class="s1">n = (guard || n === undefined) ? </span><span class="s4">1 </span><span class="s1">: toInteger(n);</span>
      <span class="s1">n = length - n;</span>
      <span class="s2">return </span><span class="s1">baseSlice(array, </span><span class="s4">0</span><span class="s1">, n &lt; </span><span class="s4">0 </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: n);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a slice of `array` excluding elements dropped from the end. 
     * Elements are dropped until `predicate` returns falsey. The predicate is 
     * invoked with three arguments: (value, index, array). 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.0.0 
     * @category Array 
     * @param {Array} array The array to query. 
     * @param {Function} [predicate=_.identity] The function invoked per iteration. 
     * @returns {Array} Returns the slice of `array`. 
     * @example 
     * 
     * var users = [ 
     *   { 'user': 'barney',  'active': true }, 
     *   { 'user': 'fred',    'active': false }, 
     *   { 'user': 'pebbles', 'active': false } 
     * ]; 
     * 
     * _.dropRightWhile(users, function(o) { return !o.active; }); 
     * // =&gt; objects for ['barney'] 
     * 
     * // The `_.matches` iteratee shorthand. 
     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false }); 
     * // =&gt; objects for ['barney', 'fred'] 
     * 
     * // The `_.matchesProperty` iteratee shorthand. 
     * _.dropRightWhile(users, ['active', false]); 
     * // =&gt; objects for ['barney'] 
     * 
     * // The `_.property` iteratee shorthand. 
     * _.dropRightWhile(users, 'active'); 
     * // =&gt; objects for ['barney', 'fred', 'pebbles'] 
     */</span>
    <span class="s2">function </span><span class="s1">dropRightWhile(array, predicate) {</span>
      <span class="s2">return </span><span class="s1">(array &amp;&amp; array.length)</span>
        <span class="s1">? baseWhile(array, getIteratee(predicate, </span><span class="s4">3</span><span class="s1">), </span><span class="s2">true</span><span class="s1">, </span><span class="s2">true</span><span class="s1">)</span>
        <span class="s1">: [];</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a slice of `array` excluding elements dropped from the beginning. 
     * Elements are dropped until `predicate` returns falsey. The predicate is 
     * invoked with three arguments: (value, index, array). 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.0.0 
     * @category Array 
     * @param {Array} array The array to query. 
     * @param {Function} [predicate=_.identity] The function invoked per iteration. 
     * @returns {Array} Returns the slice of `array`. 
     * @example 
     * 
     * var users = [ 
     *   { 'user': 'barney',  'active': false }, 
     *   { 'user': 'fred',    'active': false }, 
     *   { 'user': 'pebbles', 'active': true } 
     * ]; 
     * 
     * _.dropWhile(users, function(o) { return !o.active; }); 
     * // =&gt; objects for ['pebbles'] 
     * 
     * // The `_.matches` iteratee shorthand. 
     * _.dropWhile(users, { 'user': 'barney', 'active': false }); 
     * // =&gt; objects for ['fred', 'pebbles'] 
     * 
     * // The `_.matchesProperty` iteratee shorthand. 
     * _.dropWhile(users, ['active', false]); 
     * // =&gt; objects for ['pebbles'] 
     * 
     * // The `_.property` iteratee shorthand. 
     * _.dropWhile(users, 'active'); 
     * // =&gt; objects for ['barney', 'fred', 'pebbles'] 
     */</span>
    <span class="s2">function </span><span class="s1">dropWhile(array, predicate) {</span>
      <span class="s2">return </span><span class="s1">(array &amp;&amp; array.length)</span>
        <span class="s1">? baseWhile(array, getIteratee(predicate, </span><span class="s4">3</span><span class="s1">), </span><span class="s2">true</span><span class="s1">)</span>
        <span class="s1">: [];</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Fills elements of `array` with `value` from `start` up to, but not 
     * including, `end`. 
     * 
     * **Note:** This method mutates `array`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.2.0 
     * @category Array 
     * @param {Array} array The array to fill. 
     * @param {*} value The value to fill `array` with. 
     * @param {number} [start=0] The start position. 
     * @param {number} [end=array.length] The end position. 
     * @returns {Array} Returns `array`. 
     * @example 
     * 
     * var array = [1, 2, 3]; 
     * 
     * _.fill(array, 'a'); 
     * console.log(array); 
     * // =&gt; ['a', 'a', 'a'] 
     * 
     * _.fill(Array(3), 2); 
     * // =&gt; [2, 2, 2] 
     * 
     * _.fill([4, 6, 8, 10], '*', 1, 3); 
     * // =&gt; [4, '*', '*', 10] 
     */</span>
    <span class="s2">function </span><span class="s1">fill(array, value, start, end) {</span>
      <span class="s2">var </span><span class="s1">length = array == </span><span class="s2">null </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: array.length;</span>
      <span class="s2">if </span><span class="s1">(!length) {</span>
        <span class="s2">return </span><span class="s1">[];</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(start &amp;&amp; </span><span class="s2">typeof </span><span class="s1">start != </span><span class="s3">'number' </span><span class="s1">&amp;&amp; isIterateeCall(array, value, start)) {</span>
        <span class="s1">start = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">end = length;</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">baseFill(array, value, start, end);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * This method is like `_.find` except that it returns the index of the first 
     * element `predicate` returns truthy for instead of the element itself. 
     * 
     * @static 
     * @memberOf _ 
     * @since 1.1.0 
     * @category Array 
     * @param {Array} array The array to inspect. 
     * @param {Function} [predicate=_.identity] The function invoked per iteration. 
     * @param {number} [fromIndex=0] The index to search from. 
     * @returns {number} Returns the index of the found element, else `-1`. 
     * @example 
     * 
     * var users = [ 
     *   { 'user': 'barney',  'active': false }, 
     *   { 'user': 'fred',    'active': false }, 
     *   { 'user': 'pebbles', 'active': true } 
     * ]; 
     * 
     * _.findIndex(users, function(o) { return o.user == 'barney'; }); 
     * // =&gt; 0 
     * 
     * // The `_.matches` iteratee shorthand. 
     * _.findIndex(users, { 'user': 'fred', 'active': false }); 
     * // =&gt; 1 
     * 
     * // The `_.matchesProperty` iteratee shorthand. 
     * _.findIndex(users, ['active', false]); 
     * // =&gt; 0 
     * 
     * // The `_.property` iteratee shorthand. 
     * _.findIndex(users, 'active'); 
     * // =&gt; 2 
     */</span>
    <span class="s2">function </span><span class="s1">findIndex(array, predicate, fromIndex) {</span>
      <span class="s2">var </span><span class="s1">length = array == </span><span class="s2">null </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: array.length;</span>
      <span class="s2">if </span><span class="s1">(!length) {</span>
        <span class="s2">return </span><span class="s1">-</span><span class="s4">1</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">index = fromIndex == </span><span class="s2">null </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: toInteger(fromIndex);</span>
      <span class="s2">if </span><span class="s1">(index &lt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">index = nativeMax(length + index, </span><span class="s4">0</span><span class="s1">);</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">baseFindIndex(array, getIteratee(predicate, </span><span class="s4">3</span><span class="s1">), index);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * This method is like `_.findIndex` except that it iterates over elements 
     * of `collection` from right to left. 
     * 
     * @static 
     * @memberOf _ 
     * @since 2.0.0 
     * @category Array 
     * @param {Array} array The array to inspect. 
     * @param {Function} [predicate=_.identity] The function invoked per iteration. 
     * @param {number} [fromIndex=array.length-1] The index to search from. 
     * @returns {number} Returns the index of the found element, else `-1`. 
     * @example 
     * 
     * var users = [ 
     *   { 'user': 'barney',  'active': true }, 
     *   { 'user': 'fred',    'active': false }, 
     *   { 'user': 'pebbles', 'active': false } 
     * ]; 
     * 
     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; }); 
     * // =&gt; 2 
     * 
     * // The `_.matches` iteratee shorthand. 
     * _.findLastIndex(users, { 'user': 'barney', 'active': true }); 
     * // =&gt; 0 
     * 
     * // The `_.matchesProperty` iteratee shorthand. 
     * _.findLastIndex(users, ['active', false]); 
     * // =&gt; 2 
     * 
     * // The `_.property` iteratee shorthand. 
     * _.findLastIndex(users, 'active'); 
     * // =&gt; 0 
     */</span>
    <span class="s2">function </span><span class="s1">findLastIndex(array, predicate, fromIndex) {</span>
      <span class="s2">var </span><span class="s1">length = array == </span><span class="s2">null </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: array.length;</span>
      <span class="s2">if </span><span class="s1">(!length) {</span>
        <span class="s2">return </span><span class="s1">-</span><span class="s4">1</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">index = length - </span><span class="s4">1</span><span class="s1">;</span>
      <span class="s2">if </span><span class="s1">(fromIndex !== undefined) {</span>
        <span class="s1">index = toInteger(fromIndex);</span>
        <span class="s1">index = fromIndex &lt; </span><span class="s4">0</span>
          <span class="s1">? nativeMax(length + index, </span><span class="s4">0</span><span class="s1">)</span>
          <span class="s1">: nativeMin(index, length - </span><span class="s4">1</span><span class="s1">);</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">baseFindIndex(array, getIteratee(predicate, </span><span class="s4">3</span><span class="s1">), index, </span><span class="s2">true</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Flattens `array` a single level deep. 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.1.0 
     * @category Array 
     * @param {Array} array The array to flatten. 
     * @returns {Array} Returns the new flattened array. 
     * @example 
     * 
     * _.flatten([1, [2, [3, [4]], 5]]); 
     * // =&gt; [1, 2, [3, [4]], 5] 
     */</span>
    <span class="s2">function </span><span class="s1">flatten(array) {</span>
      <span class="s2">var </span><span class="s1">length = array == </span><span class="s2">null </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: array.length;</span>
      <span class="s2">return </span><span class="s1">length ? baseFlatten(array, </span><span class="s4">1</span><span class="s1">) : [];</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Recursively flattens `array`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.0.0 
     * @category Array 
     * @param {Array} array The array to flatten. 
     * @returns {Array} Returns the new flattened array. 
     * @example 
     * 
     * _.flattenDeep([1, [2, [3, [4]], 5]]); 
     * // =&gt; [1, 2, 3, 4, 5] 
     */</span>
    <span class="s2">function </span><span class="s1">flattenDeep(array) {</span>
      <span class="s2">var </span><span class="s1">length = array == </span><span class="s2">null </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: array.length;</span>
      <span class="s2">return </span><span class="s1">length ? baseFlatten(array, INFINITY) : [];</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Recursively flatten `array` up to `depth` times. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.4.0 
     * @category Array 
     * @param {Array} array The array to flatten. 
     * @param {number} [depth=1] The maximum recursion depth. 
     * @returns {Array} Returns the new flattened array. 
     * @example 
     * 
     * var array = [1, [2, [3, [4]], 5]]; 
     * 
     * _.flattenDepth(array, 1); 
     * // =&gt; [1, 2, [3, [4]], 5] 
     * 
     * _.flattenDepth(array, 2); 
     * // =&gt; [1, 2, 3, [4], 5] 
     */</span>
    <span class="s2">function </span><span class="s1">flattenDepth(array, depth) {</span>
      <span class="s2">var </span><span class="s1">length = array == </span><span class="s2">null </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: array.length;</span>
      <span class="s2">if </span><span class="s1">(!length) {</span>
        <span class="s2">return </span><span class="s1">[];</span>
      <span class="s1">}</span>
      <span class="s1">depth = depth === undefined ? </span><span class="s4">1 </span><span class="s1">: toInteger(depth);</span>
      <span class="s2">return </span><span class="s1">baseFlatten(array, depth);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The inverse of `_.toPairs`; this method returns an object composed 
     * from key-value `pairs`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Array 
     * @param {Array} pairs The key-value pairs. 
     * @returns {Object} Returns the new object. 
     * @example 
     * 
     * _.fromPairs([['a', 1], ['b', 2]]); 
     * // =&gt; { 'a': 1, 'b': 2 } 
     */</span>
    <span class="s2">function </span><span class="s1">fromPairs(pairs) {</span>
      <span class="s2">var </span><span class="s1">index = -</span><span class="s4">1</span><span class="s1">,</span>
          <span class="s1">length = pairs == </span><span class="s2">null </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: pairs.length,</span>
          <span class="s1">result = {};</span>

      <span class="s2">while </span><span class="s1">(++index &lt; length) {</span>
        <span class="s2">var </span><span class="s1">pair = pairs[index];</span>
        <span class="s1">result[pair[</span><span class="s4">0</span><span class="s1">]] = pair[</span><span class="s4">1</span><span class="s1">];</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Gets the first element of `array`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.1.0 
     * @alias first 
     * @category Array 
     * @param {Array} array The array to query. 
     * @returns {*} Returns the first element of `array`. 
     * @example 
     * 
     * _.head([1, 2, 3]); 
     * // =&gt; 1 
     * 
     * _.head([]); 
     * // =&gt; undefined 
     */</span>
    <span class="s2">function </span><span class="s1">head(array) {</span>
      <span class="s2">return </span><span class="s1">(array &amp;&amp; array.length) ? array[</span><span class="s4">0</span><span class="s1">] : undefined;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Gets the index at which the first occurrence of `value` is found in `array` 
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero) 
     * for equality comparisons. If `fromIndex` is negative, it's used as the 
     * offset from the end of `array`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.1.0 
     * @category Array 
     * @param {Array} array The array to inspect. 
     * @param {*} value The value to search for. 
     * @param {number} [fromIndex=0] The index to search from. 
     * @returns {number} Returns the index of the matched value, else `-1`. 
     * @example 
     * 
     * _.indexOf([1, 2, 1, 2], 2); 
     * // =&gt; 1 
     * 
     * // Search from the `fromIndex`. 
     * _.indexOf([1, 2, 1, 2], 2, 2); 
     * // =&gt; 3 
     */</span>
    <span class="s2">function </span><span class="s1">indexOf(array, value, fromIndex) {</span>
      <span class="s2">var </span><span class="s1">length = array == </span><span class="s2">null </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: array.length;</span>
      <span class="s2">if </span><span class="s1">(!length) {</span>
        <span class="s2">return </span><span class="s1">-</span><span class="s4">1</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">index = fromIndex == </span><span class="s2">null </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: toInteger(fromIndex);</span>
      <span class="s2">if </span><span class="s1">(index &lt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">index = nativeMax(length + index, </span><span class="s4">0</span><span class="s1">);</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">baseIndexOf(array, value, index);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Gets all but the last element of `array`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.1.0 
     * @category Array 
     * @param {Array} array The array to query. 
     * @returns {Array} Returns the slice of `array`. 
     * @example 
     * 
     * _.initial([1, 2, 3]); 
     * // =&gt; [1, 2] 
     */</span>
    <span class="s2">function </span><span class="s1">initial(array) {</span>
      <span class="s2">var </span><span class="s1">length = array == </span><span class="s2">null </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: array.length;</span>
      <span class="s2">return </span><span class="s1">length ? baseSlice(array, </span><span class="s4">0</span><span class="s1">, -</span><span class="s4">1</span><span class="s1">) : [];</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates an array of unique values that are included in all given arrays 
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero) 
     * for equality comparisons. The order and references of result values are 
     * determined by the first array. 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.1.0 
     * @category Array 
     * @param {...Array} [arrays] The arrays to inspect. 
     * @returns {Array} Returns the new array of intersecting values. 
     * @example 
     * 
     * _.intersection([2, 1], [2, 3]); 
     * // =&gt; [2] 
     */</span>
    <span class="s2">var </span><span class="s1">intersection = baseRest(</span><span class="s2">function</span><span class="s1">(arrays) {</span>
      <span class="s2">var </span><span class="s1">mapped = arrayMap(arrays, castArrayLikeObject);</span>
      <span class="s2">return </span><span class="s1">(mapped.length &amp;&amp; mapped[</span><span class="s4">0</span><span class="s1">] === arrays[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">? baseIntersection(mapped)</span>
        <span class="s1">: [];</span>
    <span class="s1">});</span>

    <span class="s0">/** 
     * This method is like `_.intersection` except that it accepts `iteratee` 
     * which is invoked for each element of each `arrays` to generate the criterion 
     * by which they're compared. The order and references of result values are 
     * determined by the first array. The iteratee is invoked with one argument: 
     * (value). 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Array 
     * @param {...Array} [arrays] The arrays to inspect. 
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element. 
     * @returns {Array} Returns the new array of intersecting values. 
     * @example 
     * 
     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor); 
     * // =&gt; [2.1] 
     * 
     * // The `_.property` iteratee shorthand. 
     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x'); 
     * // =&gt; [{ 'x': 1 }] 
     */</span>
    <span class="s2">var </span><span class="s1">intersectionBy = baseRest(</span><span class="s2">function</span><span class="s1">(arrays) {</span>
      <span class="s2">var </span><span class="s1">iteratee = last(arrays),</span>
          <span class="s1">mapped = arrayMap(arrays, castArrayLikeObject);</span>

      <span class="s2">if </span><span class="s1">(iteratee === last(mapped)) {</span>
        <span class="s1">iteratee = undefined;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">mapped.pop();</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">(mapped.length &amp;&amp; mapped[</span><span class="s4">0</span><span class="s1">] === arrays[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">? baseIntersection(mapped, getIteratee(iteratee, </span><span class="s4">2</span><span class="s1">))</span>
        <span class="s1">: [];</span>
    <span class="s1">});</span>

    <span class="s0">/** 
     * This method is like `_.intersection` except that it accepts `comparator` 
     * which is invoked to compare elements of `arrays`. The order and references 
     * of result values are determined by the first array. The comparator is 
     * invoked with two arguments: (arrVal, othVal). 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Array 
     * @param {...Array} [arrays] The arrays to inspect. 
     * @param {Function} [comparator] The comparator invoked per element. 
     * @returns {Array} Returns the new array of intersecting values. 
     * @example 
     * 
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]; 
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }]; 
     * 
     * _.intersectionWith(objects, others, _.isEqual); 
     * // =&gt; [{ 'x': 1, 'y': 2 }] 
     */</span>
    <span class="s2">var </span><span class="s1">intersectionWith = baseRest(</span><span class="s2">function</span><span class="s1">(arrays) {</span>
      <span class="s2">var </span><span class="s1">comparator = last(arrays),</span>
          <span class="s1">mapped = arrayMap(arrays, castArrayLikeObject);</span>

      <span class="s1">comparator = </span><span class="s2">typeof </span><span class="s1">comparator == </span><span class="s3">'function' </span><span class="s1">? comparator : undefined;</span>
      <span class="s2">if </span><span class="s1">(comparator) {</span>
        <span class="s1">mapped.pop();</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">(mapped.length &amp;&amp; mapped[</span><span class="s4">0</span><span class="s1">] === arrays[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">? baseIntersection(mapped, undefined, comparator)</span>
        <span class="s1">: [];</span>
    <span class="s1">});</span>

    <span class="s0">/** 
     * Converts all elements in `array` into a string separated by `separator`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Array 
     * @param {Array} array The array to convert. 
     * @param {string} [separator=','] The element separator. 
     * @returns {string} Returns the joined string. 
     * @example 
     * 
     * _.join(['a', 'b', 'c'], '~'); 
     * // =&gt; 'a~b~c' 
     */</span>
    <span class="s2">function </span><span class="s1">join(array, separator) {</span>
      <span class="s2">return </span><span class="s1">array == </span><span class="s2">null </span><span class="s1">? </span><span class="s3">'' </span><span class="s1">: nativeJoin.call(array, separator);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Gets the last element of `array`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.1.0 
     * @category Array 
     * @param {Array} array The array to query. 
     * @returns {*} Returns the last element of `array`. 
     * @example 
     * 
     * _.last([1, 2, 3]); 
     * // =&gt; 3 
     */</span>
    <span class="s2">function </span><span class="s1">last(array) {</span>
      <span class="s2">var </span><span class="s1">length = array == </span><span class="s2">null </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: array.length;</span>
      <span class="s2">return </span><span class="s1">length ? array[length - </span><span class="s4">1</span><span class="s1">] : undefined;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * This method is like `_.indexOf` except that it iterates over elements of 
     * `array` from right to left. 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.1.0 
     * @category Array 
     * @param {Array} array The array to inspect. 
     * @param {*} value The value to search for. 
     * @param {number} [fromIndex=array.length-1] The index to search from. 
     * @returns {number} Returns the index of the matched value, else `-1`. 
     * @example 
     * 
     * _.lastIndexOf([1, 2, 1, 2], 2); 
     * // =&gt; 3 
     * 
     * // Search from the `fromIndex`. 
     * _.lastIndexOf([1, 2, 1, 2], 2, 2); 
     * // =&gt; 1 
     */</span>
    <span class="s2">function </span><span class="s1">lastIndexOf(array, value, fromIndex) {</span>
      <span class="s2">var </span><span class="s1">length = array == </span><span class="s2">null </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: array.length;</span>
      <span class="s2">if </span><span class="s1">(!length) {</span>
        <span class="s2">return </span><span class="s1">-</span><span class="s4">1</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">index = length;</span>
      <span class="s2">if </span><span class="s1">(fromIndex !== undefined) {</span>
        <span class="s1">index = toInteger(fromIndex);</span>
        <span class="s1">index = index &lt; </span><span class="s4">0 </span><span class="s1">? nativeMax(length + index, </span><span class="s4">0</span><span class="s1">) : nativeMin(index, length - </span><span class="s4">1</span><span class="s1">);</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">value === value</span>
        <span class="s1">? strictLastIndexOf(array, value, index)</span>
        <span class="s1">: baseFindIndex(array, baseIsNaN, index, </span><span class="s2">true</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Gets the element at index `n` of `array`. If `n` is negative, the nth 
     * element from the end is returned. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.11.0 
     * @category Array 
     * @param {Array} array The array to query. 
     * @param {number} [n=0] The index of the element to return. 
     * @returns {*} Returns the nth element of `array`. 
     * @example 
     * 
     * var array = ['a', 'b', 'c', 'd']; 
     * 
     * _.nth(array, 1); 
     * // =&gt; 'b' 
     * 
     * _.nth(array, -2); 
     * // =&gt; 'c'; 
     */</span>
    <span class="s2">function </span><span class="s1">nth(array, n) {</span>
      <span class="s2">return </span><span class="s1">(array &amp;&amp; array.length) ? baseNth(array, toInteger(n)) : undefined;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Removes all given values from `array` using 
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero) 
     * for equality comparisons. 
     * 
     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove` 
     * to remove elements from an array by predicate. 
     * 
     * @static 
     * @memberOf _ 
     * @since 2.0.0 
     * @category Array 
     * @param {Array} array The array to modify. 
     * @param {...*} [values] The values to remove. 
     * @returns {Array} Returns `array`. 
     * @example 
     * 
     * var array = ['a', 'b', 'c', 'a', 'b', 'c']; 
     * 
     * _.pull(array, 'a', 'c'); 
     * console.log(array); 
     * // =&gt; ['b', 'b'] 
     */</span>
    <span class="s2">var </span><span class="s1">pull = baseRest(pullAll);</span>

    <span class="s0">/** 
     * This method is like `_.pull` except that it accepts an array of values to remove. 
     * 
     * **Note:** Unlike `_.difference`, this method mutates `array`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Array 
     * @param {Array} array The array to modify. 
     * @param {Array} values The values to remove. 
     * @returns {Array} Returns `array`. 
     * @example 
     * 
     * var array = ['a', 'b', 'c', 'a', 'b', 'c']; 
     * 
     * _.pullAll(array, ['a', 'c']); 
     * console.log(array); 
     * // =&gt; ['b', 'b'] 
     */</span>
    <span class="s2">function </span><span class="s1">pullAll(array, values) {</span>
      <span class="s2">return </span><span class="s1">(array &amp;&amp; array.length &amp;&amp; values &amp;&amp; values.length)</span>
        <span class="s1">? basePullAll(array, values)</span>
        <span class="s1">: array;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * This method is like `_.pullAll` except that it accepts `iteratee` which is 
     * invoked for each element of `array` and `values` to generate the criterion 
     * by which they're compared. The iteratee is invoked with one argument: (value). 
     * 
     * **Note:** Unlike `_.differenceBy`, this method mutates `array`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Array 
     * @param {Array} array The array to modify. 
     * @param {Array} values The values to remove. 
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element. 
     * @returns {Array} Returns `array`. 
     * @example 
     * 
     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }]; 
     * 
     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x'); 
     * console.log(array); 
     * // =&gt; [{ 'x': 2 }] 
     */</span>
    <span class="s2">function </span><span class="s1">pullAllBy(array, values, iteratee) {</span>
      <span class="s2">return </span><span class="s1">(array &amp;&amp; array.length &amp;&amp; values &amp;&amp; values.length)</span>
        <span class="s1">? basePullAll(array, values, getIteratee(iteratee, </span><span class="s4">2</span><span class="s1">))</span>
        <span class="s1">: array;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * This method is like `_.pullAll` except that it accepts `comparator` which 
     * is invoked to compare elements of `array` to `values`. The comparator is 
     * invoked with two arguments: (arrVal, othVal). 
     * 
     * **Note:** Unlike `_.differenceWith`, this method mutates `array`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.6.0 
     * @category Array 
     * @param {Array} array The array to modify. 
     * @param {Array} values The values to remove. 
     * @param {Function} [comparator] The comparator invoked per element. 
     * @returns {Array} Returns `array`. 
     * @example 
     * 
     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }]; 
     * 
     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual); 
     * console.log(array); 
     * // =&gt; [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }] 
     */</span>
    <span class="s2">function </span><span class="s1">pullAllWith(array, values, comparator) {</span>
      <span class="s2">return </span><span class="s1">(array &amp;&amp; array.length &amp;&amp; values &amp;&amp; values.length)</span>
        <span class="s1">? basePullAll(array, values, undefined, comparator)</span>
        <span class="s1">: array;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Removes elements from `array` corresponding to `indexes` and returns an 
     * array of removed elements. 
     * 
     * **Note:** Unlike `_.at`, this method mutates `array`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.0.0 
     * @category Array 
     * @param {Array} array The array to modify. 
     * @param {...(number|number[])} [indexes] The indexes of elements to remove. 
     * @returns {Array} Returns the new array of removed elements. 
     * @example 
     * 
     * var array = ['a', 'b', 'c', 'd']; 
     * var pulled = _.pullAt(array, [1, 3]); 
     * 
     * console.log(array); 
     * // =&gt; ['a', 'c'] 
     * 
     * console.log(pulled); 
     * // =&gt; ['b', 'd'] 
     */</span>
    <span class="s2">var </span><span class="s1">pullAt = flatRest(</span><span class="s2">function</span><span class="s1">(array, indexes) {</span>
      <span class="s2">var </span><span class="s1">length = array == </span><span class="s2">null </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: array.length,</span>
          <span class="s1">result = baseAt(array, indexes);</span>

      <span class="s1">basePullAt(array, arrayMap(indexes, </span><span class="s2">function</span><span class="s1">(index) {</span>
        <span class="s2">return </span><span class="s1">isIndex(index, length) ? +index : index;</span>
      <span class="s1">}).sort(compareAscending));</span>

      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">});</span>

    <span class="s0">/** 
     * Removes all elements from `array` that `predicate` returns truthy for 
     * and returns an array of the removed elements. The predicate is invoked 
     * with three arguments: (value, index, array). 
     * 
     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull` 
     * to pull elements from an array by value. 
     * 
     * @static 
     * @memberOf _ 
     * @since 2.0.0 
     * @category Array 
     * @param {Array} array The array to modify. 
     * @param {Function} [predicate=_.identity] The function invoked per iteration. 
     * @returns {Array} Returns the new array of removed elements. 
     * @example 
     * 
     * var array = [1, 2, 3, 4]; 
     * var evens = _.remove(array, function(n) { 
     *   return n % 2 == 0; 
     * }); 
     * 
     * console.log(array); 
     * // =&gt; [1, 3] 
     * 
     * console.log(evens); 
     * // =&gt; [2, 4] 
     */</span>
    <span class="s2">function </span><span class="s1">remove(array, predicate) {</span>
      <span class="s2">var </span><span class="s1">result = [];</span>
      <span class="s2">if </span><span class="s1">(!(array &amp;&amp; array.length)) {</span>
        <span class="s2">return </span><span class="s1">result;</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">index = -</span><span class="s4">1</span><span class="s1">,</span>
          <span class="s1">indexes = [],</span>
          <span class="s1">length = array.length;</span>

      <span class="s1">predicate = getIteratee(predicate, </span><span class="s4">3</span><span class="s1">);</span>
      <span class="s2">while </span><span class="s1">(++index &lt; length) {</span>
        <span class="s2">var </span><span class="s1">value = array[index];</span>
        <span class="s2">if </span><span class="s1">(predicate(value, index, array)) {</span>
          <span class="s1">result.push(value);</span>
          <span class="s1">indexes.push(index);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s1">basePullAt(array, indexes);</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Reverses `array` so that the first element becomes the last, the second 
     * element becomes the second to last, and so on. 
     * 
     * **Note:** This method mutates `array` and is based on 
     * [`Array#reverse`](https://mdn.io/Array/reverse). 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Array 
     * @param {Array} array The array to modify. 
     * @returns {Array} Returns `array`. 
     * @example 
     * 
     * var array = [1, 2, 3]; 
     * 
     * _.reverse(array); 
     * // =&gt; [3, 2, 1] 
     * 
     * console.log(array); 
     * // =&gt; [3, 2, 1] 
     */</span>
    <span class="s2">function </span><span class="s1">reverse(array) {</span>
      <span class="s2">return </span><span class="s1">array == </span><span class="s2">null </span><span class="s1">? array : nativeReverse.call(array);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a slice of `array` from `start` up to, but not including, `end`. 
     * 
     * **Note:** This method is used instead of 
     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are 
     * returned. 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.0.0 
     * @category Array 
     * @param {Array} array The array to slice. 
     * @param {number} [start=0] The start position. 
     * @param {number} [end=array.length] The end position. 
     * @returns {Array} Returns the slice of `array`. 
     */</span>
    <span class="s2">function </span><span class="s1">slice(array, start, end) {</span>
      <span class="s2">var </span><span class="s1">length = array == </span><span class="s2">null </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: array.length;</span>
      <span class="s2">if </span><span class="s1">(!length) {</span>
        <span class="s2">return </span><span class="s1">[];</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(end &amp;&amp; </span><span class="s2">typeof </span><span class="s1">end != </span><span class="s3">'number' </span><span class="s1">&amp;&amp; isIterateeCall(array, start, end)) {</span>
        <span class="s1">start = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">end = length;</span>
      <span class="s1">}</span>
      <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">start = start == </span><span class="s2">null </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: toInteger(start);</span>
        <span class="s1">end = end === undefined ? length : toInteger(end);</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">baseSlice(array, start, end);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Uses a binary search to determine the lowest index at which `value` 
     * should be inserted into `array` in order to maintain its sort order. 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.1.0 
     * @category Array 
     * @param {Array} array The sorted array to inspect. 
     * @param {*} value The value to evaluate. 
     * @returns {number} Returns the index at which `value` should be inserted 
     *  into `array`. 
     * @example 
     * 
     * _.sortedIndex([30, 50], 40); 
     * // =&gt; 1 
     */</span>
    <span class="s2">function </span><span class="s1">sortedIndex(array, value) {</span>
      <span class="s2">return </span><span class="s1">baseSortedIndex(array, value);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * This method is like `_.sortedIndex` except that it accepts `iteratee` 
     * which is invoked for `value` and each element of `array` to compute their 
     * sort ranking. The iteratee is invoked with one argument: (value). 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Array 
     * @param {Array} array The sorted array to inspect. 
     * @param {*} value The value to evaluate. 
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element. 
     * @returns {number} Returns the index at which `value` should be inserted 
     *  into `array`. 
     * @example 
     * 
     * var objects = [{ 'x': 4 }, { 'x': 5 }]; 
     * 
     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; }); 
     * // =&gt; 0 
     * 
     * // The `_.property` iteratee shorthand. 
     * _.sortedIndexBy(objects, { 'x': 4 }, 'x'); 
     * // =&gt; 0 
     */</span>
    <span class="s2">function </span><span class="s1">sortedIndexBy(array, value, iteratee) {</span>
      <span class="s2">return </span><span class="s1">baseSortedIndexBy(array, value, getIteratee(iteratee, </span><span class="s4">2</span><span class="s1">));</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * This method is like `_.indexOf` except that it performs a binary 
     * search on a sorted `array`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Array 
     * @param {Array} array The array to inspect. 
     * @param {*} value The value to search for. 
     * @returns {number} Returns the index of the matched value, else `-1`. 
     * @example 
     * 
     * _.sortedIndexOf([4, 5, 5, 5, 6], 5); 
     * // =&gt; 1 
     */</span>
    <span class="s2">function </span><span class="s1">sortedIndexOf(array, value) {</span>
      <span class="s2">var </span><span class="s1">length = array == </span><span class="s2">null </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: array.length;</span>
      <span class="s2">if </span><span class="s1">(length) {</span>
        <span class="s2">var </span><span class="s1">index = baseSortedIndex(array, value);</span>
        <span class="s2">if </span><span class="s1">(index &lt; length &amp;&amp; eq(array[index], value)) {</span>
          <span class="s2">return </span><span class="s1">index;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">-</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * This method is like `_.sortedIndex` except that it returns the highest 
     * index at which `value` should be inserted into `array` in order to 
     * maintain its sort order. 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.0.0 
     * @category Array 
     * @param {Array} array The sorted array to inspect. 
     * @param {*} value The value to evaluate. 
     * @returns {number} Returns the index at which `value` should be inserted 
     *  into `array`. 
     * @example 
     * 
     * _.sortedLastIndex([4, 5, 5, 5, 6], 5); 
     * // =&gt; 4 
     */</span>
    <span class="s2">function </span><span class="s1">sortedLastIndex(array, value) {</span>
      <span class="s2">return </span><span class="s1">baseSortedIndex(array, value, </span><span class="s2">true</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * This method is like `_.sortedLastIndex` except that it accepts `iteratee` 
     * which is invoked for `value` and each element of `array` to compute their 
     * sort ranking. The iteratee is invoked with one argument: (value). 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Array 
     * @param {Array} array The sorted array to inspect. 
     * @param {*} value The value to evaluate. 
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element. 
     * @returns {number} Returns the index at which `value` should be inserted 
     *  into `array`. 
     * @example 
     * 
     * var objects = [{ 'x': 4 }, { 'x': 5 }]; 
     * 
     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; }); 
     * // =&gt; 1 
     * 
     * // The `_.property` iteratee shorthand. 
     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x'); 
     * // =&gt; 1 
     */</span>
    <span class="s2">function </span><span class="s1">sortedLastIndexBy(array, value, iteratee) {</span>
      <span class="s2">return </span><span class="s1">baseSortedIndexBy(array, value, getIteratee(iteratee, </span><span class="s4">2</span><span class="s1">), </span><span class="s2">true</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * This method is like `_.lastIndexOf` except that it performs a binary 
     * search on a sorted `array`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Array 
     * @param {Array} array The array to inspect. 
     * @param {*} value The value to search for. 
     * @returns {number} Returns the index of the matched value, else `-1`. 
     * @example 
     * 
     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5); 
     * // =&gt; 3 
     */</span>
    <span class="s2">function </span><span class="s1">sortedLastIndexOf(array, value) {</span>
      <span class="s2">var </span><span class="s1">length = array == </span><span class="s2">null </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: array.length;</span>
      <span class="s2">if </span><span class="s1">(length) {</span>
        <span class="s2">var </span><span class="s1">index = baseSortedIndex(array, value, </span><span class="s2">true</span><span class="s1">) - </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(eq(array[index], value)) {</span>
          <span class="s2">return </span><span class="s1">index;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">-</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * This method is like `_.uniq` except that it's designed and optimized 
     * for sorted arrays. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Array 
     * @param {Array} array The array to inspect. 
     * @returns {Array} Returns the new duplicate free array. 
     * @example 
     * 
     * _.sortedUniq([1, 1, 2]); 
     * // =&gt; [1, 2] 
     */</span>
    <span class="s2">function </span><span class="s1">sortedUniq(array) {</span>
      <span class="s2">return </span><span class="s1">(array &amp;&amp; array.length)</span>
        <span class="s1">? baseSortedUniq(array)</span>
        <span class="s1">: [];</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * This method is like `_.uniqBy` except that it's designed and optimized 
     * for sorted arrays. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Array 
     * @param {Array} array The array to inspect. 
     * @param {Function} [iteratee] The iteratee invoked per element. 
     * @returns {Array} Returns the new duplicate free array. 
     * @example 
     * 
     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor); 
     * // =&gt; [1.1, 2.3] 
     */</span>
    <span class="s2">function </span><span class="s1">sortedUniqBy(array, iteratee) {</span>
      <span class="s2">return </span><span class="s1">(array &amp;&amp; array.length)</span>
        <span class="s1">? baseSortedUniq(array, getIteratee(iteratee, </span><span class="s4">2</span><span class="s1">))</span>
        <span class="s1">: [];</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Gets all but the first element of `array`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Array 
     * @param {Array} array The array to query. 
     * @returns {Array} Returns the slice of `array`. 
     * @example 
     * 
     * _.tail([1, 2, 3]); 
     * // =&gt; [2, 3] 
     */</span>
    <span class="s2">function </span><span class="s1">tail(array) {</span>
      <span class="s2">var </span><span class="s1">length = array == </span><span class="s2">null </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: array.length;</span>
      <span class="s2">return </span><span class="s1">length ? baseSlice(array, </span><span class="s4">1</span><span class="s1">, length) : [];</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a slice of `array` with `n` elements taken from the beginning. 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.1.0 
     * @category Array 
     * @param {Array} array The array to query. 
     * @param {number} [n=1] The number of elements to take. 
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`. 
     * @returns {Array} Returns the slice of `array`. 
     * @example 
     * 
     * _.take([1, 2, 3]); 
     * // =&gt; [1] 
     * 
     * _.take([1, 2, 3], 2); 
     * // =&gt; [1, 2] 
     * 
     * _.take([1, 2, 3], 5); 
     * // =&gt; [1, 2, 3] 
     * 
     * _.take([1, 2, 3], 0); 
     * // =&gt; [] 
     */</span>
    <span class="s2">function </span><span class="s1">take(array, n, guard) {</span>
      <span class="s2">if </span><span class="s1">(!(array &amp;&amp; array.length)) {</span>
        <span class="s2">return </span><span class="s1">[];</span>
      <span class="s1">}</span>
      <span class="s1">n = (guard || n === undefined) ? </span><span class="s4">1 </span><span class="s1">: toInteger(n);</span>
      <span class="s2">return </span><span class="s1">baseSlice(array, </span><span class="s4">0</span><span class="s1">, n &lt; </span><span class="s4">0 </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: n);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a slice of `array` with `n` elements taken from the end. 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.0.0 
     * @category Array 
     * @param {Array} array The array to query. 
     * @param {number} [n=1] The number of elements to take. 
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`. 
     * @returns {Array} Returns the slice of `array`. 
     * @example 
     * 
     * _.takeRight([1, 2, 3]); 
     * // =&gt; [3] 
     * 
     * _.takeRight([1, 2, 3], 2); 
     * // =&gt; [2, 3] 
     * 
     * _.takeRight([1, 2, 3], 5); 
     * // =&gt; [1, 2, 3] 
     * 
     * _.takeRight([1, 2, 3], 0); 
     * // =&gt; [] 
     */</span>
    <span class="s2">function </span><span class="s1">takeRight(array, n, guard) {</span>
      <span class="s2">var </span><span class="s1">length = array == </span><span class="s2">null </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: array.length;</span>
      <span class="s2">if </span><span class="s1">(!length) {</span>
        <span class="s2">return </span><span class="s1">[];</span>
      <span class="s1">}</span>
      <span class="s1">n = (guard || n === undefined) ? </span><span class="s4">1 </span><span class="s1">: toInteger(n);</span>
      <span class="s1">n = length - n;</span>
      <span class="s2">return </span><span class="s1">baseSlice(array, n &lt; </span><span class="s4">0 </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: n, length);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a slice of `array` with elements taken from the end. Elements are 
     * taken until `predicate` returns falsey. The predicate is invoked with 
     * three arguments: (value, index, array). 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.0.0 
     * @category Array 
     * @param {Array} array The array to query. 
     * @param {Function} [predicate=_.identity] The function invoked per iteration. 
     * @returns {Array} Returns the slice of `array`. 
     * @example 
     * 
     * var users = [ 
     *   { 'user': 'barney',  'active': true }, 
     *   { 'user': 'fred',    'active': false }, 
     *   { 'user': 'pebbles', 'active': false } 
     * ]; 
     * 
     * _.takeRightWhile(users, function(o) { return !o.active; }); 
     * // =&gt; objects for ['fred', 'pebbles'] 
     * 
     * // The `_.matches` iteratee shorthand. 
     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false }); 
     * // =&gt; objects for ['pebbles'] 
     * 
     * // The `_.matchesProperty` iteratee shorthand. 
     * _.takeRightWhile(users, ['active', false]); 
     * // =&gt; objects for ['fred', 'pebbles'] 
     * 
     * // The `_.property` iteratee shorthand. 
     * _.takeRightWhile(users, 'active'); 
     * // =&gt; [] 
     */</span>
    <span class="s2">function </span><span class="s1">takeRightWhile(array, predicate) {</span>
      <span class="s2">return </span><span class="s1">(array &amp;&amp; array.length)</span>
        <span class="s1">? baseWhile(array, getIteratee(predicate, </span><span class="s4">3</span><span class="s1">), </span><span class="s2">false</span><span class="s1">, </span><span class="s2">true</span><span class="s1">)</span>
        <span class="s1">: [];</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a slice of `array` with elements taken from the beginning. Elements 
     * are taken until `predicate` returns falsey. The predicate is invoked with 
     * three arguments: (value, index, array). 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.0.0 
     * @category Array 
     * @param {Array} array The array to query. 
     * @param {Function} [predicate=_.identity] The function invoked per iteration. 
     * @returns {Array} Returns the slice of `array`. 
     * @example 
     * 
     * var users = [ 
     *   { 'user': 'barney',  'active': false }, 
     *   { 'user': 'fred',    'active': false }, 
     *   { 'user': 'pebbles', 'active': true } 
     * ]; 
     * 
     * _.takeWhile(users, function(o) { return !o.active; }); 
     * // =&gt; objects for ['barney', 'fred'] 
     * 
     * // The `_.matches` iteratee shorthand. 
     * _.takeWhile(users, { 'user': 'barney', 'active': false }); 
     * // =&gt; objects for ['barney'] 
     * 
     * // The `_.matchesProperty` iteratee shorthand. 
     * _.takeWhile(users, ['active', false]); 
     * // =&gt; objects for ['barney', 'fred'] 
     * 
     * // The `_.property` iteratee shorthand. 
     * _.takeWhile(users, 'active'); 
     * // =&gt; [] 
     */</span>
    <span class="s2">function </span><span class="s1">takeWhile(array, predicate) {</span>
      <span class="s2">return </span><span class="s1">(array &amp;&amp; array.length)</span>
        <span class="s1">? baseWhile(array, getIteratee(predicate, </span><span class="s4">3</span><span class="s1">))</span>
        <span class="s1">: [];</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates an array of unique values, in order, from all given arrays using 
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero) 
     * for equality comparisons. 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.1.0 
     * @category Array 
     * @param {...Array} [arrays] The arrays to inspect. 
     * @returns {Array} Returns the new array of combined values. 
     * @example 
     * 
     * _.union([2], [1, 2]); 
     * // =&gt; [2, 1] 
     */</span>
    <span class="s2">var </span><span class="s1">union = baseRest(</span><span class="s2">function</span><span class="s1">(arrays) {</span>
      <span class="s2">return </span><span class="s1">baseUniq(baseFlatten(arrays, </span><span class="s4">1</span><span class="s1">, isArrayLikeObject, </span><span class="s2">true</span><span class="s1">));</span>
    <span class="s1">});</span>

    <span class="s0">/** 
     * This method is like `_.union` except that it accepts `iteratee` which is 
     * invoked for each element of each `arrays` to generate the criterion by 
     * which uniqueness is computed. Result values are chosen from the first 
     * array in which the value occurs. The iteratee is invoked with one argument: 
     * (value). 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Array 
     * @param {...Array} [arrays] The arrays to inspect. 
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element. 
     * @returns {Array} Returns the new array of combined values. 
     * @example 
     * 
     * _.unionBy([2.1], [1.2, 2.3], Math.floor); 
     * // =&gt; [2.1, 1.2] 
     * 
     * // The `_.property` iteratee shorthand. 
     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x'); 
     * // =&gt; [{ 'x': 1 }, { 'x': 2 }] 
     */</span>
    <span class="s2">var </span><span class="s1">unionBy = baseRest(</span><span class="s2">function</span><span class="s1">(arrays) {</span>
      <span class="s2">var </span><span class="s1">iteratee = last(arrays);</span>
      <span class="s2">if </span><span class="s1">(isArrayLikeObject(iteratee)) {</span>
        <span class="s1">iteratee = undefined;</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">baseUniq(baseFlatten(arrays, </span><span class="s4">1</span><span class="s1">, isArrayLikeObject, </span><span class="s2">true</span><span class="s1">), getIteratee(iteratee, </span><span class="s4">2</span><span class="s1">));</span>
    <span class="s1">});</span>

    <span class="s0">/** 
     * This method is like `_.union` except that it accepts `comparator` which 
     * is invoked to compare elements of `arrays`. Result values are chosen from 
     * the first array in which the value occurs. The comparator is invoked 
     * with two arguments: (arrVal, othVal). 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Array 
     * @param {...Array} [arrays] The arrays to inspect. 
     * @param {Function} [comparator] The comparator invoked per element. 
     * @returns {Array} Returns the new array of combined values. 
     * @example 
     * 
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]; 
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }]; 
     * 
     * _.unionWith(objects, others, _.isEqual); 
     * // =&gt; [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }] 
     */</span>
    <span class="s2">var </span><span class="s1">unionWith = baseRest(</span><span class="s2">function</span><span class="s1">(arrays) {</span>
      <span class="s2">var </span><span class="s1">comparator = last(arrays);</span>
      <span class="s1">comparator = </span><span class="s2">typeof </span><span class="s1">comparator == </span><span class="s3">'function' </span><span class="s1">? comparator : undefined;</span>
      <span class="s2">return </span><span class="s1">baseUniq(baseFlatten(arrays, </span><span class="s4">1</span><span class="s1">, isArrayLikeObject, </span><span class="s2">true</span><span class="s1">), undefined, comparator);</span>
    <span class="s1">});</span>

    <span class="s0">/** 
     * Creates a duplicate-free version of an array, using 
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero) 
     * for equality comparisons, in which only the first occurrence of each element 
     * is kept. The order of result values is determined by the order they occur 
     * in the array. 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.1.0 
     * @category Array 
     * @param {Array} array The array to inspect. 
     * @returns {Array} Returns the new duplicate free array. 
     * @example 
     * 
     * _.uniq([2, 1, 2]); 
     * // =&gt; [2, 1] 
     */</span>
    <span class="s2">function </span><span class="s1">uniq(array) {</span>
      <span class="s2">return </span><span class="s1">(array &amp;&amp; array.length) ? baseUniq(array) : [];</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * This method is like `_.uniq` except that it accepts `iteratee` which is 
     * invoked for each element in `array` to generate the criterion by which 
     * uniqueness is computed. The order of result values is determined by the 
     * order they occur in the array. The iteratee is invoked with one argument: 
     * (value). 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Array 
     * @param {Array} array The array to inspect. 
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element. 
     * @returns {Array} Returns the new duplicate free array. 
     * @example 
     * 
     * _.uniqBy([2.1, 1.2, 2.3], Math.floor); 
     * // =&gt; [2.1, 1.2] 
     * 
     * // The `_.property` iteratee shorthand. 
     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x'); 
     * // =&gt; [{ 'x': 1 }, { 'x': 2 }] 
     */</span>
    <span class="s2">function </span><span class="s1">uniqBy(array, iteratee) {</span>
      <span class="s2">return </span><span class="s1">(array &amp;&amp; array.length) ? baseUniq(array, getIteratee(iteratee, </span><span class="s4">2</span><span class="s1">)) : [];</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * This method is like `_.uniq` except that it accepts `comparator` which 
     * is invoked to compare elements of `array`. The order of result values is 
     * determined by the order they occur in the array.The comparator is invoked 
     * with two arguments: (arrVal, othVal). 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Array 
     * @param {Array} array The array to inspect. 
     * @param {Function} [comparator] The comparator invoked per element. 
     * @returns {Array} Returns the new duplicate free array. 
     * @example 
     * 
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }]; 
     * 
     * _.uniqWith(objects, _.isEqual); 
     * // =&gt; [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }] 
     */</span>
    <span class="s2">function </span><span class="s1">uniqWith(array, comparator) {</span>
      <span class="s1">comparator = </span><span class="s2">typeof </span><span class="s1">comparator == </span><span class="s3">'function' </span><span class="s1">? comparator : undefined;</span>
      <span class="s2">return </span><span class="s1">(array &amp;&amp; array.length) ? baseUniq(array, undefined, comparator) : [];</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * This method is like `_.zip` except that it accepts an array of grouped 
     * elements and creates an array regrouping the elements to their pre-zip 
     * configuration. 
     * 
     * @static 
     * @memberOf _ 
     * @since 1.2.0 
     * @category Array 
     * @param {Array} array The array of grouped elements to process. 
     * @returns {Array} Returns the new array of regrouped elements. 
     * @example 
     * 
     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]); 
     * // =&gt; [['a', 1, true], ['b', 2, false]] 
     * 
     * _.unzip(zipped); 
     * // =&gt; [['a', 'b'], [1, 2], [true, false]] 
     */</span>
    <span class="s2">function </span><span class="s1">unzip(array) {</span>
      <span class="s2">if </span><span class="s1">(!(array &amp;&amp; array.length)) {</span>
        <span class="s2">return </span><span class="s1">[];</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">length = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s1">array = arrayFilter(array, </span><span class="s2">function</span><span class="s1">(group) {</span>
        <span class="s2">if </span><span class="s1">(isArrayLikeObject(group)) {</span>
          <span class="s1">length = nativeMax(group.length, length);</span>
          <span class="s2">return true</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">});</span>
      <span class="s2">return </span><span class="s1">baseTimes(length, </span><span class="s2">function</span><span class="s1">(index) {</span>
        <span class="s2">return </span><span class="s1">arrayMap(array, baseProperty(index));</span>
      <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * This method is like `_.unzip` except that it accepts `iteratee` to specify 
     * how regrouped values should be combined. The iteratee is invoked with the 
     * elements of each group: (...group). 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.8.0 
     * @category Array 
     * @param {Array} array The array of grouped elements to process. 
     * @param {Function} [iteratee=_.identity] The function to combine 
     *  regrouped values. 
     * @returns {Array} Returns the new array of regrouped elements. 
     * @example 
     * 
     * var zipped = _.zip([1, 2], [10, 20], [100, 200]); 
     * // =&gt; [[1, 10, 100], [2, 20, 200]] 
     * 
     * _.unzipWith(zipped, _.add); 
     * // =&gt; [3, 30, 300] 
     */</span>
    <span class="s2">function </span><span class="s1">unzipWith(array, iteratee) {</span>
      <span class="s2">if </span><span class="s1">(!(array &amp;&amp; array.length)) {</span>
        <span class="s2">return </span><span class="s1">[];</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">result = unzip(array);</span>
      <span class="s2">if </span><span class="s1">(iteratee == </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">result;</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">arrayMap(result, </span><span class="s2">function</span><span class="s1">(group) {</span>
        <span class="s2">return </span><span class="s1">apply(iteratee, undefined, group);</span>
      <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates an array excluding all given values using 
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero) 
     * for equality comparisons. 
     * 
     * **Note:** Unlike `_.pull`, this method returns a new array. 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.1.0 
     * @category Array 
     * @param {Array} array The array to inspect. 
     * @param {...*} [values] The values to exclude. 
     * @returns {Array} Returns the new array of filtered values. 
     * @see _.difference, _.xor 
     * @example 
     * 
     * _.without([2, 1, 2, 3], 1, 2); 
     * // =&gt; [3] 
     */</span>
    <span class="s2">var </span><span class="s1">without = baseRest(</span><span class="s2">function</span><span class="s1">(array, values) {</span>
      <span class="s2">return </span><span class="s1">isArrayLikeObject(array)</span>
        <span class="s1">? baseDifference(array, values)</span>
        <span class="s1">: [];</span>
    <span class="s1">});</span>

    <span class="s0">/** 
     * Creates an array of unique values that is the 
     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference) 
     * of the given arrays. The order of result values is determined by the order 
     * they occur in the arrays. 
     * 
     * @static 
     * @memberOf _ 
     * @since 2.4.0 
     * @category Array 
     * @param {...Array} [arrays] The arrays to inspect. 
     * @returns {Array} Returns the new array of filtered values. 
     * @see _.difference, _.without 
     * @example 
     * 
     * _.xor([2, 1], [2, 3]); 
     * // =&gt; [1, 3] 
     */</span>
    <span class="s2">var </span><span class="s1">xor = baseRest(</span><span class="s2">function</span><span class="s1">(arrays) {</span>
      <span class="s2">return </span><span class="s1">baseXor(arrayFilter(arrays, isArrayLikeObject));</span>
    <span class="s1">});</span>

    <span class="s0">/** 
     * This method is like `_.xor` except that it accepts `iteratee` which is 
     * invoked for each element of each `arrays` to generate the criterion by 
     * which by which they're compared. The order of result values is determined 
     * by the order they occur in the arrays. The iteratee is invoked with one 
     * argument: (value). 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Array 
     * @param {...Array} [arrays] The arrays to inspect. 
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element. 
     * @returns {Array} Returns the new array of filtered values. 
     * @example 
     * 
     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor); 
     * // =&gt; [1.2, 3.4] 
     * 
     * // The `_.property` iteratee shorthand. 
     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x'); 
     * // =&gt; [{ 'x': 2 }] 
     */</span>
    <span class="s2">var </span><span class="s1">xorBy = baseRest(</span><span class="s2">function</span><span class="s1">(arrays) {</span>
      <span class="s2">var </span><span class="s1">iteratee = last(arrays);</span>
      <span class="s2">if </span><span class="s1">(isArrayLikeObject(iteratee)) {</span>
        <span class="s1">iteratee = undefined;</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, </span><span class="s4">2</span><span class="s1">));</span>
    <span class="s1">});</span>

    <span class="s0">/** 
     * This method is like `_.xor` except that it accepts `comparator` which is 
     * invoked to compare elements of `arrays`. The order of result values is 
     * determined by the order they occur in the arrays. The comparator is invoked 
     * with two arguments: (arrVal, othVal). 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Array 
     * @param {...Array} [arrays] The arrays to inspect. 
     * @param {Function} [comparator] The comparator invoked per element. 
     * @returns {Array} Returns the new array of filtered values. 
     * @example 
     * 
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]; 
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }]; 
     * 
     * _.xorWith(objects, others, _.isEqual); 
     * // =&gt; [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }] 
     */</span>
    <span class="s2">var </span><span class="s1">xorWith = baseRest(</span><span class="s2">function</span><span class="s1">(arrays) {</span>
      <span class="s2">var </span><span class="s1">comparator = last(arrays);</span>
      <span class="s1">comparator = </span><span class="s2">typeof </span><span class="s1">comparator == </span><span class="s3">'function' </span><span class="s1">? comparator : undefined;</span>
      <span class="s2">return </span><span class="s1">baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);</span>
    <span class="s1">});</span>

    <span class="s0">/** 
     * Creates an array of grouped elements, the first of which contains the 
     * first elements of the given arrays, the second of which contains the 
     * second elements of the given arrays, and so on. 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.1.0 
     * @category Array 
     * @param {...Array} [arrays] The arrays to process. 
     * @returns {Array} Returns the new array of grouped elements. 
     * @example 
     * 
     * _.zip(['a', 'b'], [1, 2], [true, false]); 
     * // =&gt; [['a', 1, true], ['b', 2, false]] 
     */</span>
    <span class="s2">var </span><span class="s1">zip = baseRest(unzip);</span>

    <span class="s0">/** 
     * This method is like `_.fromPairs` except that it accepts two arrays, 
     * one of property identifiers and one of corresponding values. 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.4.0 
     * @category Array 
     * @param {Array} [props=[]] The property identifiers. 
     * @param {Array} [values=[]] The property values. 
     * @returns {Object} Returns the new object. 
     * @example 
     * 
     * _.zipObject(['a', 'b'], [1, 2]); 
     * // =&gt; { 'a': 1, 'b': 2 } 
     */</span>
    <span class="s2">function </span><span class="s1">zipObject(props, values) {</span>
      <span class="s2">return </span><span class="s1">baseZipObject(props || [], values || [], assignValue);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * This method is like `_.zipObject` except that it supports property paths. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.1.0 
     * @category Array 
     * @param {Array} [props=[]] The property identifiers. 
     * @param {Array} [values=[]] The property values. 
     * @returns {Object} Returns the new object. 
     * @example 
     * 
     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]); 
     * // =&gt; { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } } 
     */</span>
    <span class="s2">function </span><span class="s1">zipObjectDeep(props, values) {</span>
      <span class="s2">return </span><span class="s1">baseZipObject(props || [], values || [], baseSet);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * This method is like `_.zip` except that it accepts `iteratee` to specify 
     * how grouped values should be combined. The iteratee is invoked with the 
     * elements of each group: (...group). 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.8.0 
     * @category Array 
     * @param {...Array} [arrays] The arrays to process. 
     * @param {Function} [iteratee=_.identity] The function to combine 
     *  grouped values. 
     * @returns {Array} Returns the new array of grouped elements. 
     * @example 
     * 
     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) { 
     *   return a + b + c; 
     * }); 
     * // =&gt; [111, 222] 
     */</span>
    <span class="s2">var </span><span class="s1">zipWith = baseRest(</span><span class="s2">function</span><span class="s1">(arrays) {</span>
      <span class="s2">var </span><span class="s1">length = arrays.length,</span>
          <span class="s1">iteratee = length &gt; </span><span class="s4">1 </span><span class="s1">? arrays[length - </span><span class="s4">1</span><span class="s1">] : undefined;</span>

      <span class="s1">iteratee = </span><span class="s2">typeof </span><span class="s1">iteratee == </span><span class="s3">'function' </span><span class="s1">? (arrays.pop(), iteratee) : undefined;</span>
      <span class="s2">return </span><span class="s1">unzipWith(arrays, iteratee);</span>
    <span class="s1">});</span>

    <span class="s0">/*------------------------------------------------------------------------*/</span>

    <span class="s0">/** 
     * Creates a `lodash` wrapper instance that wraps `value` with explicit method 
     * chain sequences enabled. The result of such sequences must be unwrapped 
     * with `_#value`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 1.3.0 
     * @category Seq 
     * @param {*} value The value to wrap. 
     * @returns {Object} Returns the new `lodash` wrapper instance. 
     * @example 
     * 
     * var users = [ 
     *   { 'user': 'barney',  'age': 36 }, 
     *   { 'user': 'fred',    'age': 40 }, 
     *   { 'user': 'pebbles', 'age': 1 } 
     * ]; 
     * 
     * var youngest = _ 
     *   .chain(users) 
     *   .sortBy('age') 
     *   .map(function(o) { 
     *     return o.user + ' is ' + o.age; 
     *   }) 
     *   .head() 
     *   .value(); 
     * // =&gt; 'pebbles is 1' 
     */</span>
    <span class="s2">function </span><span class="s1">chain(value) {</span>
      <span class="s2">var </span><span class="s1">result = lodash(value);</span>
      <span class="s1">result.__chain__ = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * This method invokes `interceptor` and returns `value`. The interceptor 
     * is invoked with one argument; (value). The purpose of this method is to 
     * &quot;tap into&quot; a method chain sequence in order to modify intermediate results. 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.1.0 
     * @category Seq 
     * @param {*} value The value to provide to `interceptor`. 
     * @param {Function} interceptor The function to invoke. 
     * @returns {*} Returns `value`. 
     * @example 
     * 
     * _([1, 2, 3]) 
     *  .tap(function(array) { 
     *    // Mutate input array. 
     *    array.pop(); 
     *  }) 
     *  .reverse() 
     *  .value(); 
     * // =&gt; [2, 1] 
     */</span>
    <span class="s2">function </span><span class="s1">tap(value, interceptor) {</span>
      <span class="s1">interceptor(value);</span>
      <span class="s2">return </span><span class="s1">value;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * This method is like `_.tap` except that it returns the result of `interceptor`. 
     * The purpose of this method is to &quot;pass thru&quot; values replacing intermediate 
     * results in a method chain sequence. 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.0.0 
     * @category Seq 
     * @param {*} value The value to provide to `interceptor`. 
     * @param {Function} interceptor The function to invoke. 
     * @returns {*} Returns the result of `interceptor`. 
     * @example 
     * 
     * _('  abc  ') 
     *  .chain() 
     *  .trim() 
     *  .thru(function(value) { 
     *    return [value]; 
     *  }) 
     *  .value(); 
     * // =&gt; ['abc'] 
     */</span>
    <span class="s2">function </span><span class="s1">thru(value, interceptor) {</span>
      <span class="s2">return </span><span class="s1">interceptor(value);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * This method is the wrapper version of `_.at`. 
     * 
     * @name at 
     * @memberOf _ 
     * @since 1.0.0 
     * @category Seq 
     * @param {...(string|string[])} [paths] The property paths to pick. 
     * @returns {Object} Returns the new `lodash` wrapper instance. 
     * @example 
     * 
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] }; 
     * 
     * _(object).at(['a[0].b.c', 'a[1]']).value(); 
     * // =&gt; [3, 4] 
     */</span>
    <span class="s2">var </span><span class="s1">wrapperAt = flatRest(</span><span class="s2">function</span><span class="s1">(paths) {</span>
      <span class="s2">var </span><span class="s1">length = paths.length,</span>
          <span class="s1">start = length ? paths[</span><span class="s4">0</span><span class="s1">] : </span><span class="s4">0</span><span class="s1">,</span>
          <span class="s1">value = </span><span class="s2">this</span><span class="s1">.__wrapped__,</span>
          <span class="s1">interceptor = </span><span class="s2">function</span><span class="s1">(object) { </span><span class="s2">return </span><span class="s1">baseAt(object, paths); };</span>

      <span class="s2">if </span><span class="s1">(length &gt; </span><span class="s4">1 </span><span class="s1">|| </span><span class="s2">this</span><span class="s1">.__actions__.length ||</span>
          <span class="s1">!(value </span><span class="s2">instanceof </span><span class="s1">LazyWrapper) || !isIndex(start)) {</span>
        <span class="s2">return this</span><span class="s1">.thru(interceptor);</span>
      <span class="s1">}</span>
      <span class="s1">value = value.slice(start, +start + (length ? </span><span class="s4">1 </span><span class="s1">: </span><span class="s4">0</span><span class="s1">));</span>
      <span class="s1">value.__actions__.push({</span>
        <span class="s3">'func'</span><span class="s1">: thru,</span>
        <span class="s3">'args'</span><span class="s1">: [interceptor],</span>
        <span class="s3">'thisArg'</span><span class="s1">: undefined</span>
      <span class="s1">});</span>
      <span class="s2">return new </span><span class="s1">LodashWrapper(value, </span><span class="s2">this</span><span class="s1">.__chain__).thru(</span><span class="s2">function</span><span class="s1">(array) {</span>
        <span class="s2">if </span><span class="s1">(length &amp;&amp; !array.length) {</span>
          <span class="s1">array.push(undefined);</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">array;</span>
      <span class="s1">});</span>
    <span class="s1">});</span>

    <span class="s0">/** 
     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled. 
     * 
     * @name chain 
     * @memberOf _ 
     * @since 0.1.0 
     * @category Seq 
     * @returns {Object} Returns the new `lodash` wrapper instance. 
     * @example 
     * 
     * var users = [ 
     *   { 'user': 'barney', 'age': 36 }, 
     *   { 'user': 'fred',   'age': 40 } 
     * ]; 
     * 
     * // A sequence without explicit chaining. 
     * _(users).head(); 
     * // =&gt; { 'user': 'barney', 'age': 36 } 
     * 
     * // A sequence with explicit chaining. 
     * _(users) 
     *   .chain() 
     *   .head() 
     *   .pick('user') 
     *   .value(); 
     * // =&gt; { 'user': 'barney' } 
     */</span>
    <span class="s2">function </span><span class="s1">wrapperChain() {</span>
      <span class="s2">return </span><span class="s1">chain(</span><span class="s2">this</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Executes the chain sequence and returns the wrapped result. 
     * 
     * @name commit 
     * @memberOf _ 
     * @since 3.2.0 
     * @category Seq 
     * @returns {Object} Returns the new `lodash` wrapper instance. 
     * @example 
     * 
     * var array = [1, 2]; 
     * var wrapped = _(array).push(3); 
     * 
     * console.log(array); 
     * // =&gt; [1, 2] 
     * 
     * wrapped = wrapped.commit(); 
     * console.log(array); 
     * // =&gt; [1, 2, 3] 
     * 
     * wrapped.last(); 
     * // =&gt; 3 
     * 
     * console.log(array); 
     * // =&gt; [1, 2, 3] 
     */</span>
    <span class="s2">function </span><span class="s1">wrapperCommit() {</span>
      <span class="s2">return new </span><span class="s1">LodashWrapper(</span><span class="s2">this</span><span class="s1">.value(), </span><span class="s2">this</span><span class="s1">.__chain__);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Gets the next value on a wrapped object following the 
     * [iterator protocol](https://mdn.io/iteration_protocols#iterator). 
     * 
     * @name next 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Seq 
     * @returns {Object} Returns the next iterator value. 
     * @example 
     * 
     * var wrapped = _([1, 2]); 
     * 
     * wrapped.next(); 
     * // =&gt; { 'done': false, 'value': 1 } 
     * 
     * wrapped.next(); 
     * // =&gt; { 'done': false, 'value': 2 } 
     * 
     * wrapped.next(); 
     * // =&gt; { 'done': true, 'value': undefined } 
     */</span>
    <span class="s2">function </span><span class="s1">wrapperNext() {</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.__values__ === undefined) {</span>
        <span class="s2">this</span><span class="s1">.__values__ = toArray(</span><span class="s2">this</span><span class="s1">.value());</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">done = </span><span class="s2">this</span><span class="s1">.__index__ &gt;= </span><span class="s2">this</span><span class="s1">.__values__.length,</span>
          <span class="s1">value = done ? undefined : </span><span class="s2">this</span><span class="s1">.__values__[</span><span class="s2">this</span><span class="s1">.__index__++];</span>

      <span class="s2">return </span><span class="s1">{ </span><span class="s3">'done'</span><span class="s1">: done, </span><span class="s3">'value'</span><span class="s1">: value };</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Enables the wrapper to be iterable. 
     * 
     * @name Symbol.iterator 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Seq 
     * @returns {Object} Returns the wrapper object. 
     * @example 
     * 
     * var wrapped = _([1, 2]); 
     * 
     * wrapped[Symbol.iterator]() === wrapped; 
     * // =&gt; true 
     * 
     * Array.from(wrapped); 
     * // =&gt; [1, 2] 
     */</span>
    <span class="s2">function </span><span class="s1">wrapperToIterator() {</span>
      <span class="s2">return this</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a clone of the chain sequence planting `value` as the wrapped value. 
     * 
     * @name plant 
     * @memberOf _ 
     * @since 3.2.0 
     * @category Seq 
     * @param {*} value The value to plant. 
     * @returns {Object} Returns the new `lodash` wrapper instance. 
     * @example 
     * 
     * function square(n) { 
     *   return n * n; 
     * } 
     * 
     * var wrapped = _([1, 2]).map(square); 
     * var other = wrapped.plant([3, 4]); 
     * 
     * other.value(); 
     * // =&gt; [9, 16] 
     * 
     * wrapped.value(); 
     * // =&gt; [1, 4] 
     */</span>
    <span class="s2">function </span><span class="s1">wrapperPlant(value) {</span>
      <span class="s2">var </span><span class="s1">result,</span>
          <span class="s1">parent = </span><span class="s2">this</span><span class="s1">;</span>

      <span class="s2">while </span><span class="s1">(parent </span><span class="s2">instanceof </span><span class="s1">baseLodash) {</span>
        <span class="s2">var </span><span class="s1">clone = wrapperClone(parent);</span>
        <span class="s1">clone.__index__ = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">clone.__values__ = undefined;</span>
        <span class="s2">if </span><span class="s1">(result) {</span>
          <span class="s1">previous.__wrapped__ = clone;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">result = clone;</span>
        <span class="s1">}</span>
        <span class="s2">var </span><span class="s1">previous = clone;</span>
        <span class="s1">parent = parent.__wrapped__;</span>
      <span class="s1">}</span>
      <span class="s1">previous.__wrapped__ = value;</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * This method is the wrapper version of `_.reverse`. 
     * 
     * **Note:** This method mutates the wrapped array. 
     * 
     * @name reverse 
     * @memberOf _ 
     * @since 0.1.0 
     * @category Seq 
     * @returns {Object} Returns the new `lodash` wrapper instance. 
     * @example 
     * 
     * var array = [1, 2, 3]; 
     * 
     * _(array).reverse().value() 
     * // =&gt; [3, 2, 1] 
     * 
     * console.log(array); 
     * // =&gt; [3, 2, 1] 
     */</span>
    <span class="s2">function </span><span class="s1">wrapperReverse() {</span>
      <span class="s2">var </span><span class="s1">value = </span><span class="s2">this</span><span class="s1">.__wrapped__;</span>
      <span class="s2">if </span><span class="s1">(value </span><span class="s2">instanceof </span><span class="s1">LazyWrapper) {</span>
        <span class="s2">var </span><span class="s1">wrapped = value;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.__actions__.length) {</span>
          <span class="s1">wrapped = </span><span class="s2">new </span><span class="s1">LazyWrapper(</span><span class="s2">this</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s1">wrapped = wrapped.reverse();</span>
        <span class="s1">wrapped.__actions__.push({</span>
          <span class="s3">'func'</span><span class="s1">: thru,</span>
          <span class="s3">'args'</span><span class="s1">: [reverse],</span>
          <span class="s3">'thisArg'</span><span class="s1">: undefined</span>
        <span class="s1">});</span>
        <span class="s2">return new </span><span class="s1">LodashWrapper(wrapped, </span><span class="s2">this</span><span class="s1">.__chain__);</span>
      <span class="s1">}</span>
      <span class="s2">return this</span><span class="s1">.thru(reverse);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Executes the chain sequence to resolve the unwrapped value. 
     * 
     * @name value 
     * @memberOf _ 
     * @since 0.1.0 
     * @alias toJSON, valueOf 
     * @category Seq 
     * @returns {*} Returns the resolved unwrapped value. 
     * @example 
     * 
     * _([1, 2, 3]).value(); 
     * // =&gt; [1, 2, 3] 
     */</span>
    <span class="s2">function </span><span class="s1">wrapperValue() {</span>
      <span class="s2">return </span><span class="s1">baseWrapperValue(</span><span class="s2">this</span><span class="s1">.__wrapped__, </span><span class="s2">this</span><span class="s1">.__actions__);</span>
    <span class="s1">}</span>

    <span class="s0">/*------------------------------------------------------------------------*/</span>

    <span class="s0">/** 
     * Creates an object composed of keys generated from the results of running 
     * each element of `collection` thru `iteratee`. The corresponding value of 
     * each key is the number of times the key was returned by `iteratee`. The 
     * iteratee is invoked with one argument: (value). 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.5.0 
     * @category Collection 
     * @param {Array|Object} collection The collection to iterate over. 
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys. 
     * @returns {Object} Returns the composed aggregate object. 
     * @example 
     * 
     * _.countBy([6.1, 4.2, 6.3], Math.floor); 
     * // =&gt; { '4': 1, '6': 2 } 
     * 
     * // The `_.property` iteratee shorthand. 
     * _.countBy(['one', 'two', 'three'], 'length'); 
     * // =&gt; { '3': 2, '5': 1 } 
     */</span>
    <span class="s2">var </span><span class="s1">countBy = createAggregator(</span><span class="s2">function</span><span class="s1">(result, value, key) {</span>
      <span class="s2">if </span><span class="s1">(hasOwnProperty.call(result, key)) {</span>
        <span class="s1">++result[key];</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">baseAssignValue(result, key, </span><span class="s4">1</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">});</span>

    <span class="s0">/** 
     * Checks if `predicate` returns truthy for **all** elements of `collection`. 
     * Iteration is stopped once `predicate` returns falsey. The predicate is 
     * invoked with three arguments: (value, index|key, collection). 
     * 
     * **Note:** This method returns `true` for 
     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because 
     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of 
     * elements of empty collections. 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.1.0 
     * @category Collection 
     * @param {Array|Object} collection The collection to iterate over. 
     * @param {Function} [predicate=_.identity] The function invoked per iteration. 
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`. 
     * @returns {boolean} Returns `true` if all elements pass the predicate check, 
     *  else `false`. 
     * @example 
     * 
     * _.every([true, 1, null, 'yes'], Boolean); 
     * // =&gt; false 
     * 
     * var users = [ 
     *   { 'user': 'barney', 'age': 36, 'active': false }, 
     *   { 'user': 'fred',   'age': 40, 'active': false } 
     * ]; 
     * 
     * // The `_.matches` iteratee shorthand. 
     * _.every(users, { 'user': 'barney', 'active': false }); 
     * // =&gt; false 
     * 
     * // The `_.matchesProperty` iteratee shorthand. 
     * _.every(users, ['active', false]); 
     * // =&gt; true 
     * 
     * // The `_.property` iteratee shorthand. 
     * _.every(users, 'active'); 
     * // =&gt; false 
     */</span>
    <span class="s2">function </span><span class="s1">every(collection, predicate, guard) {</span>
      <span class="s2">var </span><span class="s1">func = isArray(collection) ? arrayEvery : baseEvery;</span>
      <span class="s2">if </span><span class="s1">(guard &amp;&amp; isIterateeCall(collection, predicate, guard)) {</span>
        <span class="s1">predicate = undefined;</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">func(collection, getIteratee(predicate, </span><span class="s4">3</span><span class="s1">));</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Iterates over elements of `collection`, returning an array of all elements 
     * `predicate` returns truthy for. The predicate is invoked with three 
     * arguments: (value, index|key, collection). 
     * 
     * **Note:** Unlike `_.remove`, this method returns a new array. 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.1.0 
     * @category Collection 
     * @param {Array|Object} collection The collection to iterate over. 
     * @param {Function} [predicate=_.identity] The function invoked per iteration. 
     * @returns {Array} Returns the new filtered array. 
     * @see _.reject 
     * @example 
     * 
     * var users = [ 
     *   { 'user': 'barney', 'age': 36, 'active': true }, 
     *   { 'user': 'fred',   'age': 40, 'active': false } 
     * ]; 
     * 
     * _.filter(users, function(o) { return !o.active; }); 
     * // =&gt; objects for ['fred'] 
     * 
     * // The `_.matches` iteratee shorthand. 
     * _.filter(users, { 'age': 36, 'active': true }); 
     * // =&gt; objects for ['barney'] 
     * 
     * // The `_.matchesProperty` iteratee shorthand. 
     * _.filter(users, ['active', false]); 
     * // =&gt; objects for ['fred'] 
     * 
     * // The `_.property` iteratee shorthand. 
     * _.filter(users, 'active'); 
     * // =&gt; objects for ['barney'] 
     * 
     * // Combining several predicates using `_.overEvery` or `_.overSome`. 
     * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]])); 
     * // =&gt; objects for ['fred', 'barney'] 
     */</span>
    <span class="s2">function </span><span class="s1">filter(collection, predicate) {</span>
      <span class="s2">var </span><span class="s1">func = isArray(collection) ? arrayFilter : baseFilter;</span>
      <span class="s2">return </span><span class="s1">func(collection, getIteratee(predicate, </span><span class="s4">3</span><span class="s1">));</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Iterates over elements of `collection`, returning the first element 
     * `predicate` returns truthy for. The predicate is invoked with three 
     * arguments: (value, index|key, collection). 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.1.0 
     * @category Collection 
     * @param {Array|Object} collection The collection to inspect. 
     * @param {Function} [predicate=_.identity] The function invoked per iteration. 
     * @param {number} [fromIndex=0] The index to search from. 
     * @returns {*} Returns the matched element, else `undefined`. 
     * @example 
     * 
     * var users = [ 
     *   { 'user': 'barney',  'age': 36, 'active': true }, 
     *   { 'user': 'fred',    'age': 40, 'active': false }, 
     *   { 'user': 'pebbles', 'age': 1,  'active': true } 
     * ]; 
     * 
     * _.find(users, function(o) { return o.age &lt; 40; }); 
     * // =&gt; object for 'barney' 
     * 
     * // The `_.matches` iteratee shorthand. 
     * _.find(users, { 'age': 1, 'active': true }); 
     * // =&gt; object for 'pebbles' 
     * 
     * // The `_.matchesProperty` iteratee shorthand. 
     * _.find(users, ['active', false]); 
     * // =&gt; object for 'fred' 
     * 
     * // The `_.property` iteratee shorthand. 
     * _.find(users, 'active'); 
     * // =&gt; object for 'barney' 
     */</span>
    <span class="s2">var </span><span class="s1">find = createFind(findIndex);</span>

    <span class="s0">/** 
     * This method is like `_.find` except that it iterates over elements of 
     * `collection` from right to left. 
     * 
     * @static 
     * @memberOf _ 
     * @since 2.0.0 
     * @category Collection 
     * @param {Array|Object} collection The collection to inspect. 
     * @param {Function} [predicate=_.identity] The function invoked per iteration. 
     * @param {number} [fromIndex=collection.length-1] The index to search from. 
     * @returns {*} Returns the matched element, else `undefined`. 
     * @example 
     * 
     * _.findLast([1, 2, 3, 4], function(n) { 
     *   return n % 2 == 1; 
     * }); 
     * // =&gt; 3 
     */</span>
    <span class="s2">var </span><span class="s1">findLast = createFind(findLastIndex);</span>

    <span class="s0">/** 
     * Creates a flattened array of values by running each element in `collection` 
     * thru `iteratee` and flattening the mapped results. The iteratee is invoked 
     * with three arguments: (value, index|key, collection). 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Collection 
     * @param {Array|Object} collection The collection to iterate over. 
     * @param {Function} [iteratee=_.identity] The function invoked per iteration. 
     * @returns {Array} Returns the new flattened array. 
     * @example 
     * 
     * function duplicate(n) { 
     *   return [n, n]; 
     * } 
     * 
     * _.flatMap([1, 2], duplicate); 
     * // =&gt; [1, 1, 2, 2] 
     */</span>
    <span class="s2">function </span><span class="s1">flatMap(collection, iteratee) {</span>
      <span class="s2">return </span><span class="s1">baseFlatten(map(collection, iteratee), </span><span class="s4">1</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * This method is like `_.flatMap` except that it recursively flattens the 
     * mapped results. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.7.0 
     * @category Collection 
     * @param {Array|Object} collection The collection to iterate over. 
     * @param {Function} [iteratee=_.identity] The function invoked per iteration. 
     * @returns {Array} Returns the new flattened array. 
     * @example 
     * 
     * function duplicate(n) { 
     *   return [[[n, n]]]; 
     * } 
     * 
     * _.flatMapDeep([1, 2], duplicate); 
     * // =&gt; [1, 1, 2, 2] 
     */</span>
    <span class="s2">function </span><span class="s1">flatMapDeep(collection, iteratee) {</span>
      <span class="s2">return </span><span class="s1">baseFlatten(map(collection, iteratee), INFINITY);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * This method is like `_.flatMap` except that it recursively flattens the 
     * mapped results up to `depth` times. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.7.0 
     * @category Collection 
     * @param {Array|Object} collection The collection to iterate over. 
     * @param {Function} [iteratee=_.identity] The function invoked per iteration. 
     * @param {number} [depth=1] The maximum recursion depth. 
     * @returns {Array} Returns the new flattened array. 
     * @example 
     * 
     * function duplicate(n) { 
     *   return [[[n, n]]]; 
     * } 
     * 
     * _.flatMapDepth([1, 2], duplicate, 2); 
     * // =&gt; [[1, 1], [2, 2]] 
     */</span>
    <span class="s2">function </span><span class="s1">flatMapDepth(collection, iteratee, depth) {</span>
      <span class="s1">depth = depth === undefined ? </span><span class="s4">1 </span><span class="s1">: toInteger(depth);</span>
      <span class="s2">return </span><span class="s1">baseFlatten(map(collection, iteratee), depth);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Iterates over elements of `collection` and invokes `iteratee` for each element. 
     * The iteratee is invoked with three arguments: (value, index|key, collection). 
     * Iteratee functions may exit iteration early by explicitly returning `false`. 
     * 
     * **Note:** As with other &quot;Collections&quot; methods, objects with a &quot;length&quot; 
     * property are iterated like arrays. To avoid this behavior use `_.forIn` 
     * or `_.forOwn` for object iteration. 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.1.0 
     * @alias each 
     * @category Collection 
     * @param {Array|Object} collection The collection to iterate over. 
     * @param {Function} [iteratee=_.identity] The function invoked per iteration. 
     * @returns {Array|Object} Returns `collection`. 
     * @see _.forEachRight 
     * @example 
     * 
     * _.forEach([1, 2], function(value) { 
     *   console.log(value); 
     * }); 
     * // =&gt; Logs `1` then `2`. 
     * 
     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) { 
     *   console.log(key); 
     * }); 
     * // =&gt; Logs 'a' then 'b' (iteration order is not guaranteed). 
     */</span>
    <span class="s2">function </span><span class="s1">forEach(collection, iteratee) {</span>
      <span class="s2">var </span><span class="s1">func = isArray(collection) ? arrayEach : baseEach;</span>
      <span class="s2">return </span><span class="s1">func(collection, getIteratee(iteratee, </span><span class="s4">3</span><span class="s1">));</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * This method is like `_.forEach` except that it iterates over elements of 
     * `collection` from right to left. 
     * 
     * @static 
     * @memberOf _ 
     * @since 2.0.0 
     * @alias eachRight 
     * @category Collection 
     * @param {Array|Object} collection The collection to iterate over. 
     * @param {Function} [iteratee=_.identity] The function invoked per iteration. 
     * @returns {Array|Object} Returns `collection`. 
     * @see _.forEach 
     * @example 
     * 
     * _.forEachRight([1, 2], function(value) { 
     *   console.log(value); 
     * }); 
     * // =&gt; Logs `2` then `1`. 
     */</span>
    <span class="s2">function </span><span class="s1">forEachRight(collection, iteratee) {</span>
      <span class="s2">var </span><span class="s1">func = isArray(collection) ? arrayEachRight : baseEachRight;</span>
      <span class="s2">return </span><span class="s1">func(collection, getIteratee(iteratee, </span><span class="s4">3</span><span class="s1">));</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates an object composed of keys generated from the results of running 
     * each element of `collection` thru `iteratee`. The order of grouped values 
     * is determined by the order they occur in `collection`. The corresponding 
     * value of each key is an array of elements responsible for generating the 
     * key. The iteratee is invoked with one argument: (value). 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.1.0 
     * @category Collection 
     * @param {Array|Object} collection The collection to iterate over. 
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys. 
     * @returns {Object} Returns the composed aggregate object. 
     * @example 
     * 
     * _.groupBy([6.1, 4.2, 6.3], Math.floor); 
     * // =&gt; { '4': [4.2], '6': [6.1, 6.3] } 
     * 
     * // The `_.property` iteratee shorthand. 
     * _.groupBy(['one', 'two', 'three'], 'length'); 
     * // =&gt; { '3': ['one', 'two'], '5': ['three'] } 
     */</span>
    <span class="s2">var </span><span class="s1">groupBy = createAggregator(</span><span class="s2">function</span><span class="s1">(result, value, key) {</span>
      <span class="s2">if </span><span class="s1">(hasOwnProperty.call(result, key)) {</span>
        <span class="s1">result[key].push(value);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">baseAssignValue(result, key, [value]);</span>
      <span class="s1">}</span>
    <span class="s1">});</span>

    <span class="s0">/** 
     * Checks if `value` is in `collection`. If `collection` is a string, it's 
     * checked for a substring of `value`, otherwise 
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero) 
     * is used for equality comparisons. If `fromIndex` is negative, it's used as 
     * the offset from the end of `collection`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.1.0 
     * @category Collection 
     * @param {Array|Object|string} collection The collection to inspect. 
     * @param {*} value The value to search for. 
     * @param {number} [fromIndex=0] The index to search from. 
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`. 
     * @returns {boolean} Returns `true` if `value` is found, else `false`. 
     * @example 
     * 
     * _.includes([1, 2, 3], 1); 
     * // =&gt; true 
     * 
     * _.includes([1, 2, 3], 1, 2); 
     * // =&gt; false 
     * 
     * _.includes({ 'a': 1, 'b': 2 }, 1); 
     * // =&gt; true 
     * 
     * _.includes('abcd', 'bc'); 
     * // =&gt; true 
     */</span>
    <span class="s2">function </span><span class="s1">includes(collection, value, fromIndex, guard) {</span>
      <span class="s1">collection = isArrayLike(collection) ? collection : values(collection);</span>
      <span class="s1">fromIndex = (fromIndex &amp;&amp; !guard) ? toInteger(fromIndex) : </span><span class="s4">0</span><span class="s1">;</span>

      <span class="s2">var </span><span class="s1">length = collection.length;</span>
      <span class="s2">if </span><span class="s1">(fromIndex &lt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">fromIndex = nativeMax(length + fromIndex, </span><span class="s4">0</span><span class="s1">);</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">isString(collection)</span>
        <span class="s1">? (fromIndex &lt;= length &amp;&amp; collection.indexOf(value, fromIndex) &gt; -</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">: (!!length &amp;&amp; baseIndexOf(collection, value, fromIndex) &gt; -</span><span class="s4">1</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Invokes the method at `path` of each element in `collection`, returning 
     * an array of the results of each invoked method. Any additional arguments 
     * are provided to each invoked method. If `path` is a function, it's invoked 
     * for, and `this` bound to, each element in `collection`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Collection 
     * @param {Array|Object} collection The collection to iterate over. 
     * @param {Array|Function|string} path The path of the method to invoke or 
     *  the function invoked per iteration. 
     * @param {...*} [args] The arguments to invoke each method with. 
     * @returns {Array} Returns the array of results. 
     * @example 
     * 
     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort'); 
     * // =&gt; [[1, 5, 7], [1, 2, 3]] 
     * 
     * _.invokeMap([123, 456], String.prototype.split, ''); 
     * // =&gt; [['1', '2', '3'], ['4', '5', '6']] 
     */</span>
    <span class="s2">var </span><span class="s1">invokeMap = baseRest(</span><span class="s2">function</span><span class="s1">(collection, path, args) {</span>
      <span class="s2">var </span><span class="s1">index = -</span><span class="s4">1</span><span class="s1">,</span>
          <span class="s1">isFunc = </span><span class="s2">typeof </span><span class="s1">path == </span><span class="s3">'function'</span><span class="s1">,</span>
          <span class="s1">result = isArrayLike(collection) ? Array(collection.length) : [];</span>

      <span class="s1">baseEach(collection, </span><span class="s2">function</span><span class="s1">(value) {</span>
        <span class="s1">result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);</span>
      <span class="s1">});</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">});</span>

    <span class="s0">/** 
     * Creates an object composed of keys generated from the results of running 
     * each element of `collection` thru `iteratee`. The corresponding value of 
     * each key is the last element responsible for generating the key. The 
     * iteratee is invoked with one argument: (value). 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Collection 
     * @param {Array|Object} collection The collection to iterate over. 
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys. 
     * @returns {Object} Returns the composed aggregate object. 
     * @example 
     * 
     * var array = [ 
     *   { 'dir': 'left', 'code': 97 }, 
     *   { 'dir': 'right', 'code': 100 } 
     * ]; 
     * 
     * _.keyBy(array, function(o) { 
     *   return String.fromCharCode(o.code); 
     * }); 
     * // =&gt; { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } } 
     * 
     * _.keyBy(array, 'dir'); 
     * // =&gt; { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } } 
     */</span>
    <span class="s2">var </span><span class="s1">keyBy = createAggregator(</span><span class="s2">function</span><span class="s1">(result, value, key) {</span>
      <span class="s1">baseAssignValue(result, key, value);</span>
    <span class="s1">});</span>

    <span class="s0">/** 
     * Creates an array of values by running each element in `collection` thru 
     * `iteratee`. The iteratee is invoked with three arguments: 
     * (value, index|key, collection). 
     * 
     * Many lodash methods are guarded to work as iteratees for methods like 
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`. 
     * 
     * The guarded methods are: 
     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`, 
     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`, 
     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`, 
     * `template`, `trim`, `trimEnd`, `trimStart`, and `words` 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.1.0 
     * @category Collection 
     * @param {Array|Object} collection The collection to iterate over. 
     * @param {Function} [iteratee=_.identity] The function invoked per iteration. 
     * @returns {Array} Returns the new mapped array. 
     * @example 
     * 
     * function square(n) { 
     *   return n * n; 
     * } 
     * 
     * _.map([4, 8], square); 
     * // =&gt; [16, 64] 
     * 
     * _.map({ 'a': 4, 'b': 8 }, square); 
     * // =&gt; [16, 64] (iteration order is not guaranteed) 
     * 
     * var users = [ 
     *   { 'user': 'barney' }, 
     *   { 'user': 'fred' } 
     * ]; 
     * 
     * // The `_.property` iteratee shorthand. 
     * _.map(users, 'user'); 
     * // =&gt; ['barney', 'fred'] 
     */</span>
    <span class="s2">function </span><span class="s1">map(collection, iteratee) {</span>
      <span class="s2">var </span><span class="s1">func = isArray(collection) ? arrayMap : baseMap;</span>
      <span class="s2">return </span><span class="s1">func(collection, getIteratee(iteratee, </span><span class="s4">3</span><span class="s1">));</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * This method is like `_.sortBy` except that it allows specifying the sort 
     * orders of the iteratees to sort by. If `orders` is unspecified, all values 
     * are sorted in ascending order. Otherwise, specify an order of &quot;desc&quot; for 
     * descending or &quot;asc&quot; for ascending sort order of corresponding values. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Collection 
     * @param {Array|Object} collection The collection to iterate over. 
     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]] 
     *  The iteratees to sort by. 
     * @param {string[]} [orders] The sort orders of `iteratees`. 
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`. 
     * @returns {Array} Returns the new sorted array. 
     * @example 
     * 
     * var users = [ 
     *   { 'user': 'fred',   'age': 48 }, 
     *   { 'user': 'barney', 'age': 34 }, 
     *   { 'user': 'fred',   'age': 40 }, 
     *   { 'user': 'barney', 'age': 36 } 
     * ]; 
     * 
     * // Sort by `user` in ascending order and by `age` in descending order. 
     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']); 
     * // =&gt; objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]] 
     */</span>
    <span class="s2">function </span><span class="s1">orderBy(collection, iteratees, orders, guard) {</span>
      <span class="s2">if </span><span class="s1">(collection == </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">[];</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(!isArray(iteratees)) {</span>
        <span class="s1">iteratees = iteratees == </span><span class="s2">null </span><span class="s1">? [] : [iteratees];</span>
      <span class="s1">}</span>
      <span class="s1">orders = guard ? undefined : orders;</span>
      <span class="s2">if </span><span class="s1">(!isArray(orders)) {</span>
        <span class="s1">orders = orders == </span><span class="s2">null </span><span class="s1">? [] : [orders];</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">baseOrderBy(collection, iteratees, orders);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates an array of elements split into two groups, the first of which 
     * contains elements `predicate` returns truthy for, the second of which 
     * contains elements `predicate` returns falsey for. The predicate is 
     * invoked with one argument: (value). 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.0.0 
     * @category Collection 
     * @param {Array|Object} collection The collection to iterate over. 
     * @param {Function} [predicate=_.identity] The function invoked per iteration. 
     * @returns {Array} Returns the array of grouped elements. 
     * @example 
     * 
     * var users = [ 
     *   { 'user': 'barney',  'age': 36, 'active': false }, 
     *   { 'user': 'fred',    'age': 40, 'active': true }, 
     *   { 'user': 'pebbles', 'age': 1,  'active': false } 
     * ]; 
     * 
     * _.partition(users, function(o) { return o.active; }); 
     * // =&gt; objects for [['fred'], ['barney', 'pebbles']] 
     * 
     * // The `_.matches` iteratee shorthand. 
     * _.partition(users, { 'age': 1, 'active': false }); 
     * // =&gt; objects for [['pebbles'], ['barney', 'fred']] 
     * 
     * // The `_.matchesProperty` iteratee shorthand. 
     * _.partition(users, ['active', false]); 
     * // =&gt; objects for [['barney', 'pebbles'], ['fred']] 
     * 
     * // The `_.property` iteratee shorthand. 
     * _.partition(users, 'active'); 
     * // =&gt; objects for [['fred'], ['barney', 'pebbles']] 
     */</span>
    <span class="s2">var </span><span class="s1">partition = createAggregator(</span><span class="s2">function</span><span class="s1">(result, value, key) {</span>
      <span class="s1">result[key ? </span><span class="s4">0 </span><span class="s1">: </span><span class="s4">1</span><span class="s1">].push(value);</span>
    <span class="s1">}, </span><span class="s2">function</span><span class="s1">() { </span><span class="s2">return </span><span class="s1">[[], []]; });</span>

    <span class="s0">/** 
     * Reduces `collection` to a value which is the accumulated result of running 
     * each element in `collection` thru `iteratee`, where each successive 
     * invocation is supplied the return value of the previous. If `accumulator` 
     * is not given, the first element of `collection` is used as the initial 
     * value. The iteratee is invoked with four arguments: 
     * (accumulator, value, index|key, collection). 
     * 
     * Many lodash methods are guarded to work as iteratees for methods like 
     * `_.reduce`, `_.reduceRight`, and `_.transform`. 
     * 
     * The guarded methods are: 
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`, 
     * and `sortBy` 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.1.0 
     * @category Collection 
     * @param {Array|Object} collection The collection to iterate over. 
     * @param {Function} [iteratee=_.identity] The function invoked per iteration. 
     * @param {*} [accumulator] The initial value. 
     * @returns {*} Returns the accumulated value. 
     * @see _.reduceRight 
     * @example 
     * 
     * _.reduce([1, 2], function(sum, n) { 
     *   return sum + n; 
     * }, 0); 
     * // =&gt; 3 
     * 
     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) { 
     *   (result[value] || (result[value] = [])).push(key); 
     *   return result; 
     * }, {}); 
     * // =&gt; { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed) 
     */</span>
    <span class="s2">function </span><span class="s1">reduce(collection, iteratee, accumulator) {</span>
      <span class="s2">var </span><span class="s1">func = isArray(collection) ? arrayReduce : baseReduce,</span>
          <span class="s1">initAccum = arguments.length &lt; </span><span class="s4">3</span><span class="s1">;</span>

      <span class="s2">return </span><span class="s1">func(collection, getIteratee(iteratee, </span><span class="s4">4</span><span class="s1">), accumulator, initAccum, baseEach);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * This method is like `_.reduce` except that it iterates over elements of 
     * `collection` from right to left. 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.1.0 
     * @category Collection 
     * @param {Array|Object} collection The collection to iterate over. 
     * @param {Function} [iteratee=_.identity] The function invoked per iteration. 
     * @param {*} [accumulator] The initial value. 
     * @returns {*} Returns the accumulated value. 
     * @see _.reduce 
     * @example 
     * 
     * var array = [[0, 1], [2, 3], [4, 5]]; 
     * 
     * _.reduceRight(array, function(flattened, other) { 
     *   return flattened.concat(other); 
     * }, []); 
     * // =&gt; [4, 5, 2, 3, 0, 1] 
     */</span>
    <span class="s2">function </span><span class="s1">reduceRight(collection, iteratee, accumulator) {</span>
      <span class="s2">var </span><span class="s1">func = isArray(collection) ? arrayReduceRight : baseReduce,</span>
          <span class="s1">initAccum = arguments.length &lt; </span><span class="s4">3</span><span class="s1">;</span>

      <span class="s2">return </span><span class="s1">func(collection, getIteratee(iteratee, </span><span class="s4">4</span><span class="s1">), accumulator, initAccum, baseEachRight);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The opposite of `_.filter`; this method returns the elements of `collection` 
     * that `predicate` does **not** return truthy for. 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.1.0 
     * @category Collection 
     * @param {Array|Object} collection The collection to iterate over. 
     * @param {Function} [predicate=_.identity] The function invoked per iteration. 
     * @returns {Array} Returns the new filtered array. 
     * @see _.filter 
     * @example 
     * 
     * var users = [ 
     *   { 'user': 'barney', 'age': 36, 'active': false }, 
     *   { 'user': 'fred',   'age': 40, 'active': true } 
     * ]; 
     * 
     * _.reject(users, function(o) { return !o.active; }); 
     * // =&gt; objects for ['fred'] 
     * 
     * // The `_.matches` iteratee shorthand. 
     * _.reject(users, { 'age': 40, 'active': true }); 
     * // =&gt; objects for ['barney'] 
     * 
     * // The `_.matchesProperty` iteratee shorthand. 
     * _.reject(users, ['active', false]); 
     * // =&gt; objects for ['fred'] 
     * 
     * // The `_.property` iteratee shorthand. 
     * _.reject(users, 'active'); 
     * // =&gt; objects for ['barney'] 
     */</span>
    <span class="s2">function </span><span class="s1">reject(collection, predicate) {</span>
      <span class="s2">var </span><span class="s1">func = isArray(collection) ? arrayFilter : baseFilter;</span>
      <span class="s2">return </span><span class="s1">func(collection, negate(getIteratee(predicate, </span><span class="s4">3</span><span class="s1">)));</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Gets a random element from `collection`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 2.0.0 
     * @category Collection 
     * @param {Array|Object} collection The collection to sample. 
     * @returns {*} Returns the random element. 
     * @example 
     * 
     * _.sample([1, 2, 3, 4]); 
     * // =&gt; 2 
     */</span>
    <span class="s2">function </span><span class="s1">sample(collection) {</span>
      <span class="s2">var </span><span class="s1">func = isArray(collection) ? arraySample : baseSample;</span>
      <span class="s2">return </span><span class="s1">func(collection);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Gets `n` random elements at unique keys from `collection` up to the 
     * size of `collection`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Collection 
     * @param {Array|Object} collection The collection to sample. 
     * @param {number} [n=1] The number of elements to sample. 
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`. 
     * @returns {Array} Returns the random elements. 
     * @example 
     * 
     * _.sampleSize([1, 2, 3], 2); 
     * // =&gt; [3, 1] 
     * 
     * _.sampleSize([1, 2, 3], 4); 
     * // =&gt; [2, 3, 1] 
     */</span>
    <span class="s2">function </span><span class="s1">sampleSize(collection, n, guard) {</span>
      <span class="s2">if </span><span class="s1">((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {</span>
        <span class="s1">n = </span><span class="s4">1</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">n = toInteger(n);</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">func = isArray(collection) ? arraySampleSize : baseSampleSize;</span>
      <span class="s2">return </span><span class="s1">func(collection, n);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates an array of shuffled values, using a version of the 
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle). 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.1.0 
     * @category Collection 
     * @param {Array|Object} collection The collection to shuffle. 
     * @returns {Array} Returns the new shuffled array. 
     * @example 
     * 
     * _.shuffle([1, 2, 3, 4]); 
     * // =&gt; [4, 1, 3, 2] 
     */</span>
    <span class="s2">function </span><span class="s1">shuffle(collection) {</span>
      <span class="s2">var </span><span class="s1">func = isArray(collection) ? arrayShuffle : baseShuffle;</span>
      <span class="s2">return </span><span class="s1">func(collection);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Gets the size of `collection` by returning its length for array-like 
     * values or the number of own enumerable string keyed properties for objects. 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.1.0 
     * @category Collection 
     * @param {Array|Object|string} collection The collection to inspect. 
     * @returns {number} Returns the collection size. 
     * @example 
     * 
     * _.size([1, 2, 3]); 
     * // =&gt; 3 
     * 
     * _.size({ 'a': 1, 'b': 2 }); 
     * // =&gt; 2 
     * 
     * _.size('pebbles'); 
     * // =&gt; 7 
     */</span>
    <span class="s2">function </span><span class="s1">size(collection) {</span>
      <span class="s2">if </span><span class="s1">(collection == </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(isArrayLike(collection)) {</span>
        <span class="s2">return </span><span class="s1">isString(collection) ? stringSize(collection) : collection.length;</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">tag = getTag(collection);</span>
      <span class="s2">if </span><span class="s1">(tag == mapTag || tag == setTag) {</span>
        <span class="s2">return </span><span class="s1">collection.size;</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">baseKeys(collection).length;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Checks if `predicate` returns truthy for **any** element of `collection`. 
     * Iteration is stopped once `predicate` returns truthy. The predicate is 
     * invoked with three arguments: (value, index|key, collection). 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.1.0 
     * @category Collection 
     * @param {Array|Object} collection The collection to iterate over. 
     * @param {Function} [predicate=_.identity] The function invoked per iteration. 
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`. 
     * @returns {boolean} Returns `true` if any element passes the predicate check, 
     *  else `false`. 
     * @example 
     * 
     * _.some([null, 0, 'yes', false], Boolean); 
     * // =&gt; true 
     * 
     * var users = [ 
     *   { 'user': 'barney', 'active': true }, 
     *   { 'user': 'fred',   'active': false } 
     * ]; 
     * 
     * // The `_.matches` iteratee shorthand. 
     * _.some(users, { 'user': 'barney', 'active': false }); 
     * // =&gt; false 
     * 
     * // The `_.matchesProperty` iteratee shorthand. 
     * _.some(users, ['active', false]); 
     * // =&gt; true 
     * 
     * // The `_.property` iteratee shorthand. 
     * _.some(users, 'active'); 
     * // =&gt; true 
     */</span>
    <span class="s2">function </span><span class="s1">some(collection, predicate, guard) {</span>
      <span class="s2">var </span><span class="s1">func = isArray(collection) ? arraySome : baseSome;</span>
      <span class="s2">if </span><span class="s1">(guard &amp;&amp; isIterateeCall(collection, predicate, guard)) {</span>
        <span class="s1">predicate = undefined;</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">func(collection, getIteratee(predicate, </span><span class="s4">3</span><span class="s1">));</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates an array of elements, sorted in ascending order by the results of 
     * running each element in a collection thru each iteratee. This method 
     * performs a stable sort, that is, it preserves the original sort order of 
     * equal elements. The iteratees are invoked with one argument: (value). 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.1.0 
     * @category Collection 
     * @param {Array|Object} collection The collection to iterate over. 
     * @param {...(Function|Function[])} [iteratees=[_.identity]] 
     *  The iteratees to sort by. 
     * @returns {Array} Returns the new sorted array. 
     * @example 
     * 
     * var users = [ 
     *   { 'user': 'fred',   'age': 48 }, 
     *   { 'user': 'barney', 'age': 36 }, 
     *   { 'user': 'fred',   'age': 30 }, 
     *   { 'user': 'barney', 'age': 34 } 
     * ]; 
     * 
     * _.sortBy(users, [function(o) { return o.user; }]); 
     * // =&gt; objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]] 
     * 
     * _.sortBy(users, ['user', 'age']); 
     * // =&gt; objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]] 
     */</span>
    <span class="s2">var </span><span class="s1">sortBy = baseRest(</span><span class="s2">function</span><span class="s1">(collection, iteratees) {</span>
      <span class="s2">if </span><span class="s1">(collection == </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">[];</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">length = iteratees.length;</span>
      <span class="s2">if </span><span class="s1">(length &gt; </span><span class="s4">1 </span><span class="s1">&amp;&amp; isIterateeCall(collection, iteratees[</span><span class="s4">0</span><span class="s1">], iteratees[</span><span class="s4">1</span><span class="s1">])) {</span>
        <span class="s1">iteratees = [];</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(length &gt; </span><span class="s4">2 </span><span class="s1">&amp;&amp; isIterateeCall(iteratees[</span><span class="s4">0</span><span class="s1">], iteratees[</span><span class="s4">1</span><span class="s1">], iteratees[</span><span class="s4">2</span><span class="s1">])) {</span>
        <span class="s1">iteratees = [iteratees[</span><span class="s4">0</span><span class="s1">]];</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">baseOrderBy(collection, baseFlatten(iteratees, </span><span class="s4">1</span><span class="s1">), []);</span>
    <span class="s1">});</span>

    <span class="s0">/*------------------------------------------------------------------------*/</span>

    <span class="s0">/** 
     * Gets the timestamp of the number of milliseconds that have elapsed since 
     * the Unix epoch (1 January 1970 00:00:00 UTC). 
     * 
     * @static 
     * @memberOf _ 
     * @since 2.4.0 
     * @category Date 
     * @returns {number} Returns the timestamp. 
     * @example 
     * 
     * _.defer(function(stamp) { 
     *   console.log(_.now() - stamp); 
     * }, _.now()); 
     * // =&gt; Logs the number of milliseconds it took for the deferred invocation. 
     */</span>
    <span class="s2">var </span><span class="s1">now = ctxNow || </span><span class="s2">function</span><span class="s1">() {</span>
      <span class="s2">return </span><span class="s1">root.Date.now();</span>
    <span class="s1">};</span>

    <span class="s0">/*------------------------------------------------------------------------*/</span>

    <span class="s0">/** 
     * The opposite of `_.before`; this method creates a function that invokes 
     * `func` once it's called `n` or more times. 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.1.0 
     * @category Function 
     * @param {number} n The number of calls before `func` is invoked. 
     * @param {Function} func The function to restrict. 
     * @returns {Function} Returns the new restricted function. 
     * @example 
     * 
     * var saves = ['profile', 'settings']; 
     * 
     * var done = _.after(saves.length, function() { 
     *   console.log('done saving!'); 
     * }); 
     * 
     * _.forEach(saves, function(type) { 
     *   asyncSave({ 'type': type, 'complete': done }); 
     * }); 
     * // =&gt; Logs 'done saving!' after the two async saves have completed. 
     */</span>
    <span class="s2">function </span><span class="s1">after(n, func) {</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">func != </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s2">throw new </span><span class="s1">TypeError(FUNC_ERROR_TEXT);</span>
      <span class="s1">}</span>
      <span class="s1">n = toInteger(n);</span>
      <span class="s2">return function</span><span class="s1">() {</span>
        <span class="s2">if </span><span class="s1">(--n &lt; </span><span class="s4">1</span><span class="s1">) {</span>
          <span class="s2">return </span><span class="s1">func.apply(</span><span class="s2">this</span><span class="s1">, arguments);</span>
        <span class="s1">}</span>
      <span class="s1">};</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a function that invokes `func`, with up to `n` arguments, 
     * ignoring any additional arguments. 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.0.0 
     * @category Function 
     * @param {Function} func The function to cap arguments for. 
     * @param {number} [n=func.length] The arity cap. 
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`. 
     * @returns {Function} Returns the new capped function. 
     * @example 
     * 
     * _.map(['6', '8', '10'], _.ary(parseInt, 1)); 
     * // =&gt; [6, 8, 10] 
     */</span>
    <span class="s2">function </span><span class="s1">ary(func, n, guard) {</span>
      <span class="s1">n = guard ? undefined : n;</span>
      <span class="s1">n = (func &amp;&amp; n == </span><span class="s2">null</span><span class="s1">) ? func.length : n;</span>
      <span class="s2">return </span><span class="s1">createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a function that invokes `func`, with the `this` binding and arguments 
     * of the created function, while it's called less than `n` times. Subsequent 
     * calls to the created function return the result of the last `func` invocation. 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.0.0 
     * @category Function 
     * @param {number} n The number of calls at which `func` is no longer invoked. 
     * @param {Function} func The function to restrict. 
     * @returns {Function} Returns the new restricted function. 
     * @example 
     * 
     * jQuery(element).on('click', _.before(5, addContactToList)); 
     * // =&gt; Allows adding up to 4 contacts to the list. 
     */</span>
    <span class="s2">function </span><span class="s1">before(n, func) {</span>
      <span class="s2">var </span><span class="s1">result;</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">func != </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s2">throw new </span><span class="s1">TypeError(FUNC_ERROR_TEXT);</span>
      <span class="s1">}</span>
      <span class="s1">n = toInteger(n);</span>
      <span class="s2">return function</span><span class="s1">() {</span>
        <span class="s2">if </span><span class="s1">(--n &gt; </span><span class="s4">0</span><span class="s1">) {</span>
          <span class="s1">result = func.apply(</span><span class="s2">this</span><span class="s1">, arguments);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(n &lt;= </span><span class="s4">1</span><span class="s1">) {</span>
          <span class="s1">func = undefined;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">result;</span>
      <span class="s1">};</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a function that invokes `func` with the `this` binding of `thisArg` 
     * and `partials` prepended to the arguments it receives. 
     * 
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds, 
     * may be used as a placeholder for partially applied arguments. 
     * 
     * **Note:** Unlike native `Function#bind`, this method doesn't set the &quot;length&quot; 
     * property of bound functions. 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.1.0 
     * @category Function 
     * @param {Function} func The function to bind. 
     * @param {*} thisArg The `this` binding of `func`. 
     * @param {...*} [partials] The arguments to be partially applied. 
     * @returns {Function} Returns the new bound function. 
     * @example 
     * 
     * function greet(greeting, punctuation) { 
     *   return greeting + ' ' + this.user + punctuation; 
     * } 
     * 
     * var object = { 'user': 'fred' }; 
     * 
     * var bound = _.bind(greet, object, 'hi'); 
     * bound('!'); 
     * // =&gt; 'hi fred!' 
     * 
     * // Bound with placeholders. 
     * var bound = _.bind(greet, object, _, '!'); 
     * bound('hi'); 
     * // =&gt; 'hi fred!' 
     */</span>
    <span class="s2">var </span><span class="s1">bind = baseRest(</span><span class="s2">function</span><span class="s1">(func, thisArg, partials) {</span>
      <span class="s2">var </span><span class="s1">bitmask = WRAP_BIND_FLAG;</span>
      <span class="s2">if </span><span class="s1">(partials.length) {</span>
        <span class="s2">var </span><span class="s1">holders = replaceHolders(partials, getHolder(bind));</span>
        <span class="s1">bitmask |= WRAP_PARTIAL_FLAG;</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">createWrap(func, bitmask, thisArg, partials, holders);</span>
    <span class="s1">});</span>

    <span class="s0">/** 
     * Creates a function that invokes the method at `object[key]` with `partials` 
     * prepended to the arguments it receives. 
     * 
     * This method differs from `_.bind` by allowing bound functions to reference 
     * methods that may be redefined or don't yet exist. See 
     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern) 
     * for more details. 
     * 
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic 
     * builds, may be used as a placeholder for partially applied arguments. 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.10.0 
     * @category Function 
     * @param {Object} object The object to invoke the method on. 
     * @param {string} key The key of the method. 
     * @param {...*} [partials] The arguments to be partially applied. 
     * @returns {Function} Returns the new bound function. 
     * @example 
     * 
     * var object = { 
     *   'user': 'fred', 
     *   'greet': function(greeting, punctuation) { 
     *     return greeting + ' ' + this.user + punctuation; 
     *   } 
     * }; 
     * 
     * var bound = _.bindKey(object, 'greet', 'hi'); 
     * bound('!'); 
     * // =&gt; 'hi fred!' 
     * 
     * object.greet = function(greeting, punctuation) { 
     *   return greeting + 'ya ' + this.user + punctuation; 
     * }; 
     * 
     * bound('!'); 
     * // =&gt; 'hiya fred!' 
     * 
     * // Bound with placeholders. 
     * var bound = _.bindKey(object, 'greet', _, '!'); 
     * bound('hi'); 
     * // =&gt; 'hiya fred!' 
     */</span>
    <span class="s2">var </span><span class="s1">bindKey = baseRest(</span><span class="s2">function</span><span class="s1">(object, key, partials) {</span>
      <span class="s2">var </span><span class="s1">bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;</span>
      <span class="s2">if </span><span class="s1">(partials.length) {</span>
        <span class="s2">var </span><span class="s1">holders = replaceHolders(partials, getHolder(bindKey));</span>
        <span class="s1">bitmask |= WRAP_PARTIAL_FLAG;</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">createWrap(key, bitmask, object, partials, holders);</span>
    <span class="s1">});</span>

    <span class="s0">/** 
     * Creates a function that accepts arguments of `func` and either invokes 
     * `func` returning its result, if at least `arity` number of arguments have 
     * been provided, or returns a function that accepts the remaining `func` 
     * arguments, and so on. The arity of `func` may be specified if `func.length` 
     * is not sufficient. 
     * 
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds, 
     * may be used as a placeholder for provided arguments. 
     * 
     * **Note:** This method doesn't set the &quot;length&quot; property of curried functions. 
     * 
     * @static 
     * @memberOf _ 
     * @since 2.0.0 
     * @category Function 
     * @param {Function} func The function to curry. 
     * @param {number} [arity=func.length] The arity of `func`. 
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`. 
     * @returns {Function} Returns the new curried function. 
     * @example 
     * 
     * var abc = function(a, b, c) { 
     *   return [a, b, c]; 
     * }; 
     * 
     * var curried = _.curry(abc); 
     * 
     * curried(1)(2)(3); 
     * // =&gt; [1, 2, 3] 
     * 
     * curried(1, 2)(3); 
     * // =&gt; [1, 2, 3] 
     * 
     * curried(1, 2, 3); 
     * // =&gt; [1, 2, 3] 
     * 
     * // Curried with placeholders. 
     * curried(1)(_, 3)(2); 
     * // =&gt; [1, 2, 3] 
     */</span>
    <span class="s2">function </span><span class="s1">curry(func, arity, guard) {</span>
      <span class="s1">arity = guard ? undefined : arity;</span>
      <span class="s2">var </span><span class="s1">result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);</span>
      <span class="s1">result.placeholder = curry.placeholder;</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * This method is like `_.curry` except that arguments are applied to `func` 
     * in the manner of `_.partialRight` instead of `_.partial`. 
     * 
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic 
     * builds, may be used as a placeholder for provided arguments. 
     * 
     * **Note:** This method doesn't set the &quot;length&quot; property of curried functions. 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.0.0 
     * @category Function 
     * @param {Function} func The function to curry. 
     * @param {number} [arity=func.length] The arity of `func`. 
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`. 
     * @returns {Function} Returns the new curried function. 
     * @example 
     * 
     * var abc = function(a, b, c) { 
     *   return [a, b, c]; 
     * }; 
     * 
     * var curried = _.curryRight(abc); 
     * 
     * curried(3)(2)(1); 
     * // =&gt; [1, 2, 3] 
     * 
     * curried(2, 3)(1); 
     * // =&gt; [1, 2, 3] 
     * 
     * curried(1, 2, 3); 
     * // =&gt; [1, 2, 3] 
     * 
     * // Curried with placeholders. 
     * curried(3)(1, _)(2); 
     * // =&gt; [1, 2, 3] 
     */</span>
    <span class="s2">function </span><span class="s1">curryRight(func, arity, guard) {</span>
      <span class="s1">arity = guard ? undefined : arity;</span>
      <span class="s2">var </span><span class="s1">result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);</span>
      <span class="s1">result.placeholder = curryRight.placeholder;</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a debounced function that delays invoking `func` until after `wait` 
     * milliseconds have elapsed since the last time the debounced function was 
     * invoked. The debounced function comes with a `cancel` method to cancel 
     * delayed `func` invocations and a `flush` method to immediately invoke them. 
     * Provide `options` to indicate whether `func` should be invoked on the 
     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked 
     * with the last arguments provided to the debounced function. Subsequent 
     * calls to the debounced function return the result of the last `func` 
     * invocation. 
     * 
     * **Note:** If `leading` and `trailing` options are `true`, `func` is 
     * invoked on the trailing edge of the timeout only if the debounced function 
     * is invoked more than once during the `wait` timeout. 
     * 
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred 
     * until to the next tick, similar to `setTimeout` with a timeout of `0`. 
     * 
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/) 
     * for details over the differences between `_.debounce` and `_.throttle`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.1.0 
     * @category Function 
     * @param {Function} func The function to debounce. 
     * @param {number} [wait=0] The number of milliseconds to delay. 
     * @param {Object} [options={}] The options object. 
     * @param {boolean} [options.leading=false] 
     *  Specify invoking on the leading edge of the timeout. 
     * @param {number} [options.maxWait] 
     *  The maximum time `func` is allowed to be delayed before it's invoked. 
     * @param {boolean} [options.trailing=true] 
     *  Specify invoking on the trailing edge of the timeout. 
     * @returns {Function} Returns the new debounced function. 
     * @example 
     * 
     * // Avoid costly calculations while the window size is in flux. 
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150)); 
     * 
     * // Invoke `sendMail` when clicked, debouncing subsequent calls. 
     * jQuery(element).on('click', _.debounce(sendMail, 300, { 
     *   'leading': true, 
     *   'trailing': false 
     * })); 
     * 
     * // Ensure `batchLog` is invoked once after 1 second of debounced calls. 
     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 }); 
     * var source = new EventSource('/stream'); 
     * jQuery(source).on('message', debounced); 
     * 
     * // Cancel the trailing debounced invocation. 
     * jQuery(window).on('popstate', debounced.cancel); 
     */</span>
    <span class="s2">function </span><span class="s1">debounce(func, wait, options) {</span>
      <span class="s2">var </span><span class="s1">lastArgs,</span>
          <span class="s1">lastThis,</span>
          <span class="s1">maxWait,</span>
          <span class="s1">result,</span>
          <span class="s1">timerId,</span>
          <span class="s1">lastCallTime,</span>
          <span class="s1">lastInvokeTime = </span><span class="s4">0</span><span class="s1">,</span>
          <span class="s1">leading = </span><span class="s2">false</span><span class="s1">,</span>
          <span class="s1">maxing = </span><span class="s2">false</span><span class="s1">,</span>
          <span class="s1">trailing = </span><span class="s2">true</span><span class="s1">;</span>

      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">func != </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s2">throw new </span><span class="s1">TypeError(FUNC_ERROR_TEXT);</span>
      <span class="s1">}</span>
      <span class="s1">wait = toNumber(wait) || </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s2">if </span><span class="s1">(isObject(options)) {</span>
        <span class="s1">leading = !!options.leading;</span>
        <span class="s1">maxing = </span><span class="s3">'maxWait' </span><span class="s2">in </span><span class="s1">options;</span>
        <span class="s1">maxWait = maxing ? nativeMax(toNumber(options.maxWait) || </span><span class="s4">0</span><span class="s1">, wait) : maxWait;</span>
        <span class="s1">trailing = </span><span class="s3">'trailing' </span><span class="s2">in </span><span class="s1">options ? !!options.trailing : trailing;</span>
      <span class="s1">}</span>

      <span class="s2">function </span><span class="s1">invokeFunc(time) {</span>
        <span class="s2">var </span><span class="s1">args = lastArgs,</span>
            <span class="s1">thisArg = lastThis;</span>

        <span class="s1">lastArgs = lastThis = undefined;</span>
        <span class="s1">lastInvokeTime = time;</span>
        <span class="s1">result = func.apply(thisArg, args);</span>
        <span class="s2">return </span><span class="s1">result;</span>
      <span class="s1">}</span>

      <span class="s2">function </span><span class="s1">leadingEdge(time) {</span>
        <span class="s0">// Reset any `maxWait` timer.</span>
        <span class="s1">lastInvokeTime = time;</span>
        <span class="s0">// Start the timer for the trailing edge.</span>
        <span class="s1">timerId = setTimeout(timerExpired, wait);</span>
        <span class="s0">// Invoke the leading edge.</span>
        <span class="s2">return </span><span class="s1">leading ? invokeFunc(time) : result;</span>
      <span class="s1">}</span>

      <span class="s2">function </span><span class="s1">remainingWait(time) {</span>
        <span class="s2">var </span><span class="s1">timeSinceLastCall = time - lastCallTime,</span>
            <span class="s1">timeSinceLastInvoke = time - lastInvokeTime,</span>
            <span class="s1">timeWaiting = wait - timeSinceLastCall;</span>

        <span class="s2">return </span><span class="s1">maxing</span>
          <span class="s1">? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)</span>
          <span class="s1">: timeWaiting;</span>
      <span class="s1">}</span>

      <span class="s2">function </span><span class="s1">shouldInvoke(time) {</span>
        <span class="s2">var </span><span class="s1">timeSinceLastCall = time - lastCallTime,</span>
            <span class="s1">timeSinceLastInvoke = time - lastInvokeTime;</span>

        <span class="s0">// Either this is the first call, activity has stopped and we're at the</span>
        <span class="s0">// trailing edge, the system time has gone backwards and we're treating</span>
        <span class="s0">// it as the trailing edge, or we've hit the `maxWait` limit.</span>
        <span class="s2">return </span><span class="s1">(lastCallTime === undefined || (timeSinceLastCall &gt;= wait) ||</span>
          <span class="s1">(timeSinceLastCall &lt; </span><span class="s4">0</span><span class="s1">) || (maxing &amp;&amp; timeSinceLastInvoke &gt;= maxWait));</span>
      <span class="s1">}</span>

      <span class="s2">function </span><span class="s1">timerExpired() {</span>
        <span class="s2">var </span><span class="s1">time = now();</span>
        <span class="s2">if </span><span class="s1">(shouldInvoke(time)) {</span>
          <span class="s2">return </span><span class="s1">trailingEdge(time);</span>
        <span class="s1">}</span>
        <span class="s0">// Restart the timer.</span>
        <span class="s1">timerId = setTimeout(timerExpired, remainingWait(time));</span>
      <span class="s1">}</span>

      <span class="s2">function </span><span class="s1">trailingEdge(time) {</span>
        <span class="s1">timerId = undefined;</span>

        <span class="s0">// Only invoke if we have `lastArgs` which means `func` has been</span>
        <span class="s0">// debounced at least once.</span>
        <span class="s2">if </span><span class="s1">(trailing &amp;&amp; lastArgs) {</span>
          <span class="s2">return </span><span class="s1">invokeFunc(time);</span>
        <span class="s1">}</span>
        <span class="s1">lastArgs = lastThis = undefined;</span>
        <span class="s2">return </span><span class="s1">result;</span>
      <span class="s1">}</span>

      <span class="s2">function </span><span class="s1">cancel() {</span>
        <span class="s2">if </span><span class="s1">(timerId !== undefined) {</span>
          <span class="s1">clearTimeout(timerId);</span>
        <span class="s1">}</span>
        <span class="s1">lastInvokeTime = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">lastArgs = lastCallTime = lastThis = timerId = undefined;</span>
      <span class="s1">}</span>

      <span class="s2">function </span><span class="s1">flush() {</span>
        <span class="s2">return </span><span class="s1">timerId === undefined ? result : trailingEdge(now());</span>
      <span class="s1">}</span>

      <span class="s2">function </span><span class="s1">debounced() {</span>
        <span class="s2">var </span><span class="s1">time = now(),</span>
            <span class="s1">isInvoking = shouldInvoke(time);</span>

        <span class="s1">lastArgs = arguments;</span>
        <span class="s1">lastThis = </span><span class="s2">this</span><span class="s1">;</span>
        <span class="s1">lastCallTime = time;</span>

        <span class="s2">if </span><span class="s1">(isInvoking) {</span>
          <span class="s2">if </span><span class="s1">(timerId === undefined) {</span>
            <span class="s2">return </span><span class="s1">leadingEdge(lastCallTime);</span>
          <span class="s1">}</span>
          <span class="s2">if </span><span class="s1">(maxing) {</span>
            <span class="s0">// Handle invocations in a tight loop.</span>
            <span class="s1">clearTimeout(timerId);</span>
            <span class="s1">timerId = setTimeout(timerExpired, wait);</span>
            <span class="s2">return </span><span class="s1">invokeFunc(lastCallTime);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(timerId === undefined) {</span>
          <span class="s1">timerId = setTimeout(timerExpired, wait);</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">result;</span>
      <span class="s1">}</span>
      <span class="s1">debounced.cancel = cancel;</span>
      <span class="s1">debounced.flush = flush;</span>
      <span class="s2">return </span><span class="s1">debounced;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Defers invoking the `func` until the current call stack has cleared. Any 
     * additional arguments are provided to `func` when it's invoked. 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.1.0 
     * @category Function 
     * @param {Function} func The function to defer. 
     * @param {...*} [args] The arguments to invoke `func` with. 
     * @returns {number} Returns the timer id. 
     * @example 
     * 
     * _.defer(function(text) { 
     *   console.log(text); 
     * }, 'deferred'); 
     * // =&gt; Logs 'deferred' after one millisecond. 
     */</span>
    <span class="s2">var </span><span class="s1">defer = baseRest(</span><span class="s2">function</span><span class="s1">(func, args) {</span>
      <span class="s2">return </span><span class="s1">baseDelay(func, </span><span class="s4">1</span><span class="s1">, args);</span>
    <span class="s1">});</span>

    <span class="s0">/** 
     * Invokes `func` after `wait` milliseconds. Any additional arguments are 
     * provided to `func` when it's invoked. 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.1.0 
     * @category Function 
     * @param {Function} func The function to delay. 
     * @param {number} wait The number of milliseconds to delay invocation. 
     * @param {...*} [args] The arguments to invoke `func` with. 
     * @returns {number} Returns the timer id. 
     * @example 
     * 
     * _.delay(function(text) { 
     *   console.log(text); 
     * }, 1000, 'later'); 
     * // =&gt; Logs 'later' after one second. 
     */</span>
    <span class="s2">var </span><span class="s1">delay = baseRest(</span><span class="s2">function</span><span class="s1">(func, wait, args) {</span>
      <span class="s2">return </span><span class="s1">baseDelay(func, toNumber(wait) || </span><span class="s4">0</span><span class="s1">, args);</span>
    <span class="s1">});</span>

    <span class="s0">/** 
     * Creates a function that invokes `func` with arguments reversed. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Function 
     * @param {Function} func The function to flip arguments for. 
     * @returns {Function} Returns the new flipped function. 
     * @example 
     * 
     * var flipped = _.flip(function() { 
     *   return _.toArray(arguments); 
     * }); 
     * 
     * flipped('a', 'b', 'c', 'd'); 
     * // =&gt; ['d', 'c', 'b', 'a'] 
     */</span>
    <span class="s2">function </span><span class="s1">flip(func) {</span>
      <span class="s2">return </span><span class="s1">createWrap(func, WRAP_FLIP_FLAG);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a function that memoizes the result of `func`. If `resolver` is 
     * provided, it determines the cache key for storing the result based on the 
     * arguments provided to the memoized function. By default, the first argument 
     * provided to the memoized function is used as the map cache key. The `func` 
     * is invoked with the `this` binding of the memoized function. 
     * 
     * **Note:** The cache is exposed as the `cache` property on the memoized 
     * function. Its creation may be customized by replacing the `_.memoize.Cache` 
     * constructor with one whose instances implement the 
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object) 
     * method interface of `clear`, `delete`, `get`, `has`, and `set`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.1.0 
     * @category Function 
     * @param {Function} func The function to have its output memoized. 
     * @param {Function} [resolver] The function to resolve the cache key. 
     * @returns {Function} Returns the new memoized function. 
     * @example 
     * 
     * var object = { 'a': 1, 'b': 2 }; 
     * var other = { 'c': 3, 'd': 4 }; 
     * 
     * var values = _.memoize(_.values); 
     * values(object); 
     * // =&gt; [1, 2] 
     * 
     * values(other); 
     * // =&gt; [3, 4] 
     * 
     * object.a = 2; 
     * values(object); 
     * // =&gt; [1, 2] 
     * 
     * // Modify the result cache. 
     * values.cache.set(object, ['a', 'b']); 
     * values(object); 
     * // =&gt; ['a', 'b'] 
     * 
     * // Replace `_.memoize.Cache`. 
     * _.memoize.Cache = WeakMap; 
     */</span>
    <span class="s2">function </span><span class="s1">memoize(func, resolver) {</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">func != </span><span class="s3">'function' </span><span class="s1">|| (resolver != </span><span class="s2">null </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">resolver != </span><span class="s3">'function'</span><span class="s1">)) {</span>
        <span class="s2">throw new </span><span class="s1">TypeError(FUNC_ERROR_TEXT);</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">memoized = </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">var </span><span class="s1">args = arguments,</span>
            <span class="s1">key = resolver ? resolver.apply(</span><span class="s2">this</span><span class="s1">, args) : args[</span><span class="s4">0</span><span class="s1">],</span>
            <span class="s1">cache = memoized.cache;</span>

        <span class="s2">if </span><span class="s1">(cache.has(key)) {</span>
          <span class="s2">return </span><span class="s1">cache.get(key);</span>
        <span class="s1">}</span>
        <span class="s2">var </span><span class="s1">result = func.apply(</span><span class="s2">this</span><span class="s1">, args);</span>
        <span class="s1">memoized.cache = cache.set(key, result) || cache;</span>
        <span class="s2">return </span><span class="s1">result;</span>
      <span class="s1">};</span>
      <span class="s1">memoized.cache = </span><span class="s2">new </span><span class="s1">(memoize.Cache || MapCache);</span>
      <span class="s2">return </span><span class="s1">memoized;</span>
    <span class="s1">}</span>

    <span class="s0">// Expose `MapCache`.</span>
    <span class="s1">memoize.Cache = MapCache;</span>

    <span class="s0">/** 
     * Creates a function that negates the result of the predicate `func`. The 
     * `func` predicate is invoked with the `this` binding and arguments of the 
     * created function. 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.0.0 
     * @category Function 
     * @param {Function} predicate The predicate to negate. 
     * @returns {Function} Returns the new negated function. 
     * @example 
     * 
     * function isEven(n) { 
     *   return n % 2 == 0; 
     * } 
     * 
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven)); 
     * // =&gt; [1, 3, 5] 
     */</span>
    <span class="s2">function </span><span class="s1">negate(predicate) {</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">predicate != </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s2">throw new </span><span class="s1">TypeError(FUNC_ERROR_TEXT);</span>
      <span class="s1">}</span>
      <span class="s2">return function</span><span class="s1">() {</span>
        <span class="s2">var </span><span class="s1">args = arguments;</span>
        <span class="s2">switch </span><span class="s1">(args.length) {</span>
          <span class="s2">case </span><span class="s4">0</span><span class="s1">: </span><span class="s2">return </span><span class="s1">!predicate.call(</span><span class="s2">this</span><span class="s1">);</span>
          <span class="s2">case </span><span class="s4">1</span><span class="s1">: </span><span class="s2">return </span><span class="s1">!predicate.call(</span><span class="s2">this</span><span class="s1">, args[</span><span class="s4">0</span><span class="s1">]);</span>
          <span class="s2">case </span><span class="s4">2</span><span class="s1">: </span><span class="s2">return </span><span class="s1">!predicate.call(</span><span class="s2">this</span><span class="s1">, args[</span><span class="s4">0</span><span class="s1">], args[</span><span class="s4">1</span><span class="s1">]);</span>
          <span class="s2">case </span><span class="s4">3</span><span class="s1">: </span><span class="s2">return </span><span class="s1">!predicate.call(</span><span class="s2">this</span><span class="s1">, args[</span><span class="s4">0</span><span class="s1">], args[</span><span class="s4">1</span><span class="s1">], args[</span><span class="s4">2</span><span class="s1">]);</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">!predicate.apply(</span><span class="s2">this</span><span class="s1">, args);</span>
      <span class="s1">};</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a function that is restricted to invoking `func` once. Repeat calls 
     * to the function return the value of the first invocation. The `func` is 
     * invoked with the `this` binding and arguments of the created function. 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.1.0 
     * @category Function 
     * @param {Function} func The function to restrict. 
     * @returns {Function} Returns the new restricted function. 
     * @example 
     * 
     * var initialize = _.once(createApplication); 
     * initialize(); 
     * initialize(); 
     * // =&gt; `createApplication` is invoked once 
     */</span>
    <span class="s2">function </span><span class="s1">once(func) {</span>
      <span class="s2">return </span><span class="s1">before(</span><span class="s4">2</span><span class="s1">, func);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a function that invokes `func` with its arguments transformed. 
     * 
     * @static 
     * @since 4.0.0 
     * @memberOf _ 
     * @category Function 
     * @param {Function} func The function to wrap. 
     * @param {...(Function|Function[])} [transforms=[_.identity]] 
     *  The argument transforms. 
     * @returns {Function} Returns the new function. 
     * @example 
     * 
     * function doubled(n) { 
     *   return n * 2; 
     * } 
     * 
     * function square(n) { 
     *   return n * n; 
     * } 
     * 
     * var func = _.overArgs(function(x, y) { 
     *   return [x, y]; 
     * }, [square, doubled]); 
     * 
     * func(9, 3); 
     * // =&gt; [81, 6] 
     * 
     * func(10, 5); 
     * // =&gt; [100, 10] 
     */</span>
    <span class="s2">var </span><span class="s1">overArgs = castRest(</span><span class="s2">function</span><span class="s1">(func, transforms) {</span>
      <span class="s1">transforms = (transforms.length == </span><span class="s4">1 </span><span class="s1">&amp;&amp; isArray(transforms[</span><span class="s4">0</span><span class="s1">]))</span>
        <span class="s1">? arrayMap(transforms[</span><span class="s4">0</span><span class="s1">], baseUnary(getIteratee()))</span>
        <span class="s1">: arrayMap(baseFlatten(transforms, </span><span class="s4">1</span><span class="s1">), baseUnary(getIteratee()));</span>

      <span class="s2">var </span><span class="s1">funcsLength = transforms.length;</span>
      <span class="s2">return </span><span class="s1">baseRest(</span><span class="s2">function</span><span class="s1">(args) {</span>
        <span class="s2">var </span><span class="s1">index = -</span><span class="s4">1</span><span class="s1">,</span>
            <span class="s1">length = nativeMin(args.length, funcsLength);</span>

        <span class="s2">while </span><span class="s1">(++index &lt; length) {</span>
          <span class="s1">args[index] = transforms[index].call(</span><span class="s2">this</span><span class="s1">, args[index]);</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">apply(func, </span><span class="s2">this</span><span class="s1">, args);</span>
      <span class="s1">});</span>
    <span class="s1">});</span>

    <span class="s0">/** 
     * Creates a function that invokes `func` with `partials` prepended to the 
     * arguments it receives. This method is like `_.bind` except it does **not** 
     * alter the `this` binding. 
     * 
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic 
     * builds, may be used as a placeholder for partially applied arguments. 
     * 
     * **Note:** This method doesn't set the &quot;length&quot; property of partially 
     * applied functions. 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.2.0 
     * @category Function 
     * @param {Function} func The function to partially apply arguments to. 
     * @param {...*} [partials] The arguments to be partially applied. 
     * @returns {Function} Returns the new partially applied function. 
     * @example 
     * 
     * function greet(greeting, name) { 
     *   return greeting + ' ' + name; 
     * } 
     * 
     * var sayHelloTo = _.partial(greet, 'hello'); 
     * sayHelloTo('fred'); 
     * // =&gt; 'hello fred' 
     * 
     * // Partially applied with placeholders. 
     * var greetFred = _.partial(greet, _, 'fred'); 
     * greetFred('hi'); 
     * // =&gt; 'hi fred' 
     */</span>
    <span class="s2">var </span><span class="s1">partial = baseRest(</span><span class="s2">function</span><span class="s1">(func, partials) {</span>
      <span class="s2">var </span><span class="s1">holders = replaceHolders(partials, getHolder(partial));</span>
      <span class="s2">return </span><span class="s1">createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);</span>
    <span class="s1">});</span>

    <span class="s0">/** 
     * This method is like `_.partial` except that partially applied arguments 
     * are appended to the arguments it receives. 
     * 
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic 
     * builds, may be used as a placeholder for partially applied arguments. 
     * 
     * **Note:** This method doesn't set the &quot;length&quot; property of partially 
     * applied functions. 
     * 
     * @static 
     * @memberOf _ 
     * @since 1.0.0 
     * @category Function 
     * @param {Function} func The function to partially apply arguments to. 
     * @param {...*} [partials] The arguments to be partially applied. 
     * @returns {Function} Returns the new partially applied function. 
     * @example 
     * 
     * function greet(greeting, name) { 
     *   return greeting + ' ' + name; 
     * } 
     * 
     * var greetFred = _.partialRight(greet, 'fred'); 
     * greetFred('hi'); 
     * // =&gt; 'hi fred' 
     * 
     * // Partially applied with placeholders. 
     * var sayHelloTo = _.partialRight(greet, 'hello', _); 
     * sayHelloTo('fred'); 
     * // =&gt; 'hello fred' 
     */</span>
    <span class="s2">var </span><span class="s1">partialRight = baseRest(</span><span class="s2">function</span><span class="s1">(func, partials) {</span>
      <span class="s2">var </span><span class="s1">holders = replaceHolders(partials, getHolder(partialRight));</span>
      <span class="s2">return </span><span class="s1">createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);</span>
    <span class="s1">});</span>

    <span class="s0">/** 
     * Creates a function that invokes `func` with arguments arranged according 
     * to the specified `indexes` where the argument value at the first index is 
     * provided as the first argument, the argument value at the second index is 
     * provided as the second argument, and so on. 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.0.0 
     * @category Function 
     * @param {Function} func The function to rearrange arguments for. 
     * @param {...(number|number[])} indexes The arranged argument indexes. 
     * @returns {Function} Returns the new function. 
     * @example 
     * 
     * var rearged = _.rearg(function(a, b, c) { 
     *   return [a, b, c]; 
     * }, [2, 0, 1]); 
     * 
     * rearged('b', 'c', 'a') 
     * // =&gt; ['a', 'b', 'c'] 
     */</span>
    <span class="s2">var </span><span class="s1">rearg = flatRest(</span><span class="s2">function</span><span class="s1">(func, indexes) {</span>
      <span class="s2">return </span><span class="s1">createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);</span>
    <span class="s1">});</span>

    <span class="s0">/** 
     * Creates a function that invokes `func` with the `this` binding of the 
     * created function and arguments from `start` and beyond provided as 
     * an array. 
     * 
     * **Note:** This method is based on the 
     * [rest parameter](https://mdn.io/rest_parameters). 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Function 
     * @param {Function} func The function to apply a rest parameter to. 
     * @param {number} [start=func.length-1] The start position of the rest parameter. 
     * @returns {Function} Returns the new function. 
     * @example 
     * 
     * var say = _.rest(function(what, names) { 
     *   return what + ' ' + _.initial(names).join(', ') + 
     *     (_.size(names) &gt; 1 ? ', &amp; ' : '') + _.last(names); 
     * }); 
     * 
     * say('hello', 'fred', 'barney', 'pebbles'); 
     * // =&gt; 'hello fred, barney, &amp; pebbles' 
     */</span>
    <span class="s2">function </span><span class="s1">rest(func, start) {</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">func != </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s2">throw new </span><span class="s1">TypeError(FUNC_ERROR_TEXT);</span>
      <span class="s1">}</span>
      <span class="s1">start = start === undefined ? start : toInteger(start);</span>
      <span class="s2">return </span><span class="s1">baseRest(func, start);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a function that invokes `func` with the `this` binding of the 
     * create function and an array of arguments much like 
     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply). 
     * 
     * **Note:** This method is based on the 
     * [spread operator](https://mdn.io/spread_operator). 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.2.0 
     * @category Function 
     * @param {Function} func The function to spread arguments over. 
     * @param {number} [start=0] The start position of the spread. 
     * @returns {Function} Returns the new function. 
     * @example 
     * 
     * var say = _.spread(function(who, what) { 
     *   return who + ' says ' + what; 
     * }); 
     * 
     * say(['fred', 'hello']); 
     * // =&gt; 'fred says hello' 
     * 
     * var numbers = Promise.all([ 
     *   Promise.resolve(40), 
     *   Promise.resolve(36) 
     * ]); 
     * 
     * numbers.then(_.spread(function(x, y) { 
     *   return x + y; 
     * })); 
     * // =&gt; a Promise of 76 
     */</span>
    <span class="s2">function </span><span class="s1">spread(func, start) {</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">func != </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s2">throw new </span><span class="s1">TypeError(FUNC_ERROR_TEXT);</span>
      <span class="s1">}</span>
      <span class="s1">start = start == </span><span class="s2">null </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: nativeMax(toInteger(start), </span><span class="s4">0</span><span class="s1">);</span>
      <span class="s2">return </span><span class="s1">baseRest(</span><span class="s2">function</span><span class="s1">(args) {</span>
        <span class="s2">var </span><span class="s1">array = args[start],</span>
            <span class="s1">otherArgs = castSlice(args, </span><span class="s4">0</span><span class="s1">, start);</span>

        <span class="s2">if </span><span class="s1">(array) {</span>
          <span class="s1">arrayPush(otherArgs, array);</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">apply(func, </span><span class="s2">this</span><span class="s1">, otherArgs);</span>
      <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a throttled function that only invokes `func` at most once per 
     * every `wait` milliseconds. The throttled function comes with a `cancel` 
     * method to cancel delayed `func` invocations and a `flush` method to 
     * immediately invoke them. Provide `options` to indicate whether `func` 
     * should be invoked on the leading and/or trailing edge of the `wait` 
     * timeout. The `func` is invoked with the last arguments provided to the 
     * throttled function. Subsequent calls to the throttled function return the 
     * result of the last `func` invocation. 
     * 
     * **Note:** If `leading` and `trailing` options are `true`, `func` is 
     * invoked on the trailing edge of the timeout only if the throttled function 
     * is invoked more than once during the `wait` timeout. 
     * 
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred 
     * until to the next tick, similar to `setTimeout` with a timeout of `0`. 
     * 
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/) 
     * for details over the differences between `_.throttle` and `_.debounce`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.1.0 
     * @category Function 
     * @param {Function} func The function to throttle. 
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to. 
     * @param {Object} [options={}] The options object. 
     * @param {boolean} [options.leading=true] 
     *  Specify invoking on the leading edge of the timeout. 
     * @param {boolean} [options.trailing=true] 
     *  Specify invoking on the trailing edge of the timeout. 
     * @returns {Function} Returns the new throttled function. 
     * @example 
     * 
     * // Avoid excessively updating the position while scrolling. 
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100)); 
     * 
     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes. 
     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false }); 
     * jQuery(element).on('click', throttled); 
     * 
     * // Cancel the trailing throttled invocation. 
     * jQuery(window).on('popstate', throttled.cancel); 
     */</span>
    <span class="s2">function </span><span class="s1">throttle(func, wait, options) {</span>
      <span class="s2">var </span><span class="s1">leading = </span><span class="s2">true</span><span class="s1">,</span>
          <span class="s1">trailing = </span><span class="s2">true</span><span class="s1">;</span>

      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">func != </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s2">throw new </span><span class="s1">TypeError(FUNC_ERROR_TEXT);</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(isObject(options)) {</span>
        <span class="s1">leading = </span><span class="s3">'leading' </span><span class="s2">in </span><span class="s1">options ? !!options.leading : leading;</span>
        <span class="s1">trailing = </span><span class="s3">'trailing' </span><span class="s2">in </span><span class="s1">options ? !!options.trailing : trailing;</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">debounce(func, wait, {</span>
        <span class="s3">'leading'</span><span class="s1">: leading,</span>
        <span class="s3">'maxWait'</span><span class="s1">: wait,</span>
        <span class="s3">'trailing'</span><span class="s1">: trailing</span>
      <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a function that accepts up to one argument, ignoring any 
     * additional arguments. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Function 
     * @param {Function} func The function to cap arguments for. 
     * @returns {Function} Returns the new capped function. 
     * @example 
     * 
     * _.map(['6', '8', '10'], _.unary(parseInt)); 
     * // =&gt; [6, 8, 10] 
     */</span>
    <span class="s2">function </span><span class="s1">unary(func) {</span>
      <span class="s2">return </span><span class="s1">ary(func, </span><span class="s4">1</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a function that provides `value` to `wrapper` as its first 
     * argument. Any additional arguments provided to the function are appended 
     * to those provided to the `wrapper`. The wrapper is invoked with the `this` 
     * binding of the created function. 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.1.0 
     * @category Function 
     * @param {*} value The value to wrap. 
     * @param {Function} [wrapper=identity] The wrapper function. 
     * @returns {Function} Returns the new function. 
     * @example 
     * 
     * var p = _.wrap(_.escape, function(func, text) { 
     *   return '&lt;p&gt;' + func(text) + '&lt;/p&gt;'; 
     * }); 
     * 
     * p('fred, barney, &amp; pebbles'); 
     * // =&gt; '&lt;p&gt;fred, barney, &amp;amp; pebbles&lt;/p&gt;' 
     */</span>
    <span class="s2">function </span><span class="s1">wrap(value, wrapper) {</span>
      <span class="s2">return </span><span class="s1">partial(castFunction(wrapper), value);</span>
    <span class="s1">}</span>

    <span class="s0">/*------------------------------------------------------------------------*/</span>

    <span class="s0">/** 
     * Casts `value` as an array if it's not one. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.4.0 
     * @category Lang 
     * @param {*} value The value to inspect. 
     * @returns {Array} Returns the cast array. 
     * @example 
     * 
     * _.castArray(1); 
     * // =&gt; [1] 
     * 
     * _.castArray({ 'a': 1 }); 
     * // =&gt; [{ 'a': 1 }] 
     * 
     * _.castArray('abc'); 
     * // =&gt; ['abc'] 
     * 
     * _.castArray(null); 
     * // =&gt; [null] 
     * 
     * _.castArray(undefined); 
     * // =&gt; [undefined] 
     * 
     * _.castArray(); 
     * // =&gt; [] 
     * 
     * var array = [1, 2, 3]; 
     * console.log(_.castArray(array) === array); 
     * // =&gt; true 
     */</span>
    <span class="s2">function </span><span class="s1">castArray() {</span>
      <span class="s2">if </span><span class="s1">(!arguments.length) {</span>
        <span class="s2">return </span><span class="s1">[];</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">value = arguments[</span><span class="s4">0</span><span class="s1">];</span>
      <span class="s2">return </span><span class="s1">isArray(value) ? value : [value];</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a shallow clone of `value`. 
     * 
     * **Note:** This method is loosely based on the 
     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm) 
     * and supports cloning arrays, array buffers, booleans, date objects, maps, 
     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed 
     * arrays. The own enumerable properties of `arguments` objects are cloned 
     * as plain objects. An empty object is returned for uncloneable values such 
     * as error objects, functions, DOM nodes, and WeakMaps. 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.1.0 
     * @category Lang 
     * @param {*} value The value to clone. 
     * @returns {*} Returns the cloned value. 
     * @see _.cloneDeep 
     * @example 
     * 
     * var objects = [{ 'a': 1 }, { 'b': 2 }]; 
     * 
     * var shallow = _.clone(objects); 
     * console.log(shallow[0] === objects[0]); 
     * // =&gt; true 
     */</span>
    <span class="s2">function </span><span class="s1">clone(value) {</span>
      <span class="s2">return </span><span class="s1">baseClone(value, CLONE_SYMBOLS_FLAG);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * This method is like `_.clone` except that it accepts `customizer` which 
     * is invoked to produce the cloned value. If `customizer` returns `undefined`, 
     * cloning is handled by the method instead. The `customizer` is invoked with 
     * up to four arguments; (value [, index|key, object, stack]). 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Lang 
     * @param {*} value The value to clone. 
     * @param {Function} [customizer] The function to customize cloning. 
     * @returns {*} Returns the cloned value. 
     * @see _.cloneDeepWith 
     * @example 
     * 
     * function customizer(value) { 
     *   if (_.isElement(value)) { 
     *     return value.cloneNode(false); 
     *   } 
     * } 
     * 
     * var el = _.cloneWith(document.body, customizer); 
     * 
     * console.log(el === document.body); 
     * // =&gt; false 
     * console.log(el.nodeName); 
     * // =&gt; 'BODY' 
     * console.log(el.childNodes.length); 
     * // =&gt; 0 
     */</span>
    <span class="s2">function </span><span class="s1">cloneWith(value, customizer) {</span>
      <span class="s1">customizer = </span><span class="s2">typeof </span><span class="s1">customizer == </span><span class="s3">'function' </span><span class="s1">? customizer : undefined;</span>
      <span class="s2">return </span><span class="s1">baseClone(value, CLONE_SYMBOLS_FLAG, customizer);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * This method is like `_.clone` except that it recursively clones `value`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 1.0.0 
     * @category Lang 
     * @param {*} value The value to recursively clone. 
     * @returns {*} Returns the deep cloned value. 
     * @see _.clone 
     * @example 
     * 
     * var objects = [{ 'a': 1 }, { 'b': 2 }]; 
     * 
     * var deep = _.cloneDeep(objects); 
     * console.log(deep[0] === objects[0]); 
     * // =&gt; false 
     */</span>
    <span class="s2">function </span><span class="s1">cloneDeep(value) {</span>
      <span class="s2">return </span><span class="s1">baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * This method is like `_.cloneWith` except that it recursively clones `value`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Lang 
     * @param {*} value The value to recursively clone. 
     * @param {Function} [customizer] The function to customize cloning. 
     * @returns {*} Returns the deep cloned value. 
     * @see _.cloneWith 
     * @example 
     * 
     * function customizer(value) { 
     *   if (_.isElement(value)) { 
     *     return value.cloneNode(true); 
     *   } 
     * } 
     * 
     * var el = _.cloneDeepWith(document.body, customizer); 
     * 
     * console.log(el === document.body); 
     * // =&gt; false 
     * console.log(el.nodeName); 
     * // =&gt; 'BODY' 
     * console.log(el.childNodes.length); 
     * // =&gt; 20 
     */</span>
    <span class="s2">function </span><span class="s1">cloneDeepWith(value, customizer) {</span>
      <span class="s1">customizer = </span><span class="s2">typeof </span><span class="s1">customizer == </span><span class="s3">'function' </span><span class="s1">? customizer : undefined;</span>
      <span class="s2">return </span><span class="s1">baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Checks if `object` conforms to `source` by invoking the predicate 
     * properties of `source` with the corresponding property values of `object`. 
     * 
     * **Note:** This method is equivalent to `_.conforms` when `source` is 
     * partially applied. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.14.0 
     * @category Lang 
     * @param {Object} object The object to inspect. 
     * @param {Object} source The object of property predicates to conform to. 
     * @returns {boolean} Returns `true` if `object` conforms, else `false`. 
     * @example 
     * 
     * var object = { 'a': 1, 'b': 2 }; 
     * 
     * _.conformsTo(object, { 'b': function(n) { return n &gt; 1; } }); 
     * // =&gt; true 
     * 
     * _.conformsTo(object, { 'b': function(n) { return n &gt; 2; } }); 
     * // =&gt; false 
     */</span>
    <span class="s2">function </span><span class="s1">conformsTo(object, source) {</span>
      <span class="s2">return </span><span class="s1">source == </span><span class="s2">null </span><span class="s1">|| baseConformsTo(object, source, keys(source));</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Performs a 
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero) 
     * comparison between two values to determine if they are equivalent. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Lang 
     * @param {*} value The value to compare. 
     * @param {*} other The other value to compare. 
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`. 
     * @example 
     * 
     * var object = { 'a': 1 }; 
     * var other = { 'a': 1 }; 
     * 
     * _.eq(object, object); 
     * // =&gt; true 
     * 
     * _.eq(object, other); 
     * // =&gt; false 
     * 
     * _.eq('a', 'a'); 
     * // =&gt; true 
     * 
     * _.eq('a', Object('a')); 
     * // =&gt; false 
     * 
     * _.eq(NaN, NaN); 
     * // =&gt; true 
     */</span>
    <span class="s2">function </span><span class="s1">eq(value, other) {</span>
      <span class="s2">return </span><span class="s1">value === other || (value !== value &amp;&amp; other !== other);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Checks if `value` is greater than `other`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.9.0 
     * @category Lang 
     * @param {*} value The value to compare. 
     * @param {*} other The other value to compare. 
     * @returns {boolean} Returns `true` if `value` is greater than `other`, 
     *  else `false`. 
     * @see _.lt 
     * @example 
     * 
     * _.gt(3, 1); 
     * // =&gt; true 
     * 
     * _.gt(3, 3); 
     * // =&gt; false 
     * 
     * _.gt(1, 3); 
     * // =&gt; false 
     */</span>
    <span class="s2">var </span><span class="s1">gt = createRelationalOperation(baseGt);</span>

    <span class="s0">/** 
     * Checks if `value` is greater than or equal to `other`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.9.0 
     * @category Lang 
     * @param {*} value The value to compare. 
     * @param {*} other The other value to compare. 
     * @returns {boolean} Returns `true` if `value` is greater than or equal to 
     *  `other`, else `false`. 
     * @see _.lte 
     * @example 
     * 
     * _.gte(3, 1); 
     * // =&gt; true 
     * 
     * _.gte(3, 3); 
     * // =&gt; true 
     * 
     * _.gte(1, 3); 
     * // =&gt; false 
     */</span>
    <span class="s2">var </span><span class="s1">gte = createRelationalOperation(</span><span class="s2">function</span><span class="s1">(value, other) {</span>
      <span class="s2">return </span><span class="s1">value &gt;= other;</span>
    <span class="s1">});</span>

    <span class="s0">/** 
     * Checks if `value` is likely an `arguments` object. 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.1.0 
     * @category Lang 
     * @param {*} value The value to check. 
     * @returns {boolean} Returns `true` if `value` is an `arguments` object, 
     *  else `false`. 
     * @example 
     * 
     * _.isArguments(function() { return arguments; }()); 
     * // =&gt; true 
     * 
     * _.isArguments([1, 2, 3]); 
     * // =&gt; false 
     */</span>
    <span class="s2">var </span><span class="s1">isArguments = baseIsArguments(</span><span class="s2">function</span><span class="s1">() { </span><span class="s2">return </span><span class="s1">arguments; }()) ? baseIsArguments : </span><span class="s2">function</span><span class="s1">(value) {</span>
      <span class="s2">return </span><span class="s1">isObjectLike(value) &amp;&amp; hasOwnProperty.call(value, </span><span class="s3">'callee'</span><span class="s1">) &amp;&amp;</span>
        <span class="s1">!propertyIsEnumerable.call(value, </span><span class="s3">'callee'</span><span class="s1">);</span>
    <span class="s1">};</span>

    <span class="s0">/** 
     * Checks if `value` is classified as an `Array` object. 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.1.0 
     * @category Lang 
     * @param {*} value The value to check. 
     * @returns {boolean} Returns `true` if `value` is an array, else `false`. 
     * @example 
     * 
     * _.isArray([1, 2, 3]); 
     * // =&gt; true 
     * 
     * _.isArray(document.body.children); 
     * // =&gt; false 
     * 
     * _.isArray('abc'); 
     * // =&gt; false 
     * 
     * _.isArray(_.noop); 
     * // =&gt; false 
     */</span>
    <span class="s2">var </span><span class="s1">isArray = Array.isArray;</span>

    <span class="s0">/** 
     * Checks if `value` is classified as an `ArrayBuffer` object. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.3.0 
     * @category Lang 
     * @param {*} value The value to check. 
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`. 
     * @example 
     * 
     * _.isArrayBuffer(new ArrayBuffer(2)); 
     * // =&gt; true 
     * 
     * _.isArrayBuffer(new Array(2)); 
     * // =&gt; false 
     */</span>
    <span class="s2">var </span><span class="s1">isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;</span>

    <span class="s0">/** 
     * Checks if `value` is array-like. A value is considered array-like if it's 
     * not a function and has a `value.length` that's an integer greater than or 
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Lang 
     * @param {*} value The value to check. 
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`. 
     * @example 
     * 
     * _.isArrayLike([1, 2, 3]); 
     * // =&gt; true 
     * 
     * _.isArrayLike(document.body.children); 
     * // =&gt; true 
     * 
     * _.isArrayLike('abc'); 
     * // =&gt; true 
     * 
     * _.isArrayLike(_.noop); 
     * // =&gt; false 
     */</span>
    <span class="s2">function </span><span class="s1">isArrayLike(value) {</span>
      <span class="s2">return </span><span class="s1">value != </span><span class="s2">null </span><span class="s1">&amp;&amp; isLength(value.length) &amp;&amp; !isFunction(value);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * This method is like `_.isArrayLike` except that it also checks if `value` 
     * is an object. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Lang 
     * @param {*} value The value to check. 
     * @returns {boolean} Returns `true` if `value` is an array-like object, 
     *  else `false`. 
     * @example 
     * 
     * _.isArrayLikeObject([1, 2, 3]); 
     * // =&gt; true 
     * 
     * _.isArrayLikeObject(document.body.children); 
     * // =&gt; true 
     * 
     * _.isArrayLikeObject('abc'); 
     * // =&gt; false 
     * 
     * _.isArrayLikeObject(_.noop); 
     * // =&gt; false 
     */</span>
    <span class="s2">function </span><span class="s1">isArrayLikeObject(value) {</span>
      <span class="s2">return </span><span class="s1">isObjectLike(value) &amp;&amp; isArrayLike(value);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Checks if `value` is classified as a boolean primitive or object. 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.1.0 
     * @category Lang 
     * @param {*} value The value to check. 
     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`. 
     * @example 
     * 
     * _.isBoolean(false); 
     * // =&gt; true 
     * 
     * _.isBoolean(null); 
     * // =&gt; false 
     */</span>
    <span class="s2">function </span><span class="s1">isBoolean(value) {</span>
      <span class="s2">return </span><span class="s1">value === </span><span class="s2">true </span><span class="s1">|| value === </span><span class="s2">false </span><span class="s1">||</span>
        <span class="s1">(isObjectLike(value) &amp;&amp; baseGetTag(value) == boolTag);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Checks if `value` is a buffer. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.3.0 
     * @category Lang 
     * @param {*} value The value to check. 
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`. 
     * @example 
     * 
     * _.isBuffer(new Buffer(2)); 
     * // =&gt; true 
     * 
     * _.isBuffer(new Uint8Array(2)); 
     * // =&gt; false 
     */</span>
    <span class="s2">var </span><span class="s1">isBuffer = nativeIsBuffer || stubFalse;</span>

    <span class="s0">/** 
     * Checks if `value` is classified as a `Date` object. 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.1.0 
     * @category Lang 
     * @param {*} value The value to check. 
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`. 
     * @example 
     * 
     * _.isDate(new Date); 
     * // =&gt; true 
     * 
     * _.isDate('Mon April 23 2012'); 
     * // =&gt; false 
     */</span>
    <span class="s2">var </span><span class="s1">isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;</span>

    <span class="s0">/** 
     * Checks if `value` is likely a DOM element. 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.1.0 
     * @category Lang 
     * @param {*} value The value to check. 
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`. 
     * @example 
     * 
     * _.isElement(document.body); 
     * // =&gt; true 
     * 
     * _.isElement('&lt;body&gt;'); 
     * // =&gt; false 
     */</span>
    <span class="s2">function </span><span class="s1">isElement(value) {</span>
      <span class="s2">return </span><span class="s1">isObjectLike(value) &amp;&amp; value.nodeType === </span><span class="s4">1 </span><span class="s1">&amp;&amp; !isPlainObject(value);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Checks if `value` is an empty object, collection, map, or set. 
     * 
     * Objects are considered empty if they have no own enumerable string keyed 
     * properties. 
     * 
     * Array-like values such as `arguments` objects, arrays, buffers, strings, or 
     * jQuery-like collections are considered empty if they have a `length` of `0`. 
     * Similarly, maps and sets are considered empty if they have a `size` of `0`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.1.0 
     * @category Lang 
     * @param {*} value The value to check. 
     * @returns {boolean} Returns `true` if `value` is empty, else `false`. 
     * @example 
     * 
     * _.isEmpty(null); 
     * // =&gt; true 
     * 
     * _.isEmpty(true); 
     * // =&gt; true 
     * 
     * _.isEmpty(1); 
     * // =&gt; true 
     * 
     * _.isEmpty([1, 2, 3]); 
     * // =&gt; false 
     * 
     * _.isEmpty({ 'a': 1 }); 
     * // =&gt; false 
     */</span>
    <span class="s2">function </span><span class="s1">isEmpty(value) {</span>
      <span class="s2">if </span><span class="s1">(value == </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">return true</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(isArrayLike(value) &amp;&amp;</span>
          <span class="s1">(isArray(value) || </span><span class="s2">typeof </span><span class="s1">value == </span><span class="s3">'string' </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">value.splice == </span><span class="s3">'function' </span><span class="s1">||</span>
            <span class="s1">isBuffer(value) || isTypedArray(value) || isArguments(value))) {</span>
        <span class="s2">return </span><span class="s1">!value.length;</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">tag = getTag(value);</span>
      <span class="s2">if </span><span class="s1">(tag == mapTag || tag == setTag) {</span>
        <span class="s2">return </span><span class="s1">!value.size;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(isPrototype(value)) {</span>
        <span class="s2">return </span><span class="s1">!baseKeys(value).length;</span>
      <span class="s1">}</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">key </span><span class="s2">in </span><span class="s1">value) {</span>
        <span class="s2">if </span><span class="s1">(hasOwnProperty.call(value, key)) {</span>
          <span class="s2">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Performs a deep comparison between two values to determine if they are 
     * equivalent. 
     * 
     * **Note:** This method supports comparing arrays, array buffers, booleans, 
     * date objects, error objects, maps, numbers, `Object` objects, regexes, 
     * sets, strings, symbols, and typed arrays. `Object` objects are compared 
     * by their own, not inherited, enumerable properties. Functions and DOM 
     * nodes are compared by strict equality, i.e. `===`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.1.0 
     * @category Lang 
     * @param {*} value The value to compare. 
     * @param {*} other The other value to compare. 
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`. 
     * @example 
     * 
     * var object = { 'a': 1 }; 
     * var other = { 'a': 1 }; 
     * 
     * _.isEqual(object, other); 
     * // =&gt; true 
     * 
     * object === other; 
     * // =&gt; false 
     */</span>
    <span class="s2">function </span><span class="s1">isEqual(value, other) {</span>
      <span class="s2">return </span><span class="s1">baseIsEqual(value, other);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * This method is like `_.isEqual` except that it accepts `customizer` which 
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons 
     * are handled by the method instead. The `customizer` is invoked with up to 
     * six arguments: (objValue, othValue [, index|key, object, other, stack]). 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Lang 
     * @param {*} value The value to compare. 
     * @param {*} other The other value to compare. 
     * @param {Function} [customizer] The function to customize comparisons. 
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`. 
     * @example 
     * 
     * function isGreeting(value) { 
     *   return /^h(?:i|ello)$/.test(value); 
     * } 
     * 
     * function customizer(objValue, othValue) { 
     *   if (isGreeting(objValue) &amp;&amp; isGreeting(othValue)) { 
     *     return true; 
     *   } 
     * } 
     * 
     * var array = ['hello', 'goodbye']; 
     * var other = ['hi', 'goodbye']; 
     * 
     * _.isEqualWith(array, other, customizer); 
     * // =&gt; true 
     */</span>
    <span class="s2">function </span><span class="s1">isEqualWith(value, other, customizer) {</span>
      <span class="s1">customizer = </span><span class="s2">typeof </span><span class="s1">customizer == </span><span class="s3">'function' </span><span class="s1">? customizer : undefined;</span>
      <span class="s2">var </span><span class="s1">result = customizer ? customizer(value, other) : undefined;</span>
      <span class="s2">return </span><span class="s1">result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`, 
     * `SyntaxError`, `TypeError`, or `URIError` object. 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.0.0 
     * @category Lang 
     * @param {*} value The value to check. 
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`. 
     * @example 
     * 
     * _.isError(new Error); 
     * // =&gt; true 
     * 
     * _.isError(Error); 
     * // =&gt; false 
     */</span>
    <span class="s2">function </span><span class="s1">isError(value) {</span>
      <span class="s2">if </span><span class="s1">(!isObjectLike(value)) {</span>
        <span class="s2">return false</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">tag = baseGetTag(value);</span>
      <span class="s2">return </span><span class="s1">tag == errorTag || tag == domExcTag ||</span>
        <span class="s1">(</span><span class="s2">typeof </span><span class="s1">value.message == </span><span class="s3">'string' </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">value.name == </span><span class="s3">'string' </span><span class="s1">&amp;&amp; !isPlainObject(value));</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Checks if `value` is a finite primitive number. 
     * 
     * **Note:** This method is based on 
     * [`Number.isFinite`](https://mdn.io/Number/isFinite). 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.1.0 
     * @category Lang 
     * @param {*} value The value to check. 
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`. 
     * @example 
     * 
     * _.isFinite(3); 
     * // =&gt; true 
     * 
     * _.isFinite(Number.MIN_VALUE); 
     * // =&gt; true 
     * 
     * _.isFinite(Infinity); 
     * // =&gt; false 
     * 
     * _.isFinite('3'); 
     * // =&gt; false 
     */</span>
    <span class="s2">function </span><span class="s1">isFinite(value) {</span>
      <span class="s2">return typeof </span><span class="s1">value == </span><span class="s3">'number' </span><span class="s1">&amp;&amp; nativeIsFinite(value);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Checks if `value` is classified as a `Function` object. 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.1.0 
     * @category Lang 
     * @param {*} value The value to check. 
     * @returns {boolean} Returns `true` if `value` is a function, else `false`. 
     * @example 
     * 
     * _.isFunction(_); 
     * // =&gt; true 
     * 
     * _.isFunction(/abc/); 
     * // =&gt; false 
     */</span>
    <span class="s2">function </span><span class="s1">isFunction(value) {</span>
      <span class="s2">if </span><span class="s1">(!isObject(value)) {</span>
        <span class="s2">return false</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s0">// The use of `Object#toString` avoids issues with the `typeof` operator</span>
      <span class="s0">// in Safari 9 which returns 'object' for typed arrays and other constructors.</span>
      <span class="s2">var </span><span class="s1">tag = baseGetTag(value);</span>
      <span class="s2">return </span><span class="s1">tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Checks if `value` is an integer. 
     * 
     * **Note:** This method is based on 
     * [`Number.isInteger`](https://mdn.io/Number/isInteger). 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Lang 
     * @param {*} value The value to check. 
     * @returns {boolean} Returns `true` if `value` is an integer, else `false`. 
     * @example 
     * 
     * _.isInteger(3); 
     * // =&gt; true 
     * 
     * _.isInteger(Number.MIN_VALUE); 
     * // =&gt; false 
     * 
     * _.isInteger(Infinity); 
     * // =&gt; false 
     * 
     * _.isInteger('3'); 
     * // =&gt; false 
     */</span>
    <span class="s2">function </span><span class="s1">isInteger(value) {</span>
      <span class="s2">return typeof </span><span class="s1">value == </span><span class="s3">'number' </span><span class="s1">&amp;&amp; value == toInteger(value);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Checks if `value` is a valid array-like length. 
     * 
     * **Note:** This method is loosely based on 
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength). 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Lang 
     * @param {*} value The value to check. 
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`. 
     * @example 
     * 
     * _.isLength(3); 
     * // =&gt; true 
     * 
     * _.isLength(Number.MIN_VALUE); 
     * // =&gt; false 
     * 
     * _.isLength(Infinity); 
     * // =&gt; false 
     * 
     * _.isLength('3'); 
     * // =&gt; false 
     */</span>
    <span class="s2">function </span><span class="s1">isLength(value) {</span>
      <span class="s2">return typeof </span><span class="s1">value == </span><span class="s3">'number' </span><span class="s1">&amp;&amp;</span>
        <span class="s1">value &gt; -</span><span class="s4">1 </span><span class="s1">&amp;&amp; value % </span><span class="s4">1 </span><span class="s1">== </span><span class="s4">0 </span><span class="s1">&amp;&amp; value &lt;= MAX_SAFE_INTEGER;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Checks if `value` is the 
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types) 
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`) 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.1.0 
     * @category Lang 
     * @param {*} value The value to check. 
     * @returns {boolean} Returns `true` if `value` is an object, else `false`. 
     * @example 
     * 
     * _.isObject({}); 
     * // =&gt; true 
     * 
     * _.isObject([1, 2, 3]); 
     * // =&gt; true 
     * 
     * _.isObject(_.noop); 
     * // =&gt; true 
     * 
     * _.isObject(null); 
     * // =&gt; false 
     */</span>
    <span class="s2">function </span><span class="s1">isObject(value) {</span>
      <span class="s2">var </span><span class="s1">type = </span><span class="s2">typeof </span><span class="s1">value;</span>
      <span class="s2">return </span><span class="s1">value != </span><span class="s2">null </span><span class="s1">&amp;&amp; (type == </span><span class="s3">'object' </span><span class="s1">|| type == </span><span class="s3">'function'</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Checks if `value` is object-like. A value is object-like if it's not `null` 
     * and has a `typeof` result of &quot;object&quot;. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Lang 
     * @param {*} value The value to check. 
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`. 
     * @example 
     * 
     * _.isObjectLike({}); 
     * // =&gt; true 
     * 
     * _.isObjectLike([1, 2, 3]); 
     * // =&gt; true 
     * 
     * _.isObjectLike(_.noop); 
     * // =&gt; false 
     * 
     * _.isObjectLike(null); 
     * // =&gt; false 
     */</span>
    <span class="s2">function </span><span class="s1">isObjectLike(value) {</span>
      <span class="s2">return </span><span class="s1">value != </span><span class="s2">null </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">value == </span><span class="s3">'object'</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Checks if `value` is classified as a `Map` object. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.3.0 
     * @category Lang 
     * @param {*} value The value to check. 
     * @returns {boolean} Returns `true` if `value` is a map, else `false`. 
     * @example 
     * 
     * _.isMap(new Map); 
     * // =&gt; true 
     * 
     * _.isMap(new WeakMap); 
     * // =&gt; false 
     */</span>
    <span class="s2">var </span><span class="s1">isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;</span>

    <span class="s0">/** 
     * Performs a partial deep comparison between `object` and `source` to 
     * determine if `object` contains equivalent property values. 
     * 
     * **Note:** This method is equivalent to `_.matches` when `source` is 
     * partially applied. 
     * 
     * Partial comparisons will match empty array and empty object `source` 
     * values against any array or object value, respectively. See `_.isEqual` 
     * for a list of supported value comparisons. 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.0.0 
     * @category Lang 
     * @param {Object} object The object to inspect. 
     * @param {Object} source The object of property values to match. 
     * @returns {boolean} Returns `true` if `object` is a match, else `false`. 
     * @example 
     * 
     * var object = { 'a': 1, 'b': 2 }; 
     * 
     * _.isMatch(object, { 'b': 2 }); 
     * // =&gt; true 
     * 
     * _.isMatch(object, { 'b': 1 }); 
     * // =&gt; false 
     */</span>
    <span class="s2">function </span><span class="s1">isMatch(object, source) {</span>
      <span class="s2">return </span><span class="s1">object === source || baseIsMatch(object, source, getMatchData(source));</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * This method is like `_.isMatch` except that it accepts `customizer` which 
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons 
     * are handled by the method instead. The `customizer` is invoked with five 
     * arguments: (objValue, srcValue, index|key, object, source). 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Lang 
     * @param {Object} object The object to inspect. 
     * @param {Object} source The object of property values to match. 
     * @param {Function} [customizer] The function to customize comparisons. 
     * @returns {boolean} Returns `true` if `object` is a match, else `false`. 
     * @example 
     * 
     * function isGreeting(value) { 
     *   return /^h(?:i|ello)$/.test(value); 
     * } 
     * 
     * function customizer(objValue, srcValue) { 
     *   if (isGreeting(objValue) &amp;&amp; isGreeting(srcValue)) { 
     *     return true; 
     *   } 
     * } 
     * 
     * var object = { 'greeting': 'hello' }; 
     * var source = { 'greeting': 'hi' }; 
     * 
     * _.isMatchWith(object, source, customizer); 
     * // =&gt; true 
     */</span>
    <span class="s2">function </span><span class="s1">isMatchWith(object, source, customizer) {</span>
      <span class="s1">customizer = </span><span class="s2">typeof </span><span class="s1">customizer == </span><span class="s3">'function' </span><span class="s1">? customizer : undefined;</span>
      <span class="s2">return </span><span class="s1">baseIsMatch(object, source, getMatchData(source), customizer);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Checks if `value` is `NaN`. 
     * 
     * **Note:** This method is based on 
     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as 
     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for 
     * `undefined` and other non-number values. 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.1.0 
     * @category Lang 
     * @param {*} value The value to check. 
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`. 
     * @example 
     * 
     * _.isNaN(NaN); 
     * // =&gt; true 
     * 
     * _.isNaN(new Number(NaN)); 
     * // =&gt; true 
     * 
     * isNaN(undefined); 
     * // =&gt; true 
     * 
     * _.isNaN(undefined); 
     * // =&gt; false 
     */</span>
    <span class="s2">function </span><span class="s1">isNaN(value) {</span>
      <span class="s0">// An `NaN` primitive is the only value that is not equal to itself.</span>
      <span class="s0">// Perform the `toStringTag` check first to avoid errors with some</span>
      <span class="s0">// ActiveX objects in IE.</span>
      <span class="s2">return </span><span class="s1">isNumber(value) &amp;&amp; value != +value;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Checks if `value` is a pristine native function. 
     * 
     * **Note:** This method can't reliably detect native functions in the presence 
     * of the core-js package because core-js circumvents this kind of detection. 
     * Despite multiple requests, the core-js maintainer has made it clear: any 
     * attempt to fix the detection will be obstructed. As a result, we're left 
     * with little choice but to throw an error. Unfortunately, this also affects 
     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill), 
     * which rely on core-js. 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.0.0 
     * @category Lang 
     * @param {*} value The value to check. 
     * @returns {boolean} Returns `true` if `value` is a native function, 
     *  else `false`. 
     * @example 
     * 
     * _.isNative(Array.prototype.push); 
     * // =&gt; true 
     * 
     * _.isNative(_); 
     * // =&gt; false 
     */</span>
    <span class="s2">function </span><span class="s1">isNative(value) {</span>
      <span class="s2">if </span><span class="s1">(isMaskable(value)) {</span>
        <span class="s2">throw new </span><span class="s1">Error(CORE_ERROR_TEXT);</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">baseIsNative(value);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Checks if `value` is `null`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.1.0 
     * @category Lang 
     * @param {*} value The value to check. 
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`. 
     * @example 
     * 
     * _.isNull(null); 
     * // =&gt; true 
     * 
     * _.isNull(void 0); 
     * // =&gt; false 
     */</span>
    <span class="s2">function </span><span class="s1">isNull(value) {</span>
      <span class="s2">return </span><span class="s1">value === </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Checks if `value` is `null` or `undefined`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Lang 
     * @param {*} value The value to check. 
     * @returns {boolean} Returns `true` if `value` is nullish, else `false`. 
     * @example 
     * 
     * _.isNil(null); 
     * // =&gt; true 
     * 
     * _.isNil(void 0); 
     * // =&gt; true 
     * 
     * _.isNil(NaN); 
     * // =&gt; false 
     */</span>
    <span class="s2">function </span><span class="s1">isNil(value) {</span>
      <span class="s2">return </span><span class="s1">value == </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Checks if `value` is classified as a `Number` primitive or object. 
     * 
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are 
     * classified as numbers, use the `_.isFinite` method. 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.1.0 
     * @category Lang 
     * @param {*} value The value to check. 
     * @returns {boolean} Returns `true` if `value` is a number, else `false`. 
     * @example 
     * 
     * _.isNumber(3); 
     * // =&gt; true 
     * 
     * _.isNumber(Number.MIN_VALUE); 
     * // =&gt; true 
     * 
     * _.isNumber(Infinity); 
     * // =&gt; true 
     * 
     * _.isNumber('3'); 
     * // =&gt; false 
     */</span>
    <span class="s2">function </span><span class="s1">isNumber(value) {</span>
      <span class="s2">return typeof </span><span class="s1">value == </span><span class="s3">'number' </span><span class="s1">||</span>
        <span class="s1">(isObjectLike(value) &amp;&amp; baseGetTag(value) == numberTag);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Checks if `value` is a plain object, that is, an object created by the 
     * `Object` constructor or one with a `[[Prototype]]` of `null`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.8.0 
     * @category Lang 
     * @param {*} value The value to check. 
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`. 
     * @example 
     * 
     * function Foo() { 
     *   this.a = 1; 
     * } 
     * 
     * _.isPlainObject(new Foo); 
     * // =&gt; false 
     * 
     * _.isPlainObject([1, 2, 3]); 
     * // =&gt; false 
     * 
     * _.isPlainObject({ 'x': 0, 'y': 0 }); 
     * // =&gt; true 
     * 
     * _.isPlainObject(Object.create(null)); 
     * // =&gt; true 
     */</span>
    <span class="s2">function </span><span class="s1">isPlainObject(value) {</span>
      <span class="s2">if </span><span class="s1">(!isObjectLike(value) || baseGetTag(value) != objectTag) {</span>
        <span class="s2">return false</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">proto = getPrototype(value);</span>
      <span class="s2">if </span><span class="s1">(proto === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">return true</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">Ctor = hasOwnProperty.call(proto, </span><span class="s3">'constructor'</span><span class="s1">) &amp;&amp; proto.constructor;</span>
      <span class="s2">return typeof </span><span class="s1">Ctor == </span><span class="s3">'function' </span><span class="s1">&amp;&amp; Ctor </span><span class="s2">instanceof </span><span class="s1">Ctor &amp;&amp;</span>
        <span class="s1">funcToString.call(Ctor) == objectCtorString;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Checks if `value` is classified as a `RegExp` object. 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.1.0 
     * @category Lang 
     * @param {*} value The value to check. 
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`. 
     * @example 
     * 
     * _.isRegExp(/abc/); 
     * // =&gt; true 
     * 
     * _.isRegExp('/abc/'); 
     * // =&gt; false 
     */</span>
    <span class="s2">var </span><span class="s1">isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;</span>

    <span class="s0">/** 
     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754 
     * double precision number which isn't the result of a rounded unsafe integer. 
     * 
     * **Note:** This method is based on 
     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger). 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Lang 
     * @param {*} value The value to check. 
     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`. 
     * @example 
     * 
     * _.isSafeInteger(3); 
     * // =&gt; true 
     * 
     * _.isSafeInteger(Number.MIN_VALUE); 
     * // =&gt; false 
     * 
     * _.isSafeInteger(Infinity); 
     * // =&gt; false 
     * 
     * _.isSafeInteger('3'); 
     * // =&gt; false 
     */</span>
    <span class="s2">function </span><span class="s1">isSafeInteger(value) {</span>
      <span class="s2">return </span><span class="s1">isInteger(value) &amp;&amp; value &gt;= -MAX_SAFE_INTEGER &amp;&amp; value &lt;= MAX_SAFE_INTEGER;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Checks if `value` is classified as a `Set` object. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.3.0 
     * @category Lang 
     * @param {*} value The value to check. 
     * @returns {boolean} Returns `true` if `value` is a set, else `false`. 
     * @example 
     * 
     * _.isSet(new Set); 
     * // =&gt; true 
     * 
     * _.isSet(new WeakSet); 
     * // =&gt; false 
     */</span>
    <span class="s2">var </span><span class="s1">isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;</span>

    <span class="s0">/** 
     * Checks if `value` is classified as a `String` primitive or object. 
     * 
     * @static 
     * @since 0.1.0 
     * @memberOf _ 
     * @category Lang 
     * @param {*} value The value to check. 
     * @returns {boolean} Returns `true` if `value` is a string, else `false`. 
     * @example 
     * 
     * _.isString('abc'); 
     * // =&gt; true 
     * 
     * _.isString(1); 
     * // =&gt; false 
     */</span>
    <span class="s2">function </span><span class="s1">isString(value) {</span>
      <span class="s2">return typeof </span><span class="s1">value == </span><span class="s3">'string' </span><span class="s1">||</span>
        <span class="s1">(!isArray(value) &amp;&amp; isObjectLike(value) &amp;&amp; baseGetTag(value) == stringTag);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Checks if `value` is classified as a `Symbol` primitive or object. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Lang 
     * @param {*} value The value to check. 
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`. 
     * @example 
     * 
     * _.isSymbol(Symbol.iterator); 
     * // =&gt; true 
     * 
     * _.isSymbol('abc'); 
     * // =&gt; false 
     */</span>
    <span class="s2">function </span><span class="s1">isSymbol(value) {</span>
      <span class="s2">return typeof </span><span class="s1">value == </span><span class="s3">'symbol' </span><span class="s1">||</span>
        <span class="s1">(isObjectLike(value) &amp;&amp; baseGetTag(value) == symbolTag);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Checks if `value` is classified as a typed array. 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.0.0 
     * @category Lang 
     * @param {*} value The value to check. 
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`. 
     * @example 
     * 
     * _.isTypedArray(new Uint8Array); 
     * // =&gt; true 
     * 
     * _.isTypedArray([]); 
     * // =&gt; false 
     */</span>
    <span class="s2">var </span><span class="s1">isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;</span>

    <span class="s0">/** 
     * Checks if `value` is `undefined`. 
     * 
     * @static 
     * @since 0.1.0 
     * @memberOf _ 
     * @category Lang 
     * @param {*} value The value to check. 
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`. 
     * @example 
     * 
     * _.isUndefined(void 0); 
     * // =&gt; true 
     * 
     * _.isUndefined(null); 
     * // =&gt; false 
     */</span>
    <span class="s2">function </span><span class="s1">isUndefined(value) {</span>
      <span class="s2">return </span><span class="s1">value === undefined;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Checks if `value` is classified as a `WeakMap` object. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.3.0 
     * @category Lang 
     * @param {*} value The value to check. 
     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`. 
     * @example 
     * 
     * _.isWeakMap(new WeakMap); 
     * // =&gt; true 
     * 
     * _.isWeakMap(new Map); 
     * // =&gt; false 
     */</span>
    <span class="s2">function </span><span class="s1">isWeakMap(value) {</span>
      <span class="s2">return </span><span class="s1">isObjectLike(value) &amp;&amp; getTag(value) == weakMapTag;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Checks if `value` is classified as a `WeakSet` object. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.3.0 
     * @category Lang 
     * @param {*} value The value to check. 
     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`. 
     * @example 
     * 
     * _.isWeakSet(new WeakSet); 
     * // =&gt; true 
     * 
     * _.isWeakSet(new Set); 
     * // =&gt; false 
     */</span>
    <span class="s2">function </span><span class="s1">isWeakSet(value) {</span>
      <span class="s2">return </span><span class="s1">isObjectLike(value) &amp;&amp; baseGetTag(value) == weakSetTag;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Checks if `value` is less than `other`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.9.0 
     * @category Lang 
     * @param {*} value The value to compare. 
     * @param {*} other The other value to compare. 
     * @returns {boolean} Returns `true` if `value` is less than `other`, 
     *  else `false`. 
     * @see _.gt 
     * @example 
     * 
     * _.lt(1, 3); 
     * // =&gt; true 
     * 
     * _.lt(3, 3); 
     * // =&gt; false 
     * 
     * _.lt(3, 1); 
     * // =&gt; false 
     */</span>
    <span class="s2">var </span><span class="s1">lt = createRelationalOperation(baseLt);</span>

    <span class="s0">/** 
     * Checks if `value` is less than or equal to `other`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.9.0 
     * @category Lang 
     * @param {*} value The value to compare. 
     * @param {*} other The other value to compare. 
     * @returns {boolean} Returns `true` if `value` is less than or equal to 
     *  `other`, else `false`. 
     * @see _.gte 
     * @example 
     * 
     * _.lte(1, 3); 
     * // =&gt; true 
     * 
     * _.lte(3, 3); 
     * // =&gt; true 
     * 
     * _.lte(3, 1); 
     * // =&gt; false 
     */</span>
    <span class="s2">var </span><span class="s1">lte = createRelationalOperation(</span><span class="s2">function</span><span class="s1">(value, other) {</span>
      <span class="s2">return </span><span class="s1">value &lt;= other;</span>
    <span class="s1">});</span>

    <span class="s0">/** 
     * Converts `value` to an array. 
     * 
     * @static 
     * @since 0.1.0 
     * @memberOf _ 
     * @category Lang 
     * @param {*} value The value to convert. 
     * @returns {Array} Returns the converted array. 
     * @example 
     * 
     * _.toArray({ 'a': 1, 'b': 2 }); 
     * // =&gt; [1, 2] 
     * 
     * _.toArray('abc'); 
     * // =&gt; ['a', 'b', 'c'] 
     * 
     * _.toArray(1); 
     * // =&gt; [] 
     * 
     * _.toArray(null); 
     * // =&gt; [] 
     */</span>
    <span class="s2">function </span><span class="s1">toArray(value) {</span>
      <span class="s2">if </span><span class="s1">(!value) {</span>
        <span class="s2">return </span><span class="s1">[];</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(isArrayLike(value)) {</span>
        <span class="s2">return </span><span class="s1">isString(value) ? stringToArray(value) : copyArray(value);</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(symIterator &amp;&amp; value[symIterator]) {</span>
        <span class="s2">return </span><span class="s1">iteratorToArray(value[symIterator]());</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">tag = getTag(value),</span>
          <span class="s1">func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);</span>

      <span class="s2">return </span><span class="s1">func(value);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Converts `value` to a finite number. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.12.0 
     * @category Lang 
     * @param {*} value The value to convert. 
     * @returns {number} Returns the converted number. 
     * @example 
     * 
     * _.toFinite(3.2); 
     * // =&gt; 3.2 
     * 
     * _.toFinite(Number.MIN_VALUE); 
     * // =&gt; 5e-324 
     * 
     * _.toFinite(Infinity); 
     * // =&gt; 1.7976931348623157e+308 
     * 
     * _.toFinite('3.2'); 
     * // =&gt; 3.2 
     */</span>
    <span class="s2">function </span><span class="s1">toFinite(value) {</span>
      <span class="s2">if </span><span class="s1">(!value) {</span>
        <span class="s2">return </span><span class="s1">value === </span><span class="s4">0 </span><span class="s1">? value : </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s1">value = toNumber(value);</span>
      <span class="s2">if </span><span class="s1">(value === INFINITY || value === -INFINITY) {</span>
        <span class="s2">var </span><span class="s1">sign = (value &lt; </span><span class="s4">0 </span><span class="s1">? -</span><span class="s4">1 </span><span class="s1">: </span><span class="s4">1</span><span class="s1">);</span>
        <span class="s2">return </span><span class="s1">sign * MAX_INTEGER;</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">value === value ? value : </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Converts `value` to an integer. 
     * 
     * **Note:** This method is loosely based on 
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger). 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Lang 
     * @param {*} value The value to convert. 
     * @returns {number} Returns the converted integer. 
     * @example 
     * 
     * _.toInteger(3.2); 
     * // =&gt; 3 
     * 
     * _.toInteger(Number.MIN_VALUE); 
     * // =&gt; 0 
     * 
     * _.toInteger(Infinity); 
     * // =&gt; 1.7976931348623157e+308 
     * 
     * _.toInteger('3.2'); 
     * // =&gt; 3 
     */</span>
    <span class="s2">function </span><span class="s1">toInteger(value) {</span>
      <span class="s2">var </span><span class="s1">result = toFinite(value),</span>
          <span class="s1">remainder = result % </span><span class="s4">1</span><span class="s1">;</span>

      <span class="s2">return </span><span class="s1">result === result ? (remainder ? result - remainder : result) : </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Converts `value` to an integer suitable for use as the length of an 
     * array-like object. 
     * 
     * **Note:** This method is based on 
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength). 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Lang 
     * @param {*} value The value to convert. 
     * @returns {number} Returns the converted integer. 
     * @example 
     * 
     * _.toLength(3.2); 
     * // =&gt; 3 
     * 
     * _.toLength(Number.MIN_VALUE); 
     * // =&gt; 0 
     * 
     * _.toLength(Infinity); 
     * // =&gt; 4294967295 
     * 
     * _.toLength('3.2'); 
     * // =&gt; 3 
     */</span>
    <span class="s2">function </span><span class="s1">toLength(value) {</span>
      <span class="s2">return </span><span class="s1">value ? baseClamp(toInteger(value), </span><span class="s4">0</span><span class="s1">, MAX_ARRAY_LENGTH) : </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Converts `value` to a number. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Lang 
     * @param {*} value The value to process. 
     * @returns {number} Returns the number. 
     * @example 
     * 
     * _.toNumber(3.2); 
     * // =&gt; 3.2 
     * 
     * _.toNumber(Number.MIN_VALUE); 
     * // =&gt; 5e-324 
     * 
     * _.toNumber(Infinity); 
     * // =&gt; Infinity 
     * 
     * _.toNumber('3.2'); 
     * // =&gt; 3.2 
     */</span>
    <span class="s2">function </span><span class="s1">toNumber(value) {</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">value == </span><span class="s3">'number'</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">value;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(isSymbol(value)) {</span>
        <span class="s2">return </span><span class="s1">NAN;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(isObject(value)) {</span>
        <span class="s2">var </span><span class="s1">other = </span><span class="s2">typeof </span><span class="s1">value.valueOf == </span><span class="s3">'function' </span><span class="s1">? value.valueOf() : value;</span>
        <span class="s1">value = isObject(other) ? (other + </span><span class="s3">''</span><span class="s1">) : other;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">value != </span><span class="s3">'string'</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">value === </span><span class="s4">0 </span><span class="s1">? value : +value;</span>
      <span class="s1">}</span>
      <span class="s1">value = baseTrim(value);</span>
      <span class="s2">var </span><span class="s1">isBinary = reIsBinary.test(value);</span>
      <span class="s2">return </span><span class="s1">(isBinary || reIsOctal.test(value))</span>
        <span class="s1">? freeParseInt(value.slice(</span><span class="s4">2</span><span class="s1">), isBinary ? </span><span class="s4">2 </span><span class="s1">: </span><span class="s4">8</span><span class="s1">)</span>
        <span class="s1">: (reIsBadHex.test(value) ? NAN : +value);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Converts `value` to a plain object flattening inherited enumerable string 
     * keyed properties of `value` to own properties of the plain object. 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.0.0 
     * @category Lang 
     * @param {*} value The value to convert. 
     * @returns {Object} Returns the converted plain object. 
     * @example 
     * 
     * function Foo() { 
     *   this.b = 2; 
     * } 
     * 
     * Foo.prototype.c = 3; 
     * 
     * _.assign({ 'a': 1 }, new Foo); 
     * // =&gt; { 'a': 1, 'b': 2 } 
     * 
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo)); 
     * // =&gt; { 'a': 1, 'b': 2, 'c': 3 } 
     */</span>
    <span class="s2">function </span><span class="s1">toPlainObject(value) {</span>
      <span class="s2">return </span><span class="s1">copyObject(value, keysIn(value));</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Converts `value` to a safe integer. A safe integer can be compared and 
     * represented correctly. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Lang 
     * @param {*} value The value to convert. 
     * @returns {number} Returns the converted integer. 
     * @example 
     * 
     * _.toSafeInteger(3.2); 
     * // =&gt; 3 
     * 
     * _.toSafeInteger(Number.MIN_VALUE); 
     * // =&gt; 0 
     * 
     * _.toSafeInteger(Infinity); 
     * // =&gt; 9007199254740991 
     * 
     * _.toSafeInteger('3.2'); 
     * // =&gt; 3 
     */</span>
    <span class="s2">function </span><span class="s1">toSafeInteger(value) {</span>
      <span class="s2">return </span><span class="s1">value</span>
        <span class="s1">? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)</span>
        <span class="s1">: (value === </span><span class="s4">0 </span><span class="s1">? value : </span><span class="s4">0</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Converts `value` to a string. An empty string is returned for `null` 
     * and `undefined` values. The sign of `-0` is preserved. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Lang 
     * @param {*} value The value to convert. 
     * @returns {string} Returns the converted string. 
     * @example 
     * 
     * _.toString(null); 
     * // =&gt; '' 
     * 
     * _.toString(-0); 
     * // =&gt; '-0' 
     * 
     * _.toString([1, 2, 3]); 
     * // =&gt; '1,2,3' 
     */</span>
    <span class="s2">function </span><span class="s1">toString(value) {</span>
      <span class="s2">return </span><span class="s1">value == </span><span class="s2">null </span><span class="s1">? </span><span class="s3">'' </span><span class="s1">: baseToString(value);</span>
    <span class="s1">}</span>

    <span class="s0">/*------------------------------------------------------------------------*/</span>

    <span class="s0">/** 
     * Assigns own enumerable string keyed properties of source objects to the 
     * destination object. Source objects are applied from left to right. 
     * Subsequent sources overwrite property assignments of previous sources. 
     * 
     * **Note:** This method mutates `object` and is loosely based on 
     * [`Object.assign`](https://mdn.io/Object/assign). 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.10.0 
     * @category Object 
     * @param {Object} object The destination object. 
     * @param {...Object} [sources] The source objects. 
     * @returns {Object} Returns `object`. 
     * @see _.assignIn 
     * @example 
     * 
     * function Foo() { 
     *   this.a = 1; 
     * } 
     * 
     * function Bar() { 
     *   this.c = 3; 
     * } 
     * 
     * Foo.prototype.b = 2; 
     * Bar.prototype.d = 4; 
     * 
     * _.assign({ 'a': 0 }, new Foo, new Bar); 
     * // =&gt; { 'a': 1, 'c': 3 } 
     */</span>
    <span class="s2">var </span><span class="s1">assign = createAssigner(</span><span class="s2">function</span><span class="s1">(object, source) {</span>
      <span class="s2">if </span><span class="s1">(isPrototype(source) || isArrayLike(source)) {</span>
        <span class="s1">copyObject(source, keys(source), object);</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">key </span><span class="s2">in </span><span class="s1">source) {</span>
        <span class="s2">if </span><span class="s1">(hasOwnProperty.call(source, key)) {</span>
          <span class="s1">assignValue(object, key, source[key]);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">});</span>

    <span class="s0">/** 
     * This method is like `_.assign` except that it iterates over own and 
     * inherited source properties. 
     * 
     * **Note:** This method mutates `object`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @alias extend 
     * @category Object 
     * @param {Object} object The destination object. 
     * @param {...Object} [sources] The source objects. 
     * @returns {Object} Returns `object`. 
     * @see _.assign 
     * @example 
     * 
     * function Foo() { 
     *   this.a = 1; 
     * } 
     * 
     * function Bar() { 
     *   this.c = 3; 
     * } 
     * 
     * Foo.prototype.b = 2; 
     * Bar.prototype.d = 4; 
     * 
     * _.assignIn({ 'a': 0 }, new Foo, new Bar); 
     * // =&gt; { 'a': 1, 'b': 2, 'c': 3, 'd': 4 } 
     */</span>
    <span class="s2">var </span><span class="s1">assignIn = createAssigner(</span><span class="s2">function</span><span class="s1">(object, source) {</span>
      <span class="s1">copyObject(source, keysIn(source), object);</span>
    <span class="s1">});</span>

    <span class="s0">/** 
     * This method is like `_.assignIn` except that it accepts `customizer` 
     * which is invoked to produce the assigned values. If `customizer` returns 
     * `undefined`, assignment is handled by the method instead. The `customizer` 
     * is invoked with five arguments: (objValue, srcValue, key, object, source). 
     * 
     * **Note:** This method mutates `object`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @alias extendWith 
     * @category Object 
     * @param {Object} object The destination object. 
     * @param {...Object} sources The source objects. 
     * @param {Function} [customizer] The function to customize assigned values. 
     * @returns {Object} Returns `object`. 
     * @see _.assignWith 
     * @example 
     * 
     * function customizer(objValue, srcValue) { 
     *   return _.isUndefined(objValue) ? srcValue : objValue; 
     * } 
     * 
     * var defaults = _.partialRight(_.assignInWith, customizer); 
     * 
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 }); 
     * // =&gt; { 'a': 1, 'b': 2 } 
     */</span>
    <span class="s2">var </span><span class="s1">assignInWith = createAssigner(</span><span class="s2">function</span><span class="s1">(object, source, srcIndex, customizer) {</span>
      <span class="s1">copyObject(source, keysIn(source), object, customizer);</span>
    <span class="s1">});</span>

    <span class="s0">/** 
     * This method is like `_.assign` except that it accepts `customizer` 
     * which is invoked to produce the assigned values. If `customizer` returns 
     * `undefined`, assignment is handled by the method instead. The `customizer` 
     * is invoked with five arguments: (objValue, srcValue, key, object, source). 
     * 
     * **Note:** This method mutates `object`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Object 
     * @param {Object} object The destination object. 
     * @param {...Object} sources The source objects. 
     * @param {Function} [customizer] The function to customize assigned values. 
     * @returns {Object} Returns `object`. 
     * @see _.assignInWith 
     * @example 
     * 
     * function customizer(objValue, srcValue) { 
     *   return _.isUndefined(objValue) ? srcValue : objValue; 
     * } 
     * 
     * var defaults = _.partialRight(_.assignWith, customizer); 
     * 
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 }); 
     * // =&gt; { 'a': 1, 'b': 2 } 
     */</span>
    <span class="s2">var </span><span class="s1">assignWith = createAssigner(</span><span class="s2">function</span><span class="s1">(object, source, srcIndex, customizer) {</span>
      <span class="s1">copyObject(source, keys(source), object, customizer);</span>
    <span class="s1">});</span>

    <span class="s0">/** 
     * Creates an array of values corresponding to `paths` of `object`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 1.0.0 
     * @category Object 
     * @param {Object} object The object to iterate over. 
     * @param {...(string|string[])} [paths] The property paths to pick. 
     * @returns {Array} Returns the picked values. 
     * @example 
     * 
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] }; 
     * 
     * _.at(object, ['a[0].b.c', 'a[1]']); 
     * // =&gt; [3, 4] 
     */</span>
    <span class="s2">var </span><span class="s1">at = flatRest(baseAt);</span>

    <span class="s0">/** 
     * Creates an object that inherits from the `prototype` object. If a 
     * `properties` object is given, its own enumerable string keyed properties 
     * are assigned to the created object. 
     * 
     * @static 
     * @memberOf _ 
     * @since 2.3.0 
     * @category Object 
     * @param {Object} prototype The object to inherit from. 
     * @param {Object} [properties] The properties to assign to the object. 
     * @returns {Object} Returns the new object. 
     * @example 
     * 
     * function Shape() { 
     *   this.x = 0; 
     *   this.y = 0; 
     * } 
     * 
     * function Circle() { 
     *   Shape.call(this); 
     * } 
     * 
     * Circle.prototype = _.create(Shape.prototype, { 
     *   'constructor': Circle 
     * }); 
     * 
     * var circle = new Circle; 
     * circle instanceof Circle; 
     * // =&gt; true 
     * 
     * circle instanceof Shape; 
     * // =&gt; true 
     */</span>
    <span class="s2">function </span><span class="s1">create(prototype, properties) {</span>
      <span class="s2">var </span><span class="s1">result = baseCreate(prototype);</span>
      <span class="s2">return </span><span class="s1">properties == </span><span class="s2">null </span><span class="s1">? result : baseAssign(result, properties);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Assigns own and inherited enumerable string keyed properties of source 
     * objects to the destination object for all destination properties that 
     * resolve to `undefined`. Source objects are applied from left to right. 
     * Once a property is set, additional values of the same property are ignored. 
     * 
     * **Note:** This method mutates `object`. 
     * 
     * @static 
     * @since 0.1.0 
     * @memberOf _ 
     * @category Object 
     * @param {Object} object The destination object. 
     * @param {...Object} [sources] The source objects. 
     * @returns {Object} Returns `object`. 
     * @see _.defaultsDeep 
     * @example 
     * 
     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 }); 
     * // =&gt; { 'a': 1, 'b': 2 } 
     */</span>
    <span class="s2">var </span><span class="s1">defaults = baseRest(</span><span class="s2">function</span><span class="s1">(object, sources) {</span>
      <span class="s1">object = Object(object);</span>

      <span class="s2">var </span><span class="s1">index = -</span><span class="s4">1</span><span class="s1">;</span>
      <span class="s2">var </span><span class="s1">length = sources.length;</span>
      <span class="s2">var </span><span class="s1">guard = length &gt; </span><span class="s4">2 </span><span class="s1">? sources[</span><span class="s4">2</span><span class="s1">] : undefined;</span>

      <span class="s2">if </span><span class="s1">(guard &amp;&amp; isIterateeCall(sources[</span><span class="s4">0</span><span class="s1">], sources[</span><span class="s4">1</span><span class="s1">], guard)) {</span>
        <span class="s1">length = </span><span class="s4">1</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">while </span><span class="s1">(++index &lt; length) {</span>
        <span class="s2">var </span><span class="s1">source = sources[index];</span>
        <span class="s2">var </span><span class="s1">props = keysIn(source);</span>
        <span class="s2">var </span><span class="s1">propsIndex = -</span><span class="s4">1</span><span class="s1">;</span>
        <span class="s2">var </span><span class="s1">propsLength = props.length;</span>

        <span class="s2">while </span><span class="s1">(++propsIndex &lt; propsLength) {</span>
          <span class="s2">var </span><span class="s1">key = props[propsIndex];</span>
          <span class="s2">var </span><span class="s1">value = object[key];</span>

          <span class="s2">if </span><span class="s1">(value === undefined ||</span>
              <span class="s1">(eq(value, objectProto[key]) &amp;&amp; !hasOwnProperty.call(object, key))) {</span>
            <span class="s1">object[key] = source[key];</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">return </span><span class="s1">object;</span>
    <span class="s1">});</span>

    <span class="s0">/** 
     * This method is like `_.defaults` except that it recursively assigns 
     * default properties. 
     * 
     * **Note:** This method mutates `object`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.10.0 
     * @category Object 
     * @param {Object} object The destination object. 
     * @param {...Object} [sources] The source objects. 
     * @returns {Object} Returns `object`. 
     * @see _.defaults 
     * @example 
     * 
     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } }); 
     * // =&gt; { 'a': { 'b': 2, 'c': 3 } } 
     */</span>
    <span class="s2">var </span><span class="s1">defaultsDeep = baseRest(</span><span class="s2">function</span><span class="s1">(args) {</span>
      <span class="s1">args.push(undefined, customDefaultsMerge);</span>
      <span class="s2">return </span><span class="s1">apply(mergeWith, undefined, args);</span>
    <span class="s1">});</span>

    <span class="s0">/** 
     * This method is like `_.find` except that it returns the key of the first 
     * element `predicate` returns truthy for instead of the element itself. 
     * 
     * @static 
     * @memberOf _ 
     * @since 1.1.0 
     * @category Object 
     * @param {Object} object The object to inspect. 
     * @param {Function} [predicate=_.identity] The function invoked per iteration. 
     * @returns {string|undefined} Returns the key of the matched element, 
     *  else `undefined`. 
     * @example 
     * 
     * var users = { 
     *   'barney':  { 'age': 36, 'active': true }, 
     *   'fred':    { 'age': 40, 'active': false }, 
     *   'pebbles': { 'age': 1,  'active': true } 
     * }; 
     * 
     * _.findKey(users, function(o) { return o.age &lt; 40; }); 
     * // =&gt; 'barney' (iteration order is not guaranteed) 
     * 
     * // The `_.matches` iteratee shorthand. 
     * _.findKey(users, { 'age': 1, 'active': true }); 
     * // =&gt; 'pebbles' 
     * 
     * // The `_.matchesProperty` iteratee shorthand. 
     * _.findKey(users, ['active', false]); 
     * // =&gt; 'fred' 
     * 
     * // The `_.property` iteratee shorthand. 
     * _.findKey(users, 'active'); 
     * // =&gt; 'barney' 
     */</span>
    <span class="s2">function </span><span class="s1">findKey(object, predicate) {</span>
      <span class="s2">return </span><span class="s1">baseFindKey(object, getIteratee(predicate, </span><span class="s4">3</span><span class="s1">), baseForOwn);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * This method is like `_.findKey` except that it iterates over elements of 
     * a collection in the opposite order. 
     * 
     * @static 
     * @memberOf _ 
     * @since 2.0.0 
     * @category Object 
     * @param {Object} object The object to inspect. 
     * @param {Function} [predicate=_.identity] The function invoked per iteration. 
     * @returns {string|undefined} Returns the key of the matched element, 
     *  else `undefined`. 
     * @example 
     * 
     * var users = { 
     *   'barney':  { 'age': 36, 'active': true }, 
     *   'fred':    { 'age': 40, 'active': false }, 
     *   'pebbles': { 'age': 1,  'active': true } 
     * }; 
     * 
     * _.findLastKey(users, function(o) { return o.age &lt; 40; }); 
     * // =&gt; returns 'pebbles' assuming `_.findKey` returns 'barney' 
     * 
     * // The `_.matches` iteratee shorthand. 
     * _.findLastKey(users, { 'age': 36, 'active': true }); 
     * // =&gt; 'barney' 
     * 
     * // The `_.matchesProperty` iteratee shorthand. 
     * _.findLastKey(users, ['active', false]); 
     * // =&gt; 'fred' 
     * 
     * // The `_.property` iteratee shorthand. 
     * _.findLastKey(users, 'active'); 
     * // =&gt; 'pebbles' 
     */</span>
    <span class="s2">function </span><span class="s1">findLastKey(object, predicate) {</span>
      <span class="s2">return </span><span class="s1">baseFindKey(object, getIteratee(predicate, </span><span class="s4">3</span><span class="s1">), baseForOwnRight);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Iterates over own and inherited enumerable string keyed properties of an 
     * object and invokes `iteratee` for each property. The iteratee is invoked 
     * with three arguments: (value, key, object). Iteratee functions may exit 
     * iteration early by explicitly returning `false`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.3.0 
     * @category Object 
     * @param {Object} object The object to iterate over. 
     * @param {Function} [iteratee=_.identity] The function invoked per iteration. 
     * @returns {Object} Returns `object`. 
     * @see _.forInRight 
     * @example 
     * 
     * function Foo() { 
     *   this.a = 1; 
     *   this.b = 2; 
     * } 
     * 
     * Foo.prototype.c = 3; 
     * 
     * _.forIn(new Foo, function(value, key) { 
     *   console.log(key); 
     * }); 
     * // =&gt; Logs 'a', 'b', then 'c' (iteration order is not guaranteed). 
     */</span>
    <span class="s2">function </span><span class="s1">forIn(object, iteratee) {</span>
      <span class="s2">return </span><span class="s1">object == </span><span class="s2">null</span>
        <span class="s1">? object</span>
        <span class="s1">: baseFor(object, getIteratee(iteratee, </span><span class="s4">3</span><span class="s1">), keysIn);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * This method is like `_.forIn` except that it iterates over properties of 
     * `object` in the opposite order. 
     * 
     * @static 
     * @memberOf _ 
     * @since 2.0.0 
     * @category Object 
     * @param {Object} object The object to iterate over. 
     * @param {Function} [iteratee=_.identity] The function invoked per iteration. 
     * @returns {Object} Returns `object`. 
     * @see _.forIn 
     * @example 
     * 
     * function Foo() { 
     *   this.a = 1; 
     *   this.b = 2; 
     * } 
     * 
     * Foo.prototype.c = 3; 
     * 
     * _.forInRight(new Foo, function(value, key) { 
     *   console.log(key); 
     * }); 
     * // =&gt; Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'. 
     */</span>
    <span class="s2">function </span><span class="s1">forInRight(object, iteratee) {</span>
      <span class="s2">return </span><span class="s1">object == </span><span class="s2">null</span>
        <span class="s1">? object</span>
        <span class="s1">: baseForRight(object, getIteratee(iteratee, </span><span class="s4">3</span><span class="s1">), keysIn);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Iterates over own enumerable string keyed properties of an object and 
     * invokes `iteratee` for each property. The iteratee is invoked with three 
     * arguments: (value, key, object). Iteratee functions may exit iteration 
     * early by explicitly returning `false`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.3.0 
     * @category Object 
     * @param {Object} object The object to iterate over. 
     * @param {Function} [iteratee=_.identity] The function invoked per iteration. 
     * @returns {Object} Returns `object`. 
     * @see _.forOwnRight 
     * @example 
     * 
     * function Foo() { 
     *   this.a = 1; 
     *   this.b = 2; 
     * } 
     * 
     * Foo.prototype.c = 3; 
     * 
     * _.forOwn(new Foo, function(value, key) { 
     *   console.log(key); 
     * }); 
     * // =&gt; Logs 'a' then 'b' (iteration order is not guaranteed). 
     */</span>
    <span class="s2">function </span><span class="s1">forOwn(object, iteratee) {</span>
      <span class="s2">return </span><span class="s1">object &amp;&amp; baseForOwn(object, getIteratee(iteratee, </span><span class="s4">3</span><span class="s1">));</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * This method is like `_.forOwn` except that it iterates over properties of 
     * `object` in the opposite order. 
     * 
     * @static 
     * @memberOf _ 
     * @since 2.0.0 
     * @category Object 
     * @param {Object} object The object to iterate over. 
     * @param {Function} [iteratee=_.identity] The function invoked per iteration. 
     * @returns {Object} Returns `object`. 
     * @see _.forOwn 
     * @example 
     * 
     * function Foo() { 
     *   this.a = 1; 
     *   this.b = 2; 
     * } 
     * 
     * Foo.prototype.c = 3; 
     * 
     * _.forOwnRight(new Foo, function(value, key) { 
     *   console.log(key); 
     * }); 
     * // =&gt; Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'. 
     */</span>
    <span class="s2">function </span><span class="s1">forOwnRight(object, iteratee) {</span>
      <span class="s2">return </span><span class="s1">object &amp;&amp; baseForOwnRight(object, getIteratee(iteratee, </span><span class="s4">3</span><span class="s1">));</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates an array of function property names from own enumerable properties 
     * of `object`. 
     * 
     * @static 
     * @since 0.1.0 
     * @memberOf _ 
     * @category Object 
     * @param {Object} object The object to inspect. 
     * @returns {Array} Returns the function names. 
     * @see _.functionsIn 
     * @example 
     * 
     * function Foo() { 
     *   this.a = _.constant('a'); 
     *   this.b = _.constant('b'); 
     * } 
     * 
     * Foo.prototype.c = _.constant('c'); 
     * 
     * _.functions(new Foo); 
     * // =&gt; ['a', 'b'] 
     */</span>
    <span class="s2">function </span><span class="s1">functions(object) {</span>
      <span class="s2">return </span><span class="s1">object == </span><span class="s2">null </span><span class="s1">? [] : baseFunctions(object, keys(object));</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates an array of function property names from own and inherited 
     * enumerable properties of `object`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Object 
     * @param {Object} object The object to inspect. 
     * @returns {Array} Returns the function names. 
     * @see _.functions 
     * @example 
     * 
     * function Foo() { 
     *   this.a = _.constant('a'); 
     *   this.b = _.constant('b'); 
     * } 
     * 
     * Foo.prototype.c = _.constant('c'); 
     * 
     * _.functionsIn(new Foo); 
     * // =&gt; ['a', 'b', 'c'] 
     */</span>
    <span class="s2">function </span><span class="s1">functionsIn(object) {</span>
      <span class="s2">return </span><span class="s1">object == </span><span class="s2">null </span><span class="s1">? [] : baseFunctions(object, keysIn(object));</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Gets the value at `path` of `object`. If the resolved value is 
     * `undefined`, the `defaultValue` is returned in its place. 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.7.0 
     * @category Object 
     * @param {Object} object The object to query. 
     * @param {Array|string} path The path of the property to get. 
     * @param {*} [defaultValue] The value returned for `undefined` resolved values. 
     * @returns {*} Returns the resolved value. 
     * @example 
     * 
     * var object = { 'a': [{ 'b': { 'c': 3 } }] }; 
     * 
     * _.get(object, 'a[0].b.c'); 
     * // =&gt; 3 
     * 
     * _.get(object, ['a', '0', 'b', 'c']); 
     * // =&gt; 3 
     * 
     * _.get(object, 'a.b.c', 'default'); 
     * // =&gt; 'default' 
     */</span>
    <span class="s2">function </span><span class="s1">get(object, path, defaultValue) {</span>
      <span class="s2">var </span><span class="s1">result = object == </span><span class="s2">null </span><span class="s1">? undefined : baseGet(object, path);</span>
      <span class="s2">return </span><span class="s1">result === undefined ? defaultValue : result;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Checks if `path` is a direct property of `object`. 
     * 
     * @static 
     * @since 0.1.0 
     * @memberOf _ 
     * @category Object 
     * @param {Object} object The object to query. 
     * @param {Array|string} path The path to check. 
     * @returns {boolean} Returns `true` if `path` exists, else `false`. 
     * @example 
     * 
     * var object = { 'a': { 'b': 2 } }; 
     * var other = _.create({ 'a': _.create({ 'b': 2 }) }); 
     * 
     * _.has(object, 'a'); 
     * // =&gt; true 
     * 
     * _.has(object, 'a.b'); 
     * // =&gt; true 
     * 
     * _.has(object, ['a', 'b']); 
     * // =&gt; true 
     * 
     * _.has(other, 'a'); 
     * // =&gt; false 
     */</span>
    <span class="s2">function </span><span class="s1">has(object, path) {</span>
      <span class="s2">return </span><span class="s1">object != </span><span class="s2">null </span><span class="s1">&amp;&amp; hasPath(object, path, baseHas);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Checks if `path` is a direct or inherited property of `object`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Object 
     * @param {Object} object The object to query. 
     * @param {Array|string} path The path to check. 
     * @returns {boolean} Returns `true` if `path` exists, else `false`. 
     * @example 
     * 
     * var object = _.create({ 'a': _.create({ 'b': 2 }) }); 
     * 
     * _.hasIn(object, 'a'); 
     * // =&gt; true 
     * 
     * _.hasIn(object, 'a.b'); 
     * // =&gt; true 
     * 
     * _.hasIn(object, ['a', 'b']); 
     * // =&gt; true 
     * 
     * _.hasIn(object, 'b'); 
     * // =&gt; false 
     */</span>
    <span class="s2">function </span><span class="s1">hasIn(object, path) {</span>
      <span class="s2">return </span><span class="s1">object != </span><span class="s2">null </span><span class="s1">&amp;&amp; hasPath(object, path, baseHasIn);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates an object composed of the inverted keys and values of `object`. 
     * If `object` contains duplicate values, subsequent values overwrite 
     * property assignments of previous values. 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.7.0 
     * @category Object 
     * @param {Object} object The object to invert. 
     * @returns {Object} Returns the new inverted object. 
     * @example 
     * 
     * var object = { 'a': 1, 'b': 2, 'c': 1 }; 
     * 
     * _.invert(object); 
     * // =&gt; { '1': 'c', '2': 'b' } 
     */</span>
    <span class="s2">var </span><span class="s1">invert = createInverter(</span><span class="s2">function</span><span class="s1">(result, value, key) {</span>
      <span class="s2">if </span><span class="s1">(value != </span><span class="s2">null </span><span class="s1">&amp;&amp;</span>
          <span class="s2">typeof </span><span class="s1">value.toString != </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s1">value = nativeObjectToString.call(value);</span>
      <span class="s1">}</span>

      <span class="s1">result[value] = key;</span>
    <span class="s1">}, constant(identity));</span>

    <span class="s0">/** 
     * This method is like `_.invert` except that the inverted object is generated 
     * from the results of running each element of `object` thru `iteratee`. The 
     * corresponding inverted value of each inverted key is an array of keys 
     * responsible for generating the inverted value. The iteratee is invoked 
     * with one argument: (value). 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.1.0 
     * @category Object 
     * @param {Object} object The object to invert. 
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element. 
     * @returns {Object} Returns the new inverted object. 
     * @example 
     * 
     * var object = { 'a': 1, 'b': 2, 'c': 1 }; 
     * 
     * _.invertBy(object); 
     * // =&gt; { '1': ['a', 'c'], '2': ['b'] } 
     * 
     * _.invertBy(object, function(value) { 
     *   return 'group' + value; 
     * }); 
     * // =&gt; { 'group1': ['a', 'c'], 'group2': ['b'] } 
     */</span>
    <span class="s2">var </span><span class="s1">invertBy = createInverter(</span><span class="s2">function</span><span class="s1">(result, value, key) {</span>
      <span class="s2">if </span><span class="s1">(value != </span><span class="s2">null </span><span class="s1">&amp;&amp;</span>
          <span class="s2">typeof </span><span class="s1">value.toString != </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s1">value = nativeObjectToString.call(value);</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(hasOwnProperty.call(result, value)) {</span>
        <span class="s1">result[value].push(key);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">result[value] = [key];</span>
      <span class="s1">}</span>
    <span class="s1">}, getIteratee);</span>

    <span class="s0">/** 
     * Invokes the method at `path` of `object`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Object 
     * @param {Object} object The object to query. 
     * @param {Array|string} path The path of the method to invoke. 
     * @param {...*} [args] The arguments to invoke the method with. 
     * @returns {*} Returns the result of the invoked method. 
     * @example 
     * 
     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] }; 
     * 
     * _.invoke(object, 'a[0].b.c.slice', 1, 3); 
     * // =&gt; [2, 3] 
     */</span>
    <span class="s2">var </span><span class="s1">invoke = baseRest(baseInvoke);</span>

    <span class="s0">/** 
     * Creates an array of the own enumerable property names of `object`. 
     * 
     * **Note:** Non-object values are coerced to objects. See the 
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys) 
     * for more details. 
     * 
     * @static 
     * @since 0.1.0 
     * @memberOf _ 
     * @category Object 
     * @param {Object} object The object to query. 
     * @returns {Array} Returns the array of property names. 
     * @example 
     * 
     * function Foo() { 
     *   this.a = 1; 
     *   this.b = 2; 
     * } 
     * 
     * Foo.prototype.c = 3; 
     * 
     * _.keys(new Foo); 
     * // =&gt; ['a', 'b'] (iteration order is not guaranteed) 
     * 
     * _.keys('hi'); 
     * // =&gt; ['0', '1'] 
     */</span>
    <span class="s2">function </span><span class="s1">keys(object) {</span>
      <span class="s2">return </span><span class="s1">isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates an array of the own and inherited enumerable property names of `object`. 
     * 
     * **Note:** Non-object values are coerced to objects. 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.0.0 
     * @category Object 
     * @param {Object} object The object to query. 
     * @returns {Array} Returns the array of property names. 
     * @example 
     * 
     * function Foo() { 
     *   this.a = 1; 
     *   this.b = 2; 
     * } 
     * 
     * Foo.prototype.c = 3; 
     * 
     * _.keysIn(new Foo); 
     * // =&gt; ['a', 'b', 'c'] (iteration order is not guaranteed) 
     */</span>
    <span class="s2">function </span><span class="s1">keysIn(object) {</span>
      <span class="s2">return </span><span class="s1">isArrayLike(object) ? arrayLikeKeys(object, </span><span class="s2">true</span><span class="s1">) : baseKeysIn(object);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The opposite of `_.mapValues`; this method creates an object with the 
     * same values as `object` and keys generated by running each own enumerable 
     * string keyed property of `object` thru `iteratee`. The iteratee is invoked 
     * with three arguments: (value, key, object). 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.8.0 
     * @category Object 
     * @param {Object} object The object to iterate over. 
     * @param {Function} [iteratee=_.identity] The function invoked per iteration. 
     * @returns {Object} Returns the new mapped object. 
     * @see _.mapValues 
     * @example 
     * 
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) { 
     *   return key + value; 
     * }); 
     * // =&gt; { 'a1': 1, 'b2': 2 } 
     */</span>
    <span class="s2">function </span><span class="s1">mapKeys(object, iteratee) {</span>
      <span class="s2">var </span><span class="s1">result = {};</span>
      <span class="s1">iteratee = getIteratee(iteratee, </span><span class="s4">3</span><span class="s1">);</span>

      <span class="s1">baseForOwn(object, </span><span class="s2">function</span><span class="s1">(value, key, object) {</span>
        <span class="s1">baseAssignValue(result, iteratee(value, key, object), value);</span>
      <span class="s1">});</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates an object with the same keys as `object` and values generated 
     * by running each own enumerable string keyed property of `object` thru 
     * `iteratee`. The iteratee is invoked with three arguments: 
     * (value, key, object). 
     * 
     * @static 
     * @memberOf _ 
     * @since 2.4.0 
     * @category Object 
     * @param {Object} object The object to iterate over. 
     * @param {Function} [iteratee=_.identity] The function invoked per iteration. 
     * @returns {Object} Returns the new mapped object. 
     * @see _.mapKeys 
     * @example 
     * 
     * var users = { 
     *   'fred':    { 'user': 'fred',    'age': 40 }, 
     *   'pebbles': { 'user': 'pebbles', 'age': 1 } 
     * }; 
     * 
     * _.mapValues(users, function(o) { return o.age; }); 
     * // =&gt; { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed) 
     * 
     * // The `_.property` iteratee shorthand. 
     * _.mapValues(users, 'age'); 
     * // =&gt; { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed) 
     */</span>
    <span class="s2">function </span><span class="s1">mapValues(object, iteratee) {</span>
      <span class="s2">var </span><span class="s1">result = {};</span>
      <span class="s1">iteratee = getIteratee(iteratee, </span><span class="s4">3</span><span class="s1">);</span>

      <span class="s1">baseForOwn(object, </span><span class="s2">function</span><span class="s1">(value, key, object) {</span>
        <span class="s1">baseAssignValue(result, key, iteratee(value, key, object));</span>
      <span class="s1">});</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * This method is like `_.assign` except that it recursively merges own and 
     * inherited enumerable string keyed properties of source objects into the 
     * destination object. Source properties that resolve to `undefined` are 
     * skipped if a destination value exists. Array and plain object properties 
     * are merged recursively. Other objects and value types are overridden by 
     * assignment. Source objects are applied from left to right. Subsequent 
     * sources overwrite property assignments of previous sources. 
     * 
     * **Note:** This method mutates `object`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.5.0 
     * @category Object 
     * @param {Object} object The destination object. 
     * @param {...Object} [sources] The source objects. 
     * @returns {Object} Returns `object`. 
     * @example 
     * 
     * var object = { 
     *   'a': [{ 'b': 2 }, { 'd': 4 }] 
     * }; 
     * 
     * var other = { 
     *   'a': [{ 'c': 3 }, { 'e': 5 }] 
     * }; 
     * 
     * _.merge(object, other); 
     * // =&gt; { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] } 
     */</span>
    <span class="s2">var </span><span class="s1">merge = createAssigner(</span><span class="s2">function</span><span class="s1">(object, source, srcIndex) {</span>
      <span class="s1">baseMerge(object, source, srcIndex);</span>
    <span class="s1">});</span>

    <span class="s0">/** 
     * This method is like `_.merge` except that it accepts `customizer` which 
     * is invoked to produce the merged values of the destination and source 
     * properties. If `customizer` returns `undefined`, merging is handled by the 
     * method instead. The `customizer` is invoked with six arguments: 
     * (objValue, srcValue, key, object, source, stack). 
     * 
     * **Note:** This method mutates `object`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Object 
     * @param {Object} object The destination object. 
     * @param {...Object} sources The source objects. 
     * @param {Function} customizer The function to customize assigned values. 
     * @returns {Object} Returns `object`. 
     * @example 
     * 
     * function customizer(objValue, srcValue) { 
     *   if (_.isArray(objValue)) { 
     *     return objValue.concat(srcValue); 
     *   } 
     * } 
     * 
     * var object = { 'a': [1], 'b': [2] }; 
     * var other = { 'a': [3], 'b': [4] }; 
     * 
     * _.mergeWith(object, other, customizer); 
     * // =&gt; { 'a': [1, 3], 'b': [2, 4] } 
     */</span>
    <span class="s2">var </span><span class="s1">mergeWith = createAssigner(</span><span class="s2">function</span><span class="s1">(object, source, srcIndex, customizer) {</span>
      <span class="s1">baseMerge(object, source, srcIndex, customizer);</span>
    <span class="s1">});</span>

    <span class="s0">/** 
     * The opposite of `_.pick`; this method creates an object composed of the 
     * own and inherited enumerable property paths of `object` that are not omitted. 
     * 
     * **Note:** This method is considerably slower than `_.pick`. 
     * 
     * @static 
     * @since 0.1.0 
     * @memberOf _ 
     * @category Object 
     * @param {Object} object The source object. 
     * @param {...(string|string[])} [paths] The property paths to omit. 
     * @returns {Object} Returns the new object. 
     * @example 
     * 
     * var object = { 'a': 1, 'b': '2', 'c': 3 }; 
     * 
     * _.omit(object, ['a', 'c']); 
     * // =&gt; { 'b': '2' } 
     */</span>
    <span class="s2">var </span><span class="s1">omit = flatRest(</span><span class="s2">function</span><span class="s1">(object, paths) {</span>
      <span class="s2">var </span><span class="s1">result = {};</span>
      <span class="s2">if </span><span class="s1">(object == </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">result;</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">isDeep = </span><span class="s2">false</span><span class="s1">;</span>
      <span class="s1">paths = arrayMap(paths, </span><span class="s2">function</span><span class="s1">(path) {</span>
        <span class="s1">path = castPath(path, object);</span>
        <span class="s1">isDeep || (isDeep = path.length &gt; </span><span class="s4">1</span><span class="s1">);</span>
        <span class="s2">return </span><span class="s1">path;</span>
      <span class="s1">});</span>
      <span class="s1">copyObject(object, getAllKeysIn(object), result);</span>
      <span class="s2">if </span><span class="s1">(isDeep) {</span>
        <span class="s1">result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">length = paths.length;</span>
      <span class="s2">while </span><span class="s1">(length--) {</span>
        <span class="s1">baseUnset(result, paths[length]);</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">});</span>

    <span class="s0">/** 
     * The opposite of `_.pickBy`; this method creates an object composed of 
     * the own and inherited enumerable string keyed properties of `object` that 
     * `predicate` doesn't return truthy for. The predicate is invoked with two 
     * arguments: (value, key). 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Object 
     * @param {Object} object The source object. 
     * @param {Function} [predicate=_.identity] The function invoked per property. 
     * @returns {Object} Returns the new object. 
     * @example 
     * 
     * var object = { 'a': 1, 'b': '2', 'c': 3 }; 
     * 
     * _.omitBy(object, _.isNumber); 
     * // =&gt; { 'b': '2' } 
     */</span>
    <span class="s2">function </span><span class="s1">omitBy(object, predicate) {</span>
      <span class="s2">return </span><span class="s1">pickBy(object, negate(getIteratee(predicate)));</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates an object composed of the picked `object` properties. 
     * 
     * @static 
     * @since 0.1.0 
     * @memberOf _ 
     * @category Object 
     * @param {Object} object The source object. 
     * @param {...(string|string[])} [paths] The property paths to pick. 
     * @returns {Object} Returns the new object. 
     * @example 
     * 
     * var object = { 'a': 1, 'b': '2', 'c': 3 }; 
     * 
     * _.pick(object, ['a', 'c']); 
     * // =&gt; { 'a': 1, 'c': 3 } 
     */</span>
    <span class="s2">var </span><span class="s1">pick = flatRest(</span><span class="s2">function</span><span class="s1">(object, paths) {</span>
      <span class="s2">return </span><span class="s1">object == </span><span class="s2">null </span><span class="s1">? {} : basePick(object, paths);</span>
    <span class="s1">});</span>

    <span class="s0">/** 
     * Creates an object composed of the `object` properties `predicate` returns 
     * truthy for. The predicate is invoked with two arguments: (value, key). 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Object 
     * @param {Object} object The source object. 
     * @param {Function} [predicate=_.identity] The function invoked per property. 
     * @returns {Object} Returns the new object. 
     * @example 
     * 
     * var object = { 'a': 1, 'b': '2', 'c': 3 }; 
     * 
     * _.pickBy(object, _.isNumber); 
     * // =&gt; { 'a': 1, 'c': 3 } 
     */</span>
    <span class="s2">function </span><span class="s1">pickBy(object, predicate) {</span>
      <span class="s2">if </span><span class="s1">(object == </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">{};</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">props = arrayMap(getAllKeysIn(object), </span><span class="s2">function</span><span class="s1">(prop) {</span>
        <span class="s2">return </span><span class="s1">[prop];</span>
      <span class="s1">});</span>
      <span class="s1">predicate = getIteratee(predicate);</span>
      <span class="s2">return </span><span class="s1">basePickBy(object, props, </span><span class="s2">function</span><span class="s1">(value, path) {</span>
        <span class="s2">return </span><span class="s1">predicate(value, path[</span><span class="s4">0</span><span class="s1">]);</span>
      <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * This method is like `_.get` except that if the resolved value is a 
     * function it's invoked with the `this` binding of its parent object and 
     * its result is returned. 
     * 
     * @static 
     * @since 0.1.0 
     * @memberOf _ 
     * @category Object 
     * @param {Object} object The object to query. 
     * @param {Array|string} path The path of the property to resolve. 
     * @param {*} [defaultValue] The value returned for `undefined` resolved values. 
     * @returns {*} Returns the resolved value. 
     * @example 
     * 
     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] }; 
     * 
     * _.result(object, 'a[0].b.c1'); 
     * // =&gt; 3 
     * 
     * _.result(object, 'a[0].b.c2'); 
     * // =&gt; 4 
     * 
     * _.result(object, 'a[0].b.c3', 'default'); 
     * // =&gt; 'default' 
     * 
     * _.result(object, 'a[0].b.c3', _.constant('default')); 
     * // =&gt; 'default' 
     */</span>
    <span class="s2">function </span><span class="s1">result(object, path, defaultValue) {</span>
      <span class="s1">path = castPath(path, object);</span>

      <span class="s2">var </span><span class="s1">index = -</span><span class="s4">1</span><span class="s1">,</span>
          <span class="s1">length = path.length;</span>

      <span class="s0">// Ensure the loop is entered when path is empty.</span>
      <span class="s2">if </span><span class="s1">(!length) {</span>
        <span class="s1">length = </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s1">object = undefined;</span>
      <span class="s1">}</span>
      <span class="s2">while </span><span class="s1">(++index &lt; length) {</span>
        <span class="s2">var </span><span class="s1">value = object == </span><span class="s2">null </span><span class="s1">? undefined : object[toKey(path[index])];</span>
        <span class="s2">if </span><span class="s1">(value === undefined) {</span>
          <span class="s1">index = length;</span>
          <span class="s1">value = defaultValue;</span>
        <span class="s1">}</span>
        <span class="s1">object = isFunction(value) ? value.call(object) : value;</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">object;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist, 
     * it's created. Arrays are created for missing index properties while objects 
     * are created for all other missing properties. Use `_.setWith` to customize 
     * `path` creation. 
     * 
     * **Note:** This method mutates `object`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.7.0 
     * @category Object 
     * @param {Object} object The object to modify. 
     * @param {Array|string} path The path of the property to set. 
     * @param {*} value The value to set. 
     * @returns {Object} Returns `object`. 
     * @example 
     * 
     * var object = { 'a': [{ 'b': { 'c': 3 } }] }; 
     * 
     * _.set(object, 'a[0].b.c', 4); 
     * console.log(object.a[0].b.c); 
     * // =&gt; 4 
     * 
     * _.set(object, ['x', '0', 'y', 'z'], 5); 
     * console.log(object.x[0].y.z); 
     * // =&gt; 5 
     */</span>
    <span class="s2">function </span><span class="s1">set(object, path, value) {</span>
      <span class="s2">return </span><span class="s1">object == </span><span class="s2">null </span><span class="s1">? object : baseSet(object, path, value);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * This method is like `_.set` except that it accepts `customizer` which is 
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined` 
     * path creation is handled by the method instead. The `customizer` is invoked 
     * with three arguments: (nsValue, key, nsObject). 
     * 
     * **Note:** This method mutates `object`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Object 
     * @param {Object} object The object to modify. 
     * @param {Array|string} path The path of the property to set. 
     * @param {*} value The value to set. 
     * @param {Function} [customizer] The function to customize assigned values. 
     * @returns {Object} Returns `object`. 
     * @example 
     * 
     * var object = {}; 
     * 
     * _.setWith(object, '[0][1]', 'a', Object); 
     * // =&gt; { '0': { '1': 'a' } } 
     */</span>
    <span class="s2">function </span><span class="s1">setWith(object, path, value, customizer) {</span>
      <span class="s1">customizer = </span><span class="s2">typeof </span><span class="s1">customizer == </span><span class="s3">'function' </span><span class="s1">? customizer : undefined;</span>
      <span class="s2">return </span><span class="s1">object == </span><span class="s2">null </span><span class="s1">? object : baseSet(object, path, value, customizer);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates an array of own enumerable string keyed-value pairs for `object` 
     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its 
     * entries are returned. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @alias entries 
     * @category Object 
     * @param {Object} object The object to query. 
     * @returns {Array} Returns the key-value pairs. 
     * @example 
     * 
     * function Foo() { 
     *   this.a = 1; 
     *   this.b = 2; 
     * } 
     * 
     * Foo.prototype.c = 3; 
     * 
     * _.toPairs(new Foo); 
     * // =&gt; [['a', 1], ['b', 2]] (iteration order is not guaranteed) 
     */</span>
    <span class="s2">var </span><span class="s1">toPairs = createToPairs(keys);</span>

    <span class="s0">/** 
     * Creates an array of own and inherited enumerable string keyed-value pairs 
     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map 
     * or set, its entries are returned. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @alias entriesIn 
     * @category Object 
     * @param {Object} object The object to query. 
     * @returns {Array} Returns the key-value pairs. 
     * @example 
     * 
     * function Foo() { 
     *   this.a = 1; 
     *   this.b = 2; 
     * } 
     * 
     * Foo.prototype.c = 3; 
     * 
     * _.toPairsIn(new Foo); 
     * // =&gt; [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed) 
     */</span>
    <span class="s2">var </span><span class="s1">toPairsIn = createToPairs(keysIn);</span>

    <span class="s0">/** 
     * An alternative to `_.reduce`; this method transforms `object` to a new 
     * `accumulator` object which is the result of running each of its own 
     * enumerable string keyed properties thru `iteratee`, with each invocation 
     * potentially mutating the `accumulator` object. If `accumulator` is not 
     * provided, a new object with the same `[[Prototype]]` will be used. The 
     * iteratee is invoked with four arguments: (accumulator, value, key, object). 
     * Iteratee functions may exit iteration early by explicitly returning `false`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 1.3.0 
     * @category Object 
     * @param {Object} object The object to iterate over. 
     * @param {Function} [iteratee=_.identity] The function invoked per iteration. 
     * @param {*} [accumulator] The custom accumulator value. 
     * @returns {*} Returns the accumulated value. 
     * @example 
     * 
     * _.transform([2, 3, 4], function(result, n) { 
     *   result.push(n *= n); 
     *   return n % 2 == 0; 
     * }, []); 
     * // =&gt; [4, 9] 
     * 
     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) { 
     *   (result[value] || (result[value] = [])).push(key); 
     * }, {}); 
     * // =&gt; { '1': ['a', 'c'], '2': ['b'] } 
     */</span>
    <span class="s2">function </span><span class="s1">transform(object, iteratee, accumulator) {</span>
      <span class="s2">var </span><span class="s1">isArr = isArray(object),</span>
          <span class="s1">isArrLike = isArr || isBuffer(object) || isTypedArray(object);</span>

      <span class="s1">iteratee = getIteratee(iteratee, </span><span class="s4">4</span><span class="s1">);</span>
      <span class="s2">if </span><span class="s1">(accumulator == </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">var </span><span class="s1">Ctor = object &amp;&amp; object.constructor;</span>
        <span class="s2">if </span><span class="s1">(isArrLike) {</span>
          <span class="s1">accumulator = isArr ? </span><span class="s2">new </span><span class="s1">Ctor : [];</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(isObject(object)) {</span>
          <span class="s1">accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
          <span class="s1">accumulator = {};</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s1">(isArrLike ? arrayEach : baseForOwn)(object, </span><span class="s2">function</span><span class="s1">(value, index, object) {</span>
        <span class="s2">return </span><span class="s1">iteratee(accumulator, value, index, object);</span>
      <span class="s1">});</span>
      <span class="s2">return </span><span class="s1">accumulator;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Removes the property at `path` of `object`. 
     * 
     * **Note:** This method mutates `object`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Object 
     * @param {Object} object The object to modify. 
     * @param {Array|string} path The path of the property to unset. 
     * @returns {boolean} Returns `true` if the property is deleted, else `false`. 
     * @example 
     * 
     * var object = { 'a': [{ 'b': { 'c': 7 } }] }; 
     * _.unset(object, 'a[0].b.c'); 
     * // =&gt; true 
     * 
     * console.log(object); 
     * // =&gt; { 'a': [{ 'b': {} }] }; 
     * 
     * _.unset(object, ['a', '0', 'b', 'c']); 
     * // =&gt; true 
     * 
     * console.log(object); 
     * // =&gt; { 'a': [{ 'b': {} }] }; 
     */</span>
    <span class="s2">function </span><span class="s1">unset(object, path) {</span>
      <span class="s2">return </span><span class="s1">object == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">true </span><span class="s1">: baseUnset(object, path);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * This method is like `_.set` except that accepts `updater` to produce the 
     * value to set. Use `_.updateWith` to customize `path` creation. The `updater` 
     * is invoked with one argument: (value). 
     * 
     * **Note:** This method mutates `object`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.6.0 
     * @category Object 
     * @param {Object} object The object to modify. 
     * @param {Array|string} path The path of the property to set. 
     * @param {Function} updater The function to produce the updated value. 
     * @returns {Object} Returns `object`. 
     * @example 
     * 
     * var object = { 'a': [{ 'b': { 'c': 3 } }] }; 
     * 
     * _.update(object, 'a[0].b.c', function(n) { return n * n; }); 
     * console.log(object.a[0].b.c); 
     * // =&gt; 9 
     * 
     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; }); 
     * console.log(object.x[0].y.z); 
     * // =&gt; 0 
     */</span>
    <span class="s2">function </span><span class="s1">update(object, path, updater) {</span>
      <span class="s2">return </span><span class="s1">object == </span><span class="s2">null </span><span class="s1">? object : baseUpdate(object, path, castFunction(updater));</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * This method is like `_.update` except that it accepts `customizer` which is 
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined` 
     * path creation is handled by the method instead. The `customizer` is invoked 
     * with three arguments: (nsValue, key, nsObject). 
     * 
     * **Note:** This method mutates `object`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.6.0 
     * @category Object 
     * @param {Object} object The object to modify. 
     * @param {Array|string} path The path of the property to set. 
     * @param {Function} updater The function to produce the updated value. 
     * @param {Function} [customizer] The function to customize assigned values. 
     * @returns {Object} Returns `object`. 
     * @example 
     * 
     * var object = {}; 
     * 
     * _.updateWith(object, '[0][1]', _.constant('a'), Object); 
     * // =&gt; { '0': { '1': 'a' } } 
     */</span>
    <span class="s2">function </span><span class="s1">updateWith(object, path, updater, customizer) {</span>
      <span class="s1">customizer = </span><span class="s2">typeof </span><span class="s1">customizer == </span><span class="s3">'function' </span><span class="s1">? customizer : undefined;</span>
      <span class="s2">return </span><span class="s1">object == </span><span class="s2">null </span><span class="s1">? object : baseUpdate(object, path, castFunction(updater), customizer);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates an array of the own enumerable string keyed property values of `object`. 
     * 
     * **Note:** Non-object values are coerced to objects. 
     * 
     * @static 
     * @since 0.1.0 
     * @memberOf _ 
     * @category Object 
     * @param {Object} object The object to query. 
     * @returns {Array} Returns the array of property values. 
     * @example 
     * 
     * function Foo() { 
     *   this.a = 1; 
     *   this.b = 2; 
     * } 
     * 
     * Foo.prototype.c = 3; 
     * 
     * _.values(new Foo); 
     * // =&gt; [1, 2] (iteration order is not guaranteed) 
     * 
     * _.values('hi'); 
     * // =&gt; ['h', 'i'] 
     */</span>
    <span class="s2">function </span><span class="s1">values(object) {</span>
      <span class="s2">return </span><span class="s1">object == </span><span class="s2">null </span><span class="s1">? [] : baseValues(object, keys(object));</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates an array of the own and inherited enumerable string keyed property 
     * values of `object`. 
     * 
     * **Note:** Non-object values are coerced to objects. 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.0.0 
     * @category Object 
     * @param {Object} object The object to query. 
     * @returns {Array} Returns the array of property values. 
     * @example 
     * 
     * function Foo() { 
     *   this.a = 1; 
     *   this.b = 2; 
     * } 
     * 
     * Foo.prototype.c = 3; 
     * 
     * _.valuesIn(new Foo); 
     * // =&gt; [1, 2, 3] (iteration order is not guaranteed) 
     */</span>
    <span class="s2">function </span><span class="s1">valuesIn(object) {</span>
      <span class="s2">return </span><span class="s1">object == </span><span class="s2">null </span><span class="s1">? [] : baseValues(object, keysIn(object));</span>
    <span class="s1">}</span>

    <span class="s0">/*------------------------------------------------------------------------*/</span>

    <span class="s0">/** 
     * Clamps `number` within the inclusive `lower` and `upper` bounds. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Number 
     * @param {number} number The number to clamp. 
     * @param {number} [lower] The lower bound. 
     * @param {number} upper The upper bound. 
     * @returns {number} Returns the clamped number. 
     * @example 
     * 
     * _.clamp(-10, -5, 5); 
     * // =&gt; -5 
     * 
     * _.clamp(10, -5, 5); 
     * // =&gt; 5 
     */</span>
    <span class="s2">function </span><span class="s1">clamp(number, lower, upper) {</span>
      <span class="s2">if </span><span class="s1">(upper === undefined) {</span>
        <span class="s1">upper = lower;</span>
        <span class="s1">lower = undefined;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(upper !== undefined) {</span>
        <span class="s1">upper = toNumber(upper);</span>
        <span class="s1">upper = upper === upper ? upper : </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(lower !== undefined) {</span>
        <span class="s1">lower = toNumber(lower);</span>
        <span class="s1">lower = lower === lower ? lower : </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">baseClamp(toNumber(number), lower, upper);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Checks if `n` is between `start` and up to, but not including, `end`. If 
     * `end` is not specified, it's set to `start` with `start` then set to `0`. 
     * If `start` is greater than `end` the params are swapped to support 
     * negative ranges. 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.3.0 
     * @category Number 
     * @param {number} number The number to check. 
     * @param {number} [start=0] The start of the range. 
     * @param {number} end The end of the range. 
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`. 
     * @see _.range, _.rangeRight 
     * @example 
     * 
     * _.inRange(3, 2, 4); 
     * // =&gt; true 
     * 
     * _.inRange(4, 8); 
     * // =&gt; true 
     * 
     * _.inRange(4, 2); 
     * // =&gt; false 
     * 
     * _.inRange(2, 2); 
     * // =&gt; false 
     * 
     * _.inRange(1.2, 2); 
     * // =&gt; true 
     * 
     * _.inRange(5.2, 4); 
     * // =&gt; false 
     * 
     * _.inRange(-3, -2, -6); 
     * // =&gt; true 
     */</span>
    <span class="s2">function </span><span class="s1">inRange(number, start, end) {</span>
      <span class="s1">start = toFinite(start);</span>
      <span class="s2">if </span><span class="s1">(end === undefined) {</span>
        <span class="s1">end = start;</span>
        <span class="s1">start = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">end = toFinite(end);</span>
      <span class="s1">}</span>
      <span class="s1">number = toNumber(number);</span>
      <span class="s2">return </span><span class="s1">baseInRange(number, start, end);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Produces a random number between the inclusive `lower` and `upper` bounds. 
     * If only one argument is provided a number between `0` and the given number 
     * is returned. If `floating` is `true`, or either `lower` or `upper` are 
     * floats, a floating-point number is returned instead of an integer. 
     * 
     * **Note:** JavaScript follows the IEEE-754 standard for resolving 
     * floating-point values which can produce unexpected results. 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.7.0 
     * @category Number 
     * @param {number} [lower=0] The lower bound. 
     * @param {number} [upper=1] The upper bound. 
     * @param {boolean} [floating] Specify returning a floating-point number. 
     * @returns {number} Returns the random number. 
     * @example 
     * 
     * _.random(0, 5); 
     * // =&gt; an integer between 0 and 5 
     * 
     * _.random(5); 
     * // =&gt; also an integer between 0 and 5 
     * 
     * _.random(5, true); 
     * // =&gt; a floating-point number between 0 and 5 
     * 
     * _.random(1.2, 5.2); 
     * // =&gt; a floating-point number between 1.2 and 5.2 
     */</span>
    <span class="s2">function </span><span class="s1">random(lower, upper, floating) {</span>
      <span class="s2">if </span><span class="s1">(floating &amp;&amp; </span><span class="s2">typeof </span><span class="s1">floating != </span><span class="s3">'boolean' </span><span class="s1">&amp;&amp; isIterateeCall(lower, upper, floating)) {</span>
        <span class="s1">upper = floating = undefined;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(floating === undefined) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">upper == </span><span class="s3">'boolean'</span><span class="s1">) {</span>
          <span class="s1">floating = upper;</span>
          <span class="s1">upper = undefined;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">lower == </span><span class="s3">'boolean'</span><span class="s1">) {</span>
          <span class="s1">floating = lower;</span>
          <span class="s1">lower = undefined;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(lower === undefined &amp;&amp; upper === undefined) {</span>
        <span class="s1">lower = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">upper = </span><span class="s4">1</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">lower = toFinite(lower);</span>
        <span class="s2">if </span><span class="s1">(upper === undefined) {</span>
          <span class="s1">upper = lower;</span>
          <span class="s1">lower = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">upper = toFinite(upper);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(lower &gt; upper) {</span>
        <span class="s2">var </span><span class="s1">temp = lower;</span>
        <span class="s1">lower = upper;</span>
        <span class="s1">upper = temp;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(floating || lower % </span><span class="s4">1 </span><span class="s1">|| upper % </span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s2">var </span><span class="s1">rand = nativeRandom();</span>
        <span class="s2">return </span><span class="s1">nativeMin(lower + (rand * (upper - lower + freeParseFloat(</span><span class="s3">'1e-' </span><span class="s1">+ ((rand + </span><span class="s3">''</span><span class="s1">).length - </span><span class="s4">1</span><span class="s1">)))), upper);</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">baseRandom(lower, upper);</span>
    <span class="s1">}</span>

    <span class="s0">/*------------------------------------------------------------------------*/</span>

    <span class="s0">/** 
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase). 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.0.0 
     * @category String 
     * @param {string} [string=''] The string to convert. 
     * @returns {string} Returns the camel cased string. 
     * @example 
     * 
     * _.camelCase('Foo Bar'); 
     * // =&gt; 'fooBar' 
     * 
     * _.camelCase('--foo-bar--'); 
     * // =&gt; 'fooBar' 
     * 
     * _.camelCase('__FOO_BAR__'); 
     * // =&gt; 'fooBar' 
     */</span>
    <span class="s2">var </span><span class="s1">camelCase = createCompounder(</span><span class="s2">function</span><span class="s1">(result, word, index) {</span>
      <span class="s1">word = word.toLowerCase();</span>
      <span class="s2">return </span><span class="s1">result + (index ? capitalize(word) : word);</span>
    <span class="s1">});</span>

    <span class="s0">/** 
     * Converts the first character of `string` to upper case and the remaining 
     * to lower case. 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.0.0 
     * @category String 
     * @param {string} [string=''] The string to capitalize. 
     * @returns {string} Returns the capitalized string. 
     * @example 
     * 
     * _.capitalize('FRED'); 
     * // =&gt; 'Fred' 
     */</span>
    <span class="s2">function </span><span class="s1">capitalize(string) {</span>
      <span class="s2">return </span><span class="s1">upperFirst(toString(string).toLowerCase());</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Deburrs `string` by converting 
     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table) 
     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A) 
     * letters to basic Latin letters and removing 
     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks). 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.0.0 
     * @category String 
     * @param {string} [string=''] The string to deburr. 
     * @returns {string} Returns the deburred string. 
     * @example 
     * 
     * _.deburr('déjà vu'); 
     * // =&gt; 'deja vu' 
     */</span>
    <span class="s2">function </span><span class="s1">deburr(string) {</span>
      <span class="s1">string = toString(string);</span>
      <span class="s2">return </span><span class="s1">string &amp;&amp; string.replace(reLatin, deburrLetter).replace(reComboMark, </span><span class="s3">''</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Checks if `string` ends with the given target string. 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.0.0 
     * @category String 
     * @param {string} [string=''] The string to inspect. 
     * @param {string} [target] The string to search for. 
     * @param {number} [position=string.length] The position to search up to. 
     * @returns {boolean} Returns `true` if `string` ends with `target`, 
     *  else `false`. 
     * @example 
     * 
     * _.endsWith('abc', 'c'); 
     * // =&gt; true 
     * 
     * _.endsWith('abc', 'b'); 
     * // =&gt; false 
     * 
     * _.endsWith('abc', 'b', 2); 
     * // =&gt; true 
     */</span>
    <span class="s2">function </span><span class="s1">endsWith(string, target, position) {</span>
      <span class="s1">string = toString(string);</span>
      <span class="s1">target = baseToString(target);</span>

      <span class="s2">var </span><span class="s1">length = string.length;</span>
      <span class="s1">position = position === undefined</span>
        <span class="s1">? length</span>
        <span class="s1">: baseClamp(toInteger(position), </span><span class="s4">0</span><span class="s1">, length);</span>

      <span class="s2">var </span><span class="s1">end = position;</span>
      <span class="s1">position -= target.length;</span>
      <span class="s2">return </span><span class="s1">position &gt;= </span><span class="s4">0 </span><span class="s1">&amp;&amp; string.slice(position, end) == target;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Converts the characters &quot;&amp;&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;, '&quot;', and &quot;'&quot; in `string` to their 
     * corresponding HTML entities. 
     * 
     * **Note:** No other characters are escaped. To escape additional 
     * characters use a third-party library like [_he_](https://mths.be/he). 
     * 
     * Though the &quot;&gt;&quot; character is escaped for symmetry, characters like 
     * &quot;&gt;&quot; and &quot;/&quot; don't need escaping in HTML and have no special meaning 
     * unless they're part of a tag or unquoted attribute value. See 
     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands) 
     * (under &quot;semi-related fun fact&quot;) for more details. 
     * 
     * When working with HTML you should always 
     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce 
     * XSS vectors. 
     * 
     * @static 
     * @since 0.1.0 
     * @memberOf _ 
     * @category String 
     * @param {string} [string=''] The string to escape. 
     * @returns {string} Returns the escaped string. 
     * @example 
     * 
     * _.escape('fred, barney, &amp; pebbles'); 
     * // =&gt; 'fred, barney, &amp;amp; pebbles' 
     */</span>
    <span class="s2">function </span><span class="s1">escape(string) {</span>
      <span class="s1">string = toString(string);</span>
      <span class="s2">return </span><span class="s1">(string &amp;&amp; reHasUnescapedHtml.test(string))</span>
        <span class="s1">? string.replace(reUnescapedHtml, escapeHtmlChar)</span>
        <span class="s1">: string;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Escapes the `RegExp` special characters &quot;^&quot;, &quot;$&quot;, &quot;\&quot;, &quot;.&quot;, &quot;*&quot;, &quot;+&quot;, 
     * &quot;?&quot;, &quot;(&quot;, &quot;)&quot;, &quot;[&quot;, &quot;]&quot;, &quot;{&quot;, &quot;}&quot;, and &quot;|&quot; in `string`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.0.0 
     * @category String 
     * @param {string} [string=''] The string to escape. 
     * @returns {string} Returns the escaped string. 
     * @example 
     * 
     * _.escapeRegExp('[lodash](https://lodash.com/)'); 
     * // =&gt; '\[lodash\]\(https://lodash\.com/\)' 
     */</span>
    <span class="s2">function </span><span class="s1">escapeRegExp(string) {</span>
      <span class="s1">string = toString(string);</span>
      <span class="s2">return </span><span class="s1">(string &amp;&amp; reHasRegExpChar.test(string))</span>
        <span class="s1">? string.replace(reRegExpChar, </span><span class="s3">'</span><span class="s5">\\</span><span class="s3">$&amp;'</span><span class="s1">)</span>
        <span class="s1">: string;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Converts `string` to 
     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles). 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.0.0 
     * @category String 
     * @param {string} [string=''] The string to convert. 
     * @returns {string} Returns the kebab cased string. 
     * @example 
     * 
     * _.kebabCase('Foo Bar'); 
     * // =&gt; 'foo-bar' 
     * 
     * _.kebabCase('fooBar'); 
     * // =&gt; 'foo-bar' 
     * 
     * _.kebabCase('__FOO_BAR__'); 
     * // =&gt; 'foo-bar' 
     */</span>
    <span class="s2">var </span><span class="s1">kebabCase = createCompounder(</span><span class="s2">function</span><span class="s1">(result, word, index) {</span>
      <span class="s2">return </span><span class="s1">result + (index ? </span><span class="s3">'-' </span><span class="s1">: </span><span class="s3">''</span><span class="s1">) + word.toLowerCase();</span>
    <span class="s1">});</span>

    <span class="s0">/** 
     * Converts `string`, as space separated words, to lower case. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category String 
     * @param {string} [string=''] The string to convert. 
     * @returns {string} Returns the lower cased string. 
     * @example 
     * 
     * _.lowerCase('--Foo-Bar--'); 
     * // =&gt; 'foo bar' 
     * 
     * _.lowerCase('fooBar'); 
     * // =&gt; 'foo bar' 
     * 
     * _.lowerCase('__FOO_BAR__'); 
     * // =&gt; 'foo bar' 
     */</span>
    <span class="s2">var </span><span class="s1">lowerCase = createCompounder(</span><span class="s2">function</span><span class="s1">(result, word, index) {</span>
      <span class="s2">return </span><span class="s1">result + (index ? </span><span class="s3">' ' </span><span class="s1">: </span><span class="s3">''</span><span class="s1">) + word.toLowerCase();</span>
    <span class="s1">});</span>

    <span class="s0">/** 
     * Converts the first character of `string` to lower case. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category String 
     * @param {string} [string=''] The string to convert. 
     * @returns {string} Returns the converted string. 
     * @example 
     * 
     * _.lowerFirst('Fred'); 
     * // =&gt; 'fred' 
     * 
     * _.lowerFirst('FRED'); 
     * // =&gt; 'fRED' 
     */</span>
    <span class="s2">var </span><span class="s1">lowerFirst = createCaseFirst(</span><span class="s3">'toLowerCase'</span><span class="s1">);</span>

    <span class="s0">/** 
     * Pads `string` on the left and right sides if it's shorter than `length`. 
     * Padding characters are truncated if they can't be evenly divided by `length`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.0.0 
     * @category String 
     * @param {string} [string=''] The string to pad. 
     * @param {number} [length=0] The padding length. 
     * @param {string} [chars=' '] The string used as padding. 
     * @returns {string} Returns the padded string. 
     * @example 
     * 
     * _.pad('abc', 8); 
     * // =&gt; '  abc   ' 
     * 
     * _.pad('abc', 8, '_-'); 
     * // =&gt; '_-abc_-_' 
     * 
     * _.pad('abc', 3); 
     * // =&gt; 'abc' 
     */</span>
    <span class="s2">function </span><span class="s1">pad(string, length, chars) {</span>
      <span class="s1">string = toString(string);</span>
      <span class="s1">length = toInteger(length);</span>

      <span class="s2">var </span><span class="s1">strLength = length ? stringSize(string) : </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s2">if </span><span class="s1">(!length || strLength &gt;= length) {</span>
        <span class="s2">return </span><span class="s1">string;</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">mid = (length - strLength) / </span><span class="s4">2</span><span class="s1">;</span>
      <span class="s2">return </span><span class="s1">(</span>
        <span class="s1">createPadding(nativeFloor(mid), chars) +</span>
        <span class="s1">string +</span>
        <span class="s1">createPadding(nativeCeil(mid), chars)</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Pads `string` on the right side if it's shorter than `length`. Padding 
     * characters are truncated if they exceed `length`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category String 
     * @param {string} [string=''] The string to pad. 
     * @param {number} [length=0] The padding length. 
     * @param {string} [chars=' '] The string used as padding. 
     * @returns {string} Returns the padded string. 
     * @example 
     * 
     * _.padEnd('abc', 6); 
     * // =&gt; 'abc   ' 
     * 
     * _.padEnd('abc', 6, '_-'); 
     * // =&gt; 'abc_-_' 
     * 
     * _.padEnd('abc', 3); 
     * // =&gt; 'abc' 
     */</span>
    <span class="s2">function </span><span class="s1">padEnd(string, length, chars) {</span>
      <span class="s1">string = toString(string);</span>
      <span class="s1">length = toInteger(length);</span>

      <span class="s2">var </span><span class="s1">strLength = length ? stringSize(string) : </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s2">return </span><span class="s1">(length &amp;&amp; strLength &lt; length)</span>
        <span class="s1">? (string + createPadding(length - strLength, chars))</span>
        <span class="s1">: string;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Pads `string` on the left side if it's shorter than `length`. Padding 
     * characters are truncated if they exceed `length`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category String 
     * @param {string} [string=''] The string to pad. 
     * @param {number} [length=0] The padding length. 
     * @param {string} [chars=' '] The string used as padding. 
     * @returns {string} Returns the padded string. 
     * @example 
     * 
     * _.padStart('abc', 6); 
     * // =&gt; '   abc' 
     * 
     * _.padStart('abc', 6, '_-'); 
     * // =&gt; '_-_abc' 
     * 
     * _.padStart('abc', 3); 
     * // =&gt; 'abc' 
     */</span>
    <span class="s2">function </span><span class="s1">padStart(string, length, chars) {</span>
      <span class="s1">string = toString(string);</span>
      <span class="s1">length = toInteger(length);</span>

      <span class="s2">var </span><span class="s1">strLength = length ? stringSize(string) : </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s2">return </span><span class="s1">(length &amp;&amp; strLength &lt; length)</span>
        <span class="s1">? (createPadding(length - strLength, chars) + string)</span>
        <span class="s1">: string;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Converts `string` to an integer of the specified radix. If `radix` is 
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a 
     * hexadecimal, in which case a `radix` of `16` is used. 
     * 
     * **Note:** This method aligns with the 
     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 1.1.0 
     * @category String 
     * @param {string} string The string to convert. 
     * @param {number} [radix=10] The radix to interpret `value` by. 
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`. 
     * @returns {number} Returns the converted integer. 
     * @example 
     * 
     * _.parseInt('08'); 
     * // =&gt; 8 
     * 
     * _.map(['6', '08', '10'], _.parseInt); 
     * // =&gt; [6, 8, 10] 
     */</span>
    <span class="s2">function </span><span class="s1">parseInt(string, radix, guard) {</span>
      <span class="s2">if </span><span class="s1">(guard || radix == </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">radix = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(radix) {</span>
        <span class="s1">radix = +radix;</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">nativeParseInt(toString(string).replace(reTrimStart, </span><span class="s3">''</span><span class="s1">), radix || </span><span class="s4">0</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Repeats the given string `n` times. 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.0.0 
     * @category String 
     * @param {string} [string=''] The string to repeat. 
     * @param {number} [n=1] The number of times to repeat the string. 
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`. 
     * @returns {string} Returns the repeated string. 
     * @example 
     * 
     * _.repeat('*', 3); 
     * // =&gt; '***' 
     * 
     * _.repeat('abc', 2); 
     * // =&gt; 'abcabc' 
     * 
     * _.repeat('abc', 0); 
     * // =&gt; '' 
     */</span>
    <span class="s2">function </span><span class="s1">repeat(string, n, guard) {</span>
      <span class="s2">if </span><span class="s1">((guard ? isIterateeCall(string, n, guard) : n === undefined)) {</span>
        <span class="s1">n = </span><span class="s4">1</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">n = toInteger(n);</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">baseRepeat(toString(string), n);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Replaces matches for `pattern` in `string` with `replacement`. 
     * 
     * **Note:** This method is based on 
     * [`String#replace`](https://mdn.io/String/replace). 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category String 
     * @param {string} [string=''] The string to modify. 
     * @param {RegExp|string} pattern The pattern to replace. 
     * @param {Function|string} replacement The match replacement. 
     * @returns {string} Returns the modified string. 
     * @example 
     * 
     * _.replace('Hi Fred', 'Fred', 'Barney'); 
     * // =&gt; 'Hi Barney' 
     */</span>
    <span class="s2">function </span><span class="s1">replace() {</span>
      <span class="s2">var </span><span class="s1">args = arguments,</span>
          <span class="s1">string = toString(args[</span><span class="s4">0</span><span class="s1">]);</span>

      <span class="s2">return </span><span class="s1">args.length &lt; </span><span class="s4">3 </span><span class="s1">? string : string.replace(args[</span><span class="s4">1</span><span class="s1">], args[</span><span class="s4">2</span><span class="s1">]);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Converts `string` to 
     * [snake case](https://en.wikipedia.org/wiki/Snake_case). 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.0.0 
     * @category String 
     * @param {string} [string=''] The string to convert. 
     * @returns {string} Returns the snake cased string. 
     * @example 
     * 
     * _.snakeCase('Foo Bar'); 
     * // =&gt; 'foo_bar' 
     * 
     * _.snakeCase('fooBar'); 
     * // =&gt; 'foo_bar' 
     * 
     * _.snakeCase('--FOO-BAR--'); 
     * // =&gt; 'foo_bar' 
     */</span>
    <span class="s2">var </span><span class="s1">snakeCase = createCompounder(</span><span class="s2">function</span><span class="s1">(result, word, index) {</span>
      <span class="s2">return </span><span class="s1">result + (index ? </span><span class="s3">'_' </span><span class="s1">: </span><span class="s3">''</span><span class="s1">) + word.toLowerCase();</span>
    <span class="s1">});</span>

    <span class="s0">/** 
     * Splits `string` by `separator`. 
     * 
     * **Note:** This method is based on 
     * [`String#split`](https://mdn.io/String/split). 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category String 
     * @param {string} [string=''] The string to split. 
     * @param {RegExp|string} separator The separator pattern to split by. 
     * @param {number} [limit] The length to truncate results to. 
     * @returns {Array} Returns the string segments. 
     * @example 
     * 
     * _.split('a-b-c', '-', 2); 
     * // =&gt; ['a', 'b'] 
     */</span>
    <span class="s2">function </span><span class="s1">split(string, separator, limit) {</span>
      <span class="s2">if </span><span class="s1">(limit &amp;&amp; </span><span class="s2">typeof </span><span class="s1">limit != </span><span class="s3">'number' </span><span class="s1">&amp;&amp; isIterateeCall(string, separator, limit)) {</span>
        <span class="s1">separator = limit = undefined;</span>
      <span class="s1">}</span>
      <span class="s1">limit = limit === undefined ? MAX_ARRAY_LENGTH : limit &gt;&gt;&gt; </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s2">if </span><span class="s1">(!limit) {</span>
        <span class="s2">return </span><span class="s1">[];</span>
      <span class="s1">}</span>
      <span class="s1">string = toString(string);</span>
      <span class="s2">if </span><span class="s1">(string &amp;&amp; (</span>
            <span class="s2">typeof </span><span class="s1">separator == </span><span class="s3">'string' </span><span class="s1">||</span>
            <span class="s1">(separator != </span><span class="s2">null </span><span class="s1">&amp;&amp; !isRegExp(separator))</span>
          <span class="s1">)) {</span>
        <span class="s1">separator = baseToString(separator);</span>
        <span class="s2">if </span><span class="s1">(!separator &amp;&amp; hasUnicode(string)) {</span>
          <span class="s2">return </span><span class="s1">castSlice(stringToArray(string), </span><span class="s4">0</span><span class="s1">, limit);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">string.split(separator, limit);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Converts `string` to 
     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage). 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.1.0 
     * @category String 
     * @param {string} [string=''] The string to convert. 
     * @returns {string} Returns the start cased string. 
     * @example 
     * 
     * _.startCase('--foo-bar--'); 
     * // =&gt; 'Foo Bar' 
     * 
     * _.startCase('fooBar'); 
     * // =&gt; 'Foo Bar' 
     * 
     * _.startCase('__FOO_BAR__'); 
     * // =&gt; 'FOO BAR' 
     */</span>
    <span class="s2">var </span><span class="s1">startCase = createCompounder(</span><span class="s2">function</span><span class="s1">(result, word, index) {</span>
      <span class="s2">return </span><span class="s1">result + (index ? </span><span class="s3">' ' </span><span class="s1">: </span><span class="s3">''</span><span class="s1">) + upperFirst(word);</span>
    <span class="s1">});</span>

    <span class="s0">/** 
     * Checks if `string` starts with the given target string. 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.0.0 
     * @category String 
     * @param {string} [string=''] The string to inspect. 
     * @param {string} [target] The string to search for. 
     * @param {number} [position=0] The position to search from. 
     * @returns {boolean} Returns `true` if `string` starts with `target`, 
     *  else `false`. 
     * @example 
     * 
     * _.startsWith('abc', 'a'); 
     * // =&gt; true 
     * 
     * _.startsWith('abc', 'b'); 
     * // =&gt; false 
     * 
     * _.startsWith('abc', 'b', 1); 
     * // =&gt; true 
     */</span>
    <span class="s2">function </span><span class="s1">startsWith(string, target, position) {</span>
      <span class="s1">string = toString(string);</span>
      <span class="s1">position = position == </span><span class="s2">null</span>
        <span class="s1">? </span><span class="s4">0</span>
        <span class="s1">: baseClamp(toInteger(position), </span><span class="s4">0</span><span class="s1">, string.length);</span>

      <span class="s1">target = baseToString(target);</span>
      <span class="s2">return </span><span class="s1">string.slice(position, position + target.length) == target;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a compiled template function that can interpolate data properties 
     * in &quot;interpolate&quot; delimiters, HTML-escape interpolated data properties in 
     * &quot;escape&quot; delimiters, and execute JavaScript in &quot;evaluate&quot; delimiters. Data 
     * properties may be accessed as free variables in the template. If a setting 
     * object is given, it takes precedence over `_.templateSettings` values. 
     * 
     * **Note:** In the development build `_.template` utilizes 
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl) 
     * for easier debugging. 
     * 
     * For more information on precompiling templates see 
     * [lodash's custom builds documentation](https://lodash.com/custom-builds). 
     * 
     * For more information on Chrome extension sandboxes see 
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval). 
     * 
     * @static 
     * @since 0.1.0 
     * @memberOf _ 
     * @category String 
     * @param {string} [string=''] The template string. 
     * @param {Object} [options={}] The options object. 
     * @param {RegExp} [options.escape=_.templateSettings.escape] 
     *  The HTML &quot;escape&quot; delimiter. 
     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate] 
     *  The &quot;evaluate&quot; delimiter. 
     * @param {Object} [options.imports=_.templateSettings.imports] 
     *  An object to import into the template as free variables. 
     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate] 
     *  The &quot;interpolate&quot; delimiter. 
     * @param {string} [options.sourceURL='lodash.templateSources[n]'] 
     *  The sourceURL of the compiled template. 
     * @param {string} [options.variable='obj'] 
     *  The data object variable name. 
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`. 
     * @returns {Function} Returns the compiled template function. 
     * @example 
     * 
     * // Use the &quot;interpolate&quot; delimiter to create a compiled template. 
     * var compiled = _.template('hello &lt;%= user %&gt;!'); 
     * compiled({ 'user': 'fred' }); 
     * // =&gt; 'hello fred!' 
     * 
     * // Use the HTML &quot;escape&quot; delimiter to escape data property values. 
     * var compiled = _.template('&lt;b&gt;&lt;%- value %&gt;&lt;/b&gt;'); 
     * compiled({ 'value': '&lt;script&gt;' }); 
     * // =&gt; '&lt;b&gt;&amp;lt;script&amp;gt;&lt;/b&gt;' 
     * 
     * // Use the &quot;evaluate&quot; delimiter to execute JavaScript and generate HTML. 
     * var compiled = _.template('&lt;% _.forEach(users, function(user) { %&gt;&lt;li&gt;&lt;%- user %&gt;&lt;/li&gt;&lt;% }); %&gt;'); 
     * compiled({ 'users': ['fred', 'barney'] }); 
     * // =&gt; '&lt;li&gt;fred&lt;/li&gt;&lt;li&gt;barney&lt;/li&gt;' 
     * 
     * // Use the internal `print` function in &quot;evaluate&quot; delimiters. 
     * var compiled = _.template('&lt;% print(&quot;hello &quot; + user); %&gt;!'); 
     * compiled({ 'user': 'barney' }); 
     * // =&gt; 'hello barney!' 
     * 
     * // Use the ES template literal delimiter as an &quot;interpolate&quot; delimiter. 
     * // Disable support by replacing the &quot;interpolate&quot; delimiter. 
     * var compiled = _.template('hello ${ user }!'); 
     * compiled({ 'user': 'pebbles' }); 
     * // =&gt; 'hello pebbles!' 
     * 
     * // Use backslashes to treat delimiters as plain text. 
     * var compiled = _.template('&lt;%= &quot;\\&lt;%- value %\\&gt;&quot; %&gt;'); 
     * compiled({ 'value': 'ignored' }); 
     * // =&gt; '&lt;%- value %&gt;' 
     * 
     * // Use the `imports` option to import `jQuery` as `jq`. 
     * var text = '&lt;% jq.each(users, function(user) { %&gt;&lt;li&gt;&lt;%- user %&gt;&lt;/li&gt;&lt;% }); %&gt;'; 
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } }); 
     * compiled({ 'users': ['fred', 'barney'] }); 
     * // =&gt; '&lt;li&gt;fred&lt;/li&gt;&lt;li&gt;barney&lt;/li&gt;' 
     * 
     * // Use the `sourceURL` option to specify a custom sourceURL for the template. 
     * var compiled = _.template('hello &lt;%= user %&gt;!', { 'sourceURL': '/basic/greeting.jst' }); 
     * compiled(data); 
     * // =&gt; Find the source of &quot;greeting.jst&quot; under the Sources tab or Resources panel of the web inspector. 
     * 
     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template. 
     * var compiled = _.template('hi &lt;%= data.user %&gt;!', { 'variable': 'data' }); 
     * compiled.source; 
     * // =&gt; function(data) { 
     * //   var __t, __p = ''; 
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!'; 
     * //   return __p; 
     * // } 
     * 
     * // Use custom template delimiters. 
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g; 
     * var compiled = _.template('hello {{ user }}!'); 
     * compiled({ 'user': 'mustache' }); 
     * // =&gt; 'hello mustache!' 
     * 
     * // Use the `source` property to inline compiled templates for meaningful 
     * // line numbers in error messages and stack traces. 
     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\ 
     *   var JST = {\ 
     *     &quot;main&quot;: ' + _.template(mainText).source + '\ 
     *   };\ 
     * '); 
     */</span>
    <span class="s2">function </span><span class="s1">template(string, options, guard) {</span>
      <span class="s0">// Based on John Resig's `tmpl` implementation</span>
      <span class="s0">// (http://ejohn.org/blog/javascript-micro-templating/)</span>
      <span class="s0">// and Laura Doktorova's doT.js (https://github.com/olado/doT).</span>
      <span class="s2">var </span><span class="s1">settings = lodash.templateSettings;</span>

      <span class="s2">if </span><span class="s1">(guard &amp;&amp; isIterateeCall(string, options, guard)) {</span>
        <span class="s1">options = undefined;</span>
      <span class="s1">}</span>
      <span class="s1">string = toString(string);</span>
      <span class="s1">options = assignInWith({}, options, settings, customDefaultsAssignIn);</span>

      <span class="s2">var </span><span class="s1">imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),</span>
          <span class="s1">importsKeys = keys(imports),</span>
          <span class="s1">importsValues = baseValues(imports, importsKeys);</span>

      <span class="s2">var </span><span class="s1">isEscaping,</span>
          <span class="s1">isEvaluating,</span>
          <span class="s1">index = </span><span class="s4">0</span><span class="s1">,</span>
          <span class="s1">interpolate = options.interpolate || reNoMatch,</span>
          <span class="s1">source = </span><span class="s3">&quot;__p += '&quot;</span><span class="s1">;</span>

      <span class="s0">// Compile the regexp to match each delimiter.</span>
      <span class="s2">var </span><span class="s1">reDelimiters = RegExp(</span>
        <span class="s1">(options.escape || reNoMatch).source + </span><span class="s3">'|' </span><span class="s1">+</span>
        <span class="s1">interpolate.source + </span><span class="s3">'|' </span><span class="s1">+</span>
        <span class="s1">(interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + </span><span class="s3">'|' </span><span class="s1">+</span>
        <span class="s1">(options.evaluate || reNoMatch).source + </span><span class="s3">'|$'</span>
      <span class="s1">, </span><span class="s3">'g'</span><span class="s1">);</span>

      <span class="s0">// Use a sourceURL for easier debugging.</span>
      <span class="s0">// The sourceURL gets injected into the source that's eval-ed, so be careful</span>
      <span class="s0">// to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in</span>
      <span class="s0">// and escape the comment, thus injecting code that gets evaled.</span>
      <span class="s2">var </span><span class="s1">sourceURL = </span><span class="s3">'//# sourceURL=' </span><span class="s1">+</span>
        <span class="s1">(hasOwnProperty.call(options, </span><span class="s3">'sourceURL'</span><span class="s1">)</span>
          <span class="s1">? (options.sourceURL + </span><span class="s3">''</span><span class="s1">).replace(/\s/g, </span><span class="s3">' '</span><span class="s1">)</span>
          <span class="s1">: (</span><span class="s3">'lodash.templateSources[' </span><span class="s1">+ (++templateCounter) + </span><span class="s3">']'</span><span class="s1">)</span>
        <span class="s1">) + </span><span class="s3">'</span><span class="s5">\n</span><span class="s3">'</span><span class="s1">;</span>

      <span class="s1">string.replace(reDelimiters, </span><span class="s2">function</span><span class="s1">(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {</span>
        <span class="s1">interpolateValue || (interpolateValue = esTemplateValue);</span>

        <span class="s0">// Escape characters that can't be included in string literals.</span>
        <span class="s1">source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);</span>

        <span class="s0">// Replace delimiters with snippets.</span>
        <span class="s2">if </span><span class="s1">(escapeValue) {</span>
          <span class="s1">isEscaping = </span><span class="s2">true</span><span class="s1">;</span>
          <span class="s1">source += </span><span class="s3">&quot;' +</span><span class="s5">\n</span><span class="s3">__e(&quot; </span><span class="s1">+ escapeValue + </span><span class="s3">&quot;) +</span><span class="s5">\n</span><span class="s3">'&quot;</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(evaluateValue) {</span>
          <span class="s1">isEvaluating = </span><span class="s2">true</span><span class="s1">;</span>
          <span class="s1">source += </span><span class="s3">&quot;';</span><span class="s5">\n</span><span class="s3">&quot; </span><span class="s1">+ evaluateValue + </span><span class="s3">&quot;;</span><span class="s5">\n</span><span class="s3">__p += '&quot;</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(interpolateValue) {</span>
          <span class="s1">source += </span><span class="s3">&quot;' +</span><span class="s5">\n</span><span class="s3">((__t = (&quot; </span><span class="s1">+ interpolateValue + </span><span class="s3">&quot;)) == null ? '' : __t) +</span><span class="s5">\n</span><span class="s3">'&quot;</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">index = offset + match.length;</span>

        <span class="s0">// The JS engine embedded in Adobe products needs `match` returned in</span>
        <span class="s0">// order to produce the correct `offset` value.</span>
        <span class="s2">return </span><span class="s1">match;</span>
      <span class="s1">});</span>

      <span class="s1">source += </span><span class="s3">&quot;';</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s1">;</span>

      <span class="s0">// If `variable` is not specified wrap a with-statement around the generated</span>
      <span class="s0">// code to add the data object to the top of the scope chain.</span>
      <span class="s2">var </span><span class="s1">variable = hasOwnProperty.call(options, </span><span class="s3">'variable'</span><span class="s1">) &amp;&amp; options.variable;</span>
      <span class="s2">if </span><span class="s1">(!variable) {</span>
        <span class="s1">source = </span><span class="s3">'with (obj) {</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">+ source + </span><span class="s3">'</span><span class="s5">\n</span><span class="s3">}</span><span class="s5">\n</span><span class="s3">'</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s0">// Throw an error if a forbidden character was found in `variable`, to prevent</span>
      <span class="s0">// potential command injection attacks.</span>
      <span class="s2">else if </span><span class="s1">(reForbiddenIdentifierChars.test(variable)) {</span>
        <span class="s2">throw new </span><span class="s1">Error(INVALID_TEMPL_VAR_ERROR_TEXT);</span>
      <span class="s1">}</span>

      <span class="s0">// Cleanup code by stripping empty strings.</span>
      <span class="s1">source = (isEvaluating ? source.replace(reEmptyStringLeading, </span><span class="s3">''</span><span class="s1">) : source)</span>
        <span class="s1">.replace(reEmptyStringMiddle, </span><span class="s3">'$1'</span><span class="s1">)</span>
        <span class="s1">.replace(reEmptyStringTrailing, </span><span class="s3">'$1;'</span><span class="s1">);</span>

      <span class="s0">// Frame code as the function body.</span>
      <span class="s1">source = </span><span class="s3">'function(' </span><span class="s1">+ (variable || </span><span class="s3">'obj'</span><span class="s1">) + </span><span class="s3">') {</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">+</span>
        <span class="s1">(variable</span>
          <span class="s1">? </span><span class="s3">''</span>
          <span class="s1">: </span><span class="s3">'obj || (obj = {});</span><span class="s5">\n</span><span class="s3">'</span>
        <span class="s1">) +</span>
        <span class="s3">&quot;var __t, __p = ''&quot; </span><span class="s1">+</span>
        <span class="s1">(isEscaping</span>
           <span class="s1">? </span><span class="s3">', __e = _.escape'</span>
           <span class="s1">: </span><span class="s3">''</span>
        <span class="s1">) +</span>
        <span class="s1">(isEvaluating</span>
          <span class="s1">? </span><span class="s3">', __j = Array.prototype.join;</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">+</span>
            <span class="s3">&quot;function print() { __p += __j.call(arguments, '') }</span><span class="s5">\n</span><span class="s3">&quot;</span>
          <span class="s1">: </span><span class="s3">';</span><span class="s5">\n</span><span class="s3">'</span>
        <span class="s1">) +</span>
        <span class="s1">source +</span>
        <span class="s3">'return __p</span><span class="s5">\n</span><span class="s3">}'</span><span class="s1">;</span>

      <span class="s2">var </span><span class="s1">result = attempt(</span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">Function(importsKeys, sourceURL + </span><span class="s3">'return ' </span><span class="s1">+ source)</span>
          <span class="s1">.apply(undefined, importsValues);</span>
      <span class="s1">});</span>

      <span class="s0">// Provide the compiled function's source by its `toString` method or</span>
      <span class="s0">// the `source` property as a convenience for inlining compiled templates.</span>
      <span class="s1">result.source = source;</span>
      <span class="s2">if </span><span class="s1">(isError(result)) {</span>
        <span class="s2">throw </span><span class="s1">result;</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Converts `string`, as a whole, to lower case just like 
     * [String#toLowerCase](https://mdn.io/toLowerCase). 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category String 
     * @param {string} [string=''] The string to convert. 
     * @returns {string} Returns the lower cased string. 
     * @example 
     * 
     * _.toLower('--Foo-Bar--'); 
     * // =&gt; '--foo-bar--' 
     * 
     * _.toLower('fooBar'); 
     * // =&gt; 'foobar' 
     * 
     * _.toLower('__FOO_BAR__'); 
     * // =&gt; '__foo_bar__' 
     */</span>
    <span class="s2">function </span><span class="s1">toLower(value) {</span>
      <span class="s2">return </span><span class="s1">toString(value).toLowerCase();</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Converts `string`, as a whole, to upper case just like 
     * [String#toUpperCase](https://mdn.io/toUpperCase). 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category String 
     * @param {string} [string=''] The string to convert. 
     * @returns {string} Returns the upper cased string. 
     * @example 
     * 
     * _.toUpper('--foo-bar--'); 
     * // =&gt; '--FOO-BAR--' 
     * 
     * _.toUpper('fooBar'); 
     * // =&gt; 'FOOBAR' 
     * 
     * _.toUpper('__foo_bar__'); 
     * // =&gt; '__FOO_BAR__' 
     */</span>
    <span class="s2">function </span><span class="s1">toUpper(value) {</span>
      <span class="s2">return </span><span class="s1">toString(value).toUpperCase();</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Removes leading and trailing whitespace or specified characters from `string`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.0.0 
     * @category String 
     * @param {string} [string=''] The string to trim. 
     * @param {string} [chars=whitespace] The characters to trim. 
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`. 
     * @returns {string} Returns the trimmed string. 
     * @example 
     * 
     * _.trim('  abc  '); 
     * // =&gt; 'abc' 
     * 
     * _.trim('-_-abc-_-', '_-'); 
     * // =&gt; 'abc' 
     * 
     * _.map(['  foo  ', '  bar  '], _.trim); 
     * // =&gt; ['foo', 'bar'] 
     */</span>
    <span class="s2">function </span><span class="s1">trim(string, chars, guard) {</span>
      <span class="s1">string = toString(string);</span>
      <span class="s2">if </span><span class="s1">(string &amp;&amp; (guard || chars === undefined)) {</span>
        <span class="s2">return </span><span class="s1">baseTrim(string);</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(!string || !(chars = baseToString(chars))) {</span>
        <span class="s2">return </span><span class="s1">string;</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">strSymbols = stringToArray(string),</span>
          <span class="s1">chrSymbols = stringToArray(chars),</span>
          <span class="s1">start = charsStartIndex(strSymbols, chrSymbols),</span>
          <span class="s1">end = charsEndIndex(strSymbols, chrSymbols) + </span><span class="s4">1</span><span class="s1">;</span>

      <span class="s2">return </span><span class="s1">castSlice(strSymbols, start, end).join(</span><span class="s3">''</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Removes trailing whitespace or specified characters from `string`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category String 
     * @param {string} [string=''] The string to trim. 
     * @param {string} [chars=whitespace] The characters to trim. 
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`. 
     * @returns {string} Returns the trimmed string. 
     * @example 
     * 
     * _.trimEnd('  abc  '); 
     * // =&gt; '  abc' 
     * 
     * _.trimEnd('-_-abc-_-', '_-'); 
     * // =&gt; '-_-abc' 
     */</span>
    <span class="s2">function </span><span class="s1">trimEnd(string, chars, guard) {</span>
      <span class="s1">string = toString(string);</span>
      <span class="s2">if </span><span class="s1">(string &amp;&amp; (guard || chars === undefined)) {</span>
        <span class="s2">return </span><span class="s1">string.slice(</span><span class="s4">0</span><span class="s1">, trimmedEndIndex(string) + </span><span class="s4">1</span><span class="s1">);</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(!string || !(chars = baseToString(chars))) {</span>
        <span class="s2">return </span><span class="s1">string;</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">strSymbols = stringToArray(string),</span>
          <span class="s1">end = charsEndIndex(strSymbols, stringToArray(chars)) + </span><span class="s4">1</span><span class="s1">;</span>

      <span class="s2">return </span><span class="s1">castSlice(strSymbols, </span><span class="s4">0</span><span class="s1">, end).join(</span><span class="s3">''</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Removes leading whitespace or specified characters from `string`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category String 
     * @param {string} [string=''] The string to trim. 
     * @param {string} [chars=whitespace] The characters to trim. 
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`. 
     * @returns {string} Returns the trimmed string. 
     * @example 
     * 
     * _.trimStart('  abc  '); 
     * // =&gt; 'abc  ' 
     * 
     * _.trimStart('-_-abc-_-', '_-'); 
     * // =&gt; 'abc-_-' 
     */</span>
    <span class="s2">function </span><span class="s1">trimStart(string, chars, guard) {</span>
      <span class="s1">string = toString(string);</span>
      <span class="s2">if </span><span class="s1">(string &amp;&amp; (guard || chars === undefined)) {</span>
        <span class="s2">return </span><span class="s1">string.replace(reTrimStart, </span><span class="s3">''</span><span class="s1">);</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(!string || !(chars = baseToString(chars))) {</span>
        <span class="s2">return </span><span class="s1">string;</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">strSymbols = stringToArray(string),</span>
          <span class="s1">start = charsStartIndex(strSymbols, stringToArray(chars));</span>

      <span class="s2">return </span><span class="s1">castSlice(strSymbols, start).join(</span><span class="s3">''</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Truncates `string` if it's longer than the given maximum string length. 
     * The last characters of the truncated string are replaced with the omission 
     * string which defaults to &quot;...&quot;. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category String 
     * @param {string} [string=''] The string to truncate. 
     * @param {Object} [options={}] The options object. 
     * @param {number} [options.length=30] The maximum string length. 
     * @param {string} [options.omission='...'] The string to indicate text is omitted. 
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to. 
     * @returns {string} Returns the truncated string. 
     * @example 
     * 
     * _.truncate('hi-diddly-ho there, neighborino'); 
     * // =&gt; 'hi-diddly-ho there, neighbo...' 
     * 
     * _.truncate('hi-diddly-ho there, neighborino', { 
     *   'length': 24, 
     *   'separator': ' ' 
     * }); 
     * // =&gt; 'hi-diddly-ho there,...' 
     * 
     * _.truncate('hi-diddly-ho there, neighborino', { 
     *   'length': 24, 
     *   'separator': /,? +/ 
     * }); 
     * // =&gt; 'hi-diddly-ho there...' 
     * 
     * _.truncate('hi-diddly-ho there, neighborino', { 
     *   'omission': ' [...]' 
     * }); 
     * // =&gt; 'hi-diddly-ho there, neig [...]' 
     */</span>
    <span class="s2">function </span><span class="s1">truncate(string, options) {</span>
      <span class="s2">var </span><span class="s1">length = DEFAULT_TRUNC_LENGTH,</span>
          <span class="s1">omission = DEFAULT_TRUNC_OMISSION;</span>

      <span class="s2">if </span><span class="s1">(isObject(options)) {</span>
        <span class="s2">var </span><span class="s1">separator = </span><span class="s3">'separator' </span><span class="s2">in </span><span class="s1">options ? options.separator : separator;</span>
        <span class="s1">length = </span><span class="s3">'length' </span><span class="s2">in </span><span class="s1">options ? toInteger(options.length) : length;</span>
        <span class="s1">omission = </span><span class="s3">'omission' </span><span class="s2">in </span><span class="s1">options ? baseToString(options.omission) : omission;</span>
      <span class="s1">}</span>
      <span class="s1">string = toString(string);</span>

      <span class="s2">var </span><span class="s1">strLength = string.length;</span>
      <span class="s2">if </span><span class="s1">(hasUnicode(string)) {</span>
        <span class="s2">var </span><span class="s1">strSymbols = stringToArray(string);</span>
        <span class="s1">strLength = strSymbols.length;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(length &gt;= strLength) {</span>
        <span class="s2">return </span><span class="s1">string;</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">end = length - stringSize(omission);</span>
      <span class="s2">if </span><span class="s1">(end &lt; </span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">omission;</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">result = strSymbols</span>
        <span class="s1">? castSlice(strSymbols, </span><span class="s4">0</span><span class="s1">, end).join(</span><span class="s3">''</span><span class="s1">)</span>
        <span class="s1">: string.slice(</span><span class="s4">0</span><span class="s1">, end);</span>

      <span class="s2">if </span><span class="s1">(separator === undefined) {</span>
        <span class="s2">return </span><span class="s1">result + omission;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(strSymbols) {</span>
        <span class="s1">end += (result.length - end);</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(isRegExp(separator)) {</span>
        <span class="s2">if </span><span class="s1">(string.slice(end).search(separator)) {</span>
          <span class="s2">var </span><span class="s1">match,</span>
              <span class="s1">substring = result;</span>

          <span class="s2">if </span><span class="s1">(!separator.global) {</span>
            <span class="s1">separator = RegExp(separator.source, toString(reFlags.exec(separator)) + </span><span class="s3">'g'</span><span class="s1">);</span>
          <span class="s1">}</span>
          <span class="s1">separator.lastIndex = </span><span class="s4">0</span><span class="s1">;</span>
          <span class="s2">while </span><span class="s1">((match = separator.exec(substring))) {</span>
            <span class="s2">var </span><span class="s1">newEnd = match.index;</span>
          <span class="s1">}</span>
          <span class="s1">result = result.slice(</span><span class="s4">0</span><span class="s1">, newEnd === undefined ? end : newEnd);</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(string.indexOf(baseToString(separator), end) != end) {</span>
        <span class="s2">var </span><span class="s1">index = result.lastIndexOf(separator);</span>
        <span class="s2">if </span><span class="s1">(index &gt; -</span><span class="s4">1</span><span class="s1">) {</span>
          <span class="s1">result = result.slice(</span><span class="s4">0</span><span class="s1">, index);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">result + omission;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The inverse of `_.escape`; this method converts the HTML entities 
     * `&amp;amp;`, `&amp;lt;`, `&amp;gt;`, `&amp;quot;`, and `&amp;#39;` in `string` to 
     * their corresponding characters. 
     * 
     * **Note:** No other HTML entities are unescaped. To unescape additional 
     * HTML entities use a third-party library like [_he_](https://mths.be/he). 
     * 
     * @static 
     * @memberOf _ 
     * @since 0.6.0 
     * @category String 
     * @param {string} [string=''] The string to unescape. 
     * @returns {string} Returns the unescaped string. 
     * @example 
     * 
     * _.unescape('fred, barney, &amp;amp; pebbles'); 
     * // =&gt; 'fred, barney, &amp; pebbles' 
     */</span>
    <span class="s2">function </span><span class="s1">unescape(string) {</span>
      <span class="s1">string = toString(string);</span>
      <span class="s2">return </span><span class="s1">(string &amp;&amp; reHasEscapedHtml.test(string))</span>
        <span class="s1">? string.replace(reEscapedHtml, unescapeHtmlChar)</span>
        <span class="s1">: string;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Converts `string`, as space separated words, to upper case. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category String 
     * @param {string} [string=''] The string to convert. 
     * @returns {string} Returns the upper cased string. 
     * @example 
     * 
     * _.upperCase('--foo-bar'); 
     * // =&gt; 'FOO BAR' 
     * 
     * _.upperCase('fooBar'); 
     * // =&gt; 'FOO BAR' 
     * 
     * _.upperCase('__foo_bar__'); 
     * // =&gt; 'FOO BAR' 
     */</span>
    <span class="s2">var </span><span class="s1">upperCase = createCompounder(</span><span class="s2">function</span><span class="s1">(result, word, index) {</span>
      <span class="s2">return </span><span class="s1">result + (index ? </span><span class="s3">' ' </span><span class="s1">: </span><span class="s3">''</span><span class="s1">) + word.toUpperCase();</span>
    <span class="s1">});</span>

    <span class="s0">/** 
     * Converts the first character of `string` to upper case. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category String 
     * @param {string} [string=''] The string to convert. 
     * @returns {string} Returns the converted string. 
     * @example 
     * 
     * _.upperFirst('fred'); 
     * // =&gt; 'Fred' 
     * 
     * _.upperFirst('FRED'); 
     * // =&gt; 'FRED' 
     */</span>
    <span class="s2">var </span><span class="s1">upperFirst = createCaseFirst(</span><span class="s3">'toUpperCase'</span><span class="s1">);</span>

    <span class="s0">/** 
     * Splits `string` into an array of its words. 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.0.0 
     * @category String 
     * @param {string} [string=''] The string to inspect. 
     * @param {RegExp|string} [pattern] The pattern to match words. 
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`. 
     * @returns {Array} Returns the words of `string`. 
     * @example 
     * 
     * _.words('fred, barney, &amp; pebbles'); 
     * // =&gt; ['fred', 'barney', 'pebbles'] 
     * 
     * _.words('fred, barney, &amp; pebbles', /[^, ]+/g); 
     * // =&gt; ['fred', 'barney', '&amp;', 'pebbles'] 
     */</span>
    <span class="s2">function </span><span class="s1">words(string, pattern, guard) {</span>
      <span class="s1">string = toString(string);</span>
      <span class="s1">pattern = guard ? undefined : pattern;</span>

      <span class="s2">if </span><span class="s1">(pattern === undefined) {</span>
        <span class="s2">return </span><span class="s1">hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">string.match(pattern) || [];</span>
    <span class="s1">}</span>

    <span class="s0">/*------------------------------------------------------------------------*/</span>

    <span class="s0">/** 
     * Attempts to invoke `func`, returning either the result or the caught error 
     * object. Any additional arguments are provided to `func` when it's invoked. 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.0.0 
     * @category Util 
     * @param {Function} func The function to attempt. 
     * @param {...*} [args] The arguments to invoke `func` with. 
     * @returns {*} Returns the `func` result or error object. 
     * @example 
     * 
     * // Avoid throwing errors for invalid selectors. 
     * var elements = _.attempt(function(selector) { 
     *   return document.querySelectorAll(selector); 
     * }, '&gt;_&gt;'); 
     * 
     * if (_.isError(elements)) { 
     *   elements = []; 
     * } 
     */</span>
    <span class="s2">var </span><span class="s1">attempt = baseRest(</span><span class="s2">function</span><span class="s1">(func, args) {</span>
      <span class="s2">try </span><span class="s1">{</span>
        <span class="s2">return </span><span class="s1">apply(func, undefined, args);</span>
      <span class="s1">} </span><span class="s2">catch </span><span class="s1">(e) {</span>
        <span class="s2">return </span><span class="s1">isError(e) ? e : </span><span class="s2">new </span><span class="s1">Error(e);</span>
      <span class="s1">}</span>
    <span class="s1">});</span>

    <span class="s0">/** 
     * Binds methods of an object to the object itself, overwriting the existing 
     * method. 
     * 
     * **Note:** This method doesn't set the &quot;length&quot; property of bound functions. 
     * 
     * @static 
     * @since 0.1.0 
     * @memberOf _ 
     * @category Util 
     * @param {Object} object The object to bind and assign the bound methods to. 
     * @param {...(string|string[])} methodNames The object method names to bind. 
     * @returns {Object} Returns `object`. 
     * @example 
     * 
     * var view = { 
     *   'label': 'docs', 
     *   'click': function() { 
     *     console.log('clicked ' + this.label); 
     *   } 
     * }; 
     * 
     * _.bindAll(view, ['click']); 
     * jQuery(element).on('click', view.click); 
     * // =&gt; Logs 'clicked docs' when clicked. 
     */</span>
    <span class="s2">var </span><span class="s1">bindAll = flatRest(</span><span class="s2">function</span><span class="s1">(object, methodNames) {</span>
      <span class="s1">arrayEach(methodNames, </span><span class="s2">function</span><span class="s1">(key) {</span>
        <span class="s1">key = toKey(key);</span>
        <span class="s1">baseAssignValue(object, key, bind(object[key], object));</span>
      <span class="s1">});</span>
      <span class="s2">return </span><span class="s1">object;</span>
    <span class="s1">});</span>

    <span class="s0">/** 
     * Creates a function that iterates over `pairs` and invokes the corresponding 
     * function of the first predicate to return truthy. The predicate-function 
     * pairs are invoked with the `this` binding and arguments of the created 
     * function. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Util 
     * @param {Array} pairs The predicate-function pairs. 
     * @returns {Function} Returns the new composite function. 
     * @example 
     * 
     * var func = _.cond([ 
     *   [_.matches({ 'a': 1 }),           _.constant('matches A')], 
     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')], 
     *   [_.stubTrue,                      _.constant('no match')] 
     * ]); 
     * 
     * func({ 'a': 1, 'b': 2 }); 
     * // =&gt; 'matches A' 
     * 
     * func({ 'a': 0, 'b': 1 }); 
     * // =&gt; 'matches B' 
     * 
     * func({ 'a': '1', 'b': '2' }); 
     * // =&gt; 'no match' 
     */</span>
    <span class="s2">function </span><span class="s1">cond(pairs) {</span>
      <span class="s2">var </span><span class="s1">length = pairs == </span><span class="s2">null </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: pairs.length,</span>
          <span class="s1">toIteratee = getIteratee();</span>

      <span class="s1">pairs = !length ? [] : arrayMap(pairs, </span><span class="s2">function</span><span class="s1">(pair) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">pair[</span><span class="s4">1</span><span class="s1">] != </span><span class="s3">'function'</span><span class="s1">) {</span>
          <span class="s2">throw new </span><span class="s1">TypeError(FUNC_ERROR_TEXT);</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">[toIteratee(pair[</span><span class="s4">0</span><span class="s1">]), pair[</span><span class="s4">1</span><span class="s1">]];</span>
      <span class="s1">});</span>

      <span class="s2">return </span><span class="s1">baseRest(</span><span class="s2">function</span><span class="s1">(args) {</span>
        <span class="s2">var </span><span class="s1">index = -</span><span class="s4">1</span><span class="s1">;</span>
        <span class="s2">while </span><span class="s1">(++index &lt; length) {</span>
          <span class="s2">var </span><span class="s1">pair = pairs[index];</span>
          <span class="s2">if </span><span class="s1">(apply(pair[</span><span class="s4">0</span><span class="s1">], </span><span class="s2">this</span><span class="s1">, args)) {</span>
            <span class="s2">return </span><span class="s1">apply(pair[</span><span class="s4">1</span><span class="s1">], </span><span class="s2">this</span><span class="s1">, args);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a function that invokes the predicate properties of `source` with 
     * the corresponding property values of a given object, returning `true` if 
     * all predicates return truthy, else `false`. 
     * 
     * **Note:** The created function is equivalent to `_.conformsTo` with 
     * `source` partially applied. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Util 
     * @param {Object} source The object of property predicates to conform to. 
     * @returns {Function} Returns the new spec function. 
     * @example 
     * 
     * var objects = [ 
     *   { 'a': 2, 'b': 1 }, 
     *   { 'a': 1, 'b': 2 } 
     * ]; 
     * 
     * _.filter(objects, _.conforms({ 'b': function(n) { return n &gt; 1; } })); 
     * // =&gt; [{ 'a': 1, 'b': 2 }] 
     */</span>
    <span class="s2">function </span><span class="s1">conforms(source) {</span>
      <span class="s2">return </span><span class="s1">baseConforms(baseClone(source, CLONE_DEEP_FLAG));</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a function that returns `value`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 2.4.0 
     * @category Util 
     * @param {*} value The value to return from the new function. 
     * @returns {Function} Returns the new constant function. 
     * @example 
     * 
     * var objects = _.times(2, _.constant({ 'a': 1 })); 
     * 
     * console.log(objects); 
     * // =&gt; [{ 'a': 1 }, { 'a': 1 }] 
     * 
     * console.log(objects[0] === objects[1]); 
     * // =&gt; true 
     */</span>
    <span class="s2">function </span><span class="s1">constant(value) {</span>
      <span class="s2">return function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">value;</span>
      <span class="s1">};</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Checks `value` to determine whether a default value should be returned in 
     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`, 
     * or `undefined`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.14.0 
     * @category Util 
     * @param {*} value The value to check. 
     * @param {*} defaultValue The default value. 
     * @returns {*} Returns the resolved value. 
     * @example 
     * 
     * _.defaultTo(1, 10); 
     * // =&gt; 1 
     * 
     * _.defaultTo(undefined, 10); 
     * // =&gt; 10 
     */</span>
    <span class="s2">function </span><span class="s1">defaultTo(value, defaultValue) {</span>
      <span class="s2">return </span><span class="s1">(value == </span><span class="s2">null </span><span class="s1">|| value !== value) ? defaultValue : value;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a function that returns the result of invoking the given functions 
     * with the `this` binding of the created function, where each successive 
     * invocation is supplied the return value of the previous. 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.0.0 
     * @category Util 
     * @param {...(Function|Function[])} [funcs] The functions to invoke. 
     * @returns {Function} Returns the new composite function. 
     * @see _.flowRight 
     * @example 
     * 
     * function square(n) { 
     *   return n * n; 
     * } 
     * 
     * var addSquare = _.flow([_.add, square]); 
     * addSquare(1, 2); 
     * // =&gt; 9 
     */</span>
    <span class="s2">var </span><span class="s1">flow = createFlow();</span>

    <span class="s0">/** 
     * This method is like `_.flow` except that it creates a function that 
     * invokes the given functions from right to left. 
     * 
     * @static 
     * @since 3.0.0 
     * @memberOf _ 
     * @category Util 
     * @param {...(Function|Function[])} [funcs] The functions to invoke. 
     * @returns {Function} Returns the new composite function. 
     * @see _.flow 
     * @example 
     * 
     * function square(n) { 
     *   return n * n; 
     * } 
     * 
     * var addSquare = _.flowRight([square, _.add]); 
     * addSquare(1, 2); 
     * // =&gt; 9 
     */</span>
    <span class="s2">var </span><span class="s1">flowRight = createFlow(</span><span class="s2">true</span><span class="s1">);</span>

    <span class="s0">/** 
     * This method returns the first argument it receives. 
     * 
     * @static 
     * @since 0.1.0 
     * @memberOf _ 
     * @category Util 
     * @param {*} value Any value. 
     * @returns {*} Returns `value`. 
     * @example 
     * 
     * var object = { 'a': 1 }; 
     * 
     * console.log(_.identity(object) === object); 
     * // =&gt; true 
     */</span>
    <span class="s2">function </span><span class="s1">identity(value) {</span>
      <span class="s2">return </span><span class="s1">value;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a function that invokes `func` with the arguments of the created 
     * function. If `func` is a property name, the created function returns the 
     * property value for a given element. If `func` is an array or object, the 
     * created function returns `true` for elements that contain the equivalent 
     * source properties, otherwise it returns `false`. 
     * 
     * @static 
     * @since 4.0.0 
     * @memberOf _ 
     * @category Util 
     * @param {*} [func=_.identity] The value to convert to a callback. 
     * @returns {Function} Returns the callback. 
     * @example 
     * 
     * var users = [ 
     *   { 'user': 'barney', 'age': 36, 'active': true }, 
     *   { 'user': 'fred',   'age': 40, 'active': false } 
     * ]; 
     * 
     * // The `_.matches` iteratee shorthand. 
     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true })); 
     * // =&gt; [{ 'user': 'barney', 'age': 36, 'active': true }] 
     * 
     * // The `_.matchesProperty` iteratee shorthand. 
     * _.filter(users, _.iteratee(['user', 'fred'])); 
     * // =&gt; [{ 'user': 'fred', 'age': 40 }] 
     * 
     * // The `_.property` iteratee shorthand. 
     * _.map(users, _.iteratee('user')); 
     * // =&gt; ['barney', 'fred'] 
     * 
     * // Create custom iteratee shorthands. 
     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) { 
     *   return !_.isRegExp(func) ? iteratee(func) : function(string) { 
     *     return func.test(string); 
     *   }; 
     * }); 
     * 
     * _.filter(['abc', 'def'], /ef/); 
     * // =&gt; ['def'] 
     */</span>
    <span class="s2">function </span><span class="s1">iteratee(func) {</span>
      <span class="s2">return </span><span class="s1">baseIteratee(</span><span class="s2">typeof </span><span class="s1">func == </span><span class="s3">'function' </span><span class="s1">? func : baseClone(func, CLONE_DEEP_FLAG));</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a function that performs a partial deep comparison between a given 
     * object and `source`, returning `true` if the given object has equivalent 
     * property values, else `false`. 
     * 
     * **Note:** The created function is equivalent to `_.isMatch` with `source` 
     * partially applied. 
     * 
     * Partial comparisons will match empty array and empty object `source` 
     * values against any array or object value, respectively. See `_.isEqual` 
     * for a list of supported value comparisons. 
     * 
     * **Note:** Multiple values can be checked by combining several matchers 
     * using `_.overSome` 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.0.0 
     * @category Util 
     * @param {Object} source The object of property values to match. 
     * @returns {Function} Returns the new spec function. 
     * @example 
     * 
     * var objects = [ 
     *   { 'a': 1, 'b': 2, 'c': 3 }, 
     *   { 'a': 4, 'b': 5, 'c': 6 } 
     * ]; 
     * 
     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 })); 
     * // =&gt; [{ 'a': 4, 'b': 5, 'c': 6 }] 
     * 
     * // Checking for several possible values 
     * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })])); 
     * // =&gt; [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }] 
     */</span>
    <span class="s2">function </span><span class="s1">matches(source) {</span>
      <span class="s2">return </span><span class="s1">baseMatches(baseClone(source, CLONE_DEEP_FLAG));</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a function that performs a partial deep comparison between the 
     * value at `path` of a given object to `srcValue`, returning `true` if the 
     * object value is equivalent, else `false`. 
     * 
     * **Note:** Partial comparisons will match empty array and empty object 
     * `srcValue` values against any array or object value, respectively. See 
     * `_.isEqual` for a list of supported value comparisons. 
     * 
     * **Note:** Multiple values can be checked by combining several matchers 
     * using `_.overSome` 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.2.0 
     * @category Util 
     * @param {Array|string} path The path of the property to get. 
     * @param {*} srcValue The value to match. 
     * @returns {Function} Returns the new spec function. 
     * @example 
     * 
     * var objects = [ 
     *   { 'a': 1, 'b': 2, 'c': 3 }, 
     *   { 'a': 4, 'b': 5, 'c': 6 } 
     * ]; 
     * 
     * _.find(objects, _.matchesProperty('a', 4)); 
     * // =&gt; { 'a': 4, 'b': 5, 'c': 6 } 
     * 
     * // Checking for several possible values 
     * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)])); 
     * // =&gt; [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }] 
     */</span>
    <span class="s2">function </span><span class="s1">matchesProperty(path, srcValue) {</span>
      <span class="s2">return </span><span class="s1">baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a function that invokes the method at `path` of a given object. 
     * Any additional arguments are provided to the invoked method. 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.7.0 
     * @category Util 
     * @param {Array|string} path The path of the method to invoke. 
     * @param {...*} [args] The arguments to invoke the method with. 
     * @returns {Function} Returns the new invoker function. 
     * @example 
     * 
     * var objects = [ 
     *   { 'a': { 'b': _.constant(2) } }, 
     *   { 'a': { 'b': _.constant(1) } } 
     * ]; 
     * 
     * _.map(objects, _.method('a.b')); 
     * // =&gt; [2, 1] 
     * 
     * _.map(objects, _.method(['a', 'b'])); 
     * // =&gt; [2, 1] 
     */</span>
    <span class="s2">var </span><span class="s1">method = baseRest(</span><span class="s2">function</span><span class="s1">(path, args) {</span>
      <span class="s2">return function</span><span class="s1">(object) {</span>
        <span class="s2">return </span><span class="s1">baseInvoke(object, path, args);</span>
      <span class="s1">};</span>
    <span class="s1">});</span>

    <span class="s0">/** 
     * The opposite of `_.method`; this method creates a function that invokes 
     * the method at a given path of `object`. Any additional arguments are 
     * provided to the invoked method. 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.7.0 
     * @category Util 
     * @param {Object} object The object to query. 
     * @param {...*} [args] The arguments to invoke the method with. 
     * @returns {Function} Returns the new invoker function. 
     * @example 
     * 
     * var array = _.times(3, _.constant), 
     *     object = { 'a': array, 'b': array, 'c': array }; 
     * 
     * _.map(['a[2]', 'c[0]'], _.methodOf(object)); 
     * // =&gt; [2, 0] 
     * 
     * _.map([['a', '2'], ['c', '0']], _.methodOf(object)); 
     * // =&gt; [2, 0] 
     */</span>
    <span class="s2">var </span><span class="s1">methodOf = baseRest(</span><span class="s2">function</span><span class="s1">(object, args) {</span>
      <span class="s2">return function</span><span class="s1">(path) {</span>
        <span class="s2">return </span><span class="s1">baseInvoke(object, path, args);</span>
      <span class="s1">};</span>
    <span class="s1">});</span>

    <span class="s0">/** 
     * Adds all own enumerable string keyed function properties of a source 
     * object to the destination object. If `object` is a function, then methods 
     * are added to its prototype as well. 
     * 
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to 
     * avoid conflicts caused by modifying the original. 
     * 
     * @static 
     * @since 0.1.0 
     * @memberOf _ 
     * @category Util 
     * @param {Function|Object} [object=lodash] The destination object. 
     * @param {Object} source The object of functions to add. 
     * @param {Object} [options={}] The options object. 
     * @param {boolean} [options.chain=true] Specify whether mixins are chainable. 
     * @returns {Function|Object} Returns `object`. 
     * @example 
     * 
     * function vowels(string) { 
     *   return _.filter(string, function(v) { 
     *     return /[aeiou]/i.test(v); 
     *   }); 
     * } 
     * 
     * _.mixin({ 'vowels': vowels }); 
     * _.vowels('fred'); 
     * // =&gt; ['e'] 
     * 
     * _('fred').vowels().value(); 
     * // =&gt; ['e'] 
     * 
     * _.mixin({ 'vowels': vowels }, { 'chain': false }); 
     * _('fred').vowels(); 
     * // =&gt; ['e'] 
     */</span>
    <span class="s2">function </span><span class="s1">mixin(object, source, options) {</span>
      <span class="s2">var </span><span class="s1">props = keys(source),</span>
          <span class="s1">methodNames = baseFunctions(source, props);</span>

      <span class="s2">if </span><span class="s1">(options == </span><span class="s2">null </span><span class="s1">&amp;&amp;</span>
          <span class="s1">!(isObject(source) &amp;&amp; (methodNames.length || !props.length))) {</span>
        <span class="s1">options = source;</span>
        <span class="s1">source = object;</span>
        <span class="s1">object = </span><span class="s2">this</span><span class="s1">;</span>
        <span class="s1">methodNames = baseFunctions(source, keys(source));</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">chain = !(isObject(options) &amp;&amp; </span><span class="s3">'chain' </span><span class="s2">in </span><span class="s1">options) || !!options.chain,</span>
          <span class="s1">isFunc = isFunction(object);</span>

      <span class="s1">arrayEach(methodNames, </span><span class="s2">function</span><span class="s1">(methodName) {</span>
        <span class="s2">var </span><span class="s1">func = source[methodName];</span>
        <span class="s1">object[methodName] = func;</span>
        <span class="s2">if </span><span class="s1">(isFunc) {</span>
          <span class="s1">object.prototype[methodName] = </span><span class="s2">function</span><span class="s1">() {</span>
            <span class="s2">var </span><span class="s1">chainAll = </span><span class="s2">this</span><span class="s1">.__chain__;</span>
            <span class="s2">if </span><span class="s1">(chain || chainAll) {</span>
              <span class="s2">var </span><span class="s1">result = object(</span><span class="s2">this</span><span class="s1">.__wrapped__),</span>
                  <span class="s1">actions = result.__actions__ = copyArray(</span><span class="s2">this</span><span class="s1">.__actions__);</span>

              <span class="s1">actions.push({ </span><span class="s3">'func'</span><span class="s1">: func, </span><span class="s3">'args'</span><span class="s1">: arguments, </span><span class="s3">'thisArg'</span><span class="s1">: object });</span>
              <span class="s1">result.__chain__ = chainAll;</span>
              <span class="s2">return </span><span class="s1">result;</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">func.apply(object, arrayPush([</span><span class="s2">this</span><span class="s1">.value()], arguments));</span>
          <span class="s1">};</span>
        <span class="s1">}</span>
      <span class="s1">});</span>

      <span class="s2">return </span><span class="s1">object;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Reverts the `_` variable to its previous value and returns a reference to 
     * the `lodash` function. 
     * 
     * @static 
     * @since 0.1.0 
     * @memberOf _ 
     * @category Util 
     * @returns {Function} Returns the `lodash` function. 
     * @example 
     * 
     * var lodash = _.noConflict(); 
     */</span>
    <span class="s2">function </span><span class="s1">noConflict() {</span>
      <span class="s2">if </span><span class="s1">(root._ === </span><span class="s2">this</span><span class="s1">) {</span>
        <span class="s1">root._ = oldDash;</span>
      <span class="s1">}</span>
      <span class="s2">return this</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * This method returns `undefined`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 2.3.0 
     * @category Util 
     * @example 
     * 
     * _.times(2, _.noop); 
     * // =&gt; [undefined, undefined] 
     */</span>
    <span class="s2">function </span><span class="s1">noop() {</span>
      <span class="s0">// No operation performed.</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a function that gets the argument at index `n`. If `n` is negative, 
     * the nth argument from the end is returned. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Util 
     * @param {number} [n=0] The index of the argument to return. 
     * @returns {Function} Returns the new pass-thru function. 
     * @example 
     * 
     * var func = _.nthArg(1); 
     * func('a', 'b', 'c', 'd'); 
     * // =&gt; 'b' 
     * 
     * var func = _.nthArg(-2); 
     * func('a', 'b', 'c', 'd'); 
     * // =&gt; 'c' 
     */</span>
    <span class="s2">function </span><span class="s1">nthArg(n) {</span>
      <span class="s1">n = toInteger(n);</span>
      <span class="s2">return </span><span class="s1">baseRest(</span><span class="s2">function</span><span class="s1">(args) {</span>
        <span class="s2">return </span><span class="s1">baseNth(args, n);</span>
      <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates a function that invokes `iteratees` with the arguments it receives 
     * and returns their results. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Util 
     * @param {...(Function|Function[])} [iteratees=[_.identity]] 
     *  The iteratees to invoke. 
     * @returns {Function} Returns the new function. 
     * @example 
     * 
     * var func = _.over([Math.max, Math.min]); 
     * 
     * func(1, 2, 3, 4); 
     * // =&gt; [4, 1] 
     */</span>
    <span class="s2">var </span><span class="s1">over = createOver(arrayMap);</span>

    <span class="s0">/** 
     * Creates a function that checks if **all** of the `predicates` return 
     * truthy when invoked with the arguments it receives. 
     * 
     * Following shorthands are possible for providing predicates. 
     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate. 
     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Util 
     * @param {...(Function|Function[])} [predicates=[_.identity]] 
     *  The predicates to check. 
     * @returns {Function} Returns the new function. 
     * @example 
     * 
     * var func = _.overEvery([Boolean, isFinite]); 
     * 
     * func('1'); 
     * // =&gt; true 
     * 
     * func(null); 
     * // =&gt; false 
     * 
     * func(NaN); 
     * // =&gt; false 
     */</span>
    <span class="s2">var </span><span class="s1">overEvery = createOver(arrayEvery);</span>

    <span class="s0">/** 
     * Creates a function that checks if **any** of the `predicates` return 
     * truthy when invoked with the arguments it receives. 
     * 
     * Following shorthands are possible for providing predicates. 
     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate. 
     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Util 
     * @param {...(Function|Function[])} [predicates=[_.identity]] 
     *  The predicates to check. 
     * @returns {Function} Returns the new function. 
     * @example 
     * 
     * var func = _.overSome([Boolean, isFinite]); 
     * 
     * func('1'); 
     * // =&gt; true 
     * 
     * func(null); 
     * // =&gt; true 
     * 
     * func(NaN); 
     * // =&gt; false 
     * 
     * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }]) 
     * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]]) 
     */</span>
    <span class="s2">var </span><span class="s1">overSome = createOver(arraySome);</span>

    <span class="s0">/** 
     * Creates a function that returns the value at `path` of a given object. 
     * 
     * @static 
     * @memberOf _ 
     * @since 2.4.0 
     * @category Util 
     * @param {Array|string} path The path of the property to get. 
     * @returns {Function} Returns the new accessor function. 
     * @example 
     * 
     * var objects = [ 
     *   { 'a': { 'b': 2 } }, 
     *   { 'a': { 'b': 1 } } 
     * ]; 
     * 
     * _.map(objects, _.property('a.b')); 
     * // =&gt; [2, 1] 
     * 
     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b'); 
     * // =&gt; [1, 2] 
     */</span>
    <span class="s2">function </span><span class="s1">property(path) {</span>
      <span class="s2">return </span><span class="s1">isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * The opposite of `_.property`; this method creates a function that returns 
     * the value at a given path of `object`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.0.0 
     * @category Util 
     * @param {Object} object The object to query. 
     * @returns {Function} Returns the new accessor function. 
     * @example 
     * 
     * var array = [0, 1, 2], 
     *     object = { 'a': array, 'b': array, 'c': array }; 
     * 
     * _.map(['a[2]', 'c[0]'], _.propertyOf(object)); 
     * // =&gt; [2, 0] 
     * 
     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object)); 
     * // =&gt; [2, 0] 
     */</span>
    <span class="s2">function </span><span class="s1">propertyOf(object) {</span>
      <span class="s2">return function</span><span class="s1">(path) {</span>
        <span class="s2">return </span><span class="s1">object == </span><span class="s2">null </span><span class="s1">? undefined : baseGet(object, path);</span>
      <span class="s1">};</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Creates an array of numbers (positive and/or negative) progressing from 
     * `start` up to, but not including, `end`. A step of `-1` is used if a negative 
     * `start` is specified without an `end` or `step`. If `end` is not specified, 
     * it's set to `start` with `start` then set to `0`. 
     * 
     * **Note:** JavaScript follows the IEEE-754 standard for resolving 
     * floating-point values which can produce unexpected results. 
     * 
     * @static 
     * @since 0.1.0 
     * @memberOf _ 
     * @category Util 
     * @param {number} [start=0] The start of the range. 
     * @param {number} end The end of the range. 
     * @param {number} [step=1] The value to increment or decrement by. 
     * @returns {Array} Returns the range of numbers. 
     * @see _.inRange, _.rangeRight 
     * @example 
     * 
     * _.range(4); 
     * // =&gt; [0, 1, 2, 3] 
     * 
     * _.range(-4); 
     * // =&gt; [0, -1, -2, -3] 
     * 
     * _.range(1, 5); 
     * // =&gt; [1, 2, 3, 4] 
     * 
     * _.range(0, 20, 5); 
     * // =&gt; [0, 5, 10, 15] 
     * 
     * _.range(0, -4, -1); 
     * // =&gt; [0, -1, -2, -3] 
     * 
     * _.range(1, 4, 0); 
     * // =&gt; [1, 1, 1] 
     * 
     * _.range(0); 
     * // =&gt; [] 
     */</span>
    <span class="s2">var </span><span class="s1">range = createRange();</span>

    <span class="s0">/** 
     * This method is like `_.range` except that it populates values in 
     * descending order. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Util 
     * @param {number} [start=0] The start of the range. 
     * @param {number} end The end of the range. 
     * @param {number} [step=1] The value to increment or decrement by. 
     * @returns {Array} Returns the range of numbers. 
     * @see _.inRange, _.range 
     * @example 
     * 
     * _.rangeRight(4); 
     * // =&gt; [3, 2, 1, 0] 
     * 
     * _.rangeRight(-4); 
     * // =&gt; [-3, -2, -1, 0] 
     * 
     * _.rangeRight(1, 5); 
     * // =&gt; [4, 3, 2, 1] 
     * 
     * _.rangeRight(0, 20, 5); 
     * // =&gt; [15, 10, 5, 0] 
     * 
     * _.rangeRight(0, -4, -1); 
     * // =&gt; [-3, -2, -1, 0] 
     * 
     * _.rangeRight(1, 4, 0); 
     * // =&gt; [1, 1, 1] 
     * 
     * _.rangeRight(0); 
     * // =&gt; [] 
     */</span>
    <span class="s2">var </span><span class="s1">rangeRight = createRange(</span><span class="s2">true</span><span class="s1">);</span>

    <span class="s0">/** 
     * This method returns a new empty array. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.13.0 
     * @category Util 
     * @returns {Array} Returns the new empty array. 
     * @example 
     * 
     * var arrays = _.times(2, _.stubArray); 
     * 
     * console.log(arrays); 
     * // =&gt; [[], []] 
     * 
     * console.log(arrays[0] === arrays[1]); 
     * // =&gt; false 
     */</span>
    <span class="s2">function </span><span class="s1">stubArray() {</span>
      <span class="s2">return </span><span class="s1">[];</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * This method returns `false`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.13.0 
     * @category Util 
     * @returns {boolean} Returns `false`. 
     * @example 
     * 
     * _.times(2, _.stubFalse); 
     * // =&gt; [false, false] 
     */</span>
    <span class="s2">function </span><span class="s1">stubFalse() {</span>
      <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * This method returns a new empty object. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.13.0 
     * @category Util 
     * @returns {Object} Returns the new empty object. 
     * @example 
     * 
     * var objects = _.times(2, _.stubObject); 
     * 
     * console.log(objects); 
     * // =&gt; [{}, {}] 
     * 
     * console.log(objects[0] === objects[1]); 
     * // =&gt; false 
     */</span>
    <span class="s2">function </span><span class="s1">stubObject() {</span>
      <span class="s2">return </span><span class="s1">{};</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * This method returns an empty string. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.13.0 
     * @category Util 
     * @returns {string} Returns the empty string. 
     * @example 
     * 
     * _.times(2, _.stubString); 
     * // =&gt; ['', ''] 
     */</span>
    <span class="s2">function </span><span class="s1">stubString() {</span>
      <span class="s2">return </span><span class="s3">''</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * This method returns `true`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.13.0 
     * @category Util 
     * @returns {boolean} Returns `true`. 
     * @example 
     * 
     * _.times(2, _.stubTrue); 
     * // =&gt; [true, true] 
     */</span>
    <span class="s2">function </span><span class="s1">stubTrue() {</span>
      <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Invokes the iteratee `n` times, returning an array of the results of 
     * each invocation. The iteratee is invoked with one argument; (index). 
     * 
     * @static 
     * @since 0.1.0 
     * @memberOf _ 
     * @category Util 
     * @param {number} n The number of times to invoke `iteratee`. 
     * @param {Function} [iteratee=_.identity] The function invoked per iteration. 
     * @returns {Array} Returns the array of results. 
     * @example 
     * 
     * _.times(3, String); 
     * // =&gt; ['0', '1', '2'] 
     * 
     *  _.times(4, _.constant(0)); 
     * // =&gt; [0, 0, 0, 0] 
     */</span>
    <span class="s2">function </span><span class="s1">times(n, iteratee) {</span>
      <span class="s1">n = toInteger(n);</span>
      <span class="s2">if </span><span class="s1">(n &lt; </span><span class="s4">1 </span><span class="s1">|| n &gt; MAX_SAFE_INTEGER) {</span>
        <span class="s2">return </span><span class="s1">[];</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">index = MAX_ARRAY_LENGTH,</span>
          <span class="s1">length = nativeMin(n, MAX_ARRAY_LENGTH);</span>

      <span class="s1">iteratee = getIteratee(iteratee);</span>
      <span class="s1">n -= MAX_ARRAY_LENGTH;</span>

      <span class="s2">var </span><span class="s1">result = baseTimes(length, iteratee);</span>
      <span class="s2">while </span><span class="s1">(++index &lt; n) {</span>
        <span class="s1">iteratee(index);</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Converts `value` to a property path array. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Util 
     * @param {*} value The value to convert. 
     * @returns {Array} Returns the new property path array. 
     * @example 
     * 
     * _.toPath('a.b.c'); 
     * // =&gt; ['a', 'b', 'c'] 
     * 
     * _.toPath('a[0].b.c'); 
     * // =&gt; ['a', '0', 'b', 'c'] 
     */</span>
    <span class="s2">function </span><span class="s1">toPath(value) {</span>
      <span class="s2">if </span><span class="s1">(isArray(value)) {</span>
        <span class="s2">return </span><span class="s1">arrayMap(value, toKey);</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Generates a unique ID. If `prefix` is given, the ID is appended to it. 
     * 
     * @static 
     * @since 0.1.0 
     * @memberOf _ 
     * @category Util 
     * @param {string} [prefix=''] The value to prefix the ID with. 
     * @returns {string} Returns the unique ID. 
     * @example 
     * 
     * _.uniqueId('contact_'); 
     * // =&gt; 'contact_104' 
     * 
     * _.uniqueId(); 
     * // =&gt; '105' 
     */</span>
    <span class="s2">function </span><span class="s1">uniqueId(prefix) {</span>
      <span class="s2">var </span><span class="s1">id = ++idCounter;</span>
      <span class="s2">return </span><span class="s1">toString(prefix) + id;</span>
    <span class="s1">}</span>

    <span class="s0">/*------------------------------------------------------------------------*/</span>

    <span class="s0">/** 
     * Adds two numbers. 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.4.0 
     * @category Math 
     * @param {number} augend The first number in an addition. 
     * @param {number} addend The second number in an addition. 
     * @returns {number} Returns the total. 
     * @example 
     * 
     * _.add(6, 4); 
     * // =&gt; 10 
     */</span>
    <span class="s2">var </span><span class="s1">add = createMathOperation(</span><span class="s2">function</span><span class="s1">(augend, addend) {</span>
      <span class="s2">return </span><span class="s1">augend + addend;</span>
    <span class="s1">}, </span><span class="s4">0</span><span class="s1">);</span>

    <span class="s0">/** 
     * Computes `number` rounded up to `precision`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.10.0 
     * @category Math 
     * @param {number} number The number to round up. 
     * @param {number} [precision=0] The precision to round up to. 
     * @returns {number} Returns the rounded up number. 
     * @example 
     * 
     * _.ceil(4.006); 
     * // =&gt; 5 
     * 
     * _.ceil(6.004, 2); 
     * // =&gt; 6.01 
     * 
     * _.ceil(6040, -2); 
     * // =&gt; 6100 
     */</span>
    <span class="s2">var </span><span class="s1">ceil = createRound(</span><span class="s3">'ceil'</span><span class="s1">);</span>

    <span class="s0">/** 
     * Divide two numbers. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.7.0 
     * @category Math 
     * @param {number} dividend The first number in a division. 
     * @param {number} divisor The second number in a division. 
     * @returns {number} Returns the quotient. 
     * @example 
     * 
     * _.divide(6, 4); 
     * // =&gt; 1.5 
     */</span>
    <span class="s2">var </span><span class="s1">divide = createMathOperation(</span><span class="s2">function</span><span class="s1">(dividend, divisor) {</span>
      <span class="s2">return </span><span class="s1">dividend / divisor;</span>
    <span class="s1">}, </span><span class="s4">1</span><span class="s1">);</span>

    <span class="s0">/** 
     * Computes `number` rounded down to `precision`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.10.0 
     * @category Math 
     * @param {number} number The number to round down. 
     * @param {number} [precision=0] The precision to round down to. 
     * @returns {number} Returns the rounded down number. 
     * @example 
     * 
     * _.floor(4.006); 
     * // =&gt; 4 
     * 
     * _.floor(0.046, 2); 
     * // =&gt; 0.04 
     * 
     * _.floor(4060, -2); 
     * // =&gt; 4000 
     */</span>
    <span class="s2">var </span><span class="s1">floor = createRound(</span><span class="s3">'floor'</span><span class="s1">);</span>

    <span class="s0">/** 
     * Computes the maximum value of `array`. If `array` is empty or falsey, 
     * `undefined` is returned. 
     * 
     * @static 
     * @since 0.1.0 
     * @memberOf _ 
     * @category Math 
     * @param {Array} array The array to iterate over. 
     * @returns {*} Returns the maximum value. 
     * @example 
     * 
     * _.max([4, 2, 8, 6]); 
     * // =&gt; 8 
     * 
     * _.max([]); 
     * // =&gt; undefined 
     */</span>
    <span class="s2">function </span><span class="s1">max(array) {</span>
      <span class="s2">return </span><span class="s1">(array &amp;&amp; array.length)</span>
        <span class="s1">? baseExtremum(array, identity, baseGt)</span>
        <span class="s1">: undefined;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * This method is like `_.max` except that it accepts `iteratee` which is 
     * invoked for each element in `array` to generate the criterion by which 
     * the value is ranked. The iteratee is invoked with one argument: (value). 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Math 
     * @param {Array} array The array to iterate over. 
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element. 
     * @returns {*} Returns the maximum value. 
     * @example 
     * 
     * var objects = [{ 'n': 1 }, { 'n': 2 }]; 
     * 
     * _.maxBy(objects, function(o) { return o.n; }); 
     * // =&gt; { 'n': 2 } 
     * 
     * // The `_.property` iteratee shorthand. 
     * _.maxBy(objects, 'n'); 
     * // =&gt; { 'n': 2 } 
     */</span>
    <span class="s2">function </span><span class="s1">maxBy(array, iteratee) {</span>
      <span class="s2">return </span><span class="s1">(array &amp;&amp; array.length)</span>
        <span class="s1">? baseExtremum(array, getIteratee(iteratee, </span><span class="s4">2</span><span class="s1">), baseGt)</span>
        <span class="s1">: undefined;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Computes the mean of the values in `array`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Math 
     * @param {Array} array The array to iterate over. 
     * @returns {number} Returns the mean. 
     * @example 
     * 
     * _.mean([4, 2, 8, 6]); 
     * // =&gt; 5 
     */</span>
    <span class="s2">function </span><span class="s1">mean(array) {</span>
      <span class="s2">return </span><span class="s1">baseMean(array, identity);</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * This method is like `_.mean` except that it accepts `iteratee` which is 
     * invoked for each element in `array` to generate the value to be averaged. 
     * The iteratee is invoked with one argument: (value). 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.7.0 
     * @category Math 
     * @param {Array} array The array to iterate over. 
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element. 
     * @returns {number} Returns the mean. 
     * @example 
     * 
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }]; 
     * 
     * _.meanBy(objects, function(o) { return o.n; }); 
     * // =&gt; 5 
     * 
     * // The `_.property` iteratee shorthand. 
     * _.meanBy(objects, 'n'); 
     * // =&gt; 5 
     */</span>
    <span class="s2">function </span><span class="s1">meanBy(array, iteratee) {</span>
      <span class="s2">return </span><span class="s1">baseMean(array, getIteratee(iteratee, </span><span class="s4">2</span><span class="s1">));</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Computes the minimum value of `array`. If `array` is empty or falsey, 
     * `undefined` is returned. 
     * 
     * @static 
     * @since 0.1.0 
     * @memberOf _ 
     * @category Math 
     * @param {Array} array The array to iterate over. 
     * @returns {*} Returns the minimum value. 
     * @example 
     * 
     * _.min([4, 2, 8, 6]); 
     * // =&gt; 2 
     * 
     * _.min([]); 
     * // =&gt; undefined 
     */</span>
    <span class="s2">function </span><span class="s1">min(array) {</span>
      <span class="s2">return </span><span class="s1">(array &amp;&amp; array.length)</span>
        <span class="s1">? baseExtremum(array, identity, baseLt)</span>
        <span class="s1">: undefined;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * This method is like `_.min` except that it accepts `iteratee` which is 
     * invoked for each element in `array` to generate the criterion by which 
     * the value is ranked. The iteratee is invoked with one argument: (value). 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Math 
     * @param {Array} array The array to iterate over. 
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element. 
     * @returns {*} Returns the minimum value. 
     * @example 
     * 
     * var objects = [{ 'n': 1 }, { 'n': 2 }]; 
     * 
     * _.minBy(objects, function(o) { return o.n; }); 
     * // =&gt; { 'n': 1 } 
     * 
     * // The `_.property` iteratee shorthand. 
     * _.minBy(objects, 'n'); 
     * // =&gt; { 'n': 1 } 
     */</span>
    <span class="s2">function </span><span class="s1">minBy(array, iteratee) {</span>
      <span class="s2">return </span><span class="s1">(array &amp;&amp; array.length)</span>
        <span class="s1">? baseExtremum(array, getIteratee(iteratee, </span><span class="s4">2</span><span class="s1">), baseLt)</span>
        <span class="s1">: undefined;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Multiply two numbers. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.7.0 
     * @category Math 
     * @param {number} multiplier The first number in a multiplication. 
     * @param {number} multiplicand The second number in a multiplication. 
     * @returns {number} Returns the product. 
     * @example 
     * 
     * _.multiply(6, 4); 
     * // =&gt; 24 
     */</span>
    <span class="s2">var </span><span class="s1">multiply = createMathOperation(</span><span class="s2">function</span><span class="s1">(multiplier, multiplicand) {</span>
      <span class="s2">return </span><span class="s1">multiplier * multiplicand;</span>
    <span class="s1">}, </span><span class="s4">1</span><span class="s1">);</span>

    <span class="s0">/** 
     * Computes `number` rounded to `precision`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.10.0 
     * @category Math 
     * @param {number} number The number to round. 
     * @param {number} [precision=0] The precision to round to. 
     * @returns {number} Returns the rounded number. 
     * @example 
     * 
     * _.round(4.006); 
     * // =&gt; 4 
     * 
     * _.round(4.006, 2); 
     * // =&gt; 4.01 
     * 
     * _.round(4060, -2); 
     * // =&gt; 4100 
     */</span>
    <span class="s2">var </span><span class="s1">round = createRound(</span><span class="s3">'round'</span><span class="s1">);</span>

    <span class="s0">/** 
     * Subtract two numbers. 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Math 
     * @param {number} minuend The first number in a subtraction. 
     * @param {number} subtrahend The second number in a subtraction. 
     * @returns {number} Returns the difference. 
     * @example 
     * 
     * _.subtract(6, 4); 
     * // =&gt; 2 
     */</span>
    <span class="s2">var </span><span class="s1">subtract = createMathOperation(</span><span class="s2">function</span><span class="s1">(minuend, subtrahend) {</span>
      <span class="s2">return </span><span class="s1">minuend - subtrahend;</span>
    <span class="s1">}, </span><span class="s4">0</span><span class="s1">);</span>

    <span class="s0">/** 
     * Computes the sum of the values in `array`. 
     * 
     * @static 
     * @memberOf _ 
     * @since 3.4.0 
     * @category Math 
     * @param {Array} array The array to iterate over. 
     * @returns {number} Returns the sum. 
     * @example 
     * 
     * _.sum([4, 2, 8, 6]); 
     * // =&gt; 20 
     */</span>
    <span class="s2">function </span><span class="s1">sum(array) {</span>
      <span class="s2">return </span><span class="s1">(array &amp;&amp; array.length)</span>
        <span class="s1">? baseSum(array, identity)</span>
        <span class="s1">: </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * This method is like `_.sum` except that it accepts `iteratee` which is 
     * invoked for each element in `array` to generate the value to be summed. 
     * The iteratee is invoked with one argument: (value). 
     * 
     * @static 
     * @memberOf _ 
     * @since 4.0.0 
     * @category Math 
     * @param {Array} array The array to iterate over. 
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element. 
     * @returns {number} Returns the sum. 
     * @example 
     * 
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }]; 
     * 
     * _.sumBy(objects, function(o) { return o.n; }); 
     * // =&gt; 20 
     * 
     * // The `_.property` iteratee shorthand. 
     * _.sumBy(objects, 'n'); 
     * // =&gt; 20 
     */</span>
    <span class="s2">function </span><span class="s1">sumBy(array, iteratee) {</span>
      <span class="s2">return </span><span class="s1">(array &amp;&amp; array.length)</span>
        <span class="s1">? baseSum(array, getIteratee(iteratee, </span><span class="s4">2</span><span class="s1">))</span>
        <span class="s1">: </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">/*------------------------------------------------------------------------*/</span>

    <span class="s0">// Add methods that return wrapped values in chain sequences.</span>
    <span class="s1">lodash.after = after;</span>
    <span class="s1">lodash.ary = ary;</span>
    <span class="s1">lodash.assign = assign;</span>
    <span class="s1">lodash.assignIn = assignIn;</span>
    <span class="s1">lodash.assignInWith = assignInWith;</span>
    <span class="s1">lodash.assignWith = assignWith;</span>
    <span class="s1">lodash.at = at;</span>
    <span class="s1">lodash.before = before;</span>
    <span class="s1">lodash.bind = bind;</span>
    <span class="s1">lodash.bindAll = bindAll;</span>
    <span class="s1">lodash.bindKey = bindKey;</span>
    <span class="s1">lodash.castArray = castArray;</span>
    <span class="s1">lodash.chain = chain;</span>
    <span class="s1">lodash.chunk = chunk;</span>
    <span class="s1">lodash.compact = compact;</span>
    <span class="s1">lodash.concat = concat;</span>
    <span class="s1">lodash.cond = cond;</span>
    <span class="s1">lodash.conforms = conforms;</span>
    <span class="s1">lodash.constant = constant;</span>
    <span class="s1">lodash.countBy = countBy;</span>
    <span class="s1">lodash.create = create;</span>
    <span class="s1">lodash.curry = curry;</span>
    <span class="s1">lodash.curryRight = curryRight;</span>
    <span class="s1">lodash.debounce = debounce;</span>
    <span class="s1">lodash.defaults = defaults;</span>
    <span class="s1">lodash.defaultsDeep = defaultsDeep;</span>
    <span class="s1">lodash.defer = defer;</span>
    <span class="s1">lodash.delay = delay;</span>
    <span class="s1">lodash.difference = difference;</span>
    <span class="s1">lodash.differenceBy = differenceBy;</span>
    <span class="s1">lodash.differenceWith = differenceWith;</span>
    <span class="s1">lodash.drop = drop;</span>
    <span class="s1">lodash.dropRight = dropRight;</span>
    <span class="s1">lodash.dropRightWhile = dropRightWhile;</span>
    <span class="s1">lodash.dropWhile = dropWhile;</span>
    <span class="s1">lodash.fill = fill;</span>
    <span class="s1">lodash.filter = filter;</span>
    <span class="s1">lodash.flatMap = flatMap;</span>
    <span class="s1">lodash.flatMapDeep = flatMapDeep;</span>
    <span class="s1">lodash.flatMapDepth = flatMapDepth;</span>
    <span class="s1">lodash.flatten = flatten;</span>
    <span class="s1">lodash.flattenDeep = flattenDeep;</span>
    <span class="s1">lodash.flattenDepth = flattenDepth;</span>
    <span class="s1">lodash.flip = flip;</span>
    <span class="s1">lodash.flow = flow;</span>
    <span class="s1">lodash.flowRight = flowRight;</span>
    <span class="s1">lodash.fromPairs = fromPairs;</span>
    <span class="s1">lodash.functions = functions;</span>
    <span class="s1">lodash.functionsIn = functionsIn;</span>
    <span class="s1">lodash.groupBy = groupBy;</span>
    <span class="s1">lodash.initial = initial;</span>
    <span class="s1">lodash.intersection = intersection;</span>
    <span class="s1">lodash.intersectionBy = intersectionBy;</span>
    <span class="s1">lodash.intersectionWith = intersectionWith;</span>
    <span class="s1">lodash.invert = invert;</span>
    <span class="s1">lodash.invertBy = invertBy;</span>
    <span class="s1">lodash.invokeMap = invokeMap;</span>
    <span class="s1">lodash.iteratee = iteratee;</span>
    <span class="s1">lodash.keyBy = keyBy;</span>
    <span class="s1">lodash.keys = keys;</span>
    <span class="s1">lodash.keysIn = keysIn;</span>
    <span class="s1">lodash.map = map;</span>
    <span class="s1">lodash.mapKeys = mapKeys;</span>
    <span class="s1">lodash.mapValues = mapValues;</span>
    <span class="s1">lodash.matches = matches;</span>
    <span class="s1">lodash.matchesProperty = matchesProperty;</span>
    <span class="s1">lodash.memoize = memoize;</span>
    <span class="s1">lodash.merge = merge;</span>
    <span class="s1">lodash.mergeWith = mergeWith;</span>
    <span class="s1">lodash.method = method;</span>
    <span class="s1">lodash.methodOf = methodOf;</span>
    <span class="s1">lodash.mixin = mixin;</span>
    <span class="s1">lodash.negate = negate;</span>
    <span class="s1">lodash.nthArg = nthArg;</span>
    <span class="s1">lodash.omit = omit;</span>
    <span class="s1">lodash.omitBy = omitBy;</span>
    <span class="s1">lodash.once = once;</span>
    <span class="s1">lodash.orderBy = orderBy;</span>
    <span class="s1">lodash.over = over;</span>
    <span class="s1">lodash.overArgs = overArgs;</span>
    <span class="s1">lodash.overEvery = overEvery;</span>
    <span class="s1">lodash.overSome = overSome;</span>
    <span class="s1">lodash.partial = partial;</span>
    <span class="s1">lodash.partialRight = partialRight;</span>
    <span class="s1">lodash.partition = partition;</span>
    <span class="s1">lodash.pick = pick;</span>
    <span class="s1">lodash.pickBy = pickBy;</span>
    <span class="s1">lodash.property = property;</span>
    <span class="s1">lodash.propertyOf = propertyOf;</span>
    <span class="s1">lodash.pull = pull;</span>
    <span class="s1">lodash.pullAll = pullAll;</span>
    <span class="s1">lodash.pullAllBy = pullAllBy;</span>
    <span class="s1">lodash.pullAllWith = pullAllWith;</span>
    <span class="s1">lodash.pullAt = pullAt;</span>
    <span class="s1">lodash.range = range;</span>
    <span class="s1">lodash.rangeRight = rangeRight;</span>
    <span class="s1">lodash.rearg = rearg;</span>
    <span class="s1">lodash.reject = reject;</span>
    <span class="s1">lodash.remove = remove;</span>
    <span class="s1">lodash.rest = rest;</span>
    <span class="s1">lodash.reverse = reverse;</span>
    <span class="s1">lodash.sampleSize = sampleSize;</span>
    <span class="s1">lodash.set = set;</span>
    <span class="s1">lodash.setWith = setWith;</span>
    <span class="s1">lodash.shuffle = shuffle;</span>
    <span class="s1">lodash.slice = slice;</span>
    <span class="s1">lodash.sortBy = sortBy;</span>
    <span class="s1">lodash.sortedUniq = sortedUniq;</span>
    <span class="s1">lodash.sortedUniqBy = sortedUniqBy;</span>
    <span class="s1">lodash.split = split;</span>
    <span class="s1">lodash.spread = spread;</span>
    <span class="s1">lodash.tail = tail;</span>
    <span class="s1">lodash.take = take;</span>
    <span class="s1">lodash.takeRight = takeRight;</span>
    <span class="s1">lodash.takeRightWhile = takeRightWhile;</span>
    <span class="s1">lodash.takeWhile = takeWhile;</span>
    <span class="s1">lodash.tap = tap;</span>
    <span class="s1">lodash.throttle = throttle;</span>
    <span class="s1">lodash.thru = thru;</span>
    <span class="s1">lodash.toArray = toArray;</span>
    <span class="s1">lodash.toPairs = toPairs;</span>
    <span class="s1">lodash.toPairsIn = toPairsIn;</span>
    <span class="s1">lodash.toPath = toPath;</span>
    <span class="s1">lodash.toPlainObject = toPlainObject;</span>
    <span class="s1">lodash.transform = transform;</span>
    <span class="s1">lodash.unary = unary;</span>
    <span class="s1">lodash.union = union;</span>
    <span class="s1">lodash.unionBy = unionBy;</span>
    <span class="s1">lodash.unionWith = unionWith;</span>
    <span class="s1">lodash.uniq = uniq;</span>
    <span class="s1">lodash.uniqBy = uniqBy;</span>
    <span class="s1">lodash.uniqWith = uniqWith;</span>
    <span class="s1">lodash.unset = unset;</span>
    <span class="s1">lodash.unzip = unzip;</span>
    <span class="s1">lodash.unzipWith = unzipWith;</span>
    <span class="s1">lodash.update = update;</span>
    <span class="s1">lodash.updateWith = updateWith;</span>
    <span class="s1">lodash.values = values;</span>
    <span class="s1">lodash.valuesIn = valuesIn;</span>
    <span class="s1">lodash.without = without;</span>
    <span class="s1">lodash.words = words;</span>
    <span class="s1">lodash.wrap = wrap;</span>
    <span class="s1">lodash.xor = xor;</span>
    <span class="s1">lodash.xorBy = xorBy;</span>
    <span class="s1">lodash.xorWith = xorWith;</span>
    <span class="s1">lodash.zip = zip;</span>
    <span class="s1">lodash.zipObject = zipObject;</span>
    <span class="s1">lodash.zipObjectDeep = zipObjectDeep;</span>
    <span class="s1">lodash.zipWith = zipWith;</span>

    <span class="s0">// Add aliases.</span>
    <span class="s1">lodash.entries = toPairs;</span>
    <span class="s1">lodash.entriesIn = toPairsIn;</span>
    <span class="s1">lodash.extend = assignIn;</span>
    <span class="s1">lodash.extendWith = assignInWith;</span>

    <span class="s0">// Add methods to `lodash.prototype`.</span>
    <span class="s1">mixin(lodash, lodash);</span>

    <span class="s0">/*------------------------------------------------------------------------*/</span>

    <span class="s0">// Add methods that return unwrapped values in chain sequences.</span>
    <span class="s1">lodash.add = add;</span>
    <span class="s1">lodash.attempt = attempt;</span>
    <span class="s1">lodash.camelCase = camelCase;</span>
    <span class="s1">lodash.capitalize = capitalize;</span>
    <span class="s1">lodash.ceil = ceil;</span>
    <span class="s1">lodash.clamp = clamp;</span>
    <span class="s1">lodash.clone = clone;</span>
    <span class="s1">lodash.cloneDeep = cloneDeep;</span>
    <span class="s1">lodash.cloneDeepWith = cloneDeepWith;</span>
    <span class="s1">lodash.cloneWith = cloneWith;</span>
    <span class="s1">lodash.conformsTo = conformsTo;</span>
    <span class="s1">lodash.deburr = deburr;</span>
    <span class="s1">lodash.defaultTo = defaultTo;</span>
    <span class="s1">lodash.divide = divide;</span>
    <span class="s1">lodash.endsWith = endsWith;</span>
    <span class="s1">lodash.eq = eq;</span>
    <span class="s1">lodash.escape = escape;</span>
    <span class="s1">lodash.escapeRegExp = escapeRegExp;</span>
    <span class="s1">lodash.every = every;</span>
    <span class="s1">lodash.find = find;</span>
    <span class="s1">lodash.findIndex = findIndex;</span>
    <span class="s1">lodash.findKey = findKey;</span>
    <span class="s1">lodash.findLast = findLast;</span>
    <span class="s1">lodash.findLastIndex = findLastIndex;</span>
    <span class="s1">lodash.findLastKey = findLastKey;</span>
    <span class="s1">lodash.floor = floor;</span>
    <span class="s1">lodash.forEach = forEach;</span>
    <span class="s1">lodash.forEachRight = forEachRight;</span>
    <span class="s1">lodash.forIn = forIn;</span>
    <span class="s1">lodash.forInRight = forInRight;</span>
    <span class="s1">lodash.forOwn = forOwn;</span>
    <span class="s1">lodash.forOwnRight = forOwnRight;</span>
    <span class="s1">lodash.get = get;</span>
    <span class="s1">lodash.gt = gt;</span>
    <span class="s1">lodash.gte = gte;</span>
    <span class="s1">lodash.has = has;</span>
    <span class="s1">lodash.hasIn = hasIn;</span>
    <span class="s1">lodash.head = head;</span>
    <span class="s1">lodash.identity = identity;</span>
    <span class="s1">lodash.includes = includes;</span>
    <span class="s1">lodash.indexOf = indexOf;</span>
    <span class="s1">lodash.inRange = inRange;</span>
    <span class="s1">lodash.invoke = invoke;</span>
    <span class="s1">lodash.isArguments = isArguments;</span>
    <span class="s1">lodash.isArray = isArray;</span>
    <span class="s1">lodash.isArrayBuffer = isArrayBuffer;</span>
    <span class="s1">lodash.isArrayLike = isArrayLike;</span>
    <span class="s1">lodash.isArrayLikeObject = isArrayLikeObject;</span>
    <span class="s1">lodash.isBoolean = isBoolean;</span>
    <span class="s1">lodash.isBuffer = isBuffer;</span>
    <span class="s1">lodash.isDate = isDate;</span>
    <span class="s1">lodash.isElement = isElement;</span>
    <span class="s1">lodash.isEmpty = isEmpty;</span>
    <span class="s1">lodash.isEqual = isEqual;</span>
    <span class="s1">lodash.isEqualWith = isEqualWith;</span>
    <span class="s1">lodash.isError = isError;</span>
    <span class="s1">lodash.isFinite = isFinite;</span>
    <span class="s1">lodash.isFunction = isFunction;</span>
    <span class="s1">lodash.isInteger = isInteger;</span>
    <span class="s1">lodash.isLength = isLength;</span>
    <span class="s1">lodash.isMap = isMap;</span>
    <span class="s1">lodash.isMatch = isMatch;</span>
    <span class="s1">lodash.isMatchWith = isMatchWith;</span>
    <span class="s1">lodash.isNaN = isNaN;</span>
    <span class="s1">lodash.isNative = isNative;</span>
    <span class="s1">lodash.isNil = isNil;</span>
    <span class="s1">lodash.isNull = isNull;</span>
    <span class="s1">lodash.isNumber = isNumber;</span>
    <span class="s1">lodash.isObject = isObject;</span>
    <span class="s1">lodash.isObjectLike = isObjectLike;</span>
    <span class="s1">lodash.isPlainObject = isPlainObject;</span>
    <span class="s1">lodash.isRegExp = isRegExp;</span>
    <span class="s1">lodash.isSafeInteger = isSafeInteger;</span>
    <span class="s1">lodash.isSet = isSet;</span>
    <span class="s1">lodash.isString = isString;</span>
    <span class="s1">lodash.isSymbol = isSymbol;</span>
    <span class="s1">lodash.isTypedArray = isTypedArray;</span>
    <span class="s1">lodash.isUndefined = isUndefined;</span>
    <span class="s1">lodash.isWeakMap = isWeakMap;</span>
    <span class="s1">lodash.isWeakSet = isWeakSet;</span>
    <span class="s1">lodash.join = join;</span>
    <span class="s1">lodash.kebabCase = kebabCase;</span>
    <span class="s1">lodash.last = last;</span>
    <span class="s1">lodash.lastIndexOf = lastIndexOf;</span>
    <span class="s1">lodash.lowerCase = lowerCase;</span>
    <span class="s1">lodash.lowerFirst = lowerFirst;</span>
    <span class="s1">lodash.lt = lt;</span>
    <span class="s1">lodash.lte = lte;</span>
    <span class="s1">lodash.max = max;</span>
    <span class="s1">lodash.maxBy = maxBy;</span>
    <span class="s1">lodash.mean = mean;</span>
    <span class="s1">lodash.meanBy = meanBy;</span>
    <span class="s1">lodash.min = min;</span>
    <span class="s1">lodash.minBy = minBy;</span>
    <span class="s1">lodash.stubArray = stubArray;</span>
    <span class="s1">lodash.stubFalse = stubFalse;</span>
    <span class="s1">lodash.stubObject = stubObject;</span>
    <span class="s1">lodash.stubString = stubString;</span>
    <span class="s1">lodash.stubTrue = stubTrue;</span>
    <span class="s1">lodash.multiply = multiply;</span>
    <span class="s1">lodash.nth = nth;</span>
    <span class="s1">lodash.noConflict = noConflict;</span>
    <span class="s1">lodash.noop = noop;</span>
    <span class="s1">lodash.now = now;</span>
    <span class="s1">lodash.pad = pad;</span>
    <span class="s1">lodash.padEnd = padEnd;</span>
    <span class="s1">lodash.padStart = padStart;</span>
    <span class="s1">lodash.parseInt = parseInt;</span>
    <span class="s1">lodash.random = random;</span>
    <span class="s1">lodash.reduce = reduce;</span>
    <span class="s1">lodash.reduceRight = reduceRight;</span>
    <span class="s1">lodash.repeat = repeat;</span>
    <span class="s1">lodash.replace = replace;</span>
    <span class="s1">lodash.result = result;</span>
    <span class="s1">lodash.round = round;</span>
    <span class="s1">lodash.runInContext = runInContext;</span>
    <span class="s1">lodash.sample = sample;</span>
    <span class="s1">lodash.size = size;</span>
    <span class="s1">lodash.snakeCase = snakeCase;</span>
    <span class="s1">lodash.some = some;</span>
    <span class="s1">lodash.sortedIndex = sortedIndex;</span>
    <span class="s1">lodash.sortedIndexBy = sortedIndexBy;</span>
    <span class="s1">lodash.sortedIndexOf = sortedIndexOf;</span>
    <span class="s1">lodash.sortedLastIndex = sortedLastIndex;</span>
    <span class="s1">lodash.sortedLastIndexBy = sortedLastIndexBy;</span>
    <span class="s1">lodash.sortedLastIndexOf = sortedLastIndexOf;</span>
    <span class="s1">lodash.startCase = startCase;</span>
    <span class="s1">lodash.startsWith = startsWith;</span>
    <span class="s1">lodash.subtract = subtract;</span>
    <span class="s1">lodash.sum = sum;</span>
    <span class="s1">lodash.sumBy = sumBy;</span>
    <span class="s1">lodash.template = template;</span>
    <span class="s1">lodash.times = times;</span>
    <span class="s1">lodash.toFinite = toFinite;</span>
    <span class="s1">lodash.toInteger = toInteger;</span>
    <span class="s1">lodash.toLength = toLength;</span>
    <span class="s1">lodash.toLower = toLower;</span>
    <span class="s1">lodash.toNumber = toNumber;</span>
    <span class="s1">lodash.toSafeInteger = toSafeInteger;</span>
    <span class="s1">lodash.toString = toString;</span>
    <span class="s1">lodash.toUpper = toUpper;</span>
    <span class="s1">lodash.trim = trim;</span>
    <span class="s1">lodash.trimEnd = trimEnd;</span>
    <span class="s1">lodash.trimStart = trimStart;</span>
    <span class="s1">lodash.truncate = truncate;</span>
    <span class="s1">lodash.unescape = unescape;</span>
    <span class="s1">lodash.uniqueId = uniqueId;</span>
    <span class="s1">lodash.upperCase = upperCase;</span>
    <span class="s1">lodash.upperFirst = upperFirst;</span>

    <span class="s0">// Add aliases.</span>
    <span class="s1">lodash.each = forEach;</span>
    <span class="s1">lodash.eachRight = forEachRight;</span>
    <span class="s1">lodash.first = head;</span>

    <span class="s1">mixin(lodash, (</span><span class="s2">function</span><span class="s1">() {</span>
      <span class="s2">var </span><span class="s1">source = {};</span>
      <span class="s1">baseForOwn(lodash, </span><span class="s2">function</span><span class="s1">(func, methodName) {</span>
        <span class="s2">if </span><span class="s1">(!hasOwnProperty.call(lodash.prototype, methodName)) {</span>
          <span class="s1">source[methodName] = func;</span>
        <span class="s1">}</span>
      <span class="s1">});</span>
      <span class="s2">return </span><span class="s1">source;</span>
    <span class="s1">}()), { </span><span class="s3">'chain'</span><span class="s1">: </span><span class="s2">false </span><span class="s1">});</span>

    <span class="s0">/*------------------------------------------------------------------------*/</span>

    <span class="s0">/** 
     * The semantic version number. 
     * 
     * @static 
     * @memberOf _ 
     * @type {string} 
     */</span>
    <span class="s1">lodash.VERSION = VERSION;</span>

    <span class="s0">// Assign default placeholders.</span>
    <span class="s1">arrayEach([</span><span class="s3">'bind'</span><span class="s1">, </span><span class="s3">'bindKey'</span><span class="s1">, </span><span class="s3">'curry'</span><span class="s1">, </span><span class="s3">'curryRight'</span><span class="s1">, </span><span class="s3">'partial'</span><span class="s1">, </span><span class="s3">'partialRight'</span><span class="s1">], </span><span class="s2">function</span><span class="s1">(methodName) {</span>
      <span class="s1">lodash[methodName].placeholder = lodash;</span>
    <span class="s1">});</span>

    <span class="s0">// Add `LazyWrapper` methods for `_.drop` and `_.take` variants.</span>
    <span class="s1">arrayEach([</span><span class="s3">'drop'</span><span class="s1">, </span><span class="s3">'take'</span><span class="s1">], </span><span class="s2">function</span><span class="s1">(methodName, index) {</span>
      <span class="s1">LazyWrapper.prototype[methodName] = </span><span class="s2">function</span><span class="s1">(n) {</span>
        <span class="s1">n = n === undefined ? </span><span class="s4">1 </span><span class="s1">: nativeMax(toInteger(n), </span><span class="s4">0</span><span class="s1">);</span>

        <span class="s2">var </span><span class="s1">result = (</span><span class="s2">this</span><span class="s1">.__filtered__ &amp;&amp; !index)</span>
          <span class="s1">? </span><span class="s2">new </span><span class="s1">LazyWrapper(</span><span class="s2">this</span><span class="s1">)</span>
          <span class="s1">: </span><span class="s2">this</span><span class="s1">.clone();</span>

        <span class="s2">if </span><span class="s1">(result.__filtered__) {</span>
          <span class="s1">result.__takeCount__ = nativeMin(n, result.__takeCount__);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">result.__views__.push({</span>
            <span class="s3">'size'</span><span class="s1">: nativeMin(n, MAX_ARRAY_LENGTH),</span>
            <span class="s3">'type'</span><span class="s1">: methodName + (result.__dir__ &lt; </span><span class="s4">0 </span><span class="s1">? </span><span class="s3">'Right' </span><span class="s1">: </span><span class="s3">''</span><span class="s1">)</span>
          <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">result;</span>
      <span class="s1">};</span>

      <span class="s1">LazyWrapper.prototype[methodName + </span><span class="s3">'Right'</span><span class="s1">] = </span><span class="s2">function</span><span class="s1">(n) {</span>
        <span class="s2">return this</span><span class="s1">.reverse()[methodName](n).reverse();</span>
      <span class="s1">};</span>
    <span class="s1">});</span>

    <span class="s0">// Add `LazyWrapper` methods that accept an `iteratee` value.</span>
    <span class="s1">arrayEach([</span><span class="s3">'filter'</span><span class="s1">, </span><span class="s3">'map'</span><span class="s1">, </span><span class="s3">'takeWhile'</span><span class="s1">], </span><span class="s2">function</span><span class="s1">(methodName, index) {</span>
      <span class="s2">var </span><span class="s1">type = index + </span><span class="s4">1</span><span class="s1">,</span>
          <span class="s1">isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;</span>

      <span class="s1">LazyWrapper.prototype[methodName] = </span><span class="s2">function</span><span class="s1">(iteratee) {</span>
        <span class="s2">var </span><span class="s1">result = </span><span class="s2">this</span><span class="s1">.clone();</span>
        <span class="s1">result.__iteratees__.push({</span>
          <span class="s3">'iteratee'</span><span class="s1">: getIteratee(iteratee, </span><span class="s4">3</span><span class="s1">),</span>
          <span class="s3">'type'</span><span class="s1">: type</span>
        <span class="s1">});</span>
        <span class="s1">result.__filtered__ = result.__filtered__ || isFilter;</span>
        <span class="s2">return </span><span class="s1">result;</span>
      <span class="s1">};</span>
    <span class="s1">});</span>

    <span class="s0">// Add `LazyWrapper` methods for `_.head` and `_.last`.</span>
    <span class="s1">arrayEach([</span><span class="s3">'head'</span><span class="s1">, </span><span class="s3">'last'</span><span class="s1">], </span><span class="s2">function</span><span class="s1">(methodName, index) {</span>
      <span class="s2">var </span><span class="s1">takeName = </span><span class="s3">'take' </span><span class="s1">+ (index ? </span><span class="s3">'Right' </span><span class="s1">: </span><span class="s3">''</span><span class="s1">);</span>

      <span class="s1">LazyWrapper.prototype[methodName] = </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return this</span><span class="s1">[takeName](</span><span class="s4">1</span><span class="s1">).value()[</span><span class="s4">0</span><span class="s1">];</span>
      <span class="s1">};</span>
    <span class="s1">});</span>

    <span class="s0">// Add `LazyWrapper` methods for `_.initial` and `_.tail`.</span>
    <span class="s1">arrayEach([</span><span class="s3">'initial'</span><span class="s1">, </span><span class="s3">'tail'</span><span class="s1">], </span><span class="s2">function</span><span class="s1">(methodName, index) {</span>
      <span class="s2">var </span><span class="s1">dropName = </span><span class="s3">'drop' </span><span class="s1">+ (index ? </span><span class="s3">'' </span><span class="s1">: </span><span class="s3">'Right'</span><span class="s1">);</span>

      <span class="s1">LazyWrapper.prototype[methodName] = </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return this</span><span class="s1">.__filtered__ ? </span><span class="s2">new </span><span class="s1">LazyWrapper(</span><span class="s2">this</span><span class="s1">) : </span><span class="s2">this</span><span class="s1">[dropName](</span><span class="s4">1</span><span class="s1">);</span>
      <span class="s1">};</span>
    <span class="s1">});</span>

    <span class="s1">LazyWrapper.prototype.compact = </span><span class="s2">function</span><span class="s1">() {</span>
      <span class="s2">return this</span><span class="s1">.filter(identity);</span>
    <span class="s1">};</span>

    <span class="s1">LazyWrapper.prototype.find = </span><span class="s2">function</span><span class="s1">(predicate) {</span>
      <span class="s2">return this</span><span class="s1">.filter(predicate).head();</span>
    <span class="s1">};</span>

    <span class="s1">LazyWrapper.prototype.findLast = </span><span class="s2">function</span><span class="s1">(predicate) {</span>
      <span class="s2">return this</span><span class="s1">.reverse().find(predicate);</span>
    <span class="s1">};</span>

    <span class="s1">LazyWrapper.prototype.invokeMap = baseRest(</span><span class="s2">function</span><span class="s1">(path, args) {</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">path == </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s2">return new </span><span class="s1">LazyWrapper(</span><span class="s2">this</span><span class="s1">);</span>
      <span class="s1">}</span>
      <span class="s2">return this</span><span class="s1">.map(</span><span class="s2">function</span><span class="s1">(value) {</span>
        <span class="s2">return </span><span class="s1">baseInvoke(value, path, args);</span>
      <span class="s1">});</span>
    <span class="s1">});</span>

    <span class="s1">LazyWrapper.prototype.reject = </span><span class="s2">function</span><span class="s1">(predicate) {</span>
      <span class="s2">return this</span><span class="s1">.filter(negate(getIteratee(predicate)));</span>
    <span class="s1">};</span>

    <span class="s1">LazyWrapper.prototype.slice = </span><span class="s2">function</span><span class="s1">(start, end) {</span>
      <span class="s1">start = toInteger(start);</span>

      <span class="s2">var </span><span class="s1">result = </span><span class="s2">this</span><span class="s1">;</span>
      <span class="s2">if </span><span class="s1">(result.__filtered__ &amp;&amp; (start &gt; </span><span class="s4">0 </span><span class="s1">|| end &lt; </span><span class="s4">0</span><span class="s1">)) {</span>
        <span class="s2">return new </span><span class="s1">LazyWrapper(result);</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(start &lt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">result = result.takeRight(-start);</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(start) {</span>
        <span class="s1">result = result.drop(start);</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(end !== undefined) {</span>
        <span class="s1">end = toInteger(end);</span>
        <span class="s1">result = end &lt; </span><span class="s4">0 </span><span class="s1">? result.dropRight(-end) : result.take(end - start);</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">};</span>

    <span class="s1">LazyWrapper.prototype.takeRightWhile = </span><span class="s2">function</span><span class="s1">(predicate) {</span>
      <span class="s2">return this</span><span class="s1">.reverse().takeWhile(predicate).reverse();</span>
    <span class="s1">};</span>

    <span class="s1">LazyWrapper.prototype.toArray = </span><span class="s2">function</span><span class="s1">() {</span>
      <span class="s2">return this</span><span class="s1">.take(MAX_ARRAY_LENGTH);</span>
    <span class="s1">};</span>

    <span class="s0">// Add `LazyWrapper` methods to `lodash.prototype`.</span>
    <span class="s1">baseForOwn(LazyWrapper.prototype, </span><span class="s2">function</span><span class="s1">(func, methodName) {</span>
      <span class="s2">var </span><span class="s1">checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),</span>
          <span class="s1">isTaker = /^(?:head|last)$/.test(methodName),</span>
          <span class="s1">lodashFunc = lodash[isTaker ? (</span><span class="s3">'take' </span><span class="s1">+ (methodName == </span><span class="s3">'last' </span><span class="s1">? </span><span class="s3">'Right' </span><span class="s1">: </span><span class="s3">''</span><span class="s1">)) : methodName],</span>
          <span class="s1">retUnwrapped = isTaker || /^find/.test(methodName);</span>

      <span class="s2">if </span><span class="s1">(!lodashFunc) {</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s1">lodash.prototype[methodName] = </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">var </span><span class="s1">value = </span><span class="s2">this</span><span class="s1">.__wrapped__,</span>
            <span class="s1">args = isTaker ? [</span><span class="s4">1</span><span class="s1">] : arguments,</span>
            <span class="s1">isLazy = value </span><span class="s2">instanceof </span><span class="s1">LazyWrapper,</span>
            <span class="s1">iteratee = args[</span><span class="s4">0</span><span class="s1">],</span>
            <span class="s1">useLazy = isLazy || isArray(value);</span>

        <span class="s2">var </span><span class="s1">interceptor = </span><span class="s2">function</span><span class="s1">(value) {</span>
          <span class="s2">var </span><span class="s1">result = lodashFunc.apply(lodash, arrayPush([value], args));</span>
          <span class="s2">return </span><span class="s1">(isTaker &amp;&amp; chainAll) ? result[</span><span class="s4">0</span><span class="s1">] : result;</span>
        <span class="s1">};</span>

        <span class="s2">if </span><span class="s1">(useLazy &amp;&amp; checkIteratee &amp;&amp; </span><span class="s2">typeof </span><span class="s1">iteratee == </span><span class="s3">'function' </span><span class="s1">&amp;&amp; iteratee.length != </span><span class="s4">1</span><span class="s1">) {</span>
          <span class="s0">// Avoid lazy use if the iteratee has a &quot;length&quot; value other than `1`.</span>
          <span class="s1">isLazy = useLazy = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">var </span><span class="s1">chainAll = </span><span class="s2">this</span><span class="s1">.__chain__,</span>
            <span class="s1">isHybrid = !!</span><span class="s2">this</span><span class="s1">.__actions__.length,</span>
            <span class="s1">isUnwrapped = retUnwrapped &amp;&amp; !chainAll,</span>
            <span class="s1">onlyLazy = isLazy &amp;&amp; !isHybrid;</span>

        <span class="s2">if </span><span class="s1">(!retUnwrapped &amp;&amp; useLazy) {</span>
          <span class="s1">value = onlyLazy ? value : </span><span class="s2">new </span><span class="s1">LazyWrapper(</span><span class="s2">this</span><span class="s1">);</span>
          <span class="s2">var </span><span class="s1">result = func.apply(value, args);</span>
          <span class="s1">result.__actions__.push({ </span><span class="s3">'func'</span><span class="s1">: thru, </span><span class="s3">'args'</span><span class="s1">: [interceptor], </span><span class="s3">'thisArg'</span><span class="s1">: undefined });</span>
          <span class="s2">return new </span><span class="s1">LodashWrapper(result, chainAll);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(isUnwrapped &amp;&amp; onlyLazy) {</span>
          <span class="s2">return </span><span class="s1">func.apply(</span><span class="s2">this</span><span class="s1">, args);</span>
        <span class="s1">}</span>
        <span class="s1">result = </span><span class="s2">this</span><span class="s1">.thru(interceptor);</span>
        <span class="s2">return </span><span class="s1">isUnwrapped ? (isTaker ? result.value()[</span><span class="s4">0</span><span class="s1">] : result.value()) : result;</span>
      <span class="s1">};</span>
    <span class="s1">});</span>

    <span class="s0">// Add `Array` methods to `lodash.prototype`.</span>
    <span class="s1">arrayEach([</span><span class="s3">'pop'</span><span class="s1">, </span><span class="s3">'push'</span><span class="s1">, </span><span class="s3">'shift'</span><span class="s1">, </span><span class="s3">'sort'</span><span class="s1">, </span><span class="s3">'splice'</span><span class="s1">, </span><span class="s3">'unshift'</span><span class="s1">], </span><span class="s2">function</span><span class="s1">(methodName) {</span>
      <span class="s2">var </span><span class="s1">func = arrayProto[methodName],</span>
          <span class="s1">chainName = /^(?:push|sort|unshift)$/.test(methodName) ? </span><span class="s3">'tap' </span><span class="s1">: </span><span class="s3">'thru'</span><span class="s1">,</span>
          <span class="s1">retUnwrapped = /^(?:pop|shift)$/.test(methodName);</span>

      <span class="s1">lodash.prototype[methodName] = </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">var </span><span class="s1">args = arguments;</span>
        <span class="s2">if </span><span class="s1">(retUnwrapped &amp;&amp; !</span><span class="s2">this</span><span class="s1">.__chain__) {</span>
          <span class="s2">var </span><span class="s1">value = </span><span class="s2">this</span><span class="s1">.value();</span>
          <span class="s2">return </span><span class="s1">func.apply(isArray(value) ? value : [], args);</span>
        <span class="s1">}</span>
        <span class="s2">return this</span><span class="s1">[chainName](</span><span class="s2">function</span><span class="s1">(value) {</span>
          <span class="s2">return </span><span class="s1">func.apply(isArray(value) ? value : [], args);</span>
        <span class="s1">});</span>
      <span class="s1">};</span>
    <span class="s1">});</span>

    <span class="s0">// Map minified method names to their real names.</span>
    <span class="s1">baseForOwn(LazyWrapper.prototype, </span><span class="s2">function</span><span class="s1">(func, methodName) {</span>
      <span class="s2">var </span><span class="s1">lodashFunc = lodash[methodName];</span>
      <span class="s2">if </span><span class="s1">(lodashFunc) {</span>
        <span class="s2">var </span><span class="s1">key = lodashFunc.name + </span><span class="s3">''</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(!hasOwnProperty.call(realNames, key)) {</span>
          <span class="s1">realNames[key] = [];</span>
        <span class="s1">}</span>
        <span class="s1">realNames[key].push({ </span><span class="s3">'name'</span><span class="s1">: methodName, </span><span class="s3">'func'</span><span class="s1">: lodashFunc });</span>
      <span class="s1">}</span>
    <span class="s1">});</span>

    <span class="s1">realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{</span>
      <span class="s3">'name'</span><span class="s1">: </span><span class="s3">'wrapper'</span><span class="s1">,</span>
      <span class="s3">'func'</span><span class="s1">: undefined</span>
    <span class="s1">}];</span>

    <span class="s0">// Add methods to `LazyWrapper`.</span>
    <span class="s1">LazyWrapper.prototype.clone = lazyClone;</span>
    <span class="s1">LazyWrapper.prototype.reverse = lazyReverse;</span>
    <span class="s1">LazyWrapper.prototype.value = lazyValue;</span>

    <span class="s0">// Add chain sequence methods to the `lodash` wrapper.</span>
    <span class="s1">lodash.prototype.at = wrapperAt;</span>
    <span class="s1">lodash.prototype.chain = wrapperChain;</span>
    <span class="s1">lodash.prototype.commit = wrapperCommit;</span>
    <span class="s1">lodash.prototype.next = wrapperNext;</span>
    <span class="s1">lodash.prototype.plant = wrapperPlant;</span>
    <span class="s1">lodash.prototype.reverse = wrapperReverse;</span>
    <span class="s1">lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;</span>

    <span class="s0">// Add lazy aliases.</span>
    <span class="s1">lodash.prototype.first = lodash.prototype.head;</span>

    <span class="s2">if </span><span class="s1">(symIterator) {</span>
      <span class="s1">lodash.prototype[symIterator] = wrapperToIterator;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">lodash;</span>
  <span class="s1">});</span>

  <span class="s0">/*--------------------------------------------------------------------------*/</span>

  <span class="s0">// Export lodash.</span>
  <span class="s2">var </span><span class="s1">_ = runInContext();</span>

  <span class="s0">// Some AMD build optimizers, like r.js, check for condition patterns like:</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">define == </span><span class="s3">'function' </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">define.amd == </span><span class="s3">'object' </span><span class="s1">&amp;&amp; define.amd) {</span>
    <span class="s0">// Expose Lodash on the global object to prevent errors when Lodash is</span>
    <span class="s0">// loaded by a script tag in the presence of an AMD loader.</span>
    <span class="s0">// See http://requirejs.org/docs/errors.html#mismatch for more details.</span>
    <span class="s0">// Use `_.noConflict` to remove Lodash from the global object.</span>
    <span class="s1">root._ = _;</span>

    <span class="s0">// Define as an anonymous module so, through path mapping, it can be</span>
    <span class="s0">// referenced as the &quot;underscore&quot; module.</span>
    <span class="s1">define(</span><span class="s2">function</span><span class="s1">() {</span>
      <span class="s2">return </span><span class="s1">_;</span>
    <span class="s1">});</span>
  <span class="s1">}</span>
  <span class="s0">// Check for `exports` after `define` in case a build optimizer adds it.</span>
  <span class="s2">else if </span><span class="s1">(freeModule) {</span>
    <span class="s0">// Export for Node.js.</span>
    <span class="s1">(freeModule.exports = _)._ = _;</span>
    <span class="s0">// Export for CommonJS support.</span>
    <span class="s1">freeExports._ = _;</span>
  <span class="s1">}</span>
  <span class="s2">else </span><span class="s1">{</span>
    <span class="s0">// Export to the global object.</span>
    <span class="s1">root._ = _;</span>
  <span class="s1">}</span>
<span class="s1">}.call(</span><span class="s2">this</span><span class="s1">));</span>
</pre>
</body>
</html>
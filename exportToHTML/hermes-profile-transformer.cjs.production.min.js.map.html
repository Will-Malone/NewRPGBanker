<html>
<head>
<title>hermes-profile-transformer.cjs.production.min.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
.s1 { color: #6a8759;}
.s2 { color: #6897bb; font-style: italic;}
.s3 { color: #cc7832; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
hermes-profile-transformer.cjs.production.min.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;hermes-profile-transformer.cjs.production.min.js&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../src/types/Phases.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;../src/profiler/cpuProfilerModel.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;../node_modules/babel-plugin-transform-async-to-promises/helpers.js&quot;</span><span class="s0">,</span><span class="s1">&quot;../src/utils/fileSystem.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;../src/profiler/applySourceMapsToEvents.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;../src/index.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;export enum EventsPhase {</span><span class="s3">\n  </span><span class="s1">DURATION_EVENTS_BEGIN = 'B',</span><span class="s3">\n  </span><span class="s1">DURATION_EVENTS_END = 'E',</span><span class="s3">\n  </span><span class="s1">COMPLETE_EVENTS = 'X',</span><span class="s3">\n  </span><span class="s1">INSTANT_EVENTS = 'I',</span><span class="s3">\n  </span><span class="s1">COUNTER_EVENTS = 'C',</span><span class="s3">\n  </span><span class="s1">ASYNC_EVENTS_NESTABLE_START = 'b',</span><span class="s3">\n  </span><span class="s1">ASYNC_EVENTS_NESTABLE_INSTANT = 'n',</span><span class="s3">\n  </span><span class="s1">ASYNC_EVENTS_NESTABLE_END = 'e',</span><span class="s3">\n  </span><span class="s1">FLOW_EVENTS_START = 's',</span><span class="s3">\n  </span><span class="s1">FLOW_EVENTS_STEP = 't',</span><span class="s3">\n  </span><span class="s1">FLOW_EVENTS_END = 'f',</span><span class="s3">\n  </span><span class="s1">SAMPLE_EVENTS = 'P',</span><span class="s3">\n  </span><span class="s1">OBJECT_EVENTS_CREATED = 'N',</span><span class="s3">\n  </span><span class="s1">OBJECT_EVENTS_SNAPSHOT = 'O',</span><span class="s3">\n  </span><span class="s1">OBJECT_EVENTS_DESTROYED = 'D',</span><span class="s3">\n  </span><span class="s1">METADATA_EVENTS = 'M',</span><span class="s3">\n  </span><span class="s1">MEMORY_DUMP_EVENTS_GLOBAL = 'V',</span><span class="s3">\n  </span><span class="s1">MEMORY_DUMP_EVENTS_PROCESS = 'v',</span><span class="s3">\n  </span><span class="s1">MARK_EVENTS = 'R',</span><span class="s3">\n  </span><span class="s1">CLOCK_SYNC_EVENTS = 'c',</span><span class="s3">\n  </span><span class="s1">CONTEXT_EVENTS_ENTER = '(',</span><span class="s3">\n  </span><span class="s1">CONTEXT_EVENTS_LEAVE = ')',</span><span class="s3">\n  </span><span class="s1">// Deprecated</span><span class="s3">\n  </span><span class="s1">ASYNC_EVENTS_START = 'S',</span><span class="s3">\n  </span><span class="s1">ASYNC_EVENTS_STEP_INTO = 'T',</span><span class="s3">\n  </span><span class="s1">ASYNC_EVENTS_STEP_PAST = 'p',</span><span class="s3">\n  </span><span class="s1">ASYNC_EVENTS_END = 'F',</span><span class="s3">\n  </span><span class="s1">LINKED_ID_EVENTS = '=',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* @license Copyright 2020 The Lighthouse Authors. All Rights Reserved.</span><span class="s3">\n </span><span class="s1">* Licensed under the Apache License, Version 2.0 (the </span><span class="s3">\&quot;</span><span class="s1">License</span><span class="s3">\&quot;</span><span class="s1">); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0</span><span class="s3">\n </span><span class="s1">* Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an </span><span class="s3">\&quot;</span><span class="s1">AS IS</span><span class="s3">\&quot; </span><span class="s1">BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* MODIFICATION NOTICE:</span><span class="s3">\n </span><span class="s1">* This file is derived from `https://github.com/GoogleChrome/lighthouse/blob/0422daa9b1b8528dd8436860b153134bd0f959f1/lighthouse-core/lib/tracehouse/cpu-profile-model.js`</span><span class="s3">\n </span><span class="s1">* and has been modified by Saphal Patro (email: saphal1998@gmail.com)</span><span class="s3">\n </span><span class="s1">* The following changes have been made to the original file:</span><span class="s3">\n </span><span class="s1">* 1. Converted code to Typescript and defined necessary types</span><span class="s3">\n </span><span class="s1">* 2. Wrote a method @see collectProfileEvents to convert the Hermes Samples to Profile Chunks supported by Lighthouse Parser</span><span class="s3">\n </span><span class="s1">* 3. Modified @see constructNodes to work with the Hermes Samples and StackFrames</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @fileoverview</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This model converts the `Profile` and `ProfileChunk` mega trace events from the `disabled-by-default-v8.cpu_profiler`</span><span class="s3">\n </span><span class="s1">* category into B/E-style trace events that main-thread-tasks.js already knows how to parse into a task tree.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* The CPU profiler measures where time is being spent by sampling the stack (See https://www.jetbrains.com/help/profiler/Profiling_Guidelines__Choosing_the_Right_Profiling_Mode.html</span><span class="s3">\n </span><span class="s1">* for a generic description of the differences between tracing and sampling).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* A `Profile` event is a record of the stack that was being executed at different sample points in time.</span><span class="s3">\n </span><span class="s1">* It has a structure like this:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*    nodes: [function A, function B, function C]</span><span class="s3">\n </span><span class="s1">*    samples: [node with id 2, node with id 1, ...]</span><span class="s3">\n </span><span class="s1">*    timeDeltas: [4125μs since last sample, 121μs since last sample, ...]</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Helpful prior art:</span><span class="s3">\n </span><span class="s1">* @see https://cs.chromium.org/chromium/src/third_party/devtools-frontend/src/front_end/sdk/CPUProfileDataModel.js?sq=package:chromium&amp;g=0&amp;l=42</span><span class="s3">\n </span><span class="s1">* @see https://github.com/v8/v8/blob/99ca333b0efba3236954b823101315aefeac51ab/tools/profile.js</span><span class="s3">\n </span><span class="s1">* @see https://github.com/jlfwong/speedscope/blob/9ed1eb192cb7e9dac43a5f25bd101af169dc654a/src/import/chrome.ts#L200</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">CPUProfileChunk,</span><span class="s3">\n  </span><span class="s1">CPUProfileChunkNode,</span><span class="s3">\n  </span><span class="s1">CPUProfileChunker,</span><span class="s3">\n</span><span class="s1">} from '../types/CPUProfile';</span><span class="s3">\n</span><span class="s1">import { DurationEvent } from '../types/EventInterfaces';</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">HermesCPUProfile,</span><span class="s3">\n  </span><span class="s1">HermesSample,</span><span class="s3">\n  </span><span class="s1">HermesStackFrame,</span><span class="s3">\n</span><span class="s1">} from '../types/HermesProfile';</span><span class="s3">\n</span><span class="s1">import { EventsPhase } from '../types/Phases';</span><span class="s3">\n\n</span><span class="s1">export class CpuProfilerModel {</span><span class="s3">\n  </span><span class="s1">_profile: CPUProfileChunk;</span><span class="s3">\n  </span><span class="s1">_nodesById: Map&lt;number, CPUProfileChunkNode&gt;;</span><span class="s3">\n  </span><span class="s1">_activeNodeArraysById: Map&lt;number, number[]&gt;;</span><span class="s3">\n\n  </span><span class="s1">constructor(profile: CPUProfileChunk) {</span><span class="s3">\n    </span><span class="s1">this._profile = profile;</span><span class="s3">\n    </span><span class="s1">this._nodesById = this._createNodeMap();</span><span class="s3">\n    </span><span class="s1">this._activeNodeArraysById = this._createActiveNodeArrays();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Initialization function to enable O(1) access to nodes by node ID.</span><span class="s3">\n   </span><span class="s1">* @return {Map&lt;number, CPUProfileChunkNode}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">_createNodeMap(): Map&lt;number, CPUProfileChunkNode&gt; {</span><span class="s3">\n    </span><span class="s1">/** @type {Map&lt;number, CpuProfile['nodes'][0]&gt;} */</span><span class="s3">\n    </span><span class="s1">const map: Map&lt;number, CPUProfileChunkNode&gt; = new Map&lt;</span><span class="s3">\n      </span><span class="s1">number,</span><span class="s3">\n      </span><span class="s1">CPUProfileChunkNode</span><span class="s3">\n    </span><span class="s1">&gt;();</span><span class="s3">\n    </span><span class="s1">for (const node of this._profile.nodes) {</span><span class="s3">\n      </span><span class="s1">map.set(node.id, node);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return map;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Initialization function to enable O(1) access to the set of active nodes in the stack by node ID.</span><span class="s3">\n   </span><span class="s1">* @return Map&lt;number, number[]&gt;</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">_createActiveNodeArrays(): Map&lt;number, number[]&gt; {</span><span class="s3">\n    </span><span class="s1">const map: Map&lt;number, number[]&gt; = new Map&lt;number, number[]&gt;();</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Given a nodeId, `getActiveNodes` gets all the parent nodes in reversed call order</span><span class="s3">\n     </span><span class="s1">* @param {number} id</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">const getActiveNodes = (id: number): number[] =&gt; {</span><span class="s3">\n      </span><span class="s1">if (map.has(id)) return map.get(id) || [];</span><span class="s3">\n\n      </span><span class="s1">const node = this._nodesById.get(id);</span><span class="s3">\n      </span><span class="s1">if (!node) throw new Error(`No such node ${id}`);</span><span class="s3">\n      </span><span class="s1">if (node.parent) {</span><span class="s3">\n        </span><span class="s1">const array = getActiveNodes(node.parent).concat([id]);</span><span class="s3">\n        </span><span class="s1">map.set(id, array);</span><span class="s3">\n        </span><span class="s1">return array;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">return [id];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">for (const node of this._profile.nodes) {</span><span class="s3">\n      </span><span class="s1">map.set(node.id, getActiveNodes(node.id));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return map;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns all the node IDs in a stack when a specific nodeId is at the top of the stack</span><span class="s3">\n   </span><span class="s1">* (i.e. a stack's node ID and the node ID of all of its parents).</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">_getActiveNodeIds(nodeId: number): number[] {</span><span class="s3">\n    </span><span class="s1">const activeNodeIds = this._activeNodeArraysById.get(nodeId);</span><span class="s3">\n    </span><span class="s1">if (!activeNodeIds) throw new Error(`No such node ID ${nodeId}`);</span><span class="s3">\n    </span><span class="s1">return activeNodeIds;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Generates the necessary B/E-style trace events for a single transition from stack A to stack B</span><span class="s3">\n   </span><span class="s1">* at the given timestamp.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* Example:</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">*    timestamp 1234</span><span class="s3">\n   </span><span class="s1">*    previousNodeIds 1,2,3</span><span class="s3">\n   </span><span class="s1">*    currentNodeIds 1,2,4</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">*    yields [end 3 at ts 1234, begin 4 at ts 1234]</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {number} timestamp</span><span class="s3">\n   </span><span class="s1">* @param {Array&lt;number&gt;} previousNodeIds</span><span class="s3">\n   </span><span class="s1">* @param {Array&lt;number&gt;} currentNodeIds</span><span class="s3">\n   </span><span class="s1">* @returns {Array&lt;DurationEvent&gt;}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">_createStartEndEventsForTransition(</span><span class="s3">\n    </span><span class="s1">timestamp: number,</span><span class="s3">\n    </span><span class="s1">previousNodeIds: number[],</span><span class="s3">\n    </span><span class="s1">currentNodeIds: number[]</span><span class="s3">\n  </span><span class="s1">): DurationEvent[] {</span><span class="s3">\n    </span><span class="s1">// Start nodes are the nodes which are present only in the currentNodeIds and not in PreviousNodeIds</span><span class="s3">\n    </span><span class="s1">const startNodes: CPUProfileChunkNode[] = currentNodeIds</span><span class="s3">\n      </span><span class="s1">.filter(id =&gt; !previousNodeIds.includes(id))</span><span class="s3">\n      </span><span class="s1">.map(id =&gt; this._nodesById.get(id)!);</span><span class="s3">\n    </span><span class="s1">// End nodes are the nodes which are present only in the PreviousNodeIds and not in CurrentNodeIds</span><span class="s3">\n    </span><span class="s1">const endNodes: CPUProfileChunkNode[] = previousNodeIds</span><span class="s3">\n      </span><span class="s1">.filter(id =&gt; !currentNodeIds.includes(id))</span><span class="s3">\n      </span><span class="s1">.map(id =&gt; this._nodesById.get(id)!);</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The name needs to be modified if `http://` is present as this directs us to bundle files which does not add any information for the end user</span><span class="s3">\n     </span><span class="s1">* @param name</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">const removeLinksIfExist = (name: string): string =&gt; {</span><span class="s3">\n      </span><span class="s1">// If the name includes `http://`, we can filter the name</span><span class="s3">\n      </span><span class="s1">if (name.includes('http://')) {</span><span class="s3">\n        </span><span class="s1">name = name.substring(0, name.lastIndexOf('('));</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return name || 'anonymous';</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Create a Duration Event from CPUProfileChunkNodes.</span><span class="s3">\n     </span><span class="s1">* @param {CPUProfileChunkNode} node</span><span class="s3">\n     </span><span class="s1">* @return {DurationEvent} */</span><span class="s3">\n    </span><span class="s1">const createEvent = (node: CPUProfileChunkNode): DurationEvent =&gt; ({</span><span class="s3">\n      </span><span class="s1">ts: timestamp,</span><span class="s3">\n      </span><span class="s1">pid: this._profile.pid,</span><span class="s3">\n      </span><span class="s1">tid: Number(this._profile.tid),</span><span class="s3">\n      </span><span class="s1">ph: EventsPhase.DURATION_EVENTS_BEGIN,</span><span class="s3">\n      </span><span class="s1">name: removeLinksIfExist(node.callFrame.name),</span><span class="s3">\n      </span><span class="s1">cat: node.callFrame.category,</span><span class="s3">\n      </span><span class="s1">args: { ...node.callFrame },</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">const startEvents: DurationEvent[] = startNodes</span><span class="s3">\n      </span><span class="s1">.map(createEvent)</span><span class="s3">\n      </span><span class="s1">.map(evt =&gt; ({ ...evt, ph: EventsPhase.DURATION_EVENTS_BEGIN }));</span><span class="s3">\n    </span><span class="s1">const endEvents: DurationEvent[] = endNodes</span><span class="s3">\n      </span><span class="s1">.map(createEvent)</span><span class="s3">\n      </span><span class="s1">.map(evt =&gt; ({ ...evt, ph: EventsPhase.DURATION_EVENTS_END }));</span><span class="s3">\n    </span><span class="s1">return [...endEvents.reverse(), ...startEvents];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Creates B/E-style trace events from a CpuProfile object created by `collectProfileEvents()`</span><span class="s3">\n   </span><span class="s1">* @return {DurationEvent}</span><span class="s3">\n   </span><span class="s1">* @throws If the length of timeDeltas array or the samples array does not match with the length of samples in Hermes Profile</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">createStartEndEvents(): DurationEvent[] {</span><span class="s3">\n    </span><span class="s1">const profile = this._profile;</span><span class="s3">\n    </span><span class="s1">const length = profile.samples.length;</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">profile.timeDeltas.length !== length ||</span><span class="s3">\n      </span><span class="s1">profile.samples.length !== length</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">throw new Error(`Invalid CPU profile length`);</span><span class="s3">\n\n    </span><span class="s1">const events: DurationEvent[] = [];</span><span class="s3">\n\n    </span><span class="s1">let timestamp = profile.startTime;</span><span class="s3">\n    </span><span class="s1">let lastActiveNodeIds: number[] = [];</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; profile.samples.length; i++) {</span><span class="s3">\n      </span><span class="s1">const nodeId = profile.samples[i];</span><span class="s3">\n      </span><span class="s1">const timeDelta = Math.max(profile.timeDeltas[i], 0);</span><span class="s3">\n      </span><span class="s1">const node = this._nodesById.get(nodeId);</span><span class="s3">\n      </span><span class="s1">if (!node) throw new Error(`Missing node ${nodeId}`);</span><span class="s3">\n\n      </span><span class="s1">timestamp += timeDelta;</span><span class="s3">\n      </span><span class="s1">const activeNodeIds = this._getActiveNodeIds(nodeId);</span><span class="s3">\n      </span><span class="s1">events.push(</span><span class="s3">\n        </span><span class="s1">...this._createStartEndEventsForTransition(</span><span class="s3">\n          </span><span class="s1">timestamp,</span><span class="s3">\n          </span><span class="s1">lastActiveNodeIds,</span><span class="s3">\n          </span><span class="s1">activeNodeIds</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">lastActiveNodeIds = activeNodeIds;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">events.push(</span><span class="s3">\n      </span><span class="s1">...this._createStartEndEventsForTransition(</span><span class="s3">\n        </span><span class="s1">timestamp,</span><span class="s3">\n        </span><span class="s1">lastActiveNodeIds,</span><span class="s3">\n        </span><span class="s1">[]</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n\n    </span><span class="s1">return events;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Creates B/E-style trace events from a CpuProfile object created by `collectProfileEvents()`</span><span class="s3">\n   </span><span class="s1">* @param {CPUProfileChunk} profile</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">static createStartEndEvents(profile: CPUProfileChunk) {</span><span class="s3">\n    </span><span class="s1">const model = new CpuProfilerModel(profile);</span><span class="s3">\n    </span><span class="s1">return model.createStartEndEvents();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Converts the Hermes Sample into a single CpuProfileChunk object for consumption</span><span class="s3">\n   </span><span class="s1">* by `createStartEndEvents()`.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {HermesCPUProfile} profile</span><span class="s3">\n   </span><span class="s1">* @throws Profile must have at least one sample</span><span class="s3">\n   </span><span class="s1">* @return {CPUProfileChunk}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">static collectProfileEvents(profile: HermesCPUProfile): CPUProfileChunk {</span><span class="s3">\n    </span><span class="s1">if (profile.samples.length &gt;= 0) {</span><span class="s3">\n      </span><span class="s1">const { samples, stackFrames } = profile;</span><span class="s3">\n      </span><span class="s1">// Assumption: The sample will have a single process</span><span class="s3">\n      </span><span class="s1">const pid: number = samples[0].pid;</span><span class="s3">\n      </span><span class="s1">// Assumption: Javascript is single threaded, so there should only be one thread throughout</span><span class="s3">\n      </span><span class="s1">const tid: string = samples[0].tid;</span><span class="s3">\n      </span><span class="s1">// TODO: What role does id play in string parsing</span><span class="s3">\n      </span><span class="s1">const id: string = '0x1';</span><span class="s3">\n      </span><span class="s1">const startTime: number = Number(samples[0].ts);</span><span class="s3">\n      </span><span class="s1">const { nodes, sampleNumbers, timeDeltas } = this.constructNodes(</span><span class="s3">\n        </span><span class="s1">samples,</span><span class="s3">\n        </span><span class="s1">stackFrames</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">id,</span><span class="s3">\n        </span><span class="s1">pid,</span><span class="s3">\n        </span><span class="s1">tid,</span><span class="s3">\n        </span><span class="s1">startTime,</span><span class="s3">\n        </span><span class="s1">nodes,</span><span class="s3">\n        </span><span class="s1">samples: sampleNumbers,</span><span class="s3">\n        </span><span class="s1">timeDeltas,</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">throw new Error('The hermes profile has zero samples');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Constructs CPUProfileChunk Nodes and the resultant samples and time deltas to be inputted into the</span><span class="s3">\n   </span><span class="s1">* CPUProfileChunk object which will be processed to give createStartEndEvents()</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {HermesSample} samples</span><span class="s3">\n   </span><span class="s1">* @param {&lt;string, HermesStackFrame&gt;} stackFrames</span><span class="s3">\n   </span><span class="s1">* @return {CPUProfileChunker}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">static constructNodes(</span><span class="s3">\n    </span><span class="s1">samples: HermesSample[],</span><span class="s3">\n    </span><span class="s1">stackFrames: { [key in string]: HermesStackFrame }</span><span class="s3">\n  </span><span class="s1">): CPUProfileChunker {</span><span class="s3">\n    </span><span class="s1">samples = samples.map((sample: HermesSample) =&gt; {</span><span class="s3">\n      </span><span class="s1">sample.stackFrameData = stackFrames[sample.sf];</span><span class="s3">\n      </span><span class="s1">return sample;</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">const stackFrameIds: string[] = Object.keys(stackFrames);</span><span class="s3">\n    </span><span class="s1">const profileNodes: CPUProfileChunkNode[] = stackFrameIds.map(</span><span class="s3">\n      </span><span class="s1">(stackFrameId: string) =&gt; {</span><span class="s3">\n        </span><span class="s1">const stackFrame = stackFrames[stackFrameId];</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">id: Number(stackFrameId),</span><span class="s3">\n          </span><span class="s1">callFrame: {</span><span class="s3">\n            </span><span class="s1">...stackFrame,</span><span class="s3">\n            </span><span class="s1">url: stackFrame.name,</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">parent: stackFrames[stackFrameId].parent,</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">const returnedSamples: number[] = [];</span><span class="s3">\n    </span><span class="s1">const timeDeltas: number[] = [];</span><span class="s3">\n    </span><span class="s1">let lastTimeStamp = Number(samples[0].ts);</span><span class="s3">\n    </span><span class="s1">samples.forEach((sample: HermesSample, idx: number) =&gt; {</span><span class="s3">\n      </span><span class="s1">returnedSamples.push(sample.sf);</span><span class="s3">\n      </span><span class="s1">if (idx === 0) {</span><span class="s3">\n        </span><span class="s1">timeDeltas.push(0);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">const timeDiff = Number(sample.ts) - lastTimeStamp;</span><span class="s3">\n        </span><span class="s1">lastTimeStamp = Number(sample.ts);</span><span class="s3">\n        </span><span class="s1">timeDeltas.push(timeDiff);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">nodes: profileNodes,</span><span class="s3">\n      </span><span class="s1">sampleNumbers: returnedSamples,</span><span class="s3">\n      </span><span class="s1">timeDeltas,</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;// A type of promise-like that resolves synchronously and supports only one observer</span><span class="s3">\n</span><span class="s1">export const _Pact = /*#__PURE__*/(function() {</span><span class="s3">\n\t</span><span class="s1">function _Pact() {}</span><span class="s3">\n\t</span><span class="s1">_Pact.prototype.then = function(onFulfilled, onRejected) {</span><span class="s3">\n\t\t</span><span class="s1">const result = new _Pact();</span><span class="s3">\n\t\t</span><span class="s1">const state = this.s;</span><span class="s3">\n\t\t</span><span class="s1">if (state) {</span><span class="s3">\n\t\t\t</span><span class="s1">const callback = state &amp; 1 ? onFulfilled : onRejected;</span><span class="s3">\n\t\t\t</span><span class="s1">if (callback) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">try {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">_settle(result, 1, callback(this.v));</span><span class="s3">\n\t\t\t\t</span><span class="s1">} catch (e) {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">_settle(result, 2, e);</span><span class="s3">\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t\t</span><span class="s1">return result;</span><span class="s3">\n\t\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t\t</span><span class="s1">return this;</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">this.o = function(_this) {</span><span class="s3">\n\t\t\t</span><span class="s1">try {</span><span class="s3">\n\t\t\t\t</span><span class="s1">const value = _this.v;</span><span class="s3">\n\t\t\t\t</span><span class="s1">if (_this.s &amp; 1) {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">_settle(result, 1, onFulfilled ? onFulfilled(value) : value);</span><span class="s3">\n\t\t\t\t</span><span class="s1">} else if (onRejected) {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">_settle(result, 1, onRejected(value));</span><span class="s3">\n\t\t\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">_settle(result, 2, value);</span><span class="s3">\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">} catch (e) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">_settle(result, 2, e);</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">};</span><span class="s3">\n\t\t</span><span class="s1">return result;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">return _Pact;</span><span class="s3">\n</span><span class="s1">})();</span><span class="s3">\n\n</span><span class="s1">// Settles a pact synchronously</span><span class="s3">\n</span><span class="s1">export function _settle(pact, state, value) {</span><span class="s3">\n\t</span><span class="s1">if (!pact.s) {</span><span class="s3">\n\t\t</span><span class="s1">if (value instanceof _Pact) {</span><span class="s3">\n\t\t\t</span><span class="s1">if (value.s) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">if (state &amp; 1) {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">state = value.s;</span><span class="s3">\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t\t</span><span class="s1">value = value.v;</span><span class="s3">\n\t\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t\t</span><span class="s1">value.o = _settle.bind(null, pact, state);</span><span class="s3">\n\t\t\t\t</span><span class="s1">return;</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">if (value &amp;&amp; value.then) {</span><span class="s3">\n\t\t\t</span><span class="s1">value.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));</span><span class="s3">\n\t\t\t</span><span class="s1">return;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">pact.s = state;</span><span class="s3">\n\t\t</span><span class="s1">pact.v = value;</span><span class="s3">\n\t\t</span><span class="s1">const observer = pact.o;</span><span class="s3">\n\t\t</span><span class="s1">if (observer) {</span><span class="s3">\n\t\t\t</span><span class="s1">observer(pact);</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function _isSettledPact(thenable) {</span><span class="s3">\n\t</span><span class="s1">return thenable instanceof _Pact &amp;&amp; thenable.s &amp; 1;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Converts argument to a function that always returns a Promise</span><span class="s3">\n</span><span class="s1">export function _async(f) {</span><span class="s3">\n\t</span><span class="s1">return function() {</span><span class="s3">\n\t\t</span><span class="s1">for (var args = [], i = 0; i &lt; arguments.length; i++) {</span><span class="s3">\n\t\t\t</span><span class="s1">args[i] = arguments[i];</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">try {</span><span class="s3">\n\t\t\t</span><span class="s1">return Promise.resolve(f.apply(this, args));</span><span class="s3">\n\t\t</span><span class="s1">} catch(e) {</span><span class="s3">\n\t\t\t</span><span class="s1">return Promise.reject(e);</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)</span><span class="s3">\n</span><span class="s1">export function _await(value, then, direct) {</span><span class="s3">\n\t</span><span class="s1">if (direct) {</span><span class="s3">\n\t\t</span><span class="s1">return then ? then(value) : value;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">if (!value || !value.then) {</span><span class="s3">\n\t\t</span><span class="s1">value = Promise.resolve(value);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">return then ? value.then(then) : value;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Awaits on a value that may or may not be a Promise, then ignores it</span><span class="s3">\n</span><span class="s1">export function _awaitIgnored(value, direct) {</span><span class="s3">\n\t</span><span class="s1">if (!direct) {</span><span class="s3">\n\t\t</span><span class="s1">return value &amp;&amp; value.then ? value.then(_empty) : Promise.resolve();</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable</span><span class="s3">\n</span><span class="s1">export function _continue(value, then) {</span><span class="s3">\n\t</span><span class="s1">return value &amp;&amp; value.then ? value.then(then) : then(value);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable</span><span class="s3">\n</span><span class="s1">export function _continueIgnored(value) {</span><span class="s3">\n\t</span><span class="s1">if (value &amp;&amp; value.then) {</span><span class="s3">\n\t\t</span><span class="s1">return value.then(_empty);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)</span><span class="s3">\n</span><span class="s1">export function _forTo(array, body, check) {</span><span class="s3">\n\t</span><span class="s1">var i = -1, pact, reject;</span><span class="s3">\n\t</span><span class="s1">function _cycle(result) {</span><span class="s3">\n\t\t</span><span class="s1">try {</span><span class="s3">\n\t\t\t</span><span class="s1">while (++i &lt; array.length &amp;&amp; (!check || !check())) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">result = body(i);</span><span class="s3">\n\t\t\t\t</span><span class="s1">if (result &amp;&amp; result.then) {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">if (_isSettledPact(result)) {</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">result = result.v;</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">result.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">return;</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">if (pact) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">_settle(pact, 1, result);</span><span class="s3">\n\t\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t\t</span><span class="s1">pact = result;</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">} catch (e) {</span><span class="s3">\n\t\t\t</span><span class="s1">_settle(pact || (pact = new _Pact()), 2, e);</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">_cycle();</span><span class="s3">\n\t</span><span class="s1">return pact;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Asynchronously iterate through an object's properties (including properties inherited from the prototype)</span><span class="s3">\n</span><span class="s1">// Uses a snapshot of the object's properties</span><span class="s3">\n</span><span class="s1">export function _forIn(target, body, check) {</span><span class="s3">\n\t</span><span class="s1">var keys = [];</span><span class="s3">\n\t</span><span class="s1">for (var key in target) {</span><span class="s3">\n\t\t</span><span class="s1">keys.push(key);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">return _forTo(keys, function(i) { return body(keys[i]); }, check);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)</span><span class="s3">\n</span><span class="s1">// Uses a snapshot of the object's properties</span><span class="s3">\n</span><span class="s1">export function _forOwn(target, body, check) {</span><span class="s3">\n\t</span><span class="s1">var keys = [];</span><span class="s3">\n\t</span><span class="s1">for (var key in target) {</span><span class="s3">\n\t\t</span><span class="s1">if (Object.prototype.hasOwnProperty.call(target, key)) {</span><span class="s3">\n\t\t\t</span><span class="s1">keys.push(key);</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">return _forTo(keys, function(i) { return body(keys[i]); }, check);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot; </span><span class="s1">? (Symbol.iterator || (Symbol.iterator = Symbol(</span><span class="s3">\&quot;</span><span class="s1">Symbol.iterator</span><span class="s3">\&quot;</span><span class="s1">))) : </span><span class="s3">\&quot;</span><span class="s1">@@iterator</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">// Asynchronously iterate through an object's values</span><span class="s3">\n</span><span class="s1">// Uses for...of if the runtime supports it, otherwise iterates until length on a copy</span><span class="s3">\n</span><span class="s1">export function _forOf(target, body, check) {</span><span class="s3">\n\t</span><span class="s1">if (typeof target[_iteratorSymbol] === </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n\t\t</span><span class="s1">var iterator = target[_iteratorSymbol](), step, pact, reject;</span><span class="s3">\n\t\t</span><span class="s1">function _cycle(result) {</span><span class="s3">\n\t\t\t</span><span class="s1">try {</span><span class="s3">\n\t\t\t\t</span><span class="s1">while (!(step = iterator.next()).done &amp;&amp; (!check || !check())) {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">result = body(step.value);</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">if (result &amp;&amp; result.then) {</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">if (_isSettledPact(result)) {</span><span class="s3">\n\t\t\t\t\t\t\t</span><span class="s1">result = result.v;</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t\t\t\t\t</span><span class="s1">result.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));</span><span class="s3">\n\t\t\t\t\t\t\t</span><span class="s1">return;</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t\t</span><span class="s1">if (pact) {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">_settle(pact, 1, result);</span><span class="s3">\n\t\t\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">pact = result;</span><span class="s3">\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">} catch (e) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">_settle(pact || (pact = new _Pact()), 2, e);</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">_cycle();</span><span class="s3">\n\t\t</span><span class="s1">if (iterator.return) {</span><span class="s3">\n\t\t\t</span><span class="s1">var _fixup = function(value) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">try {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">if (!step.done) {</span><span class="s3">\n\t\t\t\t\t\t</span><span class="s1">iterator.return();</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t\t</span><span class="s1">} catch(e) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t\t</span><span class="s1">return value;</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">if (pact &amp;&amp; pact.then) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">return pact.then(_fixup, function(e) {</span><span class="s3">\n\t\t\t\t\t</span><span class="s1">throw _fixup(e);</span><span class="s3">\n\t\t\t\t</span><span class="s1">});</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">_fixup();</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">return pact;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">// No support for Symbol.iterator</span><span class="s3">\n\t</span><span class="s1">if (!(</span><span class="s3">\&quot;</span><span class="s1">length</span><span class="s3">\&quot; </span><span class="s1">in target)) {</span><span class="s3">\n\t\t</span><span class="s1">throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">Object is not iterable</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">// Handle live collections properly</span><span class="s3">\n\t</span><span class="s1">var values = [];</span><span class="s3">\n\t</span><span class="s1">for (var i = 0; i &lt; target.length; i++) {</span><span class="s3">\n\t\t</span><span class="s1">values.push(target[i]);</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">return _forTo(values, function(i) { return body(values[i]); }, check);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot; </span><span class="s1">? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\&quot;Symbol.asyncIterator\&quot;))) : \&quot;@@asyncIterator\&quot;;\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \&quot;function\&quot;) {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check &amp;&amp; check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result &amp;&amp; result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue &amp;&amp; updateValue.then &amp;&amp; !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue &amp;&amp; updateValue.then &amp;&amp; !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) &amp;&amp; !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result &amp;&amp; result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result &amp;&amp; result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result &amp;&amp; result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result &amp;&amp; result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i &lt; cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue &amp;&amp; testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result &amp;&amp; result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck &amp;&amp; !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value &amp;&amp; value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result &amp;&amp; result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck &amp;&amp; !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result &amp;&amp; result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result &amp;&amp; result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result &amp;&amp; result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result &amp;&amp; result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result &amp;&amp; result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result &amp;&amp; result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value &amp;&amp; value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value &amp;&amp; value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result &amp;&amp; result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value &amp;&amp; value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \&quot;early return\&quot; value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n&quot;,&quot;import { readFile } from 'fs';\nimport { promisify } from 'util';\n\nexport const readFileAsync = async (path: string): Promise&lt;any&gt; =&gt; {\n  try {\n    const readFileAsync = promisify(readFile);\n    const fileString: string = (await readFileAsync(path, 'utf-8')) as string;\n    if (fileString.length === 0) {\n      throw new Error(`${path} is an empty file`);\n    }\n    const obj = JSON.parse(fileString);\n    return obj;\n  } catch (err) {\n    throw err;\n  }\n};\n&quot;,&quot;import path from 'path';\nimport { SourceMapConsumer, RawSourceMap } from 'source-map';\nimport { DurationEvent } from '../types/EventInterfaces';\nimport { SourceMap } from '../types/SourceMap';\n\n/**\n * This function is a helper to the applySourceMapsToEvents. The category allocation logic is implemented here based on the sourcemap url (if available)\n * @param defaultCategory The category the event is of by default without the use of Source maps\n * @param url The URL which can be parsed to interpret the new category of the event (depends on node_modules)\n */\nconst improveCategories = (\n  defaultCategory: string,\n  url: string | null\n): string =&gt; {\n  const obtainCategory = (url: string): string =&gt; {\n    const dirs = url\n      .substring(url.lastIndexOf(`${path.sep}node_modules${path.sep}`))\n      .split(path.sep);\n    return dirs.length &gt; 2 &amp;&amp; dirs[1] === 'node_modules'\n      ? dirs[2]\n      : defaultCategory;\n  };\n  return url ? obtainCategory(url) : defaultCategory;\n};\n\n/**\n * Enhances the function line, column and params information and event categories\n * based on JavaScript source maps to make it easier to associate trace events with\n * the application code\n *\n * Throws error if args not set up in ChromeEvents\n * @param {SourceMap} sourceMap\n * @param {DurationEvent[]} chromeEvents\n * @param {string} indexBundleFileName\n * @throws If `args` for events are not populated\n * @returns {DurationEvent[]}\n */\nconst applySourceMapsToEvents = async (\n  sourceMap: SourceMap,\n  chromeEvents: DurationEvent[],\n  indexBundleFileName: string | undefined\n): Promise&lt;DurationEvent[]&gt; =&gt; {\n  // SEE: Should file here be an optional parameter, so take indexBundleFileName as a parameter and use\n  // a default name of `index.bundle`\n  const rawSourceMap: RawSourceMap = {\n    version: Number(sourceMap.version),\n    file: indexBundleFileName || 'index.bundle',\n    sources: sourceMap.sources,\n    mappings: sourceMap.mappings,\n    names: sourceMap.names,\n  };\n\n  const consumer = await new SourceMapConsumer(rawSourceMap);\n  const events = chromeEvents.map((event: DurationEvent) =&gt; {\n    if (event.args) {\n      const sm = consumer.originalPositionFor({\n        line: Number(event.args.line),\n        column: Number(event.args.column),\n      });\n      /**\n       * The categories can help us better visualise the profile if we modify the categories.\n       * We change these categories only in the root level and not deeper inside the args, just so we have our\n       * original categories as well as these modified categories (as the modified categories simply help with visualisation)\n       */\n      event.cat = improveCategories(event.cat!, sm.source);\n      event.args = {\n        ...event.args,\n        url: sm.source,\n        line: sm.line,\n        column: sm.column,\n        params: sm.name,\n        allocatedCategory: event.cat,\n        allocatedName: event.name,\n      };\n    } else {\n      throw new Error(\n        `Source maps could not be derived for an event at ${event.ts} and with stackFrame ID ${event.sf}`\n      );\n    }\n    return event;\n  });\n  consumer.destroy();\n  return events;\n};\n\nexport default applySourceMapsToEvents;\n&quot;,&quot;import { CpuProfilerModel } from './profiler/cpuProfilerModel';\nimport { DurationEvent } from './types/EventInterfaces';\nimport { readFileAsync } from './utils/fileSystem';\nimport { HermesCPUProfile } from './types/HermesProfile';\nimport applySourceMapsToEvents from './profiler/applySourceMapsToEvents';\nimport { SourceMap } from './types/SourceMap';\n\n/**\n * This transformer can take in the path of the profile, the source map (optional) and the bundle file name (optional)\n * and return a promise which resolves to Chrome Dev Tools compatible events\n * @param profilePath string\n * @param sourceMapPath string\n * @param bundleFileName string\n * @return Promise&lt;DurationEvent[]&gt;\n */\nconst transformer = async (\n  profilePath: string,\n  sourceMapPath: string | undefined,\n  bundleFileName: string | undefined\n): Promise&lt;DurationEvent[]&gt; =&gt; {\n  const hermesProfile: HermesCPUProfile = await readFileAsync(profilePath);\n  const profileChunk = CpuProfilerModel.collectProfileEvents(hermesProfile);\n  const profiler = new CpuProfilerModel(profileChunk);\n  const chromeEvents = profiler.createStartEndEvents();\n  if (sourceMapPath) {\n    const sourceMap: SourceMap = await readFileAsync(sourceMapPath);\n    const events = applySourceMapsToEvents(\n      sourceMap,\n      chromeEvents,\n      bundleFileName\n    );\n    return events;\n  }\n  return chromeEvents;\n};\n\nexport default transformer;\nexport { SourceMap } from './types/SourceMap';\n&quot;],&quot;names&quot;:[&quot;EventsPhase&quot;,&quot;CpuProfilerModel&quot;,&quot;profile&quot;,&quot;_profile&quot;,&quot;_nodesById&quot;,&quot;this&quot;,&quot;_createNodeMap&quot;,&quot;_activeNodeArraysById&quot;,&quot;_createActiveNodeArrays&quot;,&quot;map&quot;,&quot;Map&quot;,&quot;nodes&quot;,&quot;node&quot;,&quot;set&quot;,&quot;id&quot;,&quot;getActiveNodes&quot;,&quot;has&quot;,&quot;get&quot;,&quot;_this&quot;,&quot;Error&quot;,&quot;parent&quot;,&quot;array&quot;,&quot;concat&quot;,&quot;_getActiveNodeIds&quot;,&quot;nodeId&quot;,&quot;activeNodeIds&quot;,&quot;_createStartEndEventsForTransition&quot;,&quot;timestamp&quot;,&quot;previousNodeIds&quot;,&quot;currentNodeIds&quot;,&quot;startNodes&quot;,&quot;filter&quot;,&quot;includes&quot;,&quot;_this2&quot;,&quot;endNodes&quot;,&quot;createEvent&quot;,&quot;ts&quot;,&quot;pid&quot;,&quot;tid&quot;,&quot;Number&quot;,&quot;ph&quot;,&quot;DURATION_EVENTS_BEGIN&quot;,&quot;name&quot;,&quot;callFrame&quot;,&quot;substring&quot;,&quot;lastIndexOf&quot;,&quot;cat&quot;,&quot;category&quot;,&quot;args&quot;,&quot;startEvents&quot;,&quot;evt&quot;,&quot;endEvents&quot;,&quot;DURATION_EVENTS_END&quot;,&quot;reverse&quot;,&quot;createStartEndEvents&quot;,&quot;length&quot;,&quot;samples&quot;,&quot;timeDeltas&quot;,&quot;events&quot;,&quot;startTime&quot;,&quot;lastActiveNodeIds&quot;,&quot;i&quot;,&quot;timeDelta&quot;,&quot;Math&quot;,&quot;max&quot;,&quot;push&quot;,&quot;collectProfileEvents&quot;,&quot;stackFrames&quot;,&quot;constructNodes&quot;,&quot;sampleNumbers&quot;,&quot;sample&quot;,&quot;stackFrameData&quot;,&quot;sf&quot;,&quot;profileNodes&quot;,&quot;Object&quot;,&quot;keys&quot;,&quot;stackFrameId&quot;,&quot;stackFrame&quot;,&quot;url&quot;,&quot;returnedSamples&quot;,&quot;lastTimeStamp&quot;,&quot;forEach&quot;,&quot;idx&quot;,&quot;timeDiff&quot;,&quot;Symbol&quot;,&quot;iterator&quot;,&quot;asyncIterator&quot;,&quot;readFileAsync&quot;,&quot;path&quot;,&quot;body&quot;,&quot;recover&quot;,&quot;result&quot;,&quot;promisify&quot;,&quot;readFile&quot;,&quot;fileString&quot;,&quot;JSON&quot;,&quot;parse&quot;,&quot;e&quot;,&quot;then&quot;,&quot;err&quot;,&quot;applySourceMapsToEvents&quot;,&quot;sourceMap&quot;,&quot;chromeEvents&quot;,&quot;indexBundleFileName&quot;,&quot;rawSourceMap&quot;,&quot;version&quot;,&quot;file&quot;,&quot;sources&quot;,&quot;mappings&quot;,&quot;names&quot;,&quot;SourceMapConsumer&quot;,&quot;consumer&quot;,&quot;event&quot;,&quot;defaultCategory&quot;,&quot;sm&quot;,&quot;originalPositionFor&quot;,&quot;line&quot;,&quot;column&quot;,&quot;source&quot;,&quot;dirs&quot;,&quot;sep&quot;,&quot;split&quot;,&quot;obtainCategory&quot;,&quot;params&quot;,&quot;allocatedCategory&quot;,&quot;allocatedName&quot;,&quot;destroy&quot;,&quot;profilePath&quot;,&quot;sourceMapPath&quot;,&quot;bundleFileName&quot;,&quot;hermesProfile&quot;,&quot;profileChunk&quot;],&quot;mappings&quot;:&quot;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&quot;}</span></pre>
</body>
</html>
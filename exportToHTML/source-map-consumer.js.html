<html>
<head>
<title>source-map-consumer.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
source-map-consumer.js</font>
</center></td></tr></table>
<pre><span class="s0">/* -*- Mode: js; js-indent-level: 2; -*- */</span>
<span class="s0">/* 
 * Copyright 2011 Mozilla Foundation and contributors 
 * Licensed under the New BSD license. See LICENSE or: 
 * http://opensource.org/licenses/BSD-3-Clause 
 */</span>

<span class="s1">const util = require(</span><span class="s2">&quot;./util&quot;</span><span class="s1">);</span>
<span class="s1">const binarySearch = require(</span><span class="s2">&quot;./binary-search&quot;</span><span class="s1">);</span>
<span class="s1">const ArraySet = require(</span><span class="s2">&quot;./array-set&quot;</span><span class="s1">).ArraySet;</span>
<span class="s1">const base64VLQ = require(</span><span class="s2">&quot;./base64-vlq&quot;</span><span class="s1">); </span><span class="s0">// eslint-disable-line no-unused-vars</span>
<span class="s1">const readWasm = require(</span><span class="s2">&quot;../lib/read-wasm&quot;</span><span class="s1">);</span>
<span class="s1">const wasm = require(</span><span class="s2">&quot;./wasm&quot;</span><span class="s1">);</span>

<span class="s1">const INTERNAL = Symbol(</span><span class="s2">&quot;smcInternal&quot;</span><span class="s1">);</span>

<span class="s1">class SourceMapConsumer {</span>
  <span class="s1">constructor(aSourceMap, aSourceMapURL) {</span>
    <span class="s0">// If the constructor was called by super(), just return Promise&lt;this&gt;.</span>
    <span class="s0">// Yes, this is a hack to retain the pre-existing API of the base-class</span>
    <span class="s0">// constructor also being an async factory function.</span>
    <span class="s3">if </span><span class="s1">(aSourceMap == INTERNAL) {</span>
      <span class="s3">return </span><span class="s1">Promise.resolve(</span><span class="s3">this</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">_factory(aSourceMap, aSourceMapURL);</span>
  <span class="s1">}</span>

  <span class="s1">static initialize(opts) {</span>
    <span class="s1">readWasm.initialize(opts[</span><span class="s2">&quot;lib/mappings.wasm&quot;</span><span class="s1">]);</span>
  <span class="s1">}</span>

  <span class="s1">static fromSourceMap(aSourceMap, aSourceMapURL) {</span>
    <span class="s3">return </span><span class="s1">_factoryBSM(aSourceMap, aSourceMapURL);</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Construct a new `SourceMapConsumer` from `rawSourceMap` and `sourceMapUrl` 
   * (see the `SourceMapConsumer` constructor for details. Then, invoke the `async 
   * function f(SourceMapConsumer) -&gt; T` with the newly constructed consumer, wait 
   * for `f` to complete, call `destroy` on the consumer, and return `f`'s return 
   * value. 
   * 
   * You must not use the consumer after `f` completes! 
   * 
   * By using `with`, you do not have to remember to manually call `destroy` on 
   * the consumer, since it will be called automatically once `f` completes. 
   * 
   * ```js 
   * const xSquared = await SourceMapConsumer.with( 
   *   myRawSourceMap, 
   *   null, 
   *   async function (consumer) { 
   *     // Use `consumer` inside here and don't worry about remembering 
   *     // to call `destroy`. 
   * 
   *     const x = await whatever(consumer); 
   *     return x * x; 
   *   } 
   * ); 
   * 
   * // You may not use that `consumer` anymore out here; it has 
   * // been destroyed. But you can use `xSquared`. 
   * console.log(xSquared); 
   * ``` 
   */</span>
  <span class="s1">static async </span><span class="s3">with</span><span class="s1">(rawSourceMap, sourceMapUrl, f) {</span>
    <span class="s1">const consumer = await </span><span class="s3">new </span><span class="s1">SourceMapConsumer(rawSourceMap, sourceMapUrl);</span>
    <span class="s3">try </span><span class="s1">{</span>
      <span class="s3">return </span><span class="s1">await f(consumer);</span>
    <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
      <span class="s1">consumer.destroy();</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Parse the mappings in a string in to a data structure which we can easily 
   * query (the ordered arrays in the `this.__generatedMappings` and 
   * `this.__originalMappings` properties). 
   */</span>
  <span class="s1">_parseMappings(aStr, aSourceRoot) {</span>
    <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Subclasses must implement _parseMappings&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Iterate over each mapping between an original source/line/column and a 
   * generated line/column in this source map. 
   * 
   * @param Function aCallback 
   *        The function that is called with each mapping. 
   * @param Object aContext 
   *        Optional. If specified, this object will be the value of `this` every 
   *        time that `aCallback` is called. 
   * @param aOrder 
   *        Either `SourceMapConsumer.GENERATED_ORDER` or 
   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to 
   *        iterate over the mappings sorted by the generated file's line/column 
   *        order or the original's source/line/column order, respectively. Defaults to 
   *        `SourceMapConsumer.GENERATED_ORDER`. 
   */</span>
  <span class="s1">eachMapping(aCallback, aContext, aOrder) {</span>
    <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Subclasses must implement eachMapping&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Returns all generated line and column information for the original source, 
   * line, and column provided. If no column is provided, returns all mappings 
   * corresponding to a either the line we are searching for or the next 
   * closest line that has any mappings. Otherwise, returns all mappings 
   * corresponding to the given line and either the column we are searching for 
   * or the next closest column that has any offsets. 
   * 
   * The only argument is an object with the following properties: 
   * 
   *   - source: The filename of the original source. 
   *   - line: The line number in the original source.  The line number is 1-based. 
   *   - column: Optional. the column number in the original source. 
   *    The column number is 0-based. 
   * 
   * and an array of objects is returned, each with the following properties: 
   * 
   *   - line: The line number in the generated source, or null.  The 
   *    line number is 1-based. 
   *   - column: The column number in the generated source, or null. 
   *    The column number is 0-based. 
   */</span>
  <span class="s1">allGeneratedPositionsFor(aArgs) {</span>
    <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Subclasses must implement allGeneratedPositionsFor&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s1">destroy() {</span>
    <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Subclasses must implement destroy&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">/** 
 * The version of the source mapping spec that we are consuming. 
 */</span>
<span class="s1">SourceMapConsumer.prototype._version = </span><span class="s4">3</span><span class="s1">;</span>
<span class="s1">SourceMapConsumer.GENERATED_ORDER = </span><span class="s4">1</span><span class="s1">;</span>
<span class="s1">SourceMapConsumer.ORIGINAL_ORDER = </span><span class="s4">2</span><span class="s1">;</span>

<span class="s1">SourceMapConsumer.GREATEST_LOWER_BOUND = </span><span class="s4">1</span><span class="s1">;</span>
<span class="s1">SourceMapConsumer.LEAST_UPPER_BOUND = </span><span class="s4">2</span><span class="s1">;</span>

<span class="s1">exports.SourceMapConsumer = SourceMapConsumer;</span>

<span class="s0">/** 
 * A BasicSourceMapConsumer instance represents a parsed source map which we can 
 * query for information about the original file positions by giving it a file 
 * position in the generated source. 
 * 
 * The first parameter is the raw source map (either as a JSON string, or 
 * already parsed to an object). According to the spec, source maps have the 
 * following attributes: 
 * 
 *   - version: Which version of the source map spec this map is following. 
 *   - sources: An array of URLs to the original source files. 
 *   - names: An array of identifiers which can be referenced by individual mappings. 
 *   - sourceRoot: Optional. The URL root from which all sources are relative. 
 *   - sourcesContent: Optional. An array of contents of the original source files. 
 *   - mappings: A string of base64 VLQs which contain the actual mappings. 
 *   - file: Optional. The generated file this source map is associated with. 
 * 
 * Here is an example source map, taken from the source map spec[0]: 
 * 
 *     { 
 *       version : 3, 
 *       file: &quot;out.js&quot;, 
 *       sourceRoot : &quot;&quot;, 
 *       sources: [&quot;foo.js&quot;, &quot;bar.js&quot;], 
 *       names: [&quot;src&quot;, &quot;maps&quot;, &quot;are&quot;, &quot;fun&quot;], 
 *       mappings: &quot;AA,AB;;ABCDE;&quot; 
 *     } 
 * 
 * The second parameter, if given, is a string whose value is the URL 
 * at which the source map was found.  This URL is used to compute the 
 * sources array. 
 * 
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1# 
 */</span>
<span class="s1">class BasicSourceMapConsumer extends SourceMapConsumer {</span>
  <span class="s1">constructor(aSourceMap, aSourceMapURL) {</span>
    <span class="s3">return </span><span class="s1">super(INTERNAL).then(that =&gt; {</span>
      <span class="s1">let sourceMap = aSourceMap;</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">aSourceMap === </span><span class="s2">&quot;string&quot;</span><span class="s1">) {</span>
        <span class="s1">sourceMap = util.parseSourceMapInput(aSourceMap);</span>
      <span class="s1">}</span>

      <span class="s1">const version = util.getArg(sourceMap, </span><span class="s2">&quot;version&quot;</span><span class="s1">);</span>
      <span class="s1">let sources = util.getArg(sourceMap, </span><span class="s2">&quot;sources&quot;</span><span class="s1">);</span>
      <span class="s0">// Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which</span>
      <span class="s0">// requires the array) to play nice here.</span>
      <span class="s1">const names = util.getArg(sourceMap, </span><span class="s2">&quot;names&quot;</span><span class="s1">, []);</span>
      <span class="s1">let sourceRoot = util.getArg(sourceMap, </span><span class="s2">&quot;sourceRoot&quot;</span><span class="s1">, </span><span class="s3">null</span><span class="s1">);</span>
      <span class="s1">const sourcesContent = util.getArg(sourceMap, </span><span class="s2">&quot;sourcesContent&quot;</span><span class="s1">, </span><span class="s3">null</span><span class="s1">);</span>
      <span class="s1">const mappings = util.getArg(sourceMap, </span><span class="s2">&quot;mappings&quot;</span><span class="s1">);</span>
      <span class="s1">const file = util.getArg(sourceMap, </span><span class="s2">&quot;file&quot;</span><span class="s1">, </span><span class="s3">null</span><span class="s1">);</span>

      <span class="s0">// Once again, Sass deviates from the spec and supplies the version as a</span>
      <span class="s0">// string rather than a number, so we use loose equality checking here.</span>
      <span class="s3">if </span><span class="s1">(version != that._version) {</span>
        <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Unsupported version: &quot; </span><span class="s1">+ version);</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(sourceRoot) {</span>
        <span class="s1">sourceRoot = util.normalize(sourceRoot);</span>
      <span class="s1">}</span>

      <span class="s1">sources = sources</span>
        <span class="s1">.map(String)</span>
        <span class="s0">// Some source maps produce relative source paths like &quot;./foo.js&quot; instead of</span>
        <span class="s0">// &quot;foo.js&quot;.  Normalize these first so that future comparisons will succeed.</span>
        <span class="s0">// See bugzil.la/1090768.</span>
        <span class="s1">.map(util.normalize)</span>
        <span class="s0">// Always ensure that absolute sources are internally stored relative to</span>
        <span class="s0">// the source root, if the source root is absolute. Not doing this would</span>
        <span class="s0">// be particularly problematic when the source root is a prefix of the</span>
        <span class="s0">// source (valid, but why??). See github issue #199 and bugzil.la/1188982.</span>
        <span class="s1">.map(</span><span class="s3">function</span><span class="s1">(source) {</span>
          <span class="s3">return </span><span class="s1">sourceRoot &amp;&amp; util.isAbsolute(sourceRoot) &amp;&amp; util.isAbsolute(source)</span>
            <span class="s1">? util.relative(sourceRoot, source)</span>
            <span class="s1">: source;</span>
        <span class="s1">});</span>

      <span class="s0">// Pass `true` below to allow duplicate names and sources. While source maps</span>
      <span class="s0">// are intended to be compressed and deduplicated, the TypeScript compiler</span>
      <span class="s0">// sometimes generates source maps with duplicates in them. See Github issue</span>
      <span class="s0">// #72 and bugzil.la/889492.</span>
      <span class="s1">that._names = ArraySet.fromArray(names.map(String), </span><span class="s3">true</span><span class="s1">);</span>
      <span class="s1">that._sources = ArraySet.fromArray(sources, </span><span class="s3">true</span><span class="s1">);</span>

      <span class="s1">that._absoluteSources = that._sources.toArray().map(</span><span class="s3">function</span><span class="s1">(s) {</span>
        <span class="s3">return </span><span class="s1">util.computeSourceURL(sourceRoot, s, aSourceMapURL);</span>
      <span class="s1">});</span>

      <span class="s1">that.sourceRoot = sourceRoot;</span>
      <span class="s1">that.sourcesContent = sourcesContent;</span>
      <span class="s1">that._mappings = mappings;</span>
      <span class="s1">that._sourceMapURL = aSourceMapURL;</span>
      <span class="s1">that.file = file;</span>

      <span class="s1">that._computedColumnSpans = </span><span class="s3">false</span><span class="s1">;</span>
      <span class="s1">that._mappingsPtr = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s1">that._wasm = </span><span class="s3">null</span><span class="s1">;</span>

      <span class="s3">return </span><span class="s1">wasm().then(w =&gt; {</span>
        <span class="s1">that._wasm = w;</span>
        <span class="s3">return </span><span class="s1">that;</span>
      <span class="s1">});</span>
    <span class="s1">});</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Utility function to find the index of a source.  Returns -1 if not 
   * found. 
   */</span>
  <span class="s1">_findSourceIndex(aSource) {</span>
    <span class="s1">let relativeSource = aSource;</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.sourceRoot != </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">relativeSource = util.relative(</span><span class="s3">this</span><span class="s1">.sourceRoot, relativeSource);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._sources.has(relativeSource)) {</span>
      <span class="s3">return this</span><span class="s1">._sources.indexOf(relativeSource);</span>
    <span class="s1">}</span>

    <span class="s0">// Maybe aSource is an absolute URL as returned by |sources|.  In</span>
    <span class="s0">// this case we can't simply undo the transform.</span>
    <span class="s3">for </span><span class="s1">(let i = </span><span class="s4">0</span><span class="s1">; i &lt; </span><span class="s3">this</span><span class="s1">._absoluteSources.length; ++i) {</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._absoluteSources[i] == aSource) {</span>
        <span class="s3">return </span><span class="s1">i;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">-</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Create a BasicSourceMapConsumer from a SourceMapGenerator. 
   * 
   * @param SourceMapGenerator aSourceMap 
   *        The source map that will be consumed. 
   * @param String aSourceMapURL 
   *        The URL at which the source map can be found (optional) 
   * @returns BasicSourceMapConsumer 
   */</span>
  <span class="s1">static fromSourceMap(aSourceMap, aSourceMapURL) {</span>
    <span class="s3">return new </span><span class="s1">BasicSourceMapConsumer(aSourceMap.toString());</span>
  <span class="s1">}</span>

  <span class="s1">get sources() {</span>
    <span class="s3">return this</span><span class="s1">._absoluteSources.slice();</span>
  <span class="s1">}</span>

  <span class="s1">_getMappingsPtr() {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._mappingsPtr === </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s3">this</span><span class="s1">._parseMappings(</span><span class="s3">this</span><span class="s1">._mappings, </span><span class="s3">this</span><span class="s1">.sourceRoot);</span>
    <span class="s1">}</span>

    <span class="s3">return this</span><span class="s1">._mappingsPtr;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Parse the mappings in a string in to a data structure which we can easily 
   * query (the ordered arrays in the `this.__generatedMappings` and 
   * `this.__originalMappings` properties). 
   */</span>
  <span class="s1">_parseMappings(aStr, aSourceRoot) {</span>
    <span class="s1">const size = aStr.length;</span>

    <span class="s1">const mappingsBufPtr = </span><span class="s3">this</span><span class="s1">._wasm.exports.allocate_mappings(size);</span>
    <span class="s1">const mappingsBuf = </span><span class="s3">new </span><span class="s1">Uint8Array(</span><span class="s3">this</span><span class="s1">._wasm.exports.memory.buffer, mappingsBufPtr, size);</span>
    <span class="s3">for </span><span class="s1">(let i = </span><span class="s4">0</span><span class="s1">; i &lt; size; i++) {</span>
      <span class="s1">mappingsBuf[i] = aStr.charCodeAt(i);</span>
    <span class="s1">}</span>

    <span class="s1">const mappingsPtr = </span><span class="s3">this</span><span class="s1">._wasm.exports.parse_mappings(mappingsBufPtr);</span>

    <span class="s3">if </span><span class="s1">(!mappingsPtr) {</span>
      <span class="s1">const error = </span><span class="s3">this</span><span class="s1">._wasm.exports.get_last_error();</span>
      <span class="s1">let msg = `Error parsing mappings (code ${error}): `;</span>

      <span class="s0">// XXX: keep these error codes in sync with `fitzgen/source-map-mappings`.</span>
      <span class="s3">switch </span><span class="s1">(error) {</span>
        <span class="s3">case </span><span class="s4">1</span><span class="s1">:</span>
          <span class="s1">msg += </span><span class="s2">&quot;the mappings contained a negative line, column, source index, or name index&quot;</span><span class="s1">;</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s4">2</span><span class="s1">:</span>
          <span class="s1">msg += </span><span class="s2">&quot;the mappings contained a number larger than 2**32&quot;</span><span class="s1">;</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s4">3</span><span class="s1">:</span>
          <span class="s1">msg += </span><span class="s2">&quot;reached EOF while in the middle of parsing a VLQ&quot;</span><span class="s1">;</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s4">4</span><span class="s1">:</span>
          <span class="s1">msg += </span><span class="s2">&quot;invalid base 64 character while parsing a VLQ&quot;</span><span class="s1">;</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s3">default</span><span class="s1">:</span>
          <span class="s1">msg += </span><span class="s2">&quot;unknown error code&quot;</span><span class="s1">;</span>
          <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">throw new </span><span class="s1">Error(msg);</span>
    <span class="s1">}</span>

    <span class="s3">this</span><span class="s1">._mappingsPtr = mappingsPtr;</span>
  <span class="s1">}</span>

  <span class="s1">eachMapping(aCallback, aContext, aOrder) {</span>
    <span class="s1">const context = aContext || </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">const order = aOrder || SourceMapConsumer.GENERATED_ORDER;</span>
    <span class="s1">const sourceRoot = </span><span class="s3">this</span><span class="s1">.sourceRoot;</span>

    <span class="s3">this</span><span class="s1">._wasm.withMappingCallback(</span>
      <span class="s1">mapping =&gt; {</span>
        <span class="s3">if </span><span class="s1">(mapping.source !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">mapping.source = </span><span class="s3">this</span><span class="s1">._sources.at(mapping.source);</span>
          <span class="s1">mapping.source = util.computeSourceURL(sourceRoot, mapping.source, </span><span class="s3">this</span><span class="s1">._sourceMapURL);</span>

          <span class="s3">if </span><span class="s1">(mapping.name !== </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s1">mapping.name = </span><span class="s3">this</span><span class="s1">._names.at(mapping.name);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s1">aCallback.call(context, mapping);</span>
      <span class="s1">},</span>
      <span class="s1">() =&gt; {</span>
        <span class="s3">switch </span><span class="s1">(order) {</span>
        <span class="s3">case </span><span class="s1">SourceMapConsumer.GENERATED_ORDER:</span>
          <span class="s3">this</span><span class="s1">._wasm.exports.by_generated_location(</span><span class="s3">this</span><span class="s1">._getMappingsPtr());</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s1">SourceMapConsumer.ORIGINAL_ORDER:</span>
          <span class="s3">this</span><span class="s1">._wasm.exports.by_original_location(</span><span class="s3">this</span><span class="s1">._getMappingsPtr());</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s3">default</span><span class="s1">:</span>
          <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Unknown order of iteration.&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s1">allGeneratedPositionsFor(aArgs) {</span>
    <span class="s1">let source = util.getArg(aArgs, </span><span class="s2">&quot;source&quot;</span><span class="s1">);</span>
    <span class="s1">const originalLine = util.getArg(aArgs, </span><span class="s2">&quot;line&quot;</span><span class="s1">);</span>
    <span class="s1">const originalColumn = aArgs.column || </span><span class="s4">0</span><span class="s1">;</span>

    <span class="s1">source = </span><span class="s3">this</span><span class="s1">._findSourceIndex(source);</span>
    <span class="s3">if </span><span class="s1">(source &lt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s3">return </span><span class="s1">[];</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(originalLine &lt; </span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Line numbers must be &gt;= 1&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(originalColumn &lt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Column numbers must be &gt;= 0&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s1">const mappings = [];</span>

    <span class="s3">this</span><span class="s1">._wasm.withMappingCallback(</span>
      <span class="s1">m =&gt; {</span>
        <span class="s1">let lastColumn = m.lastGeneratedColumn;</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._computedColumnSpans &amp;&amp; lastColumn === </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">lastColumn = Infinity;</span>
        <span class="s1">}</span>
        <span class="s1">mappings.push({</span>
          <span class="s1">line: m.generatedLine,</span>
          <span class="s1">column: m.generatedColumn,</span>
          <span class="s1">lastColumn,</span>
        <span class="s1">});</span>
      <span class="s1">}, () =&gt; {</span>
        <span class="s3">this</span><span class="s1">._wasm.exports.all_generated_locations_for(</span>
          <span class="s3">this</span><span class="s1">._getMappingsPtr(),</span>
          <span class="s1">source,</span>
          <span class="s1">originalLine - </span><span class="s4">1</span><span class="s1">,</span>
          <span class="s2">&quot;column&quot; </span><span class="s3">in </span><span class="s1">aArgs,</span>
          <span class="s1">originalColumn</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">);</span>

    <span class="s3">return </span><span class="s1">mappings;</span>
  <span class="s1">}</span>

  <span class="s1">destroy() {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._mappingsPtr !== </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s3">this</span><span class="s1">._wasm.exports.free_mappings(</span><span class="s3">this</span><span class="s1">._mappingsPtr);</span>
      <span class="s3">this</span><span class="s1">._mappingsPtr = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Compute the last column for each generated mapping. The last column is 
   * inclusive. 
   */</span>
  <span class="s1">computeColumnSpans() {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._computedColumnSpans) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">this</span><span class="s1">._wasm.exports.compute_column_spans(</span><span class="s3">this</span><span class="s1">._getMappingsPtr());</span>
    <span class="s3">this</span><span class="s1">._computedColumnSpans = </span><span class="s3">true</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Returns the original source, line, and column information for the generated 
   * source's line and column positions provided. The only argument is an object 
   * with the following properties: 
   * 
   *   - line: The line number in the generated source.  The line number 
   *     is 1-based. 
   *   - column: The column number in the generated source.  The column 
   *     number is 0-based. 
   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or 
   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the 
   *     closest element that is smaller than or greater than the one we are 
   *     searching for, respectively, if the exact element cannot be found. 
   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'. 
   * 
   * and an object is returned with the following properties: 
   * 
   *   - source: The original source file, or null. 
   *   - line: The line number in the original source, or null.  The 
   *     line number is 1-based. 
   *   - column: The column number in the original source, or null.  The 
   *     column number is 0-based. 
   *   - name: The original identifier, or null. 
   */</span>
  <span class="s1">originalPositionFor(aArgs) {</span>
    <span class="s1">const needle = {</span>
      <span class="s1">generatedLine: util.getArg(aArgs, </span><span class="s2">&quot;line&quot;</span><span class="s1">),</span>
      <span class="s1">generatedColumn: util.getArg(aArgs, </span><span class="s2">&quot;column&quot;</span><span class="s1">)</span>
    <span class="s1">};</span>

    <span class="s3">if </span><span class="s1">(needle.generatedLine &lt; </span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Line numbers must be &gt;= 1&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(needle.generatedColumn &lt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Column numbers must be &gt;= 0&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s1">let bias = util.getArg(aArgs, </span><span class="s2">&quot;bias&quot;</span><span class="s1">, SourceMapConsumer.GREATEST_LOWER_BOUND);</span>
    <span class="s3">if </span><span class="s1">(bias == </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">bias = SourceMapConsumer.GREATEST_LOWER_BOUND;</span>
    <span class="s1">}</span>

    <span class="s1">let mapping;</span>
    <span class="s3">this</span><span class="s1">._wasm.withMappingCallback(m =&gt; mapping = m, () =&gt; {</span>
      <span class="s3">this</span><span class="s1">._wasm.exports.original_location_for(</span>
        <span class="s3">this</span><span class="s1">._getMappingsPtr(),</span>
        <span class="s1">needle.generatedLine - </span><span class="s4">1</span><span class="s1">,</span>
        <span class="s1">needle.generatedColumn,</span>
        <span class="s1">bias</span>
      <span class="s1">);</span>
    <span class="s1">});</span>

    <span class="s3">if </span><span class="s1">(mapping) {</span>
      <span class="s3">if </span><span class="s1">(mapping.generatedLine === needle.generatedLine) {</span>
        <span class="s1">let source = util.getArg(mapping, </span><span class="s2">&quot;source&quot;</span><span class="s1">, </span><span class="s3">null</span><span class="s1">);</span>
        <span class="s3">if </span><span class="s1">(source !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">source = </span><span class="s3">this</span><span class="s1">._sources.at(source);</span>
          <span class="s1">source = util.computeSourceURL(</span><span class="s3">this</span><span class="s1">.sourceRoot, source, </span><span class="s3">this</span><span class="s1">._sourceMapURL);</span>
        <span class="s1">}</span>

        <span class="s1">let name = util.getArg(mapping, </span><span class="s2">&quot;name&quot;</span><span class="s1">, </span><span class="s3">null</span><span class="s1">);</span>
        <span class="s3">if </span><span class="s1">(name !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">name = </span><span class="s3">this</span><span class="s1">._names.at(name);</span>
        <span class="s1">}</span>

        <span class="s3">return </span><span class="s1">{</span>
          <span class="s1">source,</span>
          <span class="s1">line: util.getArg(mapping, </span><span class="s2">&quot;originalLine&quot;</span><span class="s1">, </span><span class="s3">null</span><span class="s1">),</span>
          <span class="s1">column: util.getArg(mapping, </span><span class="s2">&quot;originalColumn&quot;</span><span class="s1">, </span><span class="s3">null</span><span class="s1">),</span>
          <span class="s1">name</span>
        <span class="s1">};</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">{</span>
      <span class="s1">source: </span><span class="s3">null</span><span class="s1">,</span>
      <span class="s1">line: </span><span class="s3">null</span><span class="s1">,</span>
      <span class="s1">column: </span><span class="s3">null</span><span class="s1">,</span>
      <span class="s1">name: </span><span class="s3">null</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Return true if we have the source content for every source in the source 
   * map, false otherwise. 
   */</span>
  <span class="s1">hasContentsOfAllSources() {</span>
    <span class="s3">if </span><span class="s1">(!</span><span class="s3">this</span><span class="s1">.sourcesContent) {</span>
      <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">return this</span><span class="s1">.sourcesContent.length &gt;= </span><span class="s3">this</span><span class="s1">._sources.size() &amp;&amp;</span>
      <span class="s1">!</span><span class="s3">this</span><span class="s1">.sourcesContent.some(</span><span class="s3">function</span><span class="s1">(sc) { </span><span class="s3">return </span><span class="s1">sc == </span><span class="s3">null</span><span class="s1">; });</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Returns the original source content. The only argument is the url of the 
   * original source file. Returns null if no original source content is 
   * available. 
   */</span>
  <span class="s1">sourceContentFor(aSource, nullOnMissing) {</span>
    <span class="s3">if </span><span class="s1">(!</span><span class="s3">this</span><span class="s1">.sourcesContent) {</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">const index = </span><span class="s3">this</span><span class="s1">._findSourceIndex(aSource);</span>
    <span class="s3">if </span><span class="s1">(index &gt;= </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s3">return this</span><span class="s1">.sourcesContent[index];</span>
    <span class="s1">}</span>

    <span class="s1">let relativeSource = aSource;</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.sourceRoot != </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">relativeSource = util.relative(</span><span class="s3">this</span><span class="s1">.sourceRoot, relativeSource);</span>
    <span class="s1">}</span>

    <span class="s1">let url;</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.sourceRoot != </span><span class="s3">null</span>
        <span class="s1">&amp;&amp; (url = util.urlParse(</span><span class="s3">this</span><span class="s1">.sourceRoot))) {</span>
      <span class="s0">// XXX: file:// URIs and absolute paths lead to unexpected behavior for</span>
      <span class="s0">// many users. We can help them out when they expect file:// URIs to</span>
      <span class="s0">// behave like it would if they were running a local HTTP server. See</span>
      <span class="s0">// https://bugzilla.mozilla.org/show_bug.cgi?id=885597.</span>
      <span class="s1">const fileUriAbsPath = relativeSource.replace(/^file:\/\</span><span class="s0">//, &quot;&quot;);</span>
      <span class="s3">if </span><span class="s1">(url.scheme == </span><span class="s2">&quot;file&quot;</span>
          <span class="s1">&amp;&amp; </span><span class="s3">this</span><span class="s1">._sources.has(fileUriAbsPath)) {</span>
        <span class="s3">return this</span><span class="s1">.sourcesContent[</span><span class="s3">this</span><span class="s1">._sources.indexOf(fileUriAbsPath)];</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">((!url.path || url.path == </span><span class="s2">&quot;/&quot;</span><span class="s1">)</span>
          <span class="s1">&amp;&amp; </span><span class="s3">this</span><span class="s1">._sources.has(</span><span class="s2">&quot;/&quot; </span><span class="s1">+ relativeSource)) {</span>
        <span class="s3">return this</span><span class="s1">.sourcesContent[</span><span class="s3">this</span><span class="s1">._sources.indexOf(</span><span class="s2">&quot;/&quot; </span><span class="s1">+ relativeSource)];</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">// This function is used recursively from</span>
    <span class="s0">// IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we</span>
    <span class="s0">// don't want to throw if we can't find the source - we just want to</span>
    <span class="s0">// return null, so we provide a flag to exit gracefully.</span>
    <span class="s3">if </span><span class="s1">(nullOnMissing) {</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">'&quot;' </span><span class="s1">+ relativeSource + </span><span class="s2">'&quot; is not in the SourceMap.'</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Returns the generated line and column information for the original source, 
   * line, and column positions provided. The only argument is an object with 
   * the following properties: 
   * 
   *   - source: The filename of the original source. 
   *   - line: The line number in the original source.  The line number 
   *     is 1-based. 
   *   - column: The column number in the original source.  The column 
   *     number is 0-based. 
   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or 
   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the 
   *     closest element that is smaller than or greater than the one we are 
   *     searching for, respectively, if the exact element cannot be found. 
   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'. 
   * 
   * and an object is returned with the following properties: 
   * 
   *   - line: The line number in the generated source, or null.  The 
   *     line number is 1-based. 
   *   - column: The column number in the generated source, or null. 
   *     The column number is 0-based. 
   */</span>
  <span class="s1">generatedPositionFor(aArgs) {</span>
    <span class="s1">let source = util.getArg(aArgs, </span><span class="s2">&quot;source&quot;</span><span class="s1">);</span>
    <span class="s1">source = </span><span class="s3">this</span><span class="s1">._findSourceIndex(source);</span>
    <span class="s3">if </span><span class="s1">(source &lt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s3">return </span><span class="s1">{</span>
        <span class="s1">line: </span><span class="s3">null</span><span class="s1">,</span>
        <span class="s1">column: </span><span class="s3">null</span><span class="s1">,</span>
        <span class="s1">lastColumn: </span><span class="s3">null</span>
      <span class="s1">};</span>
    <span class="s1">}</span>

    <span class="s1">const needle = {</span>
      <span class="s1">source,</span>
      <span class="s1">originalLine: util.getArg(aArgs, </span><span class="s2">&quot;line&quot;</span><span class="s1">),</span>
      <span class="s1">originalColumn: util.getArg(aArgs, </span><span class="s2">&quot;column&quot;</span><span class="s1">)</span>
    <span class="s1">};</span>

    <span class="s3">if </span><span class="s1">(needle.originalLine &lt; </span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Line numbers must be &gt;= 1&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(needle.originalColumn &lt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Column numbers must be &gt;= 0&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s1">let bias = util.getArg(aArgs, </span><span class="s2">&quot;bias&quot;</span><span class="s1">, SourceMapConsumer.GREATEST_LOWER_BOUND);</span>
    <span class="s3">if </span><span class="s1">(bias == </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">bias = SourceMapConsumer.GREATEST_LOWER_BOUND;</span>
    <span class="s1">}</span>

    <span class="s1">let mapping;</span>
    <span class="s3">this</span><span class="s1">._wasm.withMappingCallback(m =&gt; mapping = m, () =&gt; {</span>
      <span class="s3">this</span><span class="s1">._wasm.exports.generated_location_for(</span>
        <span class="s3">this</span><span class="s1">._getMappingsPtr(),</span>
        <span class="s1">needle.source,</span>
        <span class="s1">needle.originalLine - </span><span class="s4">1</span><span class="s1">,</span>
        <span class="s1">needle.originalColumn,</span>
        <span class="s1">bias</span>
      <span class="s1">);</span>
    <span class="s1">});</span>

    <span class="s3">if </span><span class="s1">(mapping) {</span>
      <span class="s3">if </span><span class="s1">(mapping.source === needle.source) {</span>
        <span class="s1">let lastColumn = mapping.lastGeneratedColumn;</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._computedColumnSpans &amp;&amp; lastColumn === </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">lastColumn = Infinity;</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">{</span>
          <span class="s1">line: util.getArg(mapping, </span><span class="s2">&quot;generatedLine&quot;</span><span class="s1">, </span><span class="s3">null</span><span class="s1">),</span>
          <span class="s1">column: util.getArg(mapping, </span><span class="s2">&quot;generatedColumn&quot;</span><span class="s1">, </span><span class="s3">null</span><span class="s1">),</span>
          <span class="s1">lastColumn,</span>
        <span class="s1">};</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">{</span>
      <span class="s1">line: </span><span class="s3">null</span><span class="s1">,</span>
      <span class="s1">column: </span><span class="s3">null</span><span class="s1">,</span>
      <span class="s1">lastColumn: </span><span class="s3">null</span>
    <span class="s1">};</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;</span>
<span class="s1">exports.BasicSourceMapConsumer = BasicSourceMapConsumer;</span>

<span class="s0">/** 
 * An IndexedSourceMapConsumer instance represents a parsed source map which 
 * we can query for information. It differs from BasicSourceMapConsumer in 
 * that it takes &quot;indexed&quot; source maps (i.e. ones with a &quot;sections&quot; field) as 
 * input. 
 * 
 * The first parameter is a raw source map (either as a JSON string, or already 
 * parsed to an object). According to the spec for indexed source maps, they 
 * have the following attributes: 
 * 
 *   - version: Which version of the source map spec this map is following. 
 *   - file: Optional. The generated file this source map is associated with. 
 *   - sections: A list of section definitions. 
 * 
 * Each value under the &quot;sections&quot; field has two fields: 
 *   - offset: The offset into the original specified at which this section 
 *       begins to apply, defined as an object with a &quot;line&quot; and &quot;column&quot; 
 *       field. 
 *   - map: A source map definition. This source map could also be indexed, 
 *       but doesn't have to be. 
 * 
 * Instead of the &quot;map&quot; field, it's also possible to have a &quot;url&quot; field 
 * specifying a URL to retrieve a source map from, but that's currently 
 * unsupported. 
 * 
 * Here's an example source map, taken from the source map spec[0], but 
 * modified to omit a section which uses the &quot;url&quot; field. 
 * 
 *  { 
 *    version : 3, 
 *    file: &quot;app.js&quot;, 
 *    sections: [{ 
 *      offset: {line:100, column:10}, 
 *      map: { 
 *        version : 3, 
 *        file: &quot;section.js&quot;, 
 *        sources: [&quot;foo.js&quot;, &quot;bar.js&quot;], 
 *        names: [&quot;src&quot;, &quot;maps&quot;, &quot;are&quot;, &quot;fun&quot;], 
 *        mappings: &quot;AAAA,E;;ABCDE;&quot; 
 *      } 
 *    }], 
 *  } 
 * 
 * The second parameter, if given, is a string whose value is the URL 
 * at which the source map was found.  This URL is used to compute the 
 * sources array. 
 * 
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt 
 */</span>
<span class="s1">class IndexedSourceMapConsumer extends SourceMapConsumer {</span>
  <span class="s1">constructor(aSourceMap, aSourceMapURL) {</span>
    <span class="s3">return </span><span class="s1">super(INTERNAL).then(that =&gt; {</span>
      <span class="s1">let sourceMap = aSourceMap;</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">aSourceMap === </span><span class="s2">&quot;string&quot;</span><span class="s1">) {</span>
        <span class="s1">sourceMap = util.parseSourceMapInput(aSourceMap);</span>
      <span class="s1">}</span>

      <span class="s1">const version = util.getArg(sourceMap, </span><span class="s2">&quot;version&quot;</span><span class="s1">);</span>
      <span class="s1">const sections = util.getArg(sourceMap, </span><span class="s2">&quot;sections&quot;</span><span class="s1">);</span>

      <span class="s3">if </span><span class="s1">(version != that._version) {</span>
        <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Unsupported version: &quot; </span><span class="s1">+ version);</span>
      <span class="s1">}</span>

      <span class="s1">that._sources = </span><span class="s3">new </span><span class="s1">ArraySet();</span>
      <span class="s1">that._names = </span><span class="s3">new </span><span class="s1">ArraySet();</span>
      <span class="s1">that.__generatedMappings = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">that.__originalMappings = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">that.__generatedMappingsUnsorted = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">that.__originalMappingsUnsorted = </span><span class="s3">null</span><span class="s1">;</span>

      <span class="s1">let lastOffset = {</span>
        <span class="s1">line: -</span><span class="s4">1</span><span class="s1">,</span>
        <span class="s1">column: </span><span class="s4">0</span>
      <span class="s1">};</span>
      <span class="s3">return </span><span class="s1">Promise.all(sections.map(s =&gt; {</span>
        <span class="s3">if </span><span class="s1">(s.url) {</span>
          <span class="s0">// The url field will require support for asynchronicity.</span>
          <span class="s0">// See https://github.com/mozilla/source-map/issues/16</span>
          <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Support for url field in sections not implemented.&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s1">const offset = util.getArg(s, </span><span class="s2">&quot;offset&quot;</span><span class="s1">);</span>
        <span class="s1">const offsetLine = util.getArg(offset, </span><span class="s2">&quot;line&quot;</span><span class="s1">);</span>
        <span class="s1">const offsetColumn = util.getArg(offset, </span><span class="s2">&quot;column&quot;</span><span class="s1">);</span>

        <span class="s3">if </span><span class="s1">(offsetLine &lt; lastOffset.line ||</span>
            <span class="s1">(offsetLine === lastOffset.line &amp;&amp; offsetColumn &lt; lastOffset.column)) {</span>
          <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Section offsets must be ordered and non-overlapping.&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s1">lastOffset = offset;</span>

        <span class="s1">const cons = </span><span class="s3">new </span><span class="s1">SourceMapConsumer(util.getArg(s, </span><span class="s2">&quot;map&quot;</span><span class="s1">), aSourceMapURL);</span>
        <span class="s3">return </span><span class="s1">cons.then(consumer =&gt; {</span>
          <span class="s3">return </span><span class="s1">{</span>
            <span class="s1">generatedOffset: {</span>
              <span class="s0">// The offset fields are 0-based, but we use 1-based indices when</span>
              <span class="s0">// encoding/decoding from VLQ.</span>
              <span class="s1">generatedLine: offsetLine + </span><span class="s4">1</span><span class="s1">,</span>
              <span class="s1">generatedColumn: offsetColumn + </span><span class="s4">1</span>
            <span class="s1">},</span>
            <span class="s1">consumer</span>
          <span class="s1">};</span>
        <span class="s1">});</span>
      <span class="s1">})).then(s =&gt; {</span>
        <span class="s1">that._sections = s;</span>
        <span class="s3">return </span><span class="s1">that;</span>
      <span class="s1">});</span>
    <span class="s1">});</span>
  <span class="s1">}</span>

  <span class="s0">// `__generatedMappings` and `__originalMappings` are arrays that hold the</span>
  <span class="s0">// parsed mapping coordinates from the source map's &quot;mappings&quot; attribute. They</span>
  <span class="s0">// are lazily instantiated, accessed via the `_generatedMappings` and</span>
  <span class="s0">// `_originalMappings` getters respectively, and we only parse the mappings</span>
  <span class="s0">// and create these arrays once queried for a source location. We jump through</span>
  <span class="s0">// these hoops because there can be many thousands of mappings, and parsing</span>
  <span class="s0">// them is expensive, so we only want to do it if we must.</span>
  <span class="s0">//</span>
  <span class="s0">// Each object in the arrays is of the form:</span>
  <span class="s0">//</span>
  <span class="s0">//     {</span>
  <span class="s0">//       generatedLine: The line number in the generated code,</span>
  <span class="s0">//       generatedColumn: The column number in the generated code,</span>
  <span class="s0">//       source: The path to the original source file that generated this</span>
  <span class="s0">//               chunk of code,</span>
  <span class="s0">//       originalLine: The line number in the original source that</span>
  <span class="s0">//                     corresponds to this chunk of generated code,</span>
  <span class="s0">//       originalColumn: The column number in the original source that</span>
  <span class="s0">//                       corresponds to this chunk of generated code,</span>
  <span class="s0">//       name: The name of the original symbol which generated this chunk of</span>
  <span class="s0">//             code.</span>
  <span class="s0">//     }</span>
  <span class="s0">//</span>
  <span class="s0">// All properties except for `generatedLine` and `generatedColumn` can be</span>
  <span class="s0">// `null`.</span>
  <span class="s0">//</span>
  <span class="s0">// `_generatedMappings` is ordered by the generated positions.</span>
  <span class="s0">//</span>
  <span class="s0">// `_originalMappings` is ordered by the original positions.</span>
  <span class="s1">get _generatedMappings() {</span>
    <span class="s3">if </span><span class="s1">(!</span><span class="s3">this</span><span class="s1">.__generatedMappings) {</span>
      <span class="s3">this</span><span class="s1">._sortGeneratedMappings();</span>
    <span class="s1">}</span>

    <span class="s3">return this</span><span class="s1">.__generatedMappings;</span>
  <span class="s1">}</span>

  <span class="s1">get _originalMappings() {</span>
    <span class="s3">if </span><span class="s1">(!</span><span class="s3">this</span><span class="s1">.__originalMappings) {</span>
      <span class="s3">this</span><span class="s1">._sortOriginalMappings();</span>
    <span class="s1">}</span>

    <span class="s3">return this</span><span class="s1">.__originalMappings;</span>
  <span class="s1">}</span>

  <span class="s1">get _generatedMappingsUnsorted() {</span>
    <span class="s3">if </span><span class="s1">(!</span><span class="s3">this</span><span class="s1">.__generatedMappingsUnsorted) {</span>
      <span class="s3">this</span><span class="s1">._parseMappings(</span><span class="s3">this</span><span class="s1">._mappings, </span><span class="s3">this</span><span class="s1">.sourceRoot);</span>
    <span class="s1">}</span>

    <span class="s3">return this</span><span class="s1">.__generatedMappingsUnsorted;</span>
  <span class="s1">}</span>

  <span class="s1">get _originalMappingsUnsorted() {</span>
    <span class="s3">if </span><span class="s1">(!</span><span class="s3">this</span><span class="s1">.__originalMappingsUnsorted) {</span>
      <span class="s3">this</span><span class="s1">._parseMappings(</span><span class="s3">this</span><span class="s1">._mappings, </span><span class="s3">this</span><span class="s1">.sourceRoot);</span>
    <span class="s1">}</span>

    <span class="s3">return this</span><span class="s1">.__originalMappingsUnsorted;</span>
  <span class="s1">}</span>

  <span class="s1">_sortGeneratedMappings() {</span>
    <span class="s1">const mappings = </span><span class="s3">this</span><span class="s1">._generatedMappingsUnsorted;</span>
    <span class="s1">mappings.sort(util.compareByGeneratedPositionsDeflated);</span>
    <span class="s3">this</span><span class="s1">.__generatedMappings = mappings;</span>
  <span class="s1">}</span>

  <span class="s1">_sortOriginalMappings() {</span>
    <span class="s1">const mappings = </span><span class="s3">this</span><span class="s1">._originalMappingsUnsorted;</span>
    <span class="s1">mappings.sort(util.compareByOriginalPositions);</span>
    <span class="s3">this</span><span class="s1">.__originalMappings = mappings;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * The list of original sources. 
   */</span>
  <span class="s1">get sources() {</span>
    <span class="s1">const sources = [];</span>
    <span class="s3">for </span><span class="s1">(let i = </span><span class="s4">0</span><span class="s1">; i &lt; </span><span class="s3">this</span><span class="s1">._sections.length; i++) {</span>
      <span class="s3">for </span><span class="s1">(let j = </span><span class="s4">0</span><span class="s1">; j &lt; </span><span class="s3">this</span><span class="s1">._sections[i].consumer.sources.length; j++) {</span>
        <span class="s1">sources.push(</span><span class="s3">this</span><span class="s1">._sections[i].consumer.sources[j]);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s1">sources;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Returns the original source, line, and column information for the generated 
   * source's line and column positions provided. The only argument is an object 
   * with the following properties: 
   * 
   *   - line: The line number in the generated source.  The line number 
   *     is 1-based. 
   *   - column: The column number in the generated source.  The column 
   *     number is 0-based. 
   * 
   * and an object is returned with the following properties: 
   * 
   *   - source: The original source file, or null. 
   *   - line: The line number in the original source, or null.  The 
   *     line number is 1-based. 
   *   - column: The column number in the original source, or null.  The 
   *     column number is 0-based. 
   *   - name: The original identifier, or null. 
   */</span>
  <span class="s1">originalPositionFor(aArgs) {</span>
    <span class="s1">const needle = {</span>
      <span class="s1">generatedLine: util.getArg(aArgs, </span><span class="s2">&quot;line&quot;</span><span class="s1">),</span>
      <span class="s1">generatedColumn: util.getArg(aArgs, </span><span class="s2">&quot;column&quot;</span><span class="s1">)</span>
    <span class="s1">};</span>

    <span class="s0">// Find the section containing the generated position we're trying to map</span>
    <span class="s0">// to an original position.</span>
    <span class="s1">const sectionIndex = binarySearch.search(needle, </span><span class="s3">this</span><span class="s1">._sections,</span>
      <span class="s3">function</span><span class="s1">(aNeedle, section) {</span>
        <span class="s1">const cmp = aNeedle.generatedLine - section.generatedOffset.generatedLine;</span>
        <span class="s3">if </span><span class="s1">(cmp) {</span>
          <span class="s3">return </span><span class="s1">cmp;</span>
        <span class="s1">}</span>

        <span class="s3">return </span><span class="s1">(aNeedle.generatedColumn -</span>
                <span class="s1">section.generatedOffset.generatedColumn);</span>
      <span class="s1">});</span>
    <span class="s1">const section = </span><span class="s3">this</span><span class="s1">._sections[sectionIndex];</span>

    <span class="s3">if </span><span class="s1">(!section) {</span>
      <span class="s3">return </span><span class="s1">{</span>
        <span class="s1">source: </span><span class="s3">null</span><span class="s1">,</span>
        <span class="s1">line: </span><span class="s3">null</span><span class="s1">,</span>
        <span class="s1">column: </span><span class="s3">null</span><span class="s1">,</span>
        <span class="s1">name: </span><span class="s3">null</span>
      <span class="s1">};</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">section.consumer.originalPositionFor({</span>
      <span class="s1">line: needle.generatedLine -</span>
        <span class="s1">(section.generatedOffset.generatedLine - </span><span class="s4">1</span><span class="s1">),</span>
      <span class="s1">column: needle.generatedColumn -</span>
        <span class="s1">(section.generatedOffset.generatedLine === needle.generatedLine</span>
         <span class="s1">? section.generatedOffset.generatedColumn - </span><span class="s4">1</span>
         <span class="s1">: </span><span class="s4">0</span><span class="s1">),</span>
      <span class="s1">bias: aArgs.bias</span>
    <span class="s1">});</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Return true if we have the source content for every source in the source 
   * map, false otherwise. 
   */</span>
  <span class="s1">hasContentsOfAllSources() {</span>
    <span class="s3">return this</span><span class="s1">._sections.every(</span><span class="s3">function</span><span class="s1">(s) {</span>
      <span class="s3">return </span><span class="s1">s.consumer.hasContentsOfAllSources();</span>
    <span class="s1">});</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Returns the original source content. The only argument is the url of the 
   * original source file. Returns null if no original source content is 
   * available. 
   */</span>
  <span class="s1">sourceContentFor(aSource, nullOnMissing) {</span>
    <span class="s3">for </span><span class="s1">(let i = </span><span class="s4">0</span><span class="s1">; i &lt; </span><span class="s3">this</span><span class="s1">._sections.length; i++) {</span>
      <span class="s1">const section = </span><span class="s3">this</span><span class="s1">._sections[i];</span>

      <span class="s1">const content = section.consumer.sourceContentFor(aSource, </span><span class="s3">true</span><span class="s1">);</span>
      <span class="s3">if </span><span class="s1">(content) {</span>
        <span class="s3">return </span><span class="s1">content;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(nullOnMissing) {</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">'&quot;' </span><span class="s1">+ aSource + </span><span class="s2">'&quot; is not in the SourceMap.'</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Returns the generated line and column information for the original source, 
   * line, and column positions provided. The only argument is an object with 
   * the following properties: 
   * 
   *   - source: The filename of the original source. 
   *   - line: The line number in the original source.  The line number 
   *     is 1-based. 
   *   - column: The column number in the original source.  The column 
   *     number is 0-based. 
   * 
   * and an object is returned with the following properties: 
   * 
   *   - line: The line number in the generated source, or null.  The 
   *     line number is 1-based. 
   *   - column: The column number in the generated source, or null. 
   *     The column number is 0-based. 
   */</span>
  <span class="s1">generatedPositionFor(aArgs) {</span>
    <span class="s3">for </span><span class="s1">(let i = </span><span class="s4">0</span><span class="s1">; i &lt; </span><span class="s3">this</span><span class="s1">._sections.length; i++) {</span>
      <span class="s1">const section = </span><span class="s3">this</span><span class="s1">._sections[i];</span>

      <span class="s0">// Only consider this section if the requested source is in the list of</span>
      <span class="s0">// sources of the consumer.</span>
      <span class="s3">if </span><span class="s1">(section.consumer._findSourceIndex(util.getArg(aArgs, </span><span class="s2">&quot;source&quot;</span><span class="s1">)) === -</span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s1">const generatedPosition = section.consumer.generatedPositionFor(aArgs);</span>
      <span class="s3">if </span><span class="s1">(generatedPosition) {</span>
        <span class="s1">const ret = {</span>
          <span class="s1">line: generatedPosition.line +</span>
            <span class="s1">(section.generatedOffset.generatedLine - </span><span class="s4">1</span><span class="s1">),</span>
          <span class="s1">column: generatedPosition.column +</span>
            <span class="s1">(section.generatedOffset.generatedLine === generatedPosition.line</span>
             <span class="s1">? section.generatedOffset.generatedColumn - </span><span class="s4">1</span>
             <span class="s1">: </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">};</span>
        <span class="s3">return </span><span class="s1">ret;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">{</span>
      <span class="s1">line: </span><span class="s3">null</span><span class="s1">,</span>
      <span class="s1">column: </span><span class="s3">null</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Parse the mappings in a string in to a data structure which we can easily 
   * query (the ordered arrays in the `this.__generatedMappings` and 
   * `this.__originalMappings` properties). 
   */</span>
  <span class="s1">_parseMappings(aStr, aSourceRoot) {</span>
    <span class="s1">const generatedMappings = </span><span class="s3">this</span><span class="s1">.__generatedMappingsUnsorted = [];</span>
    <span class="s1">const originalMappings = </span><span class="s3">this</span><span class="s1">.__originalMappingsUnsorted = [];</span>
    <span class="s3">for </span><span class="s1">(let i = </span><span class="s4">0</span><span class="s1">; i &lt; </span><span class="s3">this</span><span class="s1">._sections.length; i++) {</span>
      <span class="s1">const section = </span><span class="s3">this</span><span class="s1">._sections[i];</span>

      <span class="s1">const sectionMappings = [];</span>
      <span class="s1">section.consumer.eachMapping(m =&gt; sectionMappings.push(m));</span>

      <span class="s3">for </span><span class="s1">(let j = </span><span class="s4">0</span><span class="s1">; j &lt; sectionMappings.length; j++) {</span>
        <span class="s1">const mapping = sectionMappings[j];</span>

        <span class="s0">// TODO: test if null is correct here.  The original code used</span>
        <span class="s0">// `source`, which would actually have gotten used as null because</span>
        <span class="s0">// var's get hoisted.</span>
        <span class="s0">// See: https://github.com/mozilla/source-map/issues/333</span>
        <span class="s1">let source = util.computeSourceURL(section.consumer.sourceRoot, </span><span class="s3">null</span><span class="s1">, </span><span class="s3">this</span><span class="s1">._sourceMapURL);</span>
        <span class="s3">this</span><span class="s1">._sources.add(source);</span>
        <span class="s1">source = </span><span class="s3">this</span><span class="s1">._sources.indexOf(source);</span>

        <span class="s1">let name = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s1">(mapping.name) {</span>
          <span class="s3">this</span><span class="s1">._names.add(mapping.name);</span>
          <span class="s1">name = </span><span class="s3">this</span><span class="s1">._names.indexOf(mapping.name);</span>
        <span class="s1">}</span>

        <span class="s0">// The mappings coming from the consumer for the section have</span>
        <span class="s0">// generated positions relative to the start of the section, so we</span>
        <span class="s0">// need to offset them to be relative to the start of the concatenated</span>
        <span class="s0">// generated file.</span>
        <span class="s1">const adjustedMapping = {</span>
          <span class="s1">source,</span>
          <span class="s1">generatedLine: mapping.generatedLine +</span>
            <span class="s1">(section.generatedOffset.generatedLine - </span><span class="s4">1</span><span class="s1">),</span>
          <span class="s1">generatedColumn: mapping.generatedColumn +</span>
            <span class="s1">(section.generatedOffset.generatedLine === mapping.generatedLine</span>
            <span class="s1">? section.generatedOffset.generatedColumn - </span><span class="s4">1</span>
            <span class="s1">: </span><span class="s4">0</span><span class="s1">),</span>
          <span class="s1">originalLine: mapping.originalLine,</span>
          <span class="s1">originalColumn: mapping.originalColumn,</span>
          <span class="s1">name</span>
        <span class="s1">};</span>

        <span class="s1">generatedMappings.push(adjustedMapping);</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">adjustedMapping.originalLine === </span><span class="s2">&quot;number&quot;</span><span class="s1">) {</span>
          <span class="s1">originalMappings.push(adjustedMapping);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">eachMapping(aCallback, aContext, aOrder) {</span>
    <span class="s1">const context = aContext || </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">const order = aOrder || SourceMapConsumer.GENERATED_ORDER;</span>

    <span class="s1">let mappings;</span>
    <span class="s3">switch </span><span class="s1">(order) {</span>
    <span class="s3">case </span><span class="s1">SourceMapConsumer.GENERATED_ORDER:</span>
      <span class="s1">mappings = </span><span class="s3">this</span><span class="s1">._generatedMappings;</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s1">SourceMapConsumer.ORIGINAL_ORDER:</span>
      <span class="s1">mappings = </span><span class="s3">this</span><span class="s1">._originalMappings;</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s3">default</span><span class="s1">:</span>
      <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Unknown order of iteration.&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s1">const sourceRoot = </span><span class="s3">this</span><span class="s1">.sourceRoot;</span>
    <span class="s1">mappings.map(</span><span class="s3">function</span><span class="s1">(mapping) {</span>
      <span class="s1">let source = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s3">if </span><span class="s1">(mapping.source !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">source = </span><span class="s3">this</span><span class="s1">._sources.at(mapping.source);</span>
        <span class="s1">source = util.computeSourceURL(sourceRoot, source, </span><span class="s3">this</span><span class="s1">._sourceMapURL);</span>
      <span class="s1">}</span>
      <span class="s3">return </span><span class="s1">{</span>
        <span class="s1">source,</span>
        <span class="s1">generatedLine: mapping.generatedLine,</span>
        <span class="s1">generatedColumn: mapping.generatedColumn,</span>
        <span class="s1">originalLine: mapping.originalLine,</span>
        <span class="s1">originalColumn: mapping.originalColumn,</span>
        <span class="s1">name: mapping.name === </span><span class="s3">null </span><span class="s1">? </span><span class="s3">null </span><span class="s1">: </span><span class="s3">this</span><span class="s1">._names.at(mapping.name)</span>
      <span class="s1">};</span>
    <span class="s1">}, </span><span class="s3">this</span><span class="s1">).forEach(aCallback, context);</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Find the mapping that best matches the hypothetical &quot;needle&quot; mapping that 
   * we are searching for in the given &quot;haystack&quot; of mappings. 
   */</span>
  <span class="s1">_findMapping(aNeedle, aMappings, aLineName,</span>
              <span class="s1">aColumnName, aComparator, aBias) {</span>
    <span class="s0">// To return the position we are searching for, we must first find the</span>
    <span class="s0">// mapping for the given position and then return the opposite position it</span>
    <span class="s0">// points to. Because the mappings are sorted, we can use binary search to</span>
    <span class="s0">// find the best mapping.</span>

    <span class="s3">if </span><span class="s1">(aNeedle[aLineName] &lt;= </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s3">throw new </span><span class="s1">TypeError(</span><span class="s2">&quot;Line must be greater than or equal to 1, got &quot;</span>
                          <span class="s1">+ aNeedle[aLineName]);</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(aNeedle[aColumnName] &lt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s3">throw new </span><span class="s1">TypeError(</span><span class="s2">&quot;Column must be greater than or equal to 0, got &quot;</span>
                          <span class="s1">+ aNeedle[aColumnName]);</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">binarySearch.search(aNeedle, aMappings, aComparator, aBias);</span>
  <span class="s1">}</span>

  <span class="s1">allGeneratedPositionsFor(aArgs) {</span>
    <span class="s1">const line = util.getArg(aArgs, </span><span class="s2">&quot;line&quot;</span><span class="s1">);</span>

    <span class="s0">// When there is no exact match, BasicSourceMapConsumer.prototype._findMapping</span>
    <span class="s0">// returns the index of the closest mapping less than the needle. By</span>
    <span class="s0">// setting needle.originalColumn to 0, we thus find the last mapping for</span>
    <span class="s0">// the given line, provided such a mapping exists.</span>
    <span class="s1">const needle = {</span>
      <span class="s1">source: util.getArg(aArgs, </span><span class="s2">&quot;source&quot;</span><span class="s1">),</span>
      <span class="s1">originalLine: line,</span>
      <span class="s1">originalColumn: util.getArg(aArgs, </span><span class="s2">&quot;column&quot;</span><span class="s1">, </span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">};</span>

    <span class="s1">needle.source = </span><span class="s3">this</span><span class="s1">._findSourceIndex(needle.source);</span>
    <span class="s3">if </span><span class="s1">(needle.source &lt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s3">return </span><span class="s1">[];</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(needle.originalLine &lt; </span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Line numbers must be &gt;= 1&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(needle.originalColumn &lt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Column numbers must be &gt;= 0&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s1">const mappings = [];</span>

    <span class="s1">let index = </span><span class="s3">this</span><span class="s1">._findMapping(needle,</span>
                                  <span class="s3">this</span><span class="s1">._originalMappings,</span>
                                  <span class="s2">&quot;originalLine&quot;</span><span class="s1">,</span>
                                  <span class="s2">&quot;originalColumn&quot;</span><span class="s1">,</span>
                                  <span class="s1">util.compareByOriginalPositions,</span>
                                  <span class="s1">binarySearch.LEAST_UPPER_BOUND);</span>
    <span class="s3">if </span><span class="s1">(index &gt;= </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s1">let mapping = </span><span class="s3">this</span><span class="s1">._originalMappings[index];</span>

      <span class="s3">if </span><span class="s1">(aArgs.column === undefined) {</span>
        <span class="s1">const originalLine = mapping.originalLine;</span>

        <span class="s0">// Iterate until either we run out of mappings, or we run into</span>
        <span class="s0">// a mapping for a different line than the one we found. Since</span>
        <span class="s0">// mappings are sorted, this is guaranteed to find all mappings for</span>
        <span class="s0">// the line we found.</span>
        <span class="s3">while </span><span class="s1">(mapping &amp;&amp; mapping.originalLine === originalLine) {</span>
          <span class="s1">let lastColumn = mapping.lastGeneratedColumn;</span>
          <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._computedColumnSpans &amp;&amp; lastColumn === </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s1">lastColumn = Infinity;</span>
          <span class="s1">}</span>
          <span class="s1">mappings.push({</span>
            <span class="s1">line: util.getArg(mapping, </span><span class="s2">&quot;generatedLine&quot;</span><span class="s1">, </span><span class="s3">null</span><span class="s1">),</span>
            <span class="s1">column: util.getArg(mapping, </span><span class="s2">&quot;generatedColumn&quot;</span><span class="s1">, </span><span class="s3">null</span><span class="s1">),</span>
            <span class="s1">lastColumn,</span>
          <span class="s1">});</span>

          <span class="s1">mapping = </span><span class="s3">this</span><span class="s1">._originalMappings[++index];</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">const originalColumn = mapping.originalColumn;</span>

        <span class="s0">// Iterate until either we run out of mappings, or we run into</span>
        <span class="s0">// a mapping for a different line than the one we were searching for.</span>
        <span class="s0">// Since mappings are sorted, this is guaranteed to find all mappings for</span>
        <span class="s0">// the line we are searching for.</span>
        <span class="s3">while </span><span class="s1">(mapping &amp;&amp;</span>
               <span class="s1">mapping.originalLine === line &amp;&amp;</span>
               <span class="s1">mapping.originalColumn == originalColumn) {</span>
          <span class="s1">let lastColumn = mapping.lastGeneratedColumn;</span>
          <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._computedColumnSpans &amp;&amp; lastColumn === </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s1">lastColumn = Infinity;</span>
          <span class="s1">}</span>
          <span class="s1">mappings.push({</span>
            <span class="s1">line: util.getArg(mapping, </span><span class="s2">&quot;generatedLine&quot;</span><span class="s1">, </span><span class="s3">null</span><span class="s1">),</span>
            <span class="s1">column: util.getArg(mapping, </span><span class="s2">&quot;generatedColumn&quot;</span><span class="s1">, </span><span class="s3">null</span><span class="s1">),</span>
            <span class="s1">lastColumn,</span>
          <span class="s1">});</span>

          <span class="s1">mapping = </span><span class="s3">this</span><span class="s1">._originalMappings[++index];</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">mappings;</span>
  <span class="s1">}</span>

  <span class="s1">destroy() {</span>
    <span class="s3">for </span><span class="s1">(let i = </span><span class="s4">0</span><span class="s1">; i &lt; </span><span class="s3">this</span><span class="s1">._sections.length; i++) {</span>
      <span class="s3">this</span><span class="s1">._sections[i].consumer.destroy();</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;</span>

<span class="s0">/* 
 * Cheat to get around inter-twingled classes.  `factory()` can be at the end 
 * where it has access to non-hoisted classes, but it gets hoisted itself. 
 */</span>
<span class="s3">function </span><span class="s1">_factory(aSourceMap, aSourceMapURL) {</span>
  <span class="s1">let sourceMap = aSourceMap;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">aSourceMap === </span><span class="s2">&quot;string&quot;</span><span class="s1">) {</span>
    <span class="s1">sourceMap = util.parseSourceMapInput(aSourceMap);</span>
  <span class="s1">}</span>

  <span class="s1">const consumer = sourceMap.sections != </span><span class="s3">null</span>
      <span class="s1">? </span><span class="s3">new </span><span class="s1">IndexedSourceMapConsumer(sourceMap, aSourceMapURL)</span>
      <span class="s1">: </span><span class="s3">new </span><span class="s1">BasicSourceMapConsumer(sourceMap, aSourceMapURL);</span>
  <span class="s3">return </span><span class="s1">Promise.resolve(consumer);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">_factoryBSM(aSourceMap, aSourceMapURL) {</span>
  <span class="s3">return </span><span class="s1">BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);</span>
<span class="s1">}</span>
</pre>
</body>
</html>
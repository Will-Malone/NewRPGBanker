<html>
<head>
<title>RuleTester.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6a8759;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
RuleTester.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s2">var </span><span class="s1">__createBinding = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__createBinding) || (Object.create ? (</span><span class="s2">function</span><span class="s1">(o, m, k, k2) {</span>
    <span class="s2">if </span><span class="s1">(k2 === undefined) k2 = k;</span>
    <span class="s2">var </span><span class="s1">desc = Object.getOwnPropertyDescriptor(m, k);</span>
    <span class="s2">if </span><span class="s1">(!desc || (</span><span class="s0">&quot;get&quot; </span><span class="s2">in </span><span class="s1">desc ? !m.__esModule : desc.writable || desc.configurable)) {</span>
      <span class="s1">desc = { enumerable: </span><span class="s2">true</span><span class="s1">, get: </span><span class="s2">function</span><span class="s1">() { </span><span class="s2">return </span><span class="s1">m[k]; } };</span>
    <span class="s1">}</span>
    <span class="s1">Object.defineProperty(o, k2, desc);</span>
<span class="s1">}) : (</span><span class="s2">function</span><span class="s1">(o, m, k, k2) {</span>
    <span class="s2">if </span><span class="s1">(k2 === undefined) k2 = k;</span>
    <span class="s1">o[k2] = m[k];</span>
<span class="s1">}));</span>
<span class="s2">var </span><span class="s1">__setModuleDefault = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__setModuleDefault) || (Object.create ? (</span><span class="s2">function</span><span class="s1">(o, v) {</span>
    <span class="s1">Object.defineProperty(o, </span><span class="s0">&quot;default&quot;</span><span class="s1">, { enumerable: </span><span class="s2">true</span><span class="s1">, value: v });</span>
<span class="s1">}) : </span><span class="s2">function</span><span class="s1">(o, v) {</span>
    <span class="s1">o[</span><span class="s0">&quot;default&quot;</span><span class="s1">] = v;</span>
<span class="s1">});</span>
<span class="s2">var </span><span class="s1">__importStar = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__importStar) || </span><span class="s2">function </span><span class="s1">(mod) {</span>
    <span class="s2">if </span><span class="s1">(mod &amp;&amp; mod.__esModule) </span><span class="s2">return </span><span class="s1">mod;</span>
    <span class="s2">var </span><span class="s1">result = {};</span>
    <span class="s2">if </span><span class="s1">(mod != </span><span class="s2">null</span><span class="s1">) </span><span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">k </span><span class="s2">in </span><span class="s1">mod) </span><span class="s2">if </span><span class="s1">(k !== </span><span class="s0">&quot;default&quot; </span><span class="s1">&amp;&amp; Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);</span>
    <span class="s1">__setModuleDefault(result, mod);</span>
    <span class="s2">return </span><span class="s1">result;</span>
<span class="s1">};</span>
<span class="s2">var </span><span class="s1">__classPrivateFieldGet = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__classPrivateFieldGet) || </span><span class="s2">function </span><span class="s1">(receiver, state, kind, f) {</span>
    <span class="s2">if </span><span class="s1">(kind === </span><span class="s0">&quot;a&quot; </span><span class="s1">&amp;&amp; !f) </span><span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s0">&quot;Private accessor was defined without a getter&quot;</span><span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">state === </span><span class="s0">&quot;function&quot; </span><span class="s1">? receiver !== state || !f : !state.has(receiver)) </span><span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s0">&quot;Cannot read private member from an object whose class did not declare it&quot;</span><span class="s1">);</span>
    <span class="s2">return </span><span class="s1">kind === </span><span class="s0">&quot;m&quot; </span><span class="s1">? f : kind === </span><span class="s0">&quot;a&quot; </span><span class="s1">? f.call(receiver) : f ? f.value : state.get(receiver);</span>
<span class="s1">};</span>
<span class="s2">var </span><span class="s1">__classPrivateFieldSet = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__classPrivateFieldSet) || </span><span class="s2">function </span><span class="s1">(receiver, state, value, kind, f) {</span>
    <span class="s2">if </span><span class="s1">(kind === </span><span class="s0">&quot;m&quot;</span><span class="s1">) </span><span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s0">&quot;Private method is not writable&quot;</span><span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(kind === </span><span class="s0">&quot;a&quot; </span><span class="s1">&amp;&amp; !f) </span><span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s0">&quot;Private accessor was defined without a setter&quot;</span><span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">state === </span><span class="s0">&quot;function&quot; </span><span class="s1">? receiver !== state || !f : !state.has(receiver)) </span><span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s0">&quot;Cannot write private member to an object whose class did not declare it&quot;</span><span class="s1">);</span>
    <span class="s2">return </span><span class="s1">(kind === </span><span class="s0">&quot;a&quot; </span><span class="s1">? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;</span>
<span class="s1">};</span>
<span class="s2">var </span><span class="s1">__rest = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__rest) || </span><span class="s2">function </span><span class="s1">(s, e) {</span>
    <span class="s2">var </span><span class="s1">t = {};</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">p </span><span class="s2">in </span><span class="s1">s) </span><span class="s2">if </span><span class="s1">(Object.prototype.hasOwnProperty.call(s, p) &amp;&amp; e.indexOf(p) &lt; </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">t[p] = s[p];</span>
    <span class="s2">if </span><span class="s1">(s != </span><span class="s2">null </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">Object.getOwnPropertySymbols === </span><span class="s0">&quot;function&quot;</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s3">0</span><span class="s1">, p = Object.getOwnPropertySymbols(s); i &lt; p.length; i++) {</span>
            <span class="s2">if </span><span class="s1">(e.indexOf(p[i]) &lt; </span><span class="s3">0 </span><span class="s1">&amp;&amp; Object.prototype.propertyIsEnumerable.call(s, p[i]))</span>
                <span class="s1">t[p[i]] = s[p[i]];</span>
        <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">t;</span>
<span class="s1">};</span>
<span class="s2">var </span><span class="s1">__importDefault = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__importDefault) || </span><span class="s2">function </span><span class="s1">(mod) {</span>
    <span class="s2">return </span><span class="s1">(mod &amp;&amp; mod.__esModule) ? mod : { </span><span class="s0">&quot;default&quot;</span><span class="s1">: mod };</span>
<span class="s1">};</span>
<span class="s2">var </span><span class="s1">_a, _RuleTester_baseOptions, _RuleTester_afterAll;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, { value: </span><span class="s2">true </span><span class="s1">});</span>
<span class="s1">exports.RuleTester = exports.noFormat = </span><span class="s2">void </span><span class="s3">0</span><span class="s1">;</span>
<span class="s1">const assert_1 = __importDefault(require(</span><span class="s0">&quot;assert&quot;</span><span class="s1">));</span>
<span class="s1">const package_json_1 = require(</span><span class="s0">&quot;eslint/package.json&quot;</span><span class="s1">);</span>
<span class="s1">const path = __importStar(require(</span><span class="s0">&quot;path&quot;</span><span class="s1">));</span>
<span class="s1">const semver = __importStar(require(</span><span class="s0">&quot;semver&quot;</span><span class="s1">));</span>
<span class="s1">const BaseRuleTester = __importStar(require(</span><span class="s0">&quot;../../ts-eslint/RuleTester&quot;</span><span class="s1">));</span>
<span class="s1">const deepMerge_1 = require(</span><span class="s0">&quot;../deepMerge&quot;</span><span class="s1">);</span>
<span class="s1">const dependencyConstraints_1 = require(</span><span class="s0">&quot;./dependencyConstraints&quot;</span><span class="s1">);</span>
<span class="s1">const TS_ESLINT_PARSER = </span><span class="s0">'@typescript-eslint/parser'</span><span class="s1">;</span>
<span class="s1">const ERROR_MESSAGE = `Do not set the parser at the test level unless you want to use a parser other than ${TS_ESLINT_PARSER}`;</span>
<span class="s2">function </span><span class="s1">isDescribeWithSkip(value) {</span>
    <span class="s2">return </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">value === </span><span class="s0">'object' </span><span class="s1">&amp;&amp;</span>
        <span class="s1">value != </span><span class="s2">null </span><span class="s1">&amp;&amp;</span>
        <span class="s0">'skip' </span><span class="s2">in </span><span class="s1">value &amp;&amp;</span>
        <span class="s2">typeof </span><span class="s1">value.skip === </span><span class="s0">'function'</span><span class="s1">);</span>
<span class="s1">}</span>
<span class="s1">class RuleTester extends BaseRuleTester.RuleTester {</span>
    <span class="s4">/** 
     * If you supply a value to this property, the rule tester will call this instead of using the version defined on 
     * the global namespace. 
     */</span>
    <span class="s1">static get afterAll() {</span>
        <span class="s2">var </span><span class="s1">_b;</span>
        <span class="s2">return </span><span class="s1">((_b = __classPrivateFieldGet(</span><span class="s2">this</span><span class="s1">, _a, </span><span class="s0">&quot;f&quot;</span><span class="s1">, _RuleTester_afterAll)) !== </span><span class="s2">null </span><span class="s1">&amp;&amp; _b !== </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? _b : (</span><span class="s2">typeof </span><span class="s1">afterAll === </span><span class="s0">'function' </span><span class="s1">? afterAll : () =&gt; { }));</span>
    <span class="s1">}</span>
    <span class="s1">static set afterAll(value) {</span>
        <span class="s1">__classPrivateFieldSet(</span><span class="s2">this</span><span class="s1">, _a, value, </span><span class="s0">&quot;f&quot;</span><span class="s1">, _RuleTester_afterAll);</span>
    <span class="s1">}</span>
    <span class="s1">get staticThis() {</span>
        <span class="s4">// the cast here is due to https://github.com/microsoft/TypeScript/issues/3841</span>
        <span class="s2">return this</span><span class="s1">.constructor;</span>
    <span class="s1">}</span>
    <span class="s1">constructor(baseOptions) {</span>
        <span class="s2">var </span><span class="s1">_b, _c;</span>
        <span class="s4">// eslint will hard-error if you include non-standard top-level properties</span>
        <span class="s1">const { dependencyConstraints: _ } = baseOptions, baseOptionsSafeForESLint = __rest(baseOptions, [</span><span class="s0">&quot;dependencyConstraints&quot;</span><span class="s1">]);</span>
        <span class="s1">super(Object.assign(Object.assign({}, baseOptionsSafeForESLint), { parserOptions: Object.assign(Object.assign({}, baseOptions.parserOptions), { warnOnUnsupportedTypeScriptVersion: (_c = (_b = baseOptions.parserOptions) === </span><span class="s2">null </span><span class="s1">|| _b === </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _b.warnOnUnsupportedTypeScriptVersion) !== </span><span class="s2">null </span><span class="s1">&amp;&amp; _c !== </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? _c : </span><span class="s2">false </span><span class="s1">}), </span>
            <span class="s4">// as of eslint 6 you have to provide an absolute path to the parser</span>
            <span class="s4">// but that's not as clean to type, this saves us trying to manually enforce</span>
            <span class="s4">// that contributors require.resolve everything</span>
            <span class="s1">parser: require.resolve(baseOptions.parser) }));</span>
        <span class="s1">_RuleTester_baseOptions.set(</span><span class="s2">this</span><span class="s1">, </span><span class="s2">void </span><span class="s3">0</span><span class="s1">);</span>
        <span class="s1">__classPrivateFieldSet(</span><span class="s2">this</span><span class="s1">, _RuleTester_baseOptions, baseOptions, </span><span class="s0">&quot;f&quot;</span><span class="s1">);</span>
        <span class="s4">// make sure that the parser doesn't hold onto file handles between tests</span>
        <span class="s4">// on linux (i.e. our CI env), there can be very a limited number of watch handles available</span>
        <span class="s2">this</span><span class="s1">.staticThis.afterAll(() =&gt; {</span>
            <span class="s2">try </span><span class="s1">{</span>
                <span class="s4">// instead of creating a hard dependency, just use a soft require</span>
                <span class="s4">// a bit weird, but if they're using this tooling, it'll be installed</span>
                <span class="s1">const parser = require(TS_ESLINT_PARSER);</span>
                <span class="s1">parser.clearCaches();</span>
            <span class="s1">}</span>
            <span class="s2">catch </span><span class="s1">(_b) {</span>
                <span class="s4">// ignored on purpose</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">getFilename(testOptions) {</span>
        <span class="s2">var </span><span class="s1">_b;</span>
        <span class="s1">const resolvedOptions = (</span><span class="s3">0</span><span class="s1">, deepMerge_1.deepMerge)(__classPrivateFieldGet(</span><span class="s2">this</span><span class="s1">, _RuleTester_baseOptions, </span><span class="s0">&quot;f&quot;</span><span class="s1">).parserOptions, testOptions);</span>
        <span class="s1">const filename = `file.ts${((_b = resolvedOptions.ecmaFeatures) === </span><span class="s2">null </span><span class="s1">|| _b === </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _b.jsx) ? </span><span class="s0">'x' </span><span class="s1">: </span><span class="s0">''</span><span class="s1">}`;</span>
        <span class="s2">if </span><span class="s1">(resolvedOptions.project) {</span>
            <span class="s2">return </span><span class="s1">path.join(resolvedOptions.tsconfigRootDir != </span><span class="s2">null</span>
                <span class="s1">? resolvedOptions.tsconfigRootDir</span>
                <span class="s1">: process.cwd(), filename);</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">filename;</span>
    <span class="s1">}</span>
    <span class="s4">// as of eslint 6 you have to provide an absolute path to the parser</span>
    <span class="s4">// If you don't do that at the test level, the test will fail somewhat cryptically...</span>
    <span class="s4">// This is a lot more explicit</span>
    <span class="s1">run(name, rule, testsReadonly) {</span>
        <span class="s2">if </span><span class="s1">(__classPrivateFieldGet(</span><span class="s2">this</span><span class="s1">, _RuleTester_baseOptions, </span><span class="s0">&quot;f&quot;</span><span class="s1">).dependencyConstraints &amp;&amp;</span>
            <span class="s1">!(</span><span class="s3">0</span><span class="s1">, dependencyConstraints_1.satisfiesAllDependencyConstraints)(__classPrivateFieldGet(</span><span class="s2">this</span><span class="s1">, _RuleTester_baseOptions, </span><span class="s0">&quot;f&quot;</span><span class="s1">).dependencyConstraints)) {</span>
            <span class="s2">if </span><span class="s1">(isDescribeWithSkip(</span><span class="s2">this</span><span class="s1">.staticThis.describe)) {</span>
                <span class="s4">// for frameworks like mocha or jest that have a &quot;skip&quot; version of their function</span>
                <span class="s4">// we can provide a nice skipped test!</span>
                <span class="s2">this</span><span class="s1">.staticThis.describe.skip(name, () =&gt; {</span>
                    <span class="s2">this</span><span class="s1">.staticThis.it(</span><span class="s0">'All tests skipped due to unsatisfied constructor dependency constraints'</span><span class="s1">, () =&gt; { });</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s4">// otherwise just declare an empty test</span>
                <span class="s2">this</span><span class="s1">.staticThis.describe(name, () =&gt; {</span>
                    <span class="s2">this</span><span class="s1">.staticThis.it(</span><span class="s0">'All tests skipped due to unsatisfied constructor dependency constraints'</span><span class="s1">, () =&gt; {</span>
                        <span class="s4">// some frameworks error if there are no assertions</span>
                        <span class="s1">assert_1.</span><span class="s2">default</span><span class="s1">.equal(</span><span class="s2">true</span><span class="s1">, </span><span class="s2">true</span><span class="s1">);</span>
                    <span class="s1">});</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s4">// don't run any tests because we don't match the base constraint</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">const tests = {</span>
            <span class="s4">// standardize the valid tests as objects</span>
            <span class="s1">valid: testsReadonly.valid.map(test =&gt; {</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">test === </span><span class="s0">'string'</span><span class="s1">) {</span>
                    <span class="s2">return </span><span class="s1">{</span>
                        <span class="s1">code: test,</span>
                    <span class="s1">};</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">test;</span>
            <span class="s1">}),</span>
            <span class="s1">invalid: testsReadonly.invalid,</span>
        <span class="s1">};</span>
        <span class="s4">// convenience iterator to make it easy to loop all tests without a concat</span>
        <span class="s1">const allTestsIterator = {</span>
            <span class="s1">*[Symbol.iterator]() {</span>
                <span class="s2">for </span><span class="s1">(const test of tests.valid) {</span>
                    <span class="s1">yield test;</span>
                <span class="s1">}</span>
                <span class="s2">for </span><span class="s1">(const test of tests.invalid) {</span>
                    <span class="s1">yield test;</span>
                <span class="s1">}</span>
            <span class="s1">},</span>
        <span class="s1">};</span>
        <span class="s4">/* 
        Automatically add a filename to the tests to enable type-aware tests to &quot;just work&quot;. 
        This saves users having to verbosely and manually add the filename to every 
        single test case. 
        Hugely helps with the string-based valid test cases as it means they don't 
        need to be made objects! 
        Also removes dependencyConstraints, which we support but ESLint core doesn't. 
        */</span>
        <span class="s1">const normalizeTest = (_b) =&gt; {</span>
            <span class="s2">var </span><span class="s1">{ dependencyConstraints: _ } = _b, test = __rest(_b, [</span><span class="s0">&quot;dependencyConstraints&quot;</span><span class="s1">]);</span>
            <span class="s2">if </span><span class="s1">(test.parser === TS_ESLINT_PARSER) {</span>
                <span class="s2">throw new </span><span class="s1">Error(ERROR_MESSAGE);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(!test.filename) {</span>
                <span class="s2">return </span><span class="s1">Object.assign(Object.assign({}, test), { filename: </span><span class="s2">this</span><span class="s1">.getFilename(test.parserOptions) });</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">test;</span>
        <span class="s1">};</span>
        <span class="s1">tests.valid = tests.valid.map(normalizeTest);</span>
        <span class="s1">tests.invalid = tests.invalid.map(normalizeTest);</span>
        <span class="s1">const hasOnly = (() =&gt; {</span>
            <span class="s2">for </span><span class="s1">(const test of allTestsIterator) {</span>
                <span class="s2">if </span><span class="s1">(test.only) {</span>
                    <span class="s2">return true</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">return false</span><span class="s1">;</span>
        <span class="s1">})();</span>
        <span class="s4">// if there is an `only: true` - don't apply constraints - assume that</span>
        <span class="s4">// we are in &quot;local development&quot; mode rather than &quot;CI validation&quot; mode</span>
        <span class="s2">if </span><span class="s1">(!hasOnly) {</span>
            <span class="s4">/* 
            Automatically skip tests that don't satisfy the dependency constraints. 
            */</span>
            <span class="s1">const hasConstraints = (() =&gt; {</span>
                <span class="s2">for </span><span class="s1">(const test of allTestsIterator) {</span>
                    <span class="s2">if </span><span class="s1">(test.dependencyConstraints &amp;&amp;</span>
                        <span class="s1">Object.keys(test.dependencyConstraints).length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
                        <span class="s2">return true</span><span class="s1">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">return false</span><span class="s1">;</span>
            <span class="s1">})();</span>
            <span class="s2">if </span><span class="s1">(hasConstraints) {</span>
                <span class="s4">// The `only: boolean` test property was only added in ESLint v7.29.0.</span>
                <span class="s2">if </span><span class="s1">(semver.satisfies(package_json_1.version, </span><span class="s0">'&gt;=7.29.0'</span><span class="s1">)) {</span>
                    <span class="s4">/* 
                    Mark all satisfactory tests as `only: true`, and all other tests as 
                    `only: false`. 
                    When multiple tests are marked as &quot;only&quot;, test frameworks like jest and mocha 
                    will run all of those tests and will just skip the other tests. 
           
                    We do this instead of just omitting the tests entirely because it gives the 
                    test framework the opportunity to log the test as skipped rather than the test 
                    just disappearing. 
                    */</span>
                    <span class="s1">const maybeMarkAsOnly = (test) =&gt; {</span>
                        <span class="s2">return </span><span class="s1">Object.assign(Object.assign({}, test), { only: (</span><span class="s3">0</span><span class="s1">, dependencyConstraints_1.satisfiesAllDependencyConstraints)(test.dependencyConstraints) });</span>
                    <span class="s1">};</span>
                    <span class="s1">tests.valid = tests.valid.map(maybeMarkAsOnly);</span>
                    <span class="s1">tests.invalid = tests.invalid.map(maybeMarkAsOnly);</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s4">// On older versions we just fallback to raw array filtering like SAVAGES</span>
                    <span class="s1">tests.valid = tests.valid.filter(test =&gt; (</span><span class="s3">0</span><span class="s1">, dependencyConstraints_1.satisfiesAllDependencyConstraints)(test.dependencyConstraints));</span>
                    <span class="s1">tests.invalid = tests.invalid.filter(test =&gt; (</span><span class="s3">0</span><span class="s1">, dependencyConstraints_1.satisfiesAllDependencyConstraints)(test.dependencyConstraints));</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">super.run(name, rule, tests);</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">exports.RuleTester = RuleTester;</span>
<span class="s1">_a = RuleTester, _RuleTester_baseOptions = </span><span class="s2">new </span><span class="s1">WeakMap();</span>
<span class="s1">_RuleTester_afterAll = { value: </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">};</span>
<span class="s4">/** 
 * Simple no-op tag to mark code samples as &quot;should not format with prettier&quot; 
 *   for the internal/plugin-test-formatting lint rule 
 */</span>
<span class="s2">function </span><span class="s1">noFormat(raw, ...keys) {</span>
    <span class="s2">return </span><span class="s1">String.raw({ raw }, ...keys);</span>
<span class="s1">}</span>
<span class="s1">exports.noFormat = noFormat;</span>
<span class="s4">//# sourceMappingURL=RuleTester.js.map</span></pre>
</body>
</html>
<html>
<head>
<title>compress.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
compress.js</font>
</center></td></tr></table>
<pre><span class="s0">/*********************************************************************** 
 
  A JavaScript tokenizer / parser / beautifier / compressor. 
  https://github.com/mishoo/UglifyJS2 
 
  -------------------------------- (C) --------------------------------- 
 
                           Author: Mihai Bazon 
                         &lt;mihai.bazon@gmail.com&gt; 
                       http://mihai.bazon.net/blog 
 
  Distributed under the BSD license: 
 
    Copyright 2012 (c) Mihai Bazon &lt;mihai.bazon@gmail.com&gt; 
 
    Redistribution and use in source and binary forms, with or without 
    modification, are permitted provided that the following conditions 
    are met: 
 
        * Redistributions of source code must retain the above 
          copyright notice, this list of conditions and the following 
          disclaimer. 
 
        * Redistributions in binary form must reproduce the above 
          copyright notice, this list of conditions and the following 
          disclaimer in the documentation and/or other materials 
          provided with the distribution. 
 
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY 
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE 
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, 
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF 
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
    SUCH DAMAGE. 
 
 ***********************************************************************/</span>

<span class="s2">&quot;use strict&quot;</span><span class="s1">;</span>

<span class="s3">function </span><span class="s1">Compressor(options, false_by_default) {</span>
    <span class="s3">if </span><span class="s1">(!(</span><span class="s3">this instanceof </span><span class="s1">Compressor))</span>
        <span class="s3">return new </span><span class="s1">Compressor(options, false_by_default);</span>
    <span class="s1">TreeTransformer.call(</span><span class="s3">this</span><span class="s1">, </span><span class="s3">this</span><span class="s1">.before, </span><span class="s3">this</span><span class="s1">.after);</span>
    <span class="s3">this</span><span class="s1">.options = defaults(options, {</span>
        <span class="s1">arrows        : !false_by_default,</span>
        <span class="s1">booleans      : !false_by_default,</span>
        <span class="s1">collapse_vars : !false_by_default,</span>
        <span class="s1">comparisons   : !false_by_default,</span>
        <span class="s1">computed_props: !false_by_default,</span>
        <span class="s1">conditionals  : !false_by_default,</span>
        <span class="s1">dead_code     : !false_by_default,</span>
        <span class="s1">drop_console  : </span><span class="s3">false</span><span class="s1">,</span>
        <span class="s1">drop_debugger : !false_by_default,</span>
        <span class="s1">ecma          : </span><span class="s4">5</span><span class="s1">,</span>
        <span class="s1">evaluate      : !false_by_default,</span>
        <span class="s1">expression    : </span><span class="s3">false</span><span class="s1">,</span>
        <span class="s1">global_defs   : {},</span>
        <span class="s1">hoist_funs    : </span><span class="s3">false</span><span class="s1">,</span>
        <span class="s1">hoist_props   : !false_by_default,</span>
        <span class="s1">hoist_vars    : </span><span class="s3">false</span><span class="s1">,</span>
        <span class="s1">ie8           : </span><span class="s3">false</span><span class="s1">,</span>
        <span class="s1">if_return     : !false_by_default,</span>
        <span class="s1">inline        : !false_by_default,</span>
        <span class="s1">join_vars     : !false_by_default,</span>
        <span class="s1">keep_classnames: </span><span class="s3">false</span><span class="s1">,</span>
        <span class="s1">keep_fargs    : </span><span class="s3">true</span><span class="s1">,</span>
        <span class="s1">keep_fnames   : </span><span class="s3">false</span><span class="s1">,</span>
        <span class="s1">keep_infinity : </span><span class="s3">false</span><span class="s1">,</span>
        <span class="s1">loops         : !false_by_default,</span>
        <span class="s1">negate_iife   : !false_by_default,</span>
        <span class="s1">passes        : </span><span class="s4">1</span><span class="s1">,</span>
        <span class="s1">properties    : !false_by_default,</span>
        <span class="s1">pure_getters  : !false_by_default &amp;&amp; </span><span class="s2">&quot;strict&quot;</span><span class="s1">,</span>
        <span class="s1">pure_funcs    : </span><span class="s3">null</span><span class="s1">,</span>
        <span class="s1">reduce_funcs  : !false_by_default,</span>
        <span class="s1">reduce_vars   : !false_by_default,</span>
        <span class="s1">sequences     : !false_by_default,</span>
        <span class="s1">side_effects  : !false_by_default,</span>
        <span class="s1">switches      : !false_by_default,</span>
        <span class="s1">top_retain    : </span><span class="s3">null</span><span class="s1">,</span>
        <span class="s1">toplevel      : !!(options &amp;&amp; options[</span><span class="s2">&quot;top_retain&quot;</span><span class="s1">]),</span>
        <span class="s1">typeofs       : !false_by_default,</span>
        <span class="s1">unsafe        : </span><span class="s3">false</span><span class="s1">,</span>
        <span class="s1">unsafe_arrows : </span><span class="s3">false</span><span class="s1">,</span>
        <span class="s1">unsafe_comps  : </span><span class="s3">false</span><span class="s1">,</span>
        <span class="s1">unsafe_Function: </span><span class="s3">false</span><span class="s1">,</span>
        <span class="s1">unsafe_math   : </span><span class="s3">false</span><span class="s1">,</span>
        <span class="s1">unsafe_methods: </span><span class="s3">false</span><span class="s1">,</span>
        <span class="s1">unsafe_proto  : </span><span class="s3">false</span><span class="s1">,</span>
        <span class="s1">unsafe_regexp : </span><span class="s3">false</span><span class="s1">,</span>
        <span class="s1">unsafe_undefined: </span><span class="s3">false</span><span class="s1">,</span>
        <span class="s1">unused        : !false_by_default,</span>
        <span class="s1">warnings      : </span><span class="s3">false</span><span class="s1">,</span>
    <span class="s1">}, </span><span class="s3">true</span><span class="s1">);</span>
    <span class="s3">var </span><span class="s1">global_defs = </span><span class="s3">this</span><span class="s1">.options[</span><span class="s2">&quot;global_defs&quot;</span><span class="s1">];</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">global_defs == </span><span class="s2">&quot;object&quot;</span><span class="s1">) </span><span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">key </span><span class="s3">in </span><span class="s1">global_defs) {</span>
        <span class="s3">if </span><span class="s1">(/^@/.test(key) &amp;&amp; HOP(global_defs, key)) {</span>
            <span class="s1">global_defs[key.slice(</span><span class="s4">1</span><span class="s1">)] = parse(global_defs[key], {</span>
                <span class="s1">expression: </span><span class="s3">true</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.options[</span><span class="s2">&quot;inline&quot;</span><span class="s1">] === </span><span class="s3">true</span><span class="s1">) </span><span class="s3">this</span><span class="s1">.options[</span><span class="s2">&quot;inline&quot;</span><span class="s1">] = </span><span class="s4">3</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">pure_funcs = </span><span class="s3">this</span><span class="s1">.options[</span><span class="s2">&quot;pure_funcs&quot;</span><span class="s1">];</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">pure_funcs == </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
        <span class="s3">this</span><span class="s1">.pure_funcs = pure_funcs;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s3">this</span><span class="s1">.pure_funcs = pure_funcs ? </span><span class="s3">function</span><span class="s1">(node) {</span>
            <span class="s3">return </span><span class="s1">pure_funcs.indexOf(node.expression.print_to_string()) &lt; </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">} : return_true;</span>
    <span class="s1">}</span>
    <span class="s3">var </span><span class="s1">top_retain = </span><span class="s3">this</span><span class="s1">.options[</span><span class="s2">&quot;top_retain&quot;</span><span class="s1">];</span>
    <span class="s3">if </span><span class="s1">(top_retain </span><span class="s3">instanceof </span><span class="s1">RegExp) {</span>
        <span class="s3">this</span><span class="s1">.top_retain = </span><span class="s3">function</span><span class="s1">(def) {</span>
            <span class="s3">return </span><span class="s1">top_retain.test(def.name);</span>
        <span class="s1">};</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">top_retain == </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
        <span class="s3">this</span><span class="s1">.top_retain = top_retain;</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(top_retain) {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">top_retain == </span><span class="s2">&quot;string&quot;</span><span class="s1">) {</span>
            <span class="s1">top_retain = top_retain.split(/,/);</span>
        <span class="s1">}</span>
        <span class="s3">this</span><span class="s1">.top_retain = </span><span class="s3">function</span><span class="s1">(def) {</span>
            <span class="s3">return </span><span class="s1">top_retain.indexOf(def.name) &gt;= </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s3">var </span><span class="s1">toplevel = </span><span class="s3">this</span><span class="s1">.options[</span><span class="s2">&quot;toplevel&quot;</span><span class="s1">];</span>
    <span class="s3">this</span><span class="s1">.toplevel = </span><span class="s3">typeof </span><span class="s1">toplevel == </span><span class="s2">&quot;string&quot; </span><span class="s1">? {</span>
        <span class="s1">funcs: /funcs/.test(toplevel),</span>
        <span class="s1">vars: /vars/.test(toplevel)</span>
    <span class="s1">} : {</span>
        <span class="s1">funcs: toplevel,</span>
        <span class="s1">vars: toplevel</span>
    <span class="s1">};</span>
    <span class="s3">var </span><span class="s1">sequences = </span><span class="s3">this</span><span class="s1">.options[</span><span class="s2">&quot;sequences&quot;</span><span class="s1">];</span>
    <span class="s3">this</span><span class="s1">.sequences_limit = sequences == </span><span class="s4">1 </span><span class="s1">? </span><span class="s4">800 </span><span class="s1">: sequences | </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s1">.warnings_produced = {};</span>
<span class="s1">};</span>

<span class="s1">Compressor.prototype = </span><span class="s3">new </span><span class="s1">TreeTransformer;</span>
<span class="s1">merge(Compressor.prototype, {</span>
    <span class="s1">option: </span><span class="s3">function</span><span class="s1">(key) { </span><span class="s3">return this</span><span class="s1">.options[key] },</span>
    <span class="s1">exposed: </span><span class="s3">function</span><span class="s1">(def) {</span>
        <span class="s3">if </span><span class="s1">(def.export) </span><span class="s3">return true</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s1">(def.global) </span><span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">, len = def.orig.length; i &lt; len; i++)</span>
            <span class="s3">if </span><span class="s1">(!</span><span class="s3">this</span><span class="s1">.toplevel[def.orig[i] </span><span class="s3">instanceof </span><span class="s1">AST_SymbolDefun ? </span><span class="s2">&quot;funcs&quot; </span><span class="s1">: </span><span class="s2">&quot;vars&quot;</span><span class="s1">])</span>
                <span class="s3">return true</span><span class="s1">;</span>
        <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">},</span>
    <span class="s1">in_boolean_context: </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">if </span><span class="s1">(!</span><span class="s3">this</span><span class="s1">.option(</span><span class="s2">&quot;booleans&quot;</span><span class="s1">)) </span><span class="s3">return false</span><span class="s1">;</span>
        <span class="s3">var </span><span class="s1">self = </span><span class="s3">this</span><span class="s1">.self();</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">, p; p = </span><span class="s3">this</span><span class="s1">.parent(i); i++) {</span>
            <span class="s3">if </span><span class="s1">(p </span><span class="s3">instanceof </span><span class="s1">AST_SimpleStatement</span>
                <span class="s1">|| p </span><span class="s3">instanceof </span><span class="s1">AST_Conditional &amp;&amp; p.condition === self</span>
                <span class="s1">|| p </span><span class="s3">instanceof </span><span class="s1">AST_DWLoop &amp;&amp; p.condition === self</span>
                <span class="s1">|| p </span><span class="s3">instanceof </span><span class="s1">AST_For &amp;&amp; p.condition === self</span>
                <span class="s1">|| p </span><span class="s3">instanceof </span><span class="s1">AST_If &amp;&amp; p.condition === self</span>
                <span class="s1">|| p </span><span class="s3">instanceof </span><span class="s1">AST_UnaryPrefix &amp;&amp; p.operator == </span><span class="s2">&quot;!&quot; </span><span class="s1">&amp;&amp; p.expression === self) {</span>
                <span class="s3">return true</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(p </span><span class="s3">instanceof </span><span class="s1">AST_Binary &amp;&amp; (p.operator == </span><span class="s2">&quot;&amp;&amp;&quot; </span><span class="s1">|| p.operator == </span><span class="s2">&quot;||&quot;</span><span class="s1">)</span>
                <span class="s1">|| p </span><span class="s3">instanceof </span><span class="s1">AST_Conditional</span>
                <span class="s1">|| p.tail_node() === self) {</span>
                <span class="s1">self = p;</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s3">return false</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">},</span>
    <span class="s1">compress: </span><span class="s3">function</span><span class="s1">(node) {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.option(</span><span class="s2">&quot;expression&quot;</span><span class="s1">)) {</span>
            <span class="s1">node.process_expression(</span><span class="s3">true</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s3">var </span><span class="s1">passes = +</span><span class="s3">this</span><span class="s1">.options.passes || </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s3">var </span><span class="s1">min_count = </span><span class="s4">1 </span><span class="s1">/ </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s3">var </span><span class="s1">stopping = </span><span class="s3">false</span><span class="s1">;</span>
        <span class="s3">var </span><span class="s1">mangle = { ie8: </span><span class="s3">this</span><span class="s1">.option(</span><span class="s2">&quot;ie8&quot;</span><span class="s1">) };</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">pass = </span><span class="s4">0</span><span class="s1">; pass &lt; passes; pass++) {</span>
            <span class="s1">node.figure_out_scope(mangle);</span>
            <span class="s3">if </span><span class="s1">(pass &gt; </span><span class="s4">0 </span><span class="s1">|| </span><span class="s3">this</span><span class="s1">.option(</span><span class="s2">&quot;reduce_vars&quot;</span><span class="s1">))</span>
                <span class="s1">node.reset_opt_flags(</span><span class="s3">this</span><span class="s1">);</span>
            <span class="s1">node = node.transform(</span><span class="s3">this</span><span class="s1">);</span>
            <span class="s3">if </span><span class="s1">(passes &gt; </span><span class="s4">1</span><span class="s1">) {</span>
                <span class="s3">var </span><span class="s1">count = </span><span class="s4">0</span><span class="s1">;</span>
                <span class="s1">node.walk(</span><span class="s3">new </span><span class="s1">TreeWalker(</span><span class="s3">function</span><span class="s1">() {</span>
                    <span class="s1">count++;</span>
                <span class="s1">}));</span>
                <span class="s3">this</span><span class="s1">.info(</span><span class="s2">&quot;pass &quot; </span><span class="s1">+ pass + </span><span class="s2">&quot;: last_count: &quot; </span><span class="s1">+ min_count + </span><span class="s2">&quot;, count: &quot; </span><span class="s1">+ count);</span>
                <span class="s3">if </span><span class="s1">(count &lt; min_count) {</span>
                    <span class="s1">min_count = count;</span>
                    <span class="s1">stopping = </span><span class="s3">false</span><span class="s1">;</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(stopping) {</span>
                    <span class="s3">break</span><span class="s1">;</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s1">stopping = </span><span class="s3">true</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.option(</span><span class="s2">&quot;expression&quot;</span><span class="s1">)) {</span>
            <span class="s1">node.process_expression(</span><span class="s3">false</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">node;</span>
    <span class="s1">},</span>
    <span class="s1">info: </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.options.warnings == </span><span class="s2">&quot;verbose&quot;</span><span class="s1">) {</span>
            <span class="s1">AST_Node.warn.apply(AST_Node, arguments);</span>
        <span class="s1">}</span>
    <span class="s1">},</span>
    <span class="s1">warn: </span><span class="s3">function</span><span class="s1">(text, props) {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.options.warnings) {</span>
            <span class="s0">// only emit unique warnings</span>
            <span class="s3">var </span><span class="s1">message = string_template(text, props);</span>
            <span class="s3">if </span><span class="s1">(!(message </span><span class="s3">in this</span><span class="s1">.warnings_produced)) {</span>
                <span class="s3">this</span><span class="s1">.warnings_produced[message] = </span><span class="s3">true</span><span class="s1">;</span>
                <span class="s1">AST_Node.warn.apply(AST_Node, arguments);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">},</span>
    <span class="s1">clear_warnings: </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">this</span><span class="s1">.warnings_produced = {};</span>
    <span class="s1">},</span>
    <span class="s1">before: </span><span class="s3">function</span><span class="s1">(node, descend, in_list) {</span>
        <span class="s3">if </span><span class="s1">(node._squeezed) </span><span class="s3">return </span><span class="s1">node;</span>
        <span class="s3">var </span><span class="s1">was_scope = </span><span class="s3">false</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Scope) {</span>
            <span class="s1">node = node.hoist_properties(</span><span class="s3">this</span><span class="s1">);</span>
            <span class="s1">node = node.hoist_declarations(</span><span class="s3">this</span><span class="s1">);</span>
            <span class="s1">was_scope = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s0">// Before https://github.com/mishoo/UglifyJS2/pull/1602 AST_Node.optimize()</span>
        <span class="s0">// would call AST_Node.transform() if a different instance of AST_Node is</span>
        <span class="s0">// produced after OPT().</span>
        <span class="s0">// This corrupts TreeWalker.stack, which cause AST look-ups to malfunction.</span>
        <span class="s0">// Migrate and defer all children's AST_Node.transform() to below, which</span>
        <span class="s0">// will now happen after this parent AST_Node has been properly substituted</span>
        <span class="s0">// thus gives a consistent AST snapshot.</span>
        <span class="s1">descend(node, </span><span class="s3">this</span><span class="s1">);</span>
        <span class="s0">// Existing code relies on how AST_Node.optimize() worked, and omitting the</span>
        <span class="s0">// following replacement call would result in degraded efficiency of both</span>
        <span class="s0">// output and performance.</span>
        <span class="s1">descend(node, </span><span class="s3">this</span><span class="s1">);</span>
        <span class="s3">var </span><span class="s1">opt = node.optimize(</span><span class="s3">this</span><span class="s1">);</span>
        <span class="s3">if </span><span class="s1">(was_scope &amp;&amp; opt </span><span class="s3">instanceof </span><span class="s1">AST_Scope) {</span>
            <span class="s1">opt.drop_unused(</span><span class="s3">this</span><span class="s1">);</span>
            <span class="s1">descend(opt, </span><span class="s3">this</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(opt === node) opt._squeezed = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s3">return </span><span class="s1">opt;</span>
    <span class="s1">}</span>
<span class="s1">});</span>

<span class="s1">(</span><span class="s3">function</span><span class="s1">(){</span>

    <span class="s3">function </span><span class="s1">OPT(node, optimizer) {</span>
        <span class="s1">node.DEFMETHOD(</span><span class="s2">&quot;optimize&quot;</span><span class="s1">, </span><span class="s3">function</span><span class="s1">(compressor){</span>
            <span class="s3">var </span><span class="s1">self = </span><span class="s3">this</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(self._optimized) </span><span class="s3">return </span><span class="s1">self;</span>
            <span class="s3">if </span><span class="s1">(compressor.has_directive(</span><span class="s2">&quot;use asm&quot;</span><span class="s1">)) </span><span class="s3">return </span><span class="s1">self;</span>
            <span class="s3">var </span><span class="s1">opt = optimizer(self, compressor);</span>
            <span class="s1">opt._optimized = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s3">return </span><span class="s1">opt;</span>
        <span class="s1">});</span>
    <span class="s1">};</span>

    <span class="s1">OPT(AST_Node, </span><span class="s3">function</span><span class="s1">(self, compressor){</span>
        <span class="s3">return </span><span class="s1">self;</span>
    <span class="s1">});</span>

    <span class="s1">AST_Node.DEFMETHOD(</span><span class="s2">&quot;equivalent_to&quot;</span><span class="s1">, </span><span class="s3">function</span><span class="s1">(node){</span>
        <span class="s3">return this</span><span class="s1">.TYPE == node.TYPE &amp;&amp; </span><span class="s3">this</span><span class="s1">.print_to_string() == node.print_to_string();</span>
    <span class="s1">});</span>

    <span class="s1">AST_Scope.DEFMETHOD(</span><span class="s2">&quot;process_expression&quot;</span><span class="s1">, </span><span class="s3">function</span><span class="s1">(insert, compressor) {</span>
        <span class="s3">var </span><span class="s1">self = </span><span class="s3">this</span><span class="s1">;</span>
        <span class="s3">var </span><span class="s1">tt = </span><span class="s3">new </span><span class="s1">TreeTransformer(</span><span class="s3">function</span><span class="s1">(node) {</span>
            <span class="s3">if </span><span class="s1">(insert &amp;&amp; node </span><span class="s3">instanceof </span><span class="s1">AST_SimpleStatement) {</span>
                <span class="s3">return </span><span class="s1">make_node(AST_Return, node, {</span>
                    <span class="s1">value: node.body</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(!insert &amp;&amp; node </span><span class="s3">instanceof </span><span class="s1">AST_Return) {</span>
                <span class="s3">if </span><span class="s1">(compressor) {</span>
                    <span class="s3">var </span><span class="s1">value = node.value &amp;&amp; node.value.drop_side_effect_free(compressor, </span><span class="s3">true</span><span class="s1">);</span>
                    <span class="s3">return </span><span class="s1">value ? make_node(AST_SimpleStatement, node, {</span>
                        <span class="s1">body: value</span>
                    <span class="s1">}) : make_node(AST_EmptyStatement, node);</span>
                <span class="s1">}</span>
                <span class="s3">return </span><span class="s1">make_node(AST_SimpleStatement, node, {</span>
                    <span class="s1">body: node.value || make_node(AST_UnaryPrefix, node, {</span>
                        <span class="s1">operator: </span><span class="s2">&quot;void&quot;</span><span class="s1">,</span>
                        <span class="s1">expression: make_node(AST_Number, node, {</span>
                            <span class="s1">value: </span><span class="s4">0</span>
                        <span class="s1">})</span>
                    <span class="s1">})</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Class || node </span><span class="s3">instanceof </span><span class="s1">AST_Lambda &amp;&amp; node !== self) {</span>
                <span class="s3">return </span><span class="s1">node;</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Block) {</span>
                <span class="s3">var </span><span class="s1">index = node.body.length - </span><span class="s4">1</span><span class="s1">;</span>
                <span class="s3">if </span><span class="s1">(index &gt;= </span><span class="s4">0</span><span class="s1">) {</span>
                    <span class="s1">node.body[index] = node.body[index].transform(tt);</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_If) {</span>
                <span class="s1">node.body = node.body.transform(tt);</span>
                <span class="s3">if </span><span class="s1">(node.alternative) {</span>
                    <span class="s1">node.alternative = node.alternative.transform(tt);</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_With) {</span>
                <span class="s1">node.body = node.body.transform(tt);</span>
            <span class="s1">}</span>
            <span class="s3">return </span><span class="s1">node;</span>
        <span class="s1">});</span>
        <span class="s1">self.transform(tt);</span>
    <span class="s1">});</span>

    <span class="s1">(</span><span class="s3">function</span><span class="s1">(def){</span>
        <span class="s1">def(AST_Node, noop);</span>

        <span class="s3">function </span><span class="s1">reset_def(compressor, def) {</span>
            <span class="s1">def.assignments = </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s1">def.direct_access = </span><span class="s3">false</span><span class="s1">;</span>
            <span class="s1">def.escaped = </span><span class="s3">false</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(def.scope.uses_eval || def.scope.uses_with) {</span>
                <span class="s1">def.fixed = </span><span class="s3">false</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(def.orig[</span><span class="s4">0</span><span class="s1">] </span><span class="s3">instanceof </span><span class="s1">AST_SymbolConst || !compressor.exposed(def)) {</span>
                <span class="s1">def.fixed = def.init;</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s1">def.fixed = </span><span class="s3">false</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">def.recursive_refs = </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s1">def.references = [];</span>
            <span class="s1">def.should_replace = undefined;</span>
            <span class="s1">def.single_use = undefined;</span>
        <span class="s1">}</span>

        <span class="s3">function </span><span class="s1">reset_variables(tw, compressor, node) {</span>
            <span class="s1">node.variables.each(</span><span class="s3">function</span><span class="s1">(def) {</span>
                <span class="s1">reset_def(compressor, def);</span>
                <span class="s3">if </span><span class="s1">(def.fixed === </span><span class="s3">null</span><span class="s1">) {</span>
                    <span class="s1">def.safe_ids = tw.safe_ids;</span>
                    <span class="s1">mark(tw, def, </span><span class="s3">true</span><span class="s1">);</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(def.fixed) {</span>
                    <span class="s1">tw.loop_ids[def.id] = tw.in_loop;</span>
                    <span class="s1">mark(tw, def, </span><span class="s3">true</span><span class="s1">);</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
        <span class="s1">}</span>

        <span class="s3">function </span><span class="s1">reset_block_variables(compressor, node) {</span>
            <span class="s3">if </span><span class="s1">(node.block_scope) node.block_scope.variables.each(</span><span class="s3">function</span><span class="s1">(def) {</span>
                <span class="s1">reset_def(compressor, def);</span>
            <span class="s1">});</span>
        <span class="s1">}</span>

        <span class="s3">function </span><span class="s1">push(tw) {</span>
            <span class="s1">tw.safe_ids = Object.create(tw.safe_ids);</span>
        <span class="s1">}</span>

        <span class="s3">function </span><span class="s1">pop(tw) {</span>
            <span class="s1">tw.safe_ids = Object.getPrototypeOf(tw.safe_ids);</span>
        <span class="s1">}</span>

        <span class="s3">function </span><span class="s1">mark(tw, def, safe) {</span>
            <span class="s1">tw.safe_ids[def.id] = safe;</span>
        <span class="s1">}</span>

        <span class="s3">function </span><span class="s1">safe_to_read(tw, def) {</span>
            <span class="s3">if </span><span class="s1">(tw.safe_ids[def.id]) {</span>
                <span class="s3">if </span><span class="s1">(def.fixed == </span><span class="s3">null</span><span class="s1">) {</span>
                    <span class="s3">var </span><span class="s1">orig = def.orig[</span><span class="s4">0</span><span class="s1">];</span>
                    <span class="s3">if </span><span class="s1">(orig </span><span class="s3">instanceof </span><span class="s1">AST_SymbolFunarg || orig.name == </span><span class="s2">&quot;arguments&quot;</span><span class="s1">) </span><span class="s3">return false</span><span class="s1">;</span>
                    <span class="s1">def.fixed = make_node(AST_Undefined, orig);</span>
                <span class="s1">}</span>
                <span class="s3">return true</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">return </span><span class="s1">def.fixed </span><span class="s3">instanceof </span><span class="s1">AST_Defun;</span>
        <span class="s1">}</span>

        <span class="s3">function </span><span class="s1">safe_to_assign(tw, def, value) {</span>
            <span class="s3">if </span><span class="s1">(def.fixed === undefined) </span><span class="s3">return true</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(def.fixed === </span><span class="s3">null </span><span class="s1">&amp;&amp; def.safe_ids) {</span>
                <span class="s1">def.safe_ids[def.id] = </span><span class="s3">false</span><span class="s1">;</span>
                <span class="s3">delete </span><span class="s1">def.safe_ids;</span>
                <span class="s3">return true</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(!HOP(tw.safe_ids, def.id)) </span><span class="s3">return false</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(!safe_to_read(tw, def)) </span><span class="s3">return false</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(def.fixed === </span><span class="s3">false</span><span class="s1">) </span><span class="s3">return false</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(def.fixed != </span><span class="s3">null </span><span class="s1">&amp;&amp; (!value || def.references.length &gt; def.assignments)) </span><span class="s3">return false</span><span class="s1">;</span>
            <span class="s3">return </span><span class="s1">all(def.orig, </span><span class="s3">function</span><span class="s1">(sym) {</span>
                <span class="s3">return </span><span class="s1">!(sym </span><span class="s3">instanceof </span><span class="s1">AST_SymbolConst</span>
                    <span class="s1">|| sym </span><span class="s3">instanceof </span><span class="s1">AST_SymbolDefun</span>
                    <span class="s1">|| sym </span><span class="s3">instanceof </span><span class="s1">AST_SymbolLambda);</span>
            <span class="s1">});</span>
        <span class="s1">}</span>

        <span class="s3">function </span><span class="s1">ref_once(tw, compressor, def) {</span>
            <span class="s3">return </span><span class="s1">compressor.option(</span><span class="s2">&quot;unused&quot;</span><span class="s1">)</span>
                <span class="s1">&amp;&amp; !def.scope.uses_eval</span>
                <span class="s1">&amp;&amp; !def.scope.uses_with</span>
                <span class="s1">&amp;&amp; def.references.length - def.recursive_refs == </span><span class="s4">1</span>
                <span class="s1">&amp;&amp; tw.loop_ids[def.id] === tw.in_loop;</span>
        <span class="s1">}</span>

        <span class="s3">function </span><span class="s1">is_immutable(value) {</span>
            <span class="s3">if </span><span class="s1">(!value) </span><span class="s3">return false</span><span class="s1">;</span>
            <span class="s3">return </span><span class="s1">value.is_constant()</span>
                <span class="s1">|| value </span><span class="s3">instanceof </span><span class="s1">AST_Lambda</span>
                <span class="s1">|| value </span><span class="s3">instanceof </span><span class="s1">AST_This;</span>
        <span class="s1">}</span>

        <span class="s3">function </span><span class="s1">read_property(obj, key) {</span>
            <span class="s1">key = get_value(key);</span>
            <span class="s3">if </span><span class="s1">(key </span><span class="s3">instanceof </span><span class="s1">AST_Node) </span><span class="s3">return</span><span class="s1">;</span>
            <span class="s3">var </span><span class="s1">value;</span>
            <span class="s3">if </span><span class="s1">(obj </span><span class="s3">instanceof </span><span class="s1">AST_Array) {</span>
                <span class="s3">var </span><span class="s1">elements = obj.elements;</span>
                <span class="s3">if </span><span class="s1">(key == </span><span class="s2">&quot;length&quot;</span><span class="s1">) </span><span class="s3">return </span><span class="s1">make_node_from_constant(elements.length, obj);</span>
                <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">key == </span><span class="s2">&quot;number&quot; </span><span class="s1">&amp;&amp; key </span><span class="s3">in </span><span class="s1">elements) value = elements[key];</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(obj </span><span class="s3">instanceof </span><span class="s1">AST_Object) {</span>
                <span class="s1">key = </span><span class="s2">&quot;&quot; </span><span class="s1">+ key;</span>
                <span class="s3">var </span><span class="s1">props = obj.properties;</span>
                <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = props.length; --i &gt;= </span><span class="s4">0</span><span class="s1">;) {</span>
                    <span class="s3">var </span><span class="s1">prop = props[i];</span>
                    <span class="s3">if </span><span class="s1">(!(prop </span><span class="s3">instanceof </span><span class="s1">AST_ObjectKeyVal)) </span><span class="s3">return</span><span class="s1">;</span>
                    <span class="s3">if </span><span class="s1">(!value &amp;&amp; props[i].key === key) value = props[i].value;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s3">return </span><span class="s1">value </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef &amp;&amp; value.fixed_value() || value;</span>
        <span class="s1">}</span>

        <span class="s3">function </span><span class="s1">is_modified(tw, node, value, level, immutable) {</span>
            <span class="s3">var </span><span class="s1">parent = tw.parent(level);</span>
            <span class="s3">if </span><span class="s1">(is_lhs(node, parent)</span>
                <span class="s1">|| !immutable</span>
                    <span class="s1">&amp;&amp; parent </span><span class="s3">instanceof </span><span class="s1">AST_Call</span>
                    <span class="s1">&amp;&amp; parent.expression === node</span>
                    <span class="s1">&amp;&amp; !(value </span><span class="s3">instanceof </span><span class="s1">AST_Arrow)</span>
                    <span class="s1">&amp;&amp; !(value </span><span class="s3">instanceof </span><span class="s1">AST_Class)</span>
                    <span class="s1">&amp;&amp; (!(value </span><span class="s3">instanceof </span><span class="s1">AST_Function)</span>
                        <span class="s1">|| !(parent </span><span class="s3">instanceof </span><span class="s1">AST_New) &amp;&amp; value.contains_this())) {</span>
                <span class="s3">return true</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(parent </span><span class="s3">instanceof </span><span class="s1">AST_Array) {</span>
                <span class="s3">return </span><span class="s1">is_modified(tw, parent, parent, level + </span><span class="s4">1</span><span class="s1">);</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(parent </span><span class="s3">instanceof </span><span class="s1">AST_ObjectKeyVal &amp;&amp; node === parent.value) {</span>
                <span class="s3">var </span><span class="s1">obj = tw.parent(level + </span><span class="s4">1</span><span class="s1">);</span>
                <span class="s3">return </span><span class="s1">is_modified(tw, obj, obj, level + </span><span class="s4">2</span><span class="s1">);</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(parent </span><span class="s3">instanceof </span><span class="s1">AST_PropAccess &amp;&amp; parent.expression === node) {</span>
                <span class="s3">return </span><span class="s1">!immutable &amp;&amp; is_modified(tw, parent, read_property(value, parent.property), level + </span><span class="s4">1</span><span class="s1">);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">function </span><span class="s1">mark_escaped(tw, d, scope, node, value, level, depth) {</span>
            <span class="s3">var </span><span class="s1">parent = tw.parent(level);</span>
            <span class="s3">if </span><span class="s1">(value) {</span>
                <span class="s3">if </span><span class="s1">(value.is_constant()) </span><span class="s3">return</span><span class="s1">;</span>
                <span class="s3">if </span><span class="s1">(value </span><span class="s3">instanceof </span><span class="s1">AST_ClassExpression) </span><span class="s3">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(parent </span><span class="s3">instanceof </span><span class="s1">AST_Assign &amp;&amp; parent.operator == </span><span class="s2">&quot;=&quot; </span><span class="s1">&amp;&amp; node === parent.right</span>
                <span class="s1">|| parent </span><span class="s3">instanceof </span><span class="s1">AST_Call &amp;&amp; node !== parent.expression</span>
                <span class="s1">|| parent </span><span class="s3">instanceof </span><span class="s1">AST_Exit &amp;&amp; node === parent.value &amp;&amp; node.scope !== d.scope</span>
                <span class="s1">|| parent </span><span class="s3">instanceof </span><span class="s1">AST_VarDef &amp;&amp; node === parent.value</span>
                <span class="s1">|| parent </span><span class="s3">instanceof </span><span class="s1">AST_Yield &amp;&amp; node === parent.value &amp;&amp; node.scope !== d.scope) {</span>
                <span class="s3">if </span><span class="s1">(depth &gt; </span><span class="s4">1 </span><span class="s1">&amp;&amp; !(value &amp;&amp; value.is_constant_expression(scope))) depth = </span><span class="s4">1</span><span class="s1">;</span>
                <span class="s3">if </span><span class="s1">(!d.escaped || d.escaped &gt; depth) d.escaped = depth;</span>
                <span class="s3">return</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(parent </span><span class="s3">instanceof </span><span class="s1">AST_Array</span>
                <span class="s1">|| parent </span><span class="s3">instanceof </span><span class="s1">AST_Await</span>
                <span class="s1">|| parent </span><span class="s3">instanceof </span><span class="s1">AST_Binary &amp;&amp; lazy_op(parent.operator)</span>
                <span class="s1">|| parent </span><span class="s3">instanceof </span><span class="s1">AST_Conditional &amp;&amp; node !== parent.condition</span>
                <span class="s1">|| parent </span><span class="s3">instanceof </span><span class="s1">AST_Expansion</span>
                <span class="s1">|| parent </span><span class="s3">instanceof </span><span class="s1">AST_Sequence &amp;&amp; node === parent.tail_node()) {</span>
                <span class="s1">mark_escaped(tw, d, scope, parent, parent, level + </span><span class="s4">1</span><span class="s1">, depth);</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(parent </span><span class="s3">instanceof </span><span class="s1">AST_ObjectKeyVal &amp;&amp; node === parent.value) {</span>
                <span class="s3">var </span><span class="s1">obj = tw.parent(level + </span><span class="s4">1</span><span class="s1">);</span>
                <span class="s1">mark_escaped(tw, d, scope, obj, obj, level + </span><span class="s4">2</span><span class="s1">, depth);</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(parent </span><span class="s3">instanceof </span><span class="s1">AST_PropAccess &amp;&amp; node === parent.expression) {</span>
                <span class="s1">value = read_property(value, parent.property);</span>
                <span class="s1">mark_escaped(tw, d, scope, parent, value, level + </span><span class="s4">1</span><span class="s1">, depth + </span><span class="s4">1</span><span class="s1">);</span>
                <span class="s3">if </span><span class="s1">(value) </span><span class="s3">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(level == </span><span class="s4">0</span><span class="s1">) d.direct_access = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">var </span><span class="s1">suppressor = </span><span class="s3">new </span><span class="s1">TreeWalker(</span><span class="s3">function</span><span class="s1">(node) {</span>
            <span class="s3">if </span><span class="s1">(!(node </span><span class="s3">instanceof </span><span class="s1">AST_Symbol)) </span><span class="s3">return</span><span class="s1">;</span>
            <span class="s3">var </span><span class="s1">d = node.definition();</span>
            <span class="s3">if </span><span class="s1">(!d) </span><span class="s3">return</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef) d.references.push(node);</span>
            <span class="s1">d.fixed = </span><span class="s3">false</span><span class="s1">;</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Accessor, </span><span class="s3">function</span><span class="s1">(tw, descend, compressor) {</span>
            <span class="s1">push(tw);</span>
            <span class="s1">reset_variables(tw, compressor, </span><span class="s3">this</span><span class="s1">);</span>
            <span class="s1">descend();</span>
            <span class="s1">pop(tw);</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Arrow, mark_func_expr);</span>
        <span class="s1">def(AST_Assign, </span><span class="s3">function</span><span class="s1">(tw) {</span>
            <span class="s3">var </span><span class="s1">node = </span><span class="s3">this</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(node.left </span><span class="s3">instanceof </span><span class="s1">AST_Destructuring) {</span>
                <span class="s1">node.left.walk(suppressor);</span>
                <span class="s3">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(node.operator != </span><span class="s2">&quot;=&quot; </span><span class="s1">|| !(node.left </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef)) </span><span class="s3">return</span><span class="s1">;</span>
            <span class="s3">var </span><span class="s1">d = node.left.definition();</span>
            <span class="s3">if </span><span class="s1">(safe_to_assign(tw, d, node.right)) {</span>
                <span class="s1">d.references.push(node.left);</span>
                <span class="s1">d.assignments++;</span>
                <span class="s1">d.fixed = </span><span class="s3">function</span><span class="s1">() {</span>
                    <span class="s3">return </span><span class="s1">node.right;</span>
                <span class="s1">};</span>
                <span class="s1">mark(tw, d, </span><span class="s3">false</span><span class="s1">);</span>
                <span class="s1">node.right.walk(tw);</span>
                <span class="s1">mark(tw, d, </span><span class="s3">true</span><span class="s1">);</span>
                <span class="s3">return true</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Binary, </span><span class="s3">function</span><span class="s1">(tw) {</span>
            <span class="s3">if </span><span class="s1">(!lazy_op(</span><span class="s3">this</span><span class="s1">.operator)) </span><span class="s3">return</span><span class="s1">;</span>
            <span class="s3">this</span><span class="s1">.left.walk(tw);</span>
            <span class="s1">push(tw);</span>
            <span class="s3">this</span><span class="s1">.right.walk(tw);</span>
            <span class="s1">pop(tw);</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Block, </span><span class="s3">function</span><span class="s1">(tw, descend, compressor) {</span>
            <span class="s1">reset_block_variables(compressor, </span><span class="s3">this</span><span class="s1">);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_ClassExpression, </span><span class="s3">function</span><span class="s1">(tw, descend) {</span>
            <span class="s3">this</span><span class="s1">.inlined = </span><span class="s3">false</span><span class="s1">;</span>
            <span class="s1">push(tw);</span>
            <span class="s1">descend();</span>
            <span class="s1">pop(tw);</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">})</span>
        <span class="s1">def(AST_Conditional, </span><span class="s3">function</span><span class="s1">(tw) {</span>
            <span class="s3">this</span><span class="s1">.condition.walk(tw);</span>
            <span class="s1">push(tw);</span>
            <span class="s3">this</span><span class="s1">.consequent.walk(tw);</span>
            <span class="s1">pop(tw);</span>
            <span class="s1">push(tw);</span>
            <span class="s3">this</span><span class="s1">.alternative.walk(tw);</span>
            <span class="s1">pop(tw);</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">});</span>

        <span class="s3">function </span><span class="s1">mark_def_node(tw, descend, compressor) {</span>
            <span class="s3">this</span><span class="s1">.inlined = </span><span class="s3">false</span><span class="s1">;</span>
            <span class="s3">var </span><span class="s1">save_ids = tw.safe_ids;</span>
            <span class="s1">tw.safe_ids = Object.create(</span><span class="s3">null</span><span class="s1">);</span>
            <span class="s1">reset_variables(tw, compressor, </span><span class="s3">this</span><span class="s1">);</span>
            <span class="s1">descend();</span>
            <span class="s1">tw.safe_ids = save_ids;</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">def(AST_DefClass, mark_def_node);</span>
        <span class="s1">def(AST_Defun, mark_def_node);</span>
        <span class="s1">def(AST_Do, </span><span class="s3">function</span><span class="s1">(tw, descend, compressor) {</span>
            <span class="s1">reset_block_variables(compressor, </span><span class="s3">this</span><span class="s1">);</span>
            <span class="s3">var </span><span class="s1">saved_loop = tw.in_loop;</span>
            <span class="s1">tw.in_loop = </span><span class="s3">this</span><span class="s1">;</span>
            <span class="s1">push(tw);</span>
            <span class="s3">this</span><span class="s1">.body.walk(tw);</span>
            <span class="s3">this</span><span class="s1">.condition.walk(tw);</span>
            <span class="s1">pop(tw);</span>
            <span class="s1">tw.in_loop = saved_loop;</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_For, </span><span class="s3">function</span><span class="s1">(tw, descend, compressor) {</span>
            <span class="s1">reset_block_variables(compressor, </span><span class="s3">this</span><span class="s1">);</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.init) </span><span class="s3">this</span><span class="s1">.init.walk(tw);</span>
            <span class="s3">var </span><span class="s1">saved_loop = tw.in_loop;</span>
            <span class="s1">tw.in_loop = </span><span class="s3">this</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.condition) {</span>
                <span class="s1">push(tw);</span>
                <span class="s3">this</span><span class="s1">.condition.walk(tw);</span>
                <span class="s1">pop(tw);</span>
            <span class="s1">}</span>
            <span class="s1">push(tw);</span>
            <span class="s3">this</span><span class="s1">.body.walk(tw);</span>
            <span class="s1">pop(tw);</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.step) {</span>
                <span class="s1">push(tw);</span>
                <span class="s3">this</span><span class="s1">.step.walk(tw);</span>
                <span class="s1">pop(tw);</span>
            <span class="s1">}</span>
            <span class="s1">tw.in_loop = saved_loop;</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_ForIn, </span><span class="s3">function</span><span class="s1">(tw, descend, compressor) {</span>
            <span class="s1">reset_block_variables(compressor, </span><span class="s3">this</span><span class="s1">);</span>
            <span class="s3">this</span><span class="s1">.init.walk(suppressor);</span>
            <span class="s3">this</span><span class="s1">.object.walk(tw);</span>
            <span class="s3">var </span><span class="s1">saved_loop = tw.in_loop;</span>
            <span class="s1">tw.in_loop = </span><span class="s3">this</span><span class="s1">;</span>
            <span class="s1">push(tw);</span>
            <span class="s3">this</span><span class="s1">.body.walk(tw);</span>
            <span class="s1">pop(tw);</span>
            <span class="s1">tw.in_loop = saved_loop;</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">});</span>

        <span class="s3">function </span><span class="s1">mark_func_expr(tw, descend, compressor) {</span>
            <span class="s3">var </span><span class="s1">node = </span><span class="s3">this</span><span class="s1">;</span>
            <span class="s1">node.inlined = </span><span class="s3">false</span><span class="s1">;</span>
            <span class="s1">push(tw);</span>
            <span class="s1">reset_variables(tw, compressor, node);</span>
            <span class="s3">var </span><span class="s1">iife;</span>
            <span class="s3">if </span><span class="s1">(!node.name</span>
                <span class="s1">&amp;&amp; (iife = tw.parent()) </span><span class="s3">instanceof </span><span class="s1">AST_Call</span>
                <span class="s1">&amp;&amp; iife.expression === node) {</span>
                <span class="s0">// Virtually turn IIFE parameters into variable definitions:</span>
                <span class="s0">//   (function(a,b) {...})(c,d) =&gt; (function() {var a=c,b=d; ...})()</span>
                <span class="s0">// So existing transformation rules can work on them.</span>
                <span class="s1">node.argnames.forEach(</span><span class="s3">function</span><span class="s1">(arg, i) {</span>
                    <span class="s3">if </span><span class="s1">(!arg.definition) </span><span class="s3">return</span><span class="s1">;</span>
                    <span class="s3">var </span><span class="s1">d = arg.definition();</span>
                    <span class="s3">if </span><span class="s1">(!node.uses_arguments &amp;&amp; d.fixed === undefined) {</span>
                        <span class="s1">d.fixed = </span><span class="s3">function</span><span class="s1">() {</span>
                            <span class="s3">return </span><span class="s1">iife.args[i] || make_node(AST_Undefined, iife);</span>
                        <span class="s1">};</span>
                        <span class="s1">tw.loop_ids[d.id] = tw.in_loop;</span>
                        <span class="s1">mark(tw, d, </span><span class="s3">true</span><span class="s1">);</span>
                    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                        <span class="s1">d.fixed = </span><span class="s3">false</span><span class="s1">;</span>
                    <span class="s1">}</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s1">descend();</span>
            <span class="s1">pop(tw);</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">def(AST_Function, mark_func_expr);</span>
        <span class="s1">def(AST_If, </span><span class="s3">function</span><span class="s1">(tw) {</span>
            <span class="s3">this</span><span class="s1">.condition.walk(tw);</span>
            <span class="s1">push(tw);</span>
            <span class="s3">this</span><span class="s1">.body.walk(tw);</span>
            <span class="s1">pop(tw);</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.alternative) {</span>
                <span class="s1">push(tw);</span>
                <span class="s3">this</span><span class="s1">.alternative.walk(tw);</span>
                <span class="s1">pop(tw);</span>
            <span class="s1">}</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_LabeledStatement, </span><span class="s3">function</span><span class="s1">(tw) {</span>
            <span class="s1">push(tw);</span>
            <span class="s3">this</span><span class="s1">.body.walk(tw);</span>
            <span class="s1">pop(tw);</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_SwitchBranch, </span><span class="s3">function</span><span class="s1">(tw, descend) {</span>
            <span class="s1">push(tw);</span>
            <span class="s1">descend();</span>
            <span class="s1">pop(tw);</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_SymbolCatch, </span><span class="s3">function</span><span class="s1">() {</span>
            <span class="s3">this</span><span class="s1">.definition().fixed = </span><span class="s3">false</span><span class="s1">;</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_SymbolRef, </span><span class="s3">function</span><span class="s1">(tw, descend, compressor) {</span>
            <span class="s3">var </span><span class="s1">d = </span><span class="s3">this</span><span class="s1">.definition();</span>
            <span class="s1">d.references.push(</span><span class="s3">this</span><span class="s1">);</span>
            <span class="s3">if </span><span class="s1">(d.references.length == </span><span class="s4">1</span>
                <span class="s1">&amp;&amp; !d.fixed</span>
                <span class="s1">&amp;&amp; d.orig[</span><span class="s4">0</span><span class="s1">] </span><span class="s3">instanceof </span><span class="s1">AST_SymbolDefun) {</span>
                <span class="s1">tw.loop_ids[d.id] = tw.in_loop;</span>
            <span class="s1">}</span>
            <span class="s3">var </span><span class="s1">value;</span>
            <span class="s3">if </span><span class="s1">(d.fixed === undefined || !safe_to_read(tw, d) || d.single_use == </span><span class="s2">&quot;m&quot;</span><span class="s1">) {</span>
                <span class="s1">d.fixed = </span><span class="s3">false</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(d.fixed) {</span>
                <span class="s1">value = </span><span class="s3">this</span><span class="s1">.fixed_value();</span>
                <span class="s3">if </span><span class="s1">(value </span><span class="s3">instanceof </span><span class="s1">AST_Lambda &amp;&amp; recursive_ref(tw, d)) {</span>
                    <span class="s1">d.recursive_refs++;</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(value &amp;&amp; !compressor.exposed(d) &amp;&amp; ref_once(tw, compressor, d)) {</span>
                    <span class="s1">d.single_use = value </span><span class="s3">instanceof </span><span class="s1">AST_Lambda</span>
                        <span class="s1">|| value </span><span class="s3">instanceof </span><span class="s1">AST_Class</span>
                        <span class="s1">|| d.scope === </span><span class="s3">this</span><span class="s1">.scope &amp;&amp; value.is_constant_expression();</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s1">d.single_use = </span><span class="s3">false</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s3">if </span><span class="s1">(is_modified(tw, </span><span class="s3">this</span><span class="s1">, value, </span><span class="s4">0</span><span class="s1">, is_immutable(value))) {</span>
                    <span class="s3">if </span><span class="s1">(d.single_use) {</span>
                        <span class="s1">d.single_use = </span><span class="s2">&quot;m&quot;</span><span class="s1">;</span>
                    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                        <span class="s1">d.fixed = </span><span class="s3">false</span><span class="s1">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">mark_escaped(tw, d, </span><span class="s3">this</span><span class="s1">.scope, </span><span class="s3">this</span><span class="s1">, value, </span><span class="s4">0</span><span class="s1">, </span><span class="s4">1</span><span class="s1">);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Toplevel, </span><span class="s3">function</span><span class="s1">(tw, descend, compressor) {</span>
            <span class="s3">this</span><span class="s1">.globals.each(</span><span class="s3">function</span><span class="s1">(def) {</span>
                <span class="s1">reset_def(compressor, def);</span>
            <span class="s1">});</span>
            <span class="s1">reset_variables(tw, compressor, </span><span class="s3">this</span><span class="s1">);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Try, </span><span class="s3">function</span><span class="s1">(tw, descend, compressor) {</span>
            <span class="s1">reset_block_variables(compressor, </span><span class="s3">this</span><span class="s1">);</span>
            <span class="s1">push(tw);</span>
            <span class="s1">walk_body(</span><span class="s3">this</span><span class="s1">, tw);</span>
            <span class="s1">pop(tw);</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.bcatch) {</span>
                <span class="s1">push(tw);</span>
                <span class="s3">this</span><span class="s1">.bcatch.walk(tw);</span>
                <span class="s1">pop(tw);</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.bfinally) </span><span class="s3">this</span><span class="s1">.bfinally.walk(tw);</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_VarDef, </span><span class="s3">function</span><span class="s1">(tw, descend) {</span>
            <span class="s3">var </span><span class="s1">node = </span><span class="s3">this</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(node.name </span><span class="s3">instanceof </span><span class="s1">AST_Destructuring) {</span>
                <span class="s1">node.name.walk(suppressor);</span>
                <span class="s3">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">var </span><span class="s1">d = node.name.definition();</span>
            <span class="s3">if </span><span class="s1">(safe_to_assign(tw, d, node.value)) {</span>
                <span class="s3">if </span><span class="s1">(node.value) {</span>
                    <span class="s1">d.fixed = </span><span class="s3">function</span><span class="s1">() {</span>
                        <span class="s3">return </span><span class="s1">node.value;</span>
                    <span class="s1">};</span>
                    <span class="s1">tw.loop_ids[d.id] = tw.in_loop;</span>
                    <span class="s1">mark(tw, d, </span><span class="s3">false</span><span class="s1">);</span>
                    <span class="s1">descend();</span>
                <span class="s1">}</span>
                <span class="s1">mark(tw, d, </span><span class="s3">true</span><span class="s1">);</span>
                <span class="s3">return true</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(node.value) {</span>
                <span class="s1">d.fixed = </span><span class="s3">false</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_While, </span><span class="s3">function</span><span class="s1">(tw, descend, compressor) {</span>
            <span class="s1">reset_block_variables(compressor, </span><span class="s3">this</span><span class="s1">);</span>
            <span class="s3">var </span><span class="s1">saved_loop = tw.in_loop;</span>
            <span class="s1">tw.in_loop = </span><span class="s3">this</span><span class="s1">;</span>
            <span class="s1">push(tw);</span>
            <span class="s3">this</span><span class="s1">.condition.walk(tw);</span>
            <span class="s3">this</span><span class="s1">.body.walk(tw);</span>
            <span class="s1">pop(tw);</span>
            <span class="s1">tw.in_loop = saved_loop;</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">});</span>
    <span class="s1">})(</span><span class="s3">function</span><span class="s1">(node, func){</span>
        <span class="s1">node.DEFMETHOD(</span><span class="s2">&quot;reduce_vars&quot;</span><span class="s1">, func);</span>
    <span class="s1">});</span>

    <span class="s1">AST_Toplevel.DEFMETHOD(</span><span class="s2">&quot;reset_opt_flags&quot;</span><span class="s1">, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">var </span><span class="s1">reduce_vars = compressor.option(</span><span class="s2">&quot;reduce_vars&quot;</span><span class="s1">);</span>
        <span class="s3">var </span><span class="s1">tw = </span><span class="s3">new </span><span class="s1">TreeWalker(</span><span class="s3">function</span><span class="s1">(node, descend) {</span>
            <span class="s1">node._squeezed = </span><span class="s3">false</span><span class="s1">;</span>
            <span class="s1">node._optimized = </span><span class="s3">false</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(reduce_vars) </span><span class="s3">return </span><span class="s1">node.reduce_vars(tw, descend, compressor);</span>
        <span class="s1">});</span>
        <span class="s0">// Stack of look-up tables to keep track of whether a `SymbolDef` has been</span>
        <span class="s0">// properly assigned before use:</span>
        <span class="s0">// - `push()` &amp; `pop()` when visiting conditional branches</span>
        <span class="s0">// - backup &amp; restore via `save_ids` when visiting out-of-order sections</span>
        <span class="s1">tw.safe_ids = Object.create(</span><span class="s3">null</span><span class="s1">);</span>
        <span class="s1">tw.in_loop = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">tw.loop_ids = Object.create(</span><span class="s3">null</span><span class="s1">);</span>
        <span class="s3">this</span><span class="s1">.walk(tw);</span>
    <span class="s1">});</span>

    <span class="s1">AST_Symbol.DEFMETHOD(</span><span class="s2">&quot;fixed_value&quot;</span><span class="s1">, </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">var </span><span class="s1">fixed = </span><span class="s3">this</span><span class="s1">.definition().fixed;</span>
        <span class="s3">if </span><span class="s1">(!fixed || fixed </span><span class="s3">instanceof </span><span class="s1">AST_Node) </span><span class="s3">return </span><span class="s1">fixed;</span>
        <span class="s3">return </span><span class="s1">fixed();</span>
    <span class="s1">});</span>

    <span class="s1">AST_SymbolRef.DEFMETHOD(</span><span class="s2">&quot;is_immutable&quot;</span><span class="s1">, </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">var </span><span class="s1">orig = </span><span class="s3">this</span><span class="s1">.definition().orig;</span>
        <span class="s3">return </span><span class="s1">orig.length == </span><span class="s4">1 </span><span class="s1">&amp;&amp; orig[</span><span class="s4">0</span><span class="s1">] </span><span class="s3">instanceof </span><span class="s1">AST_SymbolLambda;</span>
    <span class="s1">});</span>

    <span class="s3">function </span><span class="s1">is_func_expr(node) {</span>
        <span class="s3">return </span><span class="s1">node </span><span class="s3">instanceof </span><span class="s1">AST_Arrow || node </span><span class="s3">instanceof </span><span class="s1">AST_Function;</span>
    <span class="s1">}</span>

    <span class="s3">function </span><span class="s1">is_lhs_read_only(lhs) {</span>
        <span class="s3">if </span><span class="s1">(lhs </span><span class="s3">instanceof </span><span class="s1">AST_This) </span><span class="s3">return true</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s1">(lhs </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef) </span><span class="s3">return </span><span class="s1">lhs.definition().orig[</span><span class="s4">0</span><span class="s1">] </span><span class="s3">instanceof </span><span class="s1">AST_SymbolLambda;</span>
        <span class="s3">if </span><span class="s1">(lhs </span><span class="s3">instanceof </span><span class="s1">AST_PropAccess) {</span>
            <span class="s1">lhs = lhs.expression;</span>
            <span class="s3">if </span><span class="s1">(lhs </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef) {</span>
                <span class="s3">if </span><span class="s1">(lhs.is_immutable()) </span><span class="s3">return false</span><span class="s1">;</span>
                <span class="s1">lhs = lhs.fixed_value();</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(!lhs) </span><span class="s3">return true</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(lhs </span><span class="s3">instanceof </span><span class="s1">AST_RegExp) </span><span class="s3">return false</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(lhs </span><span class="s3">instanceof </span><span class="s1">AST_Constant) </span><span class="s3">return true</span><span class="s1">;</span>
            <span class="s3">return </span><span class="s1">is_lhs_read_only(lhs);</span>
        <span class="s1">}</span>
        <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">function </span><span class="s1">is_ref_of(ref, type) {</span>
        <span class="s3">if </span><span class="s1">(!(ref </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef)) </span><span class="s3">return false</span><span class="s1">;</span>
        <span class="s3">var </span><span class="s1">orig = ref.definition().orig;</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = orig.length; --i &gt;= </span><span class="s4">0</span><span class="s1">;) {</span>
            <span class="s3">if </span><span class="s1">(orig[i] </span><span class="s3">instanceof </span><span class="s1">type) </span><span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">function </span><span class="s1">find_variable(compressor, name) {</span>
        <span class="s3">var </span><span class="s1">scope, i = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s3">while </span><span class="s1">(scope = compressor.parent(i++)) {</span>
            <span class="s3">if </span><span class="s1">(scope </span><span class="s3">instanceof </span><span class="s1">AST_Scope) </span><span class="s3">break</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(scope </span><span class="s3">instanceof </span><span class="s1">AST_Catch) {</span>
                <span class="s1">scope = scope.argname.definition().scope;</span>
                <span class="s3">break</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">scope.find_variable(name);</span>
    <span class="s1">}</span>

    <span class="s3">function </span><span class="s1">make_node(ctor, orig, props) {</span>
        <span class="s3">if </span><span class="s1">(!props) props = {};</span>
        <span class="s3">if </span><span class="s1">(orig) {</span>
            <span class="s3">if </span><span class="s1">(!props.start) props.start = orig.start;</span>
            <span class="s3">if </span><span class="s1">(!props.end) props.end = orig.end;</span>
        <span class="s1">}</span>
        <span class="s3">return new </span><span class="s1">ctor(props);</span>
    <span class="s1">};</span>

    <span class="s3">function </span><span class="s1">make_sequence(orig, expressions) {</span>
        <span class="s3">if </span><span class="s1">(expressions.length == </span><span class="s4">1</span><span class="s1">) </span><span class="s3">return </span><span class="s1">expressions[</span><span class="s4">0</span><span class="s1">];</span>
        <span class="s3">return </span><span class="s1">make_node(AST_Sequence, orig, {</span>
            <span class="s1">expressions: expressions.reduce(merge_sequence, [])</span>
        <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s3">function </span><span class="s1">make_node_from_constant(val, orig) {</span>
        <span class="s3">switch </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">val) {</span>
          <span class="s3">case </span><span class="s2">&quot;string&quot;</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">make_node(AST_String, orig, {</span>
                <span class="s1">value: val</span>
            <span class="s1">});</span>
          <span class="s3">case </span><span class="s2">&quot;number&quot;</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">(isNaN(val)) </span><span class="s3">return </span><span class="s1">make_node(AST_NaN, orig);</span>
            <span class="s3">if </span><span class="s1">(isFinite(val)) {</span>
                <span class="s3">return </span><span class="s4">1 </span><span class="s1">/ val &lt; </span><span class="s4">0 </span><span class="s1">? make_node(AST_UnaryPrefix, orig, {</span>
                    <span class="s1">operator: </span><span class="s2">&quot;-&quot;</span><span class="s1">,</span>
                    <span class="s1">expression: make_node(AST_Number, orig, { value: -val })</span>
                <span class="s1">}) : make_node(AST_Number, orig, { value: val });</span>
            <span class="s1">}</span>
            <span class="s3">return </span><span class="s1">val &lt; </span><span class="s4">0 </span><span class="s1">? make_node(AST_UnaryPrefix, orig, {</span>
                <span class="s1">operator: </span><span class="s2">&quot;-&quot;</span><span class="s1">,</span>
                <span class="s1">expression: make_node(AST_Infinity, orig)</span>
            <span class="s1">}) : make_node(AST_Infinity, orig);</span>
          <span class="s3">case </span><span class="s2">&quot;boolean&quot;</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">make_node(val ? AST_True : AST_False, orig);</span>
          <span class="s3">case </span><span class="s2">&quot;undefined&quot;</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">make_node(AST_Undefined, orig);</span>
          <span class="s3">default</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">(val === </span><span class="s3">null</span><span class="s1">) {</span>
                <span class="s3">return </span><span class="s1">make_node(AST_Null, orig, { value: </span><span class="s3">null </span><span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(val </span><span class="s3">instanceof </span><span class="s1">RegExp) {</span>
                <span class="s3">return </span><span class="s1">make_node(AST_RegExp, orig, { value: val });</span>
            <span class="s1">}</span>
            <span class="s3">throw new </span><span class="s1">Error(string_template(</span><span class="s2">&quot;Can't handle constant of type: {type}&quot;</span><span class="s1">, {</span>
                <span class="s1">type: </span><span class="s3">typeof </span><span class="s1">val</span>
            <span class="s1">}));</span>
        <span class="s1">}</span>
    <span class="s1">};</span>

    <span class="s0">// we shouldn't compress (1,func)(something) to</span>
    <span class="s0">// func(something) because that changes the meaning of</span>
    <span class="s0">// the func (becomes lexical instead of global).</span>
    <span class="s3">function </span><span class="s1">maintain_this_binding(parent, orig, val) {</span>
        <span class="s3">if </span><span class="s1">(parent </span><span class="s3">instanceof </span><span class="s1">AST_UnaryPrefix &amp;&amp; parent.operator == </span><span class="s2">&quot;delete&quot;</span>
            <span class="s1">|| parent </span><span class="s3">instanceof </span><span class="s1">AST_Call &amp;&amp; parent.expression === orig</span>
                <span class="s1">&amp;&amp; (val </span><span class="s3">instanceof </span><span class="s1">AST_PropAccess || val </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef &amp;&amp; val.name == </span><span class="s2">&quot;eval&quot;</span><span class="s1">)) {</span>
            <span class="s3">return </span><span class="s1">make_sequence(orig, [ make_node(AST_Number, orig, { value: </span><span class="s4">0 </span><span class="s1">}), val ]);</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">val;</span>
    <span class="s1">}</span>

    <span class="s3">function </span><span class="s1">merge_sequence(array, node) {</span>
        <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Sequence) {</span>
            <span class="s1">array.push.apply(array, node.expressions);</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">array.push(node);</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">array;</span>
    <span class="s1">}</span>

    <span class="s3">function </span><span class="s1">as_statement_array(thing) {</span>
        <span class="s3">if </span><span class="s1">(thing === </span><span class="s3">null</span><span class="s1">) </span><span class="s3">return </span><span class="s1">[];</span>
        <span class="s3">if </span><span class="s1">(thing </span><span class="s3">instanceof </span><span class="s1">AST_BlockStatement) </span><span class="s3">return </span><span class="s1">thing.body;</span>
        <span class="s3">if </span><span class="s1">(thing </span><span class="s3">instanceof </span><span class="s1">AST_EmptyStatement) </span><span class="s3">return </span><span class="s1">[];</span>
        <span class="s3">if </span><span class="s1">(thing </span><span class="s3">instanceof </span><span class="s1">AST_Statement) </span><span class="s3">return </span><span class="s1">[ thing ];</span>
        <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Can't convert thing to statement array&quot;</span><span class="s1">);</span>
    <span class="s1">};</span>

    <span class="s3">function </span><span class="s1">is_empty(thing) {</span>
        <span class="s3">if </span><span class="s1">(thing === </span><span class="s3">null</span><span class="s1">) </span><span class="s3">return true</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s1">(thing </span><span class="s3">instanceof </span><span class="s1">AST_EmptyStatement) </span><span class="s3">return true</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s1">(thing </span><span class="s3">instanceof </span><span class="s1">AST_BlockStatement) </span><span class="s3">return </span><span class="s1">thing.body.length == </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">};</span>

    <span class="s3">function </span><span class="s1">can_be_evicted_from_block(node) {</span>
        <span class="s3">return </span><span class="s1">!(</span>
            <span class="s1">node </span><span class="s3">instanceof </span><span class="s1">AST_DefClass ||</span>
            <span class="s1">node </span><span class="s3">instanceof </span><span class="s1">AST_Defun ||</span>
            <span class="s1">node </span><span class="s3">instanceof </span><span class="s1">AST_Let ||</span>
            <span class="s1">node </span><span class="s3">instanceof </span><span class="s1">AST_Const ||</span>
            <span class="s1">node </span><span class="s3">instanceof </span><span class="s1">AST_Export ||</span>
            <span class="s1">node </span><span class="s3">instanceof </span><span class="s1">AST_Import</span>
        <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">function </span><span class="s1">loop_body(x) {</span>
        <span class="s3">if </span><span class="s1">(x </span><span class="s3">instanceof </span><span class="s1">AST_IterationStatement) {</span>
            <span class="s3">return </span><span class="s1">x.body </span><span class="s3">instanceof </span><span class="s1">AST_BlockStatement ? x.body : x;</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">x;</span>
    <span class="s1">};</span>

    <span class="s3">function </span><span class="s1">is_iife_call(node) {</span>
        <span class="s3">if </span><span class="s1">(node.TYPE != </span><span class="s2">&quot;Call&quot;</span><span class="s1">) </span><span class="s3">return false</span><span class="s1">;</span>
        <span class="s3">return </span><span class="s1">node.expression </span><span class="s3">instanceof </span><span class="s1">AST_Function || is_iife_call(node.expression);</span>
    <span class="s1">}</span>

    <span class="s3">function </span><span class="s1">is_undeclared_ref(node) {</span>
        <span class="s3">return </span><span class="s1">node </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef &amp;&amp; node.definition().undeclared;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">global_names = makePredicate(</span><span class="s2">&quot;Array Boolean clearInterval clearTimeout console Date decodeURI decodeURIComponent encodeURI encodeURIComponent Error escape eval EvalError Function isFinite isNaN JSON Math Number parseFloat parseInt RangeError ReferenceError RegExp Object setInterval setTimeout String SyntaxError TypeError unescape URIError&quot;</span><span class="s1">);</span>
    <span class="s1">AST_SymbolRef.DEFMETHOD(</span><span class="s2">&quot;is_declared&quot;</span><span class="s1">, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">return </span><span class="s1">!</span><span class="s3">this</span><span class="s1">.definition().undeclared</span>
            <span class="s1">|| compressor.option(</span><span class="s2">&quot;unsafe&quot;</span><span class="s1">) &amp;&amp; global_names(</span><span class="s3">this</span><span class="s1">.name);</span>
    <span class="s1">});</span>

    <span class="s3">var </span><span class="s1">identifier_atom = makePredicate(</span><span class="s2">&quot;Infinity NaN undefined&quot;</span><span class="s1">);</span>
    <span class="s3">function </span><span class="s1">is_identifier_atom(node) {</span>
        <span class="s3">return </span><span class="s1">node </span><span class="s3">instanceof </span><span class="s1">AST_Infinity</span>
            <span class="s1">|| node </span><span class="s3">instanceof </span><span class="s1">AST_NaN</span>
            <span class="s1">|| node </span><span class="s3">instanceof </span><span class="s1">AST_Undefined;</span>
    <span class="s1">}</span>

    <span class="s3">function </span><span class="s1">tighten_body(statements, compressor) {</span>
        <span class="s3">var </span><span class="s1">scope = compressor.find_parent(AST_Scope).get_defun_scope();</span>
        <span class="s3">var </span><span class="s1">CHANGED, max_iter = </span><span class="s4">10</span><span class="s1">;</span>
        <span class="s3">do </span><span class="s1">{</span>
            <span class="s1">CHANGED = </span><span class="s3">false</span><span class="s1">;</span>
            <span class="s1">eliminate_spurious_blocks(statements);</span>
            <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;dead_code&quot;</span><span class="s1">)) {</span>
                <span class="s1">eliminate_dead_code(statements, compressor);</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;if_return&quot;</span><span class="s1">)) {</span>
                <span class="s1">handle_if_return(statements, compressor);</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(compressor.sequences_limit &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s1">sequencesize(statements, compressor);</span>
                <span class="s1">sequencesize_2(statements, compressor);</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;join_vars&quot;</span><span class="s1">)) {</span>
                <span class="s1">join_consecutive_vars(statements);</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;collapse_vars&quot;</span><span class="s1">)) {</span>
                <span class="s1">collapse(statements, compressor);</span>
            <span class="s1">}</span>
        <span class="s1">} </span><span class="s3">while </span><span class="s1">(CHANGED &amp;&amp; max_iter-- &gt; </span><span class="s4">0</span><span class="s1">);</span>

        <span class="s0">// Search from right to left for assignment-like expressions:</span>
        <span class="s0">// - `var a = x;`</span>
        <span class="s0">// - `a = x;`</span>
        <span class="s0">// - `++a`</span>
        <span class="s0">// For each candidate, scan from left to right for first usage, then try</span>
        <span class="s0">// to fold assignment into the site for compression.</span>
        <span class="s0">// Will not attempt to collapse assignments into or past code blocks</span>
        <span class="s0">// which are not sequentially executed, e.g. loops and conditionals.</span>
        <span class="s3">function </span><span class="s1">collapse(statements, compressor) {</span>
            <span class="s3">if </span><span class="s1">(scope.uses_eval || scope.uses_with) </span><span class="s3">return </span><span class="s1">statements;</span>
            <span class="s3">var </span><span class="s1">args;</span>
            <span class="s3">var </span><span class="s1">candidates = [];</span>
            <span class="s3">var </span><span class="s1">in_try = compressor.self() </span><span class="s3">instanceof </span><span class="s1">AST_Try;</span>
            <span class="s3">var </span><span class="s1">stat_index = statements.length;</span>
            <span class="s3">var </span><span class="s1">scanner = </span><span class="s3">new </span><span class="s1">TreeTransformer(</span><span class="s3">function</span><span class="s1">(node, descend) {</span>
                <span class="s3">if </span><span class="s1">(abort) </span><span class="s3">return </span><span class="s1">node;</span>
                <span class="s0">// Scan case expressions first in a switch statement</span>
                <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Switch) {</span>
                    <span class="s3">if </span><span class="s1">(!hit) {</span>
                        <span class="s3">if </span><span class="s1">(node !== hit_stack[hit_index]) </span><span class="s3">return </span><span class="s1">node;</span>
                        <span class="s1">hit_index++;</span>
                    <span class="s1">}</span>
                    <span class="s1">node.expression = node.expression.transform(scanner);</span>
                    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">, len = node.body.length; !abort &amp;&amp; i &lt; len; i++) {</span>
                        <span class="s3">var </span><span class="s1">branch = node.body[i];</span>
                        <span class="s3">if </span><span class="s1">(branch </span><span class="s3">instanceof </span><span class="s1">AST_Case) {</span>
                            <span class="s3">if </span><span class="s1">(!hit) {</span>
                                <span class="s3">if </span><span class="s1">(branch !== hit_stack[hit_index]) </span><span class="s3">continue</span><span class="s1">;</span>
                                <span class="s1">hit_index++;</span>
                            <span class="s1">}</span>
                            <span class="s1">branch.expression = branch.expression.transform(scanner);</span>
                            <span class="s3">if </span><span class="s1">(side_effects || !replace_all) </span><span class="s3">break</span><span class="s1">;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s1">abort = </span><span class="s3">true</span><span class="s1">;</span>
                    <span class="s3">return </span><span class="s1">node;</span>
                <span class="s1">}</span>
                <span class="s0">// Skip nodes before `candidate` as quickly as possible</span>
                <span class="s3">if </span><span class="s1">(!hit) {</span>
                    <span class="s3">if </span><span class="s1">(node !== hit_stack[hit_index]) </span><span class="s3">return </span><span class="s1">node;</span>
                    <span class="s1">hit_index++;</span>
                    <span class="s3">if </span><span class="s1">(hit_index &lt; hit_stack.length) </span><span class="s3">return</span><span class="s1">;</span>
                    <span class="s1">hit = </span><span class="s3">true</span><span class="s1">;</span>
                    <span class="s1">stop_after = find_stop(node, </span><span class="s4">0</span><span class="s1">);</span>
                    <span class="s3">if </span><span class="s1">(stop_after === node) abort = </span><span class="s3">true</span><span class="s1">;</span>
                    <span class="s3">return </span><span class="s1">node;</span>
                <span class="s1">}</span>
                <span class="s0">// Stop immediately if these node types are encountered</span>
                <span class="s3">var </span><span class="s1">parent = scanner.parent();</span>
                <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Assign &amp;&amp; node.operator != </span><span class="s2">&quot;=&quot; </span><span class="s1">&amp;&amp; lhs.equivalent_to(node.left)</span>
                    <span class="s1">|| node </span><span class="s3">instanceof </span><span class="s1">AST_Await</span>
                    <span class="s1">|| node </span><span class="s3">instanceof </span><span class="s1">AST_Call &amp;&amp; lhs </span><span class="s3">instanceof </span><span class="s1">AST_PropAccess &amp;&amp; lhs.equivalent_to(node.expression)</span>
                    <span class="s1">|| node </span><span class="s3">instanceof </span><span class="s1">AST_Debugger</span>
                    <span class="s1">|| node </span><span class="s3">instanceof </span><span class="s1">AST_Destructuring</span>
                    <span class="s1">|| node </span><span class="s3">instanceof </span><span class="s1">AST_IterationStatement &amp;&amp; !(node </span><span class="s3">instanceof </span><span class="s1">AST_For)</span>
                    <span class="s1">|| node </span><span class="s3">instanceof </span><span class="s1">AST_Try</span>
                    <span class="s1">|| node </span><span class="s3">instanceof </span><span class="s1">AST_With</span>
                    <span class="s1">|| parent </span><span class="s3">instanceof </span><span class="s1">AST_For &amp;&amp; node !== parent.init</span>
                    <span class="s1">|| (side_effects || !replace_all)</span>
                        <span class="s1">&amp;&amp; (node </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef &amp;&amp; !node.is_declared(compressor))) {</span>
                    <span class="s1">abort = </span><span class="s3">true</span><span class="s1">;</span>
                    <span class="s3">return </span><span class="s1">node;</span>
                <span class="s1">}</span>
                <span class="s0">// Replace variable with assignment when found</span>
                <span class="s3">if </span><span class="s1">(can_replace</span>
                    <span class="s1">&amp;&amp; !(node </span><span class="s3">instanceof </span><span class="s1">AST_SymbolDeclaration)</span>
                    <span class="s1">&amp;&amp; lhs.equivalent_to(node)) {</span>
                    <span class="s3">if </span><span class="s1">(is_lhs(node, parent)) {</span>
                        <span class="s3">if </span><span class="s1">(value_def) replaced++;</span>
                        <span class="s3">return </span><span class="s1">node;</span>
                    <span class="s1">}</span>
                    <span class="s1">CHANGED = abort = </span><span class="s3">true</span><span class="s1">;</span>
                    <span class="s1">replaced++;</span>
                    <span class="s1">compressor.info(</span><span class="s2">&quot;Collapsing {name} [{file}:{line},{col}]&quot;</span><span class="s1">, {</span>
                        <span class="s1">name: node.print_to_string(),</span>
                        <span class="s1">file: node.start.file,</span>
                        <span class="s1">line: node.start.line,</span>
                        <span class="s1">col: node.start.col</span>
                    <span class="s1">});</span>
                    <span class="s3">if </span><span class="s1">(candidate </span><span class="s3">instanceof </span><span class="s1">AST_UnaryPostfix) {</span>
                        <span class="s3">return </span><span class="s1">make_node(AST_UnaryPrefix, candidate, candidate);</span>
                    <span class="s1">}</span>
                    <span class="s3">if </span><span class="s1">(candidate </span><span class="s3">instanceof </span><span class="s1">AST_VarDef) {</span>
                        <span class="s3">if </span><span class="s1">(value_def) {</span>
                            <span class="s1">abort = </span><span class="s3">false</span><span class="s1">;</span>
                            <span class="s3">return </span><span class="s1">node;</span>
                        <span class="s1">}</span>
                        <span class="s3">var </span><span class="s1">def = candidate.name.definition();</span>
                        <span class="s3">var </span><span class="s1">value = candidate.value;</span>
                        <span class="s3">if </span><span class="s1">(def.references.length - def.replaced == </span><span class="s4">1 </span><span class="s1">&amp;&amp; !compressor.exposed(def)) {</span>
                            <span class="s1">def.replaced++;</span>
                            <span class="s3">if </span><span class="s1">(funarg &amp;&amp; is_identifier_atom(value)) {</span>
                                <span class="s3">return </span><span class="s1">value.transform(compressor);</span>
                            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                                <span class="s3">return </span><span class="s1">maintain_this_binding(parent, node, value);</span>
                            <span class="s1">}</span>
                        <span class="s1">}</span>
                        <span class="s3">return </span><span class="s1">make_node(AST_Assign, candidate, {</span>
                            <span class="s1">operator: </span><span class="s2">&quot;=&quot;</span><span class="s1">,</span>
                            <span class="s1">left: make_node(AST_SymbolRef, candidate.name, candidate.name),</span>
                            <span class="s1">right: value</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                    <span class="s1">candidate.write_only = </span><span class="s3">false</span><span class="s1">;</span>
                    <span class="s3">return </span><span class="s1">candidate;</span>
                <span class="s1">}</span>
                <span class="s0">// These node types have child nodes that execute sequentially,</span>
                <span class="s0">// but are otherwise not safe to scan into or beyond them.</span>
                <span class="s3">var </span><span class="s1">sym;</span>
                <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Call</span>
                    <span class="s1">|| node </span><span class="s3">instanceof </span><span class="s1">AST_Exit</span>
                    <span class="s1">|| node </span><span class="s3">instanceof </span><span class="s1">AST_PropAccess</span>
                        <span class="s1">&amp;&amp; (side_effects || node.expression.may_throw_on_access(compressor))</span>
                    <span class="s1">|| node </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef</span>
                        <span class="s1">&amp;&amp; (lvalues[node.name]</span>
                            <span class="s1">|| side_effects &amp;&amp; !references_in_scope(node.definition()))</span>
                    <span class="s1">|| (sym = lhs_or_def(node))</span>
                        <span class="s1">&amp;&amp; (sym </span><span class="s3">instanceof </span><span class="s1">AST_PropAccess || sym.name </span><span class="s3">in </span><span class="s1">lvalues)</span>
                    <span class="s1">|| may_throw</span>
                        <span class="s1">&amp;&amp; (in_try ? node.has_side_effects(compressor) : side_effects_external(node))</span>
                    <span class="s1">|| (side_effects || !replace_all)</span>
                        <span class="s1">&amp;&amp; (parent </span><span class="s3">instanceof </span><span class="s1">AST_Binary &amp;&amp; lazy_op(parent.operator)</span>
                            <span class="s1">|| parent </span><span class="s3">instanceof </span><span class="s1">AST_Conditional</span>
                            <span class="s1">|| parent </span><span class="s3">instanceof </span><span class="s1">AST_If)) {</span>
                    <span class="s1">stop_after = node;</span>
                    <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Scope) abort = </span><span class="s3">true</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s0">// Skip (non-executed) functions</span>
                <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Scope) </span><span class="s3">return </span><span class="s1">node;</span>
            <span class="s1">}, </span><span class="s3">function</span><span class="s1">(node) {</span>
                <span class="s3">if </span><span class="s1">(!abort &amp;&amp; stop_after === node) abort = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s1">});</span>
            <span class="s3">var </span><span class="s1">multi_replacer = </span><span class="s3">new </span><span class="s1">TreeTransformer(</span><span class="s3">function</span><span class="s1">(node) {</span>
                <span class="s3">if </span><span class="s1">(abort) </span><span class="s3">return </span><span class="s1">node;</span>
                <span class="s0">// Skip nodes before `candidate` as quickly as possible</span>
                <span class="s3">if </span><span class="s1">(!hit) {</span>
                    <span class="s3">if </span><span class="s1">(node !== hit_stack[hit_index]) </span><span class="s3">return </span><span class="s1">node;</span>
                    <span class="s1">hit_index++;</span>
                    <span class="s3">if </span><span class="s1">(hit_index &lt; hit_stack.length) </span><span class="s3">return</span><span class="s1">;</span>
                    <span class="s1">hit = </span><span class="s3">true</span><span class="s1">;</span>
                    <span class="s3">return </span><span class="s1">node;</span>
                <span class="s1">}</span>
                <span class="s0">// Replace variable when found</span>
                <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef</span>
                    <span class="s1">&amp;&amp; node.name == def.name) {</span>
                    <span class="s3">if </span><span class="s1">(!--replaced) abort = </span><span class="s3">true</span><span class="s1">;</span>
                    <span class="s3">if </span><span class="s1">(is_lhs(node, multi_replacer.parent())) </span><span class="s3">return </span><span class="s1">node;</span>
                    <span class="s1">def.replaced++;</span>
                    <span class="s1">value_def.replaced--;</span>
                    <span class="s3">return </span><span class="s1">candidate.value;</span>
                <span class="s1">}</span>
                <span class="s0">// Skip (non-executed) functions and (leading) default case in switch statements</span>
                <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Default || node </span><span class="s3">instanceof </span><span class="s1">AST_Scope) </span><span class="s3">return </span><span class="s1">node;</span>
            <span class="s1">});</span>
            <span class="s3">while </span><span class="s1">(--stat_index &gt;= </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s0">// Treat parameters as collapsible in IIFE, i.e.</span>
                <span class="s0">//   function(a, b){ ... }(x());</span>
                <span class="s0">// would be translated into equivalent assignments:</span>
                <span class="s0">//   var a = x(), b = undefined;</span>
                <span class="s3">if </span><span class="s1">(stat_index == </span><span class="s4">0 </span><span class="s1">&amp;&amp; compressor.option(</span><span class="s2">&quot;unused&quot;</span><span class="s1">)) extract_args();</span>
                <span class="s0">// Find collapsible assignments</span>
                <span class="s3">var </span><span class="s1">hit_stack = [];</span>
                <span class="s1">extract_candidates(statements[stat_index]);</span>
                <span class="s3">while </span><span class="s1">(candidates.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                    <span class="s1">hit_stack = candidates.pop();</span>
                    <span class="s3">var </span><span class="s1">hit_index = </span><span class="s4">0</span><span class="s1">;</span>
                    <span class="s3">var </span><span class="s1">candidate = hit_stack[hit_stack.length - </span><span class="s4">1</span><span class="s1">];</span>
                    <span class="s3">var </span><span class="s1">value_def = </span><span class="s3">null</span><span class="s1">;</span>
                    <span class="s3">var </span><span class="s1">stop_after = </span><span class="s3">null</span><span class="s1">;</span>
                    <span class="s3">var </span><span class="s1">lhs = get_lhs(candidate);</span>
                    <span class="s3">if </span><span class="s1">(!lhs || is_lhs_read_only(lhs) || lhs.has_side_effects(compressor)) </span><span class="s3">continue</span><span class="s1">;</span>
                    <span class="s0">// Locate symbols which may execute code outside of scanning range</span>
                    <span class="s3">var </span><span class="s1">lvalues = get_lvalues(candidate);</span>
                    <span class="s3">if </span><span class="s1">(lhs </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef) lvalues[lhs.name] = </span><span class="s3">false</span><span class="s1">;</span>
                    <span class="s3">var </span><span class="s1">replace_all = value_def;</span>
                    <span class="s3">if </span><span class="s1">(!replace_all &amp;&amp; lhs </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef) {</span>
                        <span class="s3">var </span><span class="s1">def = lhs.definition();</span>
                        <span class="s3">if </span><span class="s1">(def.references.length - def.replaced == (candidate </span><span class="s3">instanceof </span><span class="s1">AST_VarDef ? </span><span class="s4">1 </span><span class="s1">: </span><span class="s4">2</span><span class="s1">)) {</span>
                            <span class="s1">replace_all = </span><span class="s3">true</span><span class="s1">;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s3">var </span><span class="s1">side_effects = value_has_side_effects(candidate);</span>
                    <span class="s3">var </span><span class="s1">may_throw = candidate.may_throw(compressor);</span>
                    <span class="s3">var </span><span class="s1">funarg = candidate.name </span><span class="s3">instanceof </span><span class="s1">AST_SymbolFunarg;</span>
                    <span class="s3">var </span><span class="s1">hit = funarg;</span>
                    <span class="s3">var </span><span class="s1">abort = </span><span class="s3">false</span><span class="s1">, replaced = </span><span class="s4">0</span><span class="s1">, can_replace = !args || !hit;</span>
                    <span class="s3">if </span><span class="s1">(!can_replace) {</span>
                        <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">j = compressor.self().argnames.lastIndexOf(candidate.name) + </span><span class="s4">1</span><span class="s1">; !abort &amp;&amp; j &lt; args.length; j++) {</span>
                            <span class="s1">args[j].transform(scanner);</span>
                        <span class="s1">}</span>
                        <span class="s1">can_replace = </span><span class="s3">true</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = stat_index; !abort &amp;&amp; i &lt; statements.length; i++) {</span>
                        <span class="s1">statements[i].transform(scanner);</span>
                    <span class="s1">}</span>
                    <span class="s3">if </span><span class="s1">(value_def) {</span>
                        <span class="s3">var </span><span class="s1">def = candidate.name.definition();</span>
                        <span class="s3">if </span><span class="s1">(abort &amp;&amp; def.references.length - def.replaced &gt; replaced) replaced = </span><span class="s3">false</span><span class="s1">;</span>
                        <span class="s3">else </span><span class="s1">{</span>
                            <span class="s1">abort = </span><span class="s3">false</span><span class="s1">;</span>
                            <span class="s1">hit_index = </span><span class="s4">0</span><span class="s1">;</span>
                            <span class="s1">hit = funarg;</span>
                            <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = stat_index; !abort &amp;&amp; i &lt; statements.length; i++) {</span>
                                <span class="s1">statements[i].transform(multi_replacer);</span>
                            <span class="s1">}</span>
                            <span class="s1">value_def.single_use = </span><span class="s3">false</span><span class="s1">;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s3">if </span><span class="s1">(replaced &amp;&amp; !remove_candidate(candidate)) statements.splice(stat_index, </span><span class="s4">1</span><span class="s1">);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>

            <span class="s3">function </span><span class="s1">has_overlapping_symbol(fn, arg, fn_strict) {</span>
                <span class="s3">var </span><span class="s1">found = </span><span class="s3">false</span><span class="s1">, scan_this = !(fn </span><span class="s3">instanceof </span><span class="s1">AST_Arrow);</span>
                <span class="s1">arg.walk(</span><span class="s3">new </span><span class="s1">TreeWalker(</span><span class="s3">function</span><span class="s1">(node, descend) {</span>
                    <span class="s3">if </span><span class="s1">(found) </span><span class="s3">return true</span><span class="s1">;</span>
                    <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef &amp;&amp; fn.variables.has(node.name)) {</span>
                        <span class="s3">var </span><span class="s1">s = node.definition().scope;</span>
                        <span class="s3">if </span><span class="s1">(s !== scope) </span><span class="s3">while </span><span class="s1">(s = s.parent_scope) {</span>
                            <span class="s3">if </span><span class="s1">(s === scope) </span><span class="s3">return true</span><span class="s1">;</span>
                        <span class="s1">}</span>
                        <span class="s3">return </span><span class="s1">found = </span><span class="s3">true</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s3">if </span><span class="s1">((fn_strict || scan_this) &amp;&amp; node </span><span class="s3">instanceof </span><span class="s1">AST_This) {</span>
                        <span class="s3">return </span><span class="s1">found = </span><span class="s3">true</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Scope &amp;&amp; !(node </span><span class="s3">instanceof </span><span class="s1">AST_Arrow)) {</span>
                        <span class="s3">var </span><span class="s1">prev = scan_this;</span>
                        <span class="s1">scan_this = </span><span class="s3">false</span><span class="s1">;</span>
                        <span class="s1">descend();</span>
                        <span class="s1">scan_this = prev;</span>
                        <span class="s3">return true</span><span class="s1">;</span>
                    <span class="s1">}</span>
                <span class="s1">}));</span>
                <span class="s3">return </span><span class="s1">found;</span>
            <span class="s1">}</span>

            <span class="s3">function </span><span class="s1">extract_args() {</span>
                <span class="s3">var </span><span class="s1">iife, fn = compressor.self();</span>
                <span class="s3">if </span><span class="s1">(is_func_expr(fn)</span>
                    <span class="s1">&amp;&amp; !fn.name</span>
                    <span class="s1">&amp;&amp; !fn.uses_arguments</span>
                    <span class="s1">&amp;&amp; !fn.uses_eval</span>
                    <span class="s1">&amp;&amp; (iife = compressor.parent()) </span><span class="s3">instanceof </span><span class="s1">AST_Call</span>
                    <span class="s1">&amp;&amp; iife.expression === fn</span>
                    <span class="s1">&amp;&amp; all(iife.args, </span><span class="s3">function</span><span class="s1">(arg) {</span>
                        <span class="s3">return </span><span class="s1">!(arg </span><span class="s3">instanceof </span><span class="s1">AST_Expansion);</span>
                    <span class="s1">})) {</span>
                    <span class="s3">var </span><span class="s1">fn_strict = compressor.has_directive(</span><span class="s2">&quot;use strict&quot;</span><span class="s1">);</span>
                    <span class="s3">if </span><span class="s1">(fn_strict &amp;&amp; !member(fn_strict, fn.body)) fn_strict = </span><span class="s3">false</span><span class="s1">;</span>
                    <span class="s3">var </span><span class="s1">len = fn.argnames.length;</span>
                    <span class="s1">args = iife.args.slice(len);</span>
                    <span class="s3">var </span><span class="s1">names = Object.create(</span><span class="s3">null</span><span class="s1">);</span>
                    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = len; --i &gt;= </span><span class="s4">0</span><span class="s1">;) {</span>
                        <span class="s3">var </span><span class="s1">sym = fn.argnames[i];</span>
                        <span class="s3">var </span><span class="s1">arg = iife.args[i];</span>
                        <span class="s1">args.unshift(make_node(AST_VarDef, sym, {</span>
                            <span class="s1">name: sym,</span>
                            <span class="s1">value: arg</span>
                        <span class="s1">}));</span>
                        <span class="s3">if </span><span class="s1">(sym.name </span><span class="s3">in </span><span class="s1">names) </span><span class="s3">continue</span><span class="s1">;</span>
                        <span class="s1">names[sym.name] = </span><span class="s3">true</span><span class="s1">;</span>
                        <span class="s3">if </span><span class="s1">(sym </span><span class="s3">instanceof </span><span class="s1">AST_Expansion) {</span>
                            <span class="s3">var </span><span class="s1">elements = iife.args.slice(i);</span>
                            <span class="s3">if </span><span class="s1">(all(elements, </span><span class="s3">function</span><span class="s1">(arg) {</span>
                                <span class="s3">return </span><span class="s1">!has_overlapping_symbol(fn, arg, fn_strict);</span>
                            <span class="s1">})) {</span>
                                <span class="s1">candidates.unshift([ make_node(AST_VarDef, sym, {</span>
                                    <span class="s1">name: sym.expression,</span>
                                    <span class="s1">value: make_node(AST_Array, iife, {</span>
                                        <span class="s1">elements: elements</span>
                                    <span class="s1">})</span>
                                <span class="s1">}) ]);</span>
                            <span class="s1">}</span>
                        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                            <span class="s3">if </span><span class="s1">(!arg) arg = make_node(AST_Undefined, sym).transform(compressor);</span>
                            <span class="s3">else if </span><span class="s1">(has_overlapping_symbol(fn, arg, fn_strict)) arg = </span><span class="s3">null</span><span class="s1">;</span>
                            <span class="s3">if </span><span class="s1">(arg) candidates.unshift([ make_node(AST_VarDef, sym, {</span>
                                <span class="s1">name: sym,</span>
                                <span class="s1">value: arg</span>
                            <span class="s1">}) ]);</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>

            <span class="s3">function </span><span class="s1">extract_candidates(expr) {</span>
                <span class="s1">hit_stack.push(expr);</span>
                <span class="s3">if </span><span class="s1">(expr </span><span class="s3">instanceof </span><span class="s1">AST_Assign) {</span>
                    <span class="s3">if </span><span class="s1">(!expr.left.has_side_effects(compressor)) {</span>
                        <span class="s1">candidates.push(hit_stack.slice());</span>
                    <span class="s1">}</span>
                    <span class="s1">extract_candidates(expr.right);</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(expr </span><span class="s3">instanceof </span><span class="s1">AST_Binary) {</span>
                    <span class="s1">extract_candidates(expr.left);</span>
                    <span class="s1">extract_candidates(expr.right);</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(expr </span><span class="s3">instanceof </span><span class="s1">AST_Call) {</span>
                    <span class="s1">extract_candidates(expr.expression);</span>
                    <span class="s1">expr.args.forEach(extract_candidates);</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(expr </span><span class="s3">instanceof </span><span class="s1">AST_Case) {</span>
                    <span class="s1">extract_candidates(expr.expression);</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(expr </span><span class="s3">instanceof </span><span class="s1">AST_Conditional) {</span>
                    <span class="s1">extract_candidates(expr.condition);</span>
                    <span class="s1">extract_candidates(expr.consequent);</span>
                    <span class="s1">extract_candidates(expr.alternative);</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(expr </span><span class="s3">instanceof </span><span class="s1">AST_Definitions</span>
                    <span class="s1">&amp;&amp; (compressor.option(</span><span class="s2">&quot;unused&quot;</span><span class="s1">) || !(expr </span><span class="s3">instanceof </span><span class="s1">AST_Const))) {</span>
                    <span class="s1">expr.definitions.forEach(extract_candidates);</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(expr </span><span class="s3">instanceof </span><span class="s1">AST_DWLoop) {</span>
                    <span class="s1">extract_candidates(expr.condition);</span>
                    <span class="s3">if </span><span class="s1">(!(expr.body </span><span class="s3">instanceof </span><span class="s1">AST_Block)) {</span>
                        <span class="s1">extract_candidates(expr.body);</span>
                    <span class="s1">}</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(expr </span><span class="s3">instanceof </span><span class="s1">AST_Exit) {</span>
                    <span class="s3">if </span><span class="s1">(expr.value) extract_candidates(expr.value);</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(expr </span><span class="s3">instanceof </span><span class="s1">AST_For) {</span>
                    <span class="s3">if </span><span class="s1">(expr.init) extract_candidates(expr.init);</span>
                    <span class="s3">if </span><span class="s1">(expr.condition) extract_candidates(expr.condition);</span>
                    <span class="s3">if </span><span class="s1">(expr.step) extract_candidates(expr.step);</span>
                    <span class="s3">if </span><span class="s1">(!(expr.body </span><span class="s3">instanceof </span><span class="s1">AST_Block)) {</span>
                        <span class="s1">extract_candidates(expr.body);</span>
                    <span class="s1">}</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(expr </span><span class="s3">instanceof </span><span class="s1">AST_ForIn) {</span>
                    <span class="s1">extract_candidates(expr.object);</span>
                    <span class="s3">if </span><span class="s1">(!(expr.body </span><span class="s3">instanceof </span><span class="s1">AST_Block)) {</span>
                        <span class="s1">extract_candidates(expr.body);</span>
                    <span class="s1">}</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(expr </span><span class="s3">instanceof </span><span class="s1">AST_If) {</span>
                    <span class="s1">extract_candidates(expr.condition);</span>
                    <span class="s3">if </span><span class="s1">(!(expr.body </span><span class="s3">instanceof </span><span class="s1">AST_Block)) {</span>
                        <span class="s1">extract_candidates(expr.body);</span>
                    <span class="s1">}</span>
                    <span class="s3">if </span><span class="s1">(expr.alternative &amp;&amp; !(expr.alternative </span><span class="s3">instanceof </span><span class="s1">AST_Block)) {</span>
                        <span class="s1">extract_candidates(expr.alternative);</span>
                    <span class="s1">}</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(expr </span><span class="s3">instanceof </span><span class="s1">AST_Sequence) {</span>
                    <span class="s1">expr.expressions.forEach(extract_candidates);</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(expr </span><span class="s3">instanceof </span><span class="s1">AST_SimpleStatement) {</span>
                    <span class="s1">extract_candidates(expr.body);</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(expr </span><span class="s3">instanceof </span><span class="s1">AST_Switch) {</span>
                    <span class="s1">extract_candidates(expr.expression);</span>
                    <span class="s1">expr.body.forEach(extract_candidates);</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(expr </span><span class="s3">instanceof </span><span class="s1">AST_Unary) {</span>
                    <span class="s3">if </span><span class="s1">(expr.operator == </span><span class="s2">&quot;++&quot; </span><span class="s1">|| expr.operator == </span><span class="s2">&quot;--&quot;</span><span class="s1">) {</span>
                        <span class="s1">candidates.push(hit_stack.slice());</span>
                    <span class="s1">}</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(expr </span><span class="s3">instanceof </span><span class="s1">AST_VarDef) {</span>
                    <span class="s3">if </span><span class="s1">(expr.value) {</span>
                        <span class="s1">candidates.push(hit_stack.slice());</span>
                        <span class="s1">extract_candidates(expr.value);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s1">hit_stack.pop();</span>
            <span class="s1">}</span>

            <span class="s3">function </span><span class="s1">find_stop(node, level) {</span>
                <span class="s3">var </span><span class="s1">parent = scanner.parent(level);</span>
                <span class="s3">if </span><span class="s1">(parent </span><span class="s3">instanceof </span><span class="s1">AST_Binary) </span><span class="s3">return </span><span class="s1">node;</span>
                <span class="s3">if </span><span class="s1">(parent </span><span class="s3">instanceof </span><span class="s1">AST_Call) </span><span class="s3">return </span><span class="s1">node;</span>
                <span class="s3">if </span><span class="s1">(parent </span><span class="s3">instanceof </span><span class="s1">AST_Case) </span><span class="s3">return </span><span class="s1">node;</span>
                <span class="s3">if </span><span class="s1">(parent </span><span class="s3">instanceof </span><span class="s1">AST_Conditional) </span><span class="s3">return </span><span class="s1">node;</span>
                <span class="s3">if </span><span class="s1">(parent </span><span class="s3">instanceof </span><span class="s1">AST_Definitions) </span><span class="s3">return </span><span class="s1">find_stop(parent, level + </span><span class="s4">1</span><span class="s1">);</span>
                <span class="s3">if </span><span class="s1">(parent </span><span class="s3">instanceof </span><span class="s1">AST_Exit) </span><span class="s3">return </span><span class="s1">node;</span>
                <span class="s3">if </span><span class="s1">(parent </span><span class="s3">instanceof </span><span class="s1">AST_If) </span><span class="s3">return </span><span class="s1">node;</span>
                <span class="s3">if </span><span class="s1">(parent </span><span class="s3">instanceof </span><span class="s1">AST_IterationStatement) </span><span class="s3">return </span><span class="s1">node;</span>
                <span class="s3">if </span><span class="s1">(parent </span><span class="s3">instanceof </span><span class="s1">AST_Sequence) </span><span class="s3">return </span><span class="s1">find_stop(parent, level + </span><span class="s4">1</span><span class="s1">);</span>
                <span class="s3">if </span><span class="s1">(parent </span><span class="s3">instanceof </span><span class="s1">AST_SimpleStatement) </span><span class="s3">return </span><span class="s1">find_stop(parent, level + </span><span class="s4">1</span><span class="s1">);</span>
                <span class="s3">if </span><span class="s1">(parent </span><span class="s3">instanceof </span><span class="s1">AST_Switch) </span><span class="s3">return </span><span class="s1">node;</span>
                <span class="s3">if </span><span class="s1">(parent </span><span class="s3">instanceof </span><span class="s1">AST_VarDef) </span><span class="s3">return </span><span class="s1">node;</span>
                <span class="s3">return null</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s3">function </span><span class="s1">mangleable_var(var_def) {</span>
                <span class="s3">var </span><span class="s1">value = var_def.value;</span>
                <span class="s3">if </span><span class="s1">(!(value </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef)) </span><span class="s3">return</span><span class="s1">;</span>
                <span class="s3">if </span><span class="s1">(value.name == </span><span class="s2">&quot;arguments&quot;</span><span class="s1">) </span><span class="s3">return</span><span class="s1">;</span>
                <span class="s3">var </span><span class="s1">def = value.definition();</span>
                <span class="s3">if </span><span class="s1">(def.undeclared) </span><span class="s3">return</span><span class="s1">;</span>
                <span class="s3">return </span><span class="s1">value_def = def;</span>
            <span class="s1">}</span>

            <span class="s3">function </span><span class="s1">get_lhs(expr) {</span>
                <span class="s3">if </span><span class="s1">(expr </span><span class="s3">instanceof </span><span class="s1">AST_VarDef &amp;&amp; expr.name </span><span class="s3">instanceof </span><span class="s1">AST_SymbolDeclaration) {</span>
                    <span class="s3">var </span><span class="s1">def = expr.name.definition();</span>
                    <span class="s3">if </span><span class="s1">(!member(expr.name, def.orig)) </span><span class="s3">return</span><span class="s1">;</span>
                    <span class="s3">var </span><span class="s1">declared = def.orig.length - def.eliminated;</span>
                    <span class="s3">var </span><span class="s1">referenced = def.references.length - def.replaced;</span>
                    <span class="s3">if </span><span class="s1">(declared &gt; </span><span class="s4">1 </span><span class="s1">&amp;&amp; !(expr.name </span><span class="s3">instanceof </span><span class="s1">AST_SymbolFunarg)</span>
                        <span class="s1">|| (referenced &gt; </span><span class="s4">1 </span><span class="s1">? mangleable_var(expr) : !compressor.exposed(def))) {</span>
                        <span class="s3">return </span><span class="s1">make_node(AST_SymbolRef, expr.name, expr.name);</span>
                    <span class="s1">}</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s3">var </span><span class="s1">lhs = expr[expr </span><span class="s3">instanceof </span><span class="s1">AST_Assign ? </span><span class="s2">&quot;left&quot; </span><span class="s1">: </span><span class="s2">&quot;expression&quot;</span><span class="s1">];</span>
                    <span class="s3">return </span><span class="s1">!is_ref_of(lhs, AST_SymbolConst) &amp;&amp; lhs;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>

            <span class="s3">function </span><span class="s1">get_rvalue(expr) {</span>
                <span class="s3">return </span><span class="s1">expr[expr </span><span class="s3">instanceof </span><span class="s1">AST_Assign ? </span><span class="s2">&quot;right&quot; </span><span class="s1">: </span><span class="s2">&quot;value&quot;</span><span class="s1">];</span>
            <span class="s1">}</span>

            <span class="s3">function </span><span class="s1">get_lvalues(expr) {</span>
                <span class="s3">var </span><span class="s1">lvalues = Object.create(</span><span class="s3">null</span><span class="s1">);</span>
                <span class="s3">if </span><span class="s1">(expr </span><span class="s3">instanceof </span><span class="s1">AST_Unary) </span><span class="s3">return </span><span class="s1">lvalues;</span>
                <span class="s3">var </span><span class="s1">tw = </span><span class="s3">new </span><span class="s1">TreeWalker(</span><span class="s3">function</span><span class="s1">(node, descend) {</span>
                    <span class="s3">var </span><span class="s1">sym = node;</span>
                    <span class="s3">while </span><span class="s1">(sym </span><span class="s3">instanceof </span><span class="s1">AST_PropAccess) sym = sym.expression;</span>
                    <span class="s3">if </span><span class="s1">(sym </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef || sym </span><span class="s3">instanceof </span><span class="s1">AST_This) {</span>
                        <span class="s1">lvalues[sym.name] = lvalues[sym.name] || is_lhs(node, tw.parent());</span>
                    <span class="s1">}</span>
                <span class="s1">});</span>
                <span class="s1">get_rvalue(expr).walk(tw);</span>
                <span class="s3">return </span><span class="s1">lvalues;</span>
            <span class="s1">}</span>

            <span class="s3">function </span><span class="s1">lhs_or_def(node) {</span>
                <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_VarDef) </span><span class="s3">return </span><span class="s1">node.value &amp;&amp; node.name;</span>
                <span class="s3">return </span><span class="s1">is_lhs(node.left, node);</span>
            <span class="s1">}</span>

            <span class="s3">function </span><span class="s1">remove_candidate(expr) {</span>
                <span class="s3">if </span><span class="s1">(expr.name </span><span class="s3">instanceof </span><span class="s1">AST_SymbolFunarg) {</span>
                    <span class="s3">var </span><span class="s1">iife = compressor.parent(), argnames = compressor.self().argnames;</span>
                    <span class="s3">var </span><span class="s1">index = argnames.indexOf(expr.name);</span>
                    <span class="s3">if </span><span class="s1">(index &lt; </span><span class="s4">0</span><span class="s1">) {</span>
                        <span class="s1">iife.args.length = Math.min(iife.args.length, argnames.length - </span><span class="s4">1</span><span class="s1">);</span>
                    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                        <span class="s3">var </span><span class="s1">args = iife.args;</span>
                        <span class="s3">if </span><span class="s1">(args[index]) args[index] = make_node(AST_Number, args[index], {</span>
                            <span class="s1">value: </span><span class="s4">0</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                    <span class="s3">return true</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s3">var </span><span class="s1">found = </span><span class="s3">false</span><span class="s1">;</span>
                <span class="s3">return </span><span class="s1">statements[stat_index].transform(</span><span class="s3">new </span><span class="s1">TreeTransformer(</span><span class="s3">function</span><span class="s1">(node, descend, in_list) {</span>
                    <span class="s3">if </span><span class="s1">(found) </span><span class="s3">return </span><span class="s1">node;</span>
                    <span class="s3">if </span><span class="s1">(node === expr || node.body === expr) {</span>
                        <span class="s1">found = </span><span class="s3">true</span><span class="s1">;</span>
                        <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_VarDef) {</span>
                            <span class="s1">node.value = </span><span class="s3">null</span><span class="s1">;</span>
                            <span class="s3">return </span><span class="s1">node;</span>
                        <span class="s1">}</span>
                        <span class="s3">return </span><span class="s1">in_list ? MAP.skip : </span><span class="s3">null</span><span class="s1">;</span>
                    <span class="s1">}</span>
                <span class="s1">}, </span><span class="s3">function</span><span class="s1">(node) {</span>
                    <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Sequence) </span><span class="s3">switch </span><span class="s1">(node.expressions.length) {</span>
                      <span class="s3">case </span><span class="s4">0</span><span class="s1">: </span><span class="s3">return null</span><span class="s1">;</span>
                      <span class="s3">case </span><span class="s4">1</span><span class="s1">: </span><span class="s3">return </span><span class="s1">node.expressions[</span><span class="s4">0</span><span class="s1">];</span>
                    <span class="s1">}</span>
                <span class="s1">}));</span>
            <span class="s1">}</span>

            <span class="s3">function </span><span class="s1">value_has_side_effects(expr) {</span>
                <span class="s3">if </span><span class="s1">(expr </span><span class="s3">instanceof </span><span class="s1">AST_Unary) </span><span class="s3">return false</span><span class="s1">;</span>
                <span class="s3">return </span><span class="s1">get_rvalue(expr).has_side_effects(compressor);</span>
            <span class="s1">}</span>

            <span class="s3">function </span><span class="s1">references_in_scope(def) {</span>
                <span class="s3">if </span><span class="s1">(def.orig.length == </span><span class="s4">1 </span><span class="s1">&amp;&amp; def.orig[</span><span class="s4">0</span><span class="s1">] </span><span class="s3">instanceof </span><span class="s1">AST_SymbolDefun) </span><span class="s3">return true</span><span class="s1">;</span>
                <span class="s3">if </span><span class="s1">(def.scope.get_defun_scope() !== scope) </span><span class="s3">return false</span><span class="s1">;</span>
                <span class="s3">return </span><span class="s1">def.references.every(</span><span class="s3">function</span><span class="s1">(ref) {</span>
                    <span class="s3">return </span><span class="s1">ref.scope.get_defun_scope() === scope;</span>
                <span class="s1">});</span>
            <span class="s1">}</span>

            <span class="s3">function </span><span class="s1">side_effects_external(node, lhs) {</span>
                <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Assign) {</span>
                    <span class="s3">return </span><span class="s1">side_effects_external(node.left, </span><span class="s3">true</span><span class="s1">)</span>
                        <span class="s1">|| side_effects_external(node.right);</span>
                <span class="s1">}</span>
                <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Definitions) </span><span class="s3">return false</span><span class="s1">;</span>
                <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Unary) </span><span class="s3">return </span><span class="s1">side_effects_external(node.expression, </span><span class="s3">true</span><span class="s1">);</span>
                <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_VarDef) </span><span class="s3">return </span><span class="s1">node.value &amp;&amp; side_effects_external(node.value);</span>
                <span class="s3">if </span><span class="s1">(lhs) {</span>
                    <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Dot) </span><span class="s3">return </span><span class="s1">side_effects_external(node.expression, </span><span class="s3">true</span><span class="s1">);</span>
                    <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Sub) {</span>
                        <span class="s3">return </span><span class="s1">side_effects_external(node.expression, </span><span class="s3">true</span><span class="s1">)</span>
                            <span class="s1">|| side_effects_external(node.property);</span>
                    <span class="s1">}</span>
                    <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef) </span><span class="s3">return </span><span class="s1">node.definition().scope !== scope;</span>
                <span class="s1">}</span>
                <span class="s3">return </span><span class="s1">node.has_side_effects(compressor);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">function </span><span class="s1">eliminate_spurious_blocks(statements) {</span>
            <span class="s3">var </span><span class="s1">seen_dirs = [];</span>
            <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; statements.length;) {</span>
                <span class="s3">var </span><span class="s1">stat = statements[i];</span>
                <span class="s3">if </span><span class="s1">(stat </span><span class="s3">instanceof </span><span class="s1">AST_BlockStatement &amp;&amp; all(stat.body, can_be_evicted_from_block)) {</span>
                    <span class="s1">CHANGED = </span><span class="s3">true</span><span class="s1">;</span>
                    <span class="s1">eliminate_spurious_blocks(stat.body);</span>
                    <span class="s1">[].splice.apply(statements, [i, </span><span class="s4">1</span><span class="s1">].concat(stat.body));</span>
                    <span class="s1">i += stat.body.length;</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(stat </span><span class="s3">instanceof </span><span class="s1">AST_EmptyStatement) {</span>
                    <span class="s1">CHANGED = </span><span class="s3">true</span><span class="s1">;</span>
                    <span class="s1">statements.splice(i, </span><span class="s4">1</span><span class="s1">);</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(stat </span><span class="s3">instanceof </span><span class="s1">AST_Directive) {</span>
                    <span class="s3">if </span><span class="s1">(seen_dirs.indexOf(stat.value) &lt; </span><span class="s4">0</span><span class="s1">) {</span>
                        <span class="s1">i++;</span>
                        <span class="s1">seen_dirs.push(stat.value);</span>
                    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                        <span class="s1">CHANGED = </span><span class="s3">true</span><span class="s1">;</span>
                        <span class="s1">statements.splice(i, </span><span class="s4">1</span><span class="s1">);</span>
                    <span class="s1">}</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">i++;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">function </span><span class="s1">handle_if_return(statements, compressor) {</span>
            <span class="s3">var </span><span class="s1">self = compressor.self();</span>
            <span class="s3">var </span><span class="s1">multiple_if_returns = has_multiple_if_returns(statements);</span>
            <span class="s3">var </span><span class="s1">in_lambda = self </span><span class="s3">instanceof </span><span class="s1">AST_Lambda;</span>
            <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = statements.length; --i &gt;= </span><span class="s4">0</span><span class="s1">;) {</span>
                <span class="s3">var </span><span class="s1">stat = statements[i];</span>
                <span class="s3">var </span><span class="s1">j = next_index(i);</span>
                <span class="s3">var </span><span class="s1">next = statements[j];</span>

                <span class="s3">if </span><span class="s1">(in_lambda &amp;&amp; !next &amp;&amp; stat </span><span class="s3">instanceof </span><span class="s1">AST_Return) {</span>
                    <span class="s3">if </span><span class="s1">(!stat.value) {</span>
                        <span class="s1">CHANGED = </span><span class="s3">true</span><span class="s1">;</span>
                        <span class="s1">statements.splice(i, </span><span class="s4">1</span><span class="s1">);</span>
                        <span class="s3">continue</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s3">if </span><span class="s1">(stat.value </span><span class="s3">instanceof </span><span class="s1">AST_UnaryPrefix &amp;&amp; stat.value.operator == </span><span class="s2">&quot;void&quot;</span><span class="s1">) {</span>
                        <span class="s1">CHANGED = </span><span class="s3">true</span><span class="s1">;</span>
                        <span class="s1">statements[i] = make_node(AST_SimpleStatement, stat, {</span>
                            <span class="s1">body: stat.value.expression</span>
                        <span class="s1">});</span>
                        <span class="s3">continue</span><span class="s1">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>

                <span class="s3">if </span><span class="s1">(stat </span><span class="s3">instanceof </span><span class="s1">AST_If) {</span>
                    <span class="s3">var </span><span class="s1">ab = aborts(stat.body);</span>
                    <span class="s3">if </span><span class="s1">(can_merge_flow(ab)) {</span>
                        <span class="s3">if </span><span class="s1">(ab.label) {</span>
                            <span class="s1">remove(ab.label.thedef.references, ab);</span>
                        <span class="s1">}</span>
                        <span class="s1">CHANGED = </span><span class="s3">true</span><span class="s1">;</span>
                        <span class="s1">stat = stat.clone();</span>
                        <span class="s1">stat.condition = stat.condition.negate(compressor);</span>
                        <span class="s3">var </span><span class="s1">body = as_statement_array_with_return(stat.body, ab);</span>
                        <span class="s1">stat.body = make_node(AST_BlockStatement, stat, {</span>
                            <span class="s1">body: as_statement_array(stat.alternative).concat(extract_functions())</span>
                        <span class="s1">});</span>
                        <span class="s1">stat.alternative = make_node(AST_BlockStatement, stat, {</span>
                            <span class="s1">body: body</span>
                        <span class="s1">});</span>
                        <span class="s1">statements[i] = stat.transform(compressor);</span>
                        <span class="s3">continue</span><span class="s1">;</span>
                    <span class="s1">}</span>

                    <span class="s3">var </span><span class="s1">ab = aborts(stat.alternative);</span>
                    <span class="s3">if </span><span class="s1">(can_merge_flow(ab)) {</span>
                        <span class="s3">if </span><span class="s1">(ab.label) {</span>
                            <span class="s1">remove(ab.label.thedef.references, ab);</span>
                        <span class="s1">}</span>
                        <span class="s1">CHANGED = </span><span class="s3">true</span><span class="s1">;</span>
                        <span class="s1">stat = stat.clone();</span>
                        <span class="s1">stat.body = make_node(AST_BlockStatement, stat.body, {</span>
                            <span class="s1">body: as_statement_array(stat.body).concat(extract_functions())</span>
                        <span class="s1">});</span>
                        <span class="s3">var </span><span class="s1">body = as_statement_array_with_return(stat.alternative, ab);</span>
                        <span class="s1">stat.alternative = make_node(AST_BlockStatement, stat.alternative, {</span>
                            <span class="s1">body: body</span>
                        <span class="s1">});</span>
                        <span class="s1">statements[i] = stat.transform(compressor);</span>
                        <span class="s3">continue</span><span class="s1">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>

                <span class="s3">if </span><span class="s1">(stat </span><span class="s3">instanceof </span><span class="s1">AST_If &amp;&amp; stat.body </span><span class="s3">instanceof </span><span class="s1">AST_Return) {</span>
                    <span class="s3">var </span><span class="s1">value = stat.body.value;</span>
                    <span class="s0">//---</span>
                    <span class="s0">// pretty silly case, but:</span>
                    <span class="s0">// if (foo()) return; return; ==&gt; foo(); return;</span>
                    <span class="s3">if </span><span class="s1">(!value &amp;&amp; !stat.alternative</span>
                        <span class="s1">&amp;&amp; (in_lambda &amp;&amp; !next || next </span><span class="s3">instanceof </span><span class="s1">AST_Return &amp;&amp; !next.value)) {</span>
                        <span class="s1">CHANGED = </span><span class="s3">true</span><span class="s1">;</span>
                        <span class="s1">statements[i] = make_node(AST_SimpleStatement, stat.condition, {</span>
                            <span class="s1">body: stat.condition</span>
                        <span class="s1">});</span>
                        <span class="s3">continue</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s0">//---</span>
                    <span class="s0">// if (foo()) return x; return y; ==&gt; return foo() ? x : y;</span>
                    <span class="s3">if </span><span class="s1">(value &amp;&amp; !stat.alternative &amp;&amp; next </span><span class="s3">instanceof </span><span class="s1">AST_Return &amp;&amp; next.value) {</span>
                        <span class="s1">CHANGED = </span><span class="s3">true</span><span class="s1">;</span>
                        <span class="s1">stat = stat.clone();</span>
                        <span class="s1">stat.alternative = next;</span>
                        <span class="s1">statements.splice(i, </span><span class="s4">1</span><span class="s1">, stat.transform(compressor));</span>
                        <span class="s1">statements.splice(j, </span><span class="s4">1</span><span class="s1">);</span>
                        <span class="s3">continue</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s0">//---</span>
                    <span class="s0">// if (foo()) return x; [ return ; ] ==&gt; return foo() ? x : undefined;</span>
                    <span class="s3">if </span><span class="s1">(value &amp;&amp; !stat.alternative</span>
                        <span class="s1">&amp;&amp; (!next &amp;&amp; in_lambda &amp;&amp; multiple_if_returns</span>
                            <span class="s1">|| next </span><span class="s3">instanceof </span><span class="s1">AST_Return)) {</span>
                        <span class="s1">CHANGED = </span><span class="s3">true</span><span class="s1">;</span>
                        <span class="s1">stat = stat.clone();</span>
                        <span class="s1">stat.alternative = next || make_node(AST_Return, stat, {</span>
                            <span class="s1">value: </span><span class="s3">null</span>
                        <span class="s1">});</span>
                        <span class="s1">statements.splice(i, </span><span class="s4">1</span><span class="s1">, stat.transform(compressor));</span>
                        <span class="s3">if </span><span class="s1">(next) statements.splice(j, </span><span class="s4">1</span><span class="s1">);</span>
                        <span class="s3">continue</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s0">//---</span>
                    <span class="s0">// if (a) return b; if (c) return d; e; ==&gt; return a ? b : c ? d : void e;</span>
                    <span class="s0">//</span>
                    <span class="s0">// if sequences is not enabled, this can lead to an endless loop (issue #866).</span>
                    <span class="s0">// however, with sequences on this helps producing slightly better output for</span>
                    <span class="s0">// the example code.</span>
                    <span class="s3">var </span><span class="s1">prev = statements[prev_index(i)];</span>
                    <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;sequences&quot;</span><span class="s1">) &amp;&amp; in_lambda &amp;&amp; !stat.alternative</span>
                        <span class="s1">&amp;&amp; prev </span><span class="s3">instanceof </span><span class="s1">AST_If &amp;&amp; prev.body </span><span class="s3">instanceof </span><span class="s1">AST_Return</span>
                        <span class="s1">&amp;&amp; next_index(j) == statements.length &amp;&amp; next </span><span class="s3">instanceof </span><span class="s1">AST_SimpleStatement) {</span>
                        <span class="s1">CHANGED = </span><span class="s3">true</span><span class="s1">;</span>
                        <span class="s1">stat = stat.clone();</span>
                        <span class="s1">stat.alternative = make_node(AST_BlockStatement, next, {</span>
                            <span class="s1">body: [</span>
                                <span class="s1">next,</span>
                                <span class="s1">make_node(AST_Return, next, {</span>
                                    <span class="s1">value: </span><span class="s3">null</span>
                                <span class="s1">})</span>
                            <span class="s1">]</span>
                        <span class="s1">});</span>
                        <span class="s1">statements.splice(i, </span><span class="s4">1</span><span class="s1">, stat.transform(compressor));</span>
                        <span class="s1">statements.splice(j, </span><span class="s4">1</span><span class="s1">);</span>
                        <span class="s3">continue</span><span class="s1">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>

            <span class="s3">function </span><span class="s1">has_multiple_if_returns(statements) {</span>
                <span class="s3">var </span><span class="s1">n = </span><span class="s4">0</span><span class="s1">;</span>
                <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = statements.length; --i &gt;= </span><span class="s4">0</span><span class="s1">;) {</span>
                    <span class="s3">var </span><span class="s1">stat = statements[i];</span>
                    <span class="s3">if </span><span class="s1">(stat </span><span class="s3">instanceof </span><span class="s1">AST_If &amp;&amp; stat.body </span><span class="s3">instanceof </span><span class="s1">AST_Return) {</span>
                        <span class="s3">if </span><span class="s1">(++n &gt; </span><span class="s4">1</span><span class="s1">) </span><span class="s3">return true</span><span class="s1">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s3">return false</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s3">function </span><span class="s1">is_return_void(value) {</span>
                <span class="s3">return </span><span class="s1">!value || value </span><span class="s3">instanceof </span><span class="s1">AST_UnaryPrefix &amp;&amp; value.operator == </span><span class="s2">&quot;void&quot;</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s3">function </span><span class="s1">can_merge_flow(ab) {</span>
                <span class="s3">if </span><span class="s1">(!ab) </span><span class="s3">return false</span><span class="s1">;</span>
                <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">j = i + </span><span class="s4">1</span><span class="s1">, len = statements.length; j &lt; len; j++) {</span>
                    <span class="s3">var </span><span class="s1">stat = statements[j];</span>
                    <span class="s3">if </span><span class="s1">(stat </span><span class="s3">instanceof </span><span class="s1">AST_Const || stat </span><span class="s3">instanceof </span><span class="s1">AST_Let) </span><span class="s3">return false</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s3">var </span><span class="s1">lct = ab </span><span class="s3">instanceof </span><span class="s1">AST_LoopControl ? compressor.loopcontrol_target(ab) : </span><span class="s3">null</span><span class="s1">;</span>
                <span class="s3">return </span><span class="s1">ab </span><span class="s3">instanceof </span><span class="s1">AST_Return &amp;&amp; in_lambda &amp;&amp; is_return_void(ab.value)</span>
                    <span class="s1">|| ab </span><span class="s3">instanceof </span><span class="s1">AST_Continue &amp;&amp; self === loop_body(lct)</span>
                    <span class="s1">|| ab </span><span class="s3">instanceof </span><span class="s1">AST_Break &amp;&amp; lct </span><span class="s3">instanceof </span><span class="s1">AST_BlockStatement &amp;&amp; self === lct;</span>
            <span class="s1">}</span>

            <span class="s3">function </span><span class="s1">extract_functions() {</span>
                <span class="s3">var </span><span class="s1">tail = statements.slice(i + </span><span class="s4">1</span><span class="s1">);</span>
                <span class="s1">statements.length = i + </span><span class="s4">1</span><span class="s1">;</span>
                <span class="s3">return </span><span class="s1">tail.filter(</span><span class="s3">function</span><span class="s1">(stat) {</span>
                    <span class="s3">if </span><span class="s1">(stat </span><span class="s3">instanceof </span><span class="s1">AST_Defun) {</span>
                        <span class="s1">statements.push(stat);</span>
                        <span class="s3">return false</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s3">return true</span><span class="s1">;</span>
                <span class="s1">});</span>
            <span class="s1">}</span>

            <span class="s3">function </span><span class="s1">as_statement_array_with_return(node, ab) {</span>
                <span class="s3">var </span><span class="s1">body = as_statement_array(node).slice(</span><span class="s4">0</span><span class="s1">, -</span><span class="s4">1</span><span class="s1">);</span>
                <span class="s3">if </span><span class="s1">(ab.value) {</span>
                    <span class="s1">body.push(make_node(AST_SimpleStatement, ab.value, {</span>
                        <span class="s1">body: ab.value.expression</span>
                    <span class="s1">}));</span>
                <span class="s1">}</span>
                <span class="s3">return </span><span class="s1">body;</span>
            <span class="s1">}</span>

            <span class="s3">function </span><span class="s1">next_index(i) {</span>
                <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">j = i + </span><span class="s4">1</span><span class="s1">, len = statements.length; j &lt; len; j++) {</span>
                    <span class="s3">var </span><span class="s1">stat = statements[j];</span>
                    <span class="s3">if </span><span class="s1">(!(stat </span><span class="s3">instanceof </span><span class="s1">AST_Var &amp;&amp; declarations_only(stat))) {</span>
                        <span class="s3">break</span><span class="s1">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s3">return </span><span class="s1">j;</span>
            <span class="s1">}</span>

            <span class="s3">function </span><span class="s1">prev_index(i) {</span>
                <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">j = i; --j &gt;= </span><span class="s4">0</span><span class="s1">;) {</span>
                    <span class="s3">var </span><span class="s1">stat = statements[j];</span>
                    <span class="s3">if </span><span class="s1">(!(stat </span><span class="s3">instanceof </span><span class="s1">AST_Var &amp;&amp; declarations_only(stat))) {</span>
                        <span class="s3">break</span><span class="s1">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s3">return </span><span class="s1">j;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">function </span><span class="s1">eliminate_dead_code(statements, compressor) {</span>
            <span class="s3">var </span><span class="s1">has_quit;</span>
            <span class="s3">var </span><span class="s1">self = compressor.self();</span>
            <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">, n = </span><span class="s4">0</span><span class="s1">, len = statements.length; i &lt; len; i++) {</span>
                <span class="s3">var </span><span class="s1">stat = statements[i];</span>
                <span class="s3">if </span><span class="s1">(stat </span><span class="s3">instanceof </span><span class="s1">AST_LoopControl) {</span>
                    <span class="s3">var </span><span class="s1">lct = compressor.loopcontrol_target(stat);</span>
                    <span class="s3">if </span><span class="s1">(stat </span><span class="s3">instanceof </span><span class="s1">AST_Break</span>
                            <span class="s1">&amp;&amp; !(lct </span><span class="s3">instanceof </span><span class="s1">AST_IterationStatement)</span>
                            <span class="s1">&amp;&amp; loop_body(lct) === self</span>
                        <span class="s1">|| stat </span><span class="s3">instanceof </span><span class="s1">AST_Continue</span>
                            <span class="s1">&amp;&amp; loop_body(lct) === self) {</span>
                        <span class="s3">if </span><span class="s1">(stat.label) {</span>
                            <span class="s1">remove(stat.label.thedef.references, stat);</span>
                        <span class="s1">}</span>
                    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                        <span class="s1">statements[n++] = stat;</span>
                    <span class="s1">}</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s1">statements[n++] = stat;</span>
                <span class="s1">}</span>
                <span class="s3">if </span><span class="s1">(aborts(stat)) {</span>
                    <span class="s1">has_quit = statements.slice(i + </span><span class="s4">1</span><span class="s1">);</span>
                    <span class="s3">break</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">statements.length = n;</span>
            <span class="s1">CHANGED = n != len;</span>
            <span class="s3">if </span><span class="s1">(has_quit) has_quit.forEach(</span><span class="s3">function</span><span class="s1">(stat) {</span>
                <span class="s1">extract_declarations_from_unreachable_code(compressor, stat, statements);</span>
            <span class="s1">});</span>
        <span class="s1">}</span>

        <span class="s3">function </span><span class="s1">declarations_only(node) {</span>
            <span class="s3">return </span><span class="s1">all(node.definitions, </span><span class="s3">function</span><span class="s1">(var_def) {</span>
                <span class="s3">return </span><span class="s1">!var_def.value;</span>
            <span class="s1">});</span>
        <span class="s1">}</span>

        <span class="s3">function </span><span class="s1">sequencesize(statements, compressor) {</span>
            <span class="s3">if </span><span class="s1">(statements.length &lt; </span><span class="s4">2</span><span class="s1">) </span><span class="s3">return</span><span class="s1">;</span>
            <span class="s3">var </span><span class="s1">seq = [], n = </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s3">function </span><span class="s1">push_seq() {</span>
                <span class="s3">if </span><span class="s1">(!seq.length) </span><span class="s3">return</span><span class="s1">;</span>
                <span class="s3">var </span><span class="s1">body = make_sequence(seq[</span><span class="s4">0</span><span class="s1">], seq);</span>
                <span class="s1">statements[n++] = make_node(AST_SimpleStatement, body, { body: body });</span>
                <span class="s1">seq = [];</span>
            <span class="s1">}</span>
            <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">, len = statements.length; i &lt; len; i++) {</span>
                <span class="s3">var </span><span class="s1">stat = statements[i];</span>
                <span class="s3">if </span><span class="s1">(stat </span><span class="s3">instanceof </span><span class="s1">AST_SimpleStatement) {</span>
                    <span class="s3">if </span><span class="s1">(seq.length &gt;= compressor.sequences_limit) push_seq();</span>
                    <span class="s3">var </span><span class="s1">body = stat.body;</span>
                    <span class="s3">if </span><span class="s1">(seq.length &gt; </span><span class="s4">0</span><span class="s1">) body = body.drop_side_effect_free(compressor);</span>
                    <span class="s3">if </span><span class="s1">(body) merge_sequence(seq, body);</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(stat </span><span class="s3">instanceof </span><span class="s1">AST_Definitions &amp;&amp; declarations_only(stat)</span>
                    <span class="s1">|| stat </span><span class="s3">instanceof </span><span class="s1">AST_Defun) {</span>
                    <span class="s1">statements[n++] = stat;</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s1">push_seq();</span>
                    <span class="s1">statements[n++] = stat;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">push_seq();</span>
            <span class="s1">statements.length = n;</span>
            <span class="s3">if </span><span class="s1">(n != len) CHANGED = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">function </span><span class="s1">to_simple_statement(block, decls) {</span>
            <span class="s3">if </span><span class="s1">(!(block </span><span class="s3">instanceof </span><span class="s1">AST_BlockStatement)) </span><span class="s3">return </span><span class="s1">block;</span>
            <span class="s3">var </span><span class="s1">stat = </span><span class="s3">null</span><span class="s1">;</span>
            <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">, len = block.body.length; i &lt; len; i++) {</span>
                <span class="s3">var </span><span class="s1">line = block.body[i];</span>
                <span class="s3">if </span><span class="s1">(line </span><span class="s3">instanceof </span><span class="s1">AST_Var &amp;&amp; declarations_only(line)) {</span>
                    <span class="s1">decls.push(line);</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(stat) {</span>
                    <span class="s3">return false</span><span class="s1">;</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s1">stat = line;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s3">return </span><span class="s1">stat;</span>
        <span class="s1">}</span>

        <span class="s3">function </span><span class="s1">sequencesize_2(statements, compressor) {</span>
            <span class="s3">function </span><span class="s1">cons_seq(right) {</span>
                <span class="s1">n--;</span>
                <span class="s1">CHANGED = </span><span class="s3">true</span><span class="s1">;</span>
                <span class="s3">var </span><span class="s1">left = prev.body;</span>
                <span class="s3">return </span><span class="s1">make_sequence(left, [ left, right ]).transform(compressor);</span>
            <span class="s1">};</span>
            <span class="s3">var </span><span class="s1">n = </span><span class="s4">0</span><span class="s1">, prev;</span>
            <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; statements.length; i++) {</span>
                <span class="s3">var </span><span class="s1">stat = statements[i];</span>
                <span class="s3">if </span><span class="s1">(prev) {</span>
                    <span class="s3">if </span><span class="s1">(stat </span><span class="s3">instanceof </span><span class="s1">AST_Exit) {</span>
                        <span class="s1">stat.value = cons_seq(stat.value || make_node(AST_Undefined, stat).transform(compressor));</span>
                    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(stat </span><span class="s3">instanceof </span><span class="s1">AST_For) {</span>
                        <span class="s3">if </span><span class="s1">(!(stat.init </span><span class="s3">instanceof </span><span class="s1">AST_Definitions)) {</span>
                            <span class="s3">var </span><span class="s1">abort = </span><span class="s3">false</span><span class="s1">;</span>
                            <span class="s1">prev.body.walk(</span><span class="s3">new </span><span class="s1">TreeWalker(</span><span class="s3">function</span><span class="s1">(node) {</span>
                                <span class="s3">if </span><span class="s1">(abort || node </span><span class="s3">instanceof </span><span class="s1">AST_Scope) </span><span class="s3">return true</span><span class="s1">;</span>
                                <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Binary &amp;&amp; node.operator == </span><span class="s2">&quot;in&quot;</span><span class="s1">) {</span>
                                    <span class="s1">abort = </span><span class="s3">true</span><span class="s1">;</span>
                                    <span class="s3">return true</span><span class="s1">;</span>
                                <span class="s1">}</span>
                            <span class="s1">}));</span>
                            <span class="s3">if </span><span class="s1">(!abort) {</span>
                                <span class="s3">if </span><span class="s1">(stat.init) stat.init = cons_seq(stat.init);</span>
                                <span class="s3">else </span><span class="s1">{</span>
                                    <span class="s1">stat.init = prev.body;</span>
                                    <span class="s1">n--;</span>
                                    <span class="s1">CHANGED = </span><span class="s3">true</span><span class="s1">;</span>
                                <span class="s1">}</span>
                            <span class="s1">}</span>
                        <span class="s1">}</span>
                    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(stat </span><span class="s3">instanceof </span><span class="s1">AST_ForIn) {</span>
                        <span class="s3">if </span><span class="s1">(!(stat.init </span><span class="s3">instanceof </span><span class="s1">AST_Const) &amp;&amp; !(stat.init </span><span class="s3">instanceof </span><span class="s1">AST_Let)) {</span>
                            <span class="s1">stat.object = cons_seq(stat.object);</span>
                        <span class="s1">}</span>
                    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(stat </span><span class="s3">instanceof </span><span class="s1">AST_If) {</span>
                        <span class="s1">stat.condition = cons_seq(stat.condition);</span>
                    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(stat </span><span class="s3">instanceof </span><span class="s1">AST_Switch) {</span>
                        <span class="s1">stat.expression = cons_seq(stat.expression);</span>
                    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(stat </span><span class="s3">instanceof </span><span class="s1">AST_With) {</span>
                        <span class="s1">stat.expression = cons_seq(stat.expression);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;conditionals&quot;</span><span class="s1">) &amp;&amp; stat </span><span class="s3">instanceof </span><span class="s1">AST_If) {</span>
                    <span class="s3">var </span><span class="s1">decls = [];</span>
                    <span class="s3">var </span><span class="s1">body = to_simple_statement(stat.body, decls);</span>
                    <span class="s3">var </span><span class="s1">alt = to_simple_statement(stat.alternative, decls);</span>
                    <span class="s3">if </span><span class="s1">(body !== </span><span class="s3">false </span><span class="s1">&amp;&amp; alt !== </span><span class="s3">false </span><span class="s1">&amp;&amp; decls.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                        <span class="s3">var </span><span class="s1">len = decls.length;</span>
                        <span class="s1">decls.push(make_node(AST_If, stat, {</span>
                            <span class="s1">condition: stat.condition,</span>
                            <span class="s1">body: body || make_node(AST_EmptyStatement, stat.body),</span>
                            <span class="s1">alternative: alt</span>
                        <span class="s1">}));</span>
                        <span class="s1">decls.unshift(n, </span><span class="s4">1</span><span class="s1">);</span>
                        <span class="s1">[].splice.apply(statements, decls);</span>
                        <span class="s1">i += len;</span>
                        <span class="s1">n += len + </span><span class="s4">1</span><span class="s1">;</span>
                        <span class="s1">prev = </span><span class="s3">null</span><span class="s1">;</span>
                        <span class="s1">CHANGED = </span><span class="s3">true</span><span class="s1">;</span>
                        <span class="s3">continue</span><span class="s1">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s1">statements[n++] = stat;</span>
                <span class="s1">prev = stat </span><span class="s3">instanceof </span><span class="s1">AST_SimpleStatement ? stat : </span><span class="s3">null</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">statements.length = n;</span>
        <span class="s1">}</span>

        <span class="s3">function </span><span class="s1">join_object_assignments(defn, body) {</span>
            <span class="s3">if </span><span class="s1">(!(defn </span><span class="s3">instanceof </span><span class="s1">AST_Definitions)) </span><span class="s3">return</span><span class="s1">;</span>
            <span class="s3">var </span><span class="s1">def = defn.definitions[defn.definitions.length - </span><span class="s4">1</span><span class="s1">];</span>
            <span class="s3">if </span><span class="s1">(!(def.value </span><span class="s3">instanceof </span><span class="s1">AST_Object)) </span><span class="s3">return</span><span class="s1">;</span>
            <span class="s3">var </span><span class="s1">exprs;</span>
            <span class="s3">if </span><span class="s1">(body </span><span class="s3">instanceof </span><span class="s1">AST_Assign) {</span>
                <span class="s1">exprs = [ body ];</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(body </span><span class="s3">instanceof </span><span class="s1">AST_Sequence) {</span>
                <span class="s1">exprs = body.expressions.slice();</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(!exprs) </span><span class="s3">return</span><span class="s1">;</span>
            <span class="s3">var </span><span class="s1">trimmed = </span><span class="s3">false</span><span class="s1">;</span>
            <span class="s3">do </span><span class="s1">{</span>
                <span class="s3">var </span><span class="s1">node = exprs[</span><span class="s4">0</span><span class="s1">];</span>
                <span class="s3">if </span><span class="s1">(!(node </span><span class="s3">instanceof </span><span class="s1">AST_Assign)) </span><span class="s3">break</span><span class="s1">;</span>
                <span class="s3">if </span><span class="s1">(node.operator != </span><span class="s2">&quot;=&quot;</span><span class="s1">) </span><span class="s3">break</span><span class="s1">;</span>
                <span class="s3">if </span><span class="s1">(!(node.left </span><span class="s3">instanceof </span><span class="s1">AST_PropAccess)) </span><span class="s3">break</span><span class="s1">;</span>
                <span class="s3">var </span><span class="s1">sym = node.left.expression;</span>
                <span class="s3">if </span><span class="s1">(!(sym </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef)) </span><span class="s3">break</span><span class="s1">;</span>
                <span class="s3">if </span><span class="s1">(def.name.name != sym.name) </span><span class="s3">break</span><span class="s1">;</span>
                <span class="s3">if </span><span class="s1">(!node.right.is_constant_expression(scope)) </span><span class="s3">break</span><span class="s1">;</span>
                <span class="s3">var </span><span class="s1">prop = node.left.property;</span>
                <span class="s3">if </span><span class="s1">(prop </span><span class="s3">instanceof </span><span class="s1">AST_Node) {</span>
                    <span class="s1">prop = prop.evaluate(compressor);</span>
                <span class="s1">}</span>
                <span class="s3">if </span><span class="s1">(prop </span><span class="s3">instanceof </span><span class="s1">AST_Node) </span><span class="s3">break</span><span class="s1">;</span>
                <span class="s1">prop = </span><span class="s2">&quot;&quot; </span><span class="s1">+ prop;</span>
                <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;ecma&quot;</span><span class="s1">) &lt; </span><span class="s4">6 </span><span class="s1">&amp;&amp; compressor.has_directive(</span><span class="s2">&quot;use strict&quot;</span><span class="s1">)) {</span>
                    <span class="s3">if </span><span class="s1">(!all(def.value.properties, </span><span class="s3">function</span><span class="s1">(node) {</span>
                        <span class="s3">return </span><span class="s1">node.key != prop &amp;&amp; node.key.name != prop;</span>
                    <span class="s1">})) </span><span class="s3">break</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s1">def.value.properties.push(make_node(AST_ObjectKeyVal, node, {</span>
                    <span class="s1">key: prop,</span>
                    <span class="s1">value: node.right</span>
                <span class="s1">}));</span>
                <span class="s1">exprs.shift();</span>
                <span class="s1">trimmed = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s3">while </span><span class="s1">(exprs.length);</span>
            <span class="s3">return </span><span class="s1">trimmed &amp;&amp; exprs;</span>
        <span class="s1">}</span>

        <span class="s3">function </span><span class="s1">join_consecutive_vars(statements) {</span>
            <span class="s3">var </span><span class="s1">defs;</span>
            <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">, j = -</span><span class="s4">1</span><span class="s1">, len = statements.length; i &lt; len; i++) {</span>
                <span class="s3">var </span><span class="s1">stat = statements[i];</span>
                <span class="s3">var </span><span class="s1">prev = statements[j];</span>
                <span class="s3">if </span><span class="s1">(stat </span><span class="s3">instanceof </span><span class="s1">AST_Definitions) {</span>
                    <span class="s3">if </span><span class="s1">(prev &amp;&amp; prev.TYPE == stat.TYPE) {</span>
                        <span class="s1">prev.definitions = prev.definitions.concat(stat.definitions);</span>
                        <span class="s1">CHANGED = </span><span class="s3">true</span><span class="s1">;</span>
                    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(defs &amp;&amp; defs.TYPE == stat.TYPE &amp;&amp; declarations_only(stat)) {</span>
                        <span class="s1">defs.definitions = defs.definitions.concat(stat.definitions);</span>
                        <span class="s1">CHANGED = </span><span class="s3">true</span><span class="s1">;</span>
                    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                        <span class="s1">statements[++j] = stat;</span>
                        <span class="s1">defs = stat;</span>
                    <span class="s1">}</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(stat </span><span class="s3">instanceof </span><span class="s1">AST_Exit) {</span>
                    <span class="s1">stat.value = extract_object_assignments(stat.value);</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(stat </span><span class="s3">instanceof </span><span class="s1">AST_For) {</span>
                    <span class="s3">var </span><span class="s1">exprs = join_object_assignments(prev, stat.init);</span>
                    <span class="s3">if </span><span class="s1">(exprs) {</span>
                        <span class="s1">CHANGED = </span><span class="s3">true</span><span class="s1">;</span>
                        <span class="s1">stat.init = exprs.length ? make_sequence(stat.init, exprs) : </span><span class="s3">null</span><span class="s1">;</span>
                        <span class="s1">statements[++j] = stat;</span>
                    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(prev </span><span class="s3">instanceof </span><span class="s1">AST_Var &amp;&amp; (!stat.init || stat.init.TYPE == prev.TYPE)) {</span>
                        <span class="s3">if </span><span class="s1">(stat.init) {</span>
                            <span class="s1">prev.definitions = prev.definitions.concat(stat.init.definitions);</span>
                        <span class="s1">}</span>
                        <span class="s1">stat.init = prev;</span>
                        <span class="s1">statements[j] = stat;</span>
                        <span class="s1">CHANGED = </span><span class="s3">true</span><span class="s1">;</span>
                    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(defs &amp;&amp; stat.init &amp;&amp; defs.TYPE == stat.init.TYPE &amp;&amp; declarations_only(stat.init)) {</span>
                        <span class="s1">defs.definitions = defs.definitions.concat(stat.init.definitions);</span>
                        <span class="s1">stat.init = </span><span class="s3">null</span><span class="s1">;</span>
                        <span class="s1">statements[++j] = stat;</span>
                        <span class="s1">CHANGED = </span><span class="s3">true</span><span class="s1">;</span>
                    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                        <span class="s1">statements[++j] = stat;</span>
                    <span class="s1">}</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(stat </span><span class="s3">instanceof </span><span class="s1">AST_ForIn) {</span>
                    <span class="s1">stat.object = extract_object_assignments(stat.object);</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(stat </span><span class="s3">instanceof </span><span class="s1">AST_If) {</span>
                    <span class="s1">stat.condition = extract_object_assignments(stat.condition);</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(stat </span><span class="s3">instanceof </span><span class="s1">AST_SimpleStatement) {</span>
                    <span class="s3">var </span><span class="s1">exprs = join_object_assignments(prev, stat.body);</span>
                    <span class="s3">if </span><span class="s1">(exprs) {</span>
                        <span class="s1">CHANGED = </span><span class="s3">true</span><span class="s1">;</span>
                        <span class="s3">if </span><span class="s1">(!exprs.length) </span><span class="s3">continue</span><span class="s1">;</span>
                        <span class="s1">stat.body = make_sequence(stat.body, exprs);</span>
                    <span class="s1">}</span>
                    <span class="s1">statements[++j] = stat;</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(stat </span><span class="s3">instanceof </span><span class="s1">AST_Switch) {</span>
                    <span class="s1">stat.expression = extract_object_assignments(stat.expression);</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(stat </span><span class="s3">instanceof </span><span class="s1">AST_With) {</span>
                    <span class="s1">stat.expression = extract_object_assignments(stat.expression);</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s1">statements[++j] = stat;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">statements.length = j + </span><span class="s4">1</span><span class="s1">;</span>

            <span class="s3">function </span><span class="s1">extract_object_assignments(value) {</span>
                <span class="s1">statements[++j] = stat;</span>
                <span class="s3">var </span><span class="s1">exprs = join_object_assignments(prev, value);</span>
                <span class="s3">if </span><span class="s1">(exprs) {</span>
                    <span class="s1">CHANGED = </span><span class="s3">true</span><span class="s1">;</span>
                    <span class="s3">if </span><span class="s1">(exprs.length) {</span>
                        <span class="s3">return </span><span class="s1">make_sequence(value, exprs);</span>
                    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(value </span><span class="s3">instanceof </span><span class="s1">AST_Sequence) {</span>
                        <span class="s3">return </span><span class="s1">value.tail_node().left;</span>
                    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                        <span class="s3">return </span><span class="s1">value.left;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s3">return </span><span class="s1">value;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">function </span><span class="s1">extract_declarations_from_unreachable_code(compressor, stat, target) {</span>
        <span class="s3">if </span><span class="s1">(!(stat </span><span class="s3">instanceof </span><span class="s1">AST_Defun)) {</span>
            <span class="s1">compressor.warn(</span><span class="s2">&quot;Dropping unreachable code [{file}:{line},{col}]&quot;</span><span class="s1">, stat.start);</span>
        <span class="s1">}</span>
        <span class="s1">stat.walk(</span><span class="s3">new </span><span class="s1">TreeWalker(</span><span class="s3">function</span><span class="s1">(node){</span>
            <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Var) {</span>
                <span class="s1">compressor.warn(</span><span class="s2">&quot;Declarations in unreachable code! [{file}:{line},{col}]&quot;</span><span class="s1">, node.start);</span>
                <span class="s1">node.remove_initializers();</span>
                <span class="s1">target.push(node);</span>
                <span class="s3">return true</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Defun &amp;&amp; (node === stat || !compressor.has_directive(</span><span class="s2">&quot;use strict&quot;</span><span class="s1">))) {</span>
                <span class="s1">target.push(node === stat ? node : make_node(AST_Var, node, {</span>
                    <span class="s1">definitions: [</span>
                        <span class="s1">make_node(AST_VarDef, node, {</span>
                            <span class="s1">name: make_node(AST_SymbolVar, node.name, node.name),</span>
                            <span class="s1">value: </span><span class="s3">null</span>
                        <span class="s1">})</span>
                    <span class="s1">]</span>
                <span class="s1">}));</span>
                <span class="s3">return true</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Scope) {</span>
                <span class="s3">return true</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}));</span>
    <span class="s1">};</span>

    <span class="s3">function </span><span class="s1">get_value(key) {</span>
        <span class="s3">if </span><span class="s1">(key </span><span class="s3">instanceof </span><span class="s1">AST_Constant) {</span>
            <span class="s3">return </span><span class="s1">key.getValue();</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(key </span><span class="s3">instanceof </span><span class="s1">AST_UnaryPrefix</span>
            <span class="s1">&amp;&amp; key.operator == </span><span class="s2">&quot;void&quot;</span>
            <span class="s1">&amp;&amp; key.expression </span><span class="s3">instanceof </span><span class="s1">AST_Constant) {</span>
            <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">key;</span>
    <span class="s1">}</span>

    <span class="s3">function </span><span class="s1">is_undefined(node, compressor) {</span>
        <span class="s3">return </span><span class="s1">node.is_undefined</span>
            <span class="s1">|| node </span><span class="s3">instanceof </span><span class="s1">AST_Undefined</span>
            <span class="s1">|| node </span><span class="s3">instanceof </span><span class="s1">AST_UnaryPrefix</span>
                <span class="s1">&amp;&amp; node.operator == </span><span class="s2">&quot;void&quot;</span>
                <span class="s1">&amp;&amp; !node.expression.has_side_effects(compressor);</span>
    <span class="s1">}</span>

    <span class="s0">// may_throw_on_access()</span>
    <span class="s0">// returns true if this node may be null, undefined or contain `AST_Accessor`</span>
    <span class="s1">(</span><span class="s3">function</span><span class="s1">(def) {</span>
        <span class="s1">AST_Node.DEFMETHOD(</span><span class="s2">&quot;may_throw_on_access&quot;</span><span class="s1">, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
            <span class="s3">return </span><span class="s1">!compressor.option(</span><span class="s2">&quot;pure_getters&quot;</span><span class="s1">)</span>
                <span class="s1">|| </span><span class="s3">this</span><span class="s1">._dot_throw(compressor);</span>
        <span class="s1">});</span>

        <span class="s3">function </span><span class="s1">is_strict(compressor) {</span>
            <span class="s3">return </span><span class="s1">/strict/.test(compressor.option(</span><span class="s2">&quot;pure_getters&quot;</span><span class="s1">));</span>
        <span class="s1">}</span>

        <span class="s1">def(AST_Node, is_strict);</span>
        <span class="s1">def(AST_Null, return_true);</span>
        <span class="s1">def(AST_Undefined, return_true);</span>
        <span class="s1">def(AST_Constant, return_false);</span>
        <span class="s1">def(AST_Array, return_false);</span>
        <span class="s1">def(AST_Object, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
            <span class="s3">if </span><span class="s1">(!is_strict(compressor)) </span><span class="s3">return false</span><span class="s1">;</span>
            <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s3">this</span><span class="s1">.properties.length; --i &gt;=</span><span class="s4">0</span><span class="s1">;)</span>
                <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.properties[i]._dot_throw(compressor)) </span><span class="s3">return true</span><span class="s1">;</span>
            <span class="s3">return false</span><span class="s1">;</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_ObjectProperty, return_false);</span>
        <span class="s1">def(AST_ObjectGetter, return_true);</span>
        <span class="s1">def(AST_Expansion, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
            <span class="s3">return this</span><span class="s1">.expression._dot_throw(compressor);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Function, return_false);</span>
        <span class="s1">def(AST_Arrow, return_false);</span>
        <span class="s1">def(AST_UnaryPostfix, return_false);</span>
        <span class="s1">def(AST_UnaryPrefix, </span><span class="s3">function</span><span class="s1">() {</span>
            <span class="s3">return this</span><span class="s1">.operator == </span><span class="s2">&quot;void&quot;</span><span class="s1">;</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Binary, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
            <span class="s3">return </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.operator == </span><span class="s2">&quot;&amp;&amp;&quot; </span><span class="s1">|| </span><span class="s3">this</span><span class="s1">.operator == </span><span class="s2">&quot;||&quot;</span><span class="s1">)</span>
                <span class="s1">&amp;&amp; (</span><span class="s3">this</span><span class="s1">.left._dot_throw(compressor) || </span><span class="s3">this</span><span class="s1">.right._dot_throw(compressor));</span>
        <span class="s1">})</span>
        <span class="s1">def(AST_Assign, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
            <span class="s3">return this</span><span class="s1">.operator == </span><span class="s2">&quot;=&quot;</span>
                <span class="s1">&amp;&amp; </span><span class="s3">this</span><span class="s1">.right._dot_throw(compressor);</span>
        <span class="s1">})</span>
        <span class="s1">def(AST_Conditional, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
            <span class="s3">return this</span><span class="s1">.consequent._dot_throw(compressor)</span>
                <span class="s1">|| </span><span class="s3">this</span><span class="s1">.alternative._dot_throw(compressor);</span>
        <span class="s1">})</span>
        <span class="s1">def(AST_Dot, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
            <span class="s3">if </span><span class="s1">(!is_strict(compressor)) </span><span class="s3">return false</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.expression </span><span class="s3">instanceof </span><span class="s1">AST_Function &amp;&amp; </span><span class="s3">this</span><span class="s1">.property == </span><span class="s2">&quot;prototype&quot;</span><span class="s1">) </span><span class="s3">return false</span><span class="s1">;</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Sequence, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
            <span class="s3">return this</span><span class="s1">.tail_node()._dot_throw(compressor);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_SymbolRef, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.is_undefined) </span><span class="s3">return true</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(!is_strict(compressor)) </span><span class="s3">return false</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(is_undeclared_ref(</span><span class="s3">this</span><span class="s1">) &amp;&amp; </span><span class="s3">this</span><span class="s1">.is_declared(compressor)) </span><span class="s3">return false</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.is_immutable()) </span><span class="s3">return false</span><span class="s1">;</span>
            <span class="s3">var </span><span class="s1">fixed = </span><span class="s3">this</span><span class="s1">.fixed_value();</span>
            <span class="s3">return </span><span class="s1">!fixed || fixed._dot_throw(compressor);</span>
        <span class="s1">});</span>
    <span class="s1">})(</span><span class="s3">function</span><span class="s1">(node, func) {</span>
        <span class="s1">node.DEFMETHOD(</span><span class="s2">&quot;_dot_throw&quot;</span><span class="s1">, func);</span>
    <span class="s1">});</span>

    <span class="s0">/* -----[ boolean/negation helpers ]----- */</span>

    <span class="s0">// methods to determine whether an expression has a boolean result type</span>
    <span class="s1">(</span><span class="s3">function</span><span class="s1">(def){</span>
        <span class="s3">var </span><span class="s1">unary_bool = [ </span><span class="s2">&quot;!&quot;</span><span class="s1">, </span><span class="s2">&quot;delete&quot; </span><span class="s1">];</span>
        <span class="s3">var </span><span class="s1">binary_bool = [ </span><span class="s2">&quot;in&quot;</span><span class="s1">, </span><span class="s2">&quot;instanceof&quot;</span><span class="s1">, </span><span class="s2">&quot;==&quot;</span><span class="s1">, </span><span class="s2">&quot;!=&quot;</span><span class="s1">, </span><span class="s2">&quot;===&quot;</span><span class="s1">, </span><span class="s2">&quot;!==&quot;</span><span class="s1">, </span><span class="s2">&quot;&lt;&quot;</span><span class="s1">, </span><span class="s2">&quot;&lt;=&quot;</span><span class="s1">, </span><span class="s2">&quot;&gt;=&quot;</span><span class="s1">, </span><span class="s2">&quot;&gt;&quot; </span><span class="s1">];</span>
        <span class="s1">def(AST_Node, return_false);</span>
        <span class="s1">def(AST_UnaryPrefix, </span><span class="s3">function</span><span class="s1">(){</span>
            <span class="s3">return </span><span class="s1">member(</span><span class="s3">this</span><span class="s1">.operator, unary_bool);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Binary, </span><span class="s3">function</span><span class="s1">(){</span>
            <span class="s3">return </span><span class="s1">member(</span><span class="s3">this</span><span class="s1">.operator, binary_bool)</span>
                <span class="s1">|| lazy_op(</span><span class="s3">this</span><span class="s1">.operator)</span>
                    <span class="s1">&amp;&amp; </span><span class="s3">this</span><span class="s1">.left.is_boolean()</span>
                    <span class="s1">&amp;&amp; </span><span class="s3">this</span><span class="s1">.right.is_boolean();</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Conditional, </span><span class="s3">function</span><span class="s1">(){</span>
            <span class="s3">return this</span><span class="s1">.consequent.is_boolean() &amp;&amp; </span><span class="s3">this</span><span class="s1">.alternative.is_boolean();</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Assign, </span><span class="s3">function</span><span class="s1">(){</span>
            <span class="s3">return this</span><span class="s1">.operator == </span><span class="s2">&quot;=&quot; </span><span class="s1">&amp;&amp; </span><span class="s3">this</span><span class="s1">.right.is_boolean();</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Sequence, </span><span class="s3">function</span><span class="s1">(){</span>
            <span class="s3">return this</span><span class="s1">.tail_node().is_boolean();</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_True, return_true);</span>
        <span class="s1">def(AST_False, return_true);</span>
    <span class="s1">})(</span><span class="s3">function</span><span class="s1">(node, func){</span>
        <span class="s1">node.DEFMETHOD(</span><span class="s2">&quot;is_boolean&quot;</span><span class="s1">, func);</span>
    <span class="s1">});</span>

    <span class="s0">// methods to determine if an expression has a numeric result type</span>
    <span class="s1">(</span><span class="s3">function</span><span class="s1">(def){</span>
        <span class="s1">def(AST_Node, return_false);</span>
        <span class="s1">def(AST_Number, return_true);</span>
        <span class="s3">var </span><span class="s1">unary = makePredicate(</span><span class="s2">&quot;+ - ~ ++ --&quot;</span><span class="s1">);</span>
        <span class="s1">def(AST_Unary, </span><span class="s3">function</span><span class="s1">(){</span>
            <span class="s3">return </span><span class="s1">unary(</span><span class="s3">this</span><span class="s1">.operator);</span>
        <span class="s1">});</span>
        <span class="s3">var </span><span class="s1">binary = makePredicate(</span><span class="s2">&quot;- * / % &amp; | ^ &lt;&lt; &gt;&gt; &gt;&gt;&gt;&quot;</span><span class="s1">);</span>
        <span class="s1">def(AST_Binary, </span><span class="s3">function</span><span class="s1">(compressor){</span>
            <span class="s3">return </span><span class="s1">binary(</span><span class="s3">this</span><span class="s1">.operator) || </span><span class="s3">this</span><span class="s1">.operator == </span><span class="s2">&quot;+&quot;</span>
                <span class="s1">&amp;&amp; </span><span class="s3">this</span><span class="s1">.left.is_number(compressor)</span>
                <span class="s1">&amp;&amp; </span><span class="s3">this</span><span class="s1">.right.is_number(compressor);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Assign, </span><span class="s3">function</span><span class="s1">(compressor){</span>
            <span class="s3">return </span><span class="s1">binary(</span><span class="s3">this</span><span class="s1">.operator.slice(</span><span class="s4">0</span><span class="s1">, -</span><span class="s4">1</span><span class="s1">))</span>
                <span class="s1">|| </span><span class="s3">this</span><span class="s1">.operator == </span><span class="s2">&quot;=&quot; </span><span class="s1">&amp;&amp; </span><span class="s3">this</span><span class="s1">.right.is_number(compressor);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Sequence, </span><span class="s3">function</span><span class="s1">(compressor){</span>
            <span class="s3">return this</span><span class="s1">.tail_node().is_number(compressor);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Conditional, </span><span class="s3">function</span><span class="s1">(compressor){</span>
            <span class="s3">return this</span><span class="s1">.consequent.is_number(compressor) &amp;&amp; </span><span class="s3">this</span><span class="s1">.alternative.is_number(compressor);</span>
        <span class="s1">});</span>
    <span class="s1">})(</span><span class="s3">function</span><span class="s1">(node, func){</span>
        <span class="s1">node.DEFMETHOD(</span><span class="s2">&quot;is_number&quot;</span><span class="s1">, func);</span>
    <span class="s1">});</span>

    <span class="s0">// methods to determine if an expression has a string result type</span>
    <span class="s1">(</span><span class="s3">function</span><span class="s1">(def){</span>
        <span class="s1">def(AST_Node, return_false);</span>
        <span class="s1">def(AST_String, return_true);</span>
        <span class="s1">def(AST_TemplateString, </span><span class="s3">function</span><span class="s1">(){</span>
            <span class="s3">return this</span><span class="s1">.segments.length === </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_UnaryPrefix, </span><span class="s3">function</span><span class="s1">(){</span>
            <span class="s3">return this</span><span class="s1">.operator == </span><span class="s2">&quot;typeof&quot;</span><span class="s1">;</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Binary, </span><span class="s3">function</span><span class="s1">(compressor){</span>
            <span class="s3">return this</span><span class="s1">.operator == </span><span class="s2">&quot;+&quot; </span><span class="s1">&amp;&amp;</span>
                <span class="s1">(</span><span class="s3">this</span><span class="s1">.left.is_string(compressor) || </span><span class="s3">this</span><span class="s1">.right.is_string(compressor));</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Assign, </span><span class="s3">function</span><span class="s1">(compressor){</span>
            <span class="s3">return </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.operator == </span><span class="s2">&quot;=&quot; </span><span class="s1">|| </span><span class="s3">this</span><span class="s1">.operator == </span><span class="s2">&quot;+=&quot;</span><span class="s1">) &amp;&amp; </span><span class="s3">this</span><span class="s1">.right.is_string(compressor);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Sequence, </span><span class="s3">function</span><span class="s1">(compressor){</span>
            <span class="s3">return this</span><span class="s1">.tail_node().is_string(compressor);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Conditional, </span><span class="s3">function</span><span class="s1">(compressor){</span>
            <span class="s3">return this</span><span class="s1">.consequent.is_string(compressor) &amp;&amp; </span><span class="s3">this</span><span class="s1">.alternative.is_string(compressor);</span>
        <span class="s1">});</span>
    <span class="s1">})(</span><span class="s3">function</span><span class="s1">(node, func){</span>
        <span class="s1">node.DEFMETHOD(</span><span class="s2">&quot;is_string&quot;</span><span class="s1">, func);</span>
    <span class="s1">});</span>

    <span class="s3">var </span><span class="s1">lazy_op = makePredicate(</span><span class="s2">&quot;&amp;&amp; ||&quot;</span><span class="s1">);</span>
    <span class="s3">var </span><span class="s1">unary_side_effects = makePredicate(</span><span class="s2">&quot;delete ++ --&quot;</span><span class="s1">);</span>

    <span class="s3">function </span><span class="s1">is_lhs(node, parent) {</span>
        <span class="s3">if </span><span class="s1">(parent </span><span class="s3">instanceof </span><span class="s1">AST_Unary &amp;&amp; unary_side_effects(parent.operator)) </span><span class="s3">return </span><span class="s1">parent.expression;</span>
        <span class="s3">if </span><span class="s1">(parent </span><span class="s3">instanceof </span><span class="s1">AST_Assign &amp;&amp; parent.left === node) </span><span class="s3">return </span><span class="s1">node;</span>
    <span class="s1">}</span>

    <span class="s1">(</span><span class="s3">function</span><span class="s1">(def){</span>
        <span class="s1">AST_Node.DEFMETHOD(</span><span class="s2">&quot;resolve_defines&quot;</span><span class="s1">, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
            <span class="s3">if </span><span class="s1">(!compressor.option(</span><span class="s2">&quot;global_defs&quot;</span><span class="s1">)) </span><span class="s3">return</span><span class="s1">;</span>
            <span class="s3">var </span><span class="s1">def = </span><span class="s3">this</span><span class="s1">._find_defs(compressor, </span><span class="s2">&quot;&quot;</span><span class="s1">);</span>
            <span class="s3">if </span><span class="s1">(def) {</span>
                <span class="s3">var </span><span class="s1">node, parent = </span><span class="s3">this</span><span class="s1">, level = </span><span class="s4">0</span><span class="s1">;</span>
                <span class="s3">do </span><span class="s1">{</span>
                    <span class="s1">node = parent;</span>
                    <span class="s1">parent = compressor.parent(level++);</span>
                <span class="s1">} </span><span class="s3">while </span><span class="s1">(parent </span><span class="s3">instanceof </span><span class="s1">AST_PropAccess &amp;&amp; parent.expression === node);</span>
                <span class="s3">if </span><span class="s1">(is_lhs(node, parent)) {</span>
                    <span class="s1">compressor.warn(</span><span class="s2">'global_defs ' </span><span class="s1">+ </span><span class="s3">this</span><span class="s1">.print_to_string() + </span><span class="s2">' redefined [{file}:{line},{col}]'</span><span class="s1">, </span><span class="s3">this</span><span class="s1">.start);</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s3">return </span><span class="s1">def;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
        <span class="s3">function </span><span class="s1">to_node(value, orig) {</span>
            <span class="s3">if </span><span class="s1">(value </span><span class="s3">instanceof </span><span class="s1">AST_Node) </span><span class="s3">return </span><span class="s1">make_node(value.CTOR, orig, value);</span>
            <span class="s3">if </span><span class="s1">(Array.isArray(value)) </span><span class="s3">return </span><span class="s1">make_node(AST_Array, orig, {</span>
                <span class="s1">elements: value.map(</span><span class="s3">function</span><span class="s1">(value) {</span>
                    <span class="s3">return </span><span class="s1">to_node(value, orig);</span>
                <span class="s1">})</span>
            <span class="s1">});</span>
            <span class="s3">if </span><span class="s1">(value &amp;&amp; </span><span class="s3">typeof </span><span class="s1">value == </span><span class="s2">&quot;object&quot;</span><span class="s1">) {</span>
                <span class="s3">var </span><span class="s1">props = [];</span>
                <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">key </span><span class="s3">in </span><span class="s1">value) </span><span class="s3">if </span><span class="s1">(HOP(value, key)) {</span>
                    <span class="s1">props.push(make_node(AST_ObjectKeyVal, orig, {</span>
                        <span class="s1">key: key,</span>
                        <span class="s1">value: to_node(value[key], orig)</span>
                    <span class="s1">}));</span>
                <span class="s1">}</span>
                <span class="s3">return </span><span class="s1">make_node(AST_Object, orig, {</span>
                    <span class="s1">properties: props</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s3">return </span><span class="s1">make_node_from_constant(value, orig);</span>
        <span class="s1">}</span>
        <span class="s1">def(AST_Node, noop);</span>
        <span class="s1">def(AST_Dot, </span><span class="s3">function</span><span class="s1">(compressor, suffix){</span>
            <span class="s3">return this</span><span class="s1">.expression._find_defs(compressor, </span><span class="s2">&quot;.&quot; </span><span class="s1">+ </span><span class="s3">this</span><span class="s1">.property + suffix);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_SymbolRef, </span><span class="s3">function</span><span class="s1">(compressor, suffix){</span>
            <span class="s3">if </span><span class="s1">(!</span><span class="s3">this</span><span class="s1">.global()) </span><span class="s3">return</span><span class="s1">;</span>
            <span class="s3">var </span><span class="s1">name;</span>
            <span class="s3">var </span><span class="s1">defines = compressor.option(</span><span class="s2">&quot;global_defs&quot;</span><span class="s1">);</span>
            <span class="s3">if </span><span class="s1">(defines &amp;&amp; HOP(defines, (name = </span><span class="s3">this</span><span class="s1">.name + suffix))) {</span>
                <span class="s3">var </span><span class="s1">node = to_node(defines[name], </span><span class="s3">this</span><span class="s1">);</span>
                <span class="s3">var </span><span class="s1">top = compressor.find_parent(AST_Toplevel);</span>
                <span class="s1">node.walk(</span><span class="s3">new </span><span class="s1">TreeWalker(</span><span class="s3">function</span><span class="s1">(node) {</span>
                    <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef) {</span>
                        <span class="s1">node.scope = top;</span>
                        <span class="s1">node.thedef = top.def_global(node);</span>
                    <span class="s1">}</span>
                <span class="s1">}));</span>
                <span class="s3">return </span><span class="s1">node;</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
    <span class="s1">})(</span><span class="s3">function</span><span class="s1">(node, func){</span>
        <span class="s1">node.DEFMETHOD(</span><span class="s2">&quot;_find_defs&quot;</span><span class="s1">, func);</span>
    <span class="s1">});</span>

    <span class="s3">function </span><span class="s1">best_of_expression(ast1, ast2) {</span>
        <span class="s3">return </span><span class="s1">ast1.print_to_string().length &gt;</span>
            <span class="s1">ast2.print_to_string().length</span>
            <span class="s1">? ast2 : ast1;</span>
    <span class="s1">}</span>

    <span class="s3">function </span><span class="s1">best_of_statement(ast1, ast2) {</span>
        <span class="s3">return </span><span class="s1">best_of_expression(make_node(AST_SimpleStatement, ast1, {</span>
            <span class="s1">body: ast1</span>
        <span class="s1">}), make_node(AST_SimpleStatement, ast2, {</span>
            <span class="s1">body: ast2</span>
        <span class="s1">})).body;</span>
    <span class="s1">}</span>

    <span class="s3">function </span><span class="s1">best_of(compressor, ast1, ast2) {</span>
        <span class="s3">return </span><span class="s1">(first_in_statement(compressor) ? best_of_statement : best_of_expression)(ast1, ast2);</span>
    <span class="s1">}</span>

    <span class="s3">function </span><span class="s1">convert_to_predicate(obj) {</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">key </span><span class="s3">in </span><span class="s1">obj) {</span>
            <span class="s1">obj[key] = makePredicate(obj[key]);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">object_fns = [</span>
        <span class="s2">&quot;constructor&quot;</span><span class="s1">,</span>
        <span class="s2">&quot;toString&quot;</span><span class="s1">,</span>
        <span class="s2">&quot;valueOf&quot;</span><span class="s1">,</span>
    <span class="s1">];</span>
    <span class="s3">var </span><span class="s1">native_fns = {</span>
        <span class="s1">Array: [</span>
            <span class="s2">&quot;indexOf&quot;</span><span class="s1">,</span>
            <span class="s2">&quot;join&quot;</span><span class="s1">,</span>
            <span class="s2">&quot;lastIndexOf&quot;</span><span class="s1">,</span>
            <span class="s2">&quot;slice&quot;</span><span class="s1">,</span>
        <span class="s1">].concat(object_fns),</span>
        <span class="s1">Boolean: object_fns,</span>
        <span class="s1">Number: [</span>
            <span class="s2">&quot;toExponential&quot;</span><span class="s1">,</span>
            <span class="s2">&quot;toFixed&quot;</span><span class="s1">,</span>
            <span class="s2">&quot;toPrecision&quot;</span><span class="s1">,</span>
        <span class="s1">].concat(object_fns),</span>
        <span class="s1">Object: object_fns,</span>
        <span class="s1">RegExp: [</span>
            <span class="s2">&quot;test&quot;</span><span class="s1">,</span>
        <span class="s1">].concat(object_fns),</span>
        <span class="s1">String: [</span>
            <span class="s2">&quot;charAt&quot;</span><span class="s1">,</span>
            <span class="s2">&quot;charCodeAt&quot;</span><span class="s1">,</span>
            <span class="s2">&quot;concat&quot;</span><span class="s1">,</span>
            <span class="s2">&quot;indexOf&quot;</span><span class="s1">,</span>
            <span class="s2">&quot;italics&quot;</span><span class="s1">,</span>
            <span class="s2">&quot;lastIndexOf&quot;</span><span class="s1">,</span>
            <span class="s2">&quot;match&quot;</span><span class="s1">,</span>
            <span class="s2">&quot;replace&quot;</span><span class="s1">,</span>
            <span class="s2">&quot;search&quot;</span><span class="s1">,</span>
            <span class="s2">&quot;slice&quot;</span><span class="s1">,</span>
            <span class="s2">&quot;split&quot;</span><span class="s1">,</span>
            <span class="s2">&quot;substr&quot;</span><span class="s1">,</span>
            <span class="s2">&quot;substring&quot;</span><span class="s1">,</span>
            <span class="s2">&quot;trim&quot;</span><span class="s1">,</span>
        <span class="s1">].concat(object_fns),</span>
    <span class="s1">};</span>
    <span class="s1">convert_to_predicate(native_fns);</span>
    <span class="s3">var </span><span class="s1">static_fns = {</span>
        <span class="s1">Array: [</span>
            <span class="s2">&quot;isArray&quot;</span><span class="s1">,</span>
        <span class="s1">],</span>
        <span class="s1">Math: [</span>
            <span class="s2">&quot;abs&quot;</span><span class="s1">,</span>
            <span class="s2">&quot;acos&quot;</span><span class="s1">,</span>
            <span class="s2">&quot;asin&quot;</span><span class="s1">,</span>
            <span class="s2">&quot;atan&quot;</span><span class="s1">,</span>
            <span class="s2">&quot;ceil&quot;</span><span class="s1">,</span>
            <span class="s2">&quot;cos&quot;</span><span class="s1">,</span>
            <span class="s2">&quot;exp&quot;</span><span class="s1">,</span>
            <span class="s2">&quot;floor&quot;</span><span class="s1">,</span>
            <span class="s2">&quot;log&quot;</span><span class="s1">,</span>
            <span class="s2">&quot;round&quot;</span><span class="s1">,</span>
            <span class="s2">&quot;sin&quot;</span><span class="s1">,</span>
            <span class="s2">&quot;sqrt&quot;</span><span class="s1">,</span>
            <span class="s2">&quot;tan&quot;</span><span class="s1">,</span>
            <span class="s2">&quot;atan2&quot;</span><span class="s1">,</span>
            <span class="s2">&quot;pow&quot;</span><span class="s1">,</span>
            <span class="s2">&quot;max&quot;</span><span class="s1">,</span>
            <span class="s2">&quot;min&quot;</span><span class="s1">,</span>
        <span class="s1">],</span>
        <span class="s1">Number: [</span>
            <span class="s2">&quot;isFinite&quot;</span><span class="s1">,</span>
            <span class="s2">&quot;isNaN&quot;</span><span class="s1">,</span>
        <span class="s1">],</span>
        <span class="s1">Object: [</span>
            <span class="s2">&quot;create&quot;</span><span class="s1">,</span>
            <span class="s2">&quot;getOwnPropertyDescriptor&quot;</span><span class="s1">,</span>
            <span class="s2">&quot;getOwnPropertyNames&quot;</span><span class="s1">,</span>
            <span class="s2">&quot;getPrototypeOf&quot;</span><span class="s1">,</span>
            <span class="s2">&quot;isExtensible&quot;</span><span class="s1">,</span>
            <span class="s2">&quot;isFrozen&quot;</span><span class="s1">,</span>
            <span class="s2">&quot;isSealed&quot;</span><span class="s1">,</span>
            <span class="s2">&quot;keys&quot;</span><span class="s1">,</span>
        <span class="s1">],</span>
        <span class="s1">String: [</span>
            <span class="s2">&quot;fromCharCode&quot;</span><span class="s1">,</span>
        <span class="s1">],</span>
    <span class="s1">};</span>
    <span class="s1">convert_to_predicate(static_fns);</span>

    <span class="s0">// methods to evaluate a constant expression</span>
    <span class="s1">(</span><span class="s3">function</span><span class="s1">(def){</span>
        <span class="s0">// If the node has been successfully reduced to a constant,</span>
        <span class="s0">// then its value is returned; otherwise the element itself</span>
        <span class="s0">// is returned.</span>
        <span class="s0">// They can be distinguished as constant value is never a</span>
        <span class="s0">// descendant of AST_Node.</span>
        <span class="s1">AST_Node.DEFMETHOD(</span><span class="s2">&quot;evaluate&quot;</span><span class="s1">, </span><span class="s3">function</span><span class="s1">(compressor){</span>
            <span class="s3">if </span><span class="s1">(!compressor.option(</span><span class="s2">&quot;evaluate&quot;</span><span class="s1">)) </span><span class="s3">return this</span><span class="s1">;</span>
            <span class="s3">var </span><span class="s1">val = </span><span class="s3">this</span><span class="s1">._eval(compressor, </span><span class="s4">1</span><span class="s1">);</span>
            <span class="s3">return </span><span class="s1">!val || val </span><span class="s3">instanceof </span><span class="s1">RegExp || </span><span class="s3">typeof </span><span class="s1">val != </span><span class="s2">&quot;object&quot; </span><span class="s1">? val : </span><span class="s3">this</span><span class="s1">;</span>
        <span class="s1">});</span>
        <span class="s3">var </span><span class="s1">unaryPrefix = makePredicate(</span><span class="s2">&quot;! ~ - + void&quot;</span><span class="s1">);</span>
        <span class="s1">AST_Node.DEFMETHOD(</span><span class="s2">&quot;is_constant&quot;</span><span class="s1">, </span><span class="s3">function</span><span class="s1">(){</span>
            <span class="s0">// Accomodate when compress option evaluate=false</span>
            <span class="s0">// as well as the common constant expressions !0 and -1</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">this instanceof </span><span class="s1">AST_Constant) {</span>
                <span class="s3">return </span><span class="s1">!(</span><span class="s3">this instanceof </span><span class="s1">AST_RegExp);</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s3">return this instanceof </span><span class="s1">AST_UnaryPrefix</span>
                    <span class="s1">&amp;&amp; </span><span class="s3">this</span><span class="s1">.expression </span><span class="s3">instanceof </span><span class="s1">AST_Constant</span>
                    <span class="s1">&amp;&amp; unaryPrefix(</span><span class="s3">this</span><span class="s1">.operator);</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Statement, </span><span class="s3">function</span><span class="s1">(){</span>
            <span class="s3">throw new </span><span class="s1">Error(string_template(</span><span class="s2">&quot;Cannot evaluate a statement [{file}:{line},{col}]&quot;</span><span class="s1">, </span><span class="s3">this</span><span class="s1">.start));</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Lambda, return_this);</span>
        <span class="s1">def(AST_Class, return_this);</span>
        <span class="s1">def(AST_Node, return_this);</span>
        <span class="s1">def(AST_Constant, </span><span class="s3">function</span><span class="s1">(){</span>
            <span class="s3">return this</span><span class="s1">.getValue();</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_TemplateString, </span><span class="s3">function</span><span class="s1">() {</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.segments.length !== </span><span class="s4">1</span><span class="s1">) </span><span class="s3">return this</span><span class="s1">;</span>
            <span class="s3">return this</span><span class="s1">.segments[</span><span class="s4">0</span><span class="s1">].value;</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Array, </span><span class="s3">function</span><span class="s1">(compressor, depth) {</span>
            <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;unsafe&quot;</span><span class="s1">)) {</span>
                <span class="s3">var </span><span class="s1">elements = [];</span>
                <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">, len = </span><span class="s3">this</span><span class="s1">.elements.length; i &lt; len; i++) {</span>
                    <span class="s3">var </span><span class="s1">element = </span><span class="s3">this</span><span class="s1">.elements[i];</span>
                    <span class="s3">if </span><span class="s1">(element </span><span class="s3">instanceof </span><span class="s1">AST_Function) {</span>
                        <span class="s1">elements.push(element);</span>
                        <span class="s3">continue</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s3">var </span><span class="s1">value = element._eval(compressor, depth);</span>
                    <span class="s3">if </span><span class="s1">(element === value) </span><span class="s3">return this</span><span class="s1">;</span>
                    <span class="s1">elements.push(value);</span>
                <span class="s1">}</span>
                <span class="s3">return </span><span class="s1">elements;</span>
            <span class="s1">}</span>
            <span class="s3">return this</span><span class="s1">;</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Object, </span><span class="s3">function</span><span class="s1">(compressor, depth) {</span>
            <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;unsafe&quot;</span><span class="s1">)) {</span>
                <span class="s3">var </span><span class="s1">val = {};</span>
                <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">, len = </span><span class="s3">this</span><span class="s1">.properties.length; i &lt; len; i++) {</span>
                    <span class="s3">var </span><span class="s1">prop = </span><span class="s3">this</span><span class="s1">.properties[i];</span>
                    <span class="s3">if </span><span class="s1">(prop </span><span class="s3">instanceof </span><span class="s1">AST_Expansion) </span><span class="s3">return this</span><span class="s1">;</span>
                    <span class="s3">var </span><span class="s1">key = prop.key;</span>
                    <span class="s3">if </span><span class="s1">(key </span><span class="s3">instanceof </span><span class="s1">AST_Symbol) {</span>
                        <span class="s1">key = key.name;</span>
                    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(key </span><span class="s3">instanceof </span><span class="s1">AST_Node) {</span>
                        <span class="s1">key = key._eval(compressor, depth);</span>
                        <span class="s3">if </span><span class="s1">(key === prop.key) </span><span class="s3">return this</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">Object.prototype[key] === </span><span class="s2">'function'</span><span class="s1">) {</span>
                        <span class="s3">return this</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s3">if </span><span class="s1">(prop.value </span><span class="s3">instanceof </span><span class="s1">AST_Function) </span><span class="s3">continue</span><span class="s1">;</span>
                    <span class="s1">val[key] = prop.value._eval(compressor, depth);</span>
                    <span class="s3">if </span><span class="s1">(val[key] === prop.value) </span><span class="s3">return this</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s3">return </span><span class="s1">val;</span>
            <span class="s1">}</span>
            <span class="s3">return this</span><span class="s1">;</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_UnaryPrefix, </span><span class="s3">function</span><span class="s1">(compressor, depth) {</span>
            <span class="s3">var </span><span class="s1">e = </span><span class="s3">this</span><span class="s1">.expression;</span>
            <span class="s0">// Function would be evaluated to an array and so typeof would</span>
            <span class="s0">// incorrectly return 'object'. Hence making is a special case.</span>
            <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;typeofs&quot;</span><span class="s1">)</span>
                <span class="s1">&amp;&amp; </span><span class="s3">this</span><span class="s1">.operator == </span><span class="s2">&quot;typeof&quot;</span>
                <span class="s1">&amp;&amp; (e </span><span class="s3">instanceof </span><span class="s1">AST_Lambda</span>
                    <span class="s1">|| e </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef</span>
                        <span class="s1">&amp;&amp; e.fixed_value() </span><span class="s3">instanceof </span><span class="s1">AST_Lambda)) {</span>
                <span class="s3">return typeof function</span><span class="s1">(){};</span>
            <span class="s1">}</span>
            <span class="s1">e = e._eval(compressor, depth);</span>
            <span class="s3">if </span><span class="s1">(e === </span><span class="s3">this</span><span class="s1">.expression) </span><span class="s3">return this</span><span class="s1">;</span>
            <span class="s3">switch </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.operator) {</span>
              <span class="s3">case </span><span class="s2">&quot;!&quot;</span><span class="s1">: </span><span class="s3">return </span><span class="s1">!e;</span>
              <span class="s3">case </span><span class="s2">&quot;typeof&quot;</span><span class="s1">:</span>
                <span class="s0">// typeof &lt;RegExp&gt; returns &quot;object&quot; or &quot;function&quot; on different platforms</span>
                <span class="s0">// so cannot evaluate reliably</span>
                <span class="s3">if </span><span class="s1">(e </span><span class="s3">instanceof </span><span class="s1">RegExp) </span><span class="s3">return this</span><span class="s1">;</span>
                <span class="s3">return typeof </span><span class="s1">e;</span>
              <span class="s3">case </span><span class="s2">&quot;void&quot;</span><span class="s1">: </span><span class="s3">return void </span><span class="s1">e;</span>
              <span class="s3">case </span><span class="s2">&quot;~&quot;</span><span class="s1">: </span><span class="s3">return </span><span class="s1">~e;</span>
              <span class="s3">case </span><span class="s2">&quot;-&quot;</span><span class="s1">: </span><span class="s3">return </span><span class="s1">-e;</span>
              <span class="s3">case </span><span class="s2">&quot;+&quot;</span><span class="s1">: </span><span class="s3">return </span><span class="s1">+e;</span>
            <span class="s1">}</span>
            <span class="s3">return this</span><span class="s1">;</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Binary, </span><span class="s3">function</span><span class="s1">(compressor, depth) {</span>
            <span class="s3">var </span><span class="s1">left = </span><span class="s3">this</span><span class="s1">.left._eval(compressor, depth);</span>
            <span class="s3">if </span><span class="s1">(left === </span><span class="s3">this</span><span class="s1">.left) </span><span class="s3">return this</span><span class="s1">;</span>
            <span class="s3">var </span><span class="s1">right = </span><span class="s3">this</span><span class="s1">.right._eval(compressor, depth);</span>
            <span class="s3">if </span><span class="s1">(right === </span><span class="s3">this</span><span class="s1">.right) </span><span class="s3">return this</span><span class="s1">;</span>
            <span class="s3">var </span><span class="s1">result;</span>
            <span class="s3">switch </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.operator) {</span>
              <span class="s3">case </span><span class="s2">&quot;&amp;&amp;&quot;  </span><span class="s1">: result = left &amp;&amp;  right; </span><span class="s3">break</span><span class="s1">;</span>
              <span class="s3">case </span><span class="s2">&quot;||&quot;  </span><span class="s1">: result = left ||  right; </span><span class="s3">break</span><span class="s1">;</span>
              <span class="s3">case </span><span class="s2">&quot;|&quot;   </span><span class="s1">: result = left |   right; </span><span class="s3">break</span><span class="s1">;</span>
              <span class="s3">case </span><span class="s2">&quot;&amp;&quot;   </span><span class="s1">: result = left &amp;   right; </span><span class="s3">break</span><span class="s1">;</span>
              <span class="s3">case </span><span class="s2">&quot;^&quot;   </span><span class="s1">: result = left ^   right; </span><span class="s3">break</span><span class="s1">;</span>
              <span class="s3">case </span><span class="s2">&quot;+&quot;   </span><span class="s1">: result = left +   right; </span><span class="s3">break</span><span class="s1">;</span>
              <span class="s3">case </span><span class="s2">&quot;*&quot;   </span><span class="s1">: result = left *   right; </span><span class="s3">break</span><span class="s1">;</span>
              <span class="s3">case </span><span class="s2">&quot;**&quot;  </span><span class="s1">: result = Math.pow(left, right); </span><span class="s3">break</span><span class="s1">;</span>
              <span class="s3">case </span><span class="s2">&quot;/&quot;   </span><span class="s1">: result = left /   right; </span><span class="s3">break</span><span class="s1">;</span>
              <span class="s3">case </span><span class="s2">&quot;%&quot;   </span><span class="s1">: result = left %   right; </span><span class="s3">break</span><span class="s1">;</span>
              <span class="s3">case </span><span class="s2">&quot;-&quot;   </span><span class="s1">: result = left -   right; </span><span class="s3">break</span><span class="s1">;</span>
              <span class="s3">case </span><span class="s2">&quot;&lt;&lt;&quot;  </span><span class="s1">: result = left &lt;&lt;  right; </span><span class="s3">break</span><span class="s1">;</span>
              <span class="s3">case </span><span class="s2">&quot;&gt;&gt;&quot;  </span><span class="s1">: result = left &gt;&gt;  right; </span><span class="s3">break</span><span class="s1">;</span>
              <span class="s3">case </span><span class="s2">&quot;&gt;&gt;&gt;&quot; </span><span class="s1">: result = left &gt;&gt;&gt; right; </span><span class="s3">break</span><span class="s1">;</span>
              <span class="s3">case </span><span class="s2">&quot;==&quot;  </span><span class="s1">: result = left ==  right; </span><span class="s3">break</span><span class="s1">;</span>
              <span class="s3">case </span><span class="s2">&quot;===&quot; </span><span class="s1">: result = left === right; </span><span class="s3">break</span><span class="s1">;</span>
              <span class="s3">case </span><span class="s2">&quot;!=&quot;  </span><span class="s1">: result = left !=  right; </span><span class="s3">break</span><span class="s1">;</span>
              <span class="s3">case </span><span class="s2">&quot;!==&quot; </span><span class="s1">: result = left !== right; </span><span class="s3">break</span><span class="s1">;</span>
              <span class="s3">case </span><span class="s2">&quot;&lt;&quot;   </span><span class="s1">: result = left &lt;   right; </span><span class="s3">break</span><span class="s1">;</span>
              <span class="s3">case </span><span class="s2">&quot;&lt;=&quot;  </span><span class="s1">: result = left &lt;=  right; </span><span class="s3">break</span><span class="s1">;</span>
              <span class="s3">case </span><span class="s2">&quot;&gt;&quot;   </span><span class="s1">: result = left &gt;   right; </span><span class="s3">break</span><span class="s1">;</span>
              <span class="s3">case </span><span class="s2">&quot;&gt;=&quot;  </span><span class="s1">: result = left &gt;=  right; </span><span class="s3">break</span><span class="s1">;</span>
              <span class="s3">default</span><span class="s1">:</span>
                  <span class="s3">return this</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(isNaN(result) &amp;&amp; compressor.find_parent(AST_With)) {</span>
                <span class="s0">// leave original expression as is</span>
                <span class="s3">return this</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">return </span><span class="s1">result;</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Conditional, </span><span class="s3">function</span><span class="s1">(compressor, depth) {</span>
            <span class="s3">var </span><span class="s1">condition = </span><span class="s3">this</span><span class="s1">.condition._eval(compressor, depth);</span>
            <span class="s3">if </span><span class="s1">(condition === </span><span class="s3">this</span><span class="s1">.condition) </span><span class="s3">return this</span><span class="s1">;</span>
            <span class="s3">var </span><span class="s1">node = condition ? </span><span class="s3">this</span><span class="s1">.consequent : </span><span class="s3">this</span><span class="s1">.alternative;</span>
            <span class="s3">var </span><span class="s1">value = node._eval(compressor, depth);</span>
            <span class="s3">return </span><span class="s1">value === node ? </span><span class="s3">this </span><span class="s1">: value;</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_SymbolRef, </span><span class="s3">function</span><span class="s1">(compressor, depth) {</span>
            <span class="s3">var </span><span class="s1">fixed = </span><span class="s3">this</span><span class="s1">.fixed_value();</span>
            <span class="s3">if </span><span class="s1">(!fixed) </span><span class="s3">return this</span><span class="s1">;</span>
            <span class="s3">var </span><span class="s1">value;</span>
            <span class="s3">if </span><span class="s1">(HOP(fixed, </span><span class="s2">&quot;_eval&quot;</span><span class="s1">)) {</span>
                <span class="s1">value = fixed._eval();</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s3">this</span><span class="s1">._eval = return_this;</span>
                <span class="s1">value = fixed._eval(compressor, depth);</span>
                <span class="s3">delete this</span><span class="s1">._eval;</span>
                <span class="s3">if </span><span class="s1">(value === fixed) </span><span class="s3">return this</span><span class="s1">;</span>
                <span class="s1">fixed._eval = </span><span class="s3">function</span><span class="s1">() {</span>
                    <span class="s3">return </span><span class="s1">value;</span>
                <span class="s1">};</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(value &amp;&amp; </span><span class="s3">typeof </span><span class="s1">value == </span><span class="s2">&quot;object&quot;</span><span class="s1">) {</span>
                <span class="s3">var </span><span class="s1">escaped = </span><span class="s3">this</span><span class="s1">.definition().escaped;</span>
                <span class="s3">if </span><span class="s1">(escaped &amp;&amp; depth &gt; escaped) </span><span class="s3">return this</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">return </span><span class="s1">value;</span>
        <span class="s1">});</span>
        <span class="s3">var </span><span class="s1">global_objs = {</span>
            <span class="s1">Array: Array,</span>
            <span class="s1">Math: Math,</span>
            <span class="s1">Number: Number,</span>
            <span class="s1">Object: Object,</span>
            <span class="s1">String: String,</span>
        <span class="s1">};</span>
        <span class="s3">var </span><span class="s1">static_values = {</span>
            <span class="s1">Math: [</span>
                <span class="s2">&quot;E&quot;</span><span class="s1">,</span>
                <span class="s2">&quot;LN10&quot;</span><span class="s1">,</span>
                <span class="s2">&quot;LN2&quot;</span><span class="s1">,</span>
                <span class="s2">&quot;LOG2E&quot;</span><span class="s1">,</span>
                <span class="s2">&quot;LOG10E&quot;</span><span class="s1">,</span>
                <span class="s2">&quot;PI&quot;</span><span class="s1">,</span>
                <span class="s2">&quot;SQRT1_2&quot;</span><span class="s1">,</span>
                <span class="s2">&quot;SQRT2&quot;</span><span class="s1">,</span>
            <span class="s1">],</span>
            <span class="s1">Number: [</span>
                <span class="s2">&quot;MAX_VALUE&quot;</span><span class="s1">,</span>
                <span class="s2">&quot;MIN_VALUE&quot;</span><span class="s1">,</span>
                <span class="s2">&quot;NaN&quot;</span><span class="s1">,</span>
                <span class="s2">&quot;NEGATIVE_INFINITY&quot;</span><span class="s1">,</span>
                <span class="s2">&quot;POSITIVE_INFINITY&quot;</span><span class="s1">,</span>
            <span class="s1">],</span>
        <span class="s1">};</span>
        <span class="s1">convert_to_predicate(static_values);</span>
        <span class="s1">def(AST_PropAccess, </span><span class="s3">function</span><span class="s1">(compressor, depth) {</span>
            <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;unsafe&quot;</span><span class="s1">)) {</span>
                <span class="s3">var </span><span class="s1">key = </span><span class="s3">this</span><span class="s1">.property;</span>
                <span class="s3">if </span><span class="s1">(key </span><span class="s3">instanceof </span><span class="s1">AST_Node) {</span>
                    <span class="s1">key = key._eval(compressor, depth);</span>
                    <span class="s3">if </span><span class="s1">(key === </span><span class="s3">this</span><span class="s1">.property) </span><span class="s3">return this</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s3">var </span><span class="s1">exp = </span><span class="s3">this</span><span class="s1">.expression;</span>
                <span class="s3">var </span><span class="s1">val;</span>
                <span class="s3">if </span><span class="s1">(is_undeclared_ref(exp)) {</span>
                    <span class="s3">if </span><span class="s1">(!(static_values[exp.name] || return_false)(key)) </span><span class="s3">return this</span><span class="s1">;</span>
                    <span class="s1">val = global_objs[exp.name];</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s1">val = exp._eval(compressor, depth + </span><span class="s4">1</span><span class="s1">);</span>
                    <span class="s3">if </span><span class="s1">(!val || val === exp || !HOP(val, key)) </span><span class="s3">return this</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s3">return </span><span class="s1">val[key];</span>
            <span class="s1">}</span>
            <span class="s3">return this</span><span class="s1">;</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Call, </span><span class="s3">function</span><span class="s1">(compressor, depth) {</span>
            <span class="s3">var </span><span class="s1">exp = </span><span class="s3">this</span><span class="s1">.expression;</span>
            <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;unsafe&quot;</span><span class="s1">) &amp;&amp; exp </span><span class="s3">instanceof </span><span class="s1">AST_PropAccess) {</span>
                <span class="s3">var </span><span class="s1">key = exp.property;</span>
                <span class="s3">if </span><span class="s1">(key </span><span class="s3">instanceof </span><span class="s1">AST_Node) {</span>
                    <span class="s1">key = key._eval(compressor, depth);</span>
                    <span class="s3">if </span><span class="s1">(key === exp.property) </span><span class="s3">return this</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s3">var </span><span class="s1">val;</span>
                <span class="s3">var </span><span class="s1">e = exp.expression;</span>
                <span class="s3">if </span><span class="s1">(is_undeclared_ref(e)) {</span>
                    <span class="s3">if </span><span class="s1">(!(static_fns[e.name] || return_false)(key)) </span><span class="s3">return this</span><span class="s1">;</span>
                    <span class="s1">val = global_objs[e.name];</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s1">val = e._eval(compressor, depth + </span><span class="s4">1</span><span class="s1">);</span>
                    <span class="s3">if </span><span class="s1">(val === e || !(val &amp;&amp; native_fns[val.constructor.name] || return_false)(key)) </span><span class="s3">return this</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s3">var </span><span class="s1">args = [];</span>
                <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">, len = </span><span class="s3">this</span><span class="s1">.args.length; i &lt; len; i++) {</span>
                    <span class="s3">var </span><span class="s1">arg = </span><span class="s3">this</span><span class="s1">.args[i];</span>
                    <span class="s3">var </span><span class="s1">value = arg._eval(compressor, depth);</span>
                    <span class="s3">if </span><span class="s1">(arg === value) </span><span class="s3">return this</span><span class="s1">;</span>
                    <span class="s1">args.push(value);</span>
                <span class="s1">}</span>
                <span class="s3">try </span><span class="s1">{</span>
                    <span class="s3">return </span><span class="s1">val[key].apply(val, args);</span>
                <span class="s1">} </span><span class="s3">catch </span><span class="s1">(ex) {</span>
                    <span class="s1">compressor.warn(</span><span class="s2">&quot;Error evaluating {code} [{file}:{line},{col}]&quot;</span><span class="s1">, {</span>
                        <span class="s1">code: </span><span class="s3">this</span><span class="s1">.print_to_string(),</span>
                        <span class="s1">file: </span><span class="s3">this</span><span class="s1">.start.file,</span>
                        <span class="s1">line: </span><span class="s3">this</span><span class="s1">.start.line,</span>
                        <span class="s1">col: </span><span class="s3">this</span><span class="s1">.start.col</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s3">return this</span><span class="s1">;</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_New, return_this);</span>
    <span class="s1">})(</span><span class="s3">function</span><span class="s1">(node, func){</span>
        <span class="s1">node.DEFMETHOD(</span><span class="s2">&quot;_eval&quot;</span><span class="s1">, func);</span>
    <span class="s1">});</span>

    <span class="s0">// method to negate an expression</span>
    <span class="s1">(</span><span class="s3">function</span><span class="s1">(def){</span>
        <span class="s3">function </span><span class="s1">basic_negation(exp) {</span>
            <span class="s3">return </span><span class="s1">make_node(AST_UnaryPrefix, exp, {</span>
                <span class="s1">operator: </span><span class="s2">&quot;!&quot;</span><span class="s1">,</span>
                <span class="s1">expression: exp</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s3">function </span><span class="s1">best(orig, alt, first_in_statement) {</span>
            <span class="s3">var </span><span class="s1">negated = basic_negation(orig);</span>
            <span class="s3">if </span><span class="s1">(first_in_statement) {</span>
                <span class="s3">var </span><span class="s1">stat = make_node(AST_SimpleStatement, alt, {</span>
                    <span class="s1">body: alt</span>
                <span class="s1">});</span>
                <span class="s3">return </span><span class="s1">best_of_expression(negated, stat) === stat ? alt : negated;</span>
            <span class="s1">}</span>
            <span class="s3">return </span><span class="s1">best_of_expression(negated, alt);</span>
        <span class="s1">}</span>
        <span class="s1">def(AST_Node, </span><span class="s3">function</span><span class="s1">(){</span>
            <span class="s3">return </span><span class="s1">basic_negation(</span><span class="s3">this</span><span class="s1">);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Statement, </span><span class="s3">function</span><span class="s1">(){</span>
            <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Cannot negate a statement&quot;</span><span class="s1">);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Function, </span><span class="s3">function</span><span class="s1">(){</span>
            <span class="s3">return </span><span class="s1">basic_negation(</span><span class="s3">this</span><span class="s1">);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Arrow, </span><span class="s3">function</span><span class="s1">(){</span>
            <span class="s3">return </span><span class="s1">basic_negation(</span><span class="s3">this</span><span class="s1">);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_UnaryPrefix, </span><span class="s3">function</span><span class="s1">(){</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.operator == </span><span class="s2">&quot;!&quot;</span><span class="s1">)</span>
                <span class="s3">return this</span><span class="s1">.expression;</span>
            <span class="s3">return </span><span class="s1">basic_negation(</span><span class="s3">this</span><span class="s1">);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Sequence, </span><span class="s3">function</span><span class="s1">(compressor){</span>
            <span class="s3">var </span><span class="s1">expressions = </span><span class="s3">this</span><span class="s1">.expressions.slice();</span>
            <span class="s1">expressions.push(expressions.pop().negate(compressor));</span>
            <span class="s3">return </span><span class="s1">make_sequence(</span><span class="s3">this</span><span class="s1">, expressions);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Conditional, </span><span class="s3">function</span><span class="s1">(compressor, first_in_statement){</span>
            <span class="s3">var </span><span class="s1">self = </span><span class="s3">this</span><span class="s1">.clone();</span>
            <span class="s1">self.consequent = self.consequent.negate(compressor);</span>
            <span class="s1">self.alternative = self.alternative.negate(compressor);</span>
            <span class="s3">return </span><span class="s1">best(</span><span class="s3">this</span><span class="s1">, self, first_in_statement);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Binary, </span><span class="s3">function</span><span class="s1">(compressor, first_in_statement){</span>
            <span class="s3">var </span><span class="s1">self = </span><span class="s3">this</span><span class="s1">.clone(), op = </span><span class="s3">this</span><span class="s1">.operator;</span>
            <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;unsafe_comps&quot;</span><span class="s1">)) {</span>
                <span class="s3">switch </span><span class="s1">(op) {</span>
                  <span class="s3">case </span><span class="s2">&quot;&lt;=&quot; </span><span class="s1">: self.operator = </span><span class="s2">&quot;&gt;&quot;  </span><span class="s1">; </span><span class="s3">return </span><span class="s1">self;</span>
                  <span class="s3">case </span><span class="s2">&quot;&lt;&quot;  </span><span class="s1">: self.operator = </span><span class="s2">&quot;&gt;=&quot; </span><span class="s1">; </span><span class="s3">return </span><span class="s1">self;</span>
                  <span class="s3">case </span><span class="s2">&quot;&gt;=&quot; </span><span class="s1">: self.operator = </span><span class="s2">&quot;&lt;&quot;  </span><span class="s1">; </span><span class="s3">return </span><span class="s1">self;</span>
                  <span class="s3">case </span><span class="s2">&quot;&gt;&quot;  </span><span class="s1">: self.operator = </span><span class="s2">&quot;&lt;=&quot; </span><span class="s1">; </span><span class="s3">return </span><span class="s1">self;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s3">switch </span><span class="s1">(op) {</span>
              <span class="s3">case </span><span class="s2">&quot;==&quot; </span><span class="s1">: self.operator = </span><span class="s2">&quot;!=&quot;</span><span class="s1">; </span><span class="s3">return </span><span class="s1">self;</span>
              <span class="s3">case </span><span class="s2">&quot;!=&quot; </span><span class="s1">: self.operator = </span><span class="s2">&quot;==&quot;</span><span class="s1">; </span><span class="s3">return </span><span class="s1">self;</span>
              <span class="s3">case </span><span class="s2">&quot;===&quot;</span><span class="s1">: self.operator = </span><span class="s2">&quot;!==&quot;</span><span class="s1">; </span><span class="s3">return </span><span class="s1">self;</span>
              <span class="s3">case </span><span class="s2">&quot;!==&quot;</span><span class="s1">: self.operator = </span><span class="s2">&quot;===&quot;</span><span class="s1">; </span><span class="s3">return </span><span class="s1">self;</span>
              <span class="s3">case </span><span class="s2">&quot;&amp;&amp;&quot;</span><span class="s1">:</span>
                <span class="s1">self.operator = </span><span class="s2">&quot;||&quot;</span><span class="s1">;</span>
                <span class="s1">self.left = self.left.negate(compressor, first_in_statement);</span>
                <span class="s1">self.right = self.right.negate(compressor);</span>
                <span class="s3">return </span><span class="s1">best(</span><span class="s3">this</span><span class="s1">, self, first_in_statement);</span>
              <span class="s3">case </span><span class="s2">&quot;||&quot;</span><span class="s1">:</span>
                <span class="s1">self.operator = </span><span class="s2">&quot;&amp;&amp;&quot;</span><span class="s1">;</span>
                <span class="s1">self.left = self.left.negate(compressor, first_in_statement);</span>
                <span class="s1">self.right = self.right.negate(compressor);</span>
                <span class="s3">return </span><span class="s1">best(</span><span class="s3">this</span><span class="s1">, self, first_in_statement);</span>
            <span class="s1">}</span>
            <span class="s3">return </span><span class="s1">basic_negation(</span><span class="s3">this</span><span class="s1">);</span>
        <span class="s1">});</span>
    <span class="s1">})(</span><span class="s3">function</span><span class="s1">(node, func){</span>
        <span class="s1">node.DEFMETHOD(</span><span class="s2">&quot;negate&quot;</span><span class="s1">, </span><span class="s3">function</span><span class="s1">(compressor, first_in_statement){</span>
            <span class="s3">return </span><span class="s1">func.call(</span><span class="s3">this</span><span class="s1">, compressor, first_in_statement);</span>
        <span class="s1">});</span>
    <span class="s1">});</span>

    <span class="s3">var </span><span class="s1">global_pure_fns = makePredicate(</span><span class="s2">&quot;Boolean decodeURI decodeURIComponent Date encodeURI encodeURIComponent Error escape EvalError isFinite isNaN Number Object parseFloat parseInt RangeError ReferenceError String SyntaxError TypeError unescape URIError&quot;</span><span class="s1">);</span>
    <span class="s1">AST_Call.DEFMETHOD(</span><span class="s2">&quot;is_expr_pure&quot;</span><span class="s1">, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;unsafe&quot;</span><span class="s1">)) {</span>
            <span class="s3">var </span><span class="s1">expr = </span><span class="s3">this</span><span class="s1">.expression;</span>
            <span class="s3">if </span><span class="s1">(is_undeclared_ref(expr) &amp;&amp; global_pure_fns(expr.name)) </span><span class="s3">return true</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(expr </span><span class="s3">instanceof </span><span class="s1">AST_Dot</span>
                <span class="s1">&amp;&amp; is_undeclared_ref(expr.expression)</span>
                <span class="s1">&amp;&amp; (static_fns[expr.expression.name] || return_false)(expr.property)) {</span>
                <span class="s3">return true</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">return this</span><span class="s1">.pure || !compressor.pure_funcs(</span><span class="s3">this</span><span class="s1">);</span>
    <span class="s1">});</span>
    <span class="s1">AST_Node.DEFMETHOD(</span><span class="s2">&quot;is_call_pure&quot;</span><span class="s1">, return_false);</span>
    <span class="s1">AST_Dot.DEFMETHOD(</span><span class="s2">&quot;is_call_pure&quot;</span><span class="s1">, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">if </span><span class="s1">(!compressor.option(</span><span class="s2">&quot;unsafe&quot;</span><span class="s1">)) </span><span class="s3">return</span><span class="s1">;</span>
        <span class="s3">var </span><span class="s1">expr = </span><span class="s3">this</span><span class="s1">.expression;</span>
        <span class="s3">var </span><span class="s1">fns = return_false;</span>
        <span class="s3">if </span><span class="s1">(expr </span><span class="s3">instanceof </span><span class="s1">AST_Array) {</span>
            <span class="s1">fns = native_fns.Array;</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(expr.is_boolean()) {</span>
            <span class="s1">fns = native_fns.Boolean;</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(expr.is_number(compressor)) {</span>
            <span class="s1">fns = native_fns.Number;</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(expr </span><span class="s3">instanceof </span><span class="s1">AST_RegExp) {</span>
            <span class="s1">fns = native_fns.RegExp;</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(expr.is_string(compressor)) {</span>
            <span class="s1">fns = native_fns.String;</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(!</span><span class="s3">this</span><span class="s1">.may_throw_on_access(compressor)) {</span>
            <span class="s1">fns = native_fns.Object;</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">fns(</span><span class="s3">this</span><span class="s1">.property);</span>
    <span class="s1">});</span>

    <span class="s0">// determine if expression has side effects</span>
    <span class="s1">(</span><span class="s3">function</span><span class="s1">(def){</span>
        <span class="s1">def(AST_Node, return_true);</span>

        <span class="s1">def(AST_EmptyStatement, return_false);</span>
        <span class="s1">def(AST_Constant, return_false);</span>
        <span class="s1">def(AST_This, return_false);</span>

        <span class="s3">function </span><span class="s1">any(list, compressor) {</span>
            <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = list.length; --i &gt;= </span><span class="s4">0</span><span class="s1">;)</span>
                <span class="s3">if </span><span class="s1">(list[i].has_side_effects(compressor))</span>
                    <span class="s3">return true</span><span class="s1">;</span>
            <span class="s3">return false</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">def(AST_Block, </span><span class="s3">function</span><span class="s1">(compressor){</span>
            <span class="s3">return </span><span class="s1">any(</span><span class="s3">this</span><span class="s1">.body, compressor);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Call, </span><span class="s3">function</span><span class="s1">(compressor){</span>
            <span class="s3">if </span><span class="s1">(!</span><span class="s3">this</span><span class="s1">.is_expr_pure(compressor)</span>
                <span class="s1">&amp;&amp; (!</span><span class="s3">this</span><span class="s1">.expression.is_call_pure(compressor)</span>
                    <span class="s1">|| </span><span class="s3">this</span><span class="s1">.expression.has_side_effects(compressor))) {</span>
                <span class="s3">return true</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">return </span><span class="s1">any(</span><span class="s3">this</span><span class="s1">.args, compressor);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Switch, </span><span class="s3">function</span><span class="s1">(compressor){</span>
            <span class="s3">return this</span><span class="s1">.expression.has_side_effects(compressor)</span>
                <span class="s1">|| any(</span><span class="s3">this</span><span class="s1">.body, compressor);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Case, </span><span class="s3">function</span><span class="s1">(compressor){</span>
            <span class="s3">return this</span><span class="s1">.expression.has_side_effects(compressor)</span>
                <span class="s1">|| any(</span><span class="s3">this</span><span class="s1">.body, compressor);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Try, </span><span class="s3">function</span><span class="s1">(compressor){</span>
            <span class="s3">return </span><span class="s1">any(</span><span class="s3">this</span><span class="s1">.body, compressor)</span>
                <span class="s1">|| </span><span class="s3">this</span><span class="s1">.bcatch &amp;&amp; </span><span class="s3">this</span><span class="s1">.bcatch.has_side_effects(compressor)</span>
                <span class="s1">|| </span><span class="s3">this</span><span class="s1">.bfinally &amp;&amp; </span><span class="s3">this</span><span class="s1">.bfinally.has_side_effects(compressor);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_If, </span><span class="s3">function</span><span class="s1">(compressor){</span>
            <span class="s3">return this</span><span class="s1">.condition.has_side_effects(compressor)</span>
                <span class="s1">|| </span><span class="s3">this</span><span class="s1">.body &amp;&amp; </span><span class="s3">this</span><span class="s1">.body.has_side_effects(compressor)</span>
                <span class="s1">|| </span><span class="s3">this</span><span class="s1">.alternative &amp;&amp; </span><span class="s3">this</span><span class="s1">.alternative.has_side_effects(compressor);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_LabeledStatement, </span><span class="s3">function</span><span class="s1">(compressor){</span>
            <span class="s3">return this</span><span class="s1">.body.has_side_effects(compressor);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_SimpleStatement, </span><span class="s3">function</span><span class="s1">(compressor){</span>
            <span class="s3">return this</span><span class="s1">.body.has_side_effects(compressor);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Lambda, return_false);</span>
        <span class="s1">def(AST_Class, return_false);</span>
        <span class="s1">def(AST_DefClass, return_true);</span>
        <span class="s1">def(AST_Binary, </span><span class="s3">function</span><span class="s1">(compressor){</span>
            <span class="s3">return this</span><span class="s1">.left.has_side_effects(compressor)</span>
                <span class="s1">|| </span><span class="s3">this</span><span class="s1">.right.has_side_effects(compressor);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Assign, return_true);</span>
        <span class="s1">def(AST_Conditional, </span><span class="s3">function</span><span class="s1">(compressor){</span>
            <span class="s3">return this</span><span class="s1">.condition.has_side_effects(compressor)</span>
                <span class="s1">|| </span><span class="s3">this</span><span class="s1">.consequent.has_side_effects(compressor)</span>
                <span class="s1">|| </span><span class="s3">this</span><span class="s1">.alternative.has_side_effects(compressor);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Unary, </span><span class="s3">function</span><span class="s1">(compressor){</span>
            <span class="s3">return </span><span class="s1">unary_side_effects(</span><span class="s3">this</span><span class="s1">.operator)</span>
                <span class="s1">|| </span><span class="s3">this</span><span class="s1">.expression.has_side_effects(compressor);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_SymbolRef, </span><span class="s3">function</span><span class="s1">(compressor){</span>
            <span class="s3">return </span><span class="s1">!</span><span class="s3">this</span><span class="s1">.is_declared(compressor);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_SymbolDeclaration, return_false);</span>
        <span class="s1">def(AST_Object, </span><span class="s3">function</span><span class="s1">(compressor){</span>
            <span class="s3">return </span><span class="s1">any(</span><span class="s3">this</span><span class="s1">.properties, compressor);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_ObjectProperty, </span><span class="s3">function</span><span class="s1">(compressor){</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.key </span><span class="s3">instanceof </span><span class="s1">AST_ObjectKeyVal &amp;&amp;</span>
                    <span class="s3">this</span><span class="s1">.key.has_side_effects(compressor))</span>
                <span class="s3">return true</span><span class="s1">;</span>
            <span class="s3">return this</span><span class="s1">.value.has_side_effects(compressor);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Array, </span><span class="s3">function</span><span class="s1">(compressor){</span>
            <span class="s3">return </span><span class="s1">any(</span><span class="s3">this</span><span class="s1">.elements, compressor);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Dot, </span><span class="s3">function</span><span class="s1">(compressor){</span>
            <span class="s3">return this</span><span class="s1">.expression.may_throw_on_access(compressor)</span>
                <span class="s1">|| </span><span class="s3">this</span><span class="s1">.expression.has_side_effects(compressor);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Sub, </span><span class="s3">function</span><span class="s1">(compressor){</span>
            <span class="s3">return this</span><span class="s1">.expression.may_throw_on_access(compressor)</span>
                <span class="s1">|| </span><span class="s3">this</span><span class="s1">.expression.has_side_effects(compressor)</span>
                <span class="s1">|| </span><span class="s3">this</span><span class="s1">.property.has_side_effects(compressor);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Sequence, </span><span class="s3">function</span><span class="s1">(compressor){</span>
            <span class="s3">return </span><span class="s1">any(</span><span class="s3">this</span><span class="s1">.expressions, compressor);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Definitions, </span><span class="s3">function</span><span class="s1">(compressor){</span>
            <span class="s3">return </span><span class="s1">any(</span><span class="s3">this</span><span class="s1">.definitions, compressor);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_VarDef, </span><span class="s3">function</span><span class="s1">(compressor){</span>
            <span class="s3">return this</span><span class="s1">.value;</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_TemplateSegment, return_false);</span>
        <span class="s1">def(AST_TemplateString, </span><span class="s3">function</span><span class="s1">(compressor){</span>
            <span class="s3">return </span><span class="s1">any(</span><span class="s3">this</span><span class="s1">.segments, compressor);</span>
        <span class="s1">});</span>
    <span class="s1">})(</span><span class="s3">function</span><span class="s1">(node, func){</span>
        <span class="s1">node.DEFMETHOD(</span><span class="s2">&quot;has_side_effects&quot;</span><span class="s1">, func);</span>
    <span class="s1">});</span>

    <span class="s0">// determine if expression may throw</span>
    <span class="s1">(</span><span class="s3">function</span><span class="s1">(def){</span>
        <span class="s1">def(AST_Node, return_true);</span>

        <span class="s1">def(AST_Class, return_false);</span>
        <span class="s1">def(AST_Constant, return_false);</span>
        <span class="s1">def(AST_EmptyStatement, return_false);</span>
        <span class="s1">def(AST_Lambda, return_false);</span>
        <span class="s1">def(AST_SymbolDeclaration, return_false);</span>
        <span class="s1">def(AST_This, return_false);</span>

        <span class="s3">function </span><span class="s1">any(list, compressor) {</span>
            <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = list.length; --i &gt;= </span><span class="s4">0</span><span class="s1">;)</span>
                <span class="s3">if </span><span class="s1">(list[i].may_throw(compressor))</span>
                    <span class="s3">return true</span><span class="s1">;</span>
            <span class="s3">return false</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">def(AST_Array, </span><span class="s3">function</span><span class="s1">(compressor){</span>
            <span class="s3">return </span><span class="s1">any(</span><span class="s3">this</span><span class="s1">.elements, compressor);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Assign, </span><span class="s3">function</span><span class="s1">(compressor){</span>
            <span class="s3">return this</span><span class="s1">.operator != </span><span class="s2">&quot;=&quot; </span><span class="s1">&amp;&amp; </span><span class="s3">this</span><span class="s1">.left.may_throw(compressor)</span>
                <span class="s1">|| </span><span class="s3">this</span><span class="s1">.right.may_throw(compressor);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Binary, </span><span class="s3">function</span><span class="s1">(compressor){</span>
            <span class="s3">return this</span><span class="s1">.left.may_throw(compressor)</span>
                <span class="s1">|| </span><span class="s3">this</span><span class="s1">.right.may_throw(compressor);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Block, </span><span class="s3">function</span><span class="s1">(compressor){</span>
            <span class="s3">return </span><span class="s1">any(</span><span class="s3">this</span><span class="s1">.body, compressor);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Call, </span><span class="s3">function</span><span class="s1">(compressor){</span>
            <span class="s3">if </span><span class="s1">(any(</span><span class="s3">this</span><span class="s1">.args, compressor)) </span><span class="s3">return true</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.is_expr_pure(compressor)) </span><span class="s3">return false</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.expression.may_throw(compressor)) </span><span class="s3">return true</span><span class="s1">;</span>
            <span class="s3">return </span><span class="s1">!(</span><span class="s3">this</span><span class="s1">.expression </span><span class="s3">instanceof </span><span class="s1">AST_Lambda)</span>
                <span class="s1">|| any(</span><span class="s3">this</span><span class="s1">.expression.body, compressor);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Case, </span><span class="s3">function</span><span class="s1">(compressor){</span>
            <span class="s3">return this</span><span class="s1">.expression.may_throw(compressor)</span>
                <span class="s1">|| any(</span><span class="s3">this</span><span class="s1">.body, compressor);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Conditional, </span><span class="s3">function</span><span class="s1">(compressor){</span>
            <span class="s3">return this</span><span class="s1">.condition.may_throw(compressor)</span>
                <span class="s1">|| </span><span class="s3">this</span><span class="s1">.consequent.may_throw(compressor)</span>
                <span class="s1">|| </span><span class="s3">this</span><span class="s1">.alternative.may_throw(compressor);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Definitions, </span><span class="s3">function</span><span class="s1">(compressor){</span>
            <span class="s3">return </span><span class="s1">any(</span><span class="s3">this</span><span class="s1">.definitions, compressor);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Dot, </span><span class="s3">function</span><span class="s1">(compressor){</span>
            <span class="s3">return this</span><span class="s1">.expression.may_throw_on_access(compressor)</span>
                <span class="s1">|| </span><span class="s3">this</span><span class="s1">.expression.may_throw(compressor);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_If, </span><span class="s3">function</span><span class="s1">(compressor){</span>
            <span class="s3">return this</span><span class="s1">.condition.may_throw(compressor)</span>
                <span class="s1">|| </span><span class="s3">this</span><span class="s1">.body &amp;&amp; </span><span class="s3">this</span><span class="s1">.body.may_throw(compressor)</span>
                <span class="s1">|| </span><span class="s3">this</span><span class="s1">.alternative &amp;&amp; </span><span class="s3">this</span><span class="s1">.alternative.may_throw(compressor);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_LabeledStatement, </span><span class="s3">function</span><span class="s1">(compressor){</span>
            <span class="s3">return this</span><span class="s1">.body.may_throw(compressor);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Object, </span><span class="s3">function</span><span class="s1">(compressor){</span>
            <span class="s3">return </span><span class="s1">any(</span><span class="s3">this</span><span class="s1">.properties, compressor);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_ObjectProperty, </span><span class="s3">function</span><span class="s1">(compressor){</span>
            <span class="s3">return this</span><span class="s1">.value.may_throw(compressor);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Sequence, </span><span class="s3">function</span><span class="s1">(compressor){</span>
            <span class="s3">return </span><span class="s1">any(</span><span class="s3">this</span><span class="s1">.expressions, compressor);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_SimpleStatement, </span><span class="s3">function</span><span class="s1">(compressor){</span>
            <span class="s3">return this</span><span class="s1">.body.may_throw(compressor);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Sub, </span><span class="s3">function</span><span class="s1">(compressor){</span>
            <span class="s3">return this</span><span class="s1">.expression.may_throw_on_access(compressor)</span>
                <span class="s1">|| </span><span class="s3">this</span><span class="s1">.expression.may_throw(compressor)</span>
                <span class="s1">|| </span><span class="s3">this</span><span class="s1">.property.may_throw(compressor);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Switch, </span><span class="s3">function</span><span class="s1">(compressor){</span>
            <span class="s3">return this</span><span class="s1">.expression.may_throw(compressor)</span>
                <span class="s1">|| any(</span><span class="s3">this</span><span class="s1">.body, compressor);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_SymbolRef, </span><span class="s3">function</span><span class="s1">(compressor){</span>
            <span class="s3">return </span><span class="s1">!</span><span class="s3">this</span><span class="s1">.is_declared(compressor);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Try, </span><span class="s3">function</span><span class="s1">(compressor){</span>
            <span class="s3">return </span><span class="s1">any(</span><span class="s3">this</span><span class="s1">.body, compressor)</span>
                <span class="s1">|| </span><span class="s3">this</span><span class="s1">.bcatch &amp;&amp; </span><span class="s3">this</span><span class="s1">.bcatch.may_throw(compressor)</span>
                <span class="s1">|| </span><span class="s3">this</span><span class="s1">.bfinally &amp;&amp; </span><span class="s3">this</span><span class="s1">.bfinally.may_throw(compressor);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Unary, </span><span class="s3">function</span><span class="s1">(compressor){</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.operator == </span><span class="s2">&quot;typeof&quot; </span><span class="s1">&amp;&amp; </span><span class="s3">this</span><span class="s1">.expression </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef)</span>
                <span class="s3">return false</span><span class="s1">;</span>
            <span class="s3">return this</span><span class="s1">.expression.may_throw(compressor);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_VarDef, </span><span class="s3">function</span><span class="s1">(compressor){</span>
            <span class="s3">if </span><span class="s1">(!</span><span class="s3">this</span><span class="s1">.value) </span><span class="s3">return false</span><span class="s1">;</span>
            <span class="s3">return this</span><span class="s1">.value.may_throw(compressor);</span>
        <span class="s1">});</span>
    <span class="s1">})(</span><span class="s3">function</span><span class="s1">(node, func){</span>
        <span class="s1">node.DEFMETHOD(</span><span class="s2">&quot;may_throw&quot;</span><span class="s1">, func);</span>
    <span class="s1">});</span>

    <span class="s0">// determine if expression is constant</span>
    <span class="s1">(</span><span class="s3">function</span><span class="s1">(def){</span>
        <span class="s3">function </span><span class="s1">all(list) {</span>
            <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = list.length; --i &gt;= </span><span class="s4">0</span><span class="s1">;)</span>
                <span class="s3">if </span><span class="s1">(!list[i].is_constant_expression())</span>
                    <span class="s3">return false</span><span class="s1">;</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">function </span><span class="s1">all_refs_local(scope) {</span>
            <span class="s3">var </span><span class="s1">self = </span><span class="s3">this</span><span class="s1">;</span>
            <span class="s3">var </span><span class="s1">result = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s1">self.walk(</span><span class="s3">new </span><span class="s1">TreeWalker(</span><span class="s3">function</span><span class="s1">(node) {</span>
                <span class="s3">if </span><span class="s1">(!result) </span><span class="s3">return true</span><span class="s1">;</span>
                <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef) {</span>
                    <span class="s3">if </span><span class="s1">(self.inlined) {</span>
                        <span class="s1">result = </span><span class="s3">false</span><span class="s1">;</span>
                        <span class="s3">return true</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s3">var </span><span class="s1">def = node.definition();</span>
                    <span class="s3">if </span><span class="s1">(member(def, self.enclosed)</span>
                        <span class="s1">&amp;&amp; !self.variables.has(def.name)) {</span>
                        <span class="s3">if </span><span class="s1">(scope) {</span>
                            <span class="s3">var </span><span class="s1">scope_def = scope.find_variable(node);</span>
                            <span class="s3">if </span><span class="s1">(def.undeclared ? !scope_def : scope_def === def) {</span>
                                <span class="s1">result = </span><span class="s2">&quot;f&quot;</span><span class="s1">;</span>
                                <span class="s3">return true</span><span class="s1">;</span>
                            <span class="s1">}</span>
                        <span class="s1">}</span>
                        <span class="s1">result = </span><span class="s3">false</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s3">return true</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_This &amp;&amp; self </span><span class="s3">instanceof </span><span class="s1">AST_Arrow) {</span>
                    <span class="s1">result = </span><span class="s3">false</span><span class="s1">;</span>
                    <span class="s3">return true</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}));</span>
            <span class="s3">return </span><span class="s1">result;</span>
        <span class="s1">}</span>

        <span class="s1">def(AST_Node, return_false);</span>
        <span class="s1">def(AST_Constant, return_true);</span>
        <span class="s1">def(AST_Class, all_refs_local);</span>
        <span class="s1">def(AST_Lambda, all_refs_local);</span>
        <span class="s1">def(AST_Unary, </span><span class="s3">function</span><span class="s1">(){</span>
            <span class="s3">return this</span><span class="s1">.expression.is_constant_expression();</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Binary, </span><span class="s3">function</span><span class="s1">(){</span>
            <span class="s3">return this</span><span class="s1">.left.is_constant_expression() &amp;&amp; </span><span class="s3">this</span><span class="s1">.right.is_constant_expression();</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Array, </span><span class="s3">function</span><span class="s1">(){</span>
            <span class="s3">return </span><span class="s1">all(</span><span class="s3">this</span><span class="s1">.elements);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Object, </span><span class="s3">function</span><span class="s1">(){</span>
            <span class="s3">return </span><span class="s1">all(</span><span class="s3">this</span><span class="s1">.properties);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_ObjectProperty, </span><span class="s3">function</span><span class="s1">(){</span>
            <span class="s3">return </span><span class="s1">!(</span><span class="s3">this</span><span class="s1">.key </span><span class="s3">instanceof </span><span class="s1">AST_Node) &amp;&amp; </span><span class="s3">this</span><span class="s1">.value.is_constant_expression();</span>
        <span class="s1">});</span>
    <span class="s1">})(</span><span class="s3">function</span><span class="s1">(node, func){</span>
        <span class="s1">node.DEFMETHOD(</span><span class="s2">&quot;is_constant_expression&quot;</span><span class="s1">, func);</span>
    <span class="s1">});</span>

    <span class="s0">// tell me if a statement aborts</span>
    <span class="s3">function </span><span class="s1">aborts(thing) {</span>
        <span class="s3">return </span><span class="s1">thing &amp;&amp; thing.aborts();</span>
    <span class="s1">};</span>
    <span class="s1">(</span><span class="s3">function</span><span class="s1">(def){</span>
        <span class="s1">def(AST_Statement, return_null);</span>
        <span class="s1">def(AST_Jump, return_this);</span>
        <span class="s3">function </span><span class="s1">block_aborts(){</span>
            <span class="s3">var </span><span class="s1">n = </span><span class="s3">this</span><span class="s1">.body.length;</span>
            <span class="s3">return </span><span class="s1">n &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; aborts(</span><span class="s3">this</span><span class="s1">.body[n - </span><span class="s4">1</span><span class="s1">]);</span>
        <span class="s1">};</span>
        <span class="s1">def(AST_Import, </span><span class="s3">function</span><span class="s1">(){ </span><span class="s3">return null</span><span class="s1">; });</span>
        <span class="s1">def(AST_BlockStatement, block_aborts);</span>
        <span class="s1">def(AST_SwitchBranch, block_aborts);</span>
        <span class="s1">def(AST_If, </span><span class="s3">function</span><span class="s1">(){</span>
            <span class="s3">return this</span><span class="s1">.alternative &amp;&amp; aborts(</span><span class="s3">this</span><span class="s1">.body) &amp;&amp; aborts(</span><span class="s3">this</span><span class="s1">.alternative) &amp;&amp; </span><span class="s3">this</span><span class="s1">;</span>
        <span class="s1">});</span>
    <span class="s1">})(</span><span class="s3">function</span><span class="s1">(node, func){</span>
        <span class="s1">node.DEFMETHOD(</span><span class="s2">&quot;aborts&quot;</span><span class="s1">, func);</span>
    <span class="s1">});</span>

    <span class="s0">/* -----[ optimizers ]----- */</span>

    <span class="s1">OPT(AST_Directive, </span><span class="s3">function</span><span class="s1">(self, compressor){</span>
        <span class="s3">if </span><span class="s1">(compressor.has_directive(self.value) !== self) {</span>
            <span class="s3">return </span><span class="s1">make_node(AST_EmptyStatement, self);</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">self;</span>
    <span class="s1">});</span>

    <span class="s1">OPT(AST_Debugger, </span><span class="s3">function</span><span class="s1">(self, compressor){</span>
        <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;drop_debugger&quot;</span><span class="s1">))</span>
            <span class="s3">return </span><span class="s1">make_node(AST_EmptyStatement, self);</span>
        <span class="s3">return </span><span class="s1">self;</span>
    <span class="s1">});</span>

    <span class="s1">OPT(AST_LabeledStatement, </span><span class="s3">function</span><span class="s1">(self, compressor){</span>
        <span class="s3">if </span><span class="s1">(self.body </span><span class="s3">instanceof </span><span class="s1">AST_Break</span>
            <span class="s1">&amp;&amp; compressor.loopcontrol_target(self.body) === self.body) {</span>
            <span class="s3">return </span><span class="s1">make_node(AST_EmptyStatement, self);</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">self.label.references.length == </span><span class="s4">0 </span><span class="s1">? self.body : self;</span>
    <span class="s1">});</span>

    <span class="s1">OPT(AST_Block, </span><span class="s3">function</span><span class="s1">(self, compressor){</span>
        <span class="s1">tighten_body(self.body, compressor);</span>
        <span class="s3">return </span><span class="s1">self;</span>
    <span class="s1">});</span>

    <span class="s1">OPT(AST_BlockStatement, </span><span class="s3">function</span><span class="s1">(self, compressor){</span>
        <span class="s1">tighten_body(self.body, compressor);</span>
        <span class="s3">switch </span><span class="s1">(self.body.length) {</span>
          <span class="s3">case </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">(!compressor.has_directive(</span><span class="s2">&quot;use strict&quot;</span><span class="s1">) &amp;&amp; compressor.parent() </span><span class="s3">instanceof </span><span class="s1">AST_If</span>
                <span class="s1">|| can_be_evicted_from_block(self.body[</span><span class="s4">0</span><span class="s1">])) {</span>
                <span class="s3">return </span><span class="s1">self.body[</span><span class="s4">0</span><span class="s1">];</span>
            <span class="s1">}</span>
            <span class="s3">break</span><span class="s1">;</span>
          <span class="s3">case </span><span class="s4">0</span><span class="s1">: </span><span class="s3">return </span><span class="s1">make_node(AST_EmptyStatement, self);</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">self;</span>
    <span class="s1">});</span>

    <span class="s1">AST_Scope.DEFMETHOD(</span><span class="s2">&quot;drop_unused&quot;</span><span class="s1">, </span><span class="s3">function</span><span class="s1">(compressor){</span>
        <span class="s3">if </span><span class="s1">(!compressor.option(</span><span class="s2">&quot;unused&quot;</span><span class="s1">)) </span><span class="s3">return</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s1">(compressor.has_directive(</span><span class="s2">&quot;use asm&quot;</span><span class="s1">)) </span><span class="s3">return</span><span class="s1">;</span>
        <span class="s3">var </span><span class="s1">self = </span><span class="s3">this</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s1">(self.uses_eval || self.uses_with) </span><span class="s3">return</span><span class="s1">;</span>
        <span class="s3">var </span><span class="s1">drop_funcs = !(self </span><span class="s3">instanceof </span><span class="s1">AST_Toplevel) || compressor.toplevel.funcs;</span>
        <span class="s3">var </span><span class="s1">drop_vars = !(self </span><span class="s3">instanceof </span><span class="s1">AST_Toplevel) || compressor.toplevel.vars;</span>
        <span class="s3">var </span><span class="s1">assign_as_unused = /keep_assign/.test(compressor.option(</span><span class="s2">&quot;unused&quot;</span><span class="s1">)) ? return_false : </span><span class="s3">function</span><span class="s1">(node) {</span>
            <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Assign &amp;&amp; (node.write_only || node.operator == </span><span class="s2">&quot;=&quot;</span><span class="s1">)) {</span>
                <span class="s3">return </span><span class="s1">node.left;</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Unary &amp;&amp; node.write_only) </span><span class="s3">return </span><span class="s1">node.expression;</span>
        <span class="s1">};</span>
        <span class="s3">var </span><span class="s1">in_use = [];</span>
        <span class="s3">var </span><span class="s1">in_use_ids = Object.create(</span><span class="s3">null</span><span class="s1">); </span><span class="s0">// avoid expensive linear scans of in_use</span>
        <span class="s3">var </span><span class="s1">fixed_ids = Object.create(</span><span class="s3">null</span><span class="s1">);</span>
        <span class="s3">if </span><span class="s1">(self </span><span class="s3">instanceof </span><span class="s1">AST_Toplevel &amp;&amp; compressor.top_retain) {</span>
            <span class="s1">self.variables.each(</span><span class="s3">function</span><span class="s1">(def) {</span>
                <span class="s3">if </span><span class="s1">(compressor.top_retain(def) &amp;&amp; !(def.id </span><span class="s3">in </span><span class="s1">in_use_ids)) {</span>
                    <span class="s1">in_use_ids[def.id] = </span><span class="s3">true</span><span class="s1">;</span>
                    <span class="s1">in_use.push(def);</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s3">var </span><span class="s1">var_defs_by_id = </span><span class="s3">new </span><span class="s1">Dictionary();</span>
        <span class="s3">var </span><span class="s1">initializations = </span><span class="s3">new </span><span class="s1">Dictionary();</span>
        <span class="s3">var </span><span class="s1">destructuring_value = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s0">// pass 1: find out which symbols are directly used in</span>
        <span class="s0">// this scope (not in nested scopes).</span>
        <span class="s3">var </span><span class="s1">scope = </span><span class="s3">this</span><span class="s1">;</span>
        <span class="s3">var </span><span class="s1">tw = </span><span class="s3">new </span><span class="s1">TreeWalker(</span><span class="s3">function</span><span class="s1">(node, descend){</span>
            <span class="s3">if </span><span class="s1">(node === self) </span><span class="s3">return</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Defun || node </span><span class="s3">instanceof </span><span class="s1">AST_DefClass) {</span>
                <span class="s3">var </span><span class="s1">node_def = node.name.definition();</span>
                <span class="s3">var </span><span class="s1">in_export = tw.parent() </span><span class="s3">instanceof </span><span class="s1">AST_Export;</span>
                <span class="s3">if </span><span class="s1">(in_export || !drop_funcs &amp;&amp; scope === self) {</span>
                    <span class="s3">if </span><span class="s1">(node_def.global &amp;&amp; !(node_def.id </span><span class="s3">in </span><span class="s1">in_use_ids)) {</span>
                        <span class="s1">in_use_ids[node_def.id] = </span><span class="s3">true</span><span class="s1">;</span>
                        <span class="s1">in_use.push(node_def);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s1">initializations.add(node_def.id, node);</span>
                <span class="s3">return true</span><span class="s1">; </span><span class="s0">// don't go in nested scopes</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_SymbolFunarg &amp;&amp; scope === self) {</span>
                <span class="s1">var_defs_by_id.add(node.definition().id, node);</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Definitions &amp;&amp; scope === self) {</span>
                <span class="s3">var </span><span class="s1">in_export = tw.parent() </span><span class="s3">instanceof </span><span class="s1">AST_Export;</span>
                <span class="s1">node.definitions.forEach(</span><span class="s3">function</span><span class="s1">(def){</span>
                    <span class="s3">if </span><span class="s1">(def.name </span><span class="s3">instanceof </span><span class="s1">AST_SymbolVar) {</span>
                        <span class="s1">var_defs_by_id.add(def.name.definition().id, def);</span>
                    <span class="s1">}</span>
                    <span class="s3">if </span><span class="s1">(in_export || !drop_vars) {</span>
                        <span class="s1">def.name.walk(</span><span class="s3">new </span><span class="s1">TreeWalker(</span><span class="s3">function</span><span class="s1">(node) {</span>
                            <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_SymbolDeclaration) {</span>
                                <span class="s3">var </span><span class="s1">def = node.definition();</span>
                                <span class="s3">if </span><span class="s1">((in_export || def.global) &amp;&amp; !(def.id </span><span class="s3">in </span><span class="s1">in_use_ids)) {</span>
                                    <span class="s1">in_use_ids[def.id] = </span><span class="s3">true</span><span class="s1">;</span>
                                    <span class="s1">in_use.push(def);</span>
                                <span class="s1">}</span>
                            <span class="s1">}</span>
                        <span class="s1">}));</span>
                    <span class="s1">}</span>
                    <span class="s3">if </span><span class="s1">(def.value) {</span>
                        <span class="s3">if </span><span class="s1">(def.name </span><span class="s3">instanceof </span><span class="s1">AST_Destructuring) {</span>
                            <span class="s3">var </span><span class="s1">destructuring_cache = destructuring_value;</span>
                            <span class="s1">destructuring_value = def.value;</span>
                            <span class="s1">def.walk(tw);</span>
                            <span class="s1">destructuring_value = destructuring_cache;</span>
                        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                            <span class="s3">var </span><span class="s1">node_def = def.name.definition();;</span>
                            <span class="s1">initializations.add(node_def.id, def.value);</span>
                            <span class="s3">if </span><span class="s1">(def.name.fixed_value() === def.value) {</span>
                                <span class="s1">fixed_ids[node_def.id] = def;</span>
                            <span class="s1">}</span>
                        <span class="s1">}</span>
                        <span class="s3">if </span><span class="s1">(def.value.has_side_effects(compressor)) {</span>
                            <span class="s1">def.value.walk(tw);</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">});</span>
                <span class="s3">return true</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(node.destructuring &amp;&amp; destructuring_value) {</span>
                <span class="s1">initializations.add(node.name, destructuring_value);</span>
            <span class="s1">}</span>
            <span class="s3">return </span><span class="s1">scan_ref_scoped(node, descend);</span>
        <span class="s1">});</span>
        <span class="s1">self.walk(tw);</span>
        <span class="s0">// pass 2: for every used symbol we need to walk its</span>
        <span class="s0">// initialization code to figure out if it uses other</span>
        <span class="s0">// symbols (that may not be in_use).</span>
        <span class="s1">tw = </span><span class="s3">new </span><span class="s1">TreeWalker(scan_ref_scoped);</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; in_use.length; i++) {</span>
            <span class="s3">var </span><span class="s1">init = initializations.get(in_use[i].id);</span>
            <span class="s3">if </span><span class="s1">(init) init.forEach(</span><span class="s3">function</span><span class="s1">(init) {</span>
                <span class="s1">init.walk(tw);</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s0">// pass 3: we should drop declarations not in_use</span>
        <span class="s3">var </span><span class="s1">tt = </span><span class="s3">new </span><span class="s1">TreeTransformer(</span>
            <span class="s3">function </span><span class="s1">before(node, descend, in_list) {</span>
                <span class="s3">var </span><span class="s1">parent = tt.parent();</span>
                <span class="s3">if </span><span class="s1">(drop_vars) {</span>
                    <span class="s3">var </span><span class="s1">sym = assign_as_unused(node);</span>
                    <span class="s3">if </span><span class="s1">(sym </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef) {</span>
                        <span class="s3">var </span><span class="s1">def = sym.definition();</span>
                        <span class="s3">var </span><span class="s1">in_use = def.id </span><span class="s3">in </span><span class="s1">in_use_ids;</span>
                        <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Assign) {</span>
                            <span class="s3">if </span><span class="s1">(!in_use || def.id </span><span class="s3">in </span><span class="s1">fixed_ids &amp;&amp; fixed_ids[def.id] !== node) {</span>
                                <span class="s3">return </span><span class="s1">maintain_this_binding(parent, node, node.right.transform(tt));</span>
                            <span class="s1">}</span>
                        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(!in_use) </span><span class="s3">return </span><span class="s1">make_node(AST_Number, node, {</span>
                            <span class="s1">value: </span><span class="s4">0</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s3">if </span><span class="s1">(scope !== self) </span><span class="s3">return</span><span class="s1">;</span>
                <span class="s3">if </span><span class="s1">(node.name</span>
                    <span class="s1">&amp;&amp; (!compressor.option(</span><span class="s2">&quot;keep_classnames&quot;</span><span class="s1">) &amp;&amp; node </span><span class="s3">instanceof </span><span class="s1">AST_ClassExpression</span>
                        <span class="s1">|| !compressor.option(</span><span class="s2">&quot;keep_fnames&quot;</span><span class="s1">) &amp;&amp; node </span><span class="s3">instanceof </span><span class="s1">AST_Function)) {</span>
                    <span class="s3">var </span><span class="s1">def = node.name.definition();</span>
                    <span class="s0">// any declarations with same name will overshadow</span>
                    <span class="s0">// name of this anonymous function and can therefore</span>
                    <span class="s0">// never be used anywhere</span>
                    <span class="s3">if </span><span class="s1">(!(def.id </span><span class="s3">in </span><span class="s1">in_use_ids) || def.orig.length &gt; </span><span class="s4">1</span><span class="s1">)</span>
                        <span class="s1">node.name = </span><span class="s3">null</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Lambda &amp;&amp; !(node </span><span class="s3">instanceof </span><span class="s1">AST_Accessor)) {</span>
                    <span class="s3">var </span><span class="s1">trim = !compressor.option(</span><span class="s2">&quot;keep_fargs&quot;</span><span class="s1">);</span>
                    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">a = node.argnames, i = a.length; --i &gt;= </span><span class="s4">0</span><span class="s1">;) {</span>
                        <span class="s3">var </span><span class="s1">sym = a[i];</span>
                        <span class="s3">if </span><span class="s1">(sym </span><span class="s3">instanceof </span><span class="s1">AST_Expansion) {</span>
                            <span class="s1">sym = sym.expression;</span>
                        <span class="s1">}</span>
                        <span class="s3">if </span><span class="s1">(sym </span><span class="s3">instanceof </span><span class="s1">AST_DefaultAssign) {</span>
                            <span class="s1">sym = sym.left;</span>
                        <span class="s1">}</span>
                        <span class="s0">// Do not drop destructuring arguments.</span>
                        <span class="s0">// They constitute a type assertion, so dropping</span>
                        <span class="s0">// them would stop that TypeError which would happen</span>
                        <span class="s0">// if someone called it with an incorrectly formatted</span>
                        <span class="s0">// parameter.</span>
                        <span class="s3">if </span><span class="s1">(!(sym </span><span class="s3">instanceof </span><span class="s1">AST_Destructuring) &amp;&amp; !(sym.definition().id </span><span class="s3">in </span><span class="s1">in_use_ids)) {</span>
                            <span class="s1">sym.__unused = </span><span class="s3">true</span><span class="s1">;</span>
                            <span class="s3">if </span><span class="s1">(trim) {</span>
                                <span class="s1">a.pop();</span>
                                <span class="s1">compressor[sym.unreferenced() ? </span><span class="s2">&quot;warn&quot; </span><span class="s1">: </span><span class="s2">&quot;info&quot;</span><span class="s1">](</span><span class="s2">&quot;Dropping unused function argument {name} [{file}:{line},{col}]&quot;</span><span class="s1">, template(sym));</span>
                            <span class="s1">}</span>
                        <span class="s1">}</span>
                        <span class="s3">else </span><span class="s1">{</span>
                            <span class="s1">trim = </span><span class="s3">false</span><span class="s1">;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s3">if </span><span class="s1">((node </span><span class="s3">instanceof </span><span class="s1">AST_Defun || node </span><span class="s3">instanceof </span><span class="s1">AST_DefClass) &amp;&amp; node !== self) {</span>
                    <span class="s3">var </span><span class="s1">def = node.name.definition();</span>
                    <span class="s3">var </span><span class="s1">keep = (def.id </span><span class="s3">in </span><span class="s1">in_use_ids) || !drop_funcs &amp;&amp; def.global;</span>
                    <span class="s3">if </span><span class="s1">(!keep) {</span>
                        <span class="s1">compressor[node.name.unreferenced() ? </span><span class="s2">&quot;warn&quot; </span><span class="s1">: </span><span class="s2">&quot;info&quot;</span><span class="s1">](</span><span class="s2">&quot;Dropping unused function {name} [{file}:{line},{col}]&quot;</span><span class="s1">, template(node.name));</span>
                        <span class="s1">def.eliminated++;</span>
                        <span class="s3">return </span><span class="s1">make_node(AST_EmptyStatement, node);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Definitions &amp;&amp; !(parent </span><span class="s3">instanceof </span><span class="s1">AST_ForIn &amp;&amp; parent.init === node)) {</span>
                    <span class="s3">var </span><span class="s1">drop_block = !(parent </span><span class="s3">instanceof </span><span class="s1">AST_Toplevel) &amp;&amp; !(node </span><span class="s3">instanceof </span><span class="s1">AST_Var);</span>
                    <span class="s0">// place uninitialized names at the start</span>
                    <span class="s3">var </span><span class="s1">body = [], head = [], tail = [];</span>
                    <span class="s0">// for unused names whose initialization has</span>
                    <span class="s0">// side effects, we can cascade the init. code</span>
                    <span class="s0">// into the next one, or next statement.</span>
                    <span class="s3">var </span><span class="s1">side_effects = [];</span>
                    <span class="s1">node.definitions.forEach(</span><span class="s3">function</span><span class="s1">(def) {</span>
                        <span class="s3">if </span><span class="s1">(def.value) def.value = def.value.transform(tt);</span>
                        <span class="s3">if </span><span class="s1">(def.name </span><span class="s3">instanceof </span><span class="s1">AST_Destructuring) </span><span class="s3">return </span><span class="s1">tail.push(def);</span>
                        <span class="s3">var </span><span class="s1">sym = def.name.definition();</span>
                        <span class="s3">if </span><span class="s1">(drop_block &amp;&amp; sym.global) </span><span class="s3">return </span><span class="s1">tail.push(def);</span>
                        <span class="s3">if </span><span class="s1">(!(drop_vars || drop_block) || sym.id </span><span class="s3">in </span><span class="s1">in_use_ids) {</span>
                            <span class="s3">if </span><span class="s1">(def.value &amp;&amp; sym.id </span><span class="s3">in </span><span class="s1">fixed_ids &amp;&amp; fixed_ids[sym.id] !== def) {</span>
                                <span class="s1">def.value = def.value.drop_side_effect_free(compressor);</span>
                            <span class="s1">}</span>
                            <span class="s3">if </span><span class="s1">(def.name </span><span class="s3">instanceof </span><span class="s1">AST_SymbolVar) {</span>
                                <span class="s3">var </span><span class="s1">var_defs = var_defs_by_id.get(sym.id);</span>
                                <span class="s3">if </span><span class="s1">(var_defs.length &gt; </span><span class="s4">1 </span><span class="s1">&amp;&amp; (!def.value || sym.orig.indexOf(def.name) &gt; sym.eliminated)) {</span>
                                    <span class="s1">compressor.warn(</span><span class="s2">&quot;Dropping duplicated definition of variable {name} [{file}:{line},{col}]&quot;</span><span class="s1">, template(def.name));</span>
                                    <span class="s3">if </span><span class="s1">(def.value) {</span>
                                        <span class="s3">var </span><span class="s1">ref = make_node(AST_SymbolRef, def.name, def.name);</span>
                                        <span class="s1">sym.references.push(ref);</span>
                                        <span class="s3">var </span><span class="s1">assign = make_node(AST_Assign, def, {</span>
                                            <span class="s1">operator: </span><span class="s2">&quot;=&quot;</span><span class="s1">,</span>
                                            <span class="s1">left: ref,</span>
                                            <span class="s1">right: def.value</span>
                                        <span class="s1">});</span>
                                        <span class="s3">if </span><span class="s1">(fixed_ids[sym.id] === def) {</span>
                                            <span class="s1">fixed_ids[sym.id] = assign;</span>
                                        <span class="s1">}</span>
                                        <span class="s1">side_effects.push(assign.transform(tt));</span>
                                    <span class="s1">}</span>
                                    <span class="s1">remove(var_defs, def);</span>
                                    <span class="s1">sym.eliminated++;</span>
                                    <span class="s3">return</span><span class="s1">;</span>
                                <span class="s1">}</span>
                            <span class="s1">}</span>
                            <span class="s3">if </span><span class="s1">(def.value) {</span>
                                <span class="s3">if </span><span class="s1">(side_effects.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                                    <span class="s3">if </span><span class="s1">(tail.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                                        <span class="s1">side_effects.push(def.value);</span>
                                        <span class="s1">def.value = make_sequence(def.value, side_effects);</span>
                                    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                                        <span class="s1">body.push(make_node(AST_SimpleStatement, node, {</span>
                                            <span class="s1">body: make_sequence(node, side_effects)</span>
                                        <span class="s1">}));</span>
                                    <span class="s1">}</span>
                                    <span class="s1">side_effects = [];</span>
                                <span class="s1">}</span>
                                <span class="s1">tail.push(def);</span>
                            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                                <span class="s1">head.push(def);</span>
                            <span class="s1">}</span>
                        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(sym.orig[</span><span class="s4">0</span><span class="s1">] </span><span class="s3">instanceof </span><span class="s1">AST_SymbolCatch) {</span>
                            <span class="s3">var </span><span class="s1">value = def.value &amp;&amp; def.value.drop_side_effect_free(compressor);</span>
                            <span class="s3">if </span><span class="s1">(value) side_effects.push(value);</span>
                            <span class="s1">def.value = </span><span class="s3">null</span><span class="s1">;</span>
                            <span class="s1">head.push(def);</span>
                        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                            <span class="s3">var </span><span class="s1">value = def.value &amp;&amp; def.value.drop_side_effect_free(compressor);</span>
                            <span class="s3">if </span><span class="s1">(value) {</span>
                                <span class="s1">compressor.warn(</span><span class="s2">&quot;Side effects in initialization of unused variable {name} [{file}:{line},{col}]&quot;</span><span class="s1">, template(def.name));</span>
                                <span class="s1">side_effects.push(value);</span>
                            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                                <span class="s1">compressor[def.name.unreferenced() ? </span><span class="s2">&quot;warn&quot; </span><span class="s1">: </span><span class="s2">&quot;info&quot;</span><span class="s1">](</span><span class="s2">&quot;Dropping unused variable {name} [{file}:{line},{col}]&quot;</span><span class="s1">, template(def.name));</span>
                            <span class="s1">}</span>
                            <span class="s1">sym.eliminated++;</span>
                        <span class="s1">}</span>
                    <span class="s1">});</span>
                    <span class="s3">if </span><span class="s1">(head.length &gt; </span><span class="s4">0 </span><span class="s1">|| tail.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                        <span class="s1">node.definitions = head.concat(tail);</span>
                        <span class="s1">body.push(node);</span>
                    <span class="s1">}</span>
                    <span class="s3">if </span><span class="s1">(side_effects.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                        <span class="s1">body.push(make_node(AST_SimpleStatement, node, {</span>
                            <span class="s1">body: make_sequence(node, side_effects)</span>
                        <span class="s1">}));</span>
                    <span class="s1">}</span>
                    <span class="s3">switch </span><span class="s1">(body.length) {</span>
                      <span class="s3">case </span><span class="s4">0</span><span class="s1">:</span>
                        <span class="s3">return </span><span class="s1">in_list ? MAP.skip : make_node(AST_EmptyStatement, node);</span>
                      <span class="s3">case </span><span class="s4">1</span><span class="s1">:</span>
                        <span class="s3">return </span><span class="s1">body[</span><span class="s4">0</span><span class="s1">];</span>
                      <span class="s3">default</span><span class="s1">:</span>
                        <span class="s3">return </span><span class="s1">in_list ? MAP.splice(body) : make_node(AST_BlockStatement, node, {</span>
                            <span class="s1">body: body</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s0">// certain combination of unused name + side effect leads to:</span>
                <span class="s0">//    https://github.com/mishoo/UglifyJS2/issues/44</span>
                <span class="s0">//    https://github.com/mishoo/UglifyJS2/issues/1830</span>
                <span class="s0">//    https://github.com/mishoo/UglifyJS2/issues/1838</span>
                <span class="s0">// that's an invalid AST.</span>
                <span class="s0">// We fix it at this stage by moving the `var` outside the `for`.</span>
                <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_For) {</span>
                    <span class="s1">descend(node, </span><span class="s3">this</span><span class="s1">);</span>
                    <span class="s3">var </span><span class="s1">block;</span>
                    <span class="s3">if </span><span class="s1">(node.init </span><span class="s3">instanceof </span><span class="s1">AST_BlockStatement) {</span>
                        <span class="s1">block = node.init;</span>
                        <span class="s1">node.init = block.body.pop();</span>
                        <span class="s1">block.body.push(node);</span>
                    <span class="s1">}</span>
                    <span class="s3">if </span><span class="s1">(node.init </span><span class="s3">instanceof </span><span class="s1">AST_SimpleStatement) {</span>
                        <span class="s1">node.init = node.init.body;</span>
                    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(is_empty(node.init)) {</span>
                        <span class="s1">node.init = </span><span class="s3">null</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s3">return </span><span class="s1">!block ? node : in_list ? MAP.splice(block.body) : block;</span>
                <span class="s1">}</span>
                <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_LabeledStatement &amp;&amp; node.body </span><span class="s3">instanceof </span><span class="s1">AST_For) {</span>
                    <span class="s1">descend(node, </span><span class="s3">this</span><span class="s1">);</span>
                    <span class="s3">if </span><span class="s1">(node.body </span><span class="s3">instanceof </span><span class="s1">AST_BlockStatement) {</span>
                        <span class="s3">var </span><span class="s1">block = node.body;</span>
                        <span class="s1">node.body = block.body.pop();</span>
                        <span class="s1">block.body.push(node);</span>
                        <span class="s3">return </span><span class="s1">in_list ? MAP.splice(block.body) : block;</span>
                    <span class="s1">}</span>
                    <span class="s3">return </span><span class="s1">node;</span>
                <span class="s1">}</span>
                <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_BlockStatement) {</span>
                    <span class="s1">descend(node, </span><span class="s3">this</span><span class="s1">);</span>
                    <span class="s3">if </span><span class="s1">(in_list &amp;&amp; all(node.body, can_be_evicted_from_block)) {</span>
                        <span class="s3">return </span><span class="s1">MAP.splice(node.body);</span>
                    <span class="s1">}</span>
                    <span class="s3">return </span><span class="s1">node;</span>
                <span class="s1">}</span>
                <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Scope) {</span>
                    <span class="s3">var </span><span class="s1">save_scope = scope;</span>
                    <span class="s1">scope = node;</span>
                    <span class="s1">descend(node, </span><span class="s3">this</span><span class="s1">);</span>
                    <span class="s1">scope = save_scope;</span>
                    <span class="s3">return </span><span class="s1">node;</span>
                <span class="s1">}</span>

                <span class="s3">function </span><span class="s1">template(sym) {</span>
                    <span class="s3">return </span><span class="s1">{</span>
                        <span class="s1">name : sym.name,</span>
                        <span class="s1">file : sym.start.file,</span>
                        <span class="s1">line : sym.start.line,</span>
                        <span class="s1">col  : sym.start.col</span>
                    <span class="s1">};</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">);</span>
        <span class="s1">self.transform(tt);</span>

        <span class="s3">function </span><span class="s1">scan_ref_scoped(node, descend) {</span>
            <span class="s3">var </span><span class="s1">node_def, sym = assign_as_unused(node);</span>
            <span class="s3">if </span><span class="s1">(sym </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef</span>
                <span class="s1">&amp;&amp; !is_ref_of(node.left, AST_SymbolBlockDeclaration)</span>
                <span class="s1">&amp;&amp; self.variables.get(sym.name) === (node_def = sym.definition())) {</span>
                <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Assign) {</span>
                    <span class="s1">node.right.walk(tw);</span>
                    <span class="s3">if </span><span class="s1">(node.left.fixed_value() === node.right) {</span>
                        <span class="s1">fixed_ids[node_def.id] = node;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s3">return true</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef) {</span>
                <span class="s1">node_def = node.definition();</span>
                <span class="s3">if </span><span class="s1">(!(node_def.id </span><span class="s3">in </span><span class="s1">in_use_ids)) {</span>
                    <span class="s1">in_use_ids[node_def.id] = </span><span class="s3">true</span><span class="s1">;</span>
                    <span class="s1">in_use.push(node_def);</span>
                    <span class="s3">if </span><span class="s1">(node_def = node_def.redefined()) {</span>
                        <span class="s1">in_use_ids[node_def.id] = </span><span class="s3">true</span><span class="s1">;</span>
                        <span class="s1">in_use.push(node_def);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s3">return true</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Scope) {</span>
                <span class="s3">var </span><span class="s1">save_scope = scope;</span>
                <span class="s1">scope = node;</span>
                <span class="s1">descend();</span>
                <span class="s1">scope = save_scope;</span>
                <span class="s3">return true</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">});</span>

    <span class="s1">AST_Scope.DEFMETHOD(</span><span class="s2">&quot;hoist_declarations&quot;</span><span class="s1">, </span><span class="s3">function</span><span class="s1">(compressor){</span>
        <span class="s3">var </span><span class="s1">self = </span><span class="s3">this</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s1">(compressor.has_directive(</span><span class="s2">&quot;use asm&quot;</span><span class="s1">)) </span><span class="s3">return </span><span class="s1">self;</span>
        <span class="s0">// Hoisting makes no sense in an arrow func</span>
        <span class="s3">if </span><span class="s1">(!Array.isArray(self.body)) </span><span class="s3">return </span><span class="s1">self;</span>

        <span class="s3">var </span><span class="s1">hoist_funs = compressor.option(</span><span class="s2">&quot;hoist_funs&quot;</span><span class="s1">);</span>
        <span class="s3">var </span><span class="s1">hoist_vars = compressor.option(</span><span class="s2">&quot;hoist_vars&quot;</span><span class="s1">);</span>

        <span class="s3">if </span><span class="s1">(hoist_funs || hoist_vars) {</span>
            <span class="s3">var </span><span class="s1">dirs = [];</span>
            <span class="s3">var </span><span class="s1">hoisted = [];</span>
            <span class="s3">var </span><span class="s1">vars = </span><span class="s3">new </span><span class="s1">Dictionary(), vars_found = </span><span class="s4">0</span><span class="s1">, var_decl = </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s0">// let's count var_decl first, we seem to waste a lot of</span>
            <span class="s0">// space if we hoist `var` when there's only one.</span>
            <span class="s1">self.walk(</span><span class="s3">new </span><span class="s1">TreeWalker(</span><span class="s3">function</span><span class="s1">(node){</span>
                <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Scope &amp;&amp; node !== self)</span>
                    <span class="s3">return true</span><span class="s1">;</span>
                <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Var) {</span>
                    <span class="s1">++var_decl;</span>
                    <span class="s3">return true</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}));</span>
            <span class="s1">hoist_vars = hoist_vars &amp;&amp; var_decl &gt; </span><span class="s4">1</span><span class="s1">;</span>
            <span class="s3">var </span><span class="s1">tt = </span><span class="s3">new </span><span class="s1">TreeTransformer(</span>
                <span class="s3">function </span><span class="s1">before(node) {</span>
                    <span class="s3">if </span><span class="s1">(node !== self) {</span>
                        <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Directive) {</span>
                            <span class="s1">dirs.push(node);</span>
                            <span class="s3">return </span><span class="s1">make_node(AST_EmptyStatement, node);</span>
                        <span class="s1">}</span>
                        <span class="s3">if </span><span class="s1">(hoist_funs &amp;&amp; node </span><span class="s3">instanceof </span><span class="s1">AST_Defun</span>
                            <span class="s1">&amp;&amp; !(tt.parent() </span><span class="s3">instanceof </span><span class="s1">AST_Export)</span>
                            <span class="s1">&amp;&amp; tt.parent() === self) {</span>
                            <span class="s1">hoisted.push(node);</span>
                            <span class="s3">return </span><span class="s1">make_node(AST_EmptyStatement, node);</span>
                        <span class="s1">}</span>
                        <span class="s3">if </span><span class="s1">(hoist_vars &amp;&amp; node </span><span class="s3">instanceof </span><span class="s1">AST_Var) {</span>
                            <span class="s1">node.definitions.forEach(</span><span class="s3">function</span><span class="s1">(def){</span>
                                <span class="s3">if </span><span class="s1">(def.name </span><span class="s3">instanceof </span><span class="s1">AST_Destructuring) </span><span class="s3">return</span><span class="s1">;</span>
                                <span class="s1">vars.set(def.name.name, def);</span>
                                <span class="s1">++vars_found;</span>
                            <span class="s1">});</span>
                            <span class="s3">var </span><span class="s1">seq = node.to_assignments(compressor);</span>
                            <span class="s3">var </span><span class="s1">p = tt.parent();</span>
                            <span class="s3">if </span><span class="s1">(p </span><span class="s3">instanceof </span><span class="s1">AST_ForIn &amp;&amp; p.init === node) {</span>
                                <span class="s3">if </span><span class="s1">(seq == </span><span class="s3">null</span><span class="s1">) {</span>
                                    <span class="s3">var </span><span class="s1">def = node.definitions[</span><span class="s4">0</span><span class="s1">].name;</span>
                                    <span class="s3">return </span><span class="s1">make_node(AST_SymbolRef, def, def);</span>
                                <span class="s1">}</span>
                                <span class="s3">return </span><span class="s1">seq;</span>
                            <span class="s1">}</span>
                            <span class="s3">if </span><span class="s1">(p </span><span class="s3">instanceof </span><span class="s1">AST_For &amp;&amp; p.init === node) {</span>
                                <span class="s3">return </span><span class="s1">seq;</span>
                            <span class="s1">}</span>
                            <span class="s3">if </span><span class="s1">(!seq) </span><span class="s3">return </span><span class="s1">make_node(AST_EmptyStatement, node);</span>
                            <span class="s3">return </span><span class="s1">make_node(AST_SimpleStatement, node, {</span>
                                <span class="s1">body: seq</span>
                            <span class="s1">});</span>
                        <span class="s1">}</span>
                        <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Scope)</span>
                            <span class="s3">return </span><span class="s1">node; </span><span class="s0">// to avoid descending in nested scopes</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">);</span>
            <span class="s1">self = self.transform(tt);</span>
            <span class="s3">if </span><span class="s1">(vars_found &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s0">// collect only vars which don't show up in self's arguments list</span>
                <span class="s3">var </span><span class="s1">defs = [];</span>
                <span class="s1">vars.each(</span><span class="s3">function</span><span class="s1">(def, name){</span>
                    <span class="s3">if </span><span class="s1">(self </span><span class="s3">instanceof </span><span class="s1">AST_Lambda</span>
                        <span class="s1">&amp;&amp; find_if(</span><span class="s3">function</span><span class="s1">(x){ </span><span class="s3">return </span><span class="s1">x.name == def.name.name },</span>
                                   <span class="s1">self.args_as_names())) {</span>
                        <span class="s1">vars.del(name);</span>
                    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                        <span class="s1">def = def.clone();</span>
                        <span class="s1">def.value = </span><span class="s3">null</span><span class="s1">;</span>
                        <span class="s1">defs.push(def);</span>
                        <span class="s1">vars.set(name, def);</span>
                    <span class="s1">}</span>
                <span class="s1">});</span>
                <span class="s3">if </span><span class="s1">(defs.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                    <span class="s0">// try to merge in assignments</span>
                    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; self.body.length;) {</span>
                        <span class="s3">if </span><span class="s1">(self.body[i] </span><span class="s3">instanceof </span><span class="s1">AST_SimpleStatement) {</span>
                            <span class="s3">var </span><span class="s1">expr = self.body[i].body, sym, assign;</span>
                            <span class="s3">if </span><span class="s1">(expr </span><span class="s3">instanceof </span><span class="s1">AST_Assign</span>
                                <span class="s1">&amp;&amp; expr.operator == </span><span class="s2">&quot;=&quot;</span>
                                <span class="s1">&amp;&amp; (sym = expr.left) </span><span class="s3">instanceof </span><span class="s1">AST_Symbol</span>
                                <span class="s1">&amp;&amp; vars.has(sym.name))</span>
                            <span class="s1">{</span>
                                <span class="s3">var </span><span class="s1">def = vars.get(sym.name);</span>
                                <span class="s3">if </span><span class="s1">(def.value) </span><span class="s3">break</span><span class="s1">;</span>
                                <span class="s1">def.value = expr.right;</span>
                                <span class="s1">remove(defs, def);</span>
                                <span class="s1">defs.push(def);</span>
                                <span class="s1">self.body.splice(i, </span><span class="s4">1</span><span class="s1">);</span>
                                <span class="s3">continue</span><span class="s1">;</span>
                            <span class="s1">}</span>
                            <span class="s3">if </span><span class="s1">(expr </span><span class="s3">instanceof </span><span class="s1">AST_Sequence</span>
                                <span class="s1">&amp;&amp; (assign = expr.expressions[</span><span class="s4">0</span><span class="s1">]) </span><span class="s3">instanceof </span><span class="s1">AST_Assign</span>
                                <span class="s1">&amp;&amp; assign.operator == </span><span class="s2">&quot;=&quot;</span>
                                <span class="s1">&amp;&amp; (sym = assign.left) </span><span class="s3">instanceof </span><span class="s1">AST_Symbol</span>
                                <span class="s1">&amp;&amp; vars.has(sym.name))</span>
                            <span class="s1">{</span>
                                <span class="s3">var </span><span class="s1">def = vars.get(sym.name);</span>
                                <span class="s3">if </span><span class="s1">(def.value) </span><span class="s3">break</span><span class="s1">;</span>
                                <span class="s1">def.value = assign.right;</span>
                                <span class="s1">remove(defs, def);</span>
                                <span class="s1">defs.push(def);</span>
                                <span class="s1">self.body[i].body = make_sequence(expr, expr.expressions.slice(</span><span class="s4">1</span><span class="s1">));</span>
                                <span class="s3">continue</span><span class="s1">;</span>
                            <span class="s1">}</span>
                        <span class="s1">}</span>
                        <span class="s3">if </span><span class="s1">(self.body[i] </span><span class="s3">instanceof </span><span class="s1">AST_EmptyStatement) {</span>
                            <span class="s1">self.body.splice(i, </span><span class="s4">1</span><span class="s1">);</span>
                            <span class="s3">continue</span><span class="s1">;</span>
                        <span class="s1">}</span>
                        <span class="s3">if </span><span class="s1">(self.body[i] </span><span class="s3">instanceof </span><span class="s1">AST_BlockStatement) {</span>
                            <span class="s3">var </span><span class="s1">tmp = [ i, </span><span class="s4">1 </span><span class="s1">].concat(self.body[i].body);</span>
                            <span class="s1">self.body.splice.apply(self.body, tmp);</span>
                            <span class="s3">continue</span><span class="s1">;</span>
                        <span class="s1">}</span>
                        <span class="s3">break</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s1">defs = make_node(AST_Var, self, {</span>
                        <span class="s1">definitions: defs</span>
                    <span class="s1">});</span>
                    <span class="s1">hoisted.push(defs);</span>
                <span class="s1">};</span>
            <span class="s1">}</span>
            <span class="s1">self.body = dirs.concat(hoisted, self.body);</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">self;</span>
    <span class="s1">});</span>

    <span class="s1">AST_Scope.DEFMETHOD(</span><span class="s2">&quot;var_names&quot;</span><span class="s1">, </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">var </span><span class="s1">var_names = </span><span class="s3">this</span><span class="s1">._var_names;</span>
        <span class="s3">if </span><span class="s1">(!var_names) {</span>
            <span class="s3">this</span><span class="s1">._var_names = var_names = Object.create(</span><span class="s3">null</span><span class="s1">);</span>
            <span class="s3">this</span><span class="s1">.enclosed.forEach(</span><span class="s3">function</span><span class="s1">(def) {</span>
                <span class="s1">var_names[def.name] = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s1">});</span>
            <span class="s3">this</span><span class="s1">.variables.each(</span><span class="s3">function</span><span class="s1">(def, name) {</span>
                <span class="s1">var_names[name] = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">var_names;</span>
    <span class="s1">});</span>

    <span class="s1">AST_Scope.DEFMETHOD(</span><span class="s2">&quot;make_var_name&quot;</span><span class="s1">, </span><span class="s3">function</span><span class="s1">(prefix) {</span>
        <span class="s3">var </span><span class="s1">var_names = </span><span class="s3">this</span><span class="s1">.var_names();</span>
        <span class="s1">prefix = prefix.replace(/[^a-z_$]+/ig, </span><span class="s2">&quot;_&quot;</span><span class="s1">);</span>
        <span class="s3">var </span><span class="s1">name = prefix;</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; var_names[name]; i++) name = prefix + </span><span class="s2">&quot;$&quot; </span><span class="s1">+ i;</span>
        <span class="s1">var_names[name] = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s3">return </span><span class="s1">name;</span>
    <span class="s1">});</span>

    <span class="s1">AST_Scope.DEFMETHOD(</span><span class="s2">&quot;hoist_properties&quot;</span><span class="s1">, </span><span class="s3">function</span><span class="s1">(compressor){</span>
        <span class="s3">var </span><span class="s1">self = </span><span class="s3">this</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s1">(!compressor.option(</span><span class="s2">&quot;hoist_props&quot;</span><span class="s1">) || compressor.has_directive(</span><span class="s2">&quot;use asm&quot;</span><span class="s1">)) </span><span class="s3">return </span><span class="s1">self;</span>
        <span class="s3">var </span><span class="s1">top_retain = self </span><span class="s3">instanceof </span><span class="s1">AST_Toplevel &amp;&amp; compressor.top_retain || return_false;</span>
        <span class="s3">var </span><span class="s1">defs_by_id = Object.create(</span><span class="s3">null</span><span class="s1">);</span>
        <span class="s3">var </span><span class="s1">tt = </span><span class="s3">new </span><span class="s1">TreeTransformer(</span><span class="s3">function</span><span class="s1">(node, descend) {</span>
            <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Definitions &amp;&amp; tt.parent() </span><span class="s3">instanceof </span><span class="s1">AST_Export) </span><span class="s3">return </span><span class="s1">node;</span>
            <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_VarDef) {</span>
                <span class="s3">var </span><span class="s1">sym = node.name, def, value;</span>
                <span class="s3">if </span><span class="s1">(sym.scope === self</span>
                    <span class="s1">&amp;&amp; (def = sym.definition()).escaped != </span><span class="s4">1</span>
                    <span class="s1">&amp;&amp; !def.single_use</span>
                    <span class="s1">&amp;&amp; !def.direct_access</span>
                    <span class="s1">&amp;&amp; !compressor.exposed(def)</span>
                    <span class="s1">&amp;&amp; !top_retain(def)</span>
                    <span class="s1">&amp;&amp; (value = sym.fixed_value()) === node.value</span>
                    <span class="s1">&amp;&amp; value </span><span class="s3">instanceof </span><span class="s1">AST_Object) {</span>
                    <span class="s1">descend(node, </span><span class="s3">this</span><span class="s1">);</span>
                    <span class="s3">var </span><span class="s1">defs = </span><span class="s3">new </span><span class="s1">Dictionary();</span>
                    <span class="s3">var </span><span class="s1">assignments = [];</span>
                    <span class="s1">value.properties.forEach(</span><span class="s3">function</span><span class="s1">(prop) {</span>
                        <span class="s1">assignments.push(make_node(AST_VarDef, node, {</span>
                            <span class="s1">name: make_sym(prop.key),</span>
                            <span class="s1">value: prop.value</span>
                        <span class="s1">}));</span>
                    <span class="s1">});</span>
                    <span class="s1">defs_by_id[def.id] = defs;</span>
                    <span class="s3">return </span><span class="s1">MAP.splice(assignments);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_PropAccess &amp;&amp; node.expression </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef) {</span>
                <span class="s3">var </span><span class="s1">defs = defs_by_id[node.expression.definition().id];</span>
                <span class="s3">if </span><span class="s1">(defs) {</span>
                    <span class="s3">var </span><span class="s1">def = defs.get(get_value(node.property));</span>
                    <span class="s3">var </span><span class="s1">sym = make_node(AST_SymbolRef, node, {</span>
                        <span class="s1">name: def.name,</span>
                        <span class="s1">scope: node.expression.scope,</span>
                        <span class="s1">thedef: def</span>
                    <span class="s1">});</span>
                    <span class="s1">sym.reference({});</span>
                    <span class="s3">return </span><span class="s1">sym;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>

            <span class="s3">function </span><span class="s1">make_sym(key) {</span>
                <span class="s3">var </span><span class="s1">new_var = make_node(sym.CTOR, sym, {</span>
                    <span class="s1">name: self.make_var_name(sym.name + </span><span class="s2">&quot;_&quot; </span><span class="s1">+ key),</span>
                    <span class="s1">scope: self</span>
                <span class="s1">});</span>
                <span class="s3">var </span><span class="s1">def = self.def_variable(new_var);</span>
                <span class="s1">defs.set(key, def);</span>
                <span class="s1">self.enclosed.push(def);</span>
                <span class="s3">return </span><span class="s1">new_var;</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
        <span class="s3">return </span><span class="s1">self.transform(tt);</span>
    <span class="s1">});</span>

    <span class="s0">// drop_side_effect_free()</span>
    <span class="s0">// remove side-effect-free parts which only affects return value</span>
    <span class="s1">(</span><span class="s3">function</span><span class="s1">(def){</span>
        <span class="s0">// Drop side-effect-free elements from an array of expressions.</span>
        <span class="s0">// Returns an array of expressions with side-effects or null</span>
        <span class="s0">// if all elements were dropped. Note: original array may be</span>
        <span class="s0">// returned if nothing changed.</span>
        <span class="s3">function </span><span class="s1">trim(nodes, compressor, first_in_statement) {</span>
            <span class="s3">var </span><span class="s1">len = nodes.length;</span>
            <span class="s3">if </span><span class="s1">(!len) </span><span class="s3">return null</span><span class="s1">;</span>
            <span class="s3">var </span><span class="s1">ret = [], changed = </span><span class="s3">false</span><span class="s1">;</span>
            <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; len; i++) {</span>
                <span class="s3">var </span><span class="s1">node = nodes[i].drop_side_effect_free(compressor, first_in_statement);</span>
                <span class="s1">changed |= node !== nodes[i];</span>
                <span class="s3">if </span><span class="s1">(node) {</span>
                    <span class="s1">ret.push(node);</span>
                    <span class="s1">first_in_statement = </span><span class="s3">false</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s3">return </span><span class="s1">changed ? ret.length ? ret : </span><span class="s3">null </span><span class="s1">: nodes;</span>
        <span class="s1">}</span>

        <span class="s1">def(AST_Node, return_this);</span>
        <span class="s1">def(AST_Constant, return_null);</span>
        <span class="s1">def(AST_This, return_null);</span>
        <span class="s1">def(AST_Call, </span><span class="s3">function</span><span class="s1">(compressor, first_in_statement){</span>
            <span class="s3">if </span><span class="s1">(!</span><span class="s3">this</span><span class="s1">.is_expr_pure(compressor)) {</span>
                <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.expression.is_call_pure(compressor)) {</span>
                    <span class="s3">var </span><span class="s1">exprs = </span><span class="s3">this</span><span class="s1">.args.slice();</span>
                    <span class="s1">exprs.unshift(</span><span class="s3">this</span><span class="s1">.expression.expression);</span>
                    <span class="s1">exprs = trim(exprs, compressor, first_in_statement);</span>
                    <span class="s3">return </span><span class="s1">exprs &amp;&amp; make_sequence(</span><span class="s3">this</span><span class="s1">, exprs);</span>
                <span class="s1">}</span>
                <span class="s3">if </span><span class="s1">(is_func_expr(</span><span class="s3">this</span><span class="s1">.expression)</span>
                    <span class="s1">&amp;&amp; (!</span><span class="s3">this</span><span class="s1">.expression.name || !</span><span class="s3">this</span><span class="s1">.expression.name.definition().references.length)) {</span>
                    <span class="s3">var </span><span class="s1">node = </span><span class="s3">this</span><span class="s1">.clone();</span>
                    <span class="s1">node.expression.process_expression(</span><span class="s3">false</span><span class="s1">, compressor);</span>
                    <span class="s3">return </span><span class="s1">node;</span>
                <span class="s1">}</span>
                <span class="s3">return this</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.pure) {</span>
                <span class="s1">compressor.warn(</span><span class="s2">&quot;Dropping __PURE__ call [{file}:{line},{col}]&quot;</span><span class="s1">, </span><span class="s3">this</span><span class="s1">.start);</span>
            <span class="s1">}</span>
            <span class="s3">var </span><span class="s1">args = trim(</span><span class="s3">this</span><span class="s1">.args, compressor, first_in_statement);</span>
            <span class="s3">return </span><span class="s1">args &amp;&amp; make_sequence(</span><span class="s3">this</span><span class="s1">, args);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Accessor, return_null);</span>
        <span class="s1">def(AST_Function, return_null);</span>
        <span class="s1">def(AST_Arrow, return_null);</span>
        <span class="s1">def(AST_ClassExpression, return_null);</span>
        <span class="s1">def(AST_Binary, </span><span class="s3">function</span><span class="s1">(compressor, first_in_statement){</span>
            <span class="s3">var </span><span class="s1">right = </span><span class="s3">this</span><span class="s1">.right.drop_side_effect_free(compressor);</span>
            <span class="s3">if </span><span class="s1">(!right) </span><span class="s3">return this</span><span class="s1">.left.drop_side_effect_free(compressor, first_in_statement);</span>
            <span class="s3">if </span><span class="s1">(lazy_op(</span><span class="s3">this</span><span class="s1">.operator)) {</span>
                <span class="s3">if </span><span class="s1">(right === </span><span class="s3">this</span><span class="s1">.right) </span><span class="s3">return this</span><span class="s1">;</span>
                <span class="s3">var </span><span class="s1">node = </span><span class="s3">this</span><span class="s1">.clone();</span>
                <span class="s1">node.right = right;</span>
                <span class="s3">return </span><span class="s1">node;</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s3">var </span><span class="s1">left = </span><span class="s3">this</span><span class="s1">.left.drop_side_effect_free(compressor, first_in_statement);</span>
                <span class="s3">if </span><span class="s1">(!left) </span><span class="s3">return this</span><span class="s1">.right.drop_side_effect_free(compressor, first_in_statement);</span>
                <span class="s3">return </span><span class="s1">make_sequence(</span><span class="s3">this</span><span class="s1">, [ left, right ]);</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Assign, </span><span class="s3">function</span><span class="s1">(compressor){</span>
            <span class="s3">var </span><span class="s1">left = </span><span class="s3">this</span><span class="s1">.left;</span>
            <span class="s3">if </span><span class="s1">(left.has_side_effects(compressor)</span>
                <span class="s1">|| compressor.has_directive(</span><span class="s2">&quot;use strict&quot;</span><span class="s1">)</span>
                    <span class="s1">&amp;&amp; left </span><span class="s3">instanceof </span><span class="s1">AST_PropAccess</span>
                    <span class="s1">&amp;&amp; left.expression.is_constant()) {</span>
                <span class="s3">return this</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">this</span><span class="s1">.write_only = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s3">while </span><span class="s1">(left </span><span class="s3">instanceof </span><span class="s1">AST_PropAccess) {</span>
                <span class="s1">left = left.expression;</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(left.is_constant_expression(compressor.find_parent(AST_Scope))) {</span>
                <span class="s3">return this</span><span class="s1">.right.drop_side_effect_free(compressor);</span>
            <span class="s1">}</span>
            <span class="s3">return this</span><span class="s1">;</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Conditional, </span><span class="s3">function</span><span class="s1">(compressor){</span>
            <span class="s3">var </span><span class="s1">consequent = </span><span class="s3">this</span><span class="s1">.consequent.drop_side_effect_free(compressor);</span>
            <span class="s3">var </span><span class="s1">alternative = </span><span class="s3">this</span><span class="s1">.alternative.drop_side_effect_free(compressor);</span>
            <span class="s3">if </span><span class="s1">(consequent === </span><span class="s3">this</span><span class="s1">.consequent &amp;&amp; alternative === </span><span class="s3">this</span><span class="s1">.alternative) </span><span class="s3">return this</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(!consequent) </span><span class="s3">return </span><span class="s1">alternative ? make_node(AST_Binary, </span><span class="s3">this</span><span class="s1">, {</span>
                <span class="s1">operator: </span><span class="s2">&quot;||&quot;</span><span class="s1">,</span>
                <span class="s1">left: </span><span class="s3">this</span><span class="s1">.condition,</span>
                <span class="s1">right: alternative</span>
            <span class="s1">}) : </span><span class="s3">this</span><span class="s1">.condition.drop_side_effect_free(compressor);</span>
            <span class="s3">if </span><span class="s1">(!alternative) </span><span class="s3">return </span><span class="s1">make_node(AST_Binary, </span><span class="s3">this</span><span class="s1">, {</span>
                <span class="s1">operator: </span><span class="s2">&quot;&amp;&amp;&quot;</span><span class="s1">,</span>
                <span class="s1">left: </span><span class="s3">this</span><span class="s1">.condition,</span>
                <span class="s1">right: consequent</span>
            <span class="s1">});</span>
            <span class="s3">var </span><span class="s1">node = </span><span class="s3">this</span><span class="s1">.clone();</span>
            <span class="s1">node.consequent = consequent;</span>
            <span class="s1">node.alternative = alternative;</span>
            <span class="s3">return </span><span class="s1">node;</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Unary, </span><span class="s3">function</span><span class="s1">(compressor, first_in_statement){</span>
            <span class="s3">if </span><span class="s1">(unary_side_effects(</span><span class="s3">this</span><span class="s1">.operator)) {</span>
                <span class="s3">this</span><span class="s1">.write_only = !</span><span class="s3">this</span><span class="s1">.expression.has_side_effects(compressor);</span>
                <span class="s3">return this</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.operator == </span><span class="s2">&quot;typeof&quot; </span><span class="s1">&amp;&amp; </span><span class="s3">this</span><span class="s1">.expression </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef) </span><span class="s3">return null</span><span class="s1">;</span>
            <span class="s3">var </span><span class="s1">expression = </span><span class="s3">this</span><span class="s1">.expression.drop_side_effect_free(compressor, first_in_statement);</span>
            <span class="s3">if </span><span class="s1">(first_in_statement &amp;&amp; expression &amp;&amp; is_iife_call(expression)) {</span>
                <span class="s3">if </span><span class="s1">(expression === </span><span class="s3">this</span><span class="s1">.expression &amp;&amp; </span><span class="s3">this</span><span class="s1">.operator == </span><span class="s2">&quot;!&quot;</span><span class="s1">) </span><span class="s3">return this</span><span class="s1">;</span>
                <span class="s3">return </span><span class="s1">expression.negate(compressor, first_in_statement);</span>
            <span class="s1">}</span>
            <span class="s3">return </span><span class="s1">expression;</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_SymbolRef, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
            <span class="s3">return this</span><span class="s1">.is_declared(compressor) ? </span><span class="s3">null </span><span class="s1">: </span><span class="s3">this</span><span class="s1">;</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Object, </span><span class="s3">function</span><span class="s1">(compressor, first_in_statement){</span>
            <span class="s3">var </span><span class="s1">values = trim(</span><span class="s3">this</span><span class="s1">.properties, compressor, first_in_statement);</span>
            <span class="s3">return </span><span class="s1">values &amp;&amp; make_sequence(</span><span class="s3">this</span><span class="s1">, values);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_ObjectProperty, </span><span class="s3">function</span><span class="s1">(compressor, first_in_statement){</span>
            <span class="s3">return this</span><span class="s1">.value.drop_side_effect_free(compressor, first_in_statement);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Array, </span><span class="s3">function</span><span class="s1">(compressor, first_in_statement){</span>
            <span class="s3">var </span><span class="s1">values = trim(</span><span class="s3">this</span><span class="s1">.elements, compressor, first_in_statement);</span>
            <span class="s3">return </span><span class="s1">values &amp;&amp; make_sequence(</span><span class="s3">this</span><span class="s1">, values);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Dot, </span><span class="s3">function</span><span class="s1">(compressor, first_in_statement){</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.expression.may_throw_on_access(compressor)) </span><span class="s3">return this</span><span class="s1">;</span>
            <span class="s3">return this</span><span class="s1">.expression.drop_side_effect_free(compressor, first_in_statement);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Sub, </span><span class="s3">function</span><span class="s1">(compressor, first_in_statement){</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.expression.may_throw_on_access(compressor)) </span><span class="s3">return this</span><span class="s1">;</span>
            <span class="s3">var </span><span class="s1">expression = </span><span class="s3">this</span><span class="s1">.expression.drop_side_effect_free(compressor, first_in_statement);</span>
            <span class="s3">if </span><span class="s1">(!expression) </span><span class="s3">return this</span><span class="s1">.property.drop_side_effect_free(compressor, first_in_statement);</span>
            <span class="s3">var </span><span class="s1">property = </span><span class="s3">this</span><span class="s1">.property.drop_side_effect_free(compressor);</span>
            <span class="s3">if </span><span class="s1">(!property) </span><span class="s3">return </span><span class="s1">expression;</span>
            <span class="s3">return </span><span class="s1">make_sequence(</span><span class="s3">this</span><span class="s1">, [ expression, property ]);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Sequence, </span><span class="s3">function</span><span class="s1">(compressor){</span>
            <span class="s3">var </span><span class="s1">last = </span><span class="s3">this</span><span class="s1">.tail_node();</span>
            <span class="s3">var </span><span class="s1">expr = last.drop_side_effect_free(compressor);</span>
            <span class="s3">if </span><span class="s1">(expr === last) </span><span class="s3">return this</span><span class="s1">;</span>
            <span class="s3">var </span><span class="s1">expressions = </span><span class="s3">this</span><span class="s1">.expressions.slice(</span><span class="s4">0</span><span class="s1">, -</span><span class="s4">1</span><span class="s1">);</span>
            <span class="s3">if </span><span class="s1">(expr) expressions.push(expr);</span>
            <span class="s3">return </span><span class="s1">make_sequence(</span><span class="s3">this</span><span class="s1">, expressions);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_Expansion, </span><span class="s3">function</span><span class="s1">(compressor, first_in_statement){</span>
            <span class="s3">return this</span><span class="s1">.expression.drop_side_effect_free(compressor, first_in_statement);</span>
        <span class="s1">});</span>
        <span class="s1">def(AST_TemplateSegment, return_null);</span>
        <span class="s1">def(AST_TemplateString, </span><span class="s3">function</span><span class="s1">(compressor){</span>
            <span class="s3">var </span><span class="s1">values = trim(</span><span class="s3">this</span><span class="s1">.segments, compressor, first_in_statement);</span>
            <span class="s3">return </span><span class="s1">values &amp;&amp; make_sequence(</span><span class="s3">this</span><span class="s1">, values);</span>
        <span class="s1">});</span>
    <span class="s1">})(</span><span class="s3">function</span><span class="s1">(node, func){</span>
        <span class="s1">node.DEFMETHOD(</span><span class="s2">&quot;drop_side_effect_free&quot;</span><span class="s1">, func);</span>
    <span class="s1">});</span>

    <span class="s1">OPT(AST_SimpleStatement, </span><span class="s3">function</span><span class="s1">(self, compressor){</span>
        <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;side_effects&quot;</span><span class="s1">)) {</span>
            <span class="s3">var </span><span class="s1">body = self.body;</span>
            <span class="s3">var </span><span class="s1">node = body.drop_side_effect_free(compressor, </span><span class="s3">true</span><span class="s1">);</span>
            <span class="s3">if </span><span class="s1">(!node) {</span>
                <span class="s1">compressor.warn(</span><span class="s2">&quot;Dropping side-effect-free statement [{file}:{line},{col}]&quot;</span><span class="s1">, self.start);</span>
                <span class="s3">return </span><span class="s1">make_node(AST_EmptyStatement, self);</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(node !== body) {</span>
                <span class="s3">return </span><span class="s1">make_node(AST_SimpleStatement, self, { body: node });</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">self;</span>
    <span class="s1">});</span>

    <span class="s1">OPT(AST_While, </span><span class="s3">function</span><span class="s1">(self, compressor){</span>
        <span class="s3">return </span><span class="s1">compressor.option(</span><span class="s2">&quot;loops&quot;</span><span class="s1">) ? make_node(AST_For, self, self).optimize(compressor) : self;</span>
    <span class="s1">});</span>

    <span class="s1">OPT(AST_Do, </span><span class="s3">function</span><span class="s1">(self, compressor){</span>
        <span class="s3">if </span><span class="s1">(!compressor.option(</span><span class="s2">&quot;loops&quot;</span><span class="s1">)) </span><span class="s3">return </span><span class="s1">self;</span>
        <span class="s3">var </span><span class="s1">cond = self.condition.tail_node().evaluate(compressor);</span>
        <span class="s3">if </span><span class="s1">(!(cond </span><span class="s3">instanceof </span><span class="s1">AST_Node)) {</span>
            <span class="s3">if </span><span class="s1">(cond) </span><span class="s3">return </span><span class="s1">make_node(AST_For, self, {</span>
                <span class="s1">body: make_node(AST_BlockStatement, self.body, {</span>
                    <span class="s1">body: [</span>
                        <span class="s1">self.body,</span>
                        <span class="s1">make_node(AST_SimpleStatement, self.condition, {</span>
                            <span class="s1">body: self.condition</span>
                        <span class="s1">})</span>
                    <span class="s1">]</span>
                <span class="s1">})</span>
            <span class="s1">}).optimize(compressor);</span>
            <span class="s3">var </span><span class="s1">has_loop_control = </span><span class="s3">false</span><span class="s1">;</span>
            <span class="s3">var </span><span class="s1">tw = </span><span class="s3">new </span><span class="s1">TreeWalker(</span><span class="s3">function</span><span class="s1">(node) {</span>
                <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Scope || has_loop_control) </span><span class="s3">return true</span><span class="s1">;</span>
                <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_LoopControl &amp;&amp; tw.loopcontrol_target(node) === self)</span>
                    <span class="s3">return </span><span class="s1">has_loop_control = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s1">});</span>
            <span class="s3">var </span><span class="s1">parent = compressor.parent();</span>
            <span class="s1">(parent </span><span class="s3">instanceof </span><span class="s1">AST_LabeledStatement ? parent : self).walk(tw);</span>
            <span class="s3">if </span><span class="s1">(!has_loop_control) </span><span class="s3">return </span><span class="s1">make_node(AST_BlockStatement, self.body, {</span>
                <span class="s1">body: [</span>
                    <span class="s1">self.body,</span>
                    <span class="s1">make_node(AST_SimpleStatement, self.condition, {</span>
                        <span class="s1">body: self.condition</span>
                    <span class="s1">})</span>
                <span class="s1">]</span>
            <span class="s1">}).optimize(compressor);</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">self;</span>
    <span class="s1">});</span>

    <span class="s3">function </span><span class="s1">if_break_in_loop(self, compressor) {</span>
        <span class="s3">var </span><span class="s1">first = self.body </span><span class="s3">instanceof </span><span class="s1">AST_BlockStatement ? self.body.body[</span><span class="s4">0</span><span class="s1">] : self.body;</span>
        <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;dead_code&quot;</span><span class="s1">) &amp;&amp; is_break(first)) {</span>
            <span class="s3">var </span><span class="s1">body = [];</span>
            <span class="s3">if </span><span class="s1">(self.init </span><span class="s3">instanceof </span><span class="s1">AST_Statement) {</span>
                <span class="s1">body.push(self.init);</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(self.init) {</span>
                <span class="s1">body.push(make_node(AST_SimpleStatement, self.init, {</span>
                    <span class="s1">body: self.init</span>
                <span class="s1">}));</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(self.condition) {</span>
                <span class="s1">body.push(make_node(AST_SimpleStatement, self.condition, {</span>
                    <span class="s1">body: self.condition</span>
                <span class="s1">}));</span>
            <span class="s1">}</span>
            <span class="s1">extract_declarations_from_unreachable_code(compressor, self.body, body);</span>
            <span class="s3">return </span><span class="s1">make_node(AST_BlockStatement, self, {</span>
                <span class="s1">body: body</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(first </span><span class="s3">instanceof </span><span class="s1">AST_If) {</span>
            <span class="s3">if </span><span class="s1">(is_break(first.body)) {</span>
                <span class="s3">if </span><span class="s1">(self.condition) {</span>
                    <span class="s1">self.condition = make_node(AST_Binary, self.condition, {</span>
                        <span class="s1">left: self.condition,</span>
                        <span class="s1">operator: </span><span class="s2">&quot;&amp;&amp;&quot;</span><span class="s1">,</span>
                        <span class="s1">right: first.condition.negate(compressor),</span>
                    <span class="s1">});</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s1">self.condition = first.condition.negate(compressor);</span>
                <span class="s1">}</span>
                <span class="s1">drop_it(first.alternative);</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(is_break(first.alternative)) {</span>
                <span class="s3">if </span><span class="s1">(self.condition) {</span>
                    <span class="s1">self.condition = make_node(AST_Binary, self.condition, {</span>
                        <span class="s1">left: self.condition,</span>
                        <span class="s1">operator: </span><span class="s2">&quot;&amp;&amp;&quot;</span><span class="s1">,</span>
                        <span class="s1">right: first.condition,</span>
                    <span class="s1">});</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s1">self.condition = first.condition;</span>
                <span class="s1">}</span>
                <span class="s1">drop_it(first.body);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">self;</span>

        <span class="s3">function </span><span class="s1">is_break(node) {</span>
            <span class="s3">return </span><span class="s1">node </span><span class="s3">instanceof </span><span class="s1">AST_Break</span>
                <span class="s1">&amp;&amp; compressor.loopcontrol_target(node) === compressor.self();</span>
        <span class="s1">}</span>

        <span class="s3">function </span><span class="s1">drop_it(rest) {</span>
            <span class="s1">rest = as_statement_array(rest);</span>
            <span class="s3">if </span><span class="s1">(self.body </span><span class="s3">instanceof </span><span class="s1">AST_BlockStatement) {</span>
                <span class="s1">self.body = self.body.clone();</span>
                <span class="s1">self.body.body = rest.concat(self.body.body.slice(</span><span class="s4">1</span><span class="s1">));</span>
                <span class="s1">self.body = self.body.transform(compressor);</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s1">self.body = make_node(AST_BlockStatement, self.body, {</span>
                    <span class="s1">body: rest</span>
                <span class="s1">}).transform(compressor);</span>
            <span class="s1">}</span>
            <span class="s1">self = if_break_in_loop(self, compressor);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">OPT(AST_For, </span><span class="s3">function</span><span class="s1">(self, compressor){</span>
        <span class="s3">if </span><span class="s1">(!compressor.option(</span><span class="s2">&quot;loops&quot;</span><span class="s1">)) </span><span class="s3">return </span><span class="s1">self;</span>
        <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;side_effects&quot;</span><span class="s1">) &amp;&amp; self.init) {</span>
            <span class="s1">self.init = self.init.drop_side_effect_free(compressor);</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(self.condition) {</span>
            <span class="s3">var </span><span class="s1">cond = self.condition.evaluate(compressor);</span>
            <span class="s3">if </span><span class="s1">(!(cond </span><span class="s3">instanceof </span><span class="s1">AST_Node)) {</span>
                <span class="s3">if </span><span class="s1">(cond) self.condition = </span><span class="s3">null</span><span class="s1">;</span>
                <span class="s3">else if </span><span class="s1">(!compressor.option(</span><span class="s2">&quot;dead_code&quot;</span><span class="s1">)) {</span>
                    <span class="s3">var </span><span class="s1">orig = self.condition;</span>
                    <span class="s1">self.condition = make_node_from_constant(cond, self.condition);</span>
                    <span class="s1">self.condition = best_of_expression(self.condition.transform(compressor), orig);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;dead_code&quot;</span><span class="s1">)) {</span>
                <span class="s3">if </span><span class="s1">(cond </span><span class="s3">instanceof </span><span class="s1">AST_Node) cond = self.condition.tail_node().evaluate(compressor);</span>
                <span class="s3">if </span><span class="s1">(!cond) {</span>
                    <span class="s3">var </span><span class="s1">body = [];</span>
                    <span class="s1">extract_declarations_from_unreachable_code(compressor, self.body, body);</span>
                    <span class="s3">if </span><span class="s1">(self.init </span><span class="s3">instanceof </span><span class="s1">AST_Statement) {</span>
                        <span class="s1">body.push(self.init);</span>
                    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(self.init) {</span>
                        <span class="s1">body.push(make_node(AST_SimpleStatement, self.init, {</span>
                            <span class="s1">body: self.init</span>
                        <span class="s1">}));</span>
                    <span class="s1">}</span>
                    <span class="s1">body.push(make_node(AST_SimpleStatement, self.condition, {</span>
                        <span class="s1">body: self.condition</span>
                    <span class="s1">}));</span>
                    <span class="s3">return </span><span class="s1">make_node(AST_BlockStatement, self, { body: body }).optimize(compressor);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">if_break_in_loop(self, compressor);</span>
    <span class="s1">});</span>

    <span class="s1">OPT(AST_If, </span><span class="s3">function</span><span class="s1">(self, compressor){</span>
        <span class="s3">if </span><span class="s1">(is_empty(self.alternative)) self.alternative = </span><span class="s3">null</span><span class="s1">;</span>

        <span class="s3">if </span><span class="s1">(!compressor.option(</span><span class="s2">&quot;conditionals&quot;</span><span class="s1">)) </span><span class="s3">return </span><span class="s1">self;</span>
        <span class="s0">// if condition can be statically determined, warn and drop</span>
        <span class="s0">// one of the blocks.  note, statically determined implies</span>
        <span class="s0">// “has no side effects”; also it doesn't work for cases like</span>
        <span class="s0">// `x &amp;&amp; true`, though it probably should.</span>
        <span class="s3">var </span><span class="s1">cond = self.condition.evaluate(compressor);</span>
        <span class="s3">if </span><span class="s1">(!compressor.option(</span><span class="s2">&quot;dead_code&quot;</span><span class="s1">) &amp;&amp; !(cond </span><span class="s3">instanceof </span><span class="s1">AST_Node)) {</span>
            <span class="s3">var </span><span class="s1">orig = self.condition;</span>
            <span class="s1">self.condition = make_node_from_constant(cond, orig);</span>
            <span class="s1">self.condition = best_of_expression(self.condition.transform(compressor), orig);</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;dead_code&quot;</span><span class="s1">)) {</span>
            <span class="s3">if </span><span class="s1">(cond </span><span class="s3">instanceof </span><span class="s1">AST_Node) cond = self.condition.tail_node().evaluate(compressor);</span>
            <span class="s3">if </span><span class="s1">(!cond) {</span>
                <span class="s1">compressor.warn(</span><span class="s2">&quot;Condition always false [{file}:{line},{col}]&quot;</span><span class="s1">, self.condition.start);</span>
                <span class="s3">var </span><span class="s1">body = [];</span>
                <span class="s1">extract_declarations_from_unreachable_code(compressor, self.body, body);</span>
                <span class="s1">body.push(make_node(AST_SimpleStatement, self.condition, {</span>
                    <span class="s1">body: self.condition</span>
                <span class="s1">}));</span>
                <span class="s3">if </span><span class="s1">(self.alternative) body.push(self.alternative);</span>
                <span class="s3">return </span><span class="s1">make_node(AST_BlockStatement, self, { body: body }).optimize(compressor);</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(!(cond </span><span class="s3">instanceof </span><span class="s1">AST_Node)) {</span>
                <span class="s1">compressor.warn(</span><span class="s2">&quot;Condition always true [{file}:{line},{col}]&quot;</span><span class="s1">, self.condition.start);</span>
                <span class="s3">var </span><span class="s1">body = [];</span>
                <span class="s3">if </span><span class="s1">(self.alternative) {</span>
                    <span class="s1">extract_declarations_from_unreachable_code(compressor, self.alternative, body);</span>
                <span class="s1">}</span>
                <span class="s1">body.push(make_node(AST_SimpleStatement, self.condition, {</span>
                    <span class="s1">body: self.condition</span>
                <span class="s1">}));</span>
                <span class="s1">body.push(self.body);</span>
                <span class="s3">return </span><span class="s1">make_node(AST_BlockStatement, self, { body: body }).optimize(compressor);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">var </span><span class="s1">negated = self.condition.negate(compressor);</span>
        <span class="s3">var </span><span class="s1">self_condition_length = self.condition.print_to_string().length;</span>
        <span class="s3">var </span><span class="s1">negated_length = negated.print_to_string().length;</span>
        <span class="s3">var </span><span class="s1">negated_is_best = negated_length &lt; self_condition_length;</span>
        <span class="s3">if </span><span class="s1">(self.alternative &amp;&amp; negated_is_best) {</span>
            <span class="s1">negated_is_best = </span><span class="s3">false</span><span class="s1">; </span><span class="s0">// because we already do the switch here.</span>
            <span class="s0">// no need to swap values of self_condition_length and negated_length</span>
            <span class="s0">// here because they are only used in an equality comparison later on.</span>
            <span class="s1">self.condition = negated;</span>
            <span class="s3">var </span><span class="s1">tmp = self.body;</span>
            <span class="s1">self.body = self.alternative || make_node(AST_EmptyStatement, self);</span>
            <span class="s1">self.alternative = tmp;</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(is_empty(self.body) &amp;&amp; is_empty(self.alternative)) {</span>
            <span class="s3">return </span><span class="s1">make_node(AST_SimpleStatement, self.condition, {</span>
                <span class="s1">body: self.condition.clone()</span>
            <span class="s1">}).optimize(compressor);</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(self.body </span><span class="s3">instanceof </span><span class="s1">AST_SimpleStatement</span>
            <span class="s1">&amp;&amp; self.alternative </span><span class="s3">instanceof </span><span class="s1">AST_SimpleStatement) {</span>
            <span class="s3">return </span><span class="s1">make_node(AST_SimpleStatement, self, {</span>
                <span class="s1">body: make_node(AST_Conditional, self, {</span>
                    <span class="s1">condition   : self.condition,</span>
                    <span class="s1">consequent  : self.body.body,</span>
                    <span class="s1">alternative : self.alternative.body</span>
                <span class="s1">})</span>
            <span class="s1">}).optimize(compressor);</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(is_empty(self.alternative) &amp;&amp; self.body </span><span class="s3">instanceof </span><span class="s1">AST_SimpleStatement) {</span>
            <span class="s3">if </span><span class="s1">(self_condition_length === negated_length &amp;&amp; !negated_is_best</span>
                <span class="s1">&amp;&amp; self.condition </span><span class="s3">instanceof </span><span class="s1">AST_Binary &amp;&amp; self.condition.operator == </span><span class="s2">&quot;||&quot;</span><span class="s1">) {</span>
                <span class="s0">// although the code length of self.condition and negated are the same,</span>
                <span class="s0">// negated does not require additional surrounding parentheses.</span>
                <span class="s0">// see https://github.com/mishoo/UglifyJS2/issues/979</span>
                <span class="s1">negated_is_best = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(negated_is_best) </span><span class="s3">return </span><span class="s1">make_node(AST_SimpleStatement, self, {</span>
                <span class="s1">body: make_node(AST_Binary, self, {</span>
                    <span class="s1">operator : </span><span class="s2">&quot;||&quot;</span><span class="s1">,</span>
                    <span class="s1">left     : negated,</span>
                    <span class="s1">right    : self.body.body</span>
                <span class="s1">})</span>
            <span class="s1">}).optimize(compressor);</span>
            <span class="s3">return </span><span class="s1">make_node(AST_SimpleStatement, self, {</span>
                <span class="s1">body: make_node(AST_Binary, self, {</span>
                    <span class="s1">operator : </span><span class="s2">&quot;&amp;&amp;&quot;</span><span class="s1">,</span>
                    <span class="s1">left     : self.condition,</span>
                    <span class="s1">right    : self.body.body</span>
                <span class="s1">})</span>
            <span class="s1">}).optimize(compressor);</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(self.body </span><span class="s3">instanceof </span><span class="s1">AST_EmptyStatement</span>
            <span class="s1">&amp;&amp; self.alternative </span><span class="s3">instanceof </span><span class="s1">AST_SimpleStatement) {</span>
            <span class="s3">return </span><span class="s1">make_node(AST_SimpleStatement, self, {</span>
                <span class="s1">body: make_node(AST_Binary, self, {</span>
                    <span class="s1">operator : </span><span class="s2">&quot;||&quot;</span><span class="s1">,</span>
                    <span class="s1">left     : self.condition,</span>
                    <span class="s1">right    : self.alternative.body</span>
                <span class="s1">})</span>
            <span class="s1">}).optimize(compressor);</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(self.body </span><span class="s3">instanceof </span><span class="s1">AST_Exit</span>
            <span class="s1">&amp;&amp; self.alternative </span><span class="s3">instanceof </span><span class="s1">AST_Exit</span>
            <span class="s1">&amp;&amp; self.body.TYPE == self.alternative.TYPE) {</span>
            <span class="s3">return </span><span class="s1">make_node(self.body.CTOR, self, {</span>
                <span class="s1">value: make_node(AST_Conditional, self, {</span>
                    <span class="s1">condition   : self.condition,</span>
                    <span class="s1">consequent  : self.body.value || make_node(AST_Undefined, self.body),</span>
                    <span class="s1">alternative : self.alternative.value || make_node(AST_Undefined, self.alternative)</span>
                <span class="s1">}).transform(compressor)</span>
            <span class="s1">}).optimize(compressor);</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(self.body </span><span class="s3">instanceof </span><span class="s1">AST_If</span>
            <span class="s1">&amp;&amp; !self.body.alternative</span>
            <span class="s1">&amp;&amp; !self.alternative) {</span>
            <span class="s1">self = make_node(AST_If, self, {</span>
                <span class="s1">condition: make_node(AST_Binary, self.condition, {</span>
                    <span class="s1">operator: </span><span class="s2">&quot;&amp;&amp;&quot;</span><span class="s1">,</span>
                    <span class="s1">left: self.condition,</span>
                    <span class="s1">right: self.body.condition</span>
                <span class="s1">}),</span>
                <span class="s1">body: self.body.body,</span>
                <span class="s1">alternative: </span><span class="s3">null</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(aborts(self.body)) {</span>
            <span class="s3">if </span><span class="s1">(self.alternative) {</span>
                <span class="s3">var </span><span class="s1">alt = self.alternative;</span>
                <span class="s1">self.alternative = </span><span class="s3">null</span><span class="s1">;</span>
                <span class="s3">return </span><span class="s1">make_node(AST_BlockStatement, self, {</span>
                    <span class="s1">body: [ self, alt ]</span>
                <span class="s1">}).optimize(compressor);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(aborts(self.alternative)) {</span>
            <span class="s3">var </span><span class="s1">body = self.body;</span>
            <span class="s1">self.body = self.alternative;</span>
            <span class="s1">self.condition = negated_is_best ? negated : self.condition.negate(compressor);</span>
            <span class="s1">self.alternative = </span><span class="s3">null</span><span class="s1">;</span>
            <span class="s3">return </span><span class="s1">make_node(AST_BlockStatement, self, {</span>
                <span class="s1">body: [ self, body ]</span>
            <span class="s1">}).optimize(compressor);</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">self;</span>
    <span class="s1">});</span>

    <span class="s1">OPT(AST_Switch, </span><span class="s3">function</span><span class="s1">(self, compressor){</span>
        <span class="s3">if </span><span class="s1">(!compressor.option(</span><span class="s2">&quot;switches&quot;</span><span class="s1">)) </span><span class="s3">return </span><span class="s1">self;</span>
        <span class="s3">var </span><span class="s1">branch;</span>
        <span class="s3">var </span><span class="s1">value = self.expression.evaluate(compressor);</span>
        <span class="s3">if </span><span class="s1">(!(value </span><span class="s3">instanceof </span><span class="s1">AST_Node)) {</span>
            <span class="s3">var </span><span class="s1">orig = self.expression;</span>
            <span class="s1">self.expression = make_node_from_constant(value, orig);</span>
            <span class="s1">self.expression = best_of_expression(self.expression.transform(compressor), orig);</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(!compressor.option(</span><span class="s2">&quot;dead_code&quot;</span><span class="s1">)) </span><span class="s3">return </span><span class="s1">self;</span>
        <span class="s3">if </span><span class="s1">(value </span><span class="s3">instanceof </span><span class="s1">AST_Node) {</span>
            <span class="s1">value = self.expression.tail_node().evaluate(compressor);</span>
        <span class="s1">}</span>
        <span class="s3">var </span><span class="s1">decl = [];</span>
        <span class="s3">var </span><span class="s1">body = [];</span>
        <span class="s3">var </span><span class="s1">default_branch;</span>
        <span class="s3">var </span><span class="s1">exact_match;</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">, len = self.body.length; i &lt; len &amp;&amp; !exact_match; i++) {</span>
            <span class="s1">branch = self.body[i];</span>
            <span class="s3">if </span><span class="s1">(branch </span><span class="s3">instanceof </span><span class="s1">AST_Default) {</span>
                <span class="s3">if </span><span class="s1">(!default_branch) {</span>
                    <span class="s1">default_branch = branch;</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s1">eliminate_branch(branch, body[body.length - </span><span class="s4">1</span><span class="s1">]);</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(!(value </span><span class="s3">instanceof </span><span class="s1">AST_Node)) {</span>
                <span class="s3">var </span><span class="s1">exp = branch.expression.evaluate(compressor);</span>
                <span class="s3">if </span><span class="s1">(!(exp </span><span class="s3">instanceof </span><span class="s1">AST_Node) &amp;&amp; exp !== value) {</span>
                    <span class="s1">eliminate_branch(branch, body[body.length - </span><span class="s4">1</span><span class="s1">]);</span>
                    <span class="s3">continue</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s3">if </span><span class="s1">(exp </span><span class="s3">instanceof </span><span class="s1">AST_Node) exp = branch.expression.tail_node().evaluate(compressor);</span>
                <span class="s3">if </span><span class="s1">(exp === value) {</span>
                    <span class="s1">exact_match = branch;</span>
                    <span class="s3">if </span><span class="s1">(default_branch) {</span>
                        <span class="s3">var </span><span class="s1">default_index = body.indexOf(default_branch);</span>
                        <span class="s1">body.splice(default_index, </span><span class="s4">1</span><span class="s1">);</span>
                        <span class="s1">eliminate_branch(default_branch, body[default_index - </span><span class="s4">1</span><span class="s1">]);</span>
                        <span class="s1">default_branch = </span><span class="s3">null</span><span class="s1">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(aborts(branch)) {</span>
                <span class="s3">var </span><span class="s1">prev = body[body.length - </span><span class="s4">1</span><span class="s1">];</span>
                <span class="s3">if </span><span class="s1">(aborts(prev) &amp;&amp; prev.body.length == branch.body.length</span>
                    <span class="s1">&amp;&amp; make_node(AST_BlockStatement, prev, prev).equivalent_to(make_node(AST_BlockStatement, branch, branch))) {</span>
                    <span class="s1">prev.body = [];</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">body.push(branch);</span>
        <span class="s1">}</span>
        <span class="s3">while </span><span class="s1">(i &lt; len) eliminate_branch(self.body[i++], body[body.length - </span><span class="s4">1</span><span class="s1">]);</span>
        <span class="s3">if </span><span class="s1">(body.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s1">body[</span><span class="s4">0</span><span class="s1">].body = decl.concat(body[</span><span class="s4">0</span><span class="s1">].body);</span>
        <span class="s1">}</span>
        <span class="s1">self.body = body;</span>
        <span class="s3">while </span><span class="s1">(branch = body[body.length - </span><span class="s4">1</span><span class="s1">]) {</span>
            <span class="s3">var </span><span class="s1">stat = branch.body[branch.body.length - </span><span class="s4">1</span><span class="s1">];</span>
            <span class="s3">if </span><span class="s1">(stat </span><span class="s3">instanceof </span><span class="s1">AST_Break &amp;&amp; compressor.loopcontrol_target(stat) === self)</span>
                <span class="s1">branch.body.pop();</span>
            <span class="s3">if </span><span class="s1">(branch.body.length || branch </span><span class="s3">instanceof </span><span class="s1">AST_Case</span>
                <span class="s1">&amp;&amp; (default_branch || branch.expression.has_side_effects(compressor))) </span><span class="s3">break</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(body.pop() === default_branch) default_branch = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(body.length == </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s3">return </span><span class="s1">make_node(AST_BlockStatement, self, {</span>
                <span class="s1">body: decl.concat(make_node(AST_SimpleStatement, self.expression, {</span>
                    <span class="s1">body: self.expression</span>
                <span class="s1">}))</span>
            <span class="s1">}).optimize(compressor);</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(body.length == </span><span class="s4">1 </span><span class="s1">&amp;&amp; (body[</span><span class="s4">0</span><span class="s1">] === exact_match || body[</span><span class="s4">0</span><span class="s1">] === default_branch)) {</span>
            <span class="s3">var </span><span class="s1">has_break = </span><span class="s3">false</span><span class="s1">;</span>
            <span class="s3">var </span><span class="s1">tw = </span><span class="s3">new </span><span class="s1">TreeWalker(</span><span class="s3">function</span><span class="s1">(node) {</span>
                <span class="s3">if </span><span class="s1">(has_break</span>
                    <span class="s1">|| node </span><span class="s3">instanceof </span><span class="s1">AST_Lambda</span>
                    <span class="s1">|| node </span><span class="s3">instanceof </span><span class="s1">AST_SimpleStatement) </span><span class="s3">return true</span><span class="s1">;</span>
                <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Break &amp;&amp; tw.loopcontrol_target(node) === self)</span>
                    <span class="s1">has_break = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s1">});</span>
            <span class="s1">self.walk(tw);</span>
            <span class="s3">if </span><span class="s1">(!has_break) {</span>
                <span class="s3">var </span><span class="s1">statements = body[</span><span class="s4">0</span><span class="s1">].body.slice();</span>
                <span class="s3">var </span><span class="s1">exp = body[</span><span class="s4">0</span><span class="s1">].expression;</span>
                <span class="s3">if </span><span class="s1">(exp) statements.unshift(make_node(AST_SimpleStatement, exp, {</span>
                    <span class="s1">body: exp</span>
                <span class="s1">}));</span>
                <span class="s1">statements.unshift(make_node(AST_SimpleStatement, self.expression, {</span>
                    <span class="s1">body:self.expression</span>
                <span class="s1">}));</span>
                <span class="s3">return </span><span class="s1">make_node(AST_BlockStatement, self, {</span>
                    <span class="s1">body: statements</span>
                <span class="s1">}).optimize(compressor);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">self;</span>

        <span class="s3">function </span><span class="s1">eliminate_branch(branch, prev) {</span>
            <span class="s3">if </span><span class="s1">(prev &amp;&amp; !aborts(prev)) {</span>
                <span class="s1">prev.body = prev.body.concat(branch.body);</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s1">extract_declarations_from_unreachable_code(compressor, branch, decl);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">});</span>

    <span class="s1">OPT(AST_Try, </span><span class="s3">function</span><span class="s1">(self, compressor){</span>
        <span class="s1">tighten_body(self.body, compressor);</span>
        <span class="s3">if </span><span class="s1">(self.bcatch &amp;&amp; self.bfinally &amp;&amp; all(self.bfinally.body, is_empty)) self.bfinally = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;dead_code&quot;</span><span class="s1">) &amp;&amp; all(self.body, is_empty)) {</span>
            <span class="s3">var </span><span class="s1">body = [];</span>
            <span class="s3">if </span><span class="s1">(self.bcatch) {</span>
                <span class="s1">extract_declarations_from_unreachable_code(compressor, self.bcatch, body);</span>
                <span class="s1">body.forEach(</span><span class="s3">function</span><span class="s1">(stat) {</span>
                    <span class="s3">if </span><span class="s1">(!(stat </span><span class="s3">instanceof </span><span class="s1">AST_Definitions)) </span><span class="s3">return</span><span class="s1">;</span>
                    <span class="s1">stat.definitions.forEach(</span><span class="s3">function</span><span class="s1">(var_def) {</span>
                        <span class="s3">var </span><span class="s1">def = var_def.name.definition().redefined();</span>
                        <span class="s3">if </span><span class="s1">(!def) </span><span class="s3">return</span><span class="s1">;</span>
                        <span class="s1">var_def.name = var_def.name.clone();</span>
                        <span class="s1">var_def.name.thedef = def;</span>
                    <span class="s1">});</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(self.bfinally) body = body.concat(self.bfinally.body);</span>
            <span class="s3">return </span><span class="s1">make_node(AST_BlockStatement, self, {</span>
                <span class="s1">body: body</span>
            <span class="s1">}).optimize(compressor);</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">self;</span>
    <span class="s1">});</span>

    <span class="s1">AST_Definitions.DEFMETHOD(</span><span class="s2">&quot;remove_initializers&quot;</span><span class="s1">, </span><span class="s3">function</span><span class="s1">(){</span>
        <span class="s3">var </span><span class="s1">decls = [];</span>
        <span class="s3">this</span><span class="s1">.definitions.forEach(</span><span class="s3">function</span><span class="s1">(def) {</span>
            <span class="s3">if </span><span class="s1">(def.name </span><span class="s3">instanceof </span><span class="s1">AST_SymbolDeclaration) {</span>
                <span class="s1">def.value = </span><span class="s3">null</span><span class="s1">;</span>
                <span class="s1">decls.push(def);</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">def.name.walk(</span><span class="s3">new </span><span class="s1">TreeWalker(</span><span class="s3">function</span><span class="s1">(node) {</span>
                <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_SymbolDeclaration) {</span>
                    <span class="s1">decls.push(make_node(AST_VarDef, def, {</span>
                        <span class="s1">name: node,</span>
                        <span class="s1">value: </span><span class="s3">null</span>
                    <span class="s1">}));</span>
                <span class="s1">}</span>
            <span class="s1">}));</span>
        <span class="s1">});</span>
        <span class="s3">this</span><span class="s1">.definitions = decls;</span>
    <span class="s1">});</span>

    <span class="s1">AST_Definitions.DEFMETHOD(</span><span class="s2">&quot;to_assignments&quot;</span><span class="s1">, </span><span class="s3">function</span><span class="s1">(compressor){</span>
        <span class="s3">var </span><span class="s1">reduce_vars = compressor.option(</span><span class="s2">&quot;reduce_vars&quot;</span><span class="s1">);</span>
        <span class="s3">var </span><span class="s1">assignments = </span><span class="s3">this</span><span class="s1">.definitions.reduce(</span><span class="s3">function</span><span class="s1">(a, def){</span>
            <span class="s3">if </span><span class="s1">(def.value &amp;&amp; !(def.name </span><span class="s3">instanceof </span><span class="s1">AST_Destructuring)) {</span>
                <span class="s3">var </span><span class="s1">name = make_node(AST_SymbolRef, def.name, def.name);</span>
                <span class="s1">a.push(make_node(AST_Assign, def, {</span>
                    <span class="s1">operator : </span><span class="s2">&quot;=&quot;</span><span class="s1">,</span>
                    <span class="s1">left     : name,</span>
                    <span class="s1">right    : def.value</span>
                <span class="s1">}));</span>
                <span class="s3">if </span><span class="s1">(reduce_vars) name.definition().fixed = </span><span class="s3">false</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(def.value) {</span>
                <span class="s0">// Because it's a destructuring, do not turn into an assignment.</span>
                <span class="s3">var </span><span class="s1">varDef = make_node(AST_VarDef, def, {</span>
                    <span class="s1">name: def.name,</span>
                    <span class="s1">value: def.value</span>
                <span class="s1">});</span>
                <span class="s3">var </span><span class="s1">var_ = make_node(AST_Var, def, {</span>
                    <span class="s1">definitions: [ varDef ]</span>
                <span class="s1">});</span>
                <span class="s1">a.push(var_);</span>
            <span class="s1">}</span>
            <span class="s1">def = def.name.definition();</span>
            <span class="s1">def.eliminated++;</span>
            <span class="s1">def.replaced--;</span>
            <span class="s3">return </span><span class="s1">a;</span>
        <span class="s1">}, []);</span>
        <span class="s3">if </span><span class="s1">(assignments.length == </span><span class="s4">0</span><span class="s1">) </span><span class="s3">return null</span><span class="s1">;</span>
        <span class="s3">return </span><span class="s1">make_sequence(</span><span class="s3">this</span><span class="s1">, assignments);</span>
    <span class="s1">});</span>

    <span class="s1">OPT(AST_Definitions, </span><span class="s3">function</span><span class="s1">(self, compressor){</span>
        <span class="s3">if </span><span class="s1">(self.definitions.length == </span><span class="s4">0</span><span class="s1">)</span>
            <span class="s3">return </span><span class="s1">make_node(AST_EmptyStatement, self);</span>
        <span class="s3">return </span><span class="s1">self;</span>
    <span class="s1">});</span>

    <span class="s1">OPT(AST_Import, </span><span class="s3">function</span><span class="s1">(self, compressor) {</span>
        <span class="s3">return </span><span class="s1">self;</span>
    <span class="s1">});</span>

    <span class="s1">OPT(AST_Call, </span><span class="s3">function</span><span class="s1">(self, compressor){</span>
        <span class="s3">var </span><span class="s1">exp = self.expression;</span>
        <span class="s3">var </span><span class="s1">fn = exp;</span>
        <span class="s3">var </span><span class="s1">simple_args = all(self.args, </span><span class="s3">function</span><span class="s1">(arg) {</span>
            <span class="s3">return </span><span class="s1">!(arg </span><span class="s3">instanceof </span><span class="s1">AST_Expansion);</span>
        <span class="s1">});</span>
        <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;reduce_vars&quot;</span><span class="s1">) &amp;&amp; fn </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef) {</span>
            <span class="s1">fn = fn.fixed_value();</span>
        <span class="s1">}</span>
        <span class="s3">var </span><span class="s1">is_func = fn </span><span class="s3">instanceof </span><span class="s1">AST_Lambda;</span>
        <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;unused&quot;</span><span class="s1">)</span>
            <span class="s1">&amp;&amp; simple_args</span>
            <span class="s1">&amp;&amp; is_func</span>
            <span class="s1">&amp;&amp; !fn.uses_arguments</span>
            <span class="s1">&amp;&amp; !fn.uses_eval) {</span>
            <span class="s3">var </span><span class="s1">pos = </span><span class="s4">0</span><span class="s1">, last = </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">, len = self.args.length; i &lt; len; i++) {</span>
                <span class="s3">if </span><span class="s1">(fn.argnames[i] </span><span class="s3">instanceof </span><span class="s1">AST_Expansion) {</span>
                    <span class="s3">if </span><span class="s1">(fn.argnames[i].expression.__unused) </span><span class="s3">while </span><span class="s1">(i &lt; len) {</span>
                        <span class="s3">var </span><span class="s1">node = self.args[i++].drop_side_effect_free(compressor);</span>
                        <span class="s3">if </span><span class="s1">(node) {</span>
                            <span class="s1">self.args[pos++] = node;</span>
                        <span class="s1">}</span>
                    <span class="s1">} </span><span class="s3">else while </span><span class="s1">(i &lt; len) {</span>
                        <span class="s1">self.args[pos++] = self.args[i++];</span>
                    <span class="s1">}</span>
                    <span class="s1">last = pos;</span>
                    <span class="s3">break</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s3">var </span><span class="s1">trim = i &gt;= fn.argnames.length;</span>
                <span class="s3">if </span><span class="s1">(trim || fn.argnames[i].__unused) {</span>
                    <span class="s3">var </span><span class="s1">node = self.args[i].drop_side_effect_free(compressor);</span>
                    <span class="s3">if </span><span class="s1">(node) {</span>
                        <span class="s1">self.args[pos++] = node;</span>
                    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(!trim) {</span>
                        <span class="s1">self.args[pos++] = make_node(AST_Number, self.args[i], {</span>
                            <span class="s1">value: </span><span class="s4">0</span>
                        <span class="s1">});</span>
                        <span class="s3">continue</span><span class="s1">;</span>
                    <span class="s1">}</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s1">self.args[pos++] = self.args[i];</span>
                <span class="s1">}</span>
                <span class="s1">last = pos;</span>
            <span class="s1">}</span>
            <span class="s1">self.args.length = last;</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;unsafe&quot;</span><span class="s1">)) {</span>
            <span class="s3">if </span><span class="s1">(is_undeclared_ref(exp)) </span><span class="s3">switch </span><span class="s1">(exp.name) {</span>
              <span class="s3">case </span><span class="s2">&quot;Array&quot;</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">(self.args.length != </span><span class="s4">1</span><span class="s1">) {</span>
                    <span class="s3">return </span><span class="s1">make_node(AST_Array, self, {</span>
                        <span class="s1">elements: self.args</span>
                    <span class="s1">}).optimize(compressor);</span>
                <span class="s1">}</span>
                <span class="s3">break</span><span class="s1">;</span>
              <span class="s3">case </span><span class="s2">&quot;Object&quot;</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">(self.args.length == </span><span class="s4">0</span><span class="s1">) {</span>
                    <span class="s3">return </span><span class="s1">make_node(AST_Object, self, {</span>
                        <span class="s1">properties: []</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s3">break</span><span class="s1">;</span>
              <span class="s3">case </span><span class="s2">&quot;String&quot;</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">(self.args.length == </span><span class="s4">0</span><span class="s1">) </span><span class="s3">return </span><span class="s1">make_node(AST_String, self, {</span>
                    <span class="s1">value: </span><span class="s2">&quot;&quot;</span>
                <span class="s1">});</span>
                <span class="s3">if </span><span class="s1">(self.args.length &lt;= </span><span class="s4">1</span><span class="s1">) </span><span class="s3">return </span><span class="s1">make_node(AST_Binary, self, {</span>
                    <span class="s1">left: self.args[</span><span class="s4">0</span><span class="s1">],</span>
                    <span class="s1">operator: </span><span class="s2">&quot;+&quot;</span><span class="s1">,</span>
                    <span class="s1">right: make_node(AST_String, self, { value: </span><span class="s2">&quot;&quot; </span><span class="s1">})</span>
                <span class="s1">}).optimize(compressor);</span>
                <span class="s3">break</span><span class="s1">;</span>
              <span class="s3">case </span><span class="s2">&quot;Number&quot;</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">(self.args.length == </span><span class="s4">0</span><span class="s1">) </span><span class="s3">return </span><span class="s1">make_node(AST_Number, self, {</span>
                    <span class="s1">value: </span><span class="s4">0</span>
                <span class="s1">});</span>
                <span class="s3">if </span><span class="s1">(self.args.length == </span><span class="s4">1</span><span class="s1">) </span><span class="s3">return </span><span class="s1">make_node(AST_UnaryPrefix, self, {</span>
                    <span class="s1">expression: self.args[</span><span class="s4">0</span><span class="s1">],</span>
                    <span class="s1">operator: </span><span class="s2">&quot;+&quot;</span>
                <span class="s1">}).optimize(compressor);</span>
              <span class="s3">case </span><span class="s2">&quot;Boolean&quot;</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">(self.args.length == </span><span class="s4">0</span><span class="s1">) </span><span class="s3">return </span><span class="s1">make_node(AST_False, self);</span>
                <span class="s3">if </span><span class="s1">(self.args.length == </span><span class="s4">1</span><span class="s1">) </span><span class="s3">return </span><span class="s1">make_node(AST_UnaryPrefix, self, {</span>
                    <span class="s1">expression: make_node(AST_UnaryPrefix, self, {</span>
                        <span class="s1">expression: self.args[</span><span class="s4">0</span><span class="s1">],</span>
                        <span class="s1">operator: </span><span class="s2">&quot;!&quot;</span>
                    <span class="s1">}),</span>
                    <span class="s1">operator: </span><span class="s2">&quot;!&quot;</span>
                <span class="s1">}).optimize(compressor);</span>
                <span class="s3">break</span><span class="s1">;</span>
              <span class="s3">case </span><span class="s2">&quot;RegExp&quot;</span><span class="s1">:</span>
                <span class="s3">var </span><span class="s1">params = [];</span>
                <span class="s3">if </span><span class="s1">(all(self.args, </span><span class="s3">function</span><span class="s1">(arg) {</span>
                    <span class="s3">var </span><span class="s1">value = arg.evaluate(compressor);</span>
                    <span class="s1">params.unshift(value);</span>
                    <span class="s3">return </span><span class="s1">arg !== value;</span>
                <span class="s1">})) {</span>
                    <span class="s3">try </span><span class="s1">{</span>
                        <span class="s3">return </span><span class="s1">best_of(compressor, self, make_node(AST_RegExp, self, {</span>
                            <span class="s1">value: RegExp.apply(RegExp, params),</span>
                        <span class="s1">}));</span>
                    <span class="s1">} </span><span class="s3">catch </span><span class="s1">(ex) {</span>
                        <span class="s1">compressor.warn(</span><span class="s2">&quot;Error converting {expr} [{file}:{line},{col}]&quot;</span><span class="s1">, {</span>
                            <span class="s1">expr: self.print_to_string(),</span>
                            <span class="s1">file: self.start.file,</span>
                            <span class="s1">line: self.start.line,</span>
                            <span class="s1">col: self.start.col</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s3">break</span><span class="s1">;</span>
              <span class="s3">case </span><span class="s2">&quot;Symbol&quot;</span><span class="s1">:</span>
                <span class="s0">// Symbol's argument is only used for debugging.</span>
                <span class="s1">self.args = [];</span>
                <span class="s3">return </span><span class="s1">self;</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(exp </span><span class="s3">instanceof </span><span class="s1">AST_Dot) </span><span class="s3">switch</span><span class="s1">(exp.property) {</span>
              <span class="s3">case </span><span class="s2">&quot;toString&quot;</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">(self.args.length == </span><span class="s4">0 </span><span class="s1">&amp;&amp; !exp.expression.may_throw_on_access(compressor)) {</span>
                    <span class="s3">return </span><span class="s1">make_node(AST_Binary, self, {</span>
                        <span class="s1">left: make_node(AST_String, self, { value: </span><span class="s2">&quot;&quot; </span><span class="s1">}),</span>
                        <span class="s1">operator: </span><span class="s2">&quot;+&quot;</span><span class="s1">,</span>
                        <span class="s1">right: exp.expression</span>
                    <span class="s1">}).optimize(compressor);</span>
                <span class="s1">}</span>
                <span class="s3">break</span><span class="s1">;</span>
              <span class="s3">case </span><span class="s2">&quot;join&quot;</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">(exp.expression </span><span class="s3">instanceof </span><span class="s1">AST_Array) EXIT: {</span>
                    <span class="s3">var </span><span class="s1">separator;</span>
                    <span class="s3">if </span><span class="s1">(self.args.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                        <span class="s1">separator = self.args[</span><span class="s4">0</span><span class="s1">].evaluate(compressor);</span>
                        <span class="s3">if </span><span class="s1">(separator === self.args[</span><span class="s4">0</span><span class="s1">]) </span><span class="s3">break </span><span class="s1">EXIT; </span><span class="s0">// not a constant</span>
                    <span class="s1">}</span>
                    <span class="s3">var </span><span class="s1">elements = [];</span>
                    <span class="s3">var </span><span class="s1">consts = [];</span>
                    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">, len = exp.expression.elements.length; i &lt; len; i++) {</span>
                        <span class="s3">var </span><span class="s1">el = exp.expression.elements[i];</span>
                        <span class="s3">if </span><span class="s1">(el </span><span class="s3">instanceof </span><span class="s1">AST_Expansion) </span><span class="s3">break </span><span class="s1">EXIT;</span>
                        <span class="s3">var </span><span class="s1">value = el.evaluate(compressor);</span>
                        <span class="s3">if </span><span class="s1">(value !== el) {</span>
                            <span class="s1">consts.push(value);</span>
                        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                            <span class="s3">if </span><span class="s1">(consts.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                                <span class="s1">elements.push(make_node(AST_String, self, {</span>
                                    <span class="s1">value: consts.join(separator)</span>
                                <span class="s1">}));</span>
                                <span class="s1">consts.length = </span><span class="s4">0</span><span class="s1">;</span>
                            <span class="s1">}</span>
                            <span class="s1">elements.push(el);</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s3">if </span><span class="s1">(consts.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                        <span class="s1">elements.push(make_node(AST_String, self, {</span>
                            <span class="s1">value: consts.join(separator)</span>
                        <span class="s1">}));</span>
                    <span class="s1">}</span>
                    <span class="s3">if </span><span class="s1">(elements.length == </span><span class="s4">0</span><span class="s1">) </span><span class="s3">return </span><span class="s1">make_node(AST_String, self, { value: </span><span class="s2">&quot;&quot; </span><span class="s1">});</span>
                    <span class="s3">if </span><span class="s1">(elements.length == </span><span class="s4">1</span><span class="s1">) {</span>
                        <span class="s3">if </span><span class="s1">(elements[</span><span class="s4">0</span><span class="s1">].is_string(compressor)) {</span>
                            <span class="s3">return </span><span class="s1">elements[</span><span class="s4">0</span><span class="s1">];</span>
                        <span class="s1">}</span>
                        <span class="s3">return </span><span class="s1">make_node(AST_Binary, elements[</span><span class="s4">0</span><span class="s1">], {</span>
                            <span class="s1">operator : </span><span class="s2">&quot;+&quot;</span><span class="s1">,</span>
                            <span class="s1">left     : make_node(AST_String, self, { value: </span><span class="s2">&quot;&quot; </span><span class="s1">}),</span>
                            <span class="s1">right    : elements[</span><span class="s4">0</span><span class="s1">]</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                    <span class="s3">if </span><span class="s1">(separator == </span><span class="s2">&quot;&quot;</span><span class="s1">) {</span>
                        <span class="s3">var </span><span class="s1">first;</span>
                        <span class="s3">if </span><span class="s1">(elements[</span><span class="s4">0</span><span class="s1">].is_string(compressor)</span>
                            <span class="s1">|| elements[</span><span class="s4">1</span><span class="s1">].is_string(compressor)) {</span>
                            <span class="s1">first = elements.shift();</span>
                        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                            <span class="s1">first = make_node(AST_String, self, { value: </span><span class="s2">&quot;&quot; </span><span class="s1">});</span>
                        <span class="s1">}</span>
                        <span class="s3">return </span><span class="s1">elements.reduce(</span><span class="s3">function</span><span class="s1">(prev, el){</span>
                            <span class="s3">return </span><span class="s1">make_node(AST_Binary, el, {</span>
                                <span class="s1">operator : </span><span class="s2">&quot;+&quot;</span><span class="s1">,</span>
                                <span class="s1">left     : prev,</span>
                                <span class="s1">right    : el</span>
                            <span class="s1">});</span>
                        <span class="s1">}, first).optimize(compressor);</span>
                    <span class="s1">}</span>
                    <span class="s0">// need this awkward cloning to not affect original element</span>
                    <span class="s0">// best_of will decide which one to get through.</span>
                    <span class="s3">var </span><span class="s1">node = self.clone();</span>
                    <span class="s1">node.expression = node.expression.clone();</span>
                    <span class="s1">node.expression.expression = node.expression.expression.clone();</span>
                    <span class="s1">node.expression.expression.elements = elements;</span>
                    <span class="s3">return </span><span class="s1">best_of(compressor, self, node);</span>
                <span class="s1">}</span>
                <span class="s3">break</span><span class="s1">;</span>
              <span class="s3">case </span><span class="s2">&quot;charAt&quot;</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">(exp.expression.is_string(compressor)) {</span>
                    <span class="s3">var </span><span class="s1">arg = self.args[</span><span class="s4">0</span><span class="s1">];</span>
                    <span class="s3">var </span><span class="s1">index = arg ? arg.evaluate(compressor) : </span><span class="s4">0</span><span class="s1">;</span>
                    <span class="s3">if </span><span class="s1">(index !== arg) {</span>
                        <span class="s3">return </span><span class="s1">make_node(AST_Sub, exp, {</span>
                            <span class="s1">expression: exp.expression,</span>
                            <span class="s1">property: make_node_from_constant(index | </span><span class="s4">0</span><span class="s1">, arg || exp)</span>
                        <span class="s1">}).optimize(compressor);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s3">break</span><span class="s1">;</span>
              <span class="s3">case </span><span class="s2">&quot;apply&quot;</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">(self.args.length == </span><span class="s4">2 </span><span class="s1">&amp;&amp; self.args[</span><span class="s4">1</span><span class="s1">] </span><span class="s3">instanceof </span><span class="s1">AST_Array) {</span>
                    <span class="s3">var </span><span class="s1">args = self.args[</span><span class="s4">1</span><span class="s1">].elements.slice();</span>
                    <span class="s1">args.unshift(self.args[</span><span class="s4">0</span><span class="s1">]);</span>
                    <span class="s3">return </span><span class="s1">make_node(AST_Call, self, {</span>
                        <span class="s1">expression: make_node(AST_Dot, exp, {</span>
                            <span class="s1">expression: exp.expression,</span>
                            <span class="s1">property: </span><span class="s2">&quot;call&quot;</span>
                        <span class="s1">}),</span>
                        <span class="s1">args: args</span>
                    <span class="s1">}).optimize(compressor);</span>
                <span class="s1">}</span>
                <span class="s3">break</span><span class="s1">;</span>
              <span class="s3">case </span><span class="s2">&quot;call&quot;</span><span class="s1">:</span>
                <span class="s3">var </span><span class="s1">func = exp.expression;</span>
                <span class="s3">if </span><span class="s1">(func </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef) {</span>
                    <span class="s1">func = func.fixed_value();</span>
                <span class="s1">}</span>
                <span class="s3">if </span><span class="s1">(func </span><span class="s3">instanceof </span><span class="s1">AST_Lambda &amp;&amp; !func.contains_this()) {</span>
                    <span class="s3">return </span><span class="s1">make_sequence(</span><span class="s3">this</span><span class="s1">, [</span>
                        <span class="s1">self.args[</span><span class="s4">0</span><span class="s1">],</span>
                        <span class="s1">make_node(AST_Call, self, {</span>
                            <span class="s1">expression: exp.expression,</span>
                            <span class="s1">args: self.args.slice(</span><span class="s4">1</span><span class="s1">)</span>
                        <span class="s1">})</span>
                    <span class="s1">]).optimize(compressor);</span>
                <span class="s1">}</span>
                <span class="s3">break</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;unsafe_Function&quot;</span><span class="s1">)</span>
            <span class="s1">&amp;&amp; is_undeclared_ref(exp)</span>
            <span class="s1">&amp;&amp; exp.name == </span><span class="s2">&quot;Function&quot;</span><span class="s1">) {</span>
            <span class="s0">// new Function() =&gt; function(){}</span>
            <span class="s3">if </span><span class="s1">(self.args.length == </span><span class="s4">0</span><span class="s1">) </span><span class="s3">return </span><span class="s1">make_node(AST_Function, self, {</span>
                <span class="s1">argnames: [],</span>
                <span class="s1">body: []</span>
            <span class="s1">}).optimize(compressor);</span>
            <span class="s3">if </span><span class="s1">(all(self.args, </span><span class="s3">function</span><span class="s1">(x) {</span>
                <span class="s3">return </span><span class="s1">x </span><span class="s3">instanceof </span><span class="s1">AST_String;</span>
            <span class="s1">})) {</span>
                <span class="s0">// quite a corner-case, but we can handle it:</span>
                <span class="s0">//   https://github.com/mishoo/UglifyJS2/issues/203</span>
                <span class="s0">// if the code argument is a constant, then we can minify it.</span>
                <span class="s3">try </span><span class="s1">{</span>
                    <span class="s3">var </span><span class="s1">code = </span><span class="s2">&quot;n(function(&quot; </span><span class="s1">+ self.args.slice(</span><span class="s4">0</span><span class="s1">, -</span><span class="s4">1</span><span class="s1">).map(</span><span class="s3">function</span><span class="s1">(arg) {</span>
                        <span class="s3">return </span><span class="s1">arg.value;</span>
                    <span class="s1">}).join(</span><span class="s2">&quot;,&quot;</span><span class="s1">) + </span><span class="s2">&quot;){&quot; </span><span class="s1">+ self.args[self.args.length - </span><span class="s4">1</span><span class="s1">].value + </span><span class="s2">&quot;})&quot;</span><span class="s1">;</span>
                    <span class="s3">var </span><span class="s1">ast = parse(code);</span>
                    <span class="s3">var </span><span class="s1">mangle = { ie8: compressor.option(</span><span class="s2">&quot;ie8&quot;</span><span class="s1">) };</span>
                    <span class="s1">ast.figure_out_scope(mangle);</span>
                    <span class="s3">var </span><span class="s1">comp = </span><span class="s3">new </span><span class="s1">Compressor(compressor.options);</span>
                    <span class="s1">ast = ast.transform(comp);</span>
                    <span class="s1">ast.figure_out_scope(mangle);</span>
                    <span class="s1">base54.reset();</span>
                    <span class="s1">ast.compute_char_frequency(mangle);</span>
                    <span class="s1">ast.mangle_names(mangle);</span>
                    <span class="s3">var </span><span class="s1">fun;</span>
                    <span class="s1">ast.walk(</span><span class="s3">new </span><span class="s1">TreeWalker(</span><span class="s3">function</span><span class="s1">(node) {</span>
                        <span class="s3">if </span><span class="s1">(fun) </span><span class="s3">return true</span><span class="s1">;</span>
                        <span class="s3">if </span><span class="s1">(is_func_expr(node)) {</span>
                            <span class="s1">fun = node;</span>
                            <span class="s3">return true</span><span class="s1">;</span>
                        <span class="s1">}</span>
                    <span class="s1">}));</span>
                    <span class="s3">if </span><span class="s1">(fun.body </span><span class="s3">instanceof </span><span class="s1">AST_Node) {</span>
                        <span class="s1">fun.body = [</span>
                            <span class="s1">make_node(AST_Return, fun.body, {</span>
                                <span class="s1">value: fun.body</span>
                            <span class="s1">})</span>
                        <span class="s1">];</span>
                    <span class="s1">}</span>
                    <span class="s3">var </span><span class="s1">code = OutputStream();</span>
                    <span class="s1">AST_BlockStatement.prototype._codegen.call(fun, fun, code);</span>
                    <span class="s1">self.args = [</span>
                        <span class="s1">make_node(AST_String, self, {</span>
                            <span class="s1">value: fun.argnames.map(</span><span class="s3">function</span><span class="s1">(arg) {</span>
                                <span class="s3">return </span><span class="s1">arg.print_to_string();</span>
                            <span class="s1">}).join(</span><span class="s2">&quot;,&quot;</span><span class="s1">)</span>
                        <span class="s1">}),</span>
                        <span class="s1">make_node(AST_String, self.args[self.args.length - </span><span class="s4">1</span><span class="s1">], {</span>
                            <span class="s1">value: code.get().replace(/^\{|\}$/g, </span><span class="s2">&quot;&quot;</span><span class="s1">)</span>
                        <span class="s1">})</span>
                    <span class="s1">];</span>
                    <span class="s3">return </span><span class="s1">self;</span>
                <span class="s1">} </span><span class="s3">catch </span><span class="s1">(ex) {</span>
                    <span class="s3">if </span><span class="s1">(ex </span><span class="s3">instanceof </span><span class="s1">JS_Parse_Error) {</span>
                        <span class="s1">compressor.warn(</span><span class="s2">&quot;Error parsing code passed to new Function [{file}:{line},{col}]&quot;</span><span class="s1">, self.args[self.args.length - </span><span class="s4">1</span><span class="s1">].start);</span>
                        <span class="s1">compressor.warn(ex.toString());</span>
                    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                        <span class="s3">throw </span><span class="s1">ex;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">var </span><span class="s1">stat = is_func &amp;&amp; fn.body;</span>
        <span class="s3">if </span><span class="s1">(stat </span><span class="s3">instanceof </span><span class="s1">AST_Node) {</span>
            <span class="s1">stat = make_node(AST_Return, stat, {</span>
                <span class="s1">value: stat</span>
            <span class="s1">});</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(stat) {</span>
            <span class="s1">stat = stat[</span><span class="s4">0</span><span class="s1">];</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;inline&quot;</span><span class="s1">) &amp;&amp; stat </span><span class="s3">instanceof </span><span class="s1">AST_Return) {</span>
            <span class="s3">var </span><span class="s1">value = stat.value;</span>
            <span class="s3">if </span><span class="s1">(!value || value.is_constant_expression()) {</span>
                <span class="s3">var </span><span class="s1">args = self.args.concat(value || make_node(AST_Undefined, self));</span>
                <span class="s3">return </span><span class="s1">make_sequence(self, args).optimize(compressor);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(is_func &amp;&amp; !fn.is_generator &amp;&amp; !fn.async) {</span>
            <span class="s3">var </span><span class="s1">def, value, scope, in_loop, level = -</span><span class="s4">1</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;inline&quot;</span><span class="s1">)</span>
                <span class="s1">&amp;&amp; simple_args</span>
                <span class="s1">&amp;&amp; !fn.uses_arguments</span>
                <span class="s1">&amp;&amp; !fn.uses_eval</span>
                <span class="s1">&amp;&amp; !(fn.name &amp;&amp; fn </span><span class="s3">instanceof </span><span class="s1">AST_Function)</span>
                <span class="s1">&amp;&amp; (value = can_flatten_body(stat))</span>
                <span class="s1">&amp;&amp; (exp === fn</span>
                    <span class="s1">|| compressor.option(</span><span class="s2">&quot;unused&quot;</span><span class="s1">)</span>
                        <span class="s1">&amp;&amp; (def = exp.definition()).references.length == </span><span class="s4">1</span>
                        <span class="s1">&amp;&amp; !recursive_ref(compressor, def)</span>
                        <span class="s1">&amp;&amp; fn.is_constant_expression(exp.scope))</span>
                <span class="s1">&amp;&amp; !self.pure</span>
                <span class="s1">&amp;&amp; !fn.contains_this()</span>
                <span class="s1">&amp;&amp; can_inject_symbols()) {</span>
                <span class="s3">return </span><span class="s1">make_sequence(self, flatten_fn()).optimize(compressor);</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;side_effects&quot;</span><span class="s1">) &amp;&amp; !(fn.body </span><span class="s3">instanceof </span><span class="s1">AST_Node) &amp;&amp; all(fn.body, is_empty)) {</span>
                <span class="s3">var </span><span class="s1">args = self.args.concat(make_node(AST_Undefined, self));</span>
                <span class="s3">return </span><span class="s1">make_sequence(self, args).optimize(compressor);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;drop_console&quot;</span><span class="s1">)) {</span>
            <span class="s3">if </span><span class="s1">(exp </span><span class="s3">instanceof </span><span class="s1">AST_PropAccess) {</span>
                <span class="s3">var </span><span class="s1">name = exp.expression;</span>
                <span class="s3">while </span><span class="s1">(name.expression) {</span>
                    <span class="s1">name = name.expression;</span>
                <span class="s1">}</span>
                <span class="s3">if </span><span class="s1">(is_undeclared_ref(name) &amp;&amp; name.name == </span><span class="s2">&quot;console&quot;</span><span class="s1">) {</span>
                    <span class="s3">return </span><span class="s1">make_node(AST_Undefined, self).optimize(compressor);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;negate_iife&quot;</span><span class="s1">)</span>
            <span class="s1">&amp;&amp; compressor.parent() </span><span class="s3">instanceof </span><span class="s1">AST_SimpleStatement</span>
            <span class="s1">&amp;&amp; is_iife_call(self)) {</span>
            <span class="s3">return </span><span class="s1">self.negate(compressor, </span><span class="s3">true</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s3">var </span><span class="s1">ev = self.evaluate(compressor);</span>
        <span class="s3">if </span><span class="s1">(ev !== self) {</span>
            <span class="s1">ev = make_node_from_constant(ev, self).optimize(compressor);</span>
            <span class="s3">return </span><span class="s1">best_of(compressor, ev, self);</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">self;</span>

        <span class="s3">function </span><span class="s1">return_value(stat) {</span>
            <span class="s3">if </span><span class="s1">(!stat) </span><span class="s3">return </span><span class="s1">make_node(AST_Undefined, self);</span>
            <span class="s3">if </span><span class="s1">(stat </span><span class="s3">instanceof </span><span class="s1">AST_Return) {</span>
                <span class="s3">if </span><span class="s1">(!stat.value) </span><span class="s3">return </span><span class="s1">make_node(AST_Undefined, self);</span>
                <span class="s3">return </span><span class="s1">stat.value.clone(</span><span class="s3">true</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(stat </span><span class="s3">instanceof </span><span class="s1">AST_SimpleStatement) {</span>
                <span class="s3">return </span><span class="s1">make_node(AST_UnaryPrefix, stat, {</span>
                    <span class="s1">operator: </span><span class="s2">&quot;void&quot;</span><span class="s1">,</span>
                    <span class="s1">expression: stat.body.clone(</span><span class="s3">true</span><span class="s1">)</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">function </span><span class="s1">can_flatten_body(stat) {</span>
            <span class="s3">var </span><span class="s1">body = fn.body </span><span class="s3">instanceof </span><span class="s1">AST_Node ? [ fn.body ] : fn.body;</span>
            <span class="s3">var </span><span class="s1">len = body.length;</span>
            <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;inline&quot;</span><span class="s1">) &lt; </span><span class="s4">3</span><span class="s1">) {</span>
                <span class="s3">return </span><span class="s1">len == </span><span class="s4">1 </span><span class="s1">&amp;&amp; return_value(stat);</span>
            <span class="s1">}</span>
            <span class="s1">stat = </span><span class="s3">null</span><span class="s1">;</span>
            <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; len; i++) {</span>
                <span class="s3">var </span><span class="s1">line = body[i];</span>
                <span class="s3">if </span><span class="s1">(line </span><span class="s3">instanceof </span><span class="s1">AST_Var) {</span>
                    <span class="s3">if </span><span class="s1">(stat &amp;&amp; !all(line.definitions, </span><span class="s3">function</span><span class="s1">(var_def) {</span>
                        <span class="s3">return </span><span class="s1">!var_def.value;</span>
                    <span class="s1">})) {</span>
                        <span class="s3">return false</span><span class="s1">;</span>
                    <span class="s1">}</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(stat) {</span>
                    <span class="s3">return false</span><span class="s1">;</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s1">stat = line;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s3">return </span><span class="s1">return_value(stat);</span>
        <span class="s1">}</span>

        <span class="s3">function </span><span class="s1">can_inject_args(catches, safe_to_inject) {</span>
            <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">, len = fn.argnames.length; i &lt; len; i++) {</span>
                <span class="s3">var </span><span class="s1">arg = fn.argnames[i];</span>
                <span class="s3">if </span><span class="s1">(arg </span><span class="s3">instanceof </span><span class="s1">AST_DefaultAssign) {</span>
                    <span class="s3">if </span><span class="s1">(arg.left.__unused) </span><span class="s3">continue</span><span class="s1">;</span>
                    <span class="s3">return false</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s3">if </span><span class="s1">(arg </span><span class="s3">instanceof </span><span class="s1">AST_Destructuring) </span><span class="s3">return false</span><span class="s1">;</span>
                <span class="s3">if </span><span class="s1">(arg </span><span class="s3">instanceof </span><span class="s1">AST_Expansion) {</span>
                    <span class="s3">if </span><span class="s1">(arg.expression.__unused) </span><span class="s3">continue</span><span class="s1">;</span>
                    <span class="s3">return false</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s3">if </span><span class="s1">(arg.__unused) </span><span class="s3">continue</span><span class="s1">;</span>
                <span class="s3">if </span><span class="s1">(!safe_to_inject</span>
                    <span class="s1">|| catches[arg.name]</span>
                    <span class="s1">|| identifier_atom(arg.name)</span>
                    <span class="s1">|| scope.var_names()[arg.name]) {</span>
                    <span class="s3">return false</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s3">if </span><span class="s1">(in_loop) in_loop.push(arg.definition());</span>
            <span class="s1">}</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">function </span><span class="s1">can_inject_vars(catches, safe_to_inject) {</span>
            <span class="s3">var </span><span class="s1">len = fn.body.length;</span>
            <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; len; i++) {</span>
                <span class="s3">var </span><span class="s1">stat = fn.body[i];</span>
                <span class="s3">if </span><span class="s1">(!(stat </span><span class="s3">instanceof </span><span class="s1">AST_Var)) </span><span class="s3">continue</span><span class="s1">;</span>
                <span class="s3">if </span><span class="s1">(!safe_to_inject) </span><span class="s3">return false</span><span class="s1">;</span>
                <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">j = stat.definitions.length; --j &gt;= </span><span class="s4">0</span><span class="s1">;) {</span>
                    <span class="s3">var </span><span class="s1">name = stat.definitions[j].name;</span>
                    <span class="s3">if </span><span class="s1">(catches[name.name]</span>
                        <span class="s1">|| identifier_atom(name.name)</span>
                        <span class="s1">|| scope.var_names()[name.name]) {</span>
                        <span class="s3">return false</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s3">if </span><span class="s1">(in_loop) in_loop.push(name.definition());</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">function </span><span class="s1">can_inject_symbols() {</span>
            <span class="s3">var </span><span class="s1">catches = Object.create(</span><span class="s3">null</span><span class="s1">);</span>
            <span class="s3">do </span><span class="s1">{</span>
                <span class="s1">scope = compressor.parent(++level);</span>
                <span class="s3">if </span><span class="s1">(scope </span><span class="s3">instanceof </span><span class="s1">AST_Catch) {</span>
                    <span class="s1">catches[scope.argname.name] = </span><span class="s3">true</span><span class="s1">;</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(scope </span><span class="s3">instanceof </span><span class="s1">AST_IterationStatement) {</span>
                    <span class="s1">in_loop = [];</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(scope </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef) {</span>
                    <span class="s3">if </span><span class="s1">(scope.fixed_value() </span><span class="s3">instanceof </span><span class="s1">AST_Scope) </span><span class="s3">return false</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s3">while </span><span class="s1">(!(scope </span><span class="s3">instanceof </span><span class="s1">AST_Scope) || scope </span><span class="s3">instanceof </span><span class="s1">AST_Arrow);</span>
            <span class="s3">var </span><span class="s1">safe_to_inject = !(scope </span><span class="s3">instanceof </span><span class="s1">AST_Toplevel) || compressor.toplevel.vars;</span>
            <span class="s3">var </span><span class="s1">inline = compressor.option(</span><span class="s2">&quot;inline&quot;</span><span class="s1">);</span>
            <span class="s3">if </span><span class="s1">(!can_inject_vars(catches, inline &gt;= </span><span class="s4">3 </span><span class="s1">&amp;&amp; safe_to_inject)) </span><span class="s3">return false</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(!can_inject_args(catches, inline &gt;= </span><span class="s4">2 </span><span class="s1">&amp;&amp; safe_to_inject)) </span><span class="s3">return false</span><span class="s1">;</span>
            <span class="s3">return </span><span class="s1">!in_loop || in_loop.length == </span><span class="s4">0 </span><span class="s1">|| !is_reachable(fn, in_loop);</span>
        <span class="s1">}</span>

        <span class="s3">function </span><span class="s1">append_var(decls, expressions, name, value) {</span>
            <span class="s3">var </span><span class="s1">def = name.definition();</span>
            <span class="s1">scope.variables.set(name.name, def);</span>
            <span class="s1">scope.enclosed.push(def);</span>
            <span class="s3">if </span><span class="s1">(!scope.var_names()[name.name]) {</span>
                <span class="s1">scope.var_names()[name.name] = </span><span class="s3">true</span><span class="s1">;</span>
                <span class="s1">decls.push(make_node(AST_VarDef, name, {</span>
                    <span class="s1">name: name,</span>
                    <span class="s1">value: </span><span class="s3">null</span>
                <span class="s1">}));</span>
            <span class="s1">}</span>
            <span class="s3">var </span><span class="s1">sym = make_node(AST_SymbolRef, name, name);</span>
            <span class="s1">def.references.push(sym);</span>
            <span class="s3">if </span><span class="s1">(value) expressions.push(make_node(AST_Assign, self, {</span>
                <span class="s1">operator: </span><span class="s2">&quot;=&quot;</span><span class="s1">,</span>
                <span class="s1">left: sym,</span>
                <span class="s1">right: value</span>
            <span class="s1">}));</span>
        <span class="s1">}</span>

        <span class="s3">function </span><span class="s1">flatten_args(decls, expressions) {</span>
            <span class="s3">var </span><span class="s1">len = fn.argnames.length;</span>
            <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = self.args.length; --i &gt;= len;) {</span>
                <span class="s1">expressions.push(self.args[i]);</span>
            <span class="s1">}</span>
            <span class="s3">for </span><span class="s1">(i = len; --i &gt;= </span><span class="s4">0</span><span class="s1">;) {</span>
                <span class="s3">var </span><span class="s1">name = fn.argnames[i];</span>
                <span class="s3">var </span><span class="s1">value = self.args[i];</span>
                <span class="s3">if </span><span class="s1">(name.__unused || !name.name || scope.var_names()[name.name]) {</span>
                    <span class="s3">if </span><span class="s1">(value) expressions.push(value);</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s3">var </span><span class="s1">symbol = make_node(AST_SymbolVar, name, name);</span>
                    <span class="s1">name.definition().orig.push(symbol);</span>
                    <span class="s3">if </span><span class="s1">(!value &amp;&amp; in_loop) value = make_node(AST_Undefined, self);</span>
                    <span class="s1">append_var(decls, expressions, symbol, value);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">decls.reverse();</span>
            <span class="s1">expressions.reverse();</span>
        <span class="s1">}</span>

        <span class="s3">function </span><span class="s1">flatten_vars(decls, expressions) {</span>
            <span class="s3">var </span><span class="s1">pos = expressions.length;</span>
            <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">, lines = fn.body.length; i &lt; lines; i++) {</span>
                <span class="s3">var </span><span class="s1">stat = fn.body[i];</span>
                <span class="s3">if </span><span class="s1">(!(stat </span><span class="s3">instanceof </span><span class="s1">AST_Var)) </span><span class="s3">continue</span><span class="s1">;</span>
                <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">j = </span><span class="s4">0</span><span class="s1">, defs = stat.definitions.length; j &lt; defs; j++) {</span>
                    <span class="s3">var </span><span class="s1">var_def = stat.definitions[j];</span>
                    <span class="s3">var </span><span class="s1">name = var_def.name;</span>
                    <span class="s1">append_var(decls, expressions, name, var_def.value);</span>
                    <span class="s3">if </span><span class="s1">(in_loop) {</span>
                        <span class="s3">var </span><span class="s1">def = name.definition();</span>
                        <span class="s3">var </span><span class="s1">sym = make_node(AST_SymbolRef, name, name);</span>
                        <span class="s1">def.references.push(sym);</span>
                        <span class="s1">expressions.splice(pos++, </span><span class="s4">0</span><span class="s1">, make_node(AST_Assign, var_def, {</span>
                            <span class="s1">operator: </span><span class="s2">&quot;=&quot;</span><span class="s1">,</span>
                            <span class="s1">left: sym,</span>
                            <span class="s1">right: make_node(AST_Undefined, name)</span>
                        <span class="s1">}));</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">function </span><span class="s1">flatten_fn() {</span>
            <span class="s3">var </span><span class="s1">decls = [];</span>
            <span class="s3">var </span><span class="s1">expressions = [];</span>
            <span class="s1">flatten_args(decls, expressions);</span>
            <span class="s1">flatten_vars(decls, expressions);</span>
            <span class="s1">expressions.push(value);</span>
            <span class="s3">if </span><span class="s1">(decls.length) {</span>
                <span class="s1">i = scope.body.indexOf(compressor.parent(level - </span><span class="s4">1</span><span class="s1">)) + </span><span class="s4">1</span><span class="s1">;</span>
                <span class="s1">scope.body.splice(i, </span><span class="s4">0</span><span class="s1">, make_node(AST_Var, fn, {</span>
                    <span class="s1">definitions: decls</span>
                <span class="s1">}));</span>
            <span class="s1">}</span>
            <span class="s3">return </span><span class="s1">expressions;</span>
        <span class="s1">}</span>
    <span class="s1">});</span>

    <span class="s1">OPT(AST_New, </span><span class="s3">function</span><span class="s1">(self, compressor){</span>
        <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;unsafe&quot;</span><span class="s1">)) {</span>
            <span class="s3">var </span><span class="s1">exp = self.expression;</span>
            <span class="s3">if </span><span class="s1">(is_undeclared_ref(exp)) {</span>
                <span class="s3">switch </span><span class="s1">(exp.name) {</span>
                  <span class="s3">case </span><span class="s2">&quot;Object&quot;</span><span class="s1">:</span>
                  <span class="s3">case </span><span class="s2">&quot;RegExp&quot;</span><span class="s1">:</span>
                  <span class="s3">case </span><span class="s2">&quot;Function&quot;</span><span class="s1">:</span>
                  <span class="s3">case </span><span class="s2">&quot;Error&quot;</span><span class="s1">:</span>
                  <span class="s3">case </span><span class="s2">&quot;Array&quot;</span><span class="s1">:</span>
                    <span class="s3">return </span><span class="s1">make_node(AST_Call, self, self).transform(compressor);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">self;</span>
    <span class="s1">});</span>

    <span class="s1">OPT(AST_Sequence, </span><span class="s3">function</span><span class="s1">(self, compressor){</span>
        <span class="s3">if </span><span class="s1">(!compressor.option(</span><span class="s2">&quot;side_effects&quot;</span><span class="s1">)) </span><span class="s3">return </span><span class="s1">self;</span>
        <span class="s3">var </span><span class="s1">expressions = [];</span>
        <span class="s1">filter_for_side_effects();</span>
        <span class="s3">var </span><span class="s1">end = expressions.length - </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s1">trim_right_for_undefined();</span>
        <span class="s3">if </span><span class="s1">(end == </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s1">self = maintain_this_binding(compressor.parent(), compressor.self(), expressions[</span><span class="s4">0</span><span class="s1">]);</span>
            <span class="s3">if </span><span class="s1">(!(self </span><span class="s3">instanceof </span><span class="s1">AST_Sequence)) self = self.optimize(compressor);</span>
            <span class="s3">return </span><span class="s1">self;</span>
        <span class="s1">}</span>
        <span class="s1">self.expressions = expressions;</span>
        <span class="s3">return </span><span class="s1">self;</span>

        <span class="s3">function </span><span class="s1">filter_for_side_effects() {</span>
            <span class="s3">var </span><span class="s1">first = first_in_statement(compressor);</span>
            <span class="s3">var </span><span class="s1">last = self.expressions.length - </span><span class="s4">1</span><span class="s1">;</span>
            <span class="s1">self.expressions.forEach(</span><span class="s3">function</span><span class="s1">(expr, index) {</span>
                <span class="s3">if </span><span class="s1">(index &lt; last) expr = expr.drop_side_effect_free(compressor, first);</span>
                <span class="s3">if </span><span class="s1">(expr) {</span>
                    <span class="s1">merge_sequence(expressions, expr);</span>
                    <span class="s1">first = </span><span class="s3">false</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
        <span class="s1">}</span>

        <span class="s3">function </span><span class="s1">trim_right_for_undefined() {</span>
            <span class="s3">while </span><span class="s1">(end &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; is_undefined(expressions[end], compressor)) end--;</span>
            <span class="s3">if </span><span class="s1">(end &lt; expressions.length - </span><span class="s4">1</span><span class="s1">) {</span>
                <span class="s1">expressions[end] = make_node(AST_UnaryPrefix, self, {</span>
                    <span class="s1">operator   : </span><span class="s2">&quot;void&quot;</span><span class="s1">,</span>
                    <span class="s1">expression : expressions[end]</span>
                <span class="s1">});</span>
                <span class="s1">expressions.length = end + </span><span class="s4">1</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">});</span>

    <span class="s1">AST_Unary.DEFMETHOD(</span><span class="s2">&quot;lift_sequences&quot;</span><span class="s1">, </span><span class="s3">function</span><span class="s1">(compressor){</span>
        <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;sequences&quot;</span><span class="s1">)) {</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.expression </span><span class="s3">instanceof </span><span class="s1">AST_Sequence) {</span>
                <span class="s3">var </span><span class="s1">x = </span><span class="s3">this</span><span class="s1">.expression.expressions.slice();</span>
                <span class="s3">var </span><span class="s1">e = </span><span class="s3">this</span><span class="s1">.clone();</span>
                <span class="s1">e.expression = x.pop();</span>
                <span class="s1">x.push(e);</span>
                <span class="s3">return </span><span class="s1">make_sequence(</span><span class="s3">this</span><span class="s1">, x).optimize(compressor);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">return this</span><span class="s1">;</span>
    <span class="s1">});</span>

    <span class="s1">OPT(AST_UnaryPostfix, </span><span class="s3">function</span><span class="s1">(self, compressor){</span>
        <span class="s3">return </span><span class="s1">self.lift_sequences(compressor);</span>
    <span class="s1">});</span>

    <span class="s1">OPT(AST_UnaryPrefix, </span><span class="s3">function</span><span class="s1">(self, compressor){</span>
        <span class="s3">var </span><span class="s1">e = self.expression;</span>
        <span class="s3">if </span><span class="s1">(self.operator == </span><span class="s2">&quot;delete&quot;</span>
            <span class="s1">&amp;&amp; !(e </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef</span>
                <span class="s1">|| e </span><span class="s3">instanceof </span><span class="s1">AST_PropAccess</span>
                <span class="s1">|| is_identifier_atom(e))) {</span>
            <span class="s3">if </span><span class="s1">(e </span><span class="s3">instanceof </span><span class="s1">AST_Sequence) {</span>
                <span class="s1">e = e.expressions.slice();</span>
                <span class="s1">e.push(make_node(AST_True, self));</span>
                <span class="s3">return </span><span class="s1">make_sequence(self, e).optimize(compressor);</span>
            <span class="s1">}</span>
            <span class="s3">return </span><span class="s1">make_sequence(self, [ e, make_node(AST_True, self) ]).optimize(compressor);</span>
        <span class="s1">}</span>
        <span class="s3">var </span><span class="s1">seq = self.lift_sequences(compressor);</span>
        <span class="s3">if </span><span class="s1">(seq !== self) {</span>
            <span class="s3">return </span><span class="s1">seq;</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;side_effects&quot;</span><span class="s1">) &amp;&amp; self.operator == </span><span class="s2">&quot;void&quot;</span><span class="s1">) {</span>
            <span class="s1">e = e.drop_side_effect_free(compressor);</span>
            <span class="s3">if </span><span class="s1">(e) {</span>
                <span class="s1">self.expression = e;</span>
                <span class="s3">return </span><span class="s1">self;</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s3">return </span><span class="s1">make_node(AST_Undefined, self).optimize(compressor);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(compressor.in_boolean_context()) {</span>
            <span class="s3">switch </span><span class="s1">(self.operator) {</span>
              <span class="s3">case </span><span class="s2">&quot;!&quot;</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">(e </span><span class="s3">instanceof </span><span class="s1">AST_UnaryPrefix &amp;&amp; e.operator == </span><span class="s2">&quot;!&quot;</span><span class="s1">) {</span>
                    <span class="s0">// !!foo ==&gt; foo, if we're in boolean context</span>
                    <span class="s3">return </span><span class="s1">e.expression;</span>
                <span class="s1">}</span>
                <span class="s3">if </span><span class="s1">(e </span><span class="s3">instanceof </span><span class="s1">AST_Binary) {</span>
                    <span class="s1">self = best_of(compressor, self, e.negate(compressor, first_in_statement(compressor)));</span>
                <span class="s1">}</span>
                <span class="s3">break</span><span class="s1">;</span>
              <span class="s3">case </span><span class="s2">&quot;typeof&quot;</span><span class="s1">:</span>
                <span class="s0">// typeof always returns a non-empty string, thus it's</span>
                <span class="s0">// always true in booleans</span>
                <span class="s1">compressor.warn(</span><span class="s2">&quot;Boolean expression always true [{file}:{line},{col}]&quot;</span><span class="s1">, self.start);</span>
                <span class="s3">return </span><span class="s1">(e </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef ? make_node(AST_True, self) : make_sequence(self, [</span>
                    <span class="s1">e,</span>
                    <span class="s1">make_node(AST_True, self)</span>
                <span class="s1">])).optimize(compressor);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(self.operator == </span><span class="s2">&quot;-&quot; </span><span class="s1">&amp;&amp; e </span><span class="s3">instanceof </span><span class="s1">AST_Infinity) {</span>
            <span class="s1">e = e.transform(compressor);</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(e </span><span class="s3">instanceof </span><span class="s1">AST_Binary</span>
            <span class="s1">&amp;&amp; (self.operator == </span><span class="s2">&quot;+&quot; </span><span class="s1">|| self.operator == </span><span class="s2">&quot;-&quot;</span><span class="s1">)</span>
            <span class="s1">&amp;&amp; (e.operator == </span><span class="s2">&quot;*&quot; </span><span class="s1">|| e.operator == </span><span class="s2">&quot;/&quot; </span><span class="s1">|| e.operator == </span><span class="s2">&quot;%&quot;</span><span class="s1">)) {</span>
            <span class="s3">return </span><span class="s1">make_node(AST_Binary, self, {</span>
                <span class="s1">operator: e.operator,</span>
                <span class="s1">left: make_node(AST_UnaryPrefix, e.left, {</span>
                    <span class="s1">operator: self.operator,</span>
                    <span class="s1">expression: e.left</span>
                <span class="s1">}),</span>
                <span class="s1">right: e.right</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s0">// avoids infinite recursion of numerals</span>
        <span class="s3">if </span><span class="s1">(self.operator != </span><span class="s2">&quot;-&quot;</span>
            <span class="s1">|| !(e </span><span class="s3">instanceof </span><span class="s1">AST_Number || e </span><span class="s3">instanceof </span><span class="s1">AST_Infinity)) {</span>
            <span class="s3">var </span><span class="s1">ev = self.evaluate(compressor);</span>
            <span class="s3">if </span><span class="s1">(ev !== self) {</span>
                <span class="s1">ev = make_node_from_constant(ev, self).optimize(compressor);</span>
                <span class="s3">return </span><span class="s1">best_of(compressor, ev, self);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">self;</span>
    <span class="s1">});</span>

    <span class="s1">AST_Binary.DEFMETHOD(</span><span class="s2">&quot;lift_sequences&quot;</span><span class="s1">, </span><span class="s3">function</span><span class="s1">(compressor){</span>
        <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;sequences&quot;</span><span class="s1">)) {</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.left </span><span class="s3">instanceof </span><span class="s1">AST_Sequence) {</span>
                <span class="s3">var </span><span class="s1">x = </span><span class="s3">this</span><span class="s1">.left.expressions.slice();</span>
                <span class="s3">var </span><span class="s1">e = </span><span class="s3">this</span><span class="s1">.clone();</span>
                <span class="s1">e.left = x.pop();</span>
                <span class="s1">x.push(e);</span>
                <span class="s3">return </span><span class="s1">make_sequence(</span><span class="s3">this</span><span class="s1">, x).optimize(compressor);</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.right </span><span class="s3">instanceof </span><span class="s1">AST_Sequence &amp;&amp; !</span><span class="s3">this</span><span class="s1">.left.has_side_effects(compressor)) {</span>
                <span class="s3">var </span><span class="s1">assign = </span><span class="s3">this</span><span class="s1">.operator == </span><span class="s2">&quot;=&quot; </span><span class="s1">&amp;&amp; </span><span class="s3">this</span><span class="s1">.left </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef;</span>
                <span class="s3">var </span><span class="s1">x = </span><span class="s3">this</span><span class="s1">.right.expressions;</span>
                <span class="s3">var </span><span class="s1">last = x.length - </span><span class="s4">1</span><span class="s1">;</span>
                <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; last; i++) {</span>
                    <span class="s3">if </span><span class="s1">(!assign &amp;&amp; x[i].has_side_effects(compressor)) </span><span class="s3">break</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s3">if </span><span class="s1">(i == last) {</span>
                    <span class="s1">x = x.slice();</span>
                    <span class="s3">var </span><span class="s1">e = </span><span class="s3">this</span><span class="s1">.clone();</span>
                    <span class="s1">e.right = x.pop();</span>
                    <span class="s1">x.push(e);</span>
                    <span class="s3">return </span><span class="s1">make_sequence(</span><span class="s3">this</span><span class="s1">, x).optimize(compressor);</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(i &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                    <span class="s3">var </span><span class="s1">e = </span><span class="s3">this</span><span class="s1">.clone();</span>
                    <span class="s1">e.right = make_sequence(</span><span class="s3">this</span><span class="s1">.right, x.slice(i));</span>
                    <span class="s1">x = x.slice(</span><span class="s4">0</span><span class="s1">, i);</span>
                    <span class="s1">x.push(e);</span>
                    <span class="s3">return </span><span class="s1">make_sequence(</span><span class="s3">this</span><span class="s1">, x).optimize(compressor);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">return this</span><span class="s1">;</span>
    <span class="s1">});</span>

    <span class="s3">var </span><span class="s1">commutativeOperators = makePredicate(</span><span class="s2">&quot;== === != !== * &amp; | ^&quot;</span><span class="s1">);</span>
    <span class="s3">function </span><span class="s1">is_object(node) {</span>
        <span class="s3">return </span><span class="s1">node </span><span class="s3">instanceof </span><span class="s1">AST_Array</span>
            <span class="s1">|| node </span><span class="s3">instanceof </span><span class="s1">AST_Lambda</span>
            <span class="s1">|| node </span><span class="s3">instanceof </span><span class="s1">AST_Object</span>
            <span class="s1">|| node </span><span class="s3">instanceof </span><span class="s1">AST_Class;</span>
    <span class="s1">}</span>

    <span class="s1">OPT(AST_Binary, </span><span class="s3">function</span><span class="s1">(self, compressor){</span>
        <span class="s3">function </span><span class="s1">reversible() {</span>
            <span class="s3">return </span><span class="s1">self.left.is_constant()</span>
                <span class="s1">|| self.right.is_constant()</span>
                <span class="s1">|| !self.left.has_side_effects(compressor)</span>
                    <span class="s1">&amp;&amp; !self.right.has_side_effects(compressor);</span>
        <span class="s1">}</span>
        <span class="s3">function </span><span class="s1">reverse(op) {</span>
            <span class="s3">if </span><span class="s1">(reversible()) {</span>
                <span class="s3">if </span><span class="s1">(op) self.operator = op;</span>
                <span class="s3">var </span><span class="s1">tmp = self.left;</span>
                <span class="s1">self.left = self.right;</span>
                <span class="s1">self.right = tmp;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(commutativeOperators(self.operator)) {</span>
            <span class="s3">if </span><span class="s1">(self.right.is_constant()</span>
                <span class="s1">&amp;&amp; !self.left.is_constant()) {</span>
                <span class="s0">// if right is a constant, whatever side effects the</span>
                <span class="s0">// left side might have could not influence the</span>
                <span class="s0">// result.  hence, force switch.</span>

                <span class="s3">if </span><span class="s1">(!(self.left </span><span class="s3">instanceof </span><span class="s1">AST_Binary</span>
                      <span class="s1">&amp;&amp; PRECEDENCE[self.left.operator] &gt;= PRECEDENCE[self.operator])) {</span>
                    <span class="s1">reverse();</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">self = self.lift_sequences(compressor);</span>
        <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;comparisons&quot;</span><span class="s1">)) </span><span class="s3">switch </span><span class="s1">(self.operator) {</span>
          <span class="s3">case </span><span class="s2">&quot;===&quot;</span><span class="s1">:</span>
          <span class="s3">case </span><span class="s2">&quot;!==&quot;</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">((self.left.is_string(compressor) &amp;&amp; self.right.is_string(compressor)) ||</span>
                <span class="s1">(self.left.is_number(compressor) &amp;&amp; self.right.is_number(compressor)) ||</span>
                <span class="s1">(self.left.is_boolean() &amp;&amp; self.right.is_boolean()) ||</span>
                <span class="s1">self.left.equivalent_to(self.right)) {</span>
                <span class="s1">self.operator = self.operator.substr(</span><span class="s4">0</span><span class="s1">, </span><span class="s4">2</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s0">// XXX: intentionally falling down to the next case</span>
          <span class="s3">case </span><span class="s2">&quot;==&quot;</span><span class="s1">:</span>
          <span class="s3">case </span><span class="s2">&quot;!=&quot;</span><span class="s1">:</span>
            <span class="s0">// &quot;undefined&quot; == typeof x =&gt; undefined === x</span>
            <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;typeofs&quot;</span><span class="s1">)</span>
                <span class="s1">&amp;&amp; self.left </span><span class="s3">instanceof </span><span class="s1">AST_String</span>
                <span class="s1">&amp;&amp; self.left.value == </span><span class="s2">&quot;undefined&quot;</span>
                <span class="s1">&amp;&amp; self.right </span><span class="s3">instanceof </span><span class="s1">AST_UnaryPrefix</span>
                <span class="s1">&amp;&amp; self.right.operator == </span><span class="s2">&quot;typeof&quot;</span><span class="s1">) {</span>
                <span class="s3">var </span><span class="s1">expr = self.right.expression;</span>
                <span class="s3">if </span><span class="s1">(expr </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef ? expr.is_declared(compressor)</span>
                    <span class="s1">: !(expr </span><span class="s3">instanceof </span><span class="s1">AST_PropAccess &amp;&amp; compressor.option(</span><span class="s2">&quot;ie8&quot;</span><span class="s1">))) {</span>
                    <span class="s1">self.right = expr;</span>
                    <span class="s1">self.left = make_node(AST_Undefined, self.left).optimize(compressor);</span>
                    <span class="s3">if </span><span class="s1">(self.operator.length == </span><span class="s4">2</span><span class="s1">) self.operator += </span><span class="s2">&quot;=&quot;</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s0">// obj !== obj =&gt; false</span>
            <span class="s3">else if </span><span class="s1">(self.left </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef</span>
                <span class="s1">&amp;&amp; self.right </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef</span>
                <span class="s1">&amp;&amp; self.left.definition() === self.right.definition()</span>
                <span class="s1">&amp;&amp; is_object(self.left.fixed_value())) {</span>
                <span class="s3">return </span><span class="s1">make_node(self.operator[</span><span class="s4">0</span><span class="s1">] == </span><span class="s2">&quot;=&quot; </span><span class="s1">? AST_True : AST_False, self);</span>
            <span class="s1">}</span>
            <span class="s3">break</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(self.operator == </span><span class="s2">&quot;+&quot; </span><span class="s1">&amp;&amp; compressor.in_boolean_context()) {</span>
            <span class="s3">var </span><span class="s1">ll = self.left.evaluate(compressor);</span>
            <span class="s3">var </span><span class="s1">rr = self.right.evaluate(compressor);</span>
            <span class="s3">if </span><span class="s1">(ll &amp;&amp; </span><span class="s3">typeof </span><span class="s1">ll == </span><span class="s2">&quot;string&quot;</span><span class="s1">) {</span>
                <span class="s1">compressor.warn(</span><span class="s2">&quot;+ in boolean context always true [{file}:{line},{col}]&quot;</span><span class="s1">, self.start);</span>
                <span class="s3">return </span><span class="s1">make_sequence(self, [</span>
                    <span class="s1">self.right,</span>
                    <span class="s1">make_node(AST_True, self)</span>
                <span class="s1">]).optimize(compressor);</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(rr &amp;&amp; </span><span class="s3">typeof </span><span class="s1">rr == </span><span class="s2">&quot;string&quot;</span><span class="s1">) {</span>
                <span class="s1">compressor.warn(</span><span class="s2">&quot;+ in boolean context always true [{file}:{line},{col}]&quot;</span><span class="s1">, self.start);</span>
                <span class="s3">return </span><span class="s1">make_sequence(self, [</span>
                    <span class="s1">self.left,</span>
                    <span class="s1">make_node(AST_True, self)</span>
                <span class="s1">]).optimize(compressor);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;comparisons&quot;</span><span class="s1">) &amp;&amp; self.is_boolean()) {</span>
            <span class="s3">if </span><span class="s1">(!(compressor.parent() </span><span class="s3">instanceof </span><span class="s1">AST_Binary)</span>
                <span class="s1">|| compressor.parent() </span><span class="s3">instanceof </span><span class="s1">AST_Assign) {</span>
                <span class="s3">var </span><span class="s1">negated = make_node(AST_UnaryPrefix, self, {</span>
                    <span class="s1">operator: </span><span class="s2">&quot;!&quot;</span><span class="s1">,</span>
                    <span class="s1">expression: self.negate(compressor, first_in_statement(compressor))</span>
                <span class="s1">});</span>
                <span class="s1">self = best_of(compressor, self, negated);</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;unsafe_comps&quot;</span><span class="s1">)) {</span>
                <span class="s3">switch </span><span class="s1">(self.operator) {</span>
                  <span class="s3">case </span><span class="s2">&quot;&lt;&quot;</span><span class="s1">: reverse(</span><span class="s2">&quot;&gt;&quot;</span><span class="s1">); </span><span class="s3">break</span><span class="s1">;</span>
                  <span class="s3">case </span><span class="s2">&quot;&lt;=&quot;</span><span class="s1">: reverse(</span><span class="s2">&quot;&gt;=&quot;</span><span class="s1">); </span><span class="s3">break</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(self.operator == </span><span class="s2">&quot;+&quot;</span><span class="s1">) {</span>
            <span class="s3">if </span><span class="s1">(self.right </span><span class="s3">instanceof </span><span class="s1">AST_String</span>
                <span class="s1">&amp;&amp; self.right.getValue() == </span><span class="s2">&quot;&quot;</span>
                <span class="s1">&amp;&amp; self.left.is_string(compressor)) {</span>
                <span class="s3">return </span><span class="s1">self.left;</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(self.left </span><span class="s3">instanceof </span><span class="s1">AST_String</span>
                <span class="s1">&amp;&amp; self.left.getValue() == </span><span class="s2">&quot;&quot;</span>
                <span class="s1">&amp;&amp; self.right.is_string(compressor)) {</span>
                <span class="s3">return </span><span class="s1">self.right;</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(self.left </span><span class="s3">instanceof </span><span class="s1">AST_Binary</span>
                <span class="s1">&amp;&amp; self.left.operator == </span><span class="s2">&quot;+&quot;</span>
                <span class="s1">&amp;&amp; self.left.left </span><span class="s3">instanceof </span><span class="s1">AST_String</span>
                <span class="s1">&amp;&amp; self.left.left.getValue() == </span><span class="s2">&quot;&quot;</span>
                <span class="s1">&amp;&amp; self.right.is_string(compressor)) {</span>
                <span class="s1">self.left = self.left.right;</span>
                <span class="s3">return </span><span class="s1">self.transform(compressor);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;evaluate&quot;</span><span class="s1">)) {</span>
            <span class="s3">switch </span><span class="s1">(self.operator) {</span>
              <span class="s3">case </span><span class="s2">&quot;&amp;&amp;&quot;</span><span class="s1">:</span>
                <span class="s3">var </span><span class="s1">ll = self.left.truthy ? </span><span class="s3">true </span><span class="s1">: self.left.falsy ? </span><span class="s3">false </span><span class="s1">: self.left.evaluate(compressor);</span>
                <span class="s3">if </span><span class="s1">(!ll) {</span>
                    <span class="s1">compressor.warn(</span><span class="s2">&quot;Condition left of &amp;&amp; always false [{file}:{line},{col}]&quot;</span><span class="s1">, self.start);</span>
                    <span class="s3">return </span><span class="s1">maintain_this_binding(compressor.parent(), compressor.self(), self.left).optimize(compressor);</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(!(ll </span><span class="s3">instanceof </span><span class="s1">AST_Node)) {</span>
                    <span class="s1">compressor.warn(</span><span class="s2">&quot;Condition left of &amp;&amp; always true [{file}:{line},{col}]&quot;</span><span class="s1">, self.start);</span>
                    <span class="s3">return </span><span class="s1">make_sequence(self, [ self.left, self.right ]).optimize(compressor);</span>
                <span class="s1">}</span>
                <span class="s3">var </span><span class="s1">rr = self.right.evaluate(compressor);</span>
                <span class="s3">if </span><span class="s1">(!rr) {</span>
                    <span class="s3">if </span><span class="s1">(compressor.in_boolean_context()) {</span>
                        <span class="s1">compressor.warn(</span><span class="s2">&quot;Boolean &amp;&amp; always false [{file}:{line},{col}]&quot;</span><span class="s1">, self.start);</span>
                        <span class="s3">return </span><span class="s1">make_sequence(self, [</span>
                            <span class="s1">self.left,</span>
                            <span class="s1">make_node(AST_False, self)</span>
                        <span class="s1">]).optimize(compressor);</span>
                    <span class="s1">} </span><span class="s3">else </span><span class="s1">self.falsy = </span><span class="s3">true</span><span class="s1">;</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(!(rr </span><span class="s3">instanceof </span><span class="s1">AST_Node)) {</span>
                    <span class="s3">var </span><span class="s1">parent = compressor.parent();</span>
                    <span class="s3">if </span><span class="s1">(parent.operator == </span><span class="s2">&quot;&amp;&amp;&quot; </span><span class="s1">&amp;&amp; parent.left === compressor.self() || compressor.in_boolean_context()) {</span>
                        <span class="s1">compressor.warn(</span><span class="s2">&quot;Dropping side-effect-free &amp;&amp; [{file}:{line},{col}]&quot;</span><span class="s1">, self.start);</span>
                        <span class="s3">return </span><span class="s1">self.left.optimize(compressor);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s0">// x || false &amp;&amp; y ---&gt; x ? y : false</span>
                <span class="s3">if </span><span class="s1">(self.left.operator == </span><span class="s2">&quot;||&quot;</span><span class="s1">) {</span>
                    <span class="s3">var </span><span class="s1">lr = self.left.right.evaluate(compressor);</span>
                    <span class="s3">if </span><span class="s1">(!lr) </span><span class="s3">return </span><span class="s1">make_node(AST_Conditional, self, {</span>
                        <span class="s1">condition: self.left.left,</span>
                        <span class="s1">consequent: self.right,</span>
                        <span class="s1">alternative: self.left.right</span>
                    <span class="s1">}).optimize(compressor);</span>
                <span class="s1">}</span>
                <span class="s3">break</span><span class="s1">;</span>
              <span class="s3">case </span><span class="s2">&quot;||&quot;</span><span class="s1">:</span>
                <span class="s3">var </span><span class="s1">ll = self.left.truthy ? </span><span class="s3">true </span><span class="s1">: self.left.falsy ? </span><span class="s3">false </span><span class="s1">: self.left.evaluate(compressor);</span>
                <span class="s3">if </span><span class="s1">(!ll) {</span>
                    <span class="s1">compressor.warn(</span><span class="s2">&quot;Condition left of || always false [{file}:{line},{col}]&quot;</span><span class="s1">, self.start);</span>
                    <span class="s3">return </span><span class="s1">make_sequence(self, [ self.left, self.right ]).optimize(compressor);</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(!(ll </span><span class="s3">instanceof </span><span class="s1">AST_Node)) {</span>
                    <span class="s1">compressor.warn(</span><span class="s2">&quot;Condition left of || always true [{file}:{line},{col}]&quot;</span><span class="s1">, self.start);</span>
                    <span class="s3">return </span><span class="s1">maintain_this_binding(compressor.parent(), compressor.self(), self.left).optimize(compressor);</span>
                <span class="s1">}</span>
                <span class="s3">var </span><span class="s1">rr = self.right.evaluate(compressor);</span>
                <span class="s3">if </span><span class="s1">(!rr) {</span>
                    <span class="s3">var </span><span class="s1">parent = compressor.parent();</span>
                    <span class="s3">if </span><span class="s1">(parent.operator == </span><span class="s2">&quot;||&quot; </span><span class="s1">&amp;&amp; parent.left === compressor.self() || compressor.in_boolean_context()) {</span>
                        <span class="s1">compressor.warn(</span><span class="s2">&quot;Dropping side-effect-free || [{file}:{line},{col}]&quot;</span><span class="s1">, self.start);</span>
                        <span class="s3">return </span><span class="s1">self.left.optimize(compressor);</span>
                    <span class="s1">}</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(!(rr </span><span class="s3">instanceof </span><span class="s1">AST_Node)) {</span>
                    <span class="s3">if </span><span class="s1">(compressor.in_boolean_context()) {</span>
                        <span class="s1">compressor.warn(</span><span class="s2">&quot;Boolean || always true [{file}:{line},{col}]&quot;</span><span class="s1">, self.start);</span>
                        <span class="s3">return </span><span class="s1">make_sequence(self, [</span>
                            <span class="s1">self.left,</span>
                            <span class="s1">make_node(AST_True, self)</span>
                        <span class="s1">]).optimize(compressor);</span>
                    <span class="s1">} </span><span class="s3">else </span><span class="s1">self.truthy = </span><span class="s3">true</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s3">if </span><span class="s1">(self.left.operator == </span><span class="s2">&quot;&amp;&amp;&quot;</span><span class="s1">) {</span>
                    <span class="s3">var </span><span class="s1">lr = self.left.right.evaluate(compressor);</span>
                    <span class="s3">if </span><span class="s1">(lr &amp;&amp; !(lr </span><span class="s3">instanceof </span><span class="s1">AST_Node)) </span><span class="s3">return </span><span class="s1">make_node(AST_Conditional, self, {</span>
                        <span class="s1">condition: self.left.left,</span>
                        <span class="s1">consequent: self.left.right,</span>
                        <span class="s1">alternative: self.right</span>
                    <span class="s1">}).optimize(compressor);</span>
                <span class="s1">}</span>
                <span class="s3">break</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">var </span><span class="s1">associative = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s3">switch </span><span class="s1">(self.operator) {</span>
              <span class="s3">case </span><span class="s2">&quot;+&quot;</span><span class="s1">:</span>
                <span class="s0">// &quot;foo&quot; + (&quot;bar&quot; + x) =&gt; &quot;foobar&quot; + x</span>
                <span class="s3">if </span><span class="s1">(self.left </span><span class="s3">instanceof </span><span class="s1">AST_Constant</span>
                    <span class="s1">&amp;&amp; self.right </span><span class="s3">instanceof </span><span class="s1">AST_Binary</span>
                    <span class="s1">&amp;&amp; self.right.operator == </span><span class="s2">&quot;+&quot;</span>
                    <span class="s1">&amp;&amp; self.right.left </span><span class="s3">instanceof </span><span class="s1">AST_Constant</span>
                    <span class="s1">&amp;&amp; self.right.is_string(compressor)) {</span>
                    <span class="s1">self = make_node(AST_Binary, self, {</span>
                        <span class="s1">operator: </span><span class="s2">&quot;+&quot;</span><span class="s1">,</span>
                        <span class="s1">left: make_node(AST_String, self.left, {</span>
                            <span class="s1">value: </span><span class="s2">&quot;&quot; </span><span class="s1">+ self.left.getValue() + self.right.left.getValue(),</span>
                            <span class="s1">start: self.left.start,</span>
                            <span class="s1">end: self.right.left.end</span>
                        <span class="s1">}),</span>
                        <span class="s1">right: self.right.right</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s0">// (x + &quot;foo&quot;) + &quot;bar&quot; =&gt; x + &quot;foobar&quot;</span>
                <span class="s3">if </span><span class="s1">(self.right </span><span class="s3">instanceof </span><span class="s1">AST_Constant</span>
                    <span class="s1">&amp;&amp; self.left </span><span class="s3">instanceof </span><span class="s1">AST_Binary</span>
                    <span class="s1">&amp;&amp; self.left.operator == </span><span class="s2">&quot;+&quot;</span>
                    <span class="s1">&amp;&amp; self.left.right </span><span class="s3">instanceof </span><span class="s1">AST_Constant</span>
                    <span class="s1">&amp;&amp; self.left.is_string(compressor)) {</span>
                    <span class="s1">self = make_node(AST_Binary, self, {</span>
                        <span class="s1">operator: </span><span class="s2">&quot;+&quot;</span><span class="s1">,</span>
                        <span class="s1">left: self.left.left,</span>
                        <span class="s1">right: make_node(AST_String, self.right, {</span>
                            <span class="s1">value: </span><span class="s2">&quot;&quot; </span><span class="s1">+ self.left.right.getValue() + self.right.getValue(),</span>
                            <span class="s1">start: self.left.right.start,</span>
                            <span class="s1">end: self.right.end</span>
                        <span class="s1">})</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s0">// (x + &quot;foo&quot;) + (&quot;bar&quot; + y) =&gt; (x + &quot;foobar&quot;) + y</span>
                <span class="s3">if </span><span class="s1">(self.left </span><span class="s3">instanceof </span><span class="s1">AST_Binary</span>
                    <span class="s1">&amp;&amp; self.left.operator == </span><span class="s2">&quot;+&quot;</span>
                    <span class="s1">&amp;&amp; self.left.is_string(compressor)</span>
                    <span class="s1">&amp;&amp; self.left.right </span><span class="s3">instanceof </span><span class="s1">AST_Constant</span>
                    <span class="s1">&amp;&amp; self.right </span><span class="s3">instanceof </span><span class="s1">AST_Binary</span>
                    <span class="s1">&amp;&amp; self.right.operator == </span><span class="s2">&quot;+&quot;</span>
                    <span class="s1">&amp;&amp; self.right.left </span><span class="s3">instanceof </span><span class="s1">AST_Constant</span>
                    <span class="s1">&amp;&amp; self.right.is_string(compressor)) {</span>
                    <span class="s1">self = make_node(AST_Binary, self, {</span>
                        <span class="s1">operator: </span><span class="s2">&quot;+&quot;</span><span class="s1">,</span>
                        <span class="s1">left: make_node(AST_Binary, self.left, {</span>
                            <span class="s1">operator: </span><span class="s2">&quot;+&quot;</span><span class="s1">,</span>
                            <span class="s1">left: self.left.left,</span>
                            <span class="s1">right: make_node(AST_String, self.left.right, {</span>
                                <span class="s1">value: </span><span class="s2">&quot;&quot; </span><span class="s1">+ self.left.right.getValue() + self.right.left.getValue(),</span>
                                <span class="s1">start: self.left.right.start,</span>
                                <span class="s1">end: self.right.left.end</span>
                            <span class="s1">})</span>
                        <span class="s1">}),</span>
                        <span class="s1">right: self.right.right</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s0">// a + -b =&gt; a - b</span>
                <span class="s3">if </span><span class="s1">(self.right </span><span class="s3">instanceof </span><span class="s1">AST_UnaryPrefix</span>
                    <span class="s1">&amp;&amp; self.right.operator == </span><span class="s2">&quot;-&quot;</span>
                    <span class="s1">&amp;&amp; self.left.is_number(compressor)) {</span>
                    <span class="s1">self = make_node(AST_Binary, self, {</span>
                        <span class="s1">operator: </span><span class="s2">&quot;-&quot;</span><span class="s1">,</span>
                        <span class="s1">left: self.left,</span>
                        <span class="s1">right: self.right.expression</span>
                    <span class="s1">});</span>
                    <span class="s3">break</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s0">// -a + b =&gt; b - a</span>
                <span class="s3">if </span><span class="s1">(self.left </span><span class="s3">instanceof </span><span class="s1">AST_UnaryPrefix</span>
                    <span class="s1">&amp;&amp; self.left.operator == </span><span class="s2">&quot;-&quot;</span>
                    <span class="s1">&amp;&amp; reversible()</span>
                    <span class="s1">&amp;&amp; self.right.is_number(compressor)) {</span>
                    <span class="s1">self = make_node(AST_Binary, self, {</span>
                        <span class="s1">operator: </span><span class="s2">&quot;-&quot;</span><span class="s1">,</span>
                        <span class="s1">left: self.right,</span>
                        <span class="s1">right: self.left.expression</span>
                    <span class="s1">});</span>
                    <span class="s3">break</span><span class="s1">;</span>
                <span class="s1">}</span>
              <span class="s3">case </span><span class="s2">&quot;*&quot;</span><span class="s1">:</span>
                <span class="s1">associative = compressor.option(</span><span class="s2">&quot;unsafe_math&quot;</span><span class="s1">);</span>
              <span class="s3">case </span><span class="s2">&quot;&amp;&quot;</span><span class="s1">:</span>
              <span class="s3">case </span><span class="s2">&quot;|&quot;</span><span class="s1">:</span>
              <span class="s3">case </span><span class="s2">&quot;^&quot;</span><span class="s1">:</span>
                <span class="s0">// a + +b =&gt; +b + a</span>
                <span class="s3">if </span><span class="s1">(self.left.is_number(compressor)</span>
                    <span class="s1">&amp;&amp; self.right.is_number(compressor)</span>
                    <span class="s1">&amp;&amp; reversible()</span>
                    <span class="s1">&amp;&amp; !(self.left </span><span class="s3">instanceof </span><span class="s1">AST_Binary</span>
                        <span class="s1">&amp;&amp; self.left.operator != self.operator</span>
                        <span class="s1">&amp;&amp; PRECEDENCE[self.left.operator] &gt;= PRECEDENCE[self.operator])) {</span>
                    <span class="s3">var </span><span class="s1">reversed = make_node(AST_Binary, self, {</span>
                        <span class="s1">operator: self.operator,</span>
                        <span class="s1">left: self.right,</span>
                        <span class="s1">right: self.left</span>
                    <span class="s1">});</span>
                    <span class="s3">if </span><span class="s1">(self.right </span><span class="s3">instanceof </span><span class="s1">AST_Constant</span>
                        <span class="s1">&amp;&amp; !(self.left </span><span class="s3">instanceof </span><span class="s1">AST_Constant)) {</span>
                        <span class="s1">self = best_of(compressor, reversed, self);</span>
                    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                        <span class="s1">self = best_of(compressor, self, reversed);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s3">if </span><span class="s1">(associative &amp;&amp; self.is_number(compressor)) {</span>
                    <span class="s0">// a + (b + c) =&gt; (a + b) + c</span>
                    <span class="s3">if </span><span class="s1">(self.right </span><span class="s3">instanceof </span><span class="s1">AST_Binary</span>
                        <span class="s1">&amp;&amp; self.right.operator == self.operator) {</span>
                        <span class="s1">self = make_node(AST_Binary, self, {</span>
                            <span class="s1">operator: self.operator,</span>
                            <span class="s1">left: make_node(AST_Binary, self.left, {</span>
                                <span class="s1">operator: self.operator,</span>
                                <span class="s1">left: self.left,</span>
                                <span class="s1">right: self.right.left,</span>
                                <span class="s1">start: self.left.start,</span>
                                <span class="s1">end: self.right.left.end</span>
                            <span class="s1">}),</span>
                            <span class="s1">right: self.right.right</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                    <span class="s0">// (n + 2) + 3 =&gt; 5 + n</span>
                    <span class="s0">// (2 * n) * 3 =&gt; 6 + n</span>
                    <span class="s3">if </span><span class="s1">(self.right </span><span class="s3">instanceof </span><span class="s1">AST_Constant</span>
                        <span class="s1">&amp;&amp; self.left </span><span class="s3">instanceof </span><span class="s1">AST_Binary</span>
                        <span class="s1">&amp;&amp; self.left.operator == self.operator) {</span>
                        <span class="s3">if </span><span class="s1">(self.left.left </span><span class="s3">instanceof </span><span class="s1">AST_Constant) {</span>
                            <span class="s1">self = make_node(AST_Binary, self, {</span>
                                <span class="s1">operator: self.operator,</span>
                                <span class="s1">left: make_node(AST_Binary, self.left, {</span>
                                    <span class="s1">operator: self.operator,</span>
                                    <span class="s1">left: self.left.left,</span>
                                    <span class="s1">right: self.right,</span>
                                    <span class="s1">start: self.left.left.start,</span>
                                    <span class="s1">end: self.right.end</span>
                                <span class="s1">}),</span>
                                <span class="s1">right: self.left.right</span>
                            <span class="s1">});</span>
                        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(self.left.right </span><span class="s3">instanceof </span><span class="s1">AST_Constant) {</span>
                            <span class="s1">self = make_node(AST_Binary, self, {</span>
                                <span class="s1">operator: self.operator,</span>
                                <span class="s1">left: make_node(AST_Binary, self.left, {</span>
                                    <span class="s1">operator: self.operator,</span>
                                    <span class="s1">left: self.left.right,</span>
                                    <span class="s1">right: self.right,</span>
                                    <span class="s1">start: self.left.right.start,</span>
                                    <span class="s1">end: self.right.end</span>
                                <span class="s1">}),</span>
                                <span class="s1">right: self.left.left</span>
                            <span class="s1">});</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s0">// (a | 1) | (2 | d) =&gt; (3 | a) | b</span>
                    <span class="s3">if </span><span class="s1">(self.left </span><span class="s3">instanceof </span><span class="s1">AST_Binary</span>
                        <span class="s1">&amp;&amp; self.left.operator == self.operator</span>
                        <span class="s1">&amp;&amp; self.left.right </span><span class="s3">instanceof </span><span class="s1">AST_Constant</span>
                        <span class="s1">&amp;&amp; self.right </span><span class="s3">instanceof </span><span class="s1">AST_Binary</span>
                        <span class="s1">&amp;&amp; self.right.operator == self.operator</span>
                        <span class="s1">&amp;&amp; self.right.left </span><span class="s3">instanceof </span><span class="s1">AST_Constant) {</span>
                        <span class="s1">self = make_node(AST_Binary, self, {</span>
                            <span class="s1">operator: self.operator,</span>
                            <span class="s1">left: make_node(AST_Binary, self.left, {</span>
                                <span class="s1">operator: self.operator,</span>
                                <span class="s1">left: make_node(AST_Binary, self.left.left, {</span>
                                    <span class="s1">operator: self.operator,</span>
                                    <span class="s1">left: self.left.right,</span>
                                    <span class="s1">right: self.right.left,</span>
                                    <span class="s1">start: self.left.right.start,</span>
                                    <span class="s1">end: self.right.left.end</span>
                                <span class="s1">}),</span>
                                <span class="s1">right: self.left.left</span>
                            <span class="s1">}),</span>
                            <span class="s1">right: self.right.right</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">// x &amp;&amp; (y &amp;&amp; z)  ==&gt;  x &amp;&amp; y &amp;&amp; z</span>
        <span class="s0">// x || (y || z)  ==&gt;  x || y || z</span>
        <span class="s0">// x + (&quot;y&quot; + z)  ==&gt;  x + &quot;y&quot; + z</span>
        <span class="s0">// &quot;x&quot; + (y + &quot;z&quot;)==&gt;  &quot;x&quot; + y + &quot;z&quot;</span>
        <span class="s3">if </span><span class="s1">(self.right </span><span class="s3">instanceof </span><span class="s1">AST_Binary</span>
            <span class="s1">&amp;&amp; self.right.operator == self.operator</span>
            <span class="s1">&amp;&amp; (lazy_op(self.operator)</span>
                <span class="s1">|| (self.operator == </span><span class="s2">&quot;+&quot;</span>
                    <span class="s1">&amp;&amp; (self.right.left.is_string(compressor)</span>
                        <span class="s1">|| (self.left.is_string(compressor)</span>
                            <span class="s1">&amp;&amp; self.right.right.is_string(compressor))))))</span>
        <span class="s1">{</span>
            <span class="s1">self.left = make_node(AST_Binary, self.left, {</span>
                <span class="s1">operator : self.operator,</span>
                <span class="s1">left     : self.left,</span>
                <span class="s1">right    : self.right.left</span>
            <span class="s1">});</span>
            <span class="s1">self.right = self.right.right;</span>
            <span class="s3">return </span><span class="s1">self.transform(compressor);</span>
        <span class="s1">}</span>
        <span class="s3">var </span><span class="s1">ev = self.evaluate(compressor);</span>
        <span class="s3">if </span><span class="s1">(ev !== self) {</span>
            <span class="s1">ev = make_node_from_constant(ev, self).optimize(compressor);</span>
            <span class="s3">return </span><span class="s1">best_of(compressor, ev, self);</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">self;</span>
    <span class="s1">});</span>

    <span class="s1">OPT(AST_SymbolExport, </span><span class="s3">function</span><span class="s1">(self, compressor){</span>
        <span class="s3">return </span><span class="s1">self;</span>
    <span class="s1">});</span>

    <span class="s3">function </span><span class="s1">recursive_ref(compressor, def) {</span>
        <span class="s3">var </span><span class="s1">node;</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; node = compressor.parent(i); i++) {</span>
            <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Lambda) {</span>
                <span class="s3">var </span><span class="s1">name = node.name;</span>
                <span class="s3">if </span><span class="s1">(name &amp;&amp; name.definition() === def) </span><span class="s3">break</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">node;</span>
    <span class="s1">}</span>

    <span class="s1">OPT(AST_SymbolRef, </span><span class="s3">function</span><span class="s1">(self, compressor){</span>
        <span class="s3">var </span><span class="s1">def = self.resolve_defines(compressor);</span>
        <span class="s3">if </span><span class="s1">(def) {</span>
            <span class="s3">return </span><span class="s1">def.optimize(compressor);</span>
        <span class="s1">}</span>
        <span class="s0">// testing against !self.scope.uses_with first is an optimization</span>
        <span class="s3">if </span><span class="s1">(!compressor.option(</span><span class="s2">&quot;ie8&quot;</span><span class="s1">)</span>
            <span class="s1">&amp;&amp; is_undeclared_ref(self)</span>
            <span class="s1">&amp;&amp; (!self.scope.uses_with || !compressor.find_parent(AST_With))) {</span>
            <span class="s3">switch </span><span class="s1">(self.name) {</span>
              <span class="s3">case </span><span class="s2">&quot;undefined&quot;</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">make_node(AST_Undefined, self).optimize(compressor);</span>
              <span class="s3">case </span><span class="s2">&quot;NaN&quot;</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">make_node(AST_NaN, self).optimize(compressor);</span>
              <span class="s3">case </span><span class="s2">&quot;Infinity&quot;</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">make_node(AST_Infinity, self).optimize(compressor);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;reduce_vars&quot;</span><span class="s1">)</span>
            <span class="s1">&amp;&amp; is_lhs(self, compressor.parent()) !== self) {</span>
            <span class="s3">var </span><span class="s1">d = self.definition();</span>
            <span class="s3">var </span><span class="s1">fixed = self.fixed_value();</span>
            <span class="s3">var </span><span class="s1">single_use = d.single_use;</span>
            <span class="s3">if </span><span class="s1">(single_use &amp;&amp; (fixed </span><span class="s3">instanceof </span><span class="s1">AST_Lambda || fixed </span><span class="s3">instanceof </span><span class="s1">AST_Class)) {</span>
                <span class="s3">if </span><span class="s1">(d.scope !== self.scope</span>
                    <span class="s1">&amp;&amp; (!compressor.option(</span><span class="s2">&quot;reduce_funcs&quot;</span><span class="s1">) &amp;&amp; fixed </span><span class="s3">instanceof </span><span class="s1">AST_Lambda</span>
                        <span class="s1">|| d.escaped == </span><span class="s4">1</span>
                        <span class="s1">|| fixed.inlined)) {</span>
                    <span class="s1">single_use = </span><span class="s3">false</span><span class="s1">;</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(recursive_ref(compressor, d)) {</span>
                    <span class="s1">single_use = </span><span class="s3">false</span><span class="s1">;</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(d.scope !== self.scope || d.orig[</span><span class="s4">0</span><span class="s1">] </span><span class="s3">instanceof </span><span class="s1">AST_SymbolFunarg) {</span>
                    <span class="s1">single_use = fixed.is_constant_expression(self.scope);</span>
                    <span class="s3">if </span><span class="s1">(single_use == </span><span class="s2">&quot;f&quot;</span><span class="s1">) {</span>
                        <span class="s3">var </span><span class="s1">scope = self.scope;</span>
                        <span class="s3">do </span><span class="s1">{</span>
                            <span class="s3">if </span><span class="s1">(scope </span><span class="s3">instanceof </span><span class="s1">AST_Defun || is_func_expr(scope)) {</span>
                                <span class="s1">scope.inlined = </span><span class="s3">true</span><span class="s1">;</span>
                            <span class="s1">}</span>
                        <span class="s1">} </span><span class="s3">while </span><span class="s1">(scope = scope.parent_scope);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(single_use &amp;&amp; fixed) {</span>
                <span class="s3">if </span><span class="s1">(fixed </span><span class="s3">instanceof </span><span class="s1">AST_DefClass) {</span>
                    <span class="s1">fixed = make_node(AST_ClassExpression, fixed, fixed);</span>
                <span class="s1">}</span>
                <span class="s3">if </span><span class="s1">(fixed </span><span class="s3">instanceof </span><span class="s1">AST_Defun) {</span>
                    <span class="s1">fixed._squeezed = </span><span class="s3">true</span><span class="s1">;</span>
                    <span class="s1">fixed = make_node(AST_Function, fixed, fixed);</span>
                <span class="s1">}</span>
                <span class="s3">var </span><span class="s1">value;</span>
                <span class="s3">if </span><span class="s1">(d.recursive_refs &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; fixed.name </span><span class="s3">instanceof </span><span class="s1">AST_SymbolDefun) {</span>
                    <span class="s1">value = fixed.clone(</span><span class="s3">true</span><span class="s1">);</span>
                    <span class="s3">var </span><span class="s1">defun_def = value.name.definition();</span>
                    <span class="s3">var </span><span class="s1">lambda_def = value.variables.get(value.name.name);</span>
                    <span class="s3">var </span><span class="s1">name = lambda_def &amp;&amp; lambda_def.orig[</span><span class="s4">0</span><span class="s1">];</span>
                    <span class="s3">if </span><span class="s1">(!(name </span><span class="s3">instanceof </span><span class="s1">AST_SymbolLambda)) {</span>
                        <span class="s1">name = make_node(AST_SymbolLambda, value.name, value.name);</span>
                        <span class="s1">name.scope = value;</span>
                        <span class="s1">value.name = name;</span>
                        <span class="s1">lambda_def = value.def_function(name);</span>
                    <span class="s1">}</span>
                    <span class="s1">value.walk(</span><span class="s3">new </span><span class="s1">TreeWalker(</span><span class="s3">function</span><span class="s1">(node) {</span>
                        <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef &amp;&amp; node.definition() === defun_def) {</span>
                            <span class="s1">node.thedef = lambda_def;</span>
                            <span class="s1">lambda_def.references.push(node);</span>
                        <span class="s1">}</span>
                    <span class="s1">}));</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s1">value = fixed.optimize(compressor);</span>
                    <span class="s3">if </span><span class="s1">(value === fixed) value = fixed.clone(</span><span class="s3">true</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s3">return </span><span class="s1">value;</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(fixed &amp;&amp; d.should_replace === undefined) {</span>
                <span class="s3">var </span><span class="s1">init;</span>
                <span class="s3">if </span><span class="s1">(fixed </span><span class="s3">instanceof </span><span class="s1">AST_This) {</span>
                    <span class="s3">if </span><span class="s1">(!(d.orig[</span><span class="s4">0</span><span class="s1">] </span><span class="s3">instanceof </span><span class="s1">AST_SymbolFunarg)</span>
                        <span class="s1">&amp;&amp; all(d.references, </span><span class="s3">function</span><span class="s1">(ref) {</span>
                            <span class="s3">return </span><span class="s1">d.scope === ref.scope;</span>
                        <span class="s1">})) {</span>
                        <span class="s1">init = fixed;</span>
                    <span class="s1">}</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s3">var </span><span class="s1">ev = fixed.evaluate(compressor);</span>
                    <span class="s3">if </span><span class="s1">(ev !== fixed &amp;&amp; (compressor.option(</span><span class="s2">&quot;unsafe_regexp&quot;</span><span class="s1">) || !(ev </span><span class="s3">instanceof </span><span class="s1">RegExp))) {</span>
                        <span class="s1">init = make_node_from_constant(ev, fixed);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s3">if </span><span class="s1">(init) {</span>
                    <span class="s3">var </span><span class="s1">value_length = init.optimize(compressor).print_to_string().length;</span>
                    <span class="s3">var </span><span class="s1">fn;</span>
                    <span class="s3">if </span><span class="s1">(has_symbol_ref(fixed)) {</span>
                        <span class="s1">fn = </span><span class="s3">function</span><span class="s1">() {</span>
                            <span class="s3">var </span><span class="s1">result = init.optimize(compressor);</span>
                            <span class="s3">return </span><span class="s1">result === init ? result.clone(</span><span class="s3">true</span><span class="s1">) : result;</span>
                        <span class="s1">};</span>
                    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                        <span class="s1">value_length = Math.min(value_length, fixed.print_to_string().length);</span>
                        <span class="s1">fn = </span><span class="s3">function</span><span class="s1">() {</span>
                            <span class="s3">var </span><span class="s1">result = best_of_expression(init.optimize(compressor), fixed);</span>
                            <span class="s3">return </span><span class="s1">result === init || result === fixed ? result.clone(</span><span class="s3">true</span><span class="s1">) : result;</span>
                        <span class="s1">};</span>
                    <span class="s1">}</span>
                    <span class="s3">var </span><span class="s1">name_length = d.name.length;</span>
                    <span class="s3">var </span><span class="s1">overhead = </span><span class="s4">0</span><span class="s1">;</span>
                    <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;unused&quot;</span><span class="s1">) &amp;&amp; !compressor.exposed(d)) {</span>
                        <span class="s1">overhead = (name_length + </span><span class="s4">2 </span><span class="s1">+ value_length) / d.references.length;</span>
                    <span class="s1">}</span>
                    <span class="s1">d.should_replace = value_length &lt;= name_length + overhead ? fn : </span><span class="s3">false</span><span class="s1">;</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s1">d.should_replace = </span><span class="s3">false</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(d.should_replace) {</span>
                <span class="s3">return </span><span class="s1">d.should_replace();</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">self;</span>

        <span class="s3">function </span><span class="s1">has_symbol_ref(value) {</span>
            <span class="s3">var </span><span class="s1">found;</span>
            <span class="s1">value.walk(</span><span class="s3">new </span><span class="s1">TreeWalker(</span><span class="s3">function</span><span class="s1">(node) {</span>
                <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef) found = </span><span class="s3">true</span><span class="s1">;</span>
                <span class="s3">if </span><span class="s1">(found) </span><span class="s3">return true</span><span class="s1">;</span>
            <span class="s1">}));</span>
            <span class="s3">return </span><span class="s1">found;</span>
        <span class="s1">}</span>
    <span class="s1">});</span>

    <span class="s3">function </span><span class="s1">is_atomic(lhs, self) {</span>
        <span class="s3">return </span><span class="s1">lhs </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef || lhs.TYPE === self.TYPE;</span>
    <span class="s1">}</span>

    <span class="s1">OPT(AST_Undefined, </span><span class="s3">function</span><span class="s1">(self, compressor){</span>
        <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;unsafe_undefined&quot;</span><span class="s1">)) {</span>
            <span class="s3">var </span><span class="s1">undef = find_variable(compressor, </span><span class="s2">&quot;undefined&quot;</span><span class="s1">);</span>
            <span class="s3">if </span><span class="s1">(undef) {</span>
                <span class="s3">var </span><span class="s1">ref = make_node(AST_SymbolRef, self, {</span>
                    <span class="s1">name   : </span><span class="s2">&quot;undefined&quot;</span><span class="s1">,</span>
                    <span class="s1">scope  : undef.scope,</span>
                    <span class="s1">thedef : undef</span>
                <span class="s1">});</span>
                <span class="s1">ref.is_undefined = </span><span class="s3">true</span><span class="s1">;</span>
                <span class="s3">return </span><span class="s1">ref;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">var </span><span class="s1">lhs = is_lhs(compressor.self(), compressor.parent());</span>
        <span class="s3">if </span><span class="s1">(lhs &amp;&amp; is_atomic(lhs, self)) </span><span class="s3">return </span><span class="s1">self;</span>
        <span class="s3">return </span><span class="s1">make_node(AST_UnaryPrefix, self, {</span>
            <span class="s1">operator: </span><span class="s2">&quot;void&quot;</span><span class="s1">,</span>
            <span class="s1">expression: make_node(AST_Number, self, {</span>
                <span class="s1">value: </span><span class="s4">0</span>
            <span class="s1">})</span>
        <span class="s1">});</span>
    <span class="s1">});</span>

    <span class="s1">OPT(AST_Infinity, </span><span class="s3">function</span><span class="s1">(self, compressor){</span>
        <span class="s3">var </span><span class="s1">lhs = is_lhs(compressor.self(), compressor.parent());</span>
        <span class="s3">if </span><span class="s1">(lhs &amp;&amp; is_atomic(lhs, self)) </span><span class="s3">return </span><span class="s1">self;</span>
        <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;keep_infinity&quot;</span><span class="s1">)</span>
            <span class="s1">&amp;&amp; !(lhs &amp;&amp; !is_atomic(lhs, self))</span>
            <span class="s1">&amp;&amp; !find_variable(compressor, </span><span class="s2">&quot;Infinity&quot;</span><span class="s1">))</span>
            <span class="s3">return </span><span class="s1">self;</span>
        <span class="s3">return </span><span class="s1">make_node(AST_Binary, self, {</span>
            <span class="s1">operator: </span><span class="s2">&quot;/&quot;</span><span class="s1">,</span>
            <span class="s1">left: make_node(AST_Number, self, {</span>
                <span class="s1">value: </span><span class="s4">1</span>
            <span class="s1">}),</span>
            <span class="s1">right: make_node(AST_Number, self, {</span>
                <span class="s1">value: </span><span class="s4">0</span>
            <span class="s1">})</span>
        <span class="s1">});</span>
    <span class="s1">});</span>

    <span class="s1">OPT(AST_NaN, </span><span class="s3">function</span><span class="s1">(self, compressor){</span>
        <span class="s3">var </span><span class="s1">lhs = is_lhs(compressor.self(), compressor.parent());</span>
        <span class="s3">if </span><span class="s1">(lhs &amp;&amp; !is_atomic(lhs, self)</span>
            <span class="s1">|| find_variable(compressor, </span><span class="s2">&quot;NaN&quot;</span><span class="s1">)) {</span>
            <span class="s3">return </span><span class="s1">make_node(AST_Binary, self, {</span>
                <span class="s1">operator: </span><span class="s2">&quot;/&quot;</span><span class="s1">,</span>
                <span class="s1">left: make_node(AST_Number, self, {</span>
                    <span class="s1">value: </span><span class="s4">0</span>
                <span class="s1">}),</span>
                <span class="s1">right: make_node(AST_Number, self, {</span>
                    <span class="s1">value: </span><span class="s4">0</span>
                <span class="s1">})</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">self;</span>
    <span class="s1">});</span>

    <span class="s3">function </span><span class="s1">is_reachable(self, defs) {</span>
        <span class="s3">var </span><span class="s1">reachable = </span><span class="s3">false</span><span class="s1">;</span>
        <span class="s3">var </span><span class="s1">find_ref = </span><span class="s3">new </span><span class="s1">TreeWalker(</span><span class="s3">function</span><span class="s1">(node) {</span>
            <span class="s3">if </span><span class="s1">(reachable) </span><span class="s3">return true</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef &amp;&amp; member(node.definition(), defs)) {</span>
                <span class="s3">return </span><span class="s1">reachable = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
        <span class="s3">var </span><span class="s1">scan_scope = </span><span class="s3">new </span><span class="s1">TreeWalker(</span><span class="s3">function</span><span class="s1">(node) {</span>
            <span class="s3">if </span><span class="s1">(reachable) </span><span class="s3">return true</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Scope &amp;&amp; node !== self) {</span>
                <span class="s3">var </span><span class="s1">parent = scan_scope.parent();</span>
                <span class="s3">if </span><span class="s1">(parent </span><span class="s3">instanceof </span><span class="s1">AST_Call &amp;&amp; parent.expression === node) </span><span class="s3">return</span><span class="s1">;</span>
                <span class="s1">node.walk(find_ref);</span>
                <span class="s3">return true</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
        <span class="s1">self.walk(scan_scope);</span>
        <span class="s3">return </span><span class="s1">reachable;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">ASSIGN_OPS = [ </span><span class="s2">'+'</span><span class="s1">, </span><span class="s2">'-'</span><span class="s1">, </span><span class="s2">'/'</span><span class="s1">, </span><span class="s2">'*'</span><span class="s1">, </span><span class="s2">'%'</span><span class="s1">, </span><span class="s2">'&gt;&gt;'</span><span class="s1">, </span><span class="s2">'&lt;&lt;'</span><span class="s1">, </span><span class="s2">'&gt;&gt;&gt;'</span><span class="s1">, </span><span class="s2">'|'</span><span class="s1">, </span><span class="s2">'^'</span><span class="s1">, </span><span class="s2">'&amp;' </span><span class="s1">];</span>
    <span class="s3">var </span><span class="s1">ASSIGN_OPS_COMMUTATIVE = [ </span><span class="s2">'*'</span><span class="s1">, </span><span class="s2">'|'</span><span class="s1">, </span><span class="s2">'^'</span><span class="s1">, </span><span class="s2">'&amp;' </span><span class="s1">];</span>
    <span class="s1">OPT(AST_Assign, </span><span class="s3">function</span><span class="s1">(self, compressor){</span>
        <span class="s3">var </span><span class="s1">def;</span>
        <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;dead_code&quot;</span><span class="s1">)</span>
            <span class="s1">&amp;&amp; self.left </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef</span>
            <span class="s1">&amp;&amp; (def = self.left.definition()).scope === compressor.find_parent(AST_Lambda)) {</span>
            <span class="s3">var </span><span class="s1">level = </span><span class="s4">0</span><span class="s1">, node, parent = self;</span>
            <span class="s3">do </span><span class="s1">{</span>
                <span class="s1">node = parent;</span>
                <span class="s1">parent = compressor.parent(level++);</span>
                <span class="s3">if </span><span class="s1">(parent </span><span class="s3">instanceof </span><span class="s1">AST_Exit) {</span>
                    <span class="s3">if </span><span class="s1">(in_try(level, parent </span><span class="s3">instanceof </span><span class="s1">AST_Throw)) </span><span class="s3">break</span><span class="s1">;</span>
                    <span class="s3">if </span><span class="s1">(is_reachable(def.scope, [ def ])) </span><span class="s3">break</span><span class="s1">;</span>
                    <span class="s3">if </span><span class="s1">(self.operator == </span><span class="s2">&quot;=&quot;</span><span class="s1">) </span><span class="s3">return </span><span class="s1">self.right;</span>
                    <span class="s3">return </span><span class="s1">make_node(AST_Binary, self, {</span>
                        <span class="s1">operator: self.operator.slice(</span><span class="s4">0</span><span class="s1">, -</span><span class="s4">1</span><span class="s1">),</span>
                        <span class="s1">left: self.left,</span>
                        <span class="s1">right: self.right</span>
                    <span class="s1">}).optimize(compressor);</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s3">while </span><span class="s1">(parent </span><span class="s3">instanceof </span><span class="s1">AST_Binary &amp;&amp; parent.right === node</span>
                <span class="s1">|| parent </span><span class="s3">instanceof </span><span class="s1">AST_Sequence &amp;&amp; parent.tail_node() === node);</span>
        <span class="s1">}</span>
        <span class="s1">self = self.lift_sequences(compressor);</span>
        <span class="s3">if </span><span class="s1">(self.operator == </span><span class="s2">&quot;=&quot; </span><span class="s1">&amp;&amp; self.left </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef &amp;&amp; self.right </span><span class="s3">instanceof </span><span class="s1">AST_Binary) {</span>
            <span class="s0">// x = expr1 OP expr2</span>
            <span class="s3">if </span><span class="s1">(self.right.left </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef</span>
                <span class="s1">&amp;&amp; self.right.left.name == self.left.name</span>
                <span class="s1">&amp;&amp; member(self.right.operator, ASSIGN_OPS)) {</span>
                <span class="s0">// x = x - 2  ---&gt;  x -= 2</span>
                <span class="s1">self.operator = self.right.operator + </span><span class="s2">&quot;=&quot;</span><span class="s1">;</span>
                <span class="s1">self.right = self.right.right;</span>
            <span class="s1">}</span>
            <span class="s3">else if </span><span class="s1">(self.right.right </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef</span>
                <span class="s1">&amp;&amp; self.right.right.name == self.left.name</span>
                <span class="s1">&amp;&amp; member(self.right.operator, ASSIGN_OPS_COMMUTATIVE)</span>
                <span class="s1">&amp;&amp; !self.right.left.has_side_effects(compressor)) {</span>
                <span class="s0">// x = 2 &amp; x  ---&gt;  x &amp;= 2</span>
                <span class="s1">self.operator = self.right.operator + </span><span class="s2">&quot;=&quot;</span><span class="s1">;</span>
                <span class="s1">self.right = self.right.left;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">self;</span>

        <span class="s3">function </span><span class="s1">in_try(level, no_catch) {</span>
            <span class="s3">var </span><span class="s1">scope = self.left.definition().scope;</span>
            <span class="s3">var </span><span class="s1">parent;</span>
            <span class="s3">while </span><span class="s1">((parent = compressor.parent(level++)) !== scope) {</span>
                <span class="s3">if </span><span class="s1">(parent </span><span class="s3">instanceof </span><span class="s1">AST_Try) {</span>
                    <span class="s3">if </span><span class="s1">(parent.bfinally) </span><span class="s3">return true</span><span class="s1">;</span>
                    <span class="s3">if </span><span class="s1">(no_catch &amp;&amp; parent.bcatch) </span><span class="s3">return true</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">});</span>

    <span class="s1">OPT(AST_DefaultAssign, </span><span class="s3">function</span><span class="s1">(self, compressor){</span>
        <span class="s3">if </span><span class="s1">(!compressor.option(</span><span class="s2">&quot;evaluate&quot;</span><span class="s1">)) {</span>
            <span class="s3">return </span><span class="s1">self;</span>
        <span class="s1">}</span>
        <span class="s3">var </span><span class="s1">evaluateRight = self.right.evaluate(compressor);</span>

        <span class="s0">// `[x = undefined] = foo` ---&gt; `[x] = foo`</span>
        <span class="s3">if </span><span class="s1">(evaluateRight === undefined) {</span>
            <span class="s1">self = self.left;</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(evaluateRight !== self.right) {</span>
            <span class="s1">evaluateRight = make_node_from_constant(evaluateRight, self.right);</span>
            <span class="s1">self.right = best_of_expression(evaluateRight, self.right);</span>
        <span class="s1">}</span>

        <span class="s3">return </span><span class="s1">self;</span>
    <span class="s1">});</span>

    <span class="s1">OPT(AST_Conditional, </span><span class="s3">function</span><span class="s1">(self, compressor){</span>
        <span class="s3">if </span><span class="s1">(!compressor.option(</span><span class="s2">&quot;conditionals&quot;</span><span class="s1">)) </span><span class="s3">return </span><span class="s1">self;</span>
        <span class="s0">// This looks like lift_sequences(), should probably be under &quot;sequences&quot;</span>
        <span class="s3">if </span><span class="s1">(self.condition </span><span class="s3">instanceof </span><span class="s1">AST_Sequence) {</span>
            <span class="s3">var </span><span class="s1">expressions = self.condition.expressions.slice();</span>
            <span class="s1">self.condition = expressions.pop();</span>
            <span class="s1">expressions.push(self);</span>
            <span class="s3">return </span><span class="s1">make_sequence(self, expressions);</span>
        <span class="s1">}</span>
        <span class="s3">var </span><span class="s1">cond = self.condition.evaluate(compressor);</span>
        <span class="s3">if </span><span class="s1">(cond !== self.condition) {</span>
            <span class="s3">if </span><span class="s1">(cond) {</span>
                <span class="s1">compressor.warn(</span><span class="s2">&quot;Condition always true [{file}:{line},{col}]&quot;</span><span class="s1">, self.start);</span>
                <span class="s3">return </span><span class="s1">maintain_this_binding(compressor.parent(), compressor.self(), self.consequent);</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s1">compressor.warn(</span><span class="s2">&quot;Condition always false [{file}:{line},{col}]&quot;</span><span class="s1">, self.start);</span>
                <span class="s3">return </span><span class="s1">maintain_this_binding(compressor.parent(), compressor.self(), self.alternative);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">var </span><span class="s1">negated = cond.negate(compressor, first_in_statement(compressor));</span>
        <span class="s3">if </span><span class="s1">(best_of(compressor, cond, negated) === negated) {</span>
            <span class="s1">self = make_node(AST_Conditional, self, {</span>
                <span class="s1">condition: negated,</span>
                <span class="s1">consequent: self.alternative,</span>
                <span class="s1">alternative: self.consequent</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s3">var </span><span class="s1">condition = self.condition;</span>
        <span class="s3">var </span><span class="s1">consequent = self.consequent;</span>
        <span class="s3">var </span><span class="s1">alternative = self.alternative;</span>
        <span class="s0">// x?x:y --&gt; x||y</span>
        <span class="s3">if </span><span class="s1">(condition </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef</span>
            <span class="s1">&amp;&amp; consequent </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef</span>
            <span class="s1">&amp;&amp; condition.definition() === consequent.definition()) {</span>
            <span class="s3">return </span><span class="s1">make_node(AST_Binary, self, {</span>
                <span class="s1">operator: </span><span class="s2">&quot;||&quot;</span><span class="s1">,</span>
                <span class="s1">left: condition,</span>
                <span class="s1">right: alternative</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s0">// if (foo) exp = something; else exp = something_else;</span>
        <span class="s0">//                   |</span>
        <span class="s0">//                   v</span>
        <span class="s0">// exp = foo ? something : something_else;</span>
        <span class="s3">if </span><span class="s1">(consequent </span><span class="s3">instanceof </span><span class="s1">AST_Assign</span>
            <span class="s1">&amp;&amp; alternative </span><span class="s3">instanceof </span><span class="s1">AST_Assign</span>
            <span class="s1">&amp;&amp; consequent.operator == alternative.operator</span>
            <span class="s1">&amp;&amp; consequent.left.equivalent_to(alternative.left)</span>
            <span class="s1">&amp;&amp; (!self.condition.has_side_effects(compressor)</span>
                <span class="s1">|| consequent.operator == </span><span class="s2">&quot;=&quot;</span>
                    <span class="s1">&amp;&amp; !consequent.left.has_side_effects(compressor))) {</span>
            <span class="s3">return </span><span class="s1">make_node(AST_Assign, self, {</span>
                <span class="s1">operator: consequent.operator,</span>
                <span class="s1">left: consequent.left,</span>
                <span class="s1">right: make_node(AST_Conditional, self, {</span>
                    <span class="s1">condition: self.condition,</span>
                    <span class="s1">consequent: consequent.right,</span>
                    <span class="s1">alternative: alternative.right</span>
                <span class="s1">})</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s0">// x ? y(a) : y(b) --&gt; y(x ? a : b)</span>
        <span class="s3">var </span><span class="s1">arg_index;</span>
        <span class="s3">if </span><span class="s1">(consequent </span><span class="s3">instanceof </span><span class="s1">AST_Call</span>
            <span class="s1">&amp;&amp; alternative.TYPE === consequent.TYPE</span>
            <span class="s1">&amp;&amp; consequent.args.length &gt; </span><span class="s4">0</span>
            <span class="s1">&amp;&amp; consequent.args.length == alternative.args.length</span>
            <span class="s1">&amp;&amp; consequent.expression.equivalent_to(alternative.expression)</span>
            <span class="s1">&amp;&amp; !self.condition.has_side_effects(compressor)</span>
            <span class="s1">&amp;&amp; !consequent.expression.has_side_effects(compressor)</span>
            <span class="s1">&amp;&amp; </span><span class="s3">typeof </span><span class="s1">(arg_index = single_arg_diff()) == </span><span class="s2">&quot;number&quot;</span><span class="s1">) {</span>
            <span class="s3">var </span><span class="s1">node = consequent.clone();</span>
            <span class="s1">node.args[arg_index] = make_node(AST_Conditional, self, {</span>
                <span class="s1">condition: self.condition,</span>
                <span class="s1">consequent: consequent.args[arg_index],</span>
                <span class="s1">alternative: alternative.args[arg_index]</span>
            <span class="s1">});</span>
            <span class="s3">return </span><span class="s1">node;</span>
        <span class="s1">}</span>
        <span class="s0">// x?y?z:a:a --&gt; x&amp;&amp;y?z:a</span>
        <span class="s3">if </span><span class="s1">(consequent </span><span class="s3">instanceof </span><span class="s1">AST_Conditional</span>
            <span class="s1">&amp;&amp; consequent.alternative.equivalent_to(alternative)) {</span>
            <span class="s3">return </span><span class="s1">make_node(AST_Conditional, self, {</span>
                <span class="s1">condition: make_node(AST_Binary, self, {</span>
                    <span class="s1">left: self.condition,</span>
                    <span class="s1">operator: </span><span class="s2">&quot;&amp;&amp;&quot;</span><span class="s1">,</span>
                    <span class="s1">right: consequent.condition</span>
                <span class="s1">}),</span>
                <span class="s1">consequent: consequent.consequent,</span>
                <span class="s1">alternative: alternative</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s0">// x ? y : y --&gt; x, y</span>
        <span class="s3">if </span><span class="s1">(consequent.equivalent_to(alternative)) {</span>
            <span class="s3">return </span><span class="s1">make_sequence(self, [</span>
                <span class="s1">self.condition,</span>
                <span class="s1">consequent</span>
            <span class="s1">]).optimize(compressor);</span>
        <span class="s1">}</span>
        <span class="s0">// x ? y || z : z --&gt; x &amp;&amp; y || z</span>
        <span class="s3">if </span><span class="s1">(consequent </span><span class="s3">instanceof </span><span class="s1">AST_Binary</span>
            <span class="s1">&amp;&amp; consequent.operator == </span><span class="s2">&quot;||&quot;</span>
            <span class="s1">&amp;&amp; consequent.right.equivalent_to(alternative)) {</span>
            <span class="s3">return </span><span class="s1">make_node(AST_Binary, self, {</span>
                <span class="s1">operator: </span><span class="s2">&quot;||&quot;</span><span class="s1">,</span>
                <span class="s1">left: make_node(AST_Binary, self, {</span>
                    <span class="s1">operator: </span><span class="s2">&quot;&amp;&amp;&quot;</span><span class="s1">,</span>
                    <span class="s1">left: self.condition,</span>
                    <span class="s1">right: consequent.left</span>
                <span class="s1">}),</span>
                <span class="s1">right: alternative</span>
            <span class="s1">}).optimize(compressor);</span>
        <span class="s1">}</span>
        <span class="s3">var </span><span class="s1">in_bool = compressor.in_boolean_context();</span>
        <span class="s3">if </span><span class="s1">(is_true(self.consequent)) {</span>
            <span class="s3">if </span><span class="s1">(is_false(self.alternative)) {</span>
                <span class="s0">// c ? true : false ---&gt; !!c</span>
                <span class="s3">return </span><span class="s1">booleanize(self.condition);</span>
            <span class="s1">}</span>
            <span class="s0">// c ? true : x ---&gt; !!c || x</span>
            <span class="s3">return </span><span class="s1">make_node(AST_Binary, self, {</span>
                <span class="s1">operator: </span><span class="s2">&quot;||&quot;</span><span class="s1">,</span>
                <span class="s1">left: booleanize(self.condition),</span>
                <span class="s1">right: self.alternative</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(is_false(self.consequent)) {</span>
            <span class="s3">if </span><span class="s1">(is_true(self.alternative)) {</span>
                <span class="s0">// c ? false : true ---&gt; !c</span>
                <span class="s3">return </span><span class="s1">booleanize(self.condition.negate(compressor));</span>
            <span class="s1">}</span>
            <span class="s0">// c ? false : x ---&gt; !c &amp;&amp; x</span>
            <span class="s3">return </span><span class="s1">make_node(AST_Binary, self, {</span>
                <span class="s1">operator: </span><span class="s2">&quot;&amp;&amp;&quot;</span><span class="s1">,</span>
                <span class="s1">left: booleanize(self.condition.negate(compressor)),</span>
                <span class="s1">right: self.alternative</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(is_true(self.alternative)) {</span>
            <span class="s0">// c ? x : true ---&gt; !c || x</span>
            <span class="s3">return </span><span class="s1">make_node(AST_Binary, self, {</span>
                <span class="s1">operator: </span><span class="s2">&quot;||&quot;</span><span class="s1">,</span>
                <span class="s1">left: booleanize(self.condition.negate(compressor)),</span>
                <span class="s1">right: self.consequent</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(is_false(self.alternative)) {</span>
            <span class="s0">// c ? x : false ---&gt; !!c &amp;&amp; x</span>
            <span class="s3">return </span><span class="s1">make_node(AST_Binary, self, {</span>
                <span class="s1">operator: </span><span class="s2">&quot;&amp;&amp;&quot;</span><span class="s1">,</span>
                <span class="s1">left: booleanize(self.condition),</span>
                <span class="s1">right: self.consequent</span>
            <span class="s1">});</span>
        <span class="s1">}</span>

        <span class="s3">return </span><span class="s1">self;</span>

        <span class="s3">function </span><span class="s1">booleanize(node) {</span>
            <span class="s3">if </span><span class="s1">(node.is_boolean()) </span><span class="s3">return </span><span class="s1">node;</span>
            <span class="s0">// !!expression</span>
            <span class="s3">return </span><span class="s1">make_node(AST_UnaryPrefix, node, {</span>
                <span class="s1">operator: </span><span class="s2">&quot;!&quot;</span><span class="s1">,</span>
                <span class="s1">expression: node.negate(compressor)</span>
            <span class="s1">});</span>
        <span class="s1">}</span>

        <span class="s0">// AST_True or !0</span>
        <span class="s3">function </span><span class="s1">is_true(node) {</span>
            <span class="s3">return </span><span class="s1">node </span><span class="s3">instanceof </span><span class="s1">AST_True</span>
                <span class="s1">|| in_bool</span>
                    <span class="s1">&amp;&amp; node </span><span class="s3">instanceof </span><span class="s1">AST_Constant</span>
                    <span class="s1">&amp;&amp; node.getValue()</span>
                <span class="s1">|| (node </span><span class="s3">instanceof </span><span class="s1">AST_UnaryPrefix</span>
                    <span class="s1">&amp;&amp; node.operator == </span><span class="s2">&quot;!&quot;</span>
                    <span class="s1">&amp;&amp; node.expression </span><span class="s3">instanceof </span><span class="s1">AST_Constant</span>
                    <span class="s1">&amp;&amp; !node.expression.getValue());</span>
        <span class="s1">}</span>
        <span class="s0">// AST_False or !1</span>
        <span class="s3">function </span><span class="s1">is_false(node) {</span>
            <span class="s3">return </span><span class="s1">node </span><span class="s3">instanceof </span><span class="s1">AST_False</span>
                <span class="s1">|| in_bool</span>
                    <span class="s1">&amp;&amp; node </span><span class="s3">instanceof </span><span class="s1">AST_Constant</span>
                    <span class="s1">&amp;&amp; !node.getValue()</span>
                <span class="s1">|| (node </span><span class="s3">instanceof </span><span class="s1">AST_UnaryPrefix</span>
                    <span class="s1">&amp;&amp; node.operator == </span><span class="s2">&quot;!&quot;</span>
                    <span class="s1">&amp;&amp; node.expression </span><span class="s3">instanceof </span><span class="s1">AST_Constant</span>
                    <span class="s1">&amp;&amp; node.expression.getValue());</span>
        <span class="s1">}</span>

        <span class="s3">function </span><span class="s1">single_arg_diff() {</span>
            <span class="s3">var </span><span class="s1">a = consequent.args;</span>
            <span class="s3">var </span><span class="s1">b = alternative.args;</span>
            <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">, len = a.length; i &lt; len; i++) {</span>
                <span class="s3">if </span><span class="s1">(a[i] </span><span class="s3">instanceof </span><span class="s1">AST_Expansion) </span><span class="s3">return</span><span class="s1">;</span>
                <span class="s3">if </span><span class="s1">(!a[i].equivalent_to(b[i])) {</span>
                    <span class="s3">if </span><span class="s1">(b[i] </span><span class="s3">instanceof </span><span class="s1">AST_Expansion) </span><span class="s3">return</span><span class="s1">;</span>
                    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">j = i + </span><span class="s4">1</span><span class="s1">; j &lt; len; j++) {</span>
                        <span class="s3">if </span><span class="s1">(a[j] </span><span class="s3">instanceof </span><span class="s1">AST_Expansion) </span><span class="s3">return</span><span class="s1">;</span>
                        <span class="s3">if </span><span class="s1">(!a[j].equivalent_to(b[j])) </span><span class="s3">return</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s3">return </span><span class="s1">i;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">});</span>

    <span class="s1">OPT(AST_Boolean, </span><span class="s3">function</span><span class="s1">(self, compressor){</span>
        <span class="s3">if </span><span class="s1">(compressor.in_boolean_context()) </span><span class="s3">return </span><span class="s1">make_node(AST_Number, self, {</span>
            <span class="s1">value: +self.value</span>
        <span class="s1">});</span>
        <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;booleans&quot;</span><span class="s1">)) {</span>
            <span class="s3">var </span><span class="s1">p = compressor.parent();</span>
            <span class="s3">if </span><span class="s1">(p </span><span class="s3">instanceof </span><span class="s1">AST_Binary &amp;&amp; (p.operator == </span><span class="s2">&quot;==&quot;</span>
                                            <span class="s1">|| p.operator == </span><span class="s2">&quot;!=&quot;</span><span class="s1">)) {</span>
                <span class="s1">compressor.warn(</span><span class="s2">&quot;Non-strict equality against boolean: {operator} {value} [{file}:{line},{col}]&quot;</span><span class="s1">, {</span>
                    <span class="s1">operator : p.operator,</span>
                    <span class="s1">value    : self.value,</span>
                    <span class="s1">file     : p.start.file,</span>
                    <span class="s1">line     : p.start.line,</span>
                    <span class="s1">col      : p.start.col,</span>
                <span class="s1">});</span>
                <span class="s3">return </span><span class="s1">make_node(AST_Number, self, {</span>
                    <span class="s1">value: +self.value</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s3">return </span><span class="s1">make_node(AST_UnaryPrefix, self, {</span>
                <span class="s1">operator: </span><span class="s2">&quot;!&quot;</span><span class="s1">,</span>
                <span class="s1">expression: make_node(AST_Number, self, {</span>
                    <span class="s1">value: </span><span class="s4">1 </span><span class="s1">- self.value</span>
                <span class="s1">})</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">self;</span>
    <span class="s1">});</span>

    <span class="s1">OPT(AST_Sub, </span><span class="s3">function</span><span class="s1">(self, compressor){</span>
        <span class="s3">var </span><span class="s1">expr = self.expression;</span>
        <span class="s3">var </span><span class="s1">prop = self.property;</span>
        <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;properties&quot;</span><span class="s1">)) {</span>
            <span class="s3">var </span><span class="s1">key = prop.evaluate(compressor);</span>
            <span class="s3">if </span><span class="s1">(key !== prop) {</span>
                <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">key == </span><span class="s2">&quot;string&quot;</span><span class="s1">) {</span>
                    <span class="s3">if </span><span class="s1">(key == </span><span class="s2">&quot;undefined&quot;</span><span class="s1">) {</span>
                        <span class="s1">key = undefined;</span>
                    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                        <span class="s3">var </span><span class="s1">value = parseFloat(key);</span>
                        <span class="s3">if </span><span class="s1">(value.toString() == key) {</span>
                            <span class="s1">key = value;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s1">prop = self.property = best_of_expression(prop, make_node_from_constant(key, prop).transform(compressor));</span>
                <span class="s3">var </span><span class="s1">property = </span><span class="s2">&quot;&quot; </span><span class="s1">+ key;</span>
                <span class="s3">if </span><span class="s1">(is_identifier_string(property)</span>
                    <span class="s1">&amp;&amp; property.length &lt;= prop.print_to_string().length + </span><span class="s4">1</span><span class="s1">) {</span>
                    <span class="s3">return </span><span class="s1">make_node(AST_Dot, self, {</span>
                        <span class="s1">expression: expr,</span>
                        <span class="s1">property: property</span>
                    <span class="s1">}).optimize(compressor);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(is_lhs(self, compressor.parent())) </span><span class="s3">return </span><span class="s1">self;</span>
        <span class="s3">if </span><span class="s1">(key !== prop) {</span>
            <span class="s3">var </span><span class="s1">sub = self.flatten_object(property, compressor);</span>
            <span class="s3">if </span><span class="s1">(sub) {</span>
                <span class="s1">expr = self.expression = sub.expression;</span>
                <span class="s1">prop = self.property = sub.property;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;properties&quot;</span><span class="s1">) &amp;&amp; compressor.option(</span><span class="s2">&quot;side_effects&quot;</span><span class="s1">)</span>
            <span class="s1">&amp;&amp; prop </span><span class="s3">instanceof </span><span class="s1">AST_Number &amp;&amp; expr </span><span class="s3">instanceof </span><span class="s1">AST_Array) {</span>
            <span class="s3">var </span><span class="s1">index = prop.getValue();</span>
            <span class="s3">var </span><span class="s1">elements = expr.elements;</span>
            <span class="s1">FLATTEN: </span><span class="s3">if </span><span class="s1">(index </span><span class="s3">in </span><span class="s1">elements) {</span>
                <span class="s3">var </span><span class="s1">flatten = </span><span class="s3">true</span><span class="s1">;</span>
                <span class="s3">var </span><span class="s1">values = [];</span>
                <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = elements.length; --i &gt; index;) {</span>
                    <span class="s3">var </span><span class="s1">value = elements[i].drop_side_effect_free(compressor);</span>
                    <span class="s3">if </span><span class="s1">(value) {</span>
                        <span class="s1">values.unshift(value);</span>
                        <span class="s3">if </span><span class="s1">(flatten &amp;&amp; value.has_side_effects(compressor)) flatten = </span><span class="s3">false</span><span class="s1">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s3">var </span><span class="s1">retValue = elements[index];</span>
                <span class="s3">if </span><span class="s1">(retValue </span><span class="s3">instanceof </span><span class="s1">AST_Expansion) </span><span class="s3">break </span><span class="s1">FLATTEN;</span>
                <span class="s1">retValue = retValue </span><span class="s3">instanceof </span><span class="s1">AST_Hole ? make_node(AST_Undefined, retValue) : retValue;</span>
                <span class="s3">if </span><span class="s1">(!flatten) values.unshift(retValue);</span>
                <span class="s3">while </span><span class="s1">(--i &gt;= </span><span class="s4">0</span><span class="s1">) {</span>
                    <span class="s3">var </span><span class="s1">value = elements[i];</span>
                    <span class="s3">if </span><span class="s1">(value </span><span class="s3">instanceof </span><span class="s1">AST_Expansion) </span><span class="s3">break </span><span class="s1">FLATTEN;</span>
                    <span class="s1">value = value.drop_side_effect_free(compressor);</span>
                    <span class="s3">if </span><span class="s1">(value) values.unshift(value);</span>
                    <span class="s3">else </span><span class="s1">index--;</span>
                <span class="s1">}</span>
                <span class="s3">if </span><span class="s1">(flatten) {</span>
                    <span class="s1">values.push(retValue);</span>
                    <span class="s3">return </span><span class="s1">make_sequence(self, values).optimize(compressor);</span>
                <span class="s1">} </span><span class="s3">else return </span><span class="s1">make_node(AST_Sub, self, {</span>
                    <span class="s1">expression: make_node(AST_Array, expr, {</span>
                        <span class="s1">elements: values</span>
                    <span class="s1">}),</span>
                    <span class="s1">property: make_node(AST_Number, prop, {</span>
                        <span class="s1">value: index</span>
                    <span class="s1">})</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">var </span><span class="s1">ev = self.evaluate(compressor);</span>
        <span class="s3">if </span><span class="s1">(ev !== self) {</span>
            <span class="s1">ev = make_node_from_constant(ev, self).optimize(compressor);</span>
            <span class="s3">return </span><span class="s1">best_of(compressor, ev, self);</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">self;</span>
    <span class="s1">});</span>

    <span class="s1">AST_Lambda.DEFMETHOD(</span><span class="s2">&quot;contains_this&quot;</span><span class="s1">, </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">var </span><span class="s1">result;</span>
        <span class="s3">var </span><span class="s1">self = </span><span class="s3">this</span><span class="s1">;</span>
        <span class="s1">self.walk(</span><span class="s3">new </span><span class="s1">TreeWalker(</span><span class="s3">function</span><span class="s1">(node) {</span>
            <span class="s3">if </span><span class="s1">(result) </span><span class="s3">return true</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_This) </span><span class="s3">return </span><span class="s1">result = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(node !== self &amp;&amp; node </span><span class="s3">instanceof </span><span class="s1">AST_Scope &amp;&amp; !(node </span><span class="s3">instanceof </span><span class="s1">AST_Arrow)) </span><span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">}));</span>
        <span class="s3">return </span><span class="s1">result;</span>
    <span class="s1">});</span>

    <span class="s1">AST_PropAccess.DEFMETHOD(</span><span class="s2">&quot;flatten_object&quot;</span><span class="s1">, </span><span class="s3">function</span><span class="s1">(key, compressor) {</span>
        <span class="s3">if </span><span class="s1">(!compressor.option(</span><span class="s2">&quot;properties&quot;</span><span class="s1">)) </span><span class="s3">return</span><span class="s1">;</span>
        <span class="s3">var </span><span class="s1">arrows = compressor.option(</span><span class="s2">&quot;unsafe_arrows&quot;</span><span class="s1">) &amp;&amp; compressor.option(</span><span class="s2">&quot;ecma&quot;</span><span class="s1">) &gt;= </span><span class="s4">6</span><span class="s1">;</span>
        <span class="s3">var </span><span class="s1">expr = </span><span class="s3">this</span><span class="s1">.expression;</span>
        <span class="s3">if </span><span class="s1">(expr </span><span class="s3">instanceof </span><span class="s1">AST_Object) {</span>
            <span class="s3">var </span><span class="s1">props = expr.properties;</span>
            <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = props.length; --i &gt;= </span><span class="s4">0</span><span class="s1">;) {</span>
                <span class="s3">var </span><span class="s1">prop = props[i];</span>
                <span class="s3">if </span><span class="s1">(</span><span class="s2">&quot;&quot; </span><span class="s1">+ (prop </span><span class="s3">instanceof </span><span class="s1">AST_ConciseMethod ? prop.key.name : prop.key) == key) {</span>
                    <span class="s3">if </span><span class="s1">(!all(props, </span><span class="s3">function</span><span class="s1">(prop) {</span>
                        <span class="s3">return </span><span class="s1">prop </span><span class="s3">instanceof </span><span class="s1">AST_ObjectKeyVal</span>
                            <span class="s1">|| arrows &amp;&amp; prop </span><span class="s3">instanceof </span><span class="s1">AST_ConciseMethod &amp;&amp; !prop.is_generator;</span>
                    <span class="s1">})) </span><span class="s3">break</span><span class="s1">;</span>
                    <span class="s3">var </span><span class="s1">value = prop.value;</span>
                    <span class="s3">if </span><span class="s1">((value </span><span class="s3">instanceof </span><span class="s1">AST_Accessor || value </span><span class="s3">instanceof </span><span class="s1">AST_Function)</span>
                        <span class="s1">&amp;&amp; !(compressor.parent() </span><span class="s3">instanceof </span><span class="s1">AST_New)</span>
                        <span class="s1">&amp;&amp; value.contains_this()) </span><span class="s3">break</span><span class="s1">;</span>
                    <span class="s3">return </span><span class="s1">make_node(AST_Sub, </span><span class="s3">this</span><span class="s1">, {</span>
                        <span class="s1">expression: make_node(AST_Array, expr, {</span>
                            <span class="s1">elements: props.map(</span><span class="s3">function</span><span class="s1">(prop) {</span>
                                <span class="s3">var </span><span class="s1">v = prop.value;</span>
                                <span class="s3">if </span><span class="s1">(v </span><span class="s3">instanceof </span><span class="s1">AST_Accessor) v = make_node(AST_Function, v, v);</span>
                                <span class="s3">var </span><span class="s1">k = prop.key;</span>
                                <span class="s3">if </span><span class="s1">(k </span><span class="s3">instanceof </span><span class="s1">AST_Node &amp;&amp; !(k </span><span class="s3">instanceof </span><span class="s1">AST_SymbolMethod)) {</span>
                                    <span class="s3">return </span><span class="s1">make_sequence(prop, [ k, v ]);</span>
                                <span class="s1">}</span>
                                <span class="s3">return </span><span class="s1">v;</span>
                            <span class="s1">})</span>
                        <span class="s1">}),</span>
                        <span class="s1">property: make_node(AST_Number, </span><span class="s3">this</span><span class="s1">, {</span>
                            <span class="s1">value: i</span>
                        <span class="s1">})</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">});</span>

    <span class="s1">OPT(AST_Dot, </span><span class="s3">function</span><span class="s1">(self, compressor){</span>
        <span class="s3">if </span><span class="s1">(self.property == </span><span class="s2">&quot;arguments&quot; </span><span class="s1">|| self.property == </span><span class="s2">&quot;caller&quot;</span><span class="s1">) {</span>
            <span class="s1">compressor.warn(</span><span class="s2">&quot;Function.protoype.{prop} not supported [{file}:{line},{col}]&quot;</span><span class="s1">, {</span>
                <span class="s1">prop: self.property,</span>
                <span class="s1">file: self.start.file,</span>
                <span class="s1">line: self.start.line,</span>
                <span class="s1">col: self.start.col</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s3">var </span><span class="s1">def = self.resolve_defines(compressor);</span>
        <span class="s3">if </span><span class="s1">(def) {</span>
            <span class="s3">return </span><span class="s1">def.optimize(compressor);</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(is_lhs(self, compressor.parent())) </span><span class="s3">return </span><span class="s1">self;</span>
        <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;unsafe_proto&quot;</span><span class="s1">)</span>
            <span class="s1">&amp;&amp; self.expression </span><span class="s3">instanceof </span><span class="s1">AST_Dot</span>
            <span class="s1">&amp;&amp; self.expression.property == </span><span class="s2">&quot;prototype&quot;</span><span class="s1">) {</span>
            <span class="s3">var </span><span class="s1">exp = self.expression.expression;</span>
            <span class="s3">if </span><span class="s1">(is_undeclared_ref(exp)) </span><span class="s3">switch </span><span class="s1">(exp.name) {</span>
              <span class="s3">case </span><span class="s2">&quot;Array&quot;</span><span class="s1">:</span>
                <span class="s1">self.expression = make_node(AST_Array, self.expression, {</span>
                    <span class="s1">elements: []</span>
                <span class="s1">});</span>
                <span class="s3">break</span><span class="s1">;</span>
              <span class="s3">case </span><span class="s2">&quot;Function&quot;</span><span class="s1">:</span>
                <span class="s1">self.expression = make_node(AST_Function, self.expression, {</span>
                    <span class="s1">argnames: [],</span>
                    <span class="s1">body: []</span>
                <span class="s1">});</span>
                <span class="s3">break</span><span class="s1">;</span>
              <span class="s3">case </span><span class="s2">&quot;Number&quot;</span><span class="s1">:</span>
                <span class="s1">self.expression = make_node(AST_Number, self.expression, {</span>
                    <span class="s1">value: </span><span class="s4">0</span>
                <span class="s1">});</span>
                <span class="s3">break</span><span class="s1">;</span>
              <span class="s3">case </span><span class="s2">&quot;Object&quot;</span><span class="s1">:</span>
                <span class="s1">self.expression = make_node(AST_Object, self.expression, {</span>
                    <span class="s1">properties: []</span>
                <span class="s1">});</span>
                <span class="s3">break</span><span class="s1">;</span>
              <span class="s3">case </span><span class="s2">&quot;RegExp&quot;</span><span class="s1">:</span>
                <span class="s1">self.expression = make_node(AST_RegExp, self.expression, {</span>
                    <span class="s1">value: /t/</span>
                <span class="s1">});</span>
                <span class="s3">break</span><span class="s1">;</span>
              <span class="s3">case </span><span class="s2">&quot;String&quot;</span><span class="s1">:</span>
                <span class="s1">self.expression = make_node(AST_String, self.expression, {</span>
                    <span class="s1">value: </span><span class="s2">&quot;&quot;</span>
                <span class="s1">});</span>
                <span class="s3">break</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">var </span><span class="s1">sub = self.flatten_object(self.property, compressor);</span>
        <span class="s3">if </span><span class="s1">(sub) </span><span class="s3">return </span><span class="s1">sub.optimize(compressor);</span>
        <span class="s3">var </span><span class="s1">ev = self.evaluate(compressor);</span>
        <span class="s3">if </span><span class="s1">(ev !== self) {</span>
            <span class="s1">ev = make_node_from_constant(ev, self).optimize(compressor);</span>
            <span class="s3">return </span><span class="s1">best_of(compressor, ev, self);</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">self;</span>
    <span class="s1">});</span>

    <span class="s3">function </span><span class="s1">literals_in_boolean_context(self, compressor) {</span>
        <span class="s3">if </span><span class="s1">(compressor.in_boolean_context()) {</span>
            <span class="s3">return </span><span class="s1">best_of(compressor, self, make_sequence(self, [</span>
                <span class="s1">self,</span>
                <span class="s1">make_node(AST_True, self)</span>
            <span class="s1">]).optimize(compressor));</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">self;</span>
    <span class="s1">};</span>
    <span class="s1">OPT(AST_Array, literals_in_boolean_context);</span>
    <span class="s1">OPT(AST_Object, literals_in_boolean_context);</span>
    <span class="s1">OPT(AST_RegExp, literals_in_boolean_context);</span>

    <span class="s1">OPT(AST_Return, </span><span class="s3">function</span><span class="s1">(self, compressor){</span>
        <span class="s3">if </span><span class="s1">(self.value &amp;&amp; is_undefined(self.value, compressor)) {</span>
            <span class="s1">self.value = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">self;</span>
    <span class="s1">});</span>

    <span class="s1">OPT(AST_Arrow, </span><span class="s3">function</span><span class="s1">(self, compressor){</span>
        <span class="s3">if </span><span class="s1">(!(self.body </span><span class="s3">instanceof </span><span class="s1">AST_Node)) tighten_body(self.body, compressor);</span>
        <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;arrows&quot;</span><span class="s1">)</span>
            <span class="s1">&amp;&amp; self.body.length == </span><span class="s4">1</span>
            <span class="s1">&amp;&amp; self.body[</span><span class="s4">0</span><span class="s1">] </span><span class="s3">instanceof </span><span class="s1">AST_Return) {</span>
            <span class="s3">var </span><span class="s1">value = self.body[</span><span class="s4">0</span><span class="s1">].value;</span>
            <span class="s1">self.body = value ? value : [];</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">self;</span>
    <span class="s1">});</span>

    <span class="s1">OPT(AST_Function, </span><span class="s3">function</span><span class="s1">(self, compressor){</span>
        <span class="s1">tighten_body(self.body, compressor);</span>
        <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;unsafe_arrows&quot;</span><span class="s1">)</span>
            <span class="s1">&amp;&amp; compressor.option(</span><span class="s2">&quot;ecma&quot;</span><span class="s1">) &gt;= </span><span class="s4">6</span>
            <span class="s1">&amp;&amp; !self.name</span>
            <span class="s1">&amp;&amp; !self.is_generator</span>
            <span class="s1">&amp;&amp; !self.uses_arguments</span>
            <span class="s1">&amp;&amp; !self.uses_eval) {</span>
            <span class="s3">var </span><span class="s1">has_special_symbol = </span><span class="s3">false</span><span class="s1">;</span>
            <span class="s1">self.walk(</span><span class="s3">new </span><span class="s1">TreeWalker(</span><span class="s3">function</span><span class="s1">(node) {</span>
                <span class="s3">if </span><span class="s1">(has_special_symbol) </span><span class="s3">return true</span><span class="s1">;</span>
                <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_This) {</span>
                    <span class="s1">has_special_symbol = </span><span class="s3">true</span><span class="s1">;</span>
                    <span class="s3">return true</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}));</span>
            <span class="s3">if </span><span class="s1">(!has_special_symbol) </span><span class="s3">return </span><span class="s1">make_node(AST_Arrow, self, self).optimize(compressor);</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">self;</span>
    <span class="s1">});</span>

    <span class="s1">OPT(AST_Class, </span><span class="s3">function</span><span class="s1">(self, compressor){</span>
        <span class="s0">// HACK to avoid compress failure.</span>
        <span class="s0">// AST_Class is not really an AST_Scope/AST_Block as it lacks a body.</span>
        <span class="s3">return </span><span class="s1">self;</span>
    <span class="s1">});</span>

    <span class="s1">OPT(AST_Yield, </span><span class="s3">function</span><span class="s1">(self, compressor){</span>
        <span class="s3">if </span><span class="s1">(self.expression &amp;&amp; !self.is_star &amp;&amp; is_undefined(self.expression, compressor)) {</span>
            <span class="s1">self.expression = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">self;</span>
    <span class="s1">});</span>

    <span class="s1">OPT(AST_VarDef, </span><span class="s3">function</span><span class="s1">(self, compressor){</span>
        <span class="s3">var </span><span class="s1">defines = compressor.option(</span><span class="s2">&quot;global_defs&quot;</span><span class="s1">);</span>
        <span class="s3">if </span><span class="s1">(defines &amp;&amp; HOP(defines, self.name.name)) {</span>
            <span class="s1">compressor.warn(</span><span class="s2">'global_defs ' </span><span class="s1">+ self.name.name + </span><span class="s2">' redefined [{file}:{line},{col}]'</span><span class="s1">, self.start);</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">self;</span>
    <span class="s1">});</span>

    <span class="s1">OPT(AST_TemplateString, </span><span class="s3">function</span><span class="s1">(self, compressor){</span>
        <span class="s3">if </span><span class="s1">(!compressor.option(</span><span class="s2">&quot;evaluate&quot;</span><span class="s1">)</span>
        <span class="s1">|| compressor.parent() </span><span class="s3">instanceof </span><span class="s1">AST_PrefixedTemplateString)</span>
            <span class="s3">return </span><span class="s1">self;</span>

        <span class="s3">var </span><span class="s1">segments = [];</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; self.segments.length; i++) {</span>
            <span class="s3">var </span><span class="s1">segment = self.segments[i];</span>
            <span class="s3">if </span><span class="s1">(segment </span><span class="s3">instanceof </span><span class="s1">AST_Node) {</span>
                <span class="s3">var </span><span class="s1">result = segment.evaluate(compressor);</span>
                <span class="s0">// Evaluate to constant value</span>
                <span class="s0">// Constant value shorter than ${segment}</span>
                <span class="s3">if </span><span class="s1">(result !== segment &amp;&amp; (result + </span><span class="s2">&quot;&quot;</span><span class="s1">).length &lt;= segment.print_to_string().length + </span><span class="s2">&quot;${}&quot;</span><span class="s1">.length) {</span>
                    <span class="s0">// There should always be a previous and next segment if segment is a node</span>
                    <span class="s1">segments[segments.length - </span><span class="s4">1</span><span class="s1">].value = segments[segments.length - </span><span class="s4">1</span><span class="s1">].value + result + self.segments[++i].value;</span>
                    <span class="s3">continue</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">segments.push(segment);</span>
        <span class="s1">}</span>
        <span class="s1">self.segments = segments;</span>

        <span class="s3">return </span><span class="s1">segments.length == </span><span class="s4">1 </span><span class="s1">? make_node(AST_String, self, segments[</span><span class="s4">0</span><span class="s1">]) : self;</span>
    <span class="s1">});</span>

    <span class="s1">OPT(AST_PrefixedTemplateString, </span><span class="s3">function</span><span class="s1">(self, compressor){</span>
        <span class="s3">return </span><span class="s1">self;</span>
    <span class="s1">});</span>

    <span class="s0">// [&quot;p&quot;]:1 ---&gt; p:1</span>
    <span class="s0">// [42]:1 ---&gt; 42:1</span>
    <span class="s3">function </span><span class="s1">lift_key(self, compressor) {</span>
        <span class="s3">if </span><span class="s1">(!compressor.option(</span><span class="s2">&quot;computed_props&quot;</span><span class="s1">)) </span><span class="s3">return </span><span class="s1">self;</span>
        <span class="s0">// save a comparison in the typical case</span>
        <span class="s3">if </span><span class="s1">(!(self.key </span><span class="s3">instanceof </span><span class="s1">AST_Constant)) </span><span class="s3">return </span><span class="s1">self;</span>
        <span class="s0">// whitelist acceptable props as not all AST_Constants are true constants</span>
        <span class="s3">if </span><span class="s1">(self.key </span><span class="s3">instanceof </span><span class="s1">AST_String || self.key </span><span class="s3">instanceof </span><span class="s1">AST_Number) {</span>
            <span class="s3">if </span><span class="s1">(self.key.value == </span><span class="s2">&quot;constructor&quot;</span>
                <span class="s1">&amp;&amp; compressor.parent() </span><span class="s3">instanceof </span><span class="s1">AST_Class) </span><span class="s3">return </span><span class="s1">self;</span>
            <span class="s3">if </span><span class="s1">(self </span><span class="s3">instanceof </span><span class="s1">AST_ObjectKeyVal) {</span>
                <span class="s1">self.key = self.key.value;</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s1">self.key = make_node(AST_SymbolMethod, self.key, {</span>
                    <span class="s1">name: self.key.value</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">self;</span>
    <span class="s1">}</span>

    <span class="s1">OPT(AST_ObjectProperty, lift_key);</span>

    <span class="s1">OPT(AST_ConciseMethod, </span><span class="s3">function</span><span class="s1">(self, compressor){</span>
        <span class="s1">lift_key(self, compressor);</span>
        <span class="s0">// p(){return x;} ---&gt; p:()=&gt;x</span>
        <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;arrows&quot;</span><span class="s1">)</span>
            <span class="s1">&amp;&amp; compressor.parent() </span><span class="s3">instanceof </span><span class="s1">AST_Object</span>
            <span class="s1">&amp;&amp; !self.value.uses_arguments</span>
            <span class="s1">&amp;&amp; !self.value.uses_eval</span>
            <span class="s1">&amp;&amp; self.value.body.length == </span><span class="s4">1</span>
            <span class="s1">&amp;&amp; self.value.body[</span><span class="s4">0</span><span class="s1">] </span><span class="s3">instanceof </span><span class="s1">AST_Return</span>
            <span class="s1">&amp;&amp; self.value.body[</span><span class="s4">0</span><span class="s1">].value</span>
            <span class="s1">&amp;&amp; !self.value.contains_this()) {</span>
            <span class="s3">var </span><span class="s1">arrow = make_node(AST_Arrow, self.value, self.value);</span>
            <span class="s1">arrow.async = self.async;</span>
            <span class="s1">arrow.is_generator = self.is_generator;</span>
            <span class="s3">return </span><span class="s1">make_node(AST_ObjectKeyVal, self, {</span>
                <span class="s1">key: self.key </span><span class="s3">instanceof </span><span class="s1">AST_SymbolMethod ? self.key.name : self.key,</span>
                <span class="s1">value: arrow,</span>
                <span class="s1">quote: self.quote,</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">self;</span>
    <span class="s1">});</span>

    <span class="s1">OPT(AST_ObjectKeyVal, </span><span class="s3">function</span><span class="s1">(self, compressor){</span>
        <span class="s1">lift_key(self, compressor);</span>
        <span class="s0">// p:function(){} ---&gt; p(){}</span>
        <span class="s0">// p:function*(){} ---&gt; *p(){}</span>
        <span class="s0">// p:async function(){} ---&gt; async p(){}</span>
        <span class="s0">// p:()=&gt;{} ---&gt; p(){}</span>
        <span class="s0">// p:async()=&gt;{} ---&gt; async p(){}</span>
        <span class="s3">var </span><span class="s1">unsafe_methods = compressor.option(</span><span class="s2">&quot;unsafe_methods&quot;</span><span class="s1">);</span>
        <span class="s3">if </span><span class="s1">(unsafe_methods</span>
            <span class="s1">&amp;&amp; compressor.option(</span><span class="s2">&quot;ecma&quot;</span><span class="s1">) &gt;= </span><span class="s4">6</span>
            <span class="s1">&amp;&amp; (!(unsafe_methods </span><span class="s3">instanceof </span><span class="s1">RegExp) || unsafe_methods.test(self.key + </span><span class="s2">&quot;&quot;</span><span class="s1">))) {</span>
            <span class="s3">var </span><span class="s1">key = self.key;</span>
            <span class="s3">var </span><span class="s1">value = self.value;</span>
            <span class="s3">var </span><span class="s1">is_arrow_with_block = value </span><span class="s3">instanceof </span><span class="s1">AST_Arrow</span>
                <span class="s1">&amp;&amp; Array.isArray(value.body)</span>
                <span class="s1">&amp;&amp; !value.contains_this();</span>
            <span class="s3">if </span><span class="s1">((is_arrow_with_block || value </span><span class="s3">instanceof </span><span class="s1">AST_Function) &amp;&amp; !value.name) {</span>
                <span class="s3">return </span><span class="s1">make_node(AST_ConciseMethod, self, {</span>
                    <span class="s1">async: value.async,</span>
                    <span class="s1">is_generator: value.is_generator,</span>
                    <span class="s1">key: key </span><span class="s3">instanceof </span><span class="s1">AST_Node ? key : make_node(AST_SymbolMethod, self, {</span>
                        <span class="s1">name: key,</span>
                    <span class="s1">}),</span>
                    <span class="s1">value: make_node(AST_Accessor, value, value),</span>
                    <span class="s1">quote: self.quote,</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">self;</span>
    <span class="s1">});</span>
<span class="s1">})();</span>
</pre>
</body>
</html>
<html>
<head>
<title>XMLHttpRequest.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
.s5 { color: #4646f1;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
XMLHttpRequest.js</font>
</center></td></tr></table>
<pre><span class="s0">/** 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 * 
 * @format 
 * @flow 
 */</span>

<span class="s2">'use strict'</span><span class="s1">;</span>

<span class="s1">import type {IPerformanceLogger} from </span><span class="s2">'../Utilities/createPerformanceLogger'</span><span class="s1">;</span>

<span class="s1">import {type EventSubscription} from </span><span class="s2">'../vendor/emitter/EventEmitter'</span><span class="s1">;</span>

<span class="s1">const BlobManager = require(</span><span class="s2">'../Blob/BlobManager'</span><span class="s1">);</span>
<span class="s1">const GlobalPerformanceLogger = require(</span><span class="s2">'../Utilities/GlobalPerformanceLogger'</span><span class="s1">);</span>
<span class="s1">const RCTNetworking = require(</span><span class="s2">'./RCTNetworking'</span><span class="s1">).</span><span class="s3">default</span><span class="s1">;</span>
<span class="s1">const base64 = require(</span><span class="s2">'base64-js'</span><span class="s1">);</span>
<span class="s1">const EventTarget = require(</span><span class="s2">'event-target-shim'</span><span class="s1">);</span>
<span class="s1">const invariant = require(</span><span class="s2">'invariant'</span><span class="s1">);</span>

<span class="s1">const DEBUG_NETWORK_SEND_DELAY: </span><span class="s3">false </span><span class="s1">= </span><span class="s3">false</span><span class="s1">; </span><span class="s0">// Set to a number of milliseconds when debugging</span>

<span class="s1">export type NativeResponseType = </span><span class="s2">'base64' </span><span class="s1">| </span><span class="s2">'blob' </span><span class="s1">| </span><span class="s2">'text'</span><span class="s1">;</span>
<span class="s1">export type ResponseType =</span>
  <span class="s1">| </span><span class="s2">''</span>
  <span class="s1">| </span><span class="s2">'arraybuffer'</span>
  <span class="s1">| </span><span class="s2">'blob'</span>
  <span class="s1">| </span><span class="s2">'document'</span>
  <span class="s1">| </span><span class="s2">'json'</span>
  <span class="s1">| </span><span class="s2">'text'</span><span class="s1">;</span>
<span class="s1">export type Response = ?Object | string;</span>

<span class="s1">type XHRInterceptor = interface {</span>
  <span class="s1">requestSent(id: number, url: string, method: string, headers: Object): </span><span class="s3">void</span><span class="s1">,</span>
  <span class="s1">responseReceived(</span>
    <span class="s1">id: number,</span>
    <span class="s1">url: string,</span>
    <span class="s1">status: number,</span>
    <span class="s1">headers: Object,</span>
  <span class="s1">): </span><span class="s3">void</span><span class="s1">,</span>
  <span class="s1">dataReceived(id: number, data: string): </span><span class="s3">void</span><span class="s1">,</span>
  <span class="s1">loadingFinished(id: number, encodedDataLength: number): </span><span class="s3">void</span><span class="s1">,</span>
  <span class="s1">loadingFailed(id: number, error: string): </span><span class="s3">void</span><span class="s1">,</span>
<span class="s1">};</span>

<span class="s0">// The native blob module is optional so inject it here if available.</span>
<span class="s3">if </span><span class="s1">(BlobManager.isAvailable) {</span>
  <span class="s1">BlobManager.addNetworkingHandler();</span>
<span class="s1">}</span>

<span class="s1">const UNSENT = </span><span class="s4">0</span><span class="s1">;</span>
<span class="s1">const OPENED = </span><span class="s4">1</span><span class="s1">;</span>
<span class="s1">const HEADERS_RECEIVED = </span><span class="s4">2</span><span class="s1">;</span>
<span class="s1">const LOADING = </span><span class="s4">3</span><span class="s1">;</span>
<span class="s1">const DONE = </span><span class="s4">4</span><span class="s1">;</span>

<span class="s1">const SUPPORTED_RESPONSE_TYPES = {</span>
  <span class="s1">arraybuffer: </span><span class="s3">typeof </span><span class="s1">global.ArrayBuffer === </span><span class="s2">'function'</span><span class="s1">,</span>
  <span class="s1">blob: </span><span class="s3">typeof </span><span class="s1">global.Blob === </span><span class="s2">'function'</span><span class="s1">,</span>
  <span class="s1">document: </span><span class="s3">false</span><span class="s1">,</span>
  <span class="s1">json: </span><span class="s3">true</span><span class="s1">,</span>
  <span class="s1">text: </span><span class="s3">true</span><span class="s1">,</span>
  <span class="s2">''</span><span class="s1">: </span><span class="s3">true</span><span class="s1">,</span>
<span class="s1">};</span>

<span class="s1">const REQUEST_EVENTS = [</span>
  <span class="s2">'abort'</span><span class="s1">,</span>
  <span class="s2">'error'</span><span class="s1">,</span>
  <span class="s2">'load'</span><span class="s1">,</span>
  <span class="s2">'loadstart'</span><span class="s1">,</span>
  <span class="s2">'progress'</span><span class="s1">,</span>
  <span class="s2">'timeout'</span><span class="s1">,</span>
  <span class="s2">'loadend'</span><span class="s1">,</span>
<span class="s1">];</span>

<span class="s1">const XHR_EVENTS = REQUEST_EVENTS.concat(</span><span class="s2">'readystatechange'</span><span class="s1">);</span>

<span class="s1">class XMLHttpRequestEventTarget extends (EventTarget(...REQUEST_EVENTS): any) {</span>
  <span class="s1">onload: ?Function;</span>
  <span class="s1">onloadstart: ?Function;</span>
  <span class="s1">onprogress: ?Function;</span>
  <span class="s1">ontimeout: ?Function;</span>
  <span class="s1">onerror: ?Function;</span>
  <span class="s1">onabort: ?Function;</span>
  <span class="s1">onloadend: ?Function;</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Shared base for platform-specific XMLHttpRequest implementations. 
 */</span>
<span class="s1">class XMLHttpRequest extends (EventTarget(...XHR_EVENTS): any) {</span>
  <span class="s1">static UNSENT: number = UNSENT;</span>
  <span class="s1">static OPENED: number = OPENED;</span>
  <span class="s1">static HEADERS_RECEIVED: number = HEADERS_RECEIVED;</span>
  <span class="s1">static LOADING: number = LOADING;</span>
  <span class="s1">static DONE: number = DONE;</span>

  <span class="s1">static _interceptor: ?XHRInterceptor = </span><span class="s3">null</span><span class="s1">;</span>

  <span class="s1">UNSENT: number = UNSENT;</span>
  <span class="s1">OPENED: number = OPENED;</span>
  <span class="s1">HEADERS_RECEIVED: number = HEADERS_RECEIVED;</span>
  <span class="s1">LOADING: number = LOADING;</span>
  <span class="s1">DONE: number = DONE;</span>

  <span class="s0">// EventTarget automatically initializes these to `null`.</span>
  <span class="s1">onload: ?Function;</span>
  <span class="s1">onloadstart: ?Function;</span>
  <span class="s1">onprogress: ?Function;</span>
  <span class="s1">ontimeout: ?Function;</span>
  <span class="s1">onerror: ?Function;</span>
  <span class="s1">onabort: ?Function;</span>
  <span class="s1">onloadend: ?Function;</span>
  <span class="s1">onreadystatechange: ?Function;</span>

  <span class="s1">readyState: number = UNSENT;</span>
  <span class="s1">responseHeaders: ?Object;</span>
  <span class="s1">status: number = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s1">timeout: number = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s1">responseURL: ?string;</span>
  <span class="s1">withCredentials: boolean = </span><span class="s3">true</span><span class="s1">;</span>

  <span class="s1">upload: XMLHttpRequestEventTarget = </span><span class="s3">new </span><span class="s1">XMLHttpRequestEventTarget();</span>

  <span class="s1">_requestId: ?number;</span>
  <span class="s1">_subscriptions: Array&lt;EventSubscription&gt;;</span>

  <span class="s1">_aborted: boolean = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s1">_cachedResponse: Response;</span>
  <span class="s1">_hasError: boolean = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s1">_headers: Object;</span>
  <span class="s1">_lowerCaseResponseHeaders: Object;</span>
  <span class="s1">_method: ?string = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">_perfKey: ?string = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">_responseType: ResponseType;</span>
  <span class="s1">_response: string = </span><span class="s2">''</span><span class="s1">;</span>
  <span class="s1">_sent: boolean;</span>
  <span class="s1">_url: ?string = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">_timedOut: boolean = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s1">_trackingName: string = </span><span class="s2">'unknown'</span><span class="s1">;</span>
  <span class="s1">_incrementalEvents: boolean = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s1">_performanceLogger: IPerformanceLogger = GlobalPerformanceLogger;</span>

  <span class="s1">static setInterceptor(interceptor: ?XHRInterceptor) {</span>
    <span class="s1">XMLHttpRequest._interceptor = interceptor;</span>
  <span class="s1">}</span>

  <span class="s1">constructor() {</span>
    <span class="s1">super();</span>
    <span class="s3">this</span><span class="s1">._reset();</span>
  <span class="s1">}</span>

  <span class="s1">_reset(): </span><span class="s3">void </span><span class="s1">{</span>
    <span class="s3">this</span><span class="s1">.readyState = </span><span class="s3">this</span><span class="s1">.UNSENT;</span>
    <span class="s3">this</span><span class="s1">.responseHeaders = undefined;</span>
    <span class="s3">this</span><span class="s1">.status = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s3">delete this</span><span class="s1">.responseURL;</span>

    <span class="s3">this</span><span class="s1">._requestId = </span><span class="s3">null</span><span class="s1">;</span>

    <span class="s3">this</span><span class="s1">._cachedResponse = undefined;</span>
    <span class="s3">this</span><span class="s1">._hasError = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s1">._headers = {};</span>
    <span class="s3">this</span><span class="s1">._response = </span><span class="s2">''</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s1">._responseType = </span><span class="s2">''</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s1">._sent = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s1">._lowerCaseResponseHeaders = {};</span>

    <span class="s3">this</span><span class="s1">._clearSubscriptions();</span>
    <span class="s3">this</span><span class="s1">._timedOut = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s1">get responseType(): ResponseType {</span>
    <span class="s3">return this</span><span class="s1">._responseType;</span>
  <span class="s1">}</span>

  <span class="s1">set responseType(responseType: ResponseType): </span><span class="s3">void </span><span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._sent) {</span>
      <span class="s3">throw new </span><span class="s1">Error(</span>
        <span class="s2">&quot;Failed to set the 'responseType' property on 'XMLHttpRequest': The &quot; </span><span class="s1">+</span>
          <span class="s2">'response type cannot be set after the request has been sent.'</span><span class="s1">,</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(!SUPPORTED_RESPONSE_TYPES.hasOwnProperty(responseType)) {</span>
      <span class="s1">console.warn(</span>
        <span class="s1">`The provided value </span><span class="s2">'${responseType}' </span><span class="s1">is not a valid </span><span class="s2">'responseType'</span><span class="s1">.`,</span>
      <span class="s1">);</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">// redboxes early, e.g. for 'arraybuffer' on ios 7</span>
    <span class="s1">invariant(</span>
      <span class="s1">SUPPORTED_RESPONSE_TYPES[responseType] || responseType === </span><span class="s2">'document'</span><span class="s1">,</span>
      <span class="s1">`The provided value </span><span class="s2">'${responseType}' </span><span class="s1">is unsupported </span><span class="s3">in this </span><span class="s1">environment.`,</span>
    <span class="s1">);</span>

    <span class="s3">if </span><span class="s1">(responseType === </span><span class="s2">'blob'</span><span class="s1">) {</span>
      <span class="s1">invariant(</span>
        <span class="s1">BlobManager.isAvailable,</span>
        <span class="s2">'Native module BlobModule is required for blob support'</span><span class="s1">,</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s3">this</span><span class="s1">._responseType = responseType;</span>
  <span class="s1">}</span>

  <span class="s1">get responseText(): string {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._responseType !== </span><span class="s2">'' </span><span class="s1">&amp;&amp; </span><span class="s3">this</span><span class="s1">._responseType !== </span><span class="s2">'text'</span><span class="s1">) {</span>
      <span class="s3">throw new </span><span class="s1">Error(</span>
        <span class="s2">&quot;The 'responseText' property is only available if 'responseType' &quot; </span><span class="s1">+</span>
          <span class="s1">`is set to </span><span class="s2">'' </span><span class="s1">or </span><span class="s2">'text'</span><span class="s1">, but it is </span><span class="s2">'${this._responseType}'</span><span class="s1">.`,</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.readyState &lt; LOADING) {</span>
      <span class="s3">return </span><span class="s2">''</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">return this</span><span class="s1">._response;</span>
  <span class="s1">}</span>

  <span class="s1">get response(): Response {</span>
    <span class="s1">const {responseType} = </span><span class="s3">this</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s1">(responseType === </span><span class="s2">'' </span><span class="s1">|| responseType === </span><span class="s2">'text'</span><span class="s1">) {</span>
      <span class="s3">return this</span><span class="s1">.readyState &lt; LOADING || </span><span class="s3">this</span><span class="s1">._hasError ? </span><span class="s2">'' </span><span class="s1">: </span><span class="s3">this</span><span class="s1">._response;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.readyState !== DONE) {</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._cachedResponse !== undefined) {</span>
      <span class="s3">return this</span><span class="s1">._cachedResponse;</span>
    <span class="s1">}</span>

    <span class="s3">switch </span><span class="s1">(responseType) {</span>
      <span class="s3">case </span><span class="s2">'document'</span><span class="s1">:</span>
        <span class="s3">this</span><span class="s1">._cachedResponse = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s2">'arraybuffer'</span><span class="s1">:</span>
        <span class="s3">this</span><span class="s1">._cachedResponse = base64.toByteArray(</span><span class="s3">this</span><span class="s1">._response).buffer;</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s2">'blob'</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof this</span><span class="s1">._response === </span><span class="s2">'object' </span><span class="s1">&amp;&amp; </span><span class="s3">this</span><span class="s1">._response) {</span>
          <span class="s3">this</span><span class="s1">._cachedResponse = BlobManager.createFromOptions(</span><span class="s3">this</span><span class="s1">._response);</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._response === </span><span class="s2">''</span><span class="s1">) {</span>
          <span class="s3">this</span><span class="s1">._cachedResponse = BlobManager.createFromParts([]);</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s3">throw new </span><span class="s1">Error(`Invalid response </span><span class="s3">for </span><span class="s1">blob: ${</span><span class="s3">this</span><span class="s1">._response}`);</span>
        <span class="s1">}</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s2">'json'</span><span class="s1">:</span>
        <span class="s3">try </span><span class="s1">{</span>
          <span class="s3">this</span><span class="s1">._cachedResponse = JSON.parse(</span><span class="s3">this</span><span class="s1">._response);</span>
        <span class="s1">} </span><span class="s3">catch </span><span class="s1">(_) {</span>
          <span class="s3">this</span><span class="s1">._cachedResponse = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">default</span><span class="s1">:</span>
        <span class="s3">this</span><span class="s1">._cachedResponse = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">return this</span><span class="s1">._cachedResponse;</span>
  <span class="s1">}</span>

  <span class="s0">// exposed for testing</span>
  <span class="s1">__didCreateRequest(requestId: number): </span><span class="s3">void </span><span class="s1">{</span>
    <span class="s3">this</span><span class="s1">._requestId = requestId;</span>

    <span class="s1">XMLHttpRequest._interceptor &amp;&amp;</span>
      <span class="s1">XMLHttpRequest._interceptor.requestSent(</span>
        <span class="s1">requestId,</span>
        <span class="s3">this</span><span class="s1">._url || </span><span class="s2">''</span><span class="s1">,</span>
        <span class="s3">this</span><span class="s1">._method || </span><span class="s2">'GET'</span><span class="s1">,</span>
        <span class="s3">this</span><span class="s1">._headers,</span>
      <span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s0">// exposed for testing</span>
  <span class="s1">__didUploadProgress(</span>
    <span class="s1">requestId: number,</span>
    <span class="s1">progress: number,</span>
    <span class="s1">total: number,</span>
  <span class="s1">): </span><span class="s3">void </span><span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(requestId === </span><span class="s3">this</span><span class="s1">._requestId) {</span>
      <span class="s3">this</span><span class="s1">.upload.dispatchEvent({</span>
        <span class="s1">type: </span><span class="s2">'progress'</span><span class="s1">,</span>
        <span class="s1">lengthComputable: </span><span class="s3">true</span><span class="s1">,</span>
        <span class="s1">loaded: progress,</span>
        <span class="s1">total,</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">__didReceiveResponse(</span>
    <span class="s1">requestId: number,</span>
    <span class="s1">status: number,</span>
    <span class="s1">responseHeaders: ?Object,</span>
    <span class="s1">responseURL: ?string,</span>
  <span class="s1">): </span><span class="s3">void </span><span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(requestId === </span><span class="s3">this</span><span class="s1">._requestId) {</span>
      <span class="s3">this</span><span class="s1">._perfKey != </span><span class="s3">null </span><span class="s1">&amp;&amp;</span>
        <span class="s3">this</span><span class="s1">._performanceLogger.stopTimespan(</span><span class="s3">this</span><span class="s1">._perfKey);</span>
      <span class="s3">this</span><span class="s1">.status = status;</span>
      <span class="s3">this</span><span class="s1">.setResponseHeaders(responseHeaders);</span>
      <span class="s3">this</span><span class="s1">.setReadyState(</span><span class="s3">this</span><span class="s1">.HEADERS_RECEIVED);</span>
      <span class="s3">if </span><span class="s1">(responseURL || responseURL === </span><span class="s2">''</span><span class="s1">) {</span>
        <span class="s3">this</span><span class="s1">.responseURL = responseURL;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s3">delete this</span><span class="s1">.responseURL;</span>
      <span class="s1">}</span>

      <span class="s1">XMLHttpRequest._interceptor &amp;&amp;</span>
        <span class="s1">XMLHttpRequest._interceptor.responseReceived(</span>
          <span class="s1">requestId,</span>
          <span class="s1">responseURL || </span><span class="s3">this</span><span class="s1">._url || </span><span class="s2">''</span><span class="s1">,</span>
          <span class="s1">status,</span>
          <span class="s1">responseHeaders || {},</span>
        <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">__didReceiveData(requestId: number, response: string): </span><span class="s3">void </span><span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(requestId !== </span><span class="s3">this</span><span class="s1">._requestId) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">this</span><span class="s1">._response = response;</span>
    <span class="s3">this</span><span class="s1">._cachedResponse = undefined; </span><span class="s0">// force lazy recomputation</span>
    <span class="s3">this</span><span class="s1">.setReadyState(</span><span class="s3">this</span><span class="s1">.LOADING);</span>

    <span class="s1">XMLHttpRequest._interceptor &amp;&amp;</span>
      <span class="s1">XMLHttpRequest._interceptor.dataReceived(requestId, response);</span>
  <span class="s1">}</span>

  <span class="s1">__didReceiveIncrementalData(</span>
    <span class="s1">requestId: number,</span>
    <span class="s1">responseText: string,</span>
    <span class="s1">progress: number,</span>
    <span class="s1">total: number,</span>
  <span class="s1">) {</span>
    <span class="s3">if </span><span class="s1">(requestId !== </span><span class="s3">this</span><span class="s1">._requestId) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(!</span><span class="s3">this</span><span class="s1">._response) {</span>
      <span class="s3">this</span><span class="s1">._response = responseText;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">this</span><span class="s1">._response += responseText;</span>
    <span class="s1">}</span>

    <span class="s1">XMLHttpRequest._interceptor &amp;&amp;</span>
      <span class="s1">XMLHttpRequest._interceptor.dataReceived(requestId, responseText);</span>

    <span class="s3">this</span><span class="s1">.setReadyState(</span><span class="s3">this</span><span class="s1">.LOADING);</span>
    <span class="s3">this</span><span class="s1">.__didReceiveDataProgress(requestId, progress, total);</span>
  <span class="s1">}</span>

  <span class="s1">__didReceiveDataProgress(</span>
    <span class="s1">requestId: number,</span>
    <span class="s1">loaded: number,</span>
    <span class="s1">total: number,</span>
  <span class="s1">): </span><span class="s3">void </span><span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(requestId !== </span><span class="s3">this</span><span class="s1">._requestId) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">this</span><span class="s1">.dispatchEvent({</span>
      <span class="s1">type: </span><span class="s2">'progress'</span><span class="s1">,</span>
      <span class="s1">lengthComputable: total &gt;= </span><span class="s4">0</span><span class="s1">,</span>
      <span class="s1">loaded,</span>
      <span class="s1">total,</span>
    <span class="s1">});</span>
  <span class="s1">}</span>

  <span class="s0">// exposed for testing</span>
  <span class="s1">__didCompleteResponse(</span>
    <span class="s1">requestId: number,</span>
    <span class="s1">error: string,</span>
    <span class="s1">timeOutError: boolean,</span>
  <span class="s1">): </span><span class="s3">void </span><span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(requestId === </span><span class="s3">this</span><span class="s1">._requestId) {</span>
      <span class="s3">if </span><span class="s1">(error) {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._responseType === </span><span class="s2">'' </span><span class="s1">|| </span><span class="s3">this</span><span class="s1">._responseType === </span><span class="s2">'text'</span><span class="s1">) {</span>
          <span class="s3">this</span><span class="s1">._response = error;</span>
        <span class="s1">}</span>
        <span class="s3">this</span><span class="s1">._hasError = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s1">(timeOutError) {</span>
          <span class="s3">this</span><span class="s1">._timedOut = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s3">this</span><span class="s1">._clearSubscriptions();</span>
      <span class="s3">this</span><span class="s1">._requestId = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s3">this</span><span class="s1">.setReadyState(</span><span class="s3">this</span><span class="s1">.DONE);</span>

      <span class="s3">if </span><span class="s1">(error) {</span>
        <span class="s1">XMLHttpRequest._interceptor &amp;&amp;</span>
          <span class="s1">XMLHttpRequest._interceptor.loadingFailed(requestId, error);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">XMLHttpRequest._interceptor &amp;&amp;</span>
          <span class="s1">XMLHttpRequest._interceptor.loadingFinished(</span>
            <span class="s1">requestId,</span>
            <span class="s3">this</span><span class="s1">._response.length,</span>
          <span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">_clearSubscriptions(): </span><span class="s3">void </span><span class="s1">{</span>
    <span class="s1">(</span><span class="s3">this</span><span class="s1">._subscriptions || []).forEach(sub =&gt; {</span>
      <span class="s3">if </span><span class="s1">(sub) {</span>
        <span class="s1">sub.remove();</span>
      <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s3">this</span><span class="s1">._subscriptions = [];</span>
  <span class="s1">}</span>

  <span class="s1">getAllResponseHeaders(): ?string {</span>
    <span class="s3">if </span><span class="s1">(!</span><span class="s3">this</span><span class="s1">.responseHeaders) {</span>
      <span class="s0">// according to the spec, return null if no response has been received</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">// Assign to non-nullable local variable.</span>
    <span class="s1">const responseHeaders = </span><span class="s3">this</span><span class="s1">.responseHeaders;</span>

    <span class="s1">const unsortedHeaders: Map&lt;</span>
      <span class="s1">string,</span>
      <span class="s1">{lowerHeaderName: string, upperHeaderName: string, headerValue: string},</span>
    <span class="s1">&gt; = </span><span class="s3">new </span><span class="s1">Map();</span>
    <span class="s3">for </span><span class="s1">(const rawHeaderName of Object.keys(responseHeaders)) {</span>
      <span class="s1">const headerValue = responseHeaders[rawHeaderName];</span>
      <span class="s1">const lowerHeaderName = rawHeaderName.toLowerCase();</span>
      <span class="s1">const header = unsortedHeaders.get(lowerHeaderName);</span>
      <span class="s3">if </span><span class="s1">(header) {</span>
        <span class="s1">header.headerValue += </span><span class="s2">', ' </span><span class="s1">+ headerValue;</span>
        <span class="s1">unsortedHeaders.set(lowerHeaderName, header);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">unsortedHeaders.set(lowerHeaderName, {</span>
          <span class="s1">lowerHeaderName,</span>
          <span class="s1">upperHeaderName: rawHeaderName.toUpperCase(),</span>
          <span class="s1">headerValue,</span>
        <span class="s1">});</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">// Sort in ascending order, with a being less than b if a's name is legacy-uppercased-byte less than b's name.</span>
    <span class="s1">const sortedHeaders = [...unsortedHeaders.values()].sort((a, b) =&gt; {</span>
      <span class="s3">if </span><span class="s1">(a.upperHeaderName &lt; b.upperHeaderName) {</span>
        <span class="s3">return </span><span class="s1">-</span><span class="s4">1</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(a.upperHeaderName &gt; b.upperHeaderName) {</span>
        <span class="s3">return </span><span class="s4">1</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s3">return </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">});</span>

    <span class="s0">// Combine into single text response.</span>
    <span class="s3">return </span><span class="s1">(</span>
      <span class="s1">sortedHeaders</span>
        <span class="s1">.map(header =&gt; {</span>
          <span class="s3">return </span><span class="s1">header.lowerHeaderName + </span><span class="s2">': ' </span><span class="s1">+ header.headerValue;</span>
        <span class="s1">})</span>
        <span class="s1">.join(</span><span class="s2">'</span><span class="s5">\r\n</span><span class="s2">'</span><span class="s1">) + </span><span class="s2">'</span><span class="s5">\r\n</span><span class="s2">'</span>
    <span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s1">getResponseHeader(header: string): ?string {</span>
    <span class="s1">const value = </span><span class="s3">this</span><span class="s1">._lowerCaseResponseHeaders[header.toLowerCase()];</span>
    <span class="s3">return </span><span class="s1">value !== undefined ? value : </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s1">setRequestHeader(header: string, value: any): </span><span class="s3">void </span><span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.readyState !== </span><span class="s3">this</span><span class="s1">.OPENED) {</span>
      <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">'Request has not been opened'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s3">this</span><span class="s1">._headers[header.toLowerCase()] = String(value);</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Custom extension for tracking origins of request. 
   */</span>
  <span class="s1">setTrackingName(trackingName: string): XMLHttpRequest {</span>
    <span class="s3">this</span><span class="s1">._trackingName = trackingName;</span>
    <span class="s3">return this</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Custom extension for setting a custom performance logger 
   */</span>
  <span class="s1">setPerformanceLogger(performanceLogger: IPerformanceLogger): XMLHttpRequest {</span>
    <span class="s3">this</span><span class="s1">._performanceLogger = performanceLogger;</span>
    <span class="s3">return this</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s1">open(method: string, url: string, async: ?boolean): </span><span class="s3">void </span><span class="s1">{</span>
    <span class="s0">/* Other optional arguments are not supported yet */</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.readyState !== </span><span class="s3">this</span><span class="s1">.UNSENT) {</span>
      <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">'Cannot open, already sending'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(async !== undefined &amp;&amp; !async) {</span>
      <span class="s0">// async is default</span>
      <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">'Synchronous http requests are not supported'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(!url) {</span>
      <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">'Cannot load an empty url'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s3">this</span><span class="s1">._method = method.toUpperCase();</span>
    <span class="s3">this</span><span class="s1">._url = url;</span>
    <span class="s3">this</span><span class="s1">._aborted = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s1">.setReadyState(</span><span class="s3">this</span><span class="s1">.OPENED);</span>
  <span class="s1">}</span>

  <span class="s1">send(data: any): </span><span class="s3">void </span><span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.readyState !== </span><span class="s3">this</span><span class="s1">.OPENED) {</span>
      <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">'Request has not been opened'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._sent) {</span>
      <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">'Request has already been sent'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s3">this</span><span class="s1">._sent = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">const incrementalEvents =</span>
      <span class="s3">this</span><span class="s1">._incrementalEvents || !!</span><span class="s3">this</span><span class="s1">.onreadystatechange || !!</span><span class="s3">this</span><span class="s1">.onprogress;</span>

    <span class="s3">this</span><span class="s1">._subscriptions.push(</span>
      <span class="s1">RCTNetworking.addListener(</span><span class="s2">'didSendNetworkData'</span><span class="s1">, args =&gt;</span>
        <span class="s3">this</span><span class="s1">.__didUploadProgress(...args),</span>
      <span class="s1">),</span>
    <span class="s1">);</span>
    <span class="s3">this</span><span class="s1">._subscriptions.push(</span>
      <span class="s1">RCTNetworking.addListener(</span><span class="s2">'didReceiveNetworkResponse'</span><span class="s1">, args =&gt;</span>
        <span class="s3">this</span><span class="s1">.__didReceiveResponse(...args),</span>
      <span class="s1">),</span>
    <span class="s1">);</span>
    <span class="s3">this</span><span class="s1">._subscriptions.push(</span>
      <span class="s1">RCTNetworking.addListener(</span><span class="s2">'didReceiveNetworkData'</span><span class="s1">, args =&gt;</span>
        <span class="s3">this</span><span class="s1">.__didReceiveData(...args),</span>
      <span class="s1">),</span>
    <span class="s1">);</span>
    <span class="s3">this</span><span class="s1">._subscriptions.push(</span>
      <span class="s1">RCTNetworking.addListener(</span><span class="s2">'didReceiveNetworkIncrementalData'</span><span class="s1">, args =&gt;</span>
        <span class="s3">this</span><span class="s1">.__didReceiveIncrementalData(...args),</span>
      <span class="s1">),</span>
    <span class="s1">);</span>
    <span class="s3">this</span><span class="s1">._subscriptions.push(</span>
      <span class="s1">RCTNetworking.addListener(</span><span class="s2">'didReceiveNetworkDataProgress'</span><span class="s1">, args =&gt;</span>
        <span class="s3">this</span><span class="s1">.__didReceiveDataProgress(...args),</span>
      <span class="s1">),</span>
    <span class="s1">);</span>
    <span class="s3">this</span><span class="s1">._subscriptions.push(</span>
      <span class="s1">RCTNetworking.addListener(</span><span class="s2">'didCompleteNetworkResponse'</span><span class="s1">, args =&gt;</span>
        <span class="s3">this</span><span class="s1">.__didCompleteResponse(...args),</span>
      <span class="s1">),</span>
    <span class="s1">);</span>

    <span class="s1">let nativeResponseType: NativeResponseType = </span><span class="s2">'text'</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._responseType === </span><span class="s2">'arraybuffer'</span><span class="s1">) {</span>
      <span class="s1">nativeResponseType = </span><span class="s2">'base64'</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._responseType === </span><span class="s2">'blob'</span><span class="s1">) {</span>
      <span class="s1">nativeResponseType = </span><span class="s2">'blob'</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">const doSend = () =&gt; {</span>
      <span class="s1">const friendlyName =</span>
        <span class="s3">this</span><span class="s1">._trackingName !== </span><span class="s2">'unknown' </span><span class="s1">? </span><span class="s3">this</span><span class="s1">._trackingName : </span><span class="s3">this</span><span class="s1">._url;</span>
      <span class="s3">this</span><span class="s1">._perfKey = </span><span class="s2">'network_XMLHttpRequest_' </span><span class="s1">+ String(friendlyName);</span>
      <span class="s3">this</span><span class="s1">._performanceLogger.startTimespan(</span><span class="s3">this</span><span class="s1">._perfKey);</span>
      <span class="s1">invariant(</span>
        <span class="s3">this</span><span class="s1">._method,</span>
        <span class="s2">'XMLHttpRequest method needs to be defined (%s).'</span><span class="s1">,</span>
        <span class="s1">friendlyName,</span>
      <span class="s1">);</span>
      <span class="s1">invariant(</span>
        <span class="s3">this</span><span class="s1">._url,</span>
        <span class="s2">'XMLHttpRequest URL needs to be defined (%s).'</span><span class="s1">,</span>
        <span class="s1">friendlyName,</span>
      <span class="s1">);</span>
      <span class="s1">RCTNetworking.sendRequest(</span>
        <span class="s3">this</span><span class="s1">._method,</span>
        <span class="s3">this</span><span class="s1">._trackingName,</span>
        <span class="s3">this</span><span class="s1">._url,</span>
        <span class="s3">this</span><span class="s1">._headers,</span>
        <span class="s1">data,</span>
        <span class="s0">/* $FlowFixMe(&gt;=0.78.0 site=react_native_android_fb) This issue was found 
         * when making Flow check .android.js files. */</span>
        <span class="s1">nativeResponseType,</span>
        <span class="s1">incrementalEvents,</span>
        <span class="s3">this</span><span class="s1">.timeout,</span>
        <span class="s0">// $FlowFixMe[method-unbinding] added when improving typing for this parameters</span>
        <span class="s3">this</span><span class="s1">.__didCreateRequest.bind(</span><span class="s3">this</span><span class="s1">),</span>
        <span class="s3">this</span><span class="s1">.withCredentials,</span>
      <span class="s1">);</span>
    <span class="s1">};</span>
    <span class="s3">if </span><span class="s1">(DEBUG_NETWORK_SEND_DELAY) {</span>
      <span class="s1">setTimeout(doSend, DEBUG_NETWORK_SEND_DELAY);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">doSend();</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">abort(): </span><span class="s3">void </span><span class="s1">{</span>
    <span class="s3">this</span><span class="s1">._aborted = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._requestId) {</span>
      <span class="s1">RCTNetworking.abortRequest(</span><span class="s3">this</span><span class="s1">._requestId);</span>
    <span class="s1">}</span>
    <span class="s0">// only call onreadystatechange if there is something to abort,</span>
    <span class="s0">// below logic is per spec</span>
    <span class="s3">if </span><span class="s1">(</span>
      <span class="s1">!(</span>
        <span class="s3">this</span><span class="s1">.readyState === </span><span class="s3">this</span><span class="s1">.UNSENT ||</span>
        <span class="s1">(</span><span class="s3">this</span><span class="s1">.readyState === </span><span class="s3">this</span><span class="s1">.OPENED &amp;&amp; !</span><span class="s3">this</span><span class="s1">._sent) ||</span>
        <span class="s3">this</span><span class="s1">.readyState === </span><span class="s3">this</span><span class="s1">.DONE</span>
      <span class="s1">)</span>
    <span class="s1">) {</span>
      <span class="s3">this</span><span class="s1">._reset();</span>
      <span class="s3">this</span><span class="s1">.setReadyState(</span><span class="s3">this</span><span class="s1">.DONE);</span>
    <span class="s1">}</span>
    <span class="s0">// Reset again after, in case modified in handler</span>
    <span class="s3">this</span><span class="s1">._reset();</span>
  <span class="s1">}</span>

  <span class="s1">setResponseHeaders(responseHeaders: ?Object): </span><span class="s3">void </span><span class="s1">{</span>
    <span class="s3">this</span><span class="s1">.responseHeaders = responseHeaders || </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">const headers = responseHeaders || {};</span>
    <span class="s3">this</span><span class="s1">._lowerCaseResponseHeaders = Object.keys(headers).reduce&lt;{</span>
      <span class="s1">[string]: any,</span>
    <span class="s1">}&gt;((lcaseHeaders, headerName) =&gt; {</span>
      <span class="s1">lcaseHeaders[headerName.toLowerCase()] = headers[headerName];</span>
      <span class="s3">return </span><span class="s1">lcaseHeaders;</span>
    <span class="s1">}, {});</span>
  <span class="s1">}</span>

  <span class="s1">setReadyState(newState: number): </span><span class="s3">void </span><span class="s1">{</span>
    <span class="s3">this</span><span class="s1">.readyState = newState;</span>
    <span class="s3">this</span><span class="s1">.dispatchEvent({type: </span><span class="s2">'readystatechange'</span><span class="s1">});</span>
    <span class="s3">if </span><span class="s1">(newState === </span><span class="s3">this</span><span class="s1">.DONE) {</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._aborted) {</span>
        <span class="s3">this</span><span class="s1">.dispatchEvent({type: </span><span class="s2">'abort'</span><span class="s1">});</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._hasError) {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._timedOut) {</span>
          <span class="s3">this</span><span class="s1">.dispatchEvent({type: </span><span class="s2">'timeout'</span><span class="s1">});</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s3">this</span><span class="s1">.dispatchEvent({type: </span><span class="s2">'error'</span><span class="s1">});</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s3">this</span><span class="s1">.dispatchEvent({type: </span><span class="s2">'load'</span><span class="s1">});</span>
      <span class="s1">}</span>
      <span class="s3">this</span><span class="s1">.dispatchEvent({type: </span><span class="s2">'loadend'</span><span class="s1">});</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">/* global EventListener */</span>
  <span class="s1">addEventListener(type: string, listener: EventListener): </span><span class="s3">void </span><span class="s1">{</span>
    <span class="s0">// If we dont' have a 'readystatechange' event handler, we don't</span>
    <span class="s0">// have to send repeated LOADING events with incremental updates</span>
    <span class="s0">// to responseText, which will avoid a bunch of native -&gt; JS</span>
    <span class="s0">// bridge traffic.</span>
    <span class="s3">if </span><span class="s1">(type === </span><span class="s2">'readystatechange' </span><span class="s1">|| type === </span><span class="s2">'progress'</span><span class="s1">) {</span>
      <span class="s3">this</span><span class="s1">._incrementalEvents = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">super.addEventListener(type, listener);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">module.exports = XMLHttpRequest;</span>
</pre>
</body>
</html>
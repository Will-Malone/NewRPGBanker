<html>
<head>
<title>jsi.cpp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #bbb529;}
.s3 { color: #6a8759;}
.s4 { color: #cc7832;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
jsi.cpp</font>
</center></td></tr></table>
<pre><span class="s0">/* 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>

<span class="s2">#include </span><span class="s3">&lt;cassert&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;cmath&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;cstdlib&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;stdexcept&gt;</span>

<span class="s2">#include </span><span class="s3">&lt;jsi/instrumentation.h&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;jsi/jsi.h&gt;</span>

<span class="s4">namespace </span><span class="s1">facebook {</span>
<span class="s4">namespace </span><span class="s1">jsi {</span>

<span class="s4">namespace </span><span class="s1">{</span>

<span class="s0">// This is used for generating short exception strings.</span>
<span class="s1">std::string kindToString(</span><span class="s4">const </span><span class="s1">Value&amp; v</span><span class="s4">, </span><span class="s1">Runtime* rt = </span><span class="s4">nullptr</span><span class="s1">) {</span>
  <span class="s4">if </span><span class="s1">(v.isUndefined()) {</span>
    <span class="s4">return </span><span class="s3">&quot;undefined&quot;</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else if </span><span class="s1">(v.isNull()) {</span>
    <span class="s4">return </span><span class="s3">&quot;null&quot;</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else if </span><span class="s1">(v.isBool()) {</span>
    <span class="s4">return </span><span class="s1">v.getBool() ? </span><span class="s3">&quot;true&quot; </span><span class="s1">: </span><span class="s3">&quot;false&quot;</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else if </span><span class="s1">(v.isNumber()) {</span>
    <span class="s4">return </span><span class="s3">&quot;a number&quot;</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else if </span><span class="s1">(v.isString()) {</span>
    <span class="s4">return </span><span class="s3">&quot;a string&quot;</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else if </span><span class="s1">(v.isSymbol()) {</span>
    <span class="s4">return </span><span class="s3">&quot;a symbol&quot;</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else if </span><span class="s1">(v.isBigInt()) {</span>
    <span class="s4">return </span><span class="s3">&quot;a bigint&quot;</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s1">assert(v.isObject() &amp;&amp; </span><span class="s3">&quot;Expecting object.&quot;</span><span class="s1">)</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">rt != </span><span class="s4">nullptr </span><span class="s1">&amp;&amp; v.getObject(*rt).isFunction(*rt) ? </span><span class="s3">&quot;a function&quot;</span>
                                                             <span class="s1">: </span><span class="s3">&quot;an object&quot;</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">// getPropertyAsFunction() will try to create a JSError.  If the</span>
<span class="s0">// failure is in building a JSError, this will lead to infinite</span>
<span class="s0">// recursion.  This function is used in place of getPropertyAsFunction</span>
<span class="s0">// when building JSError, to avoid that infinite recursion.</span>
<span class="s1">Value callGlobalFunction(Runtime&amp; runtime</span><span class="s4">, const char</span><span class="s1">* name</span><span class="s4">, const </span><span class="s1">Value&amp; arg) {</span>
  <span class="s1">Value v = runtime.global().getProperty(runtime</span><span class="s4">, </span><span class="s1">name)</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(!v.isObject()) {</span>
    <span class="s4">throw </span><span class="s1">JSINativeException(</span>
        <span class="s1">std::string(</span><span class="s3">&quot;callGlobalFunction: JS global property '&quot;</span><span class="s1">) + name +</span>
        <span class="s3">&quot;' is &quot; </span><span class="s1">+ kindToString(v</span><span class="s4">, </span><span class="s1">&amp;runtime) + </span><span class="s3">&quot;, expected a Function&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s1">Object o = v.getObject(runtime)</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(!o.isFunction(runtime)) {</span>
    <span class="s4">throw </span><span class="s1">JSINativeException(</span>
        <span class="s1">std::string(</span><span class="s3">&quot;callGlobalFunction: JS global property '&quot;</span><span class="s1">) + name +</span>
        <span class="s3">&quot;' is a non-callable Object, expected a Function&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s1">Function f = std::move(o).getFunction(runtime)</span><span class="s4">;</span>
  <span class="s4">return </span><span class="s1">f.call(runtime</span><span class="s4">, </span><span class="s1">arg)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">} </span><span class="s0">// namespace</span>

<span class="s1">Buffer::~Buffer() = </span><span class="s4">default;</span>

<span class="s1">MutableBuffer::~MutableBuffer() = </span><span class="s4">default;</span>

<span class="s1">PreparedJavaScript::~PreparedJavaScript() = </span><span class="s4">default;</span>

<span class="s1">Value HostObject::get(Runtime&amp;</span><span class="s4">, const </span><span class="s1">PropNameID&amp;) {</span>
  <span class="s4">return </span><span class="s1">Value()</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">HostObject::set(Runtime&amp; rt</span><span class="s4">, const </span><span class="s1">PropNameID&amp; name</span><span class="s4">, const </span><span class="s1">Value&amp;) {</span>
  <span class="s1">std::string msg(</span><span class="s3">&quot;TypeError: Cannot assign to property '&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">msg += name.utf8(rt)</span><span class="s4">;</span>
  <span class="s1">msg += </span><span class="s3">&quot;' on HostObject with default setter&quot;</span><span class="s4">;</span>
  <span class="s4">throw </span><span class="s1">JSError(rt</span><span class="s4">, </span><span class="s1">msg)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">HostObject::~HostObject() {}</span>

<span class="s1">NativeState::~NativeState() {}</span>

<span class="s1">Runtime::~Runtime() {}</span>

<span class="s1">Instrumentation&amp; Runtime::instrumentation() {</span>
  <span class="s4">class </span><span class="s1">NoInstrumentation : </span><span class="s4">public </span><span class="s1">Instrumentation {</span>
    <span class="s1">std::string getRecordedGCStats() override {</span>
      <span class="s4">return </span><span class="s3">&quot;&quot;</span><span class="s4">;</span>
    <span class="s1">}</span>

    <span class="s1">std::unordered_map&lt;std::string</span><span class="s4">, </span><span class="s1">int64_t&gt; getHeapInfo(</span><span class="s4">bool</span><span class="s1">) override {</span>
      <span class="s4">return </span><span class="s1">std::unordered_map&lt;std::string</span><span class="s4">, </span><span class="s1">int64_t&gt;{}</span><span class="s4">;</span>
    <span class="s1">}</span>

    <span class="s4">void </span><span class="s1">collectGarbage(std::string) override {}</span>

    <span class="s4">void </span><span class="s1">startTrackingHeapObjectStackTraces(</span>
        <span class="s1">std::function&lt;</span><span class="s4">void</span><span class="s1">(</span>
            <span class="s1">uint64_t</span><span class="s4">,</span>
            <span class="s1">std::chrono::microseconds</span><span class="s4">,</span>
            <span class="s1">std::vector&lt;HeapStatsUpdate&gt;)&gt;) override {}</span>
    <span class="s4">void </span><span class="s1">stopTrackingHeapObjectStackTraces() override {}</span>

    <span class="s4">void </span><span class="s1">startHeapSampling(size_t) override {}</span>
    <span class="s4">void </span><span class="s1">stopHeapSampling(std::ostream&amp;) override {}</span>

    <span class="s4">void </span><span class="s1">createSnapshotToFile(</span><span class="s4">const </span><span class="s1">std::string&amp;) override {</span>
      <span class="s4">throw </span><span class="s1">JSINativeException(</span>
          <span class="s3">&quot;Default instrumentation cannot create a heap snapshot&quot;</span><span class="s1">)</span><span class="s4">;</span>
    <span class="s1">}</span>

    <span class="s4">void </span><span class="s1">createSnapshotToStream(std::ostream&amp;) override {</span>
      <span class="s4">throw </span><span class="s1">JSINativeException(</span>
          <span class="s3">&quot;Default instrumentation cannot create a heap snapshot&quot;</span><span class="s1">)</span><span class="s4">;</span>
    <span class="s1">}</span>

    <span class="s1">std::string flushAndDisableBridgeTrafficTrace() override {</span>
      <span class="s1">std::abort()</span><span class="s4">;</span>
    <span class="s1">}</span>

    <span class="s4">void </span><span class="s1">writeBasicBlockProfileTraceToFile(</span><span class="s4">const </span><span class="s1">std::string&amp;) </span><span class="s4">const </span><span class="s1">override {</span>
      <span class="s1">std::abort()</span><span class="s4">;</span>
    <span class="s1">}</span>

    <span class="s4">void </span><span class="s1">dumpProfilerSymbolsToFile(</span><span class="s4">const </span><span class="s1">std::string&amp;) </span><span class="s4">const </span><span class="s1">override {</span>
      <span class="s1">std::abort()</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s4">;</span>

  <span class="s4">static </span><span class="s1">NoInstrumentation sharedInstance</span><span class="s4">;</span>
  <span class="s4">return </span><span class="s1">sharedInstance</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">Value Runtime::createValueFromJsonUtf8(</span><span class="s4">const </span><span class="s1">uint8_t* json</span><span class="s4">, </span><span class="s1">size_t length) {</span>
  <span class="s1">Function parseJson = global()</span>
                           <span class="s1">.getPropertyAsObject(*</span><span class="s4">this, </span><span class="s3">&quot;JSON&quot;</span><span class="s1">)</span>
                           <span class="s1">.getPropertyAsFunction(*</span><span class="s4">this, </span><span class="s3">&quot;parse&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s4">return </span><span class="s1">parseJson.call(*</span><span class="s4">this, </span><span class="s1">String::createFromUtf8(*</span><span class="s4">this, </span><span class="s1">json</span><span class="s4">, </span><span class="s1">length))</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">Pointer&amp; Pointer::</span><span class="s4">operator</span><span class="s1">=(Pointer&amp;&amp; other) {</span>
  <span class="s4">if </span><span class="s1">(ptr_) {</span>
    <span class="s1">ptr_-&gt;invalidate()</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s1">ptr_ = other.ptr_</span><span class="s4">;</span>
  <span class="s1">other.ptr_ = </span><span class="s4">nullptr;</span>
  <span class="s4">return </span><span class="s1">*</span><span class="s4">this;</span>
<span class="s1">}</span>

<span class="s1">Object Object::getPropertyAsObject(Runtime&amp; runtime</span><span class="s4">, const char</span><span class="s1">* name) </span><span class="s4">const </span><span class="s1">{</span>
  <span class="s1">Value v = getProperty(runtime</span><span class="s4">, </span><span class="s1">name)</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(!v.isObject()) {</span>
    <span class="s4">throw </span><span class="s1">JSError(</span>
        <span class="s1">runtime</span><span class="s4">,</span>
        <span class="s1">std::string(</span><span class="s3">&quot;getPropertyAsObject: property '&quot;</span><span class="s1">) + name + </span><span class="s3">&quot;' is &quot; </span><span class="s1">+</span>
            <span class="s1">kindToString(v</span><span class="s4">, </span><span class="s1">&amp;runtime) + </span><span class="s3">&quot;, expected an Object&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">return </span><span class="s1">v.getObject(runtime)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">Function Object::getPropertyAsFunction(Runtime&amp; runtime</span><span class="s4">, const char</span><span class="s1">* name)</span>
    <span class="s4">const </span><span class="s1">{</span>
  <span class="s1">Object obj = getPropertyAsObject(runtime</span><span class="s4">, </span><span class="s1">name)</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(!obj.isFunction(runtime)) {</span>
    <span class="s4">throw </span><span class="s1">JSError(</span>
        <span class="s1">runtime</span><span class="s4">,</span>
        <span class="s1">std::string(</span><span class="s3">&quot;getPropertyAsFunction: property '&quot;</span><span class="s1">) + name + </span><span class="s3">&quot;' is &quot; </span><span class="s1">+</span>
            <span class="s1">kindToString(std::move(obj)</span><span class="s4">, </span><span class="s1">&amp;runtime) + </span><span class="s3">&quot;, expected a Function&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>

  <span class="s4">return </span><span class="s1">std::move(obj).getFunction(runtime)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">Array Object::asArray(Runtime&amp; runtime) </span><span class="s4">const</span><span class="s1">&amp; {</span>
  <span class="s4">if </span><span class="s1">(!isArray(runtime)) {</span>
    <span class="s4">throw </span><span class="s1">JSError(</span>
        <span class="s1">runtime</span><span class="s4">,</span>
        <span class="s3">&quot;Object is &quot; </span><span class="s1">+ kindToString(Value(runtime</span><span class="s4">, </span><span class="s1">*</span><span class="s4">this</span><span class="s1">)</span><span class="s4">, </span><span class="s1">&amp;runtime) +</span>
            <span class="s3">&quot;, expected an array&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">return </span><span class="s1">getArray(runtime)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">Array Object::asArray(Runtime&amp; runtime) &amp;&amp; {</span>
  <span class="s4">if </span><span class="s1">(!isArray(runtime)) {</span>
    <span class="s4">throw </span><span class="s1">JSError(</span>
        <span class="s1">runtime</span><span class="s4">,</span>
        <span class="s3">&quot;Object is &quot; </span><span class="s1">+ kindToString(Value(runtime</span><span class="s4">, </span><span class="s1">*</span><span class="s4">this</span><span class="s1">)</span><span class="s4">, </span><span class="s1">&amp;runtime) +</span>
            <span class="s3">&quot;, expected an array&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">return </span><span class="s1">std::move(*</span><span class="s4">this</span><span class="s1">).getArray(runtime)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">Function Object::asFunction(Runtime&amp; runtime) </span><span class="s4">const</span><span class="s1">&amp; {</span>
  <span class="s4">if </span><span class="s1">(!isFunction(runtime)) {</span>
    <span class="s4">throw </span><span class="s1">JSError(</span>
        <span class="s1">runtime</span><span class="s4">,</span>
        <span class="s3">&quot;Object is &quot; </span><span class="s1">+ kindToString(Value(runtime</span><span class="s4">, </span><span class="s1">*</span><span class="s4">this</span><span class="s1">)</span><span class="s4">, </span><span class="s1">&amp;runtime) +</span>
            <span class="s3">&quot;, expected a function&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">return </span><span class="s1">getFunction(runtime)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">Function Object::asFunction(Runtime&amp; runtime) &amp;&amp; {</span>
  <span class="s4">if </span><span class="s1">(!isFunction(runtime)) {</span>
    <span class="s4">throw </span><span class="s1">JSError(</span>
        <span class="s1">runtime</span><span class="s4">,</span>
        <span class="s3">&quot;Object is &quot; </span><span class="s1">+ kindToString(Value(runtime</span><span class="s4">, </span><span class="s1">*</span><span class="s4">this</span><span class="s1">)</span><span class="s4">, </span><span class="s1">&amp;runtime) +</span>
            <span class="s3">&quot;, expected a function&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">return </span><span class="s1">std::move(*</span><span class="s4">this</span><span class="s1">).getFunction(runtime)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">Value::Value(Value&amp;&amp; other) : Value(other.kind_) {</span>
  <span class="s4">if </span><span class="s1">(kind_ == BooleanKind) {</span>
    <span class="s1">data_.boolean = other.data_.boolean</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else if </span><span class="s1">(kind_ == NumberKind) {</span>
    <span class="s1">data_.number = other.data_.number</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else if </span><span class="s1">(kind_ &gt;= PointerKind) {</span>
    <span class="s4">new </span><span class="s1">(&amp;data_.pointer) Pointer(std::move(other.data_.pointer))</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s0">// when the other's dtor runs, nothing will happen.</span>
  <span class="s1">other.kind_ = UndefinedKind</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">Value::Value(Runtime&amp; runtime</span><span class="s4">, const </span><span class="s1">Value&amp; other) : Value(other.kind_) {</span>
  <span class="s0">// data_ is uninitialized, so use placement new to create non-POD</span>
  <span class="s0">// types in it.  Any other kind of initialization will call a dtor</span>
  <span class="s0">// first, which is incorrect.</span>
  <span class="s4">if </span><span class="s1">(kind_ == BooleanKind) {</span>
    <span class="s1">data_.boolean = other.data_.boolean</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else if </span><span class="s1">(kind_ == NumberKind) {</span>
    <span class="s1">data_.number = other.data_.number</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else if </span><span class="s1">(kind_ == SymbolKind) {</span>
    <span class="s4">new </span><span class="s1">(&amp;data_.pointer) Pointer(runtime.cloneSymbol(other.data_.pointer.ptr_))</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else if </span><span class="s1">(kind_ == BigIntKind) {</span>
    <span class="s4">new </span><span class="s1">(&amp;data_.pointer) Pointer(runtime.cloneBigInt(other.data_.pointer.ptr_))</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else if </span><span class="s1">(kind_ == StringKind) {</span>
    <span class="s4">new </span><span class="s1">(&amp;data_.pointer) Pointer(runtime.cloneString(other.data_.pointer.ptr_))</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else if </span><span class="s1">(kind_ &gt;= ObjectKind) {</span>
    <span class="s4">new </span><span class="s1">(&amp;data_.pointer) Pointer(runtime.cloneObject(other.data_.pointer.ptr_))</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">Value::~Value() {</span>
  <span class="s4">if </span><span class="s1">(kind_ &gt;= PointerKind) {</span>
    <span class="s1">data_.pointer.~Pointer()</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s4">bool </span><span class="s1">Value::strictEquals(Runtime&amp; runtime</span><span class="s4">, const </span><span class="s1">Value&amp; a</span><span class="s4">, const </span><span class="s1">Value&amp; b) {</span>
  <span class="s4">if </span><span class="s1">(a.kind_ != b.kind_) {</span>
    <span class="s4">return false;</span>
  <span class="s1">}</span>
  <span class="s4">switch </span><span class="s1">(a.kind_) {</span>
    <span class="s4">case </span><span class="s1">UndefinedKind:</span>
    <span class="s4">case </span><span class="s1">NullKind:</span>
      <span class="s4">return true;</span>
    <span class="s4">case </span><span class="s1">BooleanKind:</span>
      <span class="s4">return </span><span class="s1">a.data_.boolean == b.data_.boolean</span><span class="s4">;</span>
    <span class="s4">case </span><span class="s1">NumberKind:</span>
      <span class="s4">return </span><span class="s1">a.data_.number == b.data_.number</span><span class="s4">;</span>
    <span class="s4">case </span><span class="s1">SymbolKind:</span>
      <span class="s4">return </span><span class="s1">runtime.strictEquals(</span>
          <span class="s4">static_cast</span><span class="s1">&lt;</span><span class="s4">const </span><span class="s1">Symbol&amp;&gt;(a.data_.pointer)</span><span class="s4">,</span>
          <span class="s4">static_cast</span><span class="s1">&lt;</span><span class="s4">const </span><span class="s1">Symbol&amp;&gt;(b.data_.pointer))</span><span class="s4">;</span>
    <span class="s4">case </span><span class="s1">BigIntKind:</span>
      <span class="s4">return </span><span class="s1">runtime.strictEquals(</span>
          <span class="s4">static_cast</span><span class="s1">&lt;</span><span class="s4">const </span><span class="s1">BigInt&amp;&gt;(a.data_.pointer)</span><span class="s4">,</span>
          <span class="s4">static_cast</span><span class="s1">&lt;</span><span class="s4">const </span><span class="s1">BigInt&amp;&gt;(b.data_.pointer))</span><span class="s4">;</span>
    <span class="s4">case </span><span class="s1">StringKind:</span>
      <span class="s4">return </span><span class="s1">runtime.strictEquals(</span>
          <span class="s4">static_cast</span><span class="s1">&lt;</span><span class="s4">const </span><span class="s1">String&amp;&gt;(a.data_.pointer)</span><span class="s4">,</span>
          <span class="s4">static_cast</span><span class="s1">&lt;</span><span class="s4">const </span><span class="s1">String&amp;&gt;(b.data_.pointer))</span><span class="s4">;</span>
    <span class="s4">case </span><span class="s1">ObjectKind:</span>
      <span class="s4">return </span><span class="s1">runtime.strictEquals(</span>
          <span class="s4">static_cast</span><span class="s1">&lt;</span><span class="s4">const </span><span class="s1">Object&amp;&gt;(a.data_.pointer)</span><span class="s4">,</span>
          <span class="s4">static_cast</span><span class="s1">&lt;</span><span class="s4">const </span><span class="s1">Object&amp;&gt;(b.data_.pointer))</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">return false;</span>
<span class="s1">}</span>

<span class="s4">bool </span><span class="s1">Value::asBool() </span><span class="s4">const </span><span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(!isBool()) {</span>
    <span class="s4">throw </span><span class="s1">JSINativeException(</span>
        <span class="s3">&quot;Value is &quot; </span><span class="s1">+ kindToString(*</span><span class="s4">this</span><span class="s1">) + </span><span class="s3">&quot;, expected a boolean&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">return </span><span class="s1">getBool()</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">double </span><span class="s1">Value::asNumber() </span><span class="s4">const </span><span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(!isNumber()) {</span>
    <span class="s4">throw </span><span class="s1">JSINativeException(</span>
        <span class="s3">&quot;Value is &quot; </span><span class="s1">+ kindToString(*</span><span class="s4">this</span><span class="s1">) + </span><span class="s3">&quot;, expected a number&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">return </span><span class="s1">getNumber()</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">Object Value::asObject(Runtime&amp; rt) </span><span class="s4">const</span><span class="s1">&amp; {</span>
  <span class="s4">if </span><span class="s1">(!isObject()) {</span>
    <span class="s4">throw </span><span class="s1">JSError(</span>
        <span class="s1">rt</span><span class="s4">, </span><span class="s3">&quot;Value is &quot; </span><span class="s1">+ kindToString(*</span><span class="s4">this, </span><span class="s1">&amp;rt) + </span><span class="s3">&quot;, expected an Object&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">return </span><span class="s1">getObject(rt)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">Object Value::asObject(Runtime&amp; rt) &amp;&amp; {</span>
  <span class="s4">if </span><span class="s1">(!isObject()) {</span>
    <span class="s4">throw </span><span class="s1">JSError(</span>
        <span class="s1">rt</span><span class="s4">, </span><span class="s3">&quot;Value is &quot; </span><span class="s1">+ kindToString(*</span><span class="s4">this, </span><span class="s1">&amp;rt) + </span><span class="s3">&quot;, expected an Object&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">auto </span><span class="s1">ptr = data_.pointer.ptr_</span><span class="s4">;</span>
  <span class="s1">data_.pointer.ptr_ = </span><span class="s4">nullptr;</span>
  <span class="s4">return static_cast</span><span class="s1">&lt;Object&gt;(ptr)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">Symbol Value::asSymbol(Runtime&amp; rt) </span><span class="s4">const</span><span class="s1">&amp; {</span>
  <span class="s4">if </span><span class="s1">(!isSymbol()) {</span>
    <span class="s4">throw </span><span class="s1">JSError(</span>
        <span class="s1">rt</span><span class="s4">, </span><span class="s3">&quot;Value is &quot; </span><span class="s1">+ kindToString(*</span><span class="s4">this, </span><span class="s1">&amp;rt) + </span><span class="s3">&quot;, expected a Symbol&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">return </span><span class="s1">getSymbol(rt)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">Symbol Value::asSymbol(Runtime&amp; rt) &amp;&amp; {</span>
  <span class="s4">if </span><span class="s1">(!isSymbol()) {</span>
    <span class="s4">throw </span><span class="s1">JSError(</span>
        <span class="s1">rt</span><span class="s4">, </span><span class="s3">&quot;Value is &quot; </span><span class="s1">+ kindToString(*</span><span class="s4">this, </span><span class="s1">&amp;rt) + </span><span class="s3">&quot;, expected a Symbol&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">return </span><span class="s1">std::move(*</span><span class="s4">this</span><span class="s1">).getSymbol(rt)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">BigInt Value::asBigInt(Runtime&amp; rt) </span><span class="s4">const</span><span class="s1">&amp; {</span>
  <span class="s4">if </span><span class="s1">(!isBigInt()) {</span>
    <span class="s4">throw </span><span class="s1">JSError(</span>
        <span class="s1">rt</span><span class="s4">, </span><span class="s3">&quot;Value is &quot; </span><span class="s1">+ kindToString(*</span><span class="s4">this, </span><span class="s1">&amp;rt) + </span><span class="s3">&quot;, expected a BigInt&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">return </span><span class="s1">getBigInt(rt)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">BigInt Value::asBigInt(Runtime&amp; rt) &amp;&amp; {</span>
  <span class="s4">if </span><span class="s1">(!isBigInt()) {</span>
    <span class="s4">throw </span><span class="s1">JSError(</span>
        <span class="s1">rt</span><span class="s4">, </span><span class="s3">&quot;Value is &quot; </span><span class="s1">+ kindToString(*</span><span class="s4">this, </span><span class="s1">&amp;rt) + </span><span class="s3">&quot;, expected a BigInt&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">return </span><span class="s1">std::move(*</span><span class="s4">this</span><span class="s1">).getBigInt(rt)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">String Value::asString(Runtime&amp; rt) </span><span class="s4">const</span><span class="s1">&amp; {</span>
  <span class="s4">if </span><span class="s1">(!isString()) {</span>
    <span class="s4">throw </span><span class="s1">JSError(</span>
        <span class="s1">rt</span><span class="s4">, </span><span class="s3">&quot;Value is &quot; </span><span class="s1">+ kindToString(*</span><span class="s4">this, </span><span class="s1">&amp;rt) + </span><span class="s3">&quot;, expected a String&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">return </span><span class="s1">getString(rt)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">String Value::asString(Runtime&amp; rt) &amp;&amp; {</span>
  <span class="s4">if </span><span class="s1">(!isString()) {</span>
    <span class="s4">throw </span><span class="s1">JSError(</span>
        <span class="s1">rt</span><span class="s4">, </span><span class="s3">&quot;Value is &quot; </span><span class="s1">+ kindToString(*</span><span class="s4">this, </span><span class="s1">&amp;rt) + </span><span class="s3">&quot;, expected a String&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">return </span><span class="s1">std::move(*</span><span class="s4">this</span><span class="s1">).getString(rt)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">String Value::toString(Runtime&amp; runtime) </span><span class="s4">const </span><span class="s1">{</span>
  <span class="s1">Function toString = runtime.global().getPropertyAsFunction(runtime</span><span class="s4">, </span><span class="s3">&quot;String&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s4">return </span><span class="s1">toString.call(runtime</span><span class="s4">, </span><span class="s1">*</span><span class="s4">this</span><span class="s1">).getString(runtime)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">uint64_t BigInt::asUint64(Runtime&amp; runtime) </span><span class="s4">const </span><span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(!isUint64(runtime)) {</span>
    <span class="s4">throw </span><span class="s1">JSError(runtime</span><span class="s4">, </span><span class="s3">&quot;Lossy truncation in BigInt64::asUint64&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">return </span><span class="s1">getUint64(runtime)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">int64_t BigInt::asInt64(Runtime&amp; runtime) </span><span class="s4">const </span><span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(!isInt64(runtime)) {</span>
    <span class="s4">throw </span><span class="s1">JSError(runtime</span><span class="s4">, </span><span class="s3">&quot;Lossy truncation in BigInt64::asInt64&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">return </span><span class="s1">getInt64(runtime)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">Array Array::createWithElements(</span>
    <span class="s1">Runtime&amp; rt</span><span class="s4">,</span>
    <span class="s1">std::initializer_list&lt;Value&gt; elements) {</span>
  <span class="s1">Array result(rt</span><span class="s4">, </span><span class="s1">elements.size())</span><span class="s4">;</span>
  <span class="s1">size_t index = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s4">for </span><span class="s1">(</span><span class="s4">const auto</span><span class="s1">&amp; element : elements) {</span>
    <span class="s1">result.setValueAtIndex(rt</span><span class="s4">, </span><span class="s1">index++</span><span class="s4">, </span><span class="s1">element)</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">return </span><span class="s1">result</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">std::vector&lt;PropNameID&gt; HostObject::getPropertyNames(Runtime&amp;) {</span>
  <span class="s4">return </span><span class="s1">{}</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">Runtime::ScopeState* Runtime::pushScope() {</span>
  <span class="s4">return nullptr;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">Runtime::popScope(ScopeState*) {}</span>

<span class="s1">JSError::JSError(Runtime&amp; rt</span><span class="s4">, </span><span class="s1">Value&amp;&amp; value) {</span>
  <span class="s1">setValue(rt</span><span class="s4">, </span><span class="s1">std::move(value))</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">JSError::JSError(Runtime&amp; rt</span><span class="s4">, </span><span class="s1">std::string msg) : message_(std::move(msg)) {</span>
  <span class="s4">try </span><span class="s1">{</span>
    <span class="s1">setValue(</span>
        <span class="s1">rt</span><span class="s4">,</span>
        <span class="s1">callGlobalFunction(rt</span><span class="s4">, </span><span class="s3">&quot;Error&quot;</span><span class="s4">, </span><span class="s1">String::createFromUtf8(rt</span><span class="s4">, </span><span class="s1">message_)))</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">catch </span><span class="s1">(</span><span class="s4">const </span><span class="s1">JSIException&amp; ex) {</span>
    <span class="s1">message_ = std::string(ex.what()) + </span><span class="s3">&quot; (while raising &quot; </span><span class="s1">+ message_ + </span><span class="s3">&quot;)&quot;</span><span class="s4">;</span>
    <span class="s1">setValue(rt</span><span class="s4">, </span><span class="s1">String::createFromUtf8(rt</span><span class="s4">, </span><span class="s1">message_))</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">JSError::JSError(Runtime&amp; rt</span><span class="s4">, </span><span class="s1">std::string msg</span><span class="s4">, </span><span class="s1">std::string stack)</span>
    <span class="s1">: message_(std::move(msg))</span><span class="s4">, </span><span class="s1">stack_(std::move(stack)) {</span>
  <span class="s4">try </span><span class="s1">{</span>
    <span class="s1">Object e(rt)</span><span class="s4">;</span>
    <span class="s1">e.setProperty(rt</span><span class="s4">, </span><span class="s3">&quot;message&quot;</span><span class="s4">, </span><span class="s1">String::createFromUtf8(rt</span><span class="s4">, </span><span class="s1">message_))</span><span class="s4">;</span>
    <span class="s1">e.setProperty(rt</span><span class="s4">, </span><span class="s3">&quot;stack&quot;</span><span class="s4">, </span><span class="s1">String::createFromUtf8(rt</span><span class="s4">, </span><span class="s1">stack_))</span><span class="s4">;</span>
    <span class="s1">setValue(rt</span><span class="s4">, </span><span class="s1">std::move(e))</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">catch </span><span class="s1">(</span><span class="s4">const </span><span class="s1">JSIException&amp; ex) {</span>
    <span class="s1">setValue(rt</span><span class="s4">, </span><span class="s1">String::createFromUtf8(rt</span><span class="s4">, </span><span class="s1">ex.what()))</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">JSError::JSError(std::string what</span><span class="s4">, </span><span class="s1">Runtime&amp; rt</span><span class="s4">, </span><span class="s1">Value&amp;&amp; value)</span>
    <span class="s1">: JSIException(std::move(what)) {</span>
  <span class="s1">setValue(rt</span><span class="s4">, </span><span class="s1">std::move(value))</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">JSError::setValue(Runtime&amp; rt</span><span class="s4">, </span><span class="s1">Value&amp;&amp; value) {</span>
  <span class="s1">value_ = std::make_shared&lt;Value&gt;(std::move(value))</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">((message_.empty() || stack_.empty()) &amp;&amp; value_-&gt;isObject()) {</span>
    <span class="s4">auto </span><span class="s1">obj = value_-&gt;getObject(rt)</span><span class="s4">;</span>

    <span class="s4">if </span><span class="s1">(message_.empty()) {</span>
      <span class="s4">try </span><span class="s1">{</span>
        <span class="s1">Value message = obj.getProperty(rt</span><span class="s4">, </span><span class="s3">&quot;message&quot;</span><span class="s1">)</span><span class="s4">;</span>
        <span class="s4">if </span><span class="s1">(!message.isUndefined() &amp;&amp; !message.isString()) {</span>
          <span class="s1">message = callGlobalFunction(rt</span><span class="s4">, </span><span class="s3">&quot;String&quot;</span><span class="s4">, </span><span class="s1">message)</span><span class="s4">;</span>
        <span class="s1">}</span>
        <span class="s4">if </span><span class="s1">(message.isString()) {</span>
          <span class="s1">message_ = message.getString(rt).utf8(rt)</span><span class="s4">;</span>
        <span class="s1">} </span><span class="s4">else if </span><span class="s1">(!message.isUndefined()) {</span>
          <span class="s1">message_ = </span><span class="s3">&quot;String(e.message) is a &quot; </span><span class="s1">+ kindToString(message</span><span class="s4">, </span><span class="s1">&amp;rt)</span><span class="s4">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s4">catch </span><span class="s1">(</span><span class="s4">const </span><span class="s1">JSIException&amp; ex) {</span>
        <span class="s1">message_ = std::string(</span><span class="s3">&quot;[Exception while creating message string: &quot;</span><span class="s1">) +</span>
            <span class="s1">ex.what() + </span><span class="s3">&quot;]&quot;</span><span class="s4">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s4">if </span><span class="s1">(stack_.empty()) {</span>
      <span class="s4">try </span><span class="s1">{</span>
        <span class="s1">Value stack = obj.getProperty(rt</span><span class="s4">, </span><span class="s3">&quot;stack&quot;</span><span class="s1">)</span><span class="s4">;</span>
        <span class="s4">if </span><span class="s1">(!stack.isUndefined() &amp;&amp; !stack.isString()) {</span>
          <span class="s1">stack = callGlobalFunction(rt</span><span class="s4">, </span><span class="s3">&quot;String&quot;</span><span class="s4">, </span><span class="s1">stack)</span><span class="s4">;</span>
        <span class="s1">}</span>
        <span class="s4">if </span><span class="s1">(stack.isString()) {</span>
          <span class="s1">stack_ = stack.getString(rt).utf8(rt)</span><span class="s4">;</span>
        <span class="s1">} </span><span class="s4">else if </span><span class="s1">(!stack.isUndefined()) {</span>
          <span class="s1">stack_ = </span><span class="s3">&quot;String(e.stack) is a &quot; </span><span class="s1">+ kindToString(stack</span><span class="s4">, </span><span class="s1">&amp;rt)</span><span class="s4">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s4">catch </span><span class="s1">(</span><span class="s4">const </span><span class="s1">JSIException&amp; ex) {</span>
        <span class="s1">message_ = std::string(</span><span class="s3">&quot;[Exception while creating stack string: &quot;</span><span class="s1">) +</span>
            <span class="s1">ex.what() + </span><span class="s3">&quot;]&quot;</span><span class="s4">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(message_.empty()) {</span>
    <span class="s4">try </span><span class="s1">{</span>
      <span class="s4">if </span><span class="s1">(value_-&gt;isString()) {</span>
        <span class="s1">message_ = value_-&gt;getString(rt).utf8(rt)</span><span class="s4">;</span>
      <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
        <span class="s1">Value message = callGlobalFunction(rt</span><span class="s4">, </span><span class="s3">&quot;String&quot;</span><span class="s4">, </span><span class="s1">*value_)</span><span class="s4">;</span>
        <span class="s4">if </span><span class="s1">(message.isString()) {</span>
          <span class="s1">message_ = message.getString(rt).utf8(rt)</span><span class="s4">;</span>
        <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
          <span class="s1">message_ = </span><span class="s3">&quot;String(e) is a &quot; </span><span class="s1">+ kindToString(message</span><span class="s4">, </span><span class="s1">&amp;rt)</span><span class="s4">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s4">catch </span><span class="s1">(</span><span class="s4">const </span><span class="s1">JSIException&amp; ex) {</span>
      <span class="s1">message_ = std::string(</span><span class="s3">&quot;[Exception while creating message string: &quot;</span><span class="s1">) +</span>
          <span class="s1">ex.what() + </span><span class="s3">&quot;]&quot;</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(stack_.empty()) {</span>
    <span class="s1">stack_ = </span><span class="s3">&quot;no stack&quot;</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(what_.empty()) {</span>
    <span class="s1">what_ = message_ + </span><span class="s3">&quot;</span><span class="s4">\n\n</span><span class="s3">&quot; </span><span class="s1">+ stack_</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">JSIException::~JSIException() {}</span>

<span class="s1">JSINativeException::~JSINativeException() {}</span>

<span class="s1">JSError::~JSError() {}</span>

<span class="s1">} </span><span class="s0">// namespace jsi</span>
<span class="s1">} </span><span class="s0">// namespace facebook</span>
</pre>
</body>
</html>
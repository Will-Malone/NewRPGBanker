<html>
<head>
<title>ReactViewGroup.java</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6897bb;}
.s5 { color: #629755; font-weight: bold; font-style: italic;}
.s6 { color: #77b767; font-style: italic;}
.s7 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
ReactViewGroup.java</font>
</center></td></tr></table>
<pre><span class="s0">/* 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>

<span class="s2">package </span><span class="s1">com.facebook.react.views.view</span><span class="s2">;</span>

<span class="s2">import static </span><span class="s1">com.facebook.react.common.ReactConstants.TAG</span><span class="s2">;</span>

<span class="s2">import </span><span class="s1">android.annotation.SuppressLint</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.annotation.TargetApi</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.content.Context</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.graphics.Canvas</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.graphics.Color</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.graphics.Path</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.graphics.Rect</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.graphics.RectF</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.graphics.drawable.Drawable</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.graphics.drawable.LayerDrawable</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.os.Build</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.view.MotionEvent</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.view.View</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.view.ViewGroup</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.view.ViewStructure</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.view.animation.Animation</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">androidx.annotation.Nullable</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.common.logging.FLog</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.infer.annotation.Assertions</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.ReactContext</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.ReactNoCrashSoftException</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.ReactSoftExceptionLogger</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.UiThreadUtil</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.common.annotations.VisibleForTesting</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.modules.i18nmanager.I18nUtil</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.touch.OnInterceptTouchEventListener</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.touch.ReactHitSlopView</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.touch.ReactInterceptingViewGroup</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.IllegalViewOperationException</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.MeasureSpecAssertions</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.PointerEvents</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.ReactClippingProhibitedView</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.ReactClippingViewGroup</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.ReactClippingViewGroupHelper</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.ReactOverflowViewWithInset</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.ReactPointerEventsView</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.ReactZIndexedViewGroup</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.RootView</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.RootViewUtil</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.ViewGroupDrawingOrderHelper</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.ViewProps</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.common.UIManagerType</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.common.ViewUtil</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.yoga.YogaConstants</span><span class="s2">;</span>

<span class="s3">/**</span>
 <span class="s3">* Backing for a React View. Has support for borders, but since borders aren't common, lazy</span>
 <span class="s3">* initializes most of the storage needed for them.</span>
 <span class="s3">*/</span>
<span class="s1">@TargetApi(Build.VERSION_CODES.LOLLIPOP)</span>
<span class="s2">public class </span><span class="s1">ReactViewGroup </span><span class="s2">extends </span><span class="s1">ViewGroup</span>
    <span class="s2">implements </span><span class="s1">ReactInterceptingViewGroup</span><span class="s2">,</span>
        <span class="s1">ReactClippingViewGroup</span><span class="s2">,</span>
        <span class="s1">ReactPointerEventsView</span><span class="s2">,</span>
        <span class="s1">ReactHitSlopView</span><span class="s2">,</span>
        <span class="s1">ReactZIndexedViewGroup</span><span class="s2">,</span>
        <span class="s1">ReactOverflowViewWithInset {</span>

  <span class="s2">private static final int </span><span class="s1">ARRAY_CAPACITY_INCREMENT = </span><span class="s4">12</span><span class="s2">;</span>
  <span class="s2">private static final int </span><span class="s1">DEFAULT_BACKGROUND_COLOR = Color.TRANSPARENT</span><span class="s2">;</span>
  <span class="s2">private static final </span><span class="s1">LayoutParams sDefaultLayoutParam = </span><span class="s2">new </span><span class="s1">ViewGroup.LayoutParams(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">private final </span><span class="s1">Rect mOverflowInset = </span><span class="s2">new </span><span class="s1">Rect()</span><span class="s2">;</span>
  <span class="s0">/* should only be used in {@link #updateClippingToRect} */</span>
  <span class="s2">private static final </span><span class="s1">Rect sHelperRect = </span><span class="s2">new </span><span class="s1">Rect()</span><span class="s2">;</span>

  <span class="s3">/**</span>
   <span class="s3">* This listener will be set for child views when removeClippedSubview property is enabled. When</span>
   <span class="s3">* children layout is updated, it will call {</span><span class="s5">@link </span><span class="s3">#updateSubviewClipStatus} to notify parent view</span>
   <span class="s3">* about that fact so that view can be attached/detached if necessary.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s6">&lt;p&gt;</span><span class="s3">TODO(7728005): Attach/detach views in batch - once per frame in case when multiple children</span>
   <span class="s3">* update their layout.</span>
   <span class="s3">*/</span>
  <span class="s2">private static final class </span><span class="s1">ChildrenLayoutChangeListener </span><span class="s2">implements </span><span class="s1">View.OnLayoutChangeListener {</span>

    <span class="s2">private final </span><span class="s1">ReactViewGroup mParent</span><span class="s2">;</span>

    <span class="s2">private </span><span class="s1">ChildrenLayoutChangeListener(ReactViewGroup parent) {</span>
      <span class="s1">mParent = parent</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">@Override</span>
    <span class="s2">public void </span><span class="s1">onLayoutChange(</span>
        <span class="s1">View v</span><span class="s2">,</span>
        <span class="s2">int </span><span class="s1">left</span><span class="s2">,</span>
        <span class="s2">int </span><span class="s1">top</span><span class="s2">,</span>
        <span class="s2">int </span><span class="s1">right</span><span class="s2">,</span>
        <span class="s2">int </span><span class="s1">bottom</span><span class="s2">,</span>
        <span class="s2">int </span><span class="s1">oldLeft</span><span class="s2">,</span>
        <span class="s2">int </span><span class="s1">oldTop</span><span class="s2">,</span>
        <span class="s2">int </span><span class="s1">oldRight</span><span class="s2">,</span>
        <span class="s2">int </span><span class="s1">oldBottom) {</span>
      <span class="s2">if </span><span class="s1">(mParent.getRemoveClippedSubviews()) {</span>
        <span class="s1">mParent.updateSubviewClipStatus(v)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">// Following properties are here to support the option {@code removeClippedSubviews}. This is a</span>
  <span class="s0">// temporary optimization/hack that is mainly applicable to the large list of images. The way</span>
  <span class="s0">// it's implemented is that we store an additional array of children in view node. We selectively</span>
  <span class="s0">// remove some of the views (detach) from it while still storing them in that additional array.</span>
  <span class="s0">// We override all possible add methods for {@link ViewGroup} so that we can control this process</span>
  <span class="s0">// whenever the option is set. We also override {@link ViewGroup#getChildAt} and</span>
  <span class="s0">// {@link ViewGroup#getChildCount} so those methods may return views that are not attached.</span>
  <span class="s0">// This is risky but allows us to perform a correct cleanup in {@link NativeViewHierarchyManager}.</span>
  <span class="s2">private boolean </span><span class="s1">mRemoveClippedSubviews</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable View[] mAllChildren</span><span class="s2">;</span>
  <span class="s2">private int </span><span class="s1">mAllChildrenCount</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable Rect mClippingRect</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable Rect mHitSlopRect</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable String mOverflow</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">PointerEvents mPointerEvents</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable ChildrenLayoutChangeListener mChildrenLayoutChangeListener</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable ReactViewBackgroundDrawable mReactBackgroundDrawable</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable OnInterceptTouchEventListener mOnInterceptTouchEventListener</span><span class="s2">;</span>
  <span class="s2">private boolean </span><span class="s1">mNeedsOffscreenAlphaCompositing</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable ViewGroupDrawingOrderHelper mDrawingOrderHelper</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable Path mPath</span><span class="s2">;</span>
  <span class="s2">private int </span><span class="s1">mLayoutDirection</span><span class="s2">;</span>
  <span class="s2">private float </span><span class="s1">mBackfaceOpacity</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">String mBackfaceVisibility</span><span class="s2">;</span>

  <span class="s2">public </span><span class="s1">ReactViewGroup(Context context) {</span>
    <span class="s2">super</span><span class="s1">(context)</span><span class="s2">;</span>
    <span class="s1">initView()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Set all default values here as opposed to in the constructor or field defaults. It is important</span>
   <span class="s3">* that these properties are set during the constructor, but also on-demand whenever an existing</span>
   <span class="s3">* ReactTextView is recycled.</span>
   <span class="s3">*/</span>
  <span class="s2">private void </span><span class="s1">initView() {</span>
    <span class="s1">setClipChildren(</span><span class="s2">false</span><span class="s1">)</span><span class="s2">;</span>

    <span class="s1">mRemoveClippedSubviews = </span><span class="s2">false;</span>
    <span class="s1">mAllChildren = </span><span class="s2">null;</span>
    <span class="s1">mAllChildrenCount = </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s1">mClippingRect = </span><span class="s2">null;</span>
    <span class="s1">mHitSlopRect = </span><span class="s2">null;</span>
    <span class="s1">mOverflow = </span><span class="s2">null;</span>
    <span class="s1">mPointerEvents = PointerEvents.AUTO</span><span class="s2">;</span>
    <span class="s1">mChildrenLayoutChangeListener = </span><span class="s2">null;</span>
    <span class="s1">mReactBackgroundDrawable = </span><span class="s2">null;</span>
    <span class="s1">mOnInterceptTouchEventListener = </span><span class="s2">null;</span>
    <span class="s1">mNeedsOffscreenAlphaCompositing = </span><span class="s2">false;</span>
    <span class="s1">mDrawingOrderHelper = </span><span class="s2">null;</span>
    <span class="s1">mPath = </span><span class="s2">null;</span>
    <span class="s1">mLayoutDirection = </span><span class="s4">0</span><span class="s2">; </span><span class="s0">// set when background is created</span>
    <span class="s1">mBackfaceOpacity = </span><span class="s4">1.f</span><span class="s2">;</span>
    <span class="s1">mBackfaceVisibility = </span><span class="s7">&quot;visible&quot;</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">/* package */ </span><span class="s2">void </span><span class="s1">recycleView() {</span>
    <span class="s0">// Set default field values</span>
    <span class="s1">initView()</span><span class="s2">;</span>
    <span class="s1">mOverflowInset.setEmpty()</span><span class="s2">;</span>
    <span class="s1">sHelperRect.setEmpty()</span><span class="s2">;</span>

    <span class="s0">// Remove any children</span>
    <span class="s1">removeAllViews()</span><span class="s2">;</span>

    <span class="s0">// Reset background, borders</span>
    <span class="s1">updateBackgroundDrawable(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>

    <span class="s1">resetPointerEvents()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private </span><span class="s1">ViewGroupDrawingOrderHelper getDrawingOrderHelper() {</span>
    <span class="s2">if </span><span class="s1">(mDrawingOrderHelper == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mDrawingOrderHelper = </span><span class="s2">new </span><span class="s1">ViewGroupDrawingOrderHelper(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">mDrawingOrderHelper</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">protected void </span><span class="s1">onMeasure(</span><span class="s2">int </span><span class="s1">widthMeasureSpec</span><span class="s2">, int </span><span class="s1">heightMeasureSpec) {</span>
    <span class="s1">MeasureSpecAssertions.assertExplicitMeasureSpec(widthMeasureSpec</span><span class="s2">, </span><span class="s1">heightMeasureSpec)</span><span class="s2">;</span>

    <span class="s1">setMeasuredDimension(</span>
        <span class="s1">MeasureSpec.getSize(widthMeasureSpec)</span><span class="s2">, </span><span class="s1">MeasureSpec.getSize(heightMeasureSpec))</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">protected void </span><span class="s1">onLayout(</span><span class="s2">boolean </span><span class="s1">changed</span><span class="s2">, int </span><span class="s1">left</span><span class="s2">, int </span><span class="s1">top</span><span class="s2">, int </span><span class="s1">right</span><span class="s2">, int </span><span class="s1">bottom) {</span>
    <span class="s0">// No-op since UIManagerModule handles actually laying out children.</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">onRtlPropertiesChanged(</span><span class="s2">int </span><span class="s1">layoutDirection) {</span>
    <span class="s2">if </span><span class="s1">(mReactBackgroundDrawable != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mReactBackgroundDrawable.setResolvedLayoutDirection(mLayoutDirection)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s1">@SuppressLint(</span><span class="s7">&quot;MissingSuperCall&quot;</span><span class="s1">)</span>
  <span class="s2">public void </span><span class="s1">requestLayout() {</span>
    <span class="s0">// No-op, terminate `requestLayout` here, UIManagerModule handles laying out children and</span>
    <span class="s0">// `layout` is called on all RN-managed views by `NativeViewHierarchyManager`</span>
  <span class="s1">}</span>

  <span class="s1">@TargetApi(</span><span class="s4">23</span><span class="s1">)</span>
  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">dispatchProvideStructure(ViewStructure structure) {</span>
    <span class="s2">try </span><span class="s1">{</span>
      <span class="s2">super</span><span class="s1">.dispatchProvideStructure(structure)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(NullPointerException e) {</span>
      <span class="s1">FLog.e(TAG</span><span class="s2">, </span><span class="s7">&quot;NullPointerException when executing dispatchProvideStructure&quot;</span><span class="s2">, </span><span class="s1">e)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setBackgroundColor(</span><span class="s2">int </span><span class="s1">color) {</span>
    <span class="s2">if </span><span class="s1">(color == Color.TRANSPARENT &amp;&amp; mReactBackgroundDrawable == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s0">// don't do anything, no need to allocate ReactBackgroundDrawable for transparent background</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">getOrCreateReactViewBackground().setColor(color)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setBackground(Drawable drawable) {</span>
    <span class="s2">throw new </span><span class="s1">UnsupportedOperationException(</span>
        <span class="s7">&quot;This method is not supported for ReactViewGroup instances&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setTranslucentBackgroundDrawable(@Nullable Drawable background) {</span>
    <span class="s0">// it's required to call setBackground to null, as in some of the cases we may set new</span>
    <span class="s0">// background to be a layer drawable that contains a drawable that has been setup</span>
    <span class="s0">// as a background previously. This will not work correctly as the drawable callback logic is</span>
    <span class="s0">// messed up in AOSP</span>
    <span class="s1">updateBackgroundDrawable(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(mReactBackgroundDrawable != </span><span class="s2">null </span><span class="s1">&amp;&amp; background != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">LayerDrawable layerDrawable =</span>
          <span class="s2">new </span><span class="s1">LayerDrawable(</span><span class="s2">new </span><span class="s1">Drawable[] {mReactBackgroundDrawable</span><span class="s2">, </span><span class="s1">background})</span><span class="s2">;</span>
      <span class="s1">updateBackgroundDrawable(layerDrawable)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(background != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">updateBackgroundDrawable(background)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setOnInterceptTouchEventListener(OnInterceptTouchEventListener listener) {</span>
    <span class="s1">mOnInterceptTouchEventListener = listener</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public boolean </span><span class="s1">onInterceptTouchEvent(MotionEvent ev) {</span>
    <span class="s2">if </span><span class="s1">(mOnInterceptTouchEventListener != </span><span class="s2">null</span>
        <span class="s1">&amp;&amp; mOnInterceptTouchEventListener.onInterceptTouchEvent(</span><span class="s2">this, </span><span class="s1">ev)) {</span>
      <span class="s2">return true;</span>
    <span class="s1">}</span>
    <span class="s0">// We intercept the touch event if the children are not supposed to receive it.</span>
    <span class="s2">if </span><span class="s1">(!PointerEvents.canChildrenBeTouchTarget(mPointerEvents)) {</span>
      <span class="s2">return true;</span>
    <span class="s1">}</span>
    <span class="s2">return super</span><span class="s1">.onInterceptTouchEvent(ev)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public boolean </span><span class="s1">onTouchEvent(MotionEvent ev) {</span>
    <span class="s0">// We do not accept the touch event if this view is not supposed to receive it.</span>
    <span class="s2">if </span><span class="s1">(!PointerEvents.canBeTouchTarget(mPointerEvents)) {</span>
      <span class="s2">return false;</span>
    <span class="s1">}</span>
    <span class="s0">// The root view always assumes any view that was tapped wants the touch</span>
    <span class="s0">// and sends the event to JS as such.</span>
    <span class="s0">// We don't need to do bubbling in native (it's already happening in JS).</span>
    <span class="s0">// For an explanation of bubbling and capturing, see</span>
    <span class="s0">// http://javascript.info/tutorial/bubbling-and-capturing#capturing</span>
    <span class="s2">return true;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public boolean </span><span class="s1">dispatchGenericPointerEvent(MotionEvent ev) {</span>
    <span class="s0">// We do not dispatch the pointer event if its children are not supposed to receive it</span>
    <span class="s2">if </span><span class="s1">(!PointerEvents.canChildrenBeTouchTarget(mPointerEvents)) {</span>
      <span class="s2">return false;</span>
    <span class="s1">}</span>

    <span class="s2">return super</span><span class="s1">.dispatchGenericPointerEvent(ev)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* We override this to allow developers to determine whether they need offscreen alpha compositing</span>
   <span class="s3">* or not. See the documentation of needsOffscreenAlphaCompositing in View.js.</span>
   <span class="s3">*/</span>
  <span class="s1">@Override</span>
  <span class="s2">public boolean </span><span class="s1">hasOverlappingRendering() {</span>
    <span class="s2">return </span><span class="s1">mNeedsOffscreenAlphaCompositing</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/** See the documentation of needsOffscreenAlphaCompositing in View.js. */</span>
  <span class="s2">public void </span><span class="s1">setNeedsOffscreenAlphaCompositing(</span><span class="s2">boolean </span><span class="s1">needsOffscreenAlphaCompositing) {</span>
    <span class="s1">mNeedsOffscreenAlphaCompositing = needsOffscreenAlphaCompositing</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setBorderWidth(</span><span class="s2">int </span><span class="s1">position</span><span class="s2">, float </span><span class="s1">width) {</span>
    <span class="s1">getOrCreateReactViewBackground().setBorderWidth(position</span><span class="s2">, </span><span class="s1">width)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setBorderColor(</span><span class="s2">int </span><span class="s1">position</span><span class="s2">, float </span><span class="s1">rgb</span><span class="s2">, float </span><span class="s1">alpha) {</span>
    <span class="s1">getOrCreateReactViewBackground().setBorderColor(position</span><span class="s2">, </span><span class="s1">rgb</span><span class="s2">, </span><span class="s1">alpha)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setBorderRadius(</span><span class="s2">float </span><span class="s1">borderRadius) {</span>
    <span class="s1">ReactViewBackgroundDrawable backgroundDrawable = getOrCreateReactViewBackground()</span><span class="s2">;</span>
    <span class="s1">backgroundDrawable.setRadius(borderRadius)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setBorderRadius(</span><span class="s2">float </span><span class="s1">borderRadius</span><span class="s2">, int </span><span class="s1">position) {</span>
    <span class="s1">ReactViewBackgroundDrawable backgroundDrawable = getOrCreateReactViewBackground()</span><span class="s2">;</span>
    <span class="s1">backgroundDrawable.setRadius(borderRadius</span><span class="s2">, </span><span class="s1">position)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setBorderStyle(@Nullable String style) {</span>
    <span class="s1">getOrCreateReactViewBackground().setBorderStyle(style)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setRemoveClippedSubviews(</span><span class="s2">boolean </span><span class="s1">removeClippedSubviews) {</span>
    <span class="s2">if </span><span class="s1">(removeClippedSubviews == mRemoveClippedSubviews) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s1">mRemoveClippedSubviews = removeClippedSubviews</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(removeClippedSubviews) {</span>
      <span class="s1">mClippingRect = </span><span class="s2">new </span><span class="s1">Rect()</span><span class="s2">;</span>
      <span class="s1">ReactClippingViewGroupHelper.calculateClippingRect(</span><span class="s2">this, </span><span class="s1">mClippingRect)</span><span class="s2">;</span>
      <span class="s1">mAllChildrenCount = getChildCount()</span><span class="s2">;</span>
      <span class="s2">int </span><span class="s1">initialSize = Math.max(</span><span class="s4">12</span><span class="s2">, </span><span class="s1">mAllChildrenCount)</span><span class="s2">;</span>
      <span class="s1">mAllChildren = </span><span class="s2">new </span><span class="s1">View[initialSize]</span><span class="s2">;</span>
      <span class="s1">mChildrenLayoutChangeListener = </span><span class="s2">new </span><span class="s1">ChildrenLayoutChangeListener(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; mAllChildrenCount</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s1">View child = getChildAt(i)</span><span class="s2">;</span>
        <span class="s1">mAllChildren[i] = child</span><span class="s2">;</span>
        <span class="s1">child.addOnLayoutChangeListener(mChildrenLayoutChangeListener)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s1">updateClippingRect()</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s0">// Add all clipped views back, deallocate additional arrays, remove layoutChangeListener</span>
      <span class="s1">Assertions.assertNotNull(mClippingRect)</span><span class="s2">;</span>
      <span class="s1">Assertions.assertNotNull(mAllChildren)</span><span class="s2">;</span>
      <span class="s1">Assertions.assertNotNull(mChildrenLayoutChangeListener)</span><span class="s2">;</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; mAllChildrenCount</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s1">mAllChildren[i].removeOnLayoutChangeListener(mChildrenLayoutChangeListener)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s1">getDrawingRect(mClippingRect)</span><span class="s2">;</span>
      <span class="s1">updateClippingToRect(mClippingRect)</span><span class="s2">;</span>
      <span class="s1">mAllChildren = </span><span class="s2">null;</span>
      <span class="s1">mClippingRect = </span><span class="s2">null;</span>
      <span class="s1">mAllChildrenCount = </span><span class="s4">0</span><span class="s2">;</span>
      <span class="s1">mChildrenLayoutChangeListener = </span><span class="s2">null;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public boolean </span><span class="s1">getRemoveClippedSubviews() {</span>
    <span class="s2">return </span><span class="s1">mRemoveClippedSubviews</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">getClippingRect(Rect outClippingRect) {</span>
    <span class="s1">outClippingRect.set(mClippingRect)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">updateClippingRect() {</span>
    <span class="s2">if </span><span class="s1">(!mRemoveClippedSubviews) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s1">Assertions.assertNotNull(mClippingRect)</span><span class="s2">;</span>
    <span class="s1">Assertions.assertNotNull(mAllChildren)</span><span class="s2">;</span>

    <span class="s1">ReactClippingViewGroupHelper.calculateClippingRect(</span><span class="s2">this, </span><span class="s1">mClippingRect)</span><span class="s2">;</span>
    <span class="s1">updateClippingToRect(mClippingRect)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private void </span><span class="s1">updateClippingToRect(Rect clippingRect) {</span>
    <span class="s1">Assertions.assertNotNull(mAllChildren)</span><span class="s2">;</span>
    <span class="s2">int </span><span class="s1">clippedSoFar = </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; mAllChildrenCount</span><span class="s2">; </span><span class="s1">i++) {</span>
      <span class="s1">updateSubviewClipStatus(clippingRect</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">clippedSoFar)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(mAllChildren[i].getParent() == </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">clippedSoFar++</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">private void </span><span class="s1">updateSubviewClipStatus(Rect clippingRect</span><span class="s2">, int </span><span class="s1">idx</span><span class="s2">, int </span><span class="s1">clippedSoFar) {</span>
    <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>

    <span class="s1">View child = Assertions.assertNotNull(mAllChildren)[idx]</span><span class="s2">;</span>
    <span class="s1">sHelperRect.set(child.getLeft()</span><span class="s2">, </span><span class="s1">child.getTop()</span><span class="s2">, </span><span class="s1">child.getRight()</span><span class="s2">, </span><span class="s1">child.getBottom())</span><span class="s2">;</span>
    <span class="s2">boolean </span><span class="s1">intersects =</span>
        <span class="s1">clippingRect.intersects(</span>
            <span class="s1">sHelperRect.left</span><span class="s2">, </span><span class="s1">sHelperRect.top</span><span class="s2">, </span><span class="s1">sHelperRect.right</span><span class="s2">, </span><span class="s1">sHelperRect.bottom)</span><span class="s2">;</span>
    <span class="s2">boolean </span><span class="s1">needUpdateClippingRecursive = </span><span class="s2">false;</span>
    <span class="s0">// We never want to clip children that are being animated, as this can easily break layout :</span>
    <span class="s0">// when layout animation changes size and/or position of views contained inside a listview that</span>
    <span class="s0">// clips offscreen children, we need to ensure that, when view exits the viewport, final size</span>
    <span class="s0">// and position is set prior to removing the view from its listview parent.</span>
    <span class="s0">// Otherwise, when view gets re-attached again, i.e when it re-enters the viewport after scroll,</span>
    <span class="s0">// it won't be size and located properly.</span>
    <span class="s1">Animation animation = child.getAnimation()</span><span class="s2">;</span>
    <span class="s2">boolean </span><span class="s1">isAnimating = animation != </span><span class="s2">null </span><span class="s1">&amp;&amp; !animation.hasEnded()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!intersects &amp;&amp; child.getParent() != </span><span class="s2">null </span><span class="s1">&amp;&amp; !isAnimating) {</span>
      <span class="s0">// We can try saving on invalidate call here as the view that we remove is out of visible area</span>
      <span class="s0">// therefore invalidation is not necessary.</span>
      <span class="s2">super</span><span class="s1">.removeViewsInLayout(idx - clippedSoFar</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">needUpdateClippingRecursive = </span><span class="s2">true;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(intersects &amp;&amp; child.getParent() == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">super</span><span class="s1">.addViewInLayout(child</span><span class="s2">, </span><span class="s1">idx - clippedSoFar</span><span class="s2">, </span><span class="s1">sDefaultLayoutParam</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">invalidate()</span><span class="s2">;</span>
      <span class="s1">needUpdateClippingRecursive = </span><span class="s2">true;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(intersects) {</span>
      <span class="s0">// If there is any intersection we need to inform the child to update its clipping rect</span>
      <span class="s1">needUpdateClippingRecursive = </span><span class="s2">true;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(needUpdateClippingRecursive) {</span>
      <span class="s2">if </span><span class="s1">(child </span><span class="s2">instanceof </span><span class="s1">ReactClippingViewGroup) {</span>
        <span class="s0">// we don't use {@link sHelperRect} until the end of this loop, therefore it's safe</span>
        <span class="s0">// to call this method that may write to the same {@link sHelperRect} object.</span>
        <span class="s1">ReactClippingViewGroup clippingChild = (ReactClippingViewGroup) child</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(clippingChild.getRemoveClippedSubviews()) {</span>
          <span class="s1">clippingChild.updateClippingRect()</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">private void </span><span class="s1">updateSubviewClipStatus(View subview) {</span>
    <span class="s2">if </span><span class="s1">(!mRemoveClippedSubviews || getParent() == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s1">Assertions.assertNotNull(mClippingRect)</span><span class="s2">;</span>
    <span class="s1">Assertions.assertNotNull(mAllChildren)</span><span class="s2">;</span>

    <span class="s0">// do fast check whether intersect state changed</span>
    <span class="s1">sHelperRect.set(subview.getLeft()</span><span class="s2">, </span><span class="s1">subview.getTop()</span><span class="s2">, </span><span class="s1">subview.getRight()</span><span class="s2">, </span><span class="s1">subview.getBottom())</span><span class="s2">;</span>
    <span class="s2">boolean </span><span class="s1">intersects =</span>
        <span class="s1">mClippingRect.intersects(</span>
            <span class="s1">sHelperRect.left</span><span class="s2">, </span><span class="s1">sHelperRect.top</span><span class="s2">, </span><span class="s1">sHelperRect.right</span><span class="s2">, </span><span class="s1">sHelperRect.bottom)</span><span class="s2">;</span>

    <span class="s0">// If it was intersecting before, should be attached to the parent</span>
    <span class="s2">boolean </span><span class="s1">oldIntersects = (subview.getParent() != </span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(intersects != oldIntersects) {</span>
      <span class="s2">int </span><span class="s1">clippedSoFar = </span><span class="s4">0</span><span class="s2">;</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; mAllChildrenCount</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s2">if </span><span class="s1">(mAllChildren[i] == subview) {</span>
          <span class="s1">updateSubviewClipStatus(mClippingRect</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">clippedSoFar)</span><span class="s2">;</span>
          <span class="s2">break;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(mAllChildren[i].getParent() == </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">clippedSoFar++</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public boolean </span><span class="s1">getChildVisibleRect(View child</span><span class="s2">, </span><span class="s1">Rect r</span><span class="s2">, </span><span class="s1">android.graphics.Point offset) {</span>
    <span class="s2">return super</span><span class="s1">.getChildVisibleRect(child</span><span class="s2">, </span><span class="s1">r</span><span class="s2">, </span><span class="s1">offset)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">protected void </span><span class="s1">onSizeChanged(</span><span class="s2">int </span><span class="s1">w</span><span class="s2">, int </span><span class="s1">h</span><span class="s2">, int </span><span class="s1">oldw</span><span class="s2">, int </span><span class="s1">oldh) {</span>
    <span class="s2">super</span><span class="s1">.onSizeChanged(w</span><span class="s2">, </span><span class="s1">h</span><span class="s2">, </span><span class="s1">oldw</span><span class="s2">, </span><span class="s1">oldh)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(mRemoveClippedSubviews) {</span>
      <span class="s1">updateClippingRect()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">protected void </span><span class="s1">onAttachedToWindow() {</span>
    <span class="s2">super</span><span class="s1">.onAttachedToWindow()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(mRemoveClippedSubviews) {</span>
      <span class="s1">updateClippingRect()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">private boolean </span><span class="s1">customDrawOrderDisabled() {</span>
    <span class="s2">if </span><span class="s1">(getId() == NO_ID) {</span>
      <span class="s2">return false;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">ViewUtil.getUIManagerType(getId()) == UIManagerType.FABRIC</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">addView(View child</span><span class="s2">, int </span><span class="s1">index</span><span class="s2">, </span><span class="s1">ViewGroup.LayoutParams params) {</span>
    <span class="s0">// This will get called for every overload of addView so there is not need to override every</span>
    <span class="s0">// method.</span>

    <span class="s2">if </span><span class="s1">(!customDrawOrderDisabled()) {</span>
      <span class="s1">getDrawingOrderHelper().handleAddView(child)</span><span class="s2">;</span>
      <span class="s1">setChildrenDrawingOrderEnabled(getDrawingOrderHelper().shouldEnableCustomDrawingOrder())</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">setChildrenDrawingOrderEnabled(</span><span class="s2">false</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">super</span><span class="s1">.addView(child</span><span class="s2">, </span><span class="s1">index</span><span class="s2">, </span><span class="s1">params)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">removeView(View view) {</span>
    <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(!customDrawOrderDisabled()) {</span>
      <span class="s1">getDrawingOrderHelper().handleRemoveView(view)</span><span class="s2">;</span>
      <span class="s1">setChildrenDrawingOrderEnabled(getDrawingOrderHelper().shouldEnableCustomDrawingOrder())</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">setChildrenDrawingOrderEnabled(</span><span class="s2">false</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">super</span><span class="s1">.removeView(view)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">removeViewAt(</span><span class="s2">int </span><span class="s1">index) {</span>
    <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(!customDrawOrderDisabled()) {</span>
      <span class="s1">getDrawingOrderHelper().handleRemoveView(getChildAt(index))</span><span class="s2">;</span>
      <span class="s1">setChildrenDrawingOrderEnabled(getDrawingOrderHelper().shouldEnableCustomDrawingOrder())</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">setChildrenDrawingOrderEnabled(</span><span class="s2">false</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">super</span><span class="s1">.removeViewAt(index)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">protected int </span><span class="s1">getChildDrawingOrder(</span><span class="s2">int </span><span class="s1">childCount</span><span class="s2">, int </span><span class="s1">index) {</span>
    <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(!customDrawOrderDisabled()) {</span>
      <span class="s2">return </span><span class="s1">getDrawingOrderHelper().getChildDrawingOrder(childCount</span><span class="s2">, </span><span class="s1">index)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">return </span><span class="s1">index</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public int </span><span class="s1">getZIndexMappedChildIndex(</span><span class="s2">int </span><span class="s1">index) {</span>
    <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(!customDrawOrderDisabled() &amp;&amp; getDrawingOrderHelper().shouldEnableCustomDrawingOrder()) {</span>
      <span class="s2">return </span><span class="s1">getDrawingOrderHelper().getChildDrawingOrder(getChildCount()</span><span class="s2">, </span><span class="s1">index)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s0">// Fabric behavior</span>
    <span class="s2">return </span><span class="s1">index</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">updateDrawingOrder() {</span>
    <span class="s2">if </span><span class="s1">(customDrawOrderDisabled()) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s1">getDrawingOrderHelper().update()</span><span class="s2">;</span>
    <span class="s1">setChildrenDrawingOrderEnabled(getDrawingOrderHelper().shouldEnableCustomDrawingOrder())</span><span class="s2">;</span>
    <span class="s1">invalidate()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public </span><span class="s1">PointerEvents getPointerEvents() {</span>
    <span class="s2">return </span><span class="s1">mPointerEvents</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">protected void </span><span class="s1">dispatchSetPressed(</span><span class="s2">boolean </span><span class="s1">pressed) {</span>
    <span class="s0">// Prevents the ViewGroup from dispatching the pressed state</span>
    <span class="s0">// to it's children.</span>
  <span class="s1">}</span>

  <span class="s0">/*package*/ </span><span class="s2">void </span><span class="s1">setPointerEvents(PointerEvents pointerEvents) {</span>
    <span class="s1">mPointerEvents = pointerEvents</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">/*package*/ </span><span class="s2">void </span><span class="s1">resetPointerEvents() {</span>
    <span class="s1">mPointerEvents = PointerEvents.AUTO</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">/*package*/ </span><span class="s2">int </span><span class="s1">getAllChildrenCount() {</span>
    <span class="s2">return </span><span class="s1">mAllChildrenCount</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">/*package*/ </span><span class="s1">View getChildAtWithSubviewClippingEnabled(</span><span class="s2">int </span><span class="s1">index) {</span>
    <span class="s2">return </span><span class="s1">Assertions.assertNotNull(mAllChildren)[index]</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">/*package*/ </span><span class="s2">void </span><span class="s1">addViewWithSubviewClippingEnabled(View child</span><span class="s2">, int </span><span class="s1">index) {</span>
    <span class="s1">addViewWithSubviewClippingEnabled(child</span><span class="s2">, </span><span class="s1">index</span><span class="s2">, </span><span class="s1">sDefaultLayoutParam)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">/*package*/ </span><span class="s2">void </span><span class="s1">addViewWithSubviewClippingEnabled(</span>
      <span class="s2">final </span><span class="s1">View child</span><span class="s2">, int </span><span class="s1">index</span><span class="s2">, </span><span class="s1">ViewGroup.LayoutParams params) {</span>
    <span class="s1">Assertions.assertCondition(mRemoveClippedSubviews)</span><span class="s2">;</span>
    <span class="s1">Assertions.assertNotNull(mClippingRect)</span><span class="s2">;</span>
    <span class="s1">Assertions.assertNotNull(mAllChildren)</span><span class="s2">;</span>
    <span class="s1">addInArray(child</span><span class="s2">, </span><span class="s1">index)</span><span class="s2">;</span>
    <span class="s0">// we add view as &quot;clipped&quot; and then run {@link #updateSubviewClipStatus} to conditionally</span>
    <span class="s0">// attach it</span>
    <span class="s2">int </span><span class="s1">clippedSoFar = </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; index</span><span class="s2">; </span><span class="s1">i++) {</span>
      <span class="s2">if </span><span class="s1">(mAllChildren[i].getParent() == </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">clippedSoFar++</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">updateSubviewClipStatus(mClippingRect</span><span class="s2">, </span><span class="s1">index</span><span class="s2">, </span><span class="s1">clippedSoFar)</span><span class="s2">;</span>
    <span class="s1">child.addOnLayoutChangeListener(mChildrenLayoutChangeListener)</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(child </span><span class="s2">instanceof </span><span class="s1">ReactClippingProhibitedView) {</span>
      <span class="s1">UiThreadUtil.runOnUiThread(</span>
          <span class="s2">new </span><span class="s1">Runnable() {</span>
            <span class="s1">@Override</span>
            <span class="s2">public void </span><span class="s1">run() {</span>
              <span class="s2">if </span><span class="s1">(!child.isShown()) {</span>
                <span class="s1">ReactSoftExceptionLogger.logSoftException(</span>
                    <span class="s1">TAG</span><span class="s2">,</span>
                    <span class="s2">new </span><span class="s1">ReactNoCrashSoftException(</span>
                        <span class="s7">&quot;Child view has been added to Parent view in which it is clipped and not visible.&quot;</span>
                            <span class="s1">+ </span><span class="s7">&quot; This is not legal for this particular child view. Child: [&quot;</span>
                            <span class="s1">+ child.getId()</span>
                            <span class="s1">+ </span><span class="s7">&quot;] &quot;</span>
                            <span class="s1">+ child.toString()</span>
                            <span class="s1">+ </span><span class="s7">&quot; Parent: [&quot;</span>
                            <span class="s1">+ getId()</span>
                            <span class="s1">+ </span><span class="s7">&quot;] &quot;</span>
                            <span class="s1">+ toString()))</span><span class="s2">;</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">/*package*/ </span><span class="s2">void </span><span class="s1">removeViewWithSubviewClippingEnabled(View view) {</span>
    <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>

    <span class="s1">Assertions.assertCondition(mRemoveClippedSubviews)</span><span class="s2">;</span>
    <span class="s1">Assertions.assertNotNull(mClippingRect)</span><span class="s2">;</span>
    <span class="s1">Assertions.assertNotNull(mAllChildren)</span><span class="s2">;</span>
    <span class="s1">view.removeOnLayoutChangeListener(mChildrenLayoutChangeListener)</span><span class="s2">;</span>
    <span class="s2">int </span><span class="s1">index = indexOfChildInAllChildren(view)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(mAllChildren[index].getParent() != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">int </span><span class="s1">clippedSoFar = </span><span class="s4">0</span><span class="s2">;</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; index</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s2">if </span><span class="s1">(mAllChildren[i].getParent() == </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">clippedSoFar++</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">super</span><span class="s1">.removeViewsInLayout(index - clippedSoFar</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">removeFromArray(index)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">/*package*/ </span><span class="s2">void </span><span class="s1">removeAllViewsWithSubviewClippingEnabled() {</span>
    <span class="s1">Assertions.assertCondition(mRemoveClippedSubviews)</span><span class="s2">;</span>
    <span class="s1">Assertions.assertNotNull(mAllChildren)</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; mAllChildrenCount</span><span class="s2">; </span><span class="s1">i++) {</span>
      <span class="s1">mAllChildren[i].removeOnLayoutChangeListener(mChildrenLayoutChangeListener)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">removeAllViewsInLayout()</span><span class="s2">;</span>
    <span class="s1">mAllChildrenCount = </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private int </span><span class="s1">indexOfChildInAllChildren(View child) {</span>
    <span class="s2">final int </span><span class="s1">count = mAllChildrenCount</span><span class="s2">;</span>
    <span class="s2">final </span><span class="s1">View[] children = Assertions.assertNotNull(mAllChildren)</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; count</span><span class="s2">; </span><span class="s1">i++) {</span>
      <span class="s2">if </span><span class="s1">(children[i] == child) {</span>
        <span class="s2">return </span><span class="s1">i</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">-</span><span class="s4">1</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private void </span><span class="s1">addInArray(View child</span><span class="s2">, int </span><span class="s1">index) {</span>
    <span class="s1">View[] children = Assertions.assertNotNull(mAllChildren)</span><span class="s2">;</span>
    <span class="s2">final int </span><span class="s1">count = mAllChildrenCount</span><span class="s2">;</span>
    <span class="s2">final int </span><span class="s1">size = children.length</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(index == count) {</span>
      <span class="s2">if </span><span class="s1">(size == count) {</span>
        <span class="s1">mAllChildren = </span><span class="s2">new </span><span class="s1">View[size + ARRAY_CAPACITY_INCREMENT]</span><span class="s2">;</span>
        <span class="s1">System.arraycopy(children</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">mAllChildren</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">size)</span><span class="s2">;</span>
        <span class="s1">children = mAllChildren</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s1">children[mAllChildrenCount++] = child</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(index &lt; count) {</span>
      <span class="s2">if </span><span class="s1">(size == count) {</span>
        <span class="s1">mAllChildren = </span><span class="s2">new </span><span class="s1">View[size + ARRAY_CAPACITY_INCREMENT]</span><span class="s2">;</span>
        <span class="s1">System.arraycopy(children</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">mAllChildren</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">index)</span><span class="s2">;</span>
        <span class="s1">System.arraycopy(children</span><span class="s2">, </span><span class="s1">index</span><span class="s2">, </span><span class="s1">mAllChildren</span><span class="s2">, </span><span class="s1">index + </span><span class="s4">1</span><span class="s2">, </span><span class="s1">count - index)</span><span class="s2">;</span>
        <span class="s1">children = mAllChildren</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">System.arraycopy(children</span><span class="s2">, </span><span class="s1">index</span><span class="s2">, </span><span class="s1">children</span><span class="s2">, </span><span class="s1">index + </span><span class="s4">1</span><span class="s2">, </span><span class="s1">count - index)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s1">children[index] = child</span><span class="s2">;</span>
      <span class="s1">mAllChildrenCount++</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">throw new </span><span class="s1">IndexOutOfBoundsException(</span><span class="s7">&quot;index=&quot; </span><span class="s1">+ index + </span><span class="s7">&quot; count=&quot; </span><span class="s1">+ count)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">// This method also sets the child's mParent to null</span>
  <span class="s2">private void </span><span class="s1">removeFromArray(</span><span class="s2">int </span><span class="s1">index) {</span>
    <span class="s2">final </span><span class="s1">View[] children = Assertions.assertNotNull(mAllChildren)</span><span class="s2">;</span>
    <span class="s2">final int </span><span class="s1">count = mAllChildrenCount</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(index == count - </span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s1">children[--mAllChildrenCount] = </span><span class="s2">null;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(index &gt;= </span><span class="s4">0 </span><span class="s1">&amp;&amp; index &lt; count) {</span>
      <span class="s1">System.arraycopy(children</span><span class="s2">, </span><span class="s1">index + </span><span class="s4">1</span><span class="s2">, </span><span class="s1">children</span><span class="s2">, </span><span class="s1">index</span><span class="s2">, </span><span class="s1">count - index - </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">children[--mAllChildrenCount] = </span><span class="s2">null;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">throw new </span><span class="s1">IndexOutOfBoundsException()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@VisibleForTesting</span>
  <span class="s2">public int </span><span class="s1">getBackgroundColor() {</span>
    <span class="s2">if </span><span class="s1">(getBackground() != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">((ReactViewBackgroundDrawable) getBackground()).getColor()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">DEFAULT_BACKGROUND_COLOR</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">/* package */ </span><span class="s1">ReactViewBackgroundDrawable getOrCreateReactViewBackground() {</span>
    <span class="s2">if </span><span class="s1">(mReactBackgroundDrawable == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mReactBackgroundDrawable = </span><span class="s2">new </span><span class="s1">ReactViewBackgroundDrawable(getContext())</span><span class="s2">;</span>
      <span class="s1">Drawable backgroundDrawable = getBackground()</span><span class="s2">;</span>
      <span class="s1">updateBackgroundDrawable(</span>
          <span class="s2">null</span><span class="s1">)</span><span class="s2">; </span><span class="s0">// required so that drawable callback is cleared before we add the</span>
      <span class="s0">// drawable back as a part of LayerDrawable</span>
      <span class="s2">if </span><span class="s1">(backgroundDrawable == </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">updateBackgroundDrawable(mReactBackgroundDrawable)</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">LayerDrawable layerDrawable =</span>
            <span class="s2">new </span><span class="s1">LayerDrawable(</span><span class="s2">new </span><span class="s1">Drawable[] {mReactBackgroundDrawable</span><span class="s2">, </span><span class="s1">backgroundDrawable})</span><span class="s2">;</span>
        <span class="s1">updateBackgroundDrawable(layerDrawable)</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s1">mLayoutDirection =</span>
          <span class="s1">I18nUtil.getInstance().isRTL(getContext()) ? LAYOUT_DIRECTION_RTL : LAYOUT_DIRECTION_LTR</span><span class="s2">;</span>
      <span class="s1">mReactBackgroundDrawable.setResolvedLayoutDirection(mLayoutDirection)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">mReactBackgroundDrawable</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public </span><span class="s1">@Nullable Rect getHitSlopRect() {</span>
    <span class="s2">return </span><span class="s1">mHitSlopRect</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setHitSlopRect(@Nullable Rect rect) {</span>
    <span class="s1">mHitSlopRect = rect</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setOverflow(String overflow) {</span>
    <span class="s1">mOverflow = overflow</span><span class="s2">;</span>
    <span class="s1">invalidate()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public </span><span class="s1">@Nullable String getOverflow() {</span>
    <span class="s2">return </span><span class="s1">mOverflow</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setOverflowInset(</span><span class="s2">int </span><span class="s1">left</span><span class="s2">, int </span><span class="s1">top</span><span class="s2">, int </span><span class="s1">right</span><span class="s2">, int </span><span class="s1">bottom) {</span>
    <span class="s1">mOverflowInset.set(left</span><span class="s2">, </span><span class="s1">top</span><span class="s2">, </span><span class="s1">right</span><span class="s2">, </span><span class="s1">bottom)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public </span><span class="s1">Rect getOverflowInset() {</span>
    <span class="s2">return </span><span class="s1">mOverflowInset</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Set the background for the view or remove the background. It calls {</span><span class="s5">@link</span>
   <span class="s3">* #setBackground(Drawable)} or {</span><span class="s5">@link </span><span class="s3">#setBackgroundDrawable(Drawable)} based on the sdk version.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">drawable {</span><span class="s5">@link </span><span class="s3">Drawable} The Drawable to use as the background, or null to remove the</span>
   <span class="s3">*     background</span>
   <span class="s3">*/</span>
  <span class="s0">/* package */ </span><span class="s2">void </span><span class="s1">updateBackgroundDrawable(Drawable drawable) {</span>
    <span class="s2">super</span><span class="s1">.setBackground(drawable)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">protected void </span><span class="s1">dispatchDraw(Canvas canvas) {</span>
    <span class="s2">try </span><span class="s1">{</span>
      <span class="s1">dispatchOverflowDraw(canvas)</span><span class="s2">;</span>
      <span class="s2">super</span><span class="s1">.dispatchDraw(canvas)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(NullPointerException | StackOverflowError e) {</span>
      <span class="s0">// Adding special exception management for StackOverflowError for logging purposes.</span>
      <span class="s0">// This will be removed in the future.</span>
      <span class="s1">RootView rootView = RootViewUtil.getRootView(ReactViewGroup.</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(rootView != </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">rootView.handleException(e)</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(getContext() </span><span class="s2">instanceof </span><span class="s1">ReactContext) {</span>
          <span class="s1">ReactContext reactContext = (ReactContext) getContext()</span><span class="s2">;</span>
          <span class="s1">reactContext.handleException(</span>
              <span class="s2">new </span><span class="s1">IllegalViewOperationException(</span><span class="s7">&quot;StackOverflowException&quot;</span><span class="s2">, this, </span><span class="s1">e))</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s2">throw </span><span class="s1">e</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">protected boolean </span><span class="s1">drawChild(Canvas canvas</span><span class="s2">, </span><span class="s1">View child</span><span class="s2">, long </span><span class="s1">drawingTime) {</span>
    <span class="s2">boolean </span><span class="s1">drawWithZ = child.getElevation() &gt; </span><span class="s4">0</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(drawWithZ) {</span>
      <span class="s1">CanvasUtil.enableZ(canvas</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">boolean </span><span class="s1">result = </span><span class="s2">super</span><span class="s1">.drawChild(canvas</span><span class="s2">, </span><span class="s1">child</span><span class="s2">, </span><span class="s1">drawingTime)</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(drawWithZ) {</span>
      <span class="s1">CanvasUtil.enableZ(canvas</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">result</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private void </span><span class="s1">dispatchOverflowDraw(Canvas canvas) {</span>
    <span class="s2">if </span><span class="s1">(mOverflow != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">switch </span><span class="s1">(mOverflow) {</span>
        <span class="s2">case </span><span class="s1">ViewProps.VISIBLE:</span>
          <span class="s2">if </span><span class="s1">(mPath != </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">mPath.rewind()</span><span class="s2">;</span>
          <span class="s1">}</span>
          <span class="s2">break;</span>
        <span class="s2">case </span><span class="s1">ViewProps.HIDDEN:</span>
        <span class="s2">case </span><span class="s1">ViewProps.SCROLL:</span>
          <span class="s2">float </span><span class="s1">left = </span><span class="s4">0f</span><span class="s2">;</span>
          <span class="s2">float </span><span class="s1">top = </span><span class="s4">0f</span><span class="s2">;</span>
          <span class="s2">float </span><span class="s1">right = getWidth()</span><span class="s2">;</span>
          <span class="s2">float </span><span class="s1">bottom = getHeight()</span><span class="s2">;</span>

          <span class="s2">boolean </span><span class="s1">hasClipPath = </span><span class="s2">false;</span>

          <span class="s2">if </span><span class="s1">(mReactBackgroundDrawable != </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">final </span><span class="s1">RectF borderWidth = mReactBackgroundDrawable.getDirectionAwareBorderInsets()</span><span class="s2">;</span>

            <span class="s2">if </span><span class="s1">(borderWidth.top &gt; </span><span class="s4">0</span>
                <span class="s1">|| borderWidth.left &gt; </span><span class="s4">0</span>
                <span class="s1">|| borderWidth.bottom &gt; </span><span class="s4">0</span>
                <span class="s1">|| borderWidth.right &gt; </span><span class="s4">0</span><span class="s1">) {</span>
              <span class="s1">left += borderWidth.left</span><span class="s2">;</span>
              <span class="s1">top += borderWidth.top</span><span class="s2">;</span>
              <span class="s1">right -= borderWidth.right</span><span class="s2">;</span>
              <span class="s1">bottom -= borderWidth.bottom</span><span class="s2">;</span>
            <span class="s1">}</span>

            <span class="s2">final float </span><span class="s1">borderRadius = mReactBackgroundDrawable.getFullBorderRadius()</span><span class="s2">;</span>
            <span class="s2">float </span><span class="s1">topLeftBorderRadius =</span>
                <span class="s1">mReactBackgroundDrawable.getBorderRadiusOrDefaultTo(</span>
                    <span class="s1">borderRadius</span><span class="s2">, </span><span class="s1">ReactViewBackgroundDrawable.BorderRadiusLocation.TOP_LEFT)</span><span class="s2">;</span>
            <span class="s2">float </span><span class="s1">topRightBorderRadius =</span>
                <span class="s1">mReactBackgroundDrawable.getBorderRadiusOrDefaultTo(</span>
                    <span class="s1">borderRadius</span><span class="s2">, </span><span class="s1">ReactViewBackgroundDrawable.BorderRadiusLocation.TOP_RIGHT)</span><span class="s2">;</span>
            <span class="s2">float </span><span class="s1">bottomLeftBorderRadius =</span>
                <span class="s1">mReactBackgroundDrawable.getBorderRadiusOrDefaultTo(</span>
                    <span class="s1">borderRadius</span><span class="s2">, </span><span class="s1">ReactViewBackgroundDrawable.BorderRadiusLocation.BOTTOM_LEFT)</span><span class="s2">;</span>
            <span class="s2">float </span><span class="s1">bottomRightBorderRadius =</span>
                <span class="s1">mReactBackgroundDrawable.getBorderRadiusOrDefaultTo(</span>
                    <span class="s1">borderRadius</span><span class="s2">, </span><span class="s1">ReactViewBackgroundDrawable.BorderRadiusLocation.BOTTOM_RIGHT)</span><span class="s2">;</span>

            <span class="s2">final boolean </span><span class="s1">isRTL = mLayoutDirection == View.LAYOUT_DIRECTION_RTL</span><span class="s2">;</span>
            <span class="s2">float </span><span class="s1">topStartBorderRadius =</span>
                <span class="s1">mReactBackgroundDrawable.getBorderRadius(</span>
                    <span class="s1">ReactViewBackgroundDrawable.BorderRadiusLocation.TOP_START)</span><span class="s2">;</span>
            <span class="s2">float </span><span class="s1">topEndBorderRadius =</span>
                <span class="s1">mReactBackgroundDrawable.getBorderRadius(</span>
                    <span class="s1">ReactViewBackgroundDrawable.BorderRadiusLocation.TOP_END)</span><span class="s2">;</span>
            <span class="s2">float </span><span class="s1">bottomStartBorderRadius =</span>
                <span class="s1">mReactBackgroundDrawable.getBorderRadius(</span>
                    <span class="s1">ReactViewBackgroundDrawable.BorderRadiusLocation.BOTTOM_START)</span><span class="s2">;</span>
            <span class="s2">float </span><span class="s1">bottomEndBorderRadius =</span>
                <span class="s1">mReactBackgroundDrawable.getBorderRadius(</span>
                    <span class="s1">ReactViewBackgroundDrawable.BorderRadiusLocation.BOTTOM_END)</span><span class="s2">;</span>

            <span class="s2">if </span><span class="s1">(I18nUtil.getInstance().doLeftAndRightSwapInRTL(getContext())) {</span>
              <span class="s2">if </span><span class="s1">(YogaConstants.isUndefined(topStartBorderRadius)) {</span>
                <span class="s1">topStartBorderRadius = topLeftBorderRadius</span><span class="s2">;</span>
              <span class="s1">}</span>

              <span class="s2">if </span><span class="s1">(YogaConstants.isUndefined(topEndBorderRadius)) {</span>
                <span class="s1">topEndBorderRadius = topRightBorderRadius</span><span class="s2">;</span>
              <span class="s1">}</span>

              <span class="s2">if </span><span class="s1">(YogaConstants.isUndefined(bottomStartBorderRadius)) {</span>
                <span class="s1">bottomStartBorderRadius = bottomLeftBorderRadius</span><span class="s2">;</span>
              <span class="s1">}</span>

              <span class="s2">if </span><span class="s1">(YogaConstants.isUndefined(bottomEndBorderRadius)) {</span>
                <span class="s1">bottomEndBorderRadius = bottomRightBorderRadius</span><span class="s2">;</span>
              <span class="s1">}</span>

              <span class="s2">final float </span><span class="s1">directionAwareTopLeftRadius =</span>
                  <span class="s1">isRTL ? topEndBorderRadius : topStartBorderRadius</span><span class="s2">;</span>
              <span class="s2">final float </span><span class="s1">directionAwareTopRightRadius =</span>
                  <span class="s1">isRTL ? topStartBorderRadius : topEndBorderRadius</span><span class="s2">;</span>
              <span class="s2">final float </span><span class="s1">directionAwareBottomLeftRadius =</span>
                  <span class="s1">isRTL ? bottomEndBorderRadius : bottomStartBorderRadius</span><span class="s2">;</span>
              <span class="s2">final float </span><span class="s1">directionAwareBottomRightRadius =</span>
                  <span class="s1">isRTL ? bottomStartBorderRadius : bottomEndBorderRadius</span><span class="s2">;</span>

              <span class="s1">topLeftBorderRadius = directionAwareTopLeftRadius</span><span class="s2">;</span>
              <span class="s1">topRightBorderRadius = directionAwareTopRightRadius</span><span class="s2">;</span>
              <span class="s1">bottomLeftBorderRadius = directionAwareBottomLeftRadius</span><span class="s2">;</span>
              <span class="s1">bottomRightBorderRadius = directionAwareBottomRightRadius</span><span class="s2">;</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
              <span class="s2">final float </span><span class="s1">directionAwareTopLeftRadius =</span>
                  <span class="s1">isRTL ? topEndBorderRadius : topStartBorderRadius</span><span class="s2">;</span>
              <span class="s2">final float </span><span class="s1">directionAwareTopRightRadius =</span>
                  <span class="s1">isRTL ? topStartBorderRadius : topEndBorderRadius</span><span class="s2">;</span>
              <span class="s2">final float </span><span class="s1">directionAwareBottomLeftRadius =</span>
                  <span class="s1">isRTL ? bottomEndBorderRadius : bottomStartBorderRadius</span><span class="s2">;</span>
              <span class="s2">final float </span><span class="s1">directionAwareBottomRightRadius =</span>
                  <span class="s1">isRTL ? bottomStartBorderRadius : bottomEndBorderRadius</span><span class="s2">;</span>

              <span class="s2">if </span><span class="s1">(!YogaConstants.isUndefined(directionAwareTopLeftRadius)) {</span>
                <span class="s1">topLeftBorderRadius = directionAwareTopLeftRadius</span><span class="s2">;</span>
              <span class="s1">}</span>

              <span class="s2">if </span><span class="s1">(!YogaConstants.isUndefined(directionAwareTopRightRadius)) {</span>
                <span class="s1">topRightBorderRadius = directionAwareTopRightRadius</span><span class="s2">;</span>
              <span class="s1">}</span>

              <span class="s2">if </span><span class="s1">(!YogaConstants.isUndefined(directionAwareBottomLeftRadius)) {</span>
                <span class="s1">bottomLeftBorderRadius = directionAwareBottomLeftRadius</span><span class="s2">;</span>
              <span class="s1">}</span>

              <span class="s2">if </span><span class="s1">(!YogaConstants.isUndefined(directionAwareBottomRightRadius)) {</span>
                <span class="s1">bottomRightBorderRadius = directionAwareBottomRightRadius</span><span class="s2">;</span>
              <span class="s1">}</span>
            <span class="s1">}</span>

            <span class="s2">if </span><span class="s1">(topLeftBorderRadius &gt; </span><span class="s4">0</span>
                <span class="s1">|| topRightBorderRadius &gt; </span><span class="s4">0</span>
                <span class="s1">|| bottomRightBorderRadius &gt; </span><span class="s4">0</span>
                <span class="s1">|| bottomLeftBorderRadius &gt; </span><span class="s4">0</span><span class="s1">) {</span>
              <span class="s2">if </span><span class="s1">(mPath == </span><span class="s2">null</span><span class="s1">) {</span>
                <span class="s1">mPath = </span><span class="s2">new </span><span class="s1">Path()</span><span class="s2">;</span>
              <span class="s1">}</span>

              <span class="s1">mPath.rewind()</span><span class="s2">;</span>
              <span class="s1">mPath.addRoundRect(</span>
                  <span class="s2">new </span><span class="s1">RectF(left</span><span class="s2">, </span><span class="s1">top</span><span class="s2">, </span><span class="s1">right</span><span class="s2">, </span><span class="s1">bottom)</span><span class="s2">,</span>
                  <span class="s2">new float</span><span class="s1">[] {</span>
                    <span class="s1">Math.max(topLeftBorderRadius - borderWidth.left</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">Math.max(topLeftBorderRadius - borderWidth.top</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">Math.max(topRightBorderRadius - borderWidth.right</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">Math.max(topRightBorderRadius - borderWidth.top</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">Math.max(bottomRightBorderRadius - borderWidth.right</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">Math.max(bottomRightBorderRadius - borderWidth.bottom</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">Math.max(bottomLeftBorderRadius - borderWidth.left</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">Math.max(bottomLeftBorderRadius - borderWidth.bottom</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">,</span>
                  <span class="s1">}</span><span class="s2">,</span>
                  <span class="s1">Path.Direction.CW)</span><span class="s2">;</span>
              <span class="s1">canvas.clipPath(mPath)</span><span class="s2">;</span>
              <span class="s1">hasClipPath = </span><span class="s2">true;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s2">if </span><span class="s1">(!hasClipPath) {</span>
            <span class="s1">canvas.clipRect(</span><span class="s2">new </span><span class="s1">RectF(left</span><span class="s2">, </span><span class="s1">top</span><span class="s2">, </span><span class="s1">right</span><span class="s2">, </span><span class="s1">bottom))</span><span class="s2">;</span>
          <span class="s1">}</span>
          <span class="s2">break;</span>
        <span class="s2">default</span><span class="s1">:</span>
          <span class="s2">break;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setOpacityIfPossible(</span><span class="s2">float </span><span class="s1">opacity) {</span>
    <span class="s1">mBackfaceOpacity = opacity</span><span class="s2">;</span>
    <span class="s1">setBackfaceVisibilityDependantOpacity()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setBackfaceVisibility(String backfaceVisibility) {</span>
    <span class="s1">mBackfaceVisibility = backfaceVisibility</span><span class="s2">;</span>
    <span class="s1">setBackfaceVisibilityDependantOpacity()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setBackfaceVisibilityDependantOpacity() {</span>
    <span class="s2">boolean </span><span class="s1">isBackfaceVisible = mBackfaceVisibility.equals(</span><span class="s7">&quot;visible&quot;</span><span class="s1">)</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(isBackfaceVisible) {</span>
      <span class="s1">setAlpha(mBackfaceOpacity)</span><span class="s2">;</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s2">float </span><span class="s1">rotationX = getRotationX()</span><span class="s2">;</span>
    <span class="s2">float </span><span class="s1">rotationY = getRotationY()</span><span class="s2">;</span>

    <span class="s2">boolean </span><span class="s1">isFrontfaceVisible =</span>
        <span class="s1">(rotationX &gt;= -</span><span class="s4">90.f </span><span class="s1">&amp;&amp; rotationX &lt; </span><span class="s4">90.f</span><span class="s1">) &amp;&amp; (rotationY &gt;= -</span><span class="s4">90.f </span><span class="s1">&amp;&amp; rotationY &lt; </span><span class="s4">90.f</span><span class="s1">)</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(isFrontfaceVisible) {</span>
      <span class="s1">setAlpha(mBackfaceOpacity)</span><span class="s2">;</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s1">setAlpha(</span><span class="s4">0</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
</pre>
</body>
</html>
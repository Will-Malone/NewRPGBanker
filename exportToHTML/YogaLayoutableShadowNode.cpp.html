<html>
<head>
<title>YogaLayoutableShadowNode.cpp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #bbb529;}
.s3 { color: #6a8759;}
.s4 { color: #cc7832;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
YogaLayoutableShadowNode.cpp</font>
</center></td></tr></table>
<pre><span class="s0">/* 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>

<span class="s2">#include </span><span class="s3">&quot;YogaLayoutableShadowNode.h&quot;</span>
<span class="s2">#include </span><span class="s3">&lt;logger/react_native_log.h&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;react/debug/flags.h&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;react/debug/react_native_assert.h&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;react/renderer/components/view/ViewProps.h&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;react/renderer/components/view/ViewShadowNode.h&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;react/renderer/components/view/conversions.h&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;react/renderer/core/LayoutConstraints.h&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;react/renderer/core/LayoutContext.h&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;react/renderer/core/TraitCast.h&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;react/renderer/debug/DebugStringConvertibleItem.h&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;react/renderer/debug/SystraceSection.h&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;yoga/Yoga.h&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;algorithm&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;limits&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;memory&gt;</span>

<span class="s4">namespace </span><span class="s1">facebook::react {</span>

<span class="s4">static int </span><span class="s1">FabricDefaultYogaLog(</span>
    <span class="s4">const </span><span class="s1">YGConfigRef </span><span class="s0">/*unused*/</span><span class="s4">,</span>
    <span class="s4">const </span><span class="s1">YGNodeRef </span><span class="s0">/*unused*/</span><span class="s4">,</span>
    <span class="s1">YGLogLevel level</span><span class="s4">,</span>
    <span class="s4">const char </span><span class="s1">*format</span><span class="s4">,</span>
    <span class="s1">va_list args) {</span>
  <span class="s1">va_list args_copy</span><span class="s4">;</span>
  <span class="s1">va_copy(args_copy</span><span class="s4">, </span><span class="s1">args)</span><span class="s4">;</span>

  <span class="s0">// Adding 1 to add space for terminating null character.</span>
  <span class="s4">int </span><span class="s1">size_s = vsnprintf(</span><span class="s4">nullptr, </span><span class="s5">0</span><span class="s4">, </span><span class="s1">format</span><span class="s4">, </span><span class="s1">args)</span><span class="s4">;</span>
  <span class="s4">auto </span><span class="s1">size = </span><span class="s4">static_cast</span><span class="s1">&lt;size_t&gt;(size_s)</span><span class="s4">;</span>
  <span class="s1">std::vector&lt;</span><span class="s4">char</span><span class="s1">&gt; buffer(size)</span><span class="s4">;</span>

  <span class="s1">vsnprintf(buffer.data()</span><span class="s4">, </span><span class="s1">size</span><span class="s4">, </span><span class="s1">format</span><span class="s4">, </span><span class="s1">args_copy)</span><span class="s4">;</span>
  <span class="s4">switch </span><span class="s1">(level) {</span>
    <span class="s4">case </span><span class="s1">YGLogLevelError:</span>
      <span class="s1">react_native_log_error(buffer.data())</span><span class="s4">;</span>
      <span class="s4">break;</span>
    <span class="s4">case </span><span class="s1">YGLogLevelFatal:</span>
      <span class="s1">react_native_log_fatal(buffer.data())</span><span class="s4">;</span>
      <span class="s4">break;</span>
    <span class="s4">case </span><span class="s1">YGLogLevelWarn:</span>
      <span class="s1">react_native_log_warn(buffer.data())</span><span class="s4">;</span>
      <span class="s4">break;</span>
    <span class="s4">case </span><span class="s1">YGLogLevelInfo:</span>
    <span class="s4">case </span><span class="s1">YGLogLevelDebug:</span>
    <span class="s4">case </span><span class="s1">YGLogLevelVerbose:</span>
    <span class="s4">default</span><span class="s1">:</span>
      <span class="s1">react_native_log_info(buffer.data())</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">return </span><span class="s1">size_s</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">thread_local </span><span class="s1">LayoutContext threadLocalLayoutContext</span><span class="s4">;</span>

<span class="s1">ShadowNodeTraits YogaLayoutableShadowNode::BaseTraits() {</span>
  <span class="s4">auto </span><span class="s1">traits = LayoutableShadowNode::BaseTraits()</span><span class="s4">;</span>
  <span class="s1">traits.set(IdentifierTrait())</span><span class="s4">;</span>
  <span class="s4">return </span><span class="s1">traits</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">ShadowNodeTraits::Trait YogaLayoutableShadowNode::IdentifierTrait() {</span>
  <span class="s4">return </span><span class="s1">ShadowNodeTraits::Trait::YogaLayoutableKind</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">YogaLayoutableShadowNode::YogaLayoutableShadowNode(</span>
    <span class="s1">ShadowNodeFragment </span><span class="s4">const </span><span class="s1">&amp;fragment</span><span class="s4">,</span>
    <span class="s1">ShadowNodeFamily::Shared </span><span class="s4">const </span><span class="s1">&amp;family</span><span class="s4">,</span>
    <span class="s1">ShadowNodeTraits traits)</span>
    <span class="s1">: LayoutableShadowNode(fragment</span><span class="s4">, </span><span class="s1">family</span><span class="s4">, </span><span class="s1">traits)</span><span class="s4">,</span>
      <span class="s1">yogaConfig_(FabricDefaultYogaLog)</span><span class="s4">,</span>
      <span class="s1">yogaNode_(&amp;initializeYogaConfig(yogaConfig_)) {</span>
  <span class="s1">yogaNode_.setContext(</span><span class="s4">this</span><span class="s1">)</span><span class="s4">;</span>

  <span class="s0">// Newly created node must be `dirty` just because it is new.</span>
  <span class="s0">// This is not a default for `YGNode`.</span>
  <span class="s1">yogaNode_.setDirty(</span><span class="s4">true</span><span class="s1">)</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(getTraits().check(ShadowNodeTraits::Trait::MeasurableYogaNode)) {</span>
    <span class="s1">react_native_assert(</span>
        <span class="s1">getTraits().check(ShadowNodeTraits::Trait::LeafYogaNode))</span><span class="s4">;</span>

    <span class="s1">yogaNode_.setMeasureFunc(</span>
        <span class="s1">YogaLayoutableShadowNode::yogaNodeMeasureCallbackConnector)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">updateYogaProps()</span><span class="s4">;</span>
  <span class="s1">updateYogaChildren()</span><span class="s4">;</span>

  <span class="s1">ensureConsistency()</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">YogaLayoutableShadowNode::YogaLayoutableShadowNode(</span>
    <span class="s1">ShadowNode </span><span class="s4">const </span><span class="s1">&amp;sourceShadowNode</span><span class="s4">,</span>
    <span class="s1">ShadowNodeFragment </span><span class="s4">const </span><span class="s1">&amp;fragment)</span>
    <span class="s1">: LayoutableShadowNode(sourceShadowNode</span><span class="s4">, </span><span class="s1">fragment)</span><span class="s4">,</span>
      <span class="s1">yogaConfig_(FabricDefaultYogaLog)</span><span class="s4">,</span>
      <span class="s1">yogaNode_(</span>
          <span class="s4">static_cast</span><span class="s1">&lt;YogaLayoutableShadowNode </span><span class="s4">const </span><span class="s1">&amp;&gt;(sourceShadowNode)</span>
              <span class="s1">.yogaNode_</span><span class="s4">,</span>
          <span class="s1">&amp;initializeYogaConfig(yogaConfig_)) {</span>
  <span class="s0">// Note, cloned `YGNode` instance (copied using copy-constructor) inherits</span>
  <span class="s0">// dirty flag, measure function, and other properties being set originally in</span>
  <span class="s0">// the `YogaLayoutableShadowNode` constructor above.</span>

  <span class="s1">react_native_assert(</span>
      <span class="s4">static_cast</span><span class="s1">&lt;YogaLayoutableShadowNode </span><span class="s4">const </span><span class="s1">&amp;&gt;(sourceShadowNode)</span>
              <span class="s1">.yogaNode_.isDirty() == yogaNode_.isDirty() &amp;&amp;</span>
      <span class="s3">&quot;Yoga node must inherit dirty flag.&quot;</span><span class="s1">)</span><span class="s4">;</span>

  <span class="s4">for </span><span class="s1">(</span><span class="s4">auto </span><span class="s1">&amp;child : getChildren()) {</span>
    <span class="s4">if </span><span class="s1">(</span><span class="s4">auto </span><span class="s1">layoutableChild = traitCast&lt;YogaLayoutableShadowNode&gt;(child)) {</span>
      <span class="s1">yogaLayoutableChildren_.push_back(layoutableChild)</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">yogaNode_.setContext(</span><span class="s4">this</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">yogaNode_.setOwner(</span><span class="s4">nullptr</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">updateYogaChildrenOwnersIfNeeded()</span><span class="s4">;</span>

  <span class="s0">// This is the only legit place where we can dirty cloned Yoga node.</span>
  <span class="s0">// If we do it later, ancestor nodes will not be able to observe this and</span>
  <span class="s0">// dirty (and clone) themselves as a result.</span>
  <span class="s4">if </span><span class="s1">(getTraits().check(ShadowNodeTraits::Trait::DirtyYogaNode) ||</span>
      <span class="s1">getTraits().check(ShadowNodeTraits::Trait::MeasurableYogaNode)) {</span>
    <span class="s1">yogaNode_.setDirty(</span><span class="s4">true</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(fragment.props) {</span>
    <span class="s1">updateYogaProps()</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(fragment.children) {</span>
    <span class="s1">updateYogaChildren()</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">ensureConsistency()</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">YogaLayoutableShadowNode::cleanLayout() {</span>
  <span class="s1">yogaNode_.setDirty(</span><span class="s4">false</span><span class="s1">)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">YogaLayoutableShadowNode::dirtyLayout() {</span>
  <span class="s1">yogaNode_.setDirty(</span><span class="s4">true</span><span class="s1">)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">bool </span><span class="s1">YogaLayoutableShadowNode::getIsLayoutClean() </span><span class="s4">const </span><span class="s1">{</span>
  <span class="s4">return </span><span class="s1">!yogaNode_.isDirty()</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s2">#pragma </span><span class="s1">mark - Mutating Methods</span>

<span class="s4">void </span><span class="s1">YogaLayoutableShadowNode::enableMeasurement() {</span>
  <span class="s1">ensureUnsealed()</span><span class="s4">;</span>

  <span class="s1">yogaNode_.setMeasureFunc(</span>
      <span class="s1">YogaLayoutableShadowNode::yogaNodeMeasureCallbackConnector)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">YogaLayoutableShadowNode::appendYogaChild(</span>
    <span class="s1">YogaLayoutableShadowNode::Shared </span><span class="s4">const </span><span class="s1">&amp;childNode) {</span>
  <span class="s0">// The caller must check this before calling this method.</span>
  <span class="s1">react_native_assert(</span>
      <span class="s1">!getTraits().check(ShadowNodeTraits::Trait::LeafYogaNode))</span><span class="s4">;</span>

  <span class="s1">ensureYogaChildrenLookFine()</span><span class="s4">;</span>

  <span class="s1">yogaLayoutableChildren_.push_back(childNode)</span><span class="s4">;</span>
  <span class="s1">yogaNode_.insertChild(</span>
      <span class="s1">&amp;childNode-&gt;yogaNode_</span><span class="s4">,</span>
      <span class="s4">static_cast</span><span class="s1">&lt;uint32_t&gt;(yogaNode_.getChildren().size()))</span><span class="s4">;</span>

  <span class="s1">ensureYogaChildrenLookFine()</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">YogaLayoutableShadowNode::adoptYogaChild(size_t index) {</span>
  <span class="s1">ensureUnsealed()</span><span class="s4">;</span>
  <span class="s1">ensureYogaChildrenLookFine()</span><span class="s4">;</span>

  <span class="s0">// The caller must check this before calling this method.</span>
  <span class="s1">react_native_assert(</span>
      <span class="s1">!getTraits().check(ShadowNodeTraits::Trait::LeafYogaNode))</span><span class="s4">;</span>

  <span class="s4">auto </span><span class="s1">&amp;childNode =</span>
      <span class="s1">traitCast&lt;YogaLayoutableShadowNode </span><span class="s4">const </span><span class="s1">&amp;&gt;(*getChildren().at(index))</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(childNode.yogaNode_.getOwner() == </span><span class="s4">nullptr</span><span class="s1">) {</span>
    <span class="s0">// The child node is not owned.</span>
    <span class="s1">childNode.yogaNode_.setOwner(&amp;yogaNode_)</span><span class="s4">;</span>
    <span class="s0">// At this point the child yoga node must be already inserted by the caller.</span>
    <span class="s0">// react_native_assert(layoutableChildNode.yogaNode_.isDirty());</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s0">// The child is owned by some other node, we need to clone that.</span>
    <span class="s0">// TODO: At this point, React has wrong reference to the node. (T138668036)</span>
    <span class="s4">auto </span><span class="s1">clonedChildNode = childNode.clone({})</span><span class="s4">;</span>

    <span class="s0">// Replace the child node with a newly cloned one in the children list.</span>
    <span class="s1">replaceChild(childNode</span><span class="s4">, </span><span class="s1">clonedChildNode</span><span class="s4">, static_cast</span><span class="s1">&lt;</span><span class="s4">int</span><span class="s1">&gt;(index))</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">ensureYogaChildrenLookFine()</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">YogaLayoutableShadowNode::appendChild(</span>
    <span class="s1">ShadowNode::Shared </span><span class="s4">const </span><span class="s1">&amp;childNode) {</span>
  <span class="s1">ensureUnsealed()</span><span class="s4">;</span>
  <span class="s1">ensureConsistency()</span><span class="s4">;</span>

  <span class="s0">// Calling the base class (`ShadowNode`) method.</span>
  <span class="s1">LayoutableShadowNode::appendChild(childNode)</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(getTraits().check(ShadowNodeTraits::Trait::LeafYogaNode)) {</span>
    <span class="s0">// This node is a declared leaf.</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(</span><span class="s4">auto </span><span class="s1">yogaLayoutableChild =</span>
          <span class="s1">traitCast&lt;YogaLayoutableShadowNode&gt;(childNode)) {</span>
    <span class="s0">// Here we don't have information about the previous structure of the node</span>
    <span class="s0">// (if it that existed before), so we don't have anything to compare the</span>
    <span class="s0">// Yoga node with (like a previous version of this node). Therefore we must</span>
    <span class="s0">// dirty the node.</span>
    <span class="s1">yogaNode_.setDirty(</span><span class="s4">true</span><span class="s1">)</span><span class="s4">;</span>

    <span class="s0">// Appending the Yoga node.</span>
    <span class="s1">appendYogaChild(yogaLayoutableChild)</span><span class="s4">;</span>

    <span class="s1">ensureYogaChildrenLookFine()</span><span class="s4">;</span>
    <span class="s1">ensureYogaChildrenAlignment()</span><span class="s4">;</span>

    <span class="s0">// Adopting the Yoga node.</span>
    <span class="s1">adoptYogaChild(getChildren().size() - </span><span class="s5">1</span><span class="s1">)</span><span class="s4">;</span>

    <span class="s1">ensureConsistency()</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">YogaLayoutableShadowNode::replaceChild(</span>
    <span class="s1">ShadowNode </span><span class="s4">const </span><span class="s1">&amp;oldChild</span><span class="s4">,</span>
    <span class="s1">ShadowNode::Shared </span><span class="s4">const </span><span class="s1">&amp;newChild</span><span class="s4">,</span>
    <span class="s1">size_t suggestedIndex) {</span>
  <span class="s1">LayoutableShadowNode::replaceChild(oldChild</span><span class="s4">, </span><span class="s1">newChild</span><span class="s4">, </span><span class="s1">suggestedIndex)</span><span class="s4">;</span>

  <span class="s1">ensureUnsealed()</span><span class="s4">;</span>
  <span class="s1">ensureYogaChildrenLookFine()</span><span class="s4">;</span>

  <span class="s4">auto </span><span class="s1">layoutableOldChild =</span>
      <span class="s1">traitCast&lt;YogaLayoutableShadowNode </span><span class="s4">const </span><span class="s1">*&gt;(&amp;oldChild)</span><span class="s4">;</span>
  <span class="s4">auto </span><span class="s1">layoutableNewChild = traitCast&lt;YogaLayoutableShadowNode&gt;(newChild)</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(layoutableOldChild == </span><span class="s4">nullptr </span><span class="s1">&amp;&amp; layoutableNewChild == </span><span class="s4">nullptr</span><span class="s1">) {</span>
    <span class="s0">// No need to mutate yogaLayoutableChildren_</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>

  <span class="s4">bool </span><span class="s1">suggestedIndexAccurate = suggestedIndex &gt;= </span><span class="s5">0 </span><span class="s1">&amp;&amp;</span>
      <span class="s1">suggestedIndex &lt; yogaLayoutableChildren_.size() &amp;&amp;</span>
      <span class="s1">yogaLayoutableChildren_[suggestedIndex].get() == layoutableOldChild</span><span class="s4">;</span>

  <span class="s4">auto </span><span class="s1">oldChildIter = suggestedIndexAccurate</span>
      <span class="s1">? yogaLayoutableChildren_.begin() + suggestedIndex</span>
      <span class="s1">: std::find_if(</span>
            <span class="s1">yogaLayoutableChildren_.begin()</span><span class="s4">,</span>
            <span class="s1">yogaLayoutableChildren_.end()</span><span class="s4">,</span>
            <span class="s1">[&amp;](YogaLayoutableShadowNode::Shared </span><span class="s4">const </span><span class="s1">&amp;layoutableChild) {</span>
              <span class="s4">return </span><span class="s1">layoutableChild.get() == layoutableOldChild</span><span class="s4">;</span>
            <span class="s1">})</span><span class="s4">;</span>
  <span class="s4">auto </span><span class="s1">oldChildIndex =</span>
      <span class="s4">static_cast</span><span class="s1">&lt;int32_t&gt;(oldChildIter - yogaLayoutableChildren_.begin())</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(oldChildIter == yogaLayoutableChildren_.end()) {</span>
    <span class="s0">// oldChild does not exist as part of our node</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(layoutableNewChild) {</span>
    <span class="s0">// Both children are layoutable, replace the old one with the new one</span>
    <span class="s1">react_native_assert(layoutableNewChild-&gt;yogaNode_.getOwner() == </span><span class="s4">nullptr</span><span class="s1">)</span><span class="s4">;</span>
    <span class="s1">layoutableNewChild-&gt;yogaNode_.setOwner(&amp;yogaNode_)</span><span class="s4">;</span>
    <span class="s1">*oldChildIter = layoutableNewChild</span><span class="s4">;</span>
    <span class="s1">yogaNode_.replaceChild(&amp;layoutableNewChild-&gt;yogaNode_</span><span class="s4">, </span><span class="s1">oldChildIndex)</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s0">// Layoutable child replaced with non layoutable child. Remove the previous</span>
    <span class="s0">// child from the layoutable children list.</span>
    <span class="s1">yogaLayoutableChildren_.erase(oldChildIter)</span><span class="s4">;</span>
    <span class="s1">yogaNode_.removeChild(oldChildIndex)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">ensureYogaChildrenLookFine()</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">bool </span><span class="s1">YogaLayoutableShadowNode::doesOwn(</span>
    <span class="s1">YogaLayoutableShadowNode </span><span class="s4">const </span><span class="s1">&amp;child) </span><span class="s4">const </span><span class="s1">{</span>
  <span class="s4">return </span><span class="s1">child.yogaNode_.getOwner() == &amp;yogaNode_</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">YogaLayoutableShadowNode::updateYogaChildrenOwnersIfNeeded() {</span>
  <span class="s4">for </span><span class="s1">(</span><span class="s4">auto </span><span class="s1">&amp;childYogaNode : yogaNode_.getChildren()) {</span>
    <span class="s4">if </span><span class="s1">(childYogaNode-&gt;getOwner() == &amp;yogaNode_) {</span>
      <span class="s1">childYogaNode-&gt;setOwner(</span><span class="s4">reinterpret_cast</span><span class="s1">&lt;YGNodeRef&gt;(</span><span class="s5">0xBADC0FFEE0DDF00D</span><span class="s1">))</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">YogaLayoutableShadowNode::updateYogaChildren() {</span>
  <span class="s4">if </span><span class="s1">(getTraits().check(ShadowNodeTraits::Trait::LeafYogaNode)) {</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>

  <span class="s1">ensureUnsealed()</span><span class="s4">;</span>

  <span class="s4">bool </span><span class="s1">isClean = !yogaNode_.isDirty() &amp;&amp;</span>
      <span class="s1">getChildren().size() == yogaNode_.getChildren().size()</span><span class="s4">;</span>

  <span class="s4">auto </span><span class="s1">oldYogaChildren = isClean ? yogaNode_.getChildren() : YGVector{}</span><span class="s4">;</span>
  <span class="s1">yogaNode_.setChildren({})</span><span class="s4">;</span>
  <span class="s1">yogaLayoutableChildren_.clear()</span><span class="s4">;</span>

  <span class="s4">for </span><span class="s1">(size_t i = </span><span class="s5">0</span><span class="s4">; </span><span class="s1">i &lt; getChildren().size()</span><span class="s4">; </span><span class="s1">i++) {</span>
    <span class="s4">if </span><span class="s1">(</span><span class="s4">auto </span><span class="s1">yogaLayoutableChild =</span>
            <span class="s1">traitCast&lt;YogaLayoutableShadowNode&gt;(getChildren()[i])) {</span>
      <span class="s1">appendYogaChild(yogaLayoutableChild)</span><span class="s4">;</span>
      <span class="s1">adoptYogaChild(i)</span><span class="s4">;</span>

      <span class="s4">if </span><span class="s1">(isClean) {</span>
        <span class="s4">auto </span><span class="s1">yogaChildIndex = yogaLayoutableChildren_.size() - </span><span class="s5">1</span><span class="s4">;</span>
        <span class="s4">auto </span><span class="s1">&amp;oldYogaChildNode = *oldYogaChildren.at(yogaChildIndex)</span><span class="s4">;</span>
        <span class="s4">auto </span><span class="s1">&amp;newYogaChildNode =</span>
            <span class="s1">yogaLayoutableChildren_.at(yogaChildIndex)-&gt;yogaNode_</span><span class="s4">;</span>

        <span class="s1">isClean = isClean &amp;&amp; !newYogaChildNode.isDirty() &amp;&amp;</span>
            <span class="s1">(newYogaChildNode.getStyle() == oldYogaChildNode.getStyle())</span><span class="s4">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">react_native_assert(</span>
      <span class="s1">yogaLayoutableChildren_.size() == yogaNode_.getChildren().size())</span><span class="s4">;</span>

  <span class="s1">yogaNode_.setDirty(!isClean)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">YogaLayoutableShadowNode::updateYogaProps() {</span>
  <span class="s1">ensureUnsealed()</span><span class="s4">;</span>

  <span class="s4">auto </span><span class="s1">props = </span><span class="s4">static_cast</span><span class="s1">&lt;YogaStylableProps </span><span class="s4">const </span><span class="s1">&amp;&gt;(*props_)</span><span class="s4">;</span>
  <span class="s4">auto </span><span class="s1">styleResult = applyAliasedProps(props.yogaStyle</span><span class="s4">, </span><span class="s1">props)</span><span class="s4">;</span>

  <span class="s0">// Resetting `dirty` flag only if `yogaStyle` portion of `Props` was changed.</span>
  <span class="s4">if </span><span class="s1">(!yogaNode_.isDirty() &amp;&amp; (styleResult != yogaNode_.getStyle())) {</span>
    <span class="s1">yogaNode_.setDirty(</span><span class="s4">true</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">yogaNode_.setStyle(styleResult)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s0">/*static*/ </span><span class="s1">YGStyle YogaLayoutableShadowNode::applyAliasedProps(</span>
    <span class="s4">const </span><span class="s1">YGStyle &amp;baseStyle</span><span class="s4">,</span>
    <span class="s4">const </span><span class="s1">YogaStylableProps &amp;props) {</span>
  <span class="s1">YGStyle result{baseStyle}</span><span class="s4">;</span>

  <span class="s0">// Aliases with precedence</span>
  <span class="s4">if </span><span class="s1">(!props.marginInline.isUndefined()) {</span>
    <span class="s1">result.margin()[YGEdgeHorizontal] = props.marginInline</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">if </span><span class="s1">(!props.marginInlineStart.isUndefined()) {</span>
    <span class="s1">result.margin()[YGEdgeStart] = props.marginInlineStart</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">if </span><span class="s1">(!props.marginInlineEnd.isUndefined()) {</span>
    <span class="s1">result.margin()[YGEdgeEnd] = props.marginInlineEnd</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">if </span><span class="s1">(!props.marginBlock.isUndefined()) {</span>
    <span class="s1">result.margin()[YGEdgeVertical] = props.marginBlock</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">if </span><span class="s1">(!props.paddingInline.isUndefined()) {</span>
    <span class="s1">result.padding()[YGEdgeHorizontal] = props.paddingInline</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">if </span><span class="s1">(!props.paddingInlineStart.isUndefined()) {</span>
    <span class="s1">result.padding()[YGEdgeStart] = props.paddingInlineStart</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">if </span><span class="s1">(!props.paddingInlineEnd.isUndefined()) {</span>
    <span class="s1">result.padding()[YGEdgeEnd] = props.paddingInlineEnd</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">if </span><span class="s1">(!props.paddingBlock.isUndefined()) {</span>
    <span class="s1">result.padding()[YGEdgeVertical] = props.paddingBlock</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">// Aliases without precedence</span>
  <span class="s4">if </span><span class="s1">(CompactValue(result.margin()[YGEdgeTop]).isUndefined()) {</span>
    <span class="s1">result.margin()[YGEdgeTop] = props.marginBlockStart</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">if </span><span class="s1">(CompactValue(result.margin()[YGEdgeBottom]).isUndefined()) {</span>
    <span class="s1">result.margin()[YGEdgeBottom] = props.marginBlockEnd</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">if </span><span class="s1">(CompactValue(result.padding()[YGEdgeTop]).isUndefined()) {</span>
    <span class="s1">result.padding()[YGEdgeTop] = props.paddingBlockStart</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">if </span><span class="s1">(CompactValue(result.padding()[YGEdgeBottom]).isUndefined()) {</span>
    <span class="s1">result.padding()[YGEdgeBottom] = props.paddingBlockEnd</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">return </span><span class="s1">result</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">YogaLayoutableShadowNode::setSize(Size size) </span><span class="s4">const </span><span class="s1">{</span>
  <span class="s1">ensureUnsealed()</span><span class="s4">;</span>

  <span class="s4">auto </span><span class="s1">style = yogaNode_.getStyle()</span><span class="s4">;</span>
  <span class="s1">style.dimensions()[YGDimensionWidth] = yogaStyleValueFromFloat(size.width)</span><span class="s4">;</span>
  <span class="s1">style.dimensions()[YGDimensionHeight] = yogaStyleValueFromFloat(size.height)</span><span class="s4">;</span>
  <span class="s1">yogaNode_.setStyle(style)</span><span class="s4">;</span>
  <span class="s1">yogaNode_.setDirty(</span><span class="s4">true</span><span class="s1">)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">YogaLayoutableShadowNode::setPadding(RectangleEdges&lt;Float&gt; padding) </span><span class="s4">const </span><span class="s1">{</span>
  <span class="s1">ensureUnsealed()</span><span class="s4">;</span>

  <span class="s4">auto </span><span class="s1">style = yogaNode_.getStyle()</span><span class="s4">;</span>

  <span class="s4">auto </span><span class="s1">leftPadding = yogaStyleValueFromFloat(padding.left)</span><span class="s4">;</span>
  <span class="s4">auto </span><span class="s1">topPadding = yogaStyleValueFromFloat(padding.top)</span><span class="s4">;</span>
  <span class="s4">auto </span><span class="s1">rightPadding = yogaStyleValueFromFloat(padding.right)</span><span class="s4">;</span>
  <span class="s4">auto </span><span class="s1">bottomPadding = yogaStyleValueFromFloat(padding.bottom)</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(leftPadding != style.padding()[YGEdgeLeft] ||</span>
      <span class="s1">topPadding != style.padding()[YGEdgeTop] ||</span>
      <span class="s1">rightPadding != style.padding()[YGEdgeRight] ||</span>
      <span class="s1">bottomPadding != style.padding()[YGEdgeBottom]) {</span>
    <span class="s1">style.padding()[YGEdgeTop] = yogaStyleValueFromFloat(padding.top)</span><span class="s4">;</span>
    <span class="s1">style.padding()[YGEdgeLeft] = yogaStyleValueFromFloat(padding.left)</span><span class="s4">;</span>
    <span class="s1">style.padding()[YGEdgeRight] = yogaStyleValueFromFloat(padding.right)</span><span class="s4">;</span>
    <span class="s1">style.padding()[YGEdgeBottom] = yogaStyleValueFromFloat(padding.bottom)</span><span class="s4">;</span>
    <span class="s1">yogaNode_.setStyle(style)</span><span class="s4">;</span>
    <span class="s1">yogaNode_.setDirty(</span><span class="s4">true</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">YogaLayoutableShadowNode::setPositionType(</span>
    <span class="s1">YGPositionType positionType) </span><span class="s4">const </span><span class="s1">{</span>
  <span class="s1">ensureUnsealed()</span><span class="s4">;</span>

  <span class="s4">auto </span><span class="s1">style = yogaNode_.getStyle()</span><span class="s4">;</span>
  <span class="s1">style.positionType() = positionType</span><span class="s4">;</span>
  <span class="s1">yogaNode_.setStyle(style)</span><span class="s4">;</span>
  <span class="s1">yogaNode_.setDirty(</span><span class="s4">true</span><span class="s1">)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">YogaLayoutableShadowNode::layoutTree(</span>
    <span class="s1">LayoutContext layoutContext</span><span class="s4">,</span>
    <span class="s1">LayoutConstraints layoutConstraints) {</span>
  <span class="s1">ensureUnsealed()</span><span class="s4">;</span>

  <span class="s0">/* 
   * In Yoga, every single Yoga Node has to have a (non-null) pointer to 
   * Yoga Config (this config can be shared between many nodes), 
   * so every node can be individually configured. This does *not* mean 
   * however that Yoga consults with every single Yoga Node Config for every 
   * config parameter. Especially in case of `pointScaleFactor`, 
   * the only value in the config of the root node is taken into account 
   * (and this is by design). 
   */</span>
  <span class="s1">yogaConfig_.pointScaleFactor = layoutContext.pointScaleFactor</span><span class="s4">;</span>

  <span class="s4">auto </span><span class="s1">minimumSize = layoutConstraints.minimumSize</span><span class="s4">;</span>
  <span class="s4">auto </span><span class="s1">maximumSize = layoutConstraints.maximumSize</span><span class="s4">;</span>

  <span class="s0">// The caller must ensure that layout constraints make sense.</span>
  <span class="s0">// Values cannot be NaN.</span>
  <span class="s1">react_native_assert(!std::isnan(minimumSize.width))</span><span class="s4">;</span>
  <span class="s1">react_native_assert(!std::isnan(minimumSize.height))</span><span class="s4">;</span>
  <span class="s1">react_native_assert(!std::isnan(maximumSize.width))</span><span class="s4">;</span>
  <span class="s1">react_native_assert(!std::isnan(maximumSize.height))</span><span class="s4">;</span>
  <span class="s0">// Values cannot be negative.</span>
  <span class="s1">react_native_assert(minimumSize.width &gt;= </span><span class="s5">0</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">react_native_assert(minimumSize.height &gt;= </span><span class="s5">0</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">react_native_assert(maximumSize.width &gt;= </span><span class="s5">0</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">react_native_assert(maximumSize.height &gt;= </span><span class="s5">0</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s0">// Minimum size cannot be infinity.</span>
  <span class="s1">react_native_assert(!std::isinf(minimumSize.width))</span><span class="s4">;</span>
  <span class="s1">react_native_assert(!std::isinf(minimumSize.height))</span><span class="s4">;</span>

  <span class="s0">// Internally Yoga uses three different measurement modes controlling layout</span>
  <span class="s0">// constraints: `Undefined`, `Exactly`, and `AtMost`. These modes are an</span>
  <span class="s0">// implementation detail and are not defined in `CSS Flexible Box Layout</span>
  <span class="s0">// Module`. Yoga C++ API (and `YGNodeCalculateLayout` function particularly)</span>
  <span class="s0">// does not allow to specify the measure modes explicitly. Instead, it infers</span>
  <span class="s0">// these from styles associated with the root node.</span>
  <span class="s0">// To pass the actual layout constraints to Yoga we represent them as</span>
  <span class="s0">// `(min/max)(Height/Width)` style properties. Also, we pass `ownerWidth` &amp;</span>
  <span class="s0">// `ownerHeight` to allow proper calculation of relative (e.g. specified in</span>
  <span class="s0">// percents) style values.</span>

  <span class="s4">auto </span><span class="s1">&amp;yogaStyle = yogaNode_.getStyle()</span><span class="s4">;</span>

  <span class="s4">auto </span><span class="s1">ownerWidth = yogaFloatFromFloat(maximumSize.width)</span><span class="s4">;</span>
  <span class="s4">auto </span><span class="s1">ownerHeight = yogaFloatFromFloat(maximumSize.height)</span><span class="s4">;</span>

  <span class="s1">yogaStyle.maxDimensions()[YGDimensionWidth] = std::isfinite(maximumSize.width)</span>
      <span class="s1">? yogaStyleValueFromFloat(maximumSize.width)</span>
      <span class="s1">: YGValueUndefined</span><span class="s4">;</span>

  <span class="s1">yogaStyle.maxDimensions()[YGDimensionHeight] =</span>
      <span class="s1">std::isfinite(maximumSize.height)</span>
      <span class="s1">? yogaStyleValueFromFloat(maximumSize.height)</span>
      <span class="s1">: YGValueUndefined</span><span class="s4">;</span>

  <span class="s1">yogaStyle.minDimensions()[YGDimensionWidth] = minimumSize.width &gt; </span><span class="s5">0</span>
      <span class="s1">? yogaStyleValueFromFloat(minimumSize.width)</span>
      <span class="s1">: YGValueUndefined</span><span class="s4">;</span>

  <span class="s1">yogaStyle.minDimensions()[YGDimensionHeight] = minimumSize.height &gt; </span><span class="s5">0</span>
      <span class="s1">? yogaStyleValueFromFloat(minimumSize.height)</span>
      <span class="s1">: YGValueUndefined</span><span class="s4">;</span>

  <span class="s4">auto </span><span class="s1">direction =</span>
      <span class="s1">yogaDirectionFromLayoutDirection(layoutConstraints.layoutDirection)</span><span class="s4">;</span>

  <span class="s1">threadLocalLayoutContext = layoutContext</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(layoutContext.swapLeftAndRightInRTL) {</span>
    <span class="s1">swapLeftAndRightInTree(*</span><span class="s4">this</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">{</span>
    <span class="s1">SystraceSection s(</span><span class="s3">&quot;YogaLayoutableShadowNode::YGNodeCalculateLayout&quot;</span><span class="s1">)</span><span class="s4">;</span>
    <span class="s1">YGNodeCalculateLayout(&amp;yogaNode_</span><span class="s4">, </span><span class="s1">ownerWidth</span><span class="s4">, </span><span class="s1">ownerHeight</span><span class="s4">, </span><span class="s1">direction)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(yogaNode_.getHasNewLayout()) {</span>
    <span class="s4">auto </span><span class="s1">layoutMetrics = layoutMetricsFromYogaNode(yogaNode_)</span><span class="s4">;</span>
    <span class="s1">layoutMetrics.pointScaleFactor = layoutContext.pointScaleFactor</span><span class="s4">;</span>
    <span class="s1">setLayoutMetrics(layoutMetrics)</span><span class="s4">;</span>
    <span class="s1">yogaNode_.setHasNewLayout(</span><span class="s4">false</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">layout(layoutContext)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">static </span><span class="s1">EdgeInsets calculateOverflowInset(</span>
    <span class="s1">Rect containerFrame</span><span class="s4">,</span>
    <span class="s1">Rect contentFrame) {</span>
  <span class="s4">auto </span><span class="s1">size = containerFrame.size</span><span class="s4">;</span>
  <span class="s4">auto </span><span class="s1">overflowInset = EdgeInsets{}</span><span class="s4">;</span>
  <span class="s1">overflowInset.left = std::min(contentFrame.getMinX()</span><span class="s4">, </span><span class="s1">Float{</span><span class="s5">0.0</span><span class="s1">})</span><span class="s4">;</span>
  <span class="s1">overflowInset.top = std::min(contentFrame.getMinY()</span><span class="s4">, </span><span class="s1">Float{</span><span class="s5">0.0</span><span class="s1">})</span><span class="s4">;</span>
  <span class="s1">overflowInset.right =</span>
      <span class="s1">-std::max(contentFrame.getMaxX() - size.width</span><span class="s4">, </span><span class="s1">Float{</span><span class="s5">0.0</span><span class="s1">})</span><span class="s4">;</span>
  <span class="s1">overflowInset.bottom =</span>
      <span class="s1">-std::max(contentFrame.getMaxY() - size.height</span><span class="s4">, </span><span class="s1">Float{</span><span class="s5">0.0</span><span class="s1">})</span><span class="s4">;</span>
  <span class="s4">return </span><span class="s1">overflowInset</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">YogaLayoutableShadowNode::layout(LayoutContext layoutContext) {</span>
  <span class="s0">// Reading data from a dirtied node does not make sense.</span>
  <span class="s1">react_native_assert(!yogaNode_.isDirty())</span><span class="s4">;</span>

  <span class="s4">auto </span><span class="s1">contentFrame = Rect{}</span><span class="s4">;</span>
  <span class="s4">for </span><span class="s1">(</span><span class="s4">auto </span><span class="s1">childYogaNode : yogaNode_.getChildren()) {</span>
    <span class="s4">auto </span><span class="s1">&amp;childNode = shadowNodeFromContext(childYogaNode)</span><span class="s4">;</span>

    <span class="s0">// Verifying that the Yoga node belongs to the ShadowNode.</span>
    <span class="s1">react_native_assert(&amp;childNode.yogaNode_ == childYogaNode)</span><span class="s4">;</span>

    <span class="s4">if </span><span class="s1">(childYogaNode-&gt;getHasNewLayout()) {</span>
      <span class="s1">childYogaNode-&gt;setHasNewLayout(</span><span class="s4">false</span><span class="s1">)</span><span class="s4">;</span>

      <span class="s0">// Reading data from a dirtied node does not make sense.</span>
      <span class="s1">react_native_assert(!childYogaNode-&gt;isDirty())</span><span class="s4">;</span>

      <span class="s0">// We must copy layout metrics from Yoga node only once (when the parent</span>
      <span class="s0">// node exclusively ownes the child node).</span>
      <span class="s1">react_native_assert(childYogaNode-&gt;getOwner() == &amp;yogaNode_)</span><span class="s4">;</span>

      <span class="s0">// We are about to mutate layout metrics of the node.</span>
      <span class="s1">childNode.ensureUnsealed()</span><span class="s4">;</span>

      <span class="s4">auto </span><span class="s1">newLayoutMetrics = layoutMetricsFromYogaNode(*childYogaNode)</span><span class="s4">;</span>
      <span class="s1">newLayoutMetrics.pointScaleFactor = layoutContext.pointScaleFactor</span><span class="s4">;</span>

      <span class="s0">// Child node's layout has changed. When a node is added to</span>
      <span class="s0">// `affectedNodes`, onLayout event is called on the component. Comparing</span>
      <span class="s0">// `newLayoutMetrics.frame` with `childNode.getLayoutMetrics().frame` to</span>
      <span class="s0">// detect if layout has not changed is not advised, please refer to</span>
      <span class="s0">// D22999891 for details.</span>
      <span class="s4">if </span><span class="s1">(layoutContext.affectedNodes != </span><span class="s4">nullptr</span><span class="s1">) {</span>
        <span class="s1">layoutContext.affectedNodes-&gt;push_back(&amp;childNode)</span><span class="s4">;</span>
      <span class="s1">}</span>

      <span class="s1">childNode.setLayoutMetrics(newLayoutMetrics)</span><span class="s4">;</span>

      <span class="s4">if </span><span class="s1">(newLayoutMetrics.displayType != DisplayType::None) {</span>
        <span class="s1">childNode.layout(layoutContext)</span><span class="s4">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s4">auto </span><span class="s1">layoutMetricsWithOverflowInset = childNode.getLayoutMetrics()</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">(layoutMetricsWithOverflowInset.displayType != DisplayType::None) {</span>
      <span class="s4">auto </span><span class="s1">viewChildNode = traitCast&lt;ViewShadowNode </span><span class="s4">const </span><span class="s1">*&gt;(&amp;childNode)</span><span class="s4">;</span>
      <span class="s4">auto </span><span class="s1">hitSlop = viewChildNode != </span><span class="s4">nullptr</span>
          <span class="s1">? viewChildNode-&gt;getConcreteProps().hitSlop</span>
          <span class="s1">: EdgeInsets{}</span><span class="s4">;</span>

      <span class="s0">// The contentFrame should always union with existing child node layout +</span>
      <span class="s0">// overflowInset. The transform may in a deferred animation and not</span>
      <span class="s0">// applied yet.</span>
      <span class="s1">contentFrame.unionInPlace(insetBy(</span>
          <span class="s1">layoutMetricsWithOverflowInset.frame</span><span class="s4">,</span>
          <span class="s1">layoutMetricsWithOverflowInset.overflowInset))</span><span class="s4">;</span>
      <span class="s1">contentFrame.unionInPlace(</span>
          <span class="s1">outsetBy(layoutMetricsWithOverflowInset.frame</span><span class="s4">, </span><span class="s1">hitSlop))</span><span class="s4">;</span>

      <span class="s4">auto </span><span class="s1">childTransform = childNode.getTransform()</span><span class="s4">;</span>
      <span class="s4">if </span><span class="s1">(childTransform != Transform::Identity()) {</span>
        <span class="s0">// The child node's transform matrix will affect the parent node's</span>
        <span class="s0">// contentFrame. We need to union with child node's after transform</span>
        <span class="s0">// layout here.</span>
        <span class="s1">contentFrame.unionInPlace(insetBy(</span>
            <span class="s1">layoutMetricsWithOverflowInset.frame * childTransform</span><span class="s4">,</span>
            <span class="s1">layoutMetricsWithOverflowInset.overflowInset * childTransform))</span><span class="s4">;</span>
        <span class="s1">contentFrame.unionInPlace(outsetBy(</span>
            <span class="s1">layoutMetricsWithOverflowInset.frame * childTransform</span><span class="s4">, </span><span class="s1">hitSlop))</span><span class="s4">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(yogaNode_.getStyle().overflow() == YGOverflowVisible) {</span>
    <span class="s0">// Note that the parent node's overflow layout is NOT affected by its</span>
    <span class="s0">// transform matrix. That transform matrix is applied on the parent node as</span>
    <span class="s0">// well as all of its child nodes, which won't cause changes on the</span>
    <span class="s0">// overflowInset values. A special note on the scale transform -- the scaled</span>
    <span class="s0">// layout may look like it's causing overflowInset changes, but it's purely</span>
    <span class="s0">// cosmetic and will be handled by pixel density conversion logic later when</span>
    <span class="s0">// render the view. The actual overflowInset value is not changed as if the</span>
    <span class="s0">// transform is not happening here.</span>
    <span class="s1">layoutMetrics_.overflowInset =</span>
        <span class="s1">calculateOverflowInset(layoutMetrics_.frame</span><span class="s4">, </span><span class="s1">contentFrame)</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s1">layoutMetrics_.overflowInset = {}</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">#pragma </span><span class="s1">mark - Yoga Connectors</span>

<span class="s1">YGNode *YogaLayoutableShadowNode::yogaNodeCloneCallbackConnector(</span>
    <span class="s1">YGNode *oldYogaNode</span><span class="s4">,</span>
    <span class="s1">YGNode *parentYogaNode</span><span class="s4">,</span>
    <span class="s4">int </span><span class="s1">childIndex) {</span>
  <span class="s1">SystraceSection s(</span><span class="s3">&quot;YogaLayoutableShadowNode::yogaNodeCloneCallbackConnector&quot;</span><span class="s1">)</span><span class="s4">;</span>

  <span class="s0">// At this point it is guaranteed that all shadow nodes associated with yoga</span>
  <span class="s0">// nodes are `YogaLayoutableShadowNode` subclasses.</span>
  <span class="s4">auto </span><span class="s1">&amp;parentNode = shadowNodeFromContext(parentYogaNode)</span><span class="s4">;</span>
  <span class="s4">auto </span><span class="s1">&amp;oldNode = shadowNodeFromContext(oldYogaNode)</span><span class="s4">;</span>

  <span class="s4">auto </span><span class="s1">clonedNode = oldNode.clone(</span>
      <span class="s1">{ShadowNodeFragment::propsPlaceholder()</span><span class="s4">,</span>
       <span class="s1">ShadowNodeFragment::childrenPlaceholder()</span><span class="s4">,</span>
       <span class="s1">oldNode.getState()})</span><span class="s4">;</span>
  <span class="s1">parentNode.replaceChild(oldNode</span><span class="s4">, </span><span class="s1">clonedNode</span><span class="s4">, </span><span class="s1">childIndex)</span><span class="s4">;</span>
  <span class="s4">return </span><span class="s1">&amp;traitCast&lt;YogaLayoutableShadowNode &amp;&gt;(*clonedNode).yogaNode_</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">YGSize YogaLayoutableShadowNode::yogaNodeMeasureCallbackConnector(</span>
    <span class="s1">YGNode *yogaNode</span><span class="s4">,</span>
    <span class="s4">float </span><span class="s1">width</span><span class="s4">,</span>
    <span class="s1">YGMeasureMode widthMode</span><span class="s4">,</span>
    <span class="s4">float </span><span class="s1">height</span><span class="s4">,</span>
    <span class="s1">YGMeasureMode heightMode) {</span>
  <span class="s1">SystraceSection s(</span>
      <span class="s3">&quot;YogaLayoutableShadowNode::yogaNodeMeasureCallbackConnector&quot;</span><span class="s1">)</span><span class="s4">;</span>

  <span class="s4">auto </span><span class="s1">&amp;shadowNode = shadowNodeFromContext(yogaNode)</span><span class="s4">;</span>

  <span class="s4">auto </span><span class="s1">minimumSize = Size{</span><span class="s5">0</span><span class="s4">, </span><span class="s5">0</span><span class="s1">}</span><span class="s4">;</span>
  <span class="s4">auto </span><span class="s1">maximumSize = Size{</span>
      <span class="s1">std::numeric_limits&lt;Float&gt;::infinity()</span><span class="s4">,</span>
      <span class="s1">std::numeric_limits&lt;Float&gt;::infinity()}</span><span class="s4">;</span>

  <span class="s4">switch </span><span class="s1">(widthMode) {</span>
    <span class="s4">case </span><span class="s1">YGMeasureModeUndefined:</span>
      <span class="s4">break;</span>
    <span class="s4">case </span><span class="s1">YGMeasureModeExactly:</span>
      <span class="s1">minimumSize.width = floatFromYogaFloat(width)</span><span class="s4">;</span>
      <span class="s1">maximumSize.width = floatFromYogaFloat(width)</span><span class="s4">;</span>
      <span class="s4">break;</span>
    <span class="s4">case </span><span class="s1">YGMeasureModeAtMost:</span>
      <span class="s1">maximumSize.width = floatFromYogaFloat(width)</span><span class="s4">;</span>
      <span class="s4">break;</span>
  <span class="s1">}</span>

  <span class="s4">switch </span><span class="s1">(heightMode) {</span>
    <span class="s4">case </span><span class="s1">YGMeasureModeUndefined:</span>
      <span class="s4">break;</span>
    <span class="s4">case </span><span class="s1">YGMeasureModeExactly:</span>
      <span class="s1">minimumSize.height = floatFromYogaFloat(height)</span><span class="s4">;</span>
      <span class="s1">maximumSize.height = floatFromYogaFloat(height)</span><span class="s4">;</span>
      <span class="s4">break;</span>
    <span class="s4">case </span><span class="s1">YGMeasureModeAtMost:</span>
      <span class="s1">maximumSize.height = floatFromYogaFloat(height)</span><span class="s4">;</span>
      <span class="s4">break;</span>
  <span class="s1">}</span>

  <span class="s4">auto </span><span class="s1">size = shadowNode.measureContent(</span>
      <span class="s1">threadLocalLayoutContext</span><span class="s4">, </span><span class="s1">{minimumSize</span><span class="s4">, </span><span class="s1">maximumSize})</span><span class="s4">;</span>

  <span class="s4">return </span><span class="s1">YGSize{</span>
      <span class="s1">yogaFloatFromFloat(size.width)</span><span class="s4">, </span><span class="s1">yogaFloatFromFloat(size.height)}</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">YogaLayoutableShadowNode &amp;YogaLayoutableShadowNode::shadowNodeFromContext(</span>
    <span class="s1">YGNode *yogaNode) {</span>
  <span class="s4">return </span><span class="s1">traitCast&lt;YogaLayoutableShadowNode &amp;&gt;(</span>
      <span class="s1">*</span><span class="s4">static_cast</span><span class="s1">&lt;ShadowNode *&gt;(yogaNode-&gt;getContext()))</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">YGConfig &amp;YogaLayoutableShadowNode::initializeYogaConfig(YGConfig &amp;config) {</span>
  <span class="s1">config.setCloneNodeCallback(</span>
      <span class="s1">YogaLayoutableShadowNode::yogaNodeCloneCallbackConnector)</span><span class="s4">;</span>
  <span class="s1">config.useLegacyStretchBehaviour = </span><span class="s4">true;</span>
<span class="s2">#ifdef </span><span class="s1">RN_DEBUG_YOGA_LOGGER</span>
  <span class="s1">config.printTree = </span><span class="s4">true;</span>
<span class="s2">#endif</span>
  <span class="s4">return </span><span class="s1">config</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s2">#pragma </span><span class="s1">mark - RTL left </span><span class="s4">and </span><span class="s1">right swapping</span>

<span class="s4">void </span><span class="s1">YogaLayoutableShadowNode::swapLeftAndRightInTree(</span>
    <span class="s1">YogaLayoutableShadowNode </span><span class="s4">const </span><span class="s1">&amp;shadowNode) {</span>
  <span class="s1">swapLeftAndRightInYogaStyleProps(shadowNode)</span><span class="s4">;</span>
  <span class="s1">swapLeftAndRightInViewProps(shadowNode)</span><span class="s4">;</span>

  <span class="s4">for </span><span class="s1">(</span><span class="s4">auto </span><span class="s1">&amp;child : shadowNode.yogaLayoutableChildren_) {</span>
    <span class="s4">if </span><span class="s1">(!child-&gt;doesOwn(shadowNode)) {</span>
      <span class="s1">swapLeftAndRightInTree(*child)</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">YogaLayoutableShadowNode::swapLeftAndRightInYogaStyleProps(</span>
    <span class="s1">YogaLayoutableShadowNode </span><span class="s4">const </span><span class="s1">&amp;shadowNode) {</span>
  <span class="s4">auto </span><span class="s1">yogaStyle = shadowNode.yogaNode_.getStyle()</span><span class="s4">;</span>

  <span class="s1">YGStyle::Edges </span><span class="s4">const </span><span class="s1">&amp;position = yogaStyle.position()</span><span class="s4">;</span>
  <span class="s1">YGStyle::Edges </span><span class="s4">const </span><span class="s1">&amp;padding = yogaStyle.padding()</span><span class="s4">;</span>
  <span class="s1">YGStyle::Edges </span><span class="s4">const </span><span class="s1">&amp;margin = yogaStyle.margin()</span><span class="s4">;</span>

  <span class="s0">// Swap Yoga node values, position, padding and margin.</span>

  <span class="s4">if </span><span class="s1">(yogaStyle.position()[YGEdgeLeft] != YGValueUndefined) {</span>
    <span class="s1">yogaStyle.position()[YGEdgeStart] = position[YGEdgeLeft]</span><span class="s4">;</span>
    <span class="s1">yogaStyle.position()[YGEdgeLeft] = YGValueUndefined</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(yogaStyle.position()[YGEdgeRight] != YGValueUndefined) {</span>
    <span class="s1">yogaStyle.position()[YGEdgeEnd] = position[YGEdgeRight]</span><span class="s4">;</span>
    <span class="s1">yogaStyle.position()[YGEdgeRight] = YGValueUndefined</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(yogaStyle.padding()[YGEdgeLeft] != YGValueUndefined) {</span>
    <span class="s1">yogaStyle.padding()[YGEdgeStart] = padding[YGEdgeLeft]</span><span class="s4">;</span>
    <span class="s1">yogaStyle.padding()[YGEdgeLeft] = YGValueUndefined</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(yogaStyle.padding()[YGEdgeRight] != YGValueUndefined) {</span>
    <span class="s1">yogaStyle.padding()[YGEdgeEnd] = padding[YGEdgeRight]</span><span class="s4">;</span>
    <span class="s1">yogaStyle.padding()[YGEdgeRight] = YGValueUndefined</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(yogaStyle.margin()[YGEdgeLeft] != YGValueUndefined) {</span>
    <span class="s1">yogaStyle.margin()[YGEdgeStart] = margin[YGEdgeLeft]</span><span class="s4">;</span>
    <span class="s1">yogaStyle.margin()[YGEdgeLeft] = YGValueUndefined</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(yogaStyle.margin()[YGEdgeRight] != YGValueUndefined) {</span>
    <span class="s1">yogaStyle.margin()[YGEdgeEnd] = margin[YGEdgeRight]</span><span class="s4">;</span>
    <span class="s1">yogaStyle.margin()[YGEdgeRight] = YGValueUndefined</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">shadowNode.yogaNode_.setStyle(yogaStyle)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">YogaLayoutableShadowNode::swapLeftAndRightInViewProps(</span>
    <span class="s1">YogaLayoutableShadowNode </span><span class="s4">const </span><span class="s1">&amp;shadowNode) {</span>
  <span class="s4">auto </span><span class="s1">&amp;typedCasting = </span><span class="s4">static_cast</span><span class="s1">&lt;ViewProps </span><span class="s4">const </span><span class="s1">&amp;&gt;(*shadowNode.props_)</span><span class="s4">;</span>
  <span class="s4">auto </span><span class="s1">&amp;props = </span><span class="s4">const_cast</span><span class="s1">&lt;ViewProps &amp;&gt;(typedCasting)</span><span class="s4">;</span>

  <span class="s0">// Swap border node values, borderRadii, borderColors and borderStyles.</span>

  <span class="s4">if </span><span class="s1">(props.borderRadii.topLeft.has_value()) {</span>
    <span class="s1">props.borderRadii.topStart = props.borderRadii.topLeft</span><span class="s4">;</span>
    <span class="s1">props.borderRadii.topLeft.reset()</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(props.borderRadii.bottomLeft.has_value()) {</span>
    <span class="s1">props.borderRadii.bottomStart = props.borderRadii.bottomLeft</span><span class="s4">;</span>
    <span class="s1">props.borderRadii.bottomLeft.reset()</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(props.borderRadii.topRight.has_value()) {</span>
    <span class="s1">props.borderRadii.topEnd = props.borderRadii.topRight</span><span class="s4">;</span>
    <span class="s1">props.borderRadii.topRight.reset()</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(props.borderRadii.bottomRight.has_value()) {</span>
    <span class="s1">props.borderRadii.bottomEnd = props.borderRadii.bottomRight</span><span class="s4">;</span>
    <span class="s1">props.borderRadii.bottomRight.reset()</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(props.borderColors.left.has_value()) {</span>
    <span class="s1">props.borderColors.start = props.borderColors.left</span><span class="s4">;</span>
    <span class="s1">props.borderColors.left.reset()</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(props.borderColors.right.has_value()) {</span>
    <span class="s1">props.borderColors.end = props.borderColors.right</span><span class="s4">;</span>
    <span class="s1">props.borderColors.right.reset()</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(props.borderStyles.left.has_value()) {</span>
    <span class="s1">props.borderStyles.start = props.borderStyles.left</span><span class="s4">;</span>
    <span class="s1">props.borderStyles.left.reset()</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(props.borderStyles.right.has_value()) {</span>
    <span class="s1">props.borderStyles.end = props.borderStyles.right</span><span class="s4">;</span>
    <span class="s1">props.borderStyles.right.reset()</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">YGStyle::Edges </span><span class="s4">const </span><span class="s1">&amp;border = props.yogaStyle.border()</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(props.yogaStyle.border()[YGEdgeLeft] != YGValueUndefined) {</span>
    <span class="s1">props.yogaStyle.border()[YGEdgeStart] = border[YGEdgeLeft]</span><span class="s4">;</span>
    <span class="s1">props.yogaStyle.border()[YGEdgeLeft] = YGValueUndefined</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(props.yogaStyle.border()[YGEdgeRight] != YGValueUndefined) {</span>
    <span class="s1">props.yogaStyle.border()[YGEdgeEnd] = border[YGEdgeRight]</span><span class="s4">;</span>
    <span class="s1">props.yogaStyle.border()[YGEdgeRight] = YGValueUndefined</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">#pragma </span><span class="s1">mark - Consistency Ensuring Helpers</span>

<span class="s4">void </span><span class="s1">YogaLayoutableShadowNode::ensureConsistency() </span><span class="s4">const </span><span class="s1">{</span>
  <span class="s1">ensureYogaChildrenLookFine()</span><span class="s4">;</span>
  <span class="s1">ensureYogaChildrenAlignment()</span><span class="s4">;</span>
  <span class="s1">ensureYogaChildrenOwnersConsistency()</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">YogaLayoutableShadowNode::ensureYogaChildrenOwnersConsistency() </span><span class="s4">const </span><span class="s1">{</span>
<span class="s2">#ifdef </span><span class="s1">REACT_NATIVE_DEBUG</span>
  <span class="s0">// Checking that all Yoga node children have the same `owner`.</span>
  <span class="s0">// The owner might be not equal to the `yogaNode_` though.</span>
  <span class="s4">auto </span><span class="s1">&amp;yogaChildren = yogaNode_.getChildren()</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(!yogaChildren.empty()) {</span>
    <span class="s4">auto </span><span class="s1">owner = yogaChildren.at(</span><span class="s5">0</span><span class="s1">)-&gt;getOwner()</span><span class="s4">;</span>
    <span class="s4">for </span><span class="s1">(</span><span class="s4">auto const </span><span class="s1">&amp;child : yogaChildren) {</span>
      <span class="s1">react_native_assert(child-&gt;getOwner() == owner)</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s2">#endif</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">YogaLayoutableShadowNode::ensureYogaChildrenLookFine() </span><span class="s4">const </span><span class="s1">{</span>
<span class="s2">#ifdef </span><span class="s1">REACT_NATIVE_DEBUG</span>
  <span class="s0">// Checking that the shapes of Yoga node children object look fine.</span>
  <span class="s0">// This is the only heuristic that might produce false-positive results</span>
  <span class="s0">// (really broken dangled nodes might look fine). This is useful as an early</span>
  <span class="s0">// signal that something went wrong.</span>
  <span class="s4">auto </span><span class="s1">&amp;yogaChildren = yogaNode_.getChildren()</span><span class="s4">;</span>

  <span class="s4">for </span><span class="s1">(</span><span class="s4">auto const </span><span class="s1">&amp;yogaChild : yogaChildren) {</span>
    <span class="s1">react_native_assert(yogaChild-&gt;getContext())</span><span class="s4">;</span>
    <span class="s1">react_native_assert(yogaChild-&gt;getChildren().size() &lt; </span><span class="s5">16384</span><span class="s1">)</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">(!yogaChild-&gt;getChildren().empty()) {</span>
      <span class="s1">react_native_assert(!yogaChild-&gt;hasMeasureFunc())</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s2">#endif</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">YogaLayoutableShadowNode::ensureYogaChildrenAlignment() </span><span class="s4">const </span><span class="s1">{</span>
<span class="s2">#ifdef </span><span class="s1">REACT_NATIVE_DEBUG</span>
  <span class="s0">// If the node is not a leaf node, checking that:</span>
  <span class="s0">// - All children are `YogaLayoutableShadowNode` subclasses.</span>
  <span class="s0">// - All Yoga children are owned/connected to corresponding children of</span>
  <span class="s0">//   this node.</span>

  <span class="s4">auto </span><span class="s1">&amp;yogaChildren = yogaNode_.getChildren()</span><span class="s4">;</span>
  <span class="s4">auto </span><span class="s1">&amp;children = yogaLayoutableChildren_</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(getTraits().check(ShadowNodeTraits::Trait::LeafYogaNode)) {</span>
    <span class="s1">react_native_assert(yogaChildren.empty())</span><span class="s4">;</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>

  <span class="s1">react_native_assert(yogaChildren.size() == children.size())</span><span class="s4">;</span>

  <span class="s4">for </span><span class="s1">(size_t i = </span><span class="s5">0</span><span class="s4">; </span><span class="s1">i &lt; children.size()</span><span class="s4">; </span><span class="s1">i++) {</span>
    <span class="s4">auto </span><span class="s1">&amp;yogaChild = yogaChildren.at(i)</span><span class="s4">;</span>
    <span class="s4">auto </span><span class="s1">&amp;child = children.at(i)</span><span class="s4">;</span>
    <span class="s1">react_native_assert(</span>
        <span class="s1">yogaChild-&gt;getContext() ==</span>
        <span class="s1">traitCast&lt;YogaLayoutableShadowNode </span><span class="s4">const </span><span class="s1">*&gt;(child.get()))</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s2">#endif</span>
<span class="s1">}</span>

<span class="s1">} </span><span class="s0">// namespace facebook::react</span>
</pre>
</body>
</html>
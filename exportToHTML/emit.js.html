<html>
<head>
<title>emit.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
emit.js</font>
</center></td></tr></table>
<pre><span class="s0">/** 
 * Copyright (c) 2014-present, Facebook, Inc. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>

<span class="s1">import assert from </span><span class="s2">&quot;assert&quot;</span><span class="s1">;</span>
<span class="s1">import * as leap from </span><span class="s2">&quot;./leap&quot;</span><span class="s1">;</span>
<span class="s1">import * as meta from </span><span class="s2">&quot;./meta&quot;</span><span class="s1">;</span>
<span class="s1">import * as util from </span><span class="s2">&quot;./util&quot;</span><span class="s1">;</span>

<span class="s1">let hasOwn = Object.prototype.hasOwnProperty;</span>

<span class="s3">function </span><span class="s1">Emitter(contextId) {</span>
  <span class="s1">assert.ok(</span><span class="s3">this instanceof </span><span class="s1">Emitter);</span>

  <span class="s1">util.getTypes().assertIdentifier(contextId);</span>

  <span class="s0">// Used to generate unique temporary names.</span>
  <span class="s3">this</span><span class="s1">.nextTempId = </span><span class="s4">0</span><span class="s1">;</span>

  <span class="s0">// In order to make sure the context object does not collide with</span>
  <span class="s0">// anything in the local scope, we might have to rename it, so we</span>
  <span class="s0">// refer to it symbolically instead of just assuming that it will be</span>
  <span class="s0">// called &quot;context&quot;.</span>
  <span class="s3">this</span><span class="s1">.contextId = contextId;</span>

  <span class="s0">// An append-only list of Statements that grows each time this.emit is</span>
  <span class="s0">// called.</span>
  <span class="s3">this</span><span class="s1">.listing = [];</span>

  <span class="s0">// A sparse array whose keys correspond to locations in this.listing</span>
  <span class="s0">// that have been marked as branch/jump targets.</span>
  <span class="s3">this</span><span class="s1">.marked = [</span><span class="s3">true</span><span class="s1">];</span>

  <span class="s3">this</span><span class="s1">.insertedLocs = </span><span class="s3">new </span><span class="s1">Set();</span>

  <span class="s0">// The last location will be marked when this.getDispatchLoop is</span>
  <span class="s0">// called.</span>
  <span class="s3">this</span><span class="s1">.finalLoc = </span><span class="s3">this</span><span class="s1">.loc();</span>

  <span class="s0">// A list of all leap.TryEntry statements emitted.</span>
  <span class="s3">this</span><span class="s1">.tryEntries = [];</span>

  <span class="s0">// Each time we evaluate the body of a loop, we tell this.leapManager</span>
  <span class="s0">// to enter a nested loop context that determines the meaning of break</span>
  <span class="s0">// and continue statements therein.</span>
  <span class="s3">this</span><span class="s1">.leapManager = </span><span class="s3">new </span><span class="s1">leap.LeapManager(</span><span class="s3">this</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s1">let Ep = Emitter.prototype;</span>
<span class="s1">exports.Emitter = Emitter;</span>

<span class="s0">// Offsets into this.listing that could be used as targets for branches or</span>
<span class="s0">// jumps are represented as numeric Literal nodes. This representation has</span>
<span class="s0">// the amazingly convenient benefit of allowing the exact value of the</span>
<span class="s0">// location to be determined at any time, even after generating code that</span>
<span class="s0">// refers to the location.</span>
<span class="s1">Ep.loc = </span><span class="s3">function</span><span class="s1">() {</span>
  <span class="s1">const l = util.getTypes().numericLiteral(-</span><span class="s4">1</span><span class="s1">)</span>
  <span class="s3">this</span><span class="s1">.insertedLocs.add(l);</span>
  <span class="s3">return </span><span class="s1">l;</span>
<span class="s1">}</span>

<span class="s1">Ep.getInsertedLocs = </span><span class="s3">function</span><span class="s1">() {</span>
  <span class="s3">return this</span><span class="s1">.insertedLocs;</span>
<span class="s1">}</span>

<span class="s1">Ep.getContextId = </span><span class="s3">function</span><span class="s1">() {</span>
  <span class="s3">return </span><span class="s1">util.getTypes().clone(</span><span class="s3">this</span><span class="s1">.contextId);</span>
<span class="s1">}</span>

<span class="s0">// Sets the exact value of the given location to the offset of the next</span>
<span class="s0">// Statement emitted.</span>
<span class="s1">Ep.mark = </span><span class="s3">function</span><span class="s1">(loc) {</span>
  <span class="s1">util.getTypes().assertLiteral(loc);</span>
  <span class="s1">let index = </span><span class="s3">this</span><span class="s1">.listing.length;</span>
  <span class="s3">if </span><span class="s1">(loc.value === -</span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s1">loc.value = index;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s0">// Locations can be marked redundantly, but their values cannot change</span>
    <span class="s0">// once set the first time.</span>
    <span class="s1">assert.strictEqual(loc.value, index);</span>
  <span class="s1">}</span>
  <span class="s3">this</span><span class="s1">.marked[index] = </span><span class="s3">true</span><span class="s1">;</span>
  <span class="s3">return </span><span class="s1">loc;</span>
<span class="s1">};</span>

<span class="s1">Ep.emit = </span><span class="s3">function</span><span class="s1">(node) {</span>
  <span class="s1">const t = util.getTypes();</span>

  <span class="s3">if </span><span class="s1">(t.isExpression(node)) {</span>
    <span class="s1">node = t.expressionStatement(node);</span>
  <span class="s1">}</span>

  <span class="s1">t.assertStatement(node);</span>
  <span class="s3">this</span><span class="s1">.listing.push(node);</span>
<span class="s1">};</span>

<span class="s0">// Shorthand for emitting assignment statements. This will come in handy</span>
<span class="s0">// for assignments to temporary variables.</span>
<span class="s1">Ep.emitAssign = </span><span class="s3">function</span><span class="s1">(lhs, rhs) {</span>
  <span class="s3">this</span><span class="s1">.emit(</span><span class="s3">this</span><span class="s1">.assign(lhs, rhs));</span>
  <span class="s3">return </span><span class="s1">lhs;</span>
<span class="s1">};</span>

<span class="s0">// Shorthand for an assignment statement.</span>
<span class="s1">Ep.assign = </span><span class="s3">function</span><span class="s1">(lhs, rhs) {</span>
  <span class="s1">const t = util.getTypes();</span>
  <span class="s3">return </span><span class="s1">t.expressionStatement(</span>
    <span class="s1">t.assignmentExpression(</span><span class="s2">&quot;=&quot;</span><span class="s1">, t.cloneDeep(lhs), rhs));</span>
<span class="s1">};</span>

<span class="s0">// Convenience function for generating expressions like context.next,</span>
<span class="s0">// context.sent, and context.rval.</span>
<span class="s1">Ep.contextProperty = </span><span class="s3">function</span><span class="s1">(name, computed) {</span>
  <span class="s1">const t = util.getTypes();</span>
  <span class="s3">return </span><span class="s1">t.memberExpression(</span>
    <span class="s3">this</span><span class="s1">.getContextId(),</span>
    <span class="s1">computed ? t.stringLiteral(name) : t.identifier(name),</span>
    <span class="s1">!!computed</span>
  <span class="s1">);</span>
<span class="s1">};</span>

<span class="s0">// Shorthand for setting context.rval and jumping to `context.stop()`.</span>
<span class="s1">Ep.stop = </span><span class="s3">function</span><span class="s1">(rval) {</span>
  <span class="s3">if </span><span class="s1">(rval) {</span>
    <span class="s3">this</span><span class="s1">.setReturnValue(rval);</span>
  <span class="s1">}</span>

  <span class="s3">this</span><span class="s1">.jump(</span><span class="s3">this</span><span class="s1">.finalLoc);</span>
<span class="s1">};</span>

<span class="s1">Ep.setReturnValue = </span><span class="s3">function</span><span class="s1">(valuePath) {</span>
  <span class="s1">util.getTypes().assertExpression(valuePath.value);</span>

  <span class="s3">this</span><span class="s1">.emitAssign(</span>
    <span class="s3">this</span><span class="s1">.contextProperty(</span><span class="s2">&quot;rval&quot;</span><span class="s1">),</span>
    <span class="s3">this</span><span class="s1">.explodeExpression(valuePath)</span>
  <span class="s1">);</span>
<span class="s1">};</span>

<span class="s1">Ep.clearPendingException = </span><span class="s3">function</span><span class="s1">(tryLoc, assignee) {</span>
  <span class="s1">const t = util.getTypes();</span>

  <span class="s1">t.assertLiteral(tryLoc);</span>

  <span class="s1">let catchCall = t.callExpression(</span>
    <span class="s3">this</span><span class="s1">.contextProperty(</span><span class="s2">&quot;catch&quot;</span><span class="s1">, </span><span class="s3">true</span><span class="s1">),</span>
    <span class="s1">[t.clone(tryLoc)]</span>
  <span class="s1">);</span>

  <span class="s3">if </span><span class="s1">(assignee) {</span>
    <span class="s3">this</span><span class="s1">.emitAssign(assignee, catchCall);</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s3">this</span><span class="s1">.emit(catchCall);</span>
  <span class="s1">}</span>
<span class="s1">};</span>

<span class="s0">// Emits code for an unconditional jump to the given location, even if the</span>
<span class="s0">// exact value of the location is not yet known.</span>
<span class="s1">Ep.jump = </span><span class="s3">function</span><span class="s1">(toLoc) {</span>
  <span class="s3">this</span><span class="s1">.emitAssign(</span><span class="s3">this</span><span class="s1">.contextProperty(</span><span class="s2">&quot;next&quot;</span><span class="s1">), toLoc);</span>
  <span class="s3">this</span><span class="s1">.emit(util.getTypes().breakStatement());</span>
<span class="s1">};</span>

<span class="s0">// Conditional jump.</span>
<span class="s1">Ep.jumpIf = </span><span class="s3">function</span><span class="s1">(test, toLoc) {</span>
  <span class="s1">const t = util.getTypes();</span>

  <span class="s1">t.assertExpression(test);</span>
  <span class="s1">t.assertLiteral(toLoc);</span>

  <span class="s3">this</span><span class="s1">.emit(t.ifStatement(</span>
    <span class="s1">test,</span>
    <span class="s1">t.blockStatement([</span>
      <span class="s3">this</span><span class="s1">.assign(</span><span class="s3">this</span><span class="s1">.contextProperty(</span><span class="s2">&quot;next&quot;</span><span class="s1">), toLoc),</span>
      <span class="s1">t.breakStatement()</span>
    <span class="s1">])</span>
  <span class="s1">));</span>
<span class="s1">};</span>

<span class="s0">// Conditional jump, with the condition negated.</span>
<span class="s1">Ep.jumpIfNot = </span><span class="s3">function</span><span class="s1">(test, toLoc) {</span>
  <span class="s1">const t = util.getTypes();</span>

  <span class="s1">t.assertExpression(test);</span>
  <span class="s1">t.assertLiteral(toLoc);</span>

  <span class="s1">let negatedTest;</span>
  <span class="s3">if </span><span class="s1">(t.isUnaryExpression(test) &amp;&amp;</span>
      <span class="s1">test.operator === </span><span class="s2">&quot;!&quot;</span><span class="s1">) {</span>
    <span class="s0">// Avoid double negation.</span>
    <span class="s1">negatedTest = test.argument;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">negatedTest = t.unaryExpression(</span><span class="s2">&quot;!&quot;</span><span class="s1">, test);</span>
  <span class="s1">}</span>

  <span class="s3">this</span><span class="s1">.emit(t.ifStatement(</span>
    <span class="s1">negatedTest,</span>
    <span class="s1">t.blockStatement([</span>
      <span class="s3">this</span><span class="s1">.assign(</span><span class="s3">this</span><span class="s1">.contextProperty(</span><span class="s2">&quot;next&quot;</span><span class="s1">), toLoc),</span>
      <span class="s1">t.breakStatement()</span>
    <span class="s1">])</span>
  <span class="s1">));</span>
<span class="s1">};</span>

<span class="s0">// Returns a unique MemberExpression that can be used to store and</span>
<span class="s0">// retrieve temporary values. Since the object of the member expression is</span>
<span class="s0">// the context object, which is presumed to coexist peacefully with all</span>
<span class="s0">// other local variables, and since we just increment `nextTempId`</span>
<span class="s0">// monotonically, uniqueness is assured.</span>
<span class="s1">Ep.makeTempVar = </span><span class="s3">function</span><span class="s1">() {</span>
  <span class="s3">return this</span><span class="s1">.contextProperty(</span><span class="s2">&quot;t&quot; </span><span class="s1">+ </span><span class="s3">this</span><span class="s1">.nextTempId++);</span>
<span class="s1">};</span>

<span class="s1">Ep.getContextFunction = </span><span class="s3">function</span><span class="s1">(id) {</span>
  <span class="s1">const t = util.getTypes();</span>

  <span class="s3">return </span><span class="s1">t.functionExpression(</span>
    <span class="s1">id || </span><span class="s3">null</span><span class="s0">/*Anonymous*/</span><span class="s1">,</span>
    <span class="s1">[</span><span class="s3">this</span><span class="s1">.getContextId()],</span>
    <span class="s1">t.blockStatement([</span><span class="s3">this</span><span class="s1">.getDispatchLoop()]),</span>
    <span class="s3">false</span><span class="s1">, </span><span class="s0">// Not a generator anymore!</span>
    <span class="s3">false </span><span class="s0">// Nor an expression.</span>
  <span class="s1">);</span>
<span class="s1">};</span>

<span class="s0">// Turns this.listing into a loop of the form</span>
<span class="s0">//</span>
<span class="s0">//   while (1) switch (context.next) {</span>
<span class="s0">//   case 0:</span>
<span class="s0">//   ...</span>
<span class="s0">//   case n:</span>
<span class="s0">//     return context.stop();</span>
<span class="s0">//   }</span>
<span class="s0">//</span>
<span class="s0">// Each marked location in this.listing will correspond to one generated</span>
<span class="s0">// case statement.</span>
<span class="s1">Ep.getDispatchLoop = </span><span class="s3">function</span><span class="s1">() {</span>
  <span class="s1">const self = </span><span class="s3">this</span><span class="s1">;</span>
  <span class="s1">const t = util.getTypes();</span>
  <span class="s1">let cases = [];</span>
  <span class="s1">let current;</span>

  <span class="s0">// If we encounter a break, continue, or return statement in a switch</span>
  <span class="s0">// case, we can skip the rest of the statements until the next case.</span>
  <span class="s1">let alreadyEnded = </span><span class="s3">false</span><span class="s1">;</span>

  <span class="s1">self.listing.forEach(</span><span class="s3">function</span><span class="s1">(stmt, i) {</span>
    <span class="s3">if </span><span class="s1">(self.marked.hasOwnProperty(i)) {</span>
      <span class="s1">cases.push(t.switchCase(</span>
        <span class="s1">t.numericLiteral(i),</span>
        <span class="s1">current = []));</span>
      <span class="s1">alreadyEnded = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(!alreadyEnded) {</span>
      <span class="s1">current.push(stmt);</span>
      <span class="s3">if </span><span class="s1">(t.isCompletionStatement(stmt))</span>
        <span class="s1">alreadyEnded = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">});</span>

  <span class="s0">// Now that we know how many statements there will be in this.listing,</span>
  <span class="s0">// we can finally resolve this.finalLoc.value.</span>
  <span class="s3">this</span><span class="s1">.finalLoc.value = </span><span class="s3">this</span><span class="s1">.listing.length;</span>

  <span class="s1">cases.push(</span>
    <span class="s1">t.switchCase(</span><span class="s3">this</span><span class="s1">.finalLoc, [</span>
      <span class="s0">// Intentionally fall through to the &quot;end&quot; case...</span>
    <span class="s1">]),</span>

    <span class="s0">// So that the runtime can jump to the final location without having</span>
    <span class="s0">// to know its offset, we provide the &quot;end&quot; case as a synonym.</span>
    <span class="s1">t.switchCase(t.stringLiteral(</span><span class="s2">&quot;end&quot;</span><span class="s1">), [</span>
      <span class="s0">// This will check/clear both context.thrown and context.rval.</span>
      <span class="s1">t.returnStatement(</span>
        <span class="s1">t.callExpression(</span><span class="s3">this</span><span class="s1">.contextProperty(</span><span class="s2">&quot;stop&quot;</span><span class="s1">), [])</span>
      <span class="s1">)</span>
    <span class="s1">])</span>
  <span class="s1">);</span>

  <span class="s3">return </span><span class="s1">t.whileStatement(</span>
    <span class="s1">t.numericLiteral(</span><span class="s4">1</span><span class="s1">),</span>
    <span class="s1">t.switchStatement(</span>
      <span class="s1">t.assignmentExpression(</span>
        <span class="s2">&quot;=&quot;</span><span class="s1">,</span>
        <span class="s3">this</span><span class="s1">.contextProperty(</span><span class="s2">&quot;prev&quot;</span><span class="s1">),</span>
        <span class="s3">this</span><span class="s1">.contextProperty(</span><span class="s2">&quot;next&quot;</span><span class="s1">)</span>
      <span class="s1">),</span>
      <span class="s1">cases</span>
    <span class="s1">)</span>
  <span class="s1">);</span>
<span class="s1">};</span>

<span class="s1">Ep.getTryLocsList = </span><span class="s3">function</span><span class="s1">() {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.tryEntries.length === </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s0">// To avoid adding a needless [] to the majority of runtime.wrap</span>
    <span class="s0">// argument lists, force the caller to handle this case specially.</span>
    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s1">const t = util.getTypes();</span>
  <span class="s1">let lastLocValue = </span><span class="s4">0</span><span class="s1">;</span>

  <span class="s3">return </span><span class="s1">t.arrayExpression(</span>
    <span class="s3">this</span><span class="s1">.tryEntries.map(</span><span class="s3">function</span><span class="s1">(tryEntry) {</span>
      <span class="s1">let thisLocValue = tryEntry.firstLoc.value;</span>
      <span class="s1">assert.ok(thisLocValue &gt;= lastLocValue, </span><span class="s2">&quot;try entries out of order&quot;</span><span class="s1">);</span>
      <span class="s1">lastLocValue = thisLocValue;</span>

      <span class="s1">let ce = tryEntry.catchEntry;</span>
      <span class="s1">let fe = tryEntry.finallyEntry;</span>

      <span class="s1">let locs = [</span>
        <span class="s1">tryEntry.firstLoc,</span>
        <span class="s0">// The null here makes a hole in the array.</span>
        <span class="s1">ce ? ce.firstLoc : </span><span class="s3">null</span>
      <span class="s1">];</span>

      <span class="s3">if </span><span class="s1">(fe) {</span>
        <span class="s1">locs[</span><span class="s4">2</span><span class="s1">] = fe.firstLoc;</span>
        <span class="s1">locs[</span><span class="s4">3</span><span class="s1">] = fe.afterLoc;</span>
      <span class="s1">}</span>

      <span class="s3">return </span><span class="s1">t.arrayExpression(locs.map(loc =&gt; loc &amp;&amp; t.clone(loc)));</span>
    <span class="s1">})</span>
  <span class="s1">);</span>
<span class="s1">};</span>

<span class="s0">// All side effects must be realized in order.</span>

<span class="s0">// If any subexpression harbors a leap, all subexpressions must be</span>
<span class="s0">// neutered of side effects.</span>

<span class="s0">// No destructive modification of AST nodes.</span>

<span class="s1">Ep.explode = </span><span class="s3">function</span><span class="s1">(path, ignoreResult) {</span>
  <span class="s1">const t = util.getTypes();</span>
  <span class="s1">let node = path.node;</span>
  <span class="s1">let self = </span><span class="s3">this</span><span class="s1">;</span>

  <span class="s1">t.assertNode(node);</span>

  <span class="s3">if </span><span class="s1">(t.isDeclaration(node))</span>
    <span class="s3">throw </span><span class="s1">getDeclError(node);</span>

  <span class="s3">if </span><span class="s1">(t.isStatement(node))</span>
    <span class="s3">return </span><span class="s1">self.explodeStatement(path);</span>

  <span class="s3">if </span><span class="s1">(t.isExpression(node))</span>
    <span class="s3">return </span><span class="s1">self.explodeExpression(path, ignoreResult);</span>

  <span class="s3">switch </span><span class="s1">(node.type) {</span>
  <span class="s3">case </span><span class="s2">&quot;Program&quot;</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">path.get(</span><span class="s2">&quot;body&quot;</span><span class="s1">).map(</span>
      <span class="s1">self.explodeStatement,</span>
      <span class="s1">self</span>
    <span class="s1">);</span>

  <span class="s3">case </span><span class="s2">&quot;VariableDeclarator&quot;</span><span class="s1">:</span>
    <span class="s3">throw </span><span class="s1">getDeclError(node);</span>

  <span class="s0">// These node types should be handled by their parent nodes</span>
  <span class="s0">// (ObjectExpression, SwitchStatement, and TryStatement, respectively).</span>
  <span class="s3">case </span><span class="s2">&quot;Property&quot;</span><span class="s1">:</span>
  <span class="s3">case </span><span class="s2">&quot;SwitchCase&quot;</span><span class="s1">:</span>
  <span class="s3">case </span><span class="s2">&quot;CatchClause&quot;</span><span class="s1">:</span>
    <span class="s3">throw new </span><span class="s1">Error(</span>
      <span class="s1">node.type + </span><span class="s2">&quot; nodes should be handled by their parents&quot;</span><span class="s1">);</span>

  <span class="s3">default</span><span class="s1">:</span>
    <span class="s3">throw new </span><span class="s1">Error(</span>
      <span class="s2">&quot;unknown Node of type &quot; </span><span class="s1">+</span>
        <span class="s1">JSON.stringify(node.type));</span>
  <span class="s1">}</span>
<span class="s1">};</span>

<span class="s3">function </span><span class="s1">getDeclError(node) {</span>
  <span class="s3">return new </span><span class="s1">Error(</span>
    <span class="s2">&quot;all declarations should have been transformed into &quot; </span><span class="s1">+</span>
    <span class="s2">&quot;assignments before the Exploder began its work: &quot; </span><span class="s1">+</span>
    <span class="s1">JSON.stringify(node));</span>
<span class="s1">}</span>

<span class="s1">Ep.explodeStatement = </span><span class="s3">function</span><span class="s1">(path, labelId) {</span>
  <span class="s1">const t = util.getTypes();</span>
  <span class="s1">let stmt = path.node;</span>
  <span class="s1">let self = </span><span class="s3">this</span><span class="s1">;</span>
  <span class="s1">let before, after, head;</span>

  <span class="s1">t.assertStatement(stmt);</span>

  <span class="s3">if </span><span class="s1">(labelId) {</span>
    <span class="s1">t.assertIdentifier(labelId);</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">labelId = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s0">// Explode BlockStatement nodes even if they do not contain a yield,</span>
  <span class="s0">// because we don't want or need the curly braces.</span>
  <span class="s3">if </span><span class="s1">(t.isBlockStatement(stmt)) {</span>
    <span class="s1">path.get(</span><span class="s2">&quot;body&quot;</span><span class="s1">).forEach(</span><span class="s3">function </span><span class="s1">(path) {</span>
      <span class="s1">self.explodeStatement(path);</span>
    <span class="s1">});</span>
    <span class="s3">return</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(!meta.containsLeap(stmt)) {</span>
    <span class="s0">// Technically we should be able to avoid emitting the statement</span>
    <span class="s0">// altogether if !meta.hasSideEffects(stmt), but that leads to</span>
    <span class="s0">// confusing generated code (for instance, `while (true) {}` just</span>
    <span class="s0">// disappears) and is probably a more appropriate job for a dedicated</span>
    <span class="s0">// dead code elimination pass.</span>
    <span class="s1">self.emit(stmt);</span>
    <span class="s3">return</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">switch </span><span class="s1">(stmt.type) {</span>
  <span class="s3">case </span><span class="s2">&quot;ExpressionStatement&quot;</span><span class="s1">:</span>
    <span class="s1">self.explodeExpression(path.get(</span><span class="s2">&quot;expression&quot;</span><span class="s1">), </span><span class="s3">true</span><span class="s1">);</span>
    <span class="s3">break</span><span class="s1">;</span>

  <span class="s3">case </span><span class="s2">&quot;LabeledStatement&quot;</span><span class="s1">:</span>
    <span class="s1">after = </span><span class="s3">this</span><span class="s1">.loc();</span>

    <span class="s0">// Did you know you can break from any labeled block statement or</span>
    <span class="s0">// control structure? Well, you can! Note: when a labeled loop is</span>
    <span class="s0">// encountered, the leap.LabeledEntry created here will immediately</span>
    <span class="s0">// enclose a leap.LoopEntry on the leap manager's stack, and both</span>
    <span class="s0">// entries will have the same label. Though this works just fine, it</span>
    <span class="s0">// may seem a bit redundant. In theory, we could check here to</span>
    <span class="s0">// determine if stmt knows how to handle its own label; for example,</span>
    <span class="s0">// stmt happens to be a WhileStatement and so we know it's going to</span>
    <span class="s0">// establish its own LoopEntry when we explode it (below). Then this</span>
    <span class="s0">// LabeledEntry would be unnecessary. Alternatively, we might be</span>
    <span class="s0">// tempted not to pass stmt.label down into self.explodeStatement,</span>
    <span class="s0">// because we've handled the label here, but that's a mistake because</span>
    <span class="s0">// labeled loops may contain labeled continue statements, which is not</span>
    <span class="s0">// something we can handle in this generic case. All in all, I think a</span>
    <span class="s0">// little redundancy greatly simplifies the logic of this case, since</span>
    <span class="s0">// it's clear that we handle all possible LabeledStatements correctly</span>
    <span class="s0">// here, regardless of whether they interact with the leap manager</span>
    <span class="s0">// themselves. Also remember that labels and break/continue-to-label</span>
    <span class="s0">// statements are rare, and all of this logic happens at transform</span>
    <span class="s0">// time, so it has no additional runtime cost.</span>
    <span class="s1">self.leapManager.withEntry(</span>
      <span class="s3">new </span><span class="s1">leap.LabeledEntry(after, stmt.label),</span>
      <span class="s3">function</span><span class="s1">() {</span>
        <span class="s1">self.explodeStatement(path.get(</span><span class="s2">&quot;body&quot;</span><span class="s1">), stmt.label);</span>
      <span class="s1">}</span>
    <span class="s1">);</span>

    <span class="s1">self.mark(after);</span>

    <span class="s3">break</span><span class="s1">;</span>

  <span class="s3">case </span><span class="s2">&quot;WhileStatement&quot;</span><span class="s1">:</span>
    <span class="s1">before = </span><span class="s3">this</span><span class="s1">.loc();</span>
    <span class="s1">after = </span><span class="s3">this</span><span class="s1">.loc();</span>

    <span class="s1">self.mark(before);</span>
    <span class="s1">self.jumpIfNot(self.explodeExpression(path.get(</span><span class="s2">&quot;test&quot;</span><span class="s1">)), after);</span>
    <span class="s1">self.leapManager.withEntry(</span>
      <span class="s3">new </span><span class="s1">leap.LoopEntry(after, before, labelId),</span>
      <span class="s3">function</span><span class="s1">() { self.explodeStatement(path.get(</span><span class="s2">&quot;body&quot;</span><span class="s1">)); }</span>
    <span class="s1">);</span>
    <span class="s1">self.jump(before);</span>
    <span class="s1">self.mark(after);</span>

    <span class="s3">break</span><span class="s1">;</span>

  <span class="s3">case </span><span class="s2">&quot;DoWhileStatement&quot;</span><span class="s1">:</span>
    <span class="s1">let first = </span><span class="s3">this</span><span class="s1">.loc();</span>
    <span class="s1">let test = </span><span class="s3">this</span><span class="s1">.loc();</span>
    <span class="s1">after = </span><span class="s3">this</span><span class="s1">.loc();</span>

    <span class="s1">self.mark(first);</span>
    <span class="s1">self.leapManager.withEntry(</span>
      <span class="s3">new </span><span class="s1">leap.LoopEntry(after, test, labelId),</span>
      <span class="s3">function</span><span class="s1">() { self.explode(path.get(</span><span class="s2">&quot;body&quot;</span><span class="s1">)); }</span>
    <span class="s1">);</span>
    <span class="s1">self.mark(test);</span>
    <span class="s1">self.jumpIf(self.explodeExpression(path.get(</span><span class="s2">&quot;test&quot;</span><span class="s1">)), first);</span>
    <span class="s1">self.mark(after);</span>

    <span class="s3">break</span><span class="s1">;</span>

  <span class="s3">case </span><span class="s2">&quot;ForStatement&quot;</span><span class="s1">:</span>
    <span class="s1">head = </span><span class="s3">this</span><span class="s1">.loc();</span>
    <span class="s1">let update = </span><span class="s3">this</span><span class="s1">.loc();</span>
    <span class="s1">after = </span><span class="s3">this</span><span class="s1">.loc();</span>

    <span class="s3">if </span><span class="s1">(stmt.init) {</span>
      <span class="s0">// We pass true here to indicate that if stmt.init is an expression</span>
      <span class="s0">// then we do not care about its result.</span>
      <span class="s1">self.explode(path.get(</span><span class="s2">&quot;init&quot;</span><span class="s1">), </span><span class="s3">true</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s1">self.mark(head);</span>

    <span class="s3">if </span><span class="s1">(stmt.test) {</span>
      <span class="s1">self.jumpIfNot(self.explodeExpression(path.get(</span><span class="s2">&quot;test&quot;</span><span class="s1">)), after);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s0">// No test means continue unconditionally.</span>
    <span class="s1">}</span>

    <span class="s1">self.leapManager.withEntry(</span>
      <span class="s3">new </span><span class="s1">leap.LoopEntry(after, update, labelId),</span>
      <span class="s3">function</span><span class="s1">() { self.explodeStatement(path.get(</span><span class="s2">&quot;body&quot;</span><span class="s1">)); }</span>
    <span class="s1">);</span>

    <span class="s1">self.mark(update);</span>

    <span class="s3">if </span><span class="s1">(stmt.update) {</span>
      <span class="s0">// We pass true here to indicate that if stmt.update is an</span>
      <span class="s0">// expression then we do not care about its result.</span>
      <span class="s1">self.explode(path.get(</span><span class="s2">&quot;update&quot;</span><span class="s1">), </span><span class="s3">true</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s1">self.jump(head);</span>

    <span class="s1">self.mark(after);</span>

    <span class="s3">break</span><span class="s1">;</span>

  <span class="s3">case </span><span class="s2">&quot;TypeCastExpression&quot;</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">self.explodeExpression(path.get(</span><span class="s2">&quot;expression&quot;</span><span class="s1">));</span>

  <span class="s3">case </span><span class="s2">&quot;ForInStatement&quot;</span><span class="s1">:</span>
    <span class="s1">head = </span><span class="s3">this</span><span class="s1">.loc();</span>
    <span class="s1">after = </span><span class="s3">this</span><span class="s1">.loc();</span>

    <span class="s1">let keyIterNextFn = self.makeTempVar();</span>
    <span class="s1">self.emitAssign(</span>
      <span class="s1">keyIterNextFn,</span>
      <span class="s1">t.callExpression(</span>
        <span class="s1">util.runtimeProperty(</span><span class="s2">&quot;keys&quot;</span><span class="s1">),</span>
        <span class="s1">[self.explodeExpression(path.get(</span><span class="s2">&quot;right&quot;</span><span class="s1">))]</span>
      <span class="s1">)</span>
    <span class="s1">);</span>

    <span class="s1">self.mark(head);</span>

    <span class="s1">let keyInfoTmpVar = self.makeTempVar();</span>
    <span class="s1">self.jumpIf(</span>
      <span class="s1">t.memberExpression(</span>
        <span class="s1">t.assignmentExpression(</span>
          <span class="s2">&quot;=&quot;</span><span class="s1">,</span>
          <span class="s1">keyInfoTmpVar,</span>
          <span class="s1">t.callExpression(t.cloneDeep(keyIterNextFn), [])</span>
        <span class="s1">),</span>
        <span class="s1">t.identifier(</span><span class="s2">&quot;done&quot;</span><span class="s1">),</span>
        <span class="s3">false</span>
      <span class="s1">),</span>
      <span class="s1">after</span>
    <span class="s1">);</span>

    <span class="s1">self.emitAssign(</span>
      <span class="s1">stmt.left,</span>
      <span class="s1">t.memberExpression(</span>
        <span class="s1">t.cloneDeep(keyInfoTmpVar),</span>
        <span class="s1">t.identifier(</span><span class="s2">&quot;value&quot;</span><span class="s1">),</span>
        <span class="s3">false</span>
      <span class="s1">)</span>
    <span class="s1">);</span>

    <span class="s1">self.leapManager.withEntry(</span>
      <span class="s3">new </span><span class="s1">leap.LoopEntry(after, head, labelId),</span>
      <span class="s3">function</span><span class="s1">() { self.explodeStatement(path.get(</span><span class="s2">&quot;body&quot;</span><span class="s1">)); }</span>
    <span class="s1">);</span>

    <span class="s1">self.jump(head);</span>

    <span class="s1">self.mark(after);</span>

    <span class="s3">break</span><span class="s1">;</span>

  <span class="s3">case </span><span class="s2">&quot;BreakStatement&quot;</span><span class="s1">:</span>
    <span class="s1">self.emitAbruptCompletion({</span>
      <span class="s1">type: </span><span class="s2">&quot;break&quot;</span><span class="s1">,</span>
      <span class="s1">target: self.leapManager.getBreakLoc(stmt.label)</span>
    <span class="s1">});</span>

    <span class="s3">break</span><span class="s1">;</span>

  <span class="s3">case </span><span class="s2">&quot;ContinueStatement&quot;</span><span class="s1">:</span>
    <span class="s1">self.emitAbruptCompletion({</span>
      <span class="s1">type: </span><span class="s2">&quot;continue&quot;</span><span class="s1">,</span>
      <span class="s1">target: self.leapManager.getContinueLoc(stmt.label)</span>
    <span class="s1">});</span>

    <span class="s3">break</span><span class="s1">;</span>

  <span class="s3">case </span><span class="s2">&quot;SwitchStatement&quot;</span><span class="s1">:</span>
    <span class="s0">// Always save the discriminant into a temporary variable in case the</span>
    <span class="s0">// test expressions overwrite values like context.sent.</span>
    <span class="s1">let disc = self.emitAssign(</span>
      <span class="s1">self.makeTempVar(),</span>
      <span class="s1">self.explodeExpression(path.get(</span><span class="s2">&quot;discriminant&quot;</span><span class="s1">))</span>
    <span class="s1">);</span>

    <span class="s1">after = </span><span class="s3">this</span><span class="s1">.loc();</span>
    <span class="s1">let defaultLoc = </span><span class="s3">this</span><span class="s1">.loc();</span>
    <span class="s1">let condition = defaultLoc;</span>
    <span class="s1">let caseLocs = [];</span>

    <span class="s0">// If there are no cases, .cases might be undefined.</span>
    <span class="s1">let cases = stmt.cases || [];</span>

    <span class="s3">for </span><span class="s1">(let i = cases.length - </span><span class="s4">1</span><span class="s1">; i &gt;= </span><span class="s4">0</span><span class="s1">; --i) {</span>
      <span class="s1">let c = cases[i];</span>
      <span class="s1">t.assertSwitchCase(c);</span>

      <span class="s3">if </span><span class="s1">(c.test) {</span>
        <span class="s1">condition = t.conditionalExpression(</span>
          <span class="s1">t.binaryExpression(</span><span class="s2">&quot;===&quot;</span><span class="s1">, t.cloneDeep(disc), c.test),</span>
          <span class="s1">caseLocs[i] = </span><span class="s3">this</span><span class="s1">.loc(),</span>
          <span class="s1">condition</span>
        <span class="s1">);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">caseLocs[i] = defaultLoc;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">let discriminant = path.get(</span><span class="s2">&quot;discriminant&quot;</span><span class="s1">);</span>
    <span class="s1">util.replaceWithOrRemove(discriminant, condition);</span>
    <span class="s1">self.jump(self.explodeExpression(discriminant));</span>

    <span class="s1">self.leapManager.withEntry(</span>
      <span class="s3">new </span><span class="s1">leap.SwitchEntry(after),</span>
      <span class="s3">function</span><span class="s1">() {</span>
        <span class="s1">path.get(</span><span class="s2">&quot;cases&quot;</span><span class="s1">).forEach(</span><span class="s3">function</span><span class="s1">(casePath) {</span>
          <span class="s1">let i = casePath.key;</span>
          <span class="s1">self.mark(caseLocs[i]);</span>

          <span class="s1">casePath.get(</span><span class="s2">&quot;consequent&quot;</span><span class="s1">).forEach(</span><span class="s3">function </span><span class="s1">(path) {</span>
            <span class="s1">self.explodeStatement(path);</span>
          <span class="s1">});</span>
        <span class="s1">});</span>
      <span class="s1">}</span>
    <span class="s1">);</span>

    <span class="s1">self.mark(after);</span>
    <span class="s3">if </span><span class="s1">(defaultLoc.value === -</span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s1">self.mark(defaultLoc);</span>
      <span class="s1">assert.strictEqual(after.value, defaultLoc.value);</span>
    <span class="s1">}</span>

    <span class="s3">break</span><span class="s1">;</span>

  <span class="s3">case </span><span class="s2">&quot;IfStatement&quot;</span><span class="s1">:</span>
    <span class="s1">let elseLoc = stmt.alternate &amp;&amp; </span><span class="s3">this</span><span class="s1">.loc();</span>
    <span class="s1">after = </span><span class="s3">this</span><span class="s1">.loc();</span>

    <span class="s1">self.jumpIfNot(</span>
      <span class="s1">self.explodeExpression(path.get(</span><span class="s2">&quot;test&quot;</span><span class="s1">)),</span>
      <span class="s1">elseLoc || after</span>
    <span class="s1">);</span>

    <span class="s1">self.explodeStatement(path.get(</span><span class="s2">&quot;consequent&quot;</span><span class="s1">));</span>

    <span class="s3">if </span><span class="s1">(elseLoc) {</span>
      <span class="s1">self.jump(after);</span>
      <span class="s1">self.mark(elseLoc);</span>
      <span class="s1">self.explodeStatement(path.get(</span><span class="s2">&quot;alternate&quot;</span><span class="s1">));</span>
    <span class="s1">}</span>

    <span class="s1">self.mark(after);</span>

    <span class="s3">break</span><span class="s1">;</span>

  <span class="s3">case </span><span class="s2">&quot;ReturnStatement&quot;</span><span class="s1">:</span>
    <span class="s1">self.emitAbruptCompletion({</span>
      <span class="s1">type: </span><span class="s2">&quot;return&quot;</span><span class="s1">,</span>
      <span class="s1">value: self.explodeExpression(path.get(</span><span class="s2">&quot;argument&quot;</span><span class="s1">))</span>
    <span class="s1">});</span>

    <span class="s3">break</span><span class="s1">;</span>

  <span class="s3">case </span><span class="s2">&quot;WithStatement&quot;</span><span class="s1">:</span>
    <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;WithStatement not supported in generator functions.&quot;</span><span class="s1">);</span>

  <span class="s3">case </span><span class="s2">&quot;TryStatement&quot;</span><span class="s1">:</span>
    <span class="s1">after = </span><span class="s3">this</span><span class="s1">.loc();</span>

    <span class="s1">let handler = stmt.handler;</span>

    <span class="s1">let catchLoc = handler &amp;&amp; </span><span class="s3">this</span><span class="s1">.loc();</span>
    <span class="s1">let catchEntry = catchLoc &amp;&amp; </span><span class="s3">new </span><span class="s1">leap.CatchEntry(</span>
      <span class="s1">catchLoc,</span>
      <span class="s1">handler.param</span>
    <span class="s1">);</span>

    <span class="s1">let finallyLoc = stmt.finalizer &amp;&amp; </span><span class="s3">this</span><span class="s1">.loc();</span>
    <span class="s1">let finallyEntry = finallyLoc &amp;&amp;</span>
      <span class="s3">new </span><span class="s1">leap.FinallyEntry(finallyLoc, after);</span>

    <span class="s1">let tryEntry = </span><span class="s3">new </span><span class="s1">leap.TryEntry(</span>
      <span class="s1">self.getUnmarkedCurrentLoc(),</span>
      <span class="s1">catchEntry,</span>
      <span class="s1">finallyEntry</span>
    <span class="s1">);</span>

    <span class="s1">self.tryEntries.push(tryEntry);</span>
    <span class="s1">self.updateContextPrevLoc(tryEntry.firstLoc);</span>

    <span class="s1">self.leapManager.withEntry(tryEntry, </span><span class="s3">function</span><span class="s1">() {</span>
      <span class="s1">self.explodeStatement(path.get(</span><span class="s2">&quot;block&quot;</span><span class="s1">));</span>

      <span class="s3">if </span><span class="s1">(catchLoc) {</span>
        <span class="s3">if </span><span class="s1">(finallyLoc) {</span>
          <span class="s0">// If we have both a catch block and a finally block, then</span>
          <span class="s0">// because we emit the catch block first, we need to jump over</span>
          <span class="s0">// it to the finally block.</span>
          <span class="s1">self.jump(finallyLoc);</span>

        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s0">// If there is no finally block, then we need to jump over the</span>
          <span class="s0">// catch block to the fall-through location.</span>
          <span class="s1">self.jump(after);</span>
        <span class="s1">}</span>

        <span class="s1">self.updateContextPrevLoc(self.mark(catchLoc));</span>

        <span class="s1">let bodyPath = path.get(</span><span class="s2">&quot;handler.body&quot;</span><span class="s1">);</span>
        <span class="s1">let safeParam = self.makeTempVar();</span>
        <span class="s1">self.clearPendingException(tryEntry.firstLoc, safeParam);</span>

        <span class="s1">bodyPath.traverse(catchParamVisitor, {</span>
          <span class="s1">getSafeParam: () =&gt; t.cloneDeep(safeParam),</span>
          <span class="s1">catchParamName: handler.param.name</span>
        <span class="s1">});</span>

        <span class="s1">self.leapManager.withEntry(catchEntry, </span><span class="s3">function</span><span class="s1">() {</span>
          <span class="s1">self.explodeStatement(bodyPath);</span>
        <span class="s1">});</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(finallyLoc) {</span>
        <span class="s1">self.updateContextPrevLoc(self.mark(finallyLoc));</span>

        <span class="s1">self.leapManager.withEntry(finallyEntry, </span><span class="s3">function</span><span class="s1">() {</span>
          <span class="s1">self.explodeStatement(path.get(</span><span class="s2">&quot;finalizer&quot;</span><span class="s1">));</span>
        <span class="s1">});</span>

        <span class="s1">self.emit(t.returnStatement(t.callExpression(</span>
          <span class="s1">self.contextProperty(</span><span class="s2">&quot;finish&quot;</span><span class="s1">),</span>
          <span class="s1">[finallyEntry.firstLoc]</span>
        <span class="s1">)));</span>
      <span class="s1">}</span>
    <span class="s1">});</span>

    <span class="s1">self.mark(after);</span>

    <span class="s3">break</span><span class="s1">;</span>

  <span class="s3">case </span><span class="s2">&quot;ThrowStatement&quot;</span><span class="s1">:</span>
    <span class="s1">self.emit(t.throwStatement(</span>
      <span class="s1">self.explodeExpression(path.get(</span><span class="s2">&quot;argument&quot;</span><span class="s1">))</span>
    <span class="s1">));</span>

    <span class="s3">break</span><span class="s1">;</span>

  <span class="s3">case </span><span class="s2">&quot;ClassDeclaration&quot;</span><span class="s1">:</span>
    <span class="s1">self.emit(self.explodeClass(path));</span>
    <span class="s3">break</span><span class="s1">;</span>

  <span class="s3">default</span><span class="s1">:</span>
    <span class="s3">throw new </span><span class="s1">Error(</span>
      <span class="s2">&quot;unknown Statement of type &quot; </span><span class="s1">+</span>
        <span class="s1">JSON.stringify(stmt.type));</span>
  <span class="s1">}</span>
<span class="s1">};</span>

<span class="s1">let catchParamVisitor = {</span>
  <span class="s1">Identifier: </span><span class="s3">function</span><span class="s1">(path, state) {</span>
    <span class="s3">if </span><span class="s1">(path.node.name === state.catchParamName &amp;&amp; util.isReference(path)) {</span>
      <span class="s1">util.replaceWithOrRemove(path, state.getSafeParam());</span>
    <span class="s1">}</span>
  <span class="s1">},</span>

  <span class="s1">Scope: </span><span class="s3">function</span><span class="s1">(path, state) {</span>
    <span class="s3">if </span><span class="s1">(path.scope.hasOwnBinding(state.catchParamName)) {</span>
      <span class="s0">// Don't descend into nested scopes that shadow the catch</span>
      <span class="s0">// parameter with their own declarations.</span>
      <span class="s1">path.skip();</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">};</span>

<span class="s1">Ep.emitAbruptCompletion = </span><span class="s3">function</span><span class="s1">(record) {</span>
  <span class="s3">if </span><span class="s1">(!isValidCompletion(record)) {</span>
    <span class="s1">assert.ok(</span>
      <span class="s3">false</span><span class="s1">,</span>
      <span class="s2">&quot;invalid completion record: &quot; </span><span class="s1">+</span>
        <span class="s1">JSON.stringify(record)</span>
    <span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s1">assert.notStrictEqual(</span>
    <span class="s1">record.type, </span><span class="s2">&quot;normal&quot;</span><span class="s1">,</span>
    <span class="s2">&quot;normal completions are not abrupt&quot;</span>
  <span class="s1">);</span>

  <span class="s1">const t = util.getTypes();</span>
  <span class="s1">let abruptArgs = [t.stringLiteral(record.type)];</span>

  <span class="s3">if </span><span class="s1">(record.type === </span><span class="s2">&quot;break&quot; </span><span class="s1">||</span>
      <span class="s1">record.type === </span><span class="s2">&quot;continue&quot;</span><span class="s1">) {</span>
    <span class="s1">t.assertLiteral(record.target);</span>
    <span class="s1">abruptArgs[</span><span class="s4">1</span><span class="s1">] = </span><span class="s3">this</span><span class="s1">.insertedLocs.has(record.target)</span>
      <span class="s1">? record.target</span>
      <span class="s1">: t.cloneDeep(record.target);</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(record.type === </span><span class="s2">&quot;return&quot; </span><span class="s1">||</span>
             <span class="s1">record.type === </span><span class="s2">&quot;throw&quot;</span><span class="s1">) {</span>
    <span class="s3">if </span><span class="s1">(record.value) {</span>
      <span class="s1">t.assertExpression(record.value);</span>
      <span class="s1">abruptArgs[</span><span class="s4">1</span><span class="s1">] = </span><span class="s3">this</span><span class="s1">.insertedLocs.has(record.value)</span>
        <span class="s1">? record.value</span>
        <span class="s1">: t.cloneDeep(record.value);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">this</span><span class="s1">.emit(</span>
    <span class="s1">t.returnStatement(</span>
      <span class="s1">t.callExpression(</span>
        <span class="s3">this</span><span class="s1">.contextProperty(</span><span class="s2">&quot;abrupt&quot;</span><span class="s1">),</span>
        <span class="s1">abruptArgs</span>
      <span class="s1">)</span>
    <span class="s1">)</span>
  <span class="s1">);</span>
<span class="s1">};</span>

<span class="s3">function </span><span class="s1">isValidCompletion(record) {</span>
  <span class="s1">let type = record.type;</span>

  <span class="s3">if </span><span class="s1">(type === </span><span class="s2">&quot;normal&quot;</span><span class="s1">) {</span>
    <span class="s3">return </span><span class="s1">!hasOwn.call(record, </span><span class="s2">&quot;target&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(type === </span><span class="s2">&quot;break&quot; </span><span class="s1">||</span>
      <span class="s1">type === </span><span class="s2">&quot;continue&quot;</span><span class="s1">) {</span>
    <span class="s3">return </span><span class="s1">!hasOwn.call(record, </span><span class="s2">&quot;value&quot;</span><span class="s1">)</span>
        <span class="s1">&amp;&amp; util.getTypes().isLiteral(record.target);</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(type === </span><span class="s2">&quot;return&quot; </span><span class="s1">||</span>
      <span class="s1">type === </span><span class="s2">&quot;throw&quot;</span><span class="s1">) {</span>
    <span class="s3">return </span><span class="s1">hasOwn.call(record, </span><span class="s2">&quot;value&quot;</span><span class="s1">)</span>
        <span class="s1">&amp;&amp; !hasOwn.call(record, </span><span class="s2">&quot;target&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s3">return false</span><span class="s1">;</span>
<span class="s1">}</span>


<span class="s0">// Not all offsets into emitter.listing are potential jump targets. For</span>
<span class="s0">// example, execution typically falls into the beginning of a try block</span>
<span class="s0">// without jumping directly there. This method returns the current offset</span>
<span class="s0">// without marking it, so that a switch case will not necessarily be</span>
<span class="s0">// generated for this offset (I say &quot;not necessarily&quot; because the same</span>
<span class="s0">// location might end up being marked in the process of emitting other</span>
<span class="s0">// statements). There's no logical harm in marking such locations as jump</span>
<span class="s0">// targets, but minimizing the number of switch cases keeps the generated</span>
<span class="s0">// code shorter.</span>
<span class="s1">Ep.getUnmarkedCurrentLoc = </span><span class="s3">function</span><span class="s1">() {</span>
  <span class="s3">return </span><span class="s1">util.getTypes().numericLiteral(</span><span class="s3">this</span><span class="s1">.listing.length);</span>
<span class="s1">};</span>

<span class="s0">// The context.prev property takes the value of context.next whenever we</span>
<span class="s0">// evaluate the switch statement discriminant, which is generally good</span>
<span class="s0">// enough for tracking the last location we jumped to, but sometimes</span>
<span class="s0">// context.prev needs to be more precise, such as when we fall</span>
<span class="s0">// successfully out of a try block and into a finally block without</span>
<span class="s0">// jumping. This method exists to update context.prev to the freshest</span>
<span class="s0">// available location. If we were implementing a full interpreter, we</span>
<span class="s0">// would know the location of the current instruction with complete</span>
<span class="s0">// precision at all times, but we don't have that luxury here, as it would</span>
<span class="s0">// be costly and verbose to set context.prev before every statement.</span>
<span class="s1">Ep.updateContextPrevLoc = </span><span class="s3">function</span><span class="s1">(loc) {</span>
  <span class="s1">const t = util.getTypes();</span>
  <span class="s3">if </span><span class="s1">(loc) {</span>
    <span class="s1">t.assertLiteral(loc);</span>

    <span class="s3">if </span><span class="s1">(loc.value === -</span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s0">// If an uninitialized location literal was passed in, set its value</span>
      <span class="s0">// to the current this.listing.length.</span>
      <span class="s1">loc.value = </span><span class="s3">this</span><span class="s1">.listing.length;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s0">// Otherwise assert that the location matches the current offset.</span>
      <span class="s1">assert.strictEqual(loc.value, </span><span class="s3">this</span><span class="s1">.listing.length);</span>
    <span class="s1">}</span>

  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">loc = </span><span class="s3">this</span><span class="s1">.getUnmarkedCurrentLoc();</span>
  <span class="s1">}</span>

  <span class="s0">// Make sure context.prev is up to date in case we fell into this try</span>
  <span class="s0">// statement without jumping to it. TODO Consider avoiding this</span>
  <span class="s0">// assignment when we know control must have jumped here.</span>
  <span class="s3">this</span><span class="s1">.emitAssign(</span><span class="s3">this</span><span class="s1">.contextProperty(</span><span class="s2">&quot;prev&quot;</span><span class="s1">), loc);</span>
<span class="s1">};</span>


<span class="s0">// In order to save the rest of explodeExpression from a combinatorial</span>
<span class="s0">// trainwreck of special cases, explodeViaTempVar is responsible for</span>
<span class="s0">// deciding when a subexpression needs to be &quot;exploded,&quot; which is my</span>
<span class="s0">// very technical term for emitting the subexpression as an assignment</span>
<span class="s0">// to a temporary variable and the substituting the temporary variable</span>
<span class="s0">// for the original subexpression. Think of exploded view diagrams, not</span>
<span class="s0">// Michael Bay movies. The point of exploding subexpressions is to</span>
<span class="s0">// control the precise order in which the generated code realizes the</span>
<span class="s0">// side effects of those subexpressions.</span>
<span class="s1">Ep.explodeViaTempVar = </span><span class="s3">function</span><span class="s1">(tempVar, childPath, hasLeapingChildren, ignoreChildResult) {</span>
  <span class="s1">assert.ok(</span>
    <span class="s1">!ignoreChildResult || !tempVar,</span>
    <span class="s2">&quot;Ignoring the result of a child expression but forcing it to &quot; </span><span class="s1">+</span>
      <span class="s2">&quot;be assigned to a temporary variable?&quot;</span>
  <span class="s1">);</span>
  <span class="s1">const t = util.getTypes();</span>

  <span class="s1">let result = </span><span class="s3">this</span><span class="s1">.explodeExpression(childPath, ignoreChildResult);</span>

  <span class="s3">if </span><span class="s1">(ignoreChildResult) {</span>
    <span class="s0">// Side effects already emitted above.</span>

  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(tempVar || (hasLeapingChildren &amp;&amp;</span>
                          <span class="s1">!t.isLiteral(result))) {</span>
    <span class="s0">// If tempVar was provided, then the result will always be assigned</span>
    <span class="s0">// to it, even if the result does not otherwise need to be assigned</span>
    <span class="s0">// to a temporary variable.  When no tempVar is provided, we have</span>
    <span class="s0">// the flexibility to decide whether a temporary variable is really</span>
    <span class="s0">// necessary.  Unfortunately, in general, a temporary variable is</span>
    <span class="s0">// required whenever any child contains a yield expression, since it</span>
    <span class="s0">// is difficult to prove (at all, let alone efficiently) whether</span>
    <span class="s0">// this result would evaluate to the same value before and after the</span>
    <span class="s0">// yield (see #206).  One narrow case where we can prove it doesn't</span>
    <span class="s0">// matter (and thus we do not need a temporary variable) is when the</span>
    <span class="s0">// result in question is a Literal value.</span>
    <span class="s1">result = </span><span class="s3">this</span><span class="s1">.emitAssign(</span>
      <span class="s1">tempVar || </span><span class="s3">this</span><span class="s1">.makeTempVar(),</span>
      <span class="s1">result</span>
    <span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">result;</span>
<span class="s1">};</span>

<span class="s1">Ep.explodeExpression = </span><span class="s3">function</span><span class="s1">(path, ignoreResult) {</span>
  <span class="s1">const t = util.getTypes();</span>
  <span class="s1">let expr = path.node;</span>
  <span class="s3">if </span><span class="s1">(expr) {</span>
    <span class="s1">t.assertExpression(expr);</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s3">return </span><span class="s1">expr;</span>
  <span class="s1">}</span>

  <span class="s1">let self = </span><span class="s3">this</span><span class="s1">;</span>
  <span class="s1">let result; </span><span class="s0">// Used optionally by several cases below.</span>
  <span class="s1">let after;</span>

  <span class="s3">function </span><span class="s1">finish(expr) {</span>
    <span class="s1">t.assertExpression(expr);</span>
    <span class="s3">if </span><span class="s1">(ignoreResult) {</span>
      <span class="s1">self.emit(expr);</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s1">expr;</span>
  <span class="s1">}</span>

  <span class="s0">// If the expression does not contain a leap, then we either emit the</span>
  <span class="s0">// expression as a standalone statement or return it whole.</span>
  <span class="s3">if </span><span class="s1">(!meta.containsLeap(expr)) {</span>
    <span class="s3">return </span><span class="s1">finish(expr);</span>
  <span class="s1">}</span>

  <span class="s0">// If any child contains a leap (such as a yield or labeled continue or</span>
  <span class="s0">// break statement), then any sibling subexpressions will almost</span>
  <span class="s0">// certainly have to be exploded in order to maintain the order of their</span>
  <span class="s0">// side effects relative to the leaping child(ren).</span>
  <span class="s1">let hasLeapingChildren = meta.containsLeap.onlyChildren(expr);</span>

  <span class="s0">// If ignoreResult is true, then we must take full responsibility for</span>
  <span class="s0">// emitting the expression with all its side effects, and we should not</span>
  <span class="s0">// return a result.</span>

  <span class="s3">switch </span><span class="s1">(expr.type) {</span>
  <span class="s3">case </span><span class="s2">&quot;MemberExpression&quot;</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">finish(t.memberExpression(</span>
      <span class="s1">self.explodeExpression(path.get(</span><span class="s2">&quot;object&quot;</span><span class="s1">)),</span>
      <span class="s1">expr.computed</span>
        <span class="s1">? self.explodeViaTempVar(</span><span class="s3">null</span><span class="s1">, path.get(</span><span class="s2">&quot;property&quot;</span><span class="s1">), hasLeapingChildren)</span>
        <span class="s1">: expr.property,</span>
      <span class="s1">expr.computed</span>
    <span class="s1">));</span>

  <span class="s3">case </span><span class="s2">&quot;CallExpression&quot;</span><span class="s1">:</span>
    <span class="s1">let calleePath = path.get(</span><span class="s2">&quot;callee&quot;</span><span class="s1">);</span>
    <span class="s1">let argsPath = path.get(</span><span class="s2">&quot;arguments&quot;</span><span class="s1">);</span>

    <span class="s1">let newCallee;</span>
    <span class="s1">let newArgs;</span>

    <span class="s1">let hasLeapingArgs = argsPath.some(</span>
      <span class="s1">argPath =&gt; meta.containsLeap(argPath.node)</span>
    <span class="s1">);</span>

    <span class="s1">let injectFirstArg = </span><span class="s3">null</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s1">(t.isMemberExpression(calleePath.node)) {</span>
      <span class="s3">if </span><span class="s1">(hasLeapingArgs) {</span>
        <span class="s0">// If the arguments of the CallExpression contained any yield</span>
        <span class="s0">// expressions, then we need to be sure to evaluate the callee</span>
        <span class="s0">// before evaluating the arguments, but if the callee was a member</span>
        <span class="s0">// expression, then we must be careful that the object of the</span>
        <span class="s0">// member expression still gets bound to `this` for the call.</span>

        <span class="s1">let newObject = self.explodeViaTempVar(</span>
          <span class="s0">// Assign the exploded callee.object expression to a temporary</span>
          <span class="s0">// variable so that we can use it twice without reevaluating it.</span>
          <span class="s1">self.makeTempVar(),</span>
          <span class="s1">calleePath.get(</span><span class="s2">&quot;object&quot;</span><span class="s1">),</span>
          <span class="s1">hasLeapingChildren</span>
        <span class="s1">);</span>

        <span class="s1">let newProperty = calleePath.node.computed</span>
          <span class="s1">? self.explodeViaTempVar(</span><span class="s3">null</span><span class="s1">, calleePath.get(</span><span class="s2">&quot;property&quot;</span><span class="s1">), hasLeapingChildren)</span>
          <span class="s1">: calleePath.node.property;</span>

        <span class="s1">injectFirstArg = newObject;</span>

        <span class="s1">newCallee = t.memberExpression(</span>
          <span class="s1">t.memberExpression(</span>
            <span class="s1">t.cloneDeep(newObject),</span>
            <span class="s1">newProperty,</span>
            <span class="s1">calleePath.node.computed</span>
          <span class="s1">),</span>
          <span class="s1">t.identifier(</span><span class="s2">&quot;call&quot;</span><span class="s1">),</span>
          <span class="s3">false</span>
        <span class="s1">);</span>

      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">newCallee = self.explodeExpression(calleePath);</span>
      <span class="s1">}</span>

    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">newCallee = self.explodeViaTempVar(</span><span class="s3">null</span><span class="s1">, calleePath, hasLeapingChildren);</span>

      <span class="s3">if </span><span class="s1">(t.isMemberExpression(newCallee)) {</span>
        <span class="s0">// If the callee was not previously a MemberExpression, then the</span>
        <span class="s0">// CallExpression was &quot;unqualified,&quot; meaning its `this` object</span>
        <span class="s0">// should be the global object. If the exploded expression has</span>
        <span class="s0">// become a MemberExpression (e.g. a context property, probably a</span>
        <span class="s0">// temporary variable), then we need to force it to be unqualified</span>
        <span class="s0">// by using the (0, object.property)(...) trick; otherwise, it</span>
        <span class="s0">// will receive the object of the MemberExpression as its `this`</span>
        <span class="s0">// object.</span>
        <span class="s1">newCallee = t.sequenceExpression([</span>
          <span class="s1">t.numericLiteral(</span><span class="s4">0</span><span class="s1">),</span>
          <span class="s1">t.cloneDeep(newCallee)</span>
        <span class="s1">]);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(hasLeapingArgs) {</span>
      <span class="s1">newArgs = argsPath.map(argPath =&gt; self.explodeViaTempVar(</span><span class="s3">null</span><span class="s1">, argPath, hasLeapingChildren));</span>
      <span class="s3">if </span><span class="s1">(injectFirstArg) newArgs.unshift(injectFirstArg);</span>

      <span class="s1">newArgs = newArgs.map(arg =&gt; t.cloneDeep(arg));</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">newArgs = path.node.arguments;</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">finish(t.callExpression(newCallee, newArgs));</span>

  <span class="s3">case </span><span class="s2">&quot;NewExpression&quot;</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">finish(t.newExpression(</span>
     <span class="s1">self.explodeViaTempVar(</span><span class="s3">null</span><span class="s1">, path.get(</span><span class="s2">&quot;callee&quot;</span><span class="s1">), hasLeapingChildren),</span>
       <span class="s1">path.get(</span><span class="s2">&quot;arguments&quot;</span><span class="s1">).map(</span><span class="s3">function</span><span class="s1">(argPath) {</span>
        <span class="s3">return </span><span class="s1">self.explodeViaTempVar(</span><span class="s3">null</span><span class="s1">, argPath, hasLeapingChildren);</span>
      <span class="s1">})</span>
    <span class="s1">));</span>

  <span class="s3">case </span><span class="s2">&quot;ObjectExpression&quot;</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">finish(t.objectExpression(</span>
      <span class="s1">path.get(</span><span class="s2">&quot;properties&quot;</span><span class="s1">).map(</span><span class="s3">function</span><span class="s1">(propPath) {</span>
        <span class="s3">if </span><span class="s1">(propPath.isObjectProperty()) {</span>
          <span class="s3">return </span><span class="s1">t.objectProperty(</span>
            <span class="s1">propPath.node.key,</span>
            <span class="s1">self.explodeViaTempVar(</span><span class="s3">null</span><span class="s1">, propPath.get(</span><span class="s2">&quot;value&quot;</span><span class="s1">), hasLeapingChildren),</span>
            <span class="s1">propPath.node.computed</span>
          <span class="s1">);</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s3">return </span><span class="s1">propPath.node;</span>
        <span class="s1">}</span>
      <span class="s1">})</span>
    <span class="s1">));</span>

  <span class="s3">case </span><span class="s2">&quot;ArrayExpression&quot;</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">finish(t.arrayExpression(</span>
      <span class="s1">path.get(</span><span class="s2">&quot;elements&quot;</span><span class="s1">).map(</span><span class="s3">function</span><span class="s1">(elemPath) {</span>
        <span class="s3">if </span><span class="s1">(!elemPath.node) {</span>
          <span class="s3">return null</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s3">if </span><span class="s1">(elemPath.isSpreadElement()) {</span>
          <span class="s3">return </span><span class="s1">t.spreadElement(</span>
            <span class="s1">self.explodeViaTempVar(</span><span class="s3">null</span><span class="s1">, elemPath.get(</span><span class="s2">&quot;argument&quot;</span><span class="s1">), hasLeapingChildren)</span>
          <span class="s1">);</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s3">return </span><span class="s1">self.explodeViaTempVar(</span><span class="s3">null</span><span class="s1">, elemPath, hasLeapingChildren);</span>
        <span class="s1">}</span>
      <span class="s1">})</span>
    <span class="s1">));</span>

  <span class="s3">case </span><span class="s2">&quot;SequenceExpression&quot;</span><span class="s1">:</span>
    <span class="s1">let lastIndex = expr.expressions.length - </span><span class="s4">1</span><span class="s1">;</span>

    <span class="s1">path.get(</span><span class="s2">&quot;expressions&quot;</span><span class="s1">).forEach(</span><span class="s3">function</span><span class="s1">(exprPath) {</span>
      <span class="s3">if </span><span class="s1">(exprPath.key === lastIndex) {</span>
        <span class="s1">result = self.explodeExpression(exprPath, ignoreResult);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">self.explodeExpression(exprPath, </span><span class="s3">true</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">});</span>

    <span class="s3">return </span><span class="s1">result;</span>

  <span class="s3">case </span><span class="s2">&quot;LogicalExpression&quot;</span><span class="s1">:</span>
    <span class="s1">after = </span><span class="s3">this</span><span class="s1">.loc();</span>

    <span class="s3">if </span><span class="s1">(!ignoreResult) {</span>
      <span class="s1">result = self.makeTempVar();</span>
    <span class="s1">}</span>

    <span class="s1">let left = self.explodeViaTempVar(result, path.get(</span><span class="s2">&quot;left&quot;</span><span class="s1">), hasLeapingChildren);</span>

    <span class="s3">if </span><span class="s1">(expr.operator === </span><span class="s2">&quot;&amp;&amp;&quot;</span><span class="s1">) {</span>
      <span class="s1">self.jumpIfNot(left, after);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">assert.strictEqual(expr.operator, </span><span class="s2">&quot;||&quot;</span><span class="s1">);</span>
      <span class="s1">self.jumpIf(left, after);</span>
    <span class="s1">}</span>

    <span class="s1">self.explodeViaTempVar(result, path.get(</span><span class="s2">&quot;right&quot;</span><span class="s1">), hasLeapingChildren, ignoreResult);</span>

    <span class="s1">self.mark(after);</span>

    <span class="s3">return </span><span class="s1">result;</span>

  <span class="s3">case </span><span class="s2">&quot;ConditionalExpression&quot;</span><span class="s1">:</span>
    <span class="s1">let elseLoc = </span><span class="s3">this</span><span class="s1">.loc();</span>
    <span class="s1">after = </span><span class="s3">this</span><span class="s1">.loc();</span>
    <span class="s1">let test = self.explodeExpression(path.get(</span><span class="s2">&quot;test&quot;</span><span class="s1">));</span>

    <span class="s1">self.jumpIfNot(test, elseLoc);</span>

    <span class="s3">if </span><span class="s1">(!ignoreResult) {</span>
      <span class="s1">result = self.makeTempVar();</span>
    <span class="s1">}</span>

    <span class="s1">self.explodeViaTempVar(result, path.get(</span><span class="s2">&quot;consequent&quot;</span><span class="s1">), hasLeapingChildren, ignoreResult);</span>
    <span class="s1">self.jump(after);</span>

    <span class="s1">self.mark(elseLoc);</span>
    <span class="s1">self.explodeViaTempVar(result, path.get(</span><span class="s2">&quot;alternate&quot;</span><span class="s1">), hasLeapingChildren, ignoreResult);</span>

    <span class="s1">self.mark(after);</span>

    <span class="s3">return </span><span class="s1">result;</span>

  <span class="s3">case </span><span class="s2">&quot;UnaryExpression&quot;</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">finish(t.unaryExpression(</span>
      <span class="s1">expr.operator,</span>
      <span class="s0">// Can't (and don't need to) break up the syntax of the argument.</span>
      <span class="s0">// Think about delete a[b].</span>
      <span class="s1">self.explodeExpression(path.get(</span><span class="s2">&quot;argument&quot;</span><span class="s1">)),</span>
      <span class="s1">!!expr.prefix</span>
    <span class="s1">));</span>

  <span class="s3">case </span><span class="s2">&quot;BinaryExpression&quot;</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">finish(t.binaryExpression(</span>
      <span class="s1">expr.operator,</span>
      <span class="s1">self.explodeViaTempVar(</span><span class="s3">null</span><span class="s1">, path.get(</span><span class="s2">&quot;left&quot;</span><span class="s1">), hasLeapingChildren),</span>
      <span class="s1">self.explodeViaTempVar(</span><span class="s3">null</span><span class="s1">, path.get(</span><span class="s2">&quot;right&quot;</span><span class="s1">), hasLeapingChildren)</span>
    <span class="s1">));</span>

  <span class="s3">case </span><span class="s2">&quot;AssignmentExpression&quot;</span><span class="s1">:</span>
    <span class="s3">if </span><span class="s1">(expr.operator === </span><span class="s2">&quot;=&quot;</span><span class="s1">) {</span>
      <span class="s0">// If this is a simple assignment, the left hand side does not need</span>
      <span class="s0">// to be read before the right hand side is evaluated, so we can</span>
      <span class="s0">// avoid the more complicated logic below.</span>
      <span class="s3">return </span><span class="s1">finish(t.assignmentExpression(</span>
        <span class="s1">expr.operator,</span>
        <span class="s1">self.explodeExpression(path.get(</span><span class="s2">&quot;left&quot;</span><span class="s1">)),</span>
        <span class="s1">self.explodeExpression(path.get(</span><span class="s2">&quot;right&quot;</span><span class="s1">))</span>
      <span class="s1">));</span>
    <span class="s1">}</span>

    <span class="s1">const lhs = self.explodeExpression(path.get(</span><span class="s2">&quot;left&quot;</span><span class="s1">));</span>
    <span class="s1">const temp = self.emitAssign(self.makeTempVar(), lhs);</span>

    <span class="s0">// For example,</span>
    <span class="s0">//</span>
    <span class="s0">//   x += yield y</span>
    <span class="s0">//</span>
    <span class="s0">// becomes</span>
    <span class="s0">//</span>
    <span class="s0">//   context.t0 = x</span>
    <span class="s0">//   x = context.t0 += yield y</span>
    <span class="s0">//</span>
    <span class="s0">// so that the left-hand side expression is read before the yield.</span>
    <span class="s0">// Fixes https://github.com/facebook/regenerator/issues/345.</span>

    <span class="s3">return </span><span class="s1">finish(t.assignmentExpression(</span>
      <span class="s2">&quot;=&quot;</span><span class="s1">,</span>
      <span class="s1">t.cloneDeep(lhs),</span>
      <span class="s1">t.assignmentExpression(</span>
        <span class="s1">expr.operator,</span>
        <span class="s1">t.cloneDeep(temp),</span>
        <span class="s1">self.explodeExpression(path.get(</span><span class="s2">&quot;right&quot;</span><span class="s1">))</span>
      <span class="s1">)</span>
    <span class="s1">));</span>

  <span class="s3">case </span><span class="s2">&quot;UpdateExpression&quot;</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">finish(t.updateExpression(</span>
      <span class="s1">expr.operator,</span>
      <span class="s1">self.explodeExpression(path.get(</span><span class="s2">&quot;argument&quot;</span><span class="s1">)),</span>
      <span class="s1">expr.prefix</span>
    <span class="s1">));</span>

  <span class="s3">case </span><span class="s2">&quot;YieldExpression&quot;</span><span class="s1">:</span>
    <span class="s1">after = </span><span class="s3">this</span><span class="s1">.loc();</span>
    <span class="s1">let arg = expr.argument &amp;&amp; self.explodeExpression(path.get(</span><span class="s2">&quot;argument&quot;</span><span class="s1">));</span>

    <span class="s3">if </span><span class="s1">(arg &amp;&amp; expr.delegate) {</span>
      <span class="s1">let result = self.makeTempVar();</span>

      <span class="s1">let ret = t.returnStatement(t.callExpression(</span>
        <span class="s1">self.contextProperty(</span><span class="s2">&quot;delegateYield&quot;</span><span class="s1">),</span>
        <span class="s1">[</span>
          <span class="s1">arg,</span>
          <span class="s1">t.stringLiteral(result.property.name),</span>
          <span class="s1">after</span>
        <span class="s1">]</span>
      <span class="s1">));</span>
      <span class="s1">ret.loc = expr.loc;</span>

      <span class="s1">self.emit(ret);</span>
      <span class="s1">self.mark(after);</span>

      <span class="s3">return </span><span class="s1">result;</span>
    <span class="s1">}</span>

    <span class="s1">self.emitAssign(self.contextProperty(</span><span class="s2">&quot;next&quot;</span><span class="s1">), after);</span>

    <span class="s1">let ret = t.returnStatement(t.cloneDeep(arg) || </span><span class="s3">null</span><span class="s1">);</span>
    <span class="s0">// Preserve the `yield` location so that source mappings for the statements</span>
    <span class="s0">// link back to the yield properly.</span>
    <span class="s1">ret.loc = expr.loc;</span>
    <span class="s1">self.emit(ret);</span>
    <span class="s1">self.mark(after);</span>

    <span class="s3">return </span><span class="s1">self.contextProperty(</span><span class="s2">&quot;sent&quot;</span><span class="s1">);</span>

  <span class="s3">case </span><span class="s2">&quot;ClassExpression&quot;</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">finish(self.explodeClass(path));</span>

  <span class="s3">default</span><span class="s1">:</span>
    <span class="s3">throw new </span><span class="s1">Error(</span>
      <span class="s2">&quot;unknown Expression of type &quot; </span><span class="s1">+</span>
        <span class="s1">JSON.stringify(expr.type));</span>
  <span class="s1">}</span>
<span class="s1">};</span>

<span class="s1">Ep.explodeClass = </span><span class="s3">function</span><span class="s1">(path) {</span>
  <span class="s1">const explodingChildren = [];</span>

  <span class="s3">if </span><span class="s1">(path.node.superClass) {</span>
    <span class="s1">explodingChildren.push(path.get(</span><span class="s2">&quot;superClass&quot;</span><span class="s1">));</span>
  <span class="s1">}</span>

  <span class="s1">path.get(</span><span class="s2">&quot;body.body&quot;</span><span class="s1">).forEach(member =&gt; {</span>
    <span class="s3">if </span><span class="s1">(member.node.computed) {</span>
      <span class="s1">explodingChildren.push(member.get(</span><span class="s2">&quot;key&quot;</span><span class="s1">));</span>
    <span class="s1">}</span>
  <span class="s1">});</span>

  <span class="s1">const hasLeapingChildren = explodingChildren.some(</span>
    <span class="s1">child =&gt; meta.containsLeap(child));</span>

  <span class="s3">for </span><span class="s1">(let i = </span><span class="s4">0</span><span class="s1">; i &lt; explodingChildren.length; i++) {</span>
    <span class="s1">const child = explodingChildren[i];</span>
    <span class="s1">const isLast = i === explodingChildren.length - </span><span class="s4">1</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s1">(isLast) {</span>
      <span class="s1">child.replaceWith(</span><span class="s3">this</span><span class="s1">.explodeExpression(child));</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">child.replaceWith(</span><span class="s3">this</span><span class="s1">.explodeViaTempVar(</span><span class="s3">null</span><span class="s1">, child, hasLeapingChildren));</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">path.node;</span>
<span class="s1">};</span>
</pre>
</body>
</html>
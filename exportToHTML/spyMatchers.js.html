<html>
<head>
<title>spyMatchers.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6a8759;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
.s5 { color: #4646f1;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
spyMatchers.js</font>
</center></td></tr></table>
<pre><span class="s0">'use strict'</span><span class="s1">;</span>

<span class="s1">Object.defineProperty(exports, </span><span class="s0">'__esModule'</span><span class="s1">, {</span>
  <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s1">exports.</span><span class="s2">default </span><span class="s1">= </span><span class="s2">void </span><span class="s3">0</span><span class="s1">;</span>
<span class="s2">var </span><span class="s1">_expectUtils = require(</span><span class="s0">'@jest/expect-utils'</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_jestGetType = require(</span><span class="s0">'jest-get-type'</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_jestMatcherUtils = require(</span><span class="s0">'jest-matcher-utils'</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_jestMatchersObject = require(</span><span class="s0">'./jestMatchersObject'</span><span class="s1">);</span>
<span class="s4">/** 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>

<span class="s4">// The optional property of matcher context is true if undefined.</span>
<span class="s1">const isExpand = expand =&gt; expand !== </span><span class="s2">false</span><span class="s1">;</span>
<span class="s1">const PRINT_LIMIT = </span><span class="s3">3</span><span class="s1">;</span>
<span class="s1">const NO_ARGUMENTS = </span><span class="s0">'called with 0 arguments'</span><span class="s1">;</span>
<span class="s1">const printExpectedArgs = expected =&gt;</span>
  <span class="s1">expected.length === </span><span class="s3">0</span>
    <span class="s1">? NO_ARGUMENTS</span>
    <span class="s1">: expected.map(arg =&gt; (</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.printExpected)(arg)).join(</span><span class="s0">', '</span><span class="s1">);</span>
<span class="s1">const printReceivedArgs = (received, expected) =&gt;</span>
  <span class="s1">received.length === </span><span class="s3">0</span>
    <span class="s1">? NO_ARGUMENTS</span>
    <span class="s1">: received</span>
        <span class="s1">.map((arg, i) =&gt;</span>
          <span class="s1">Array.isArray(expected) &amp;&amp;</span>
          <span class="s1">i &lt; expected.length &amp;&amp;</span>
          <span class="s1">isEqualValue(expected[i], arg)</span>
            <span class="s1">? printCommon(arg)</span>
            <span class="s1">: (</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.printReceived)(arg)</span>
        <span class="s1">)</span>
        <span class="s1">.join(</span><span class="s0">', '</span><span class="s1">);</span>
<span class="s1">const printCommon = val =&gt;</span>
  <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.DIM_COLOR)((</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.stringify)(val));</span>
<span class="s1">const isEqualValue = (expected, received) =&gt;</span>
  <span class="s1">(</span><span class="s3">0</span><span class="s1">, _expectUtils.equals)(expected, received, [</span>
    <span class="s1">...(</span><span class="s3">0</span><span class="s1">, _jestMatchersObject.getCustomEqualityTesters)(),</span>
    <span class="s1">_expectUtils.iterableEquality</span>
  <span class="s1">]);</span>
<span class="s1">const isEqualCall = (expected, received) =&gt;</span>
  <span class="s1">received.length === expected.length &amp;&amp; isEqualValue(expected, received);</span>
<span class="s1">const isEqualReturn = (expected, result) =&gt;</span>
  <span class="s1">result.type === </span><span class="s0">'return' </span><span class="s1">&amp;&amp; isEqualValue(expected, result.value);</span>
<span class="s1">const countReturns = results =&gt;</span>
  <span class="s1">results.reduce((n, result) =&gt; (result.type === </span><span class="s0">'return' </span><span class="s1">? n + </span><span class="s3">1 </span><span class="s1">: n), </span><span class="s3">0</span><span class="s1">);</span>
<span class="s1">const printNumberOfReturns = (countReturns, countCalls) =&gt;</span>
  <span class="s1">`\nNumber of returns: ${(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.printReceived)(countReturns)}${</span>
    <span class="s1">countCalls !== countReturns</span>
      <span class="s1">? `\nNumber of calls:   ${(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.printReceived)(</span>
          <span class="s1">countCalls</span>
        <span class="s1">)}`</span>
      <span class="s1">: </span><span class="s0">''</span>
  <span class="s1">}`;</span>
<span class="s4">// Given a label, return a function which given a string,</span>
<span class="s4">// right-aligns it preceding the colon in the label.</span>
<span class="s1">const getRightAlignedPrinter = label =&gt; {</span>
  <span class="s4">// Assume that the label contains a colon.</span>
  <span class="s1">const index = label.indexOf(</span><span class="s0">':'</span><span class="s1">);</span>
  <span class="s1">const suffix = label.slice(index);</span>
  <span class="s2">return </span><span class="s1">(string, isExpectedCall) =&gt;</span>
    <span class="s1">(isExpectedCall</span>
      <span class="s1">? `-&gt;${</span><span class="s0">' '</span><span class="s1">.repeat(Math.max(</span><span class="s3">0</span><span class="s1">, index - </span><span class="s3">2 </span><span class="s1">- string.length))}`</span>
      <span class="s1">: </span><span class="s0">' '</span><span class="s1">.repeat(Math.max(index - string.length))) +</span>
    <span class="s1">string +</span>
    <span class="s1">suffix;</span>
<span class="s1">};</span>
<span class="s1">const printReceivedCallsNegative = (</span>
  <span class="s1">expected,</span>
  <span class="s1">indexedCalls,</span>
  <span class="s1">isOnlyCall,</span>
  <span class="s1">iExpectedCall</span>
<span class="s1">) =&gt; {</span>
  <span class="s2">if </span><span class="s1">(indexedCalls.length === </span><span class="s3">0</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s0">''</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s1">const label = </span><span class="s0">'Received:     '</span><span class="s1">;</span>
  <span class="s2">if </span><span class="s1">(isOnlyCall) {</span>
    <span class="s2">return </span><span class="s1">`${label + printReceivedArgs(indexedCalls[</span><span class="s3">0</span><span class="s1">], expected)}\n`;</span>
  <span class="s1">}</span>
  <span class="s1">const printAligned = getRightAlignedPrinter(label);</span>
  <span class="s2">return </span><span class="s1">`Received\n${indexedCalls.reduce(</span>
    <span class="s1">(printed, [i, args]) =&gt;</span>
      <span class="s1">`${</span>
        <span class="s1">printed +</span>
        <span class="s1">printAligned(String(i + </span><span class="s3">1</span><span class="s1">), i === iExpectedCall) +</span>
        <span class="s1">printReceivedArgs(args, expected)</span>
      <span class="s1">}\n`,</span>
    <span class="s0">''</span>
  <span class="s1">)}`;</span>
<span class="s1">};</span>
<span class="s1">const printExpectedReceivedCallsPositive = (</span>
  <span class="s1">expected,</span>
  <span class="s1">indexedCalls,</span>
  <span class="s1">expand,</span>
  <span class="s1">isOnlyCall,</span>
  <span class="s1">iExpectedCall</span>
<span class="s1">) =&gt; {</span>
  <span class="s1">const expectedLine = `Expected: ${printExpectedArgs(expected)}\n`;</span>
  <span class="s2">if </span><span class="s1">(indexedCalls.length === </span><span class="s3">0</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s1">expectedLine;</span>
  <span class="s1">}</span>
  <span class="s1">const label = </span><span class="s0">'Received: '</span><span class="s1">;</span>
  <span class="s2">if </span><span class="s1">(isOnlyCall &amp;&amp; (iExpectedCall === </span><span class="s3">0 </span><span class="s1">|| iExpectedCall === undefined)) {</span>
    <span class="s1">const received = indexedCalls[</span><span class="s3">0</span><span class="s1">][</span><span class="s3">1</span><span class="s1">];</span>
    <span class="s2">if </span><span class="s1">(isLineDiffableCall(expected, received)) {</span>
      <span class="s4">// Display diff without indentation.</span>
      <span class="s1">const lines = [</span>
        <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.EXPECTED_COLOR)(</span><span class="s0">'- Expected'</span><span class="s1">),</span>
        <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.RECEIVED_COLOR)(</span><span class="s0">'+ Received'</span><span class="s1">),</span>
        <span class="s0">''</span>
      <span class="s1">];</span>
      <span class="s1">const length = Math.max(expected.length, received.length);</span>
      <span class="s2">for </span><span class="s1">(let i = </span><span class="s3">0</span><span class="s1">; i &lt; length; i += </span><span class="s3">1</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(i &lt; expected.length &amp;&amp; i &lt; received.length) {</span>
          <span class="s2">if </span><span class="s1">(isEqualValue(expected[i], received[i])) {</span>
            <span class="s1">lines.push(`  ${printCommon(received[i])},`);</span>
            <span class="s2">continue</span><span class="s1">;</span>
          <span class="s1">}</span>
          <span class="s2">if </span><span class="s1">(isLineDiffableArg(expected[i], received[i])) {</span>
            <span class="s1">const difference = (</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.diff)(</span>
              <span class="s1">expected[i],</span>
              <span class="s1">received[i],</span>
              <span class="s1">{</span>
                <span class="s1">expand</span>
              <span class="s1">}</span>
            <span class="s1">);</span>
            <span class="s2">if </span><span class="s1">(</span>
              <span class="s2">typeof </span><span class="s1">difference === </span><span class="s0">'string' </span><span class="s1">&amp;&amp;</span>
              <span class="s1">difference.includes(</span><span class="s0">'- Expected'</span><span class="s1">) &amp;&amp;</span>
              <span class="s1">difference.includes(</span><span class="s0">'+ Received'</span><span class="s1">)</span>
            <span class="s1">) {</span>
              <span class="s4">// Omit annotation in case multiple args have diff.</span>
              <span class="s1">lines.push(`${difference.split(</span><span class="s0">'</span><span class="s5">\n</span><span class="s0">'</span><span class="s1">).slice(</span><span class="s3">3</span><span class="s1">).join(</span><span class="s0">'</span><span class="s5">\n</span><span class="s0">'</span><span class="s1">)},`);</span>
              <span class="s2">continue</span><span class="s1">;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(i &lt; expected.length) {</span>
          <span class="s1">lines.push(</span>
            <span class="s1">`${(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.EXPECTED_COLOR)(</span>
              <span class="s1">`- ${(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.stringify)(expected[i])}`</span>
            <span class="s1">)},`</span>
          <span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(i &lt; received.length) {</span>
          <span class="s1">lines.push(</span>
            <span class="s1">`${(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.RECEIVED_COLOR)(</span>
              <span class="s1">`+ ${(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.stringify)(received[i])}`</span>
            <span class="s1">)},`</span>
          <span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">`${lines.join(</span><span class="s0">'</span><span class="s5">\n</span><span class="s0">'</span><span class="s1">)}\n`;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">`${expectedLine + label + printReceivedArgs(received, expected)}\n`;</span>
  <span class="s1">}</span>
  <span class="s1">const printAligned = getRightAlignedPrinter(label);</span>
  <span class="s2">return </span><span class="s1">(</span>
    <span class="s4">// eslint-disable-next-line prefer-template</span>
    <span class="s1">expectedLine +</span>
    <span class="s0">'Received</span><span class="s5">\n</span><span class="s0">' </span><span class="s1">+</span>
    <span class="s1">indexedCalls.reduce((printed, [i, received]) =&gt; {</span>
      <span class="s1">const aligned = printAligned(String(i + </span><span class="s3">1</span><span class="s1">), i === iExpectedCall);</span>
      <span class="s2">return </span><span class="s1">`${</span>
        <span class="s1">printed +</span>
        <span class="s1">((i === iExpectedCall || iExpectedCall === undefined) &amp;&amp;</span>
        <span class="s1">isLineDiffableCall(expected, received)</span>
          <span class="s1">? aligned.replace(</span><span class="s0">': '</span><span class="s1">, </span><span class="s0">'</span><span class="s5">\n</span><span class="s0">'</span><span class="s1">) +</span>
            <span class="s1">printDiffCall(expected, received, expand)</span>
          <span class="s1">: aligned + printReceivedArgs(received, expected))</span>
      <span class="s1">}\n`;</span>
    <span class="s1">}, </span><span class="s0">''</span><span class="s1">)</span>
  <span class="s1">);</span>
<span class="s1">};</span>
<span class="s1">const indentation = </span><span class="s0">'Received'</span><span class="s1">.replace(/\w/g, </span><span class="s0">' '</span><span class="s1">);</span>
<span class="s1">const printDiffCall = (expected, received, expand) =&gt;</span>
  <span class="s1">received</span>
    <span class="s1">.map((arg, i) =&gt; {</span>
      <span class="s2">if </span><span class="s1">(i &lt; expected.length) {</span>
        <span class="s2">if </span><span class="s1">(isEqualValue(expected[i], arg)) {</span>
          <span class="s2">return </span><span class="s1">`${indentation}  ${printCommon(arg)},`;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(isLineDiffableArg(expected[i], arg)) {</span>
          <span class="s1">const difference = (</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.diff)(expected[i], arg, {</span>
            <span class="s1">expand</span>
          <span class="s1">});</span>
          <span class="s2">if </span><span class="s1">(</span>
            <span class="s2">typeof </span><span class="s1">difference === </span><span class="s0">'string' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">difference.includes(</span><span class="s0">'- Expected'</span><span class="s1">) &amp;&amp;</span>
            <span class="s1">difference.includes(</span><span class="s0">'+ Received'</span><span class="s1">)</span>
          <span class="s1">) {</span>
            <span class="s4">// Display diff with indentation.</span>
            <span class="s4">// Omit annotation in case multiple args have diff.</span>
            <span class="s2">return </span><span class="s1">`${difference</span>
              <span class="s1">.split(</span><span class="s0">'</span><span class="s5">\n</span><span class="s0">'</span><span class="s1">)</span>
              <span class="s1">.slice(</span><span class="s3">3</span><span class="s1">)</span>
              <span class="s1">.map(line =&gt; indentation + line)</span>
              <span class="s1">.join(</span><span class="s0">'</span><span class="s5">\n</span><span class="s0">'</span><span class="s1">)},`;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s4">// Display + only if received arg has no corresponding expected arg.</span>
      <span class="s2">return </span><span class="s1">`${</span>
        <span class="s1">indentation +</span>
        <span class="s1">(i &lt; expected.length</span>
          <span class="s1">? `  ${(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.printReceived)(arg)}`</span>
          <span class="s1">: (</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.RECEIVED_COLOR)(</span>
              <span class="s1">`+ ${(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.stringify)(arg)}`</span>
            <span class="s1">))</span>
      <span class="s1">},`;</span>
    <span class="s1">})</span>
    <span class="s1">.join(</span><span class="s0">'</span><span class="s5">\n</span><span class="s0">'</span><span class="s1">);</span>
<span class="s1">const isLineDiffableCall = (expected, received) =&gt;</span>
  <span class="s1">expected.some(</span>
    <span class="s1">(arg, i) =&gt; i &lt; received.length &amp;&amp; isLineDiffableArg(arg, received[i])</span>
  <span class="s1">);</span>

<span class="s4">// Almost redundant with function in jest-matcher-utils,</span>
<span class="s4">// except no line diff for any strings.</span>
<span class="s1">const isLineDiffableArg = (expected, received) =&gt; {</span>
  <span class="s1">const expectedType = (</span><span class="s3">0</span><span class="s1">, _jestGetType.getType)(expected);</span>
  <span class="s1">const receivedType = (</span><span class="s3">0</span><span class="s1">, _jestGetType.getType)(received);</span>
  <span class="s2">if </span><span class="s1">(expectedType !== receivedType) {</span>
    <span class="s2">return false</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _jestGetType.isPrimitive)(expected)) {</span>
    <span class="s2">return false</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(</span>
    <span class="s1">expectedType === </span><span class="s0">'date' </span><span class="s1">||</span>
    <span class="s1">expectedType === </span><span class="s0">'function' </span><span class="s1">||</span>
    <span class="s1">expectedType === </span><span class="s0">'regexp'</span>
  <span class="s1">) {</span>
    <span class="s2">return false</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(expected </span><span class="s2">instanceof </span><span class="s1">Error &amp;&amp; received </span><span class="s2">instanceof </span><span class="s1">Error) {</span>
    <span class="s2">return false</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(</span>
    <span class="s1">expectedType === </span><span class="s0">'object' </span><span class="s1">&amp;&amp;</span>
    <span class="s2">typeof </span><span class="s1">expected.asymmetricMatch === </span><span class="s0">'function'</span>
  <span class="s1">) {</span>
    <span class="s2">return false</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(</span>
    <span class="s1">receivedType === </span><span class="s0">'object' </span><span class="s1">&amp;&amp;</span>
    <span class="s2">typeof </span><span class="s1">received.asymmetricMatch === </span><span class="s0">'function'</span>
  <span class="s1">) {</span>
    <span class="s2">return false</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">return true</span><span class="s1">;</span>
<span class="s1">};</span>
<span class="s1">const printResult = (result, expected) =&gt;</span>
  <span class="s1">result.type === </span><span class="s0">'throw'</span>
    <span class="s1">? </span><span class="s0">'function call threw an error'</span>
    <span class="s1">: result.type === </span><span class="s0">'incomplete'</span>
    <span class="s1">? </span><span class="s0">'function call has not returned yet'</span>
    <span class="s1">: isEqualValue(expected, result.value)</span>
    <span class="s1">? printCommon(result.value)</span>
    <span class="s1">: (</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.printReceived)(result.value);</span>
<span class="s4">// Return either empty string or one line per indexed result,</span>
<span class="s4">// so additional empty line can separate from `Number of returns` which follows.</span>
<span class="s1">const printReceivedResults = (</span>
  <span class="s1">label,</span>
  <span class="s1">expected,</span>
  <span class="s1">indexedResults,</span>
  <span class="s1">isOnlyCall,</span>
  <span class="s1">iExpectedCall</span>
<span class="s1">) =&gt; {</span>
  <span class="s2">if </span><span class="s1">(indexedResults.length === </span><span class="s3">0</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s0">''</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(isOnlyCall &amp;&amp; (iExpectedCall === </span><span class="s3">0 </span><span class="s1">|| iExpectedCall === undefined)) {</span>
    <span class="s2">return </span><span class="s1">`${label + printResult(indexedResults[</span><span class="s3">0</span><span class="s1">][</span><span class="s3">1</span><span class="s1">], expected)}\n`;</span>
  <span class="s1">}</span>
  <span class="s1">const printAligned = getRightAlignedPrinter(label);</span>
  <span class="s2">return </span><span class="s1">(</span>
    <span class="s4">// eslint-disable-next-line prefer-template</span>
    <span class="s1">label.replace(</span><span class="s0">':'</span><span class="s1">, </span><span class="s0">''</span><span class="s1">).trim() +</span>
    <span class="s0">'</span><span class="s5">\n</span><span class="s0">' </span><span class="s1">+</span>
    <span class="s1">indexedResults.reduce(</span>
      <span class="s1">(printed, [i, result]) =&gt;</span>
        <span class="s1">`${</span>
          <span class="s1">printed +</span>
          <span class="s1">printAligned(String(i + </span><span class="s3">1</span><span class="s1">), i === iExpectedCall) +</span>
          <span class="s1">printResult(result, expected)</span>
        <span class="s1">}\n`,</span>
      <span class="s0">''</span>
    <span class="s1">)</span>
  <span class="s1">);</span>
<span class="s1">};</span>
<span class="s1">const createToBeCalledMatcher = matcherName =&gt;</span>
  <span class="s2">function </span><span class="s1">(received, expected) {</span>
    <span class="s1">const expectedArgument = </span><span class="s0">''</span><span class="s1">;</span>
    <span class="s1">const options = {</span>
      <span class="s1">isNot: </span><span class="s2">this</span><span class="s1">.isNot,</span>
      <span class="s1">promise: </span><span class="s2">this</span><span class="s1">.promise</span>
    <span class="s1">};</span>
    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.ensureNoExpected)(expected, matcherName, options);</span>
    <span class="s1">ensureMockOrSpy(received, matcherName, expectedArgument, options);</span>
    <span class="s1">const receivedIsSpy = isSpy(received);</span>
    <span class="s1">const receivedName = receivedIsSpy ? </span><span class="s0">'spy' </span><span class="s1">: received.getMockName();</span>
    <span class="s1">const count = receivedIsSpy</span>
      <span class="s1">? received.calls.count()</span>
      <span class="s1">: received.mock.calls.length;</span>
    <span class="s1">const calls = receivedIsSpy</span>
      <span class="s1">? received.calls.all().map(x =&gt; x.args)</span>
      <span class="s1">: received.mock.calls;</span>
    <span class="s1">const pass = count &gt; </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s1">const message = pass</span>
      <span class="s1">? () =&gt;</span>
          <span class="s4">// eslint-disable-next-line prefer-template</span>
          <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.matcherHint)(</span>
            <span class="s1">matcherName,</span>
            <span class="s1">receivedName,</span>
            <span class="s1">expectedArgument,</span>
            <span class="s1">options</span>
          <span class="s1">) +</span>
          <span class="s0">'</span><span class="s5">\n\n</span><span class="s0">' </span><span class="s1">+</span>
          <span class="s1">`Expected number of calls: ${(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.printExpected)(</span>
            <span class="s3">0</span>
          <span class="s1">)}\n` +</span>
          <span class="s1">`Received number of calls: ${(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.printReceived)(</span>
            <span class="s1">count</span>
          <span class="s1">)}\n\n` +</span>
          <span class="s1">calls</span>
            <span class="s1">.reduce((lines, args, i) =&gt; {</span>
              <span class="s2">if </span><span class="s1">(lines.length &lt; PRINT_LIMIT) {</span>
                <span class="s1">lines.push(`${i + </span><span class="s3">1</span><span class="s1">}: ${printReceivedArgs(args)}`);</span>
              <span class="s1">}</span>
              <span class="s2">return </span><span class="s1">lines;</span>
            <span class="s1">}, [])</span>
            <span class="s1">.join(</span><span class="s0">'</span><span class="s5">\n</span><span class="s0">'</span><span class="s1">)</span>
      <span class="s1">: () =&gt;</span>
          <span class="s4">// eslint-disable-next-line prefer-template</span>
          <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.matcherHint)(</span>
            <span class="s1">matcherName,</span>
            <span class="s1">receivedName,</span>
            <span class="s1">expectedArgument,</span>
            <span class="s1">options</span>
          <span class="s1">) +</span>
          <span class="s0">'</span><span class="s5">\n\n</span><span class="s0">' </span><span class="s1">+</span>
          <span class="s1">`Expected number of calls: &gt;= ${(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.printExpected)(</span>
            <span class="s3">1</span>
          <span class="s1">)}\n` +</span>
          <span class="s1">`Received number of calls:    ${(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.printReceived)(</span>
            <span class="s1">count</span>
          <span class="s1">)}`;</span>
    <span class="s2">return </span><span class="s1">{</span>
      <span class="s1">message,</span>
      <span class="s1">pass</span>
    <span class="s1">};</span>
  <span class="s1">};</span>
<span class="s1">const createToReturnMatcher = matcherName =&gt;</span>
  <span class="s2">function </span><span class="s1">(received, expected) {</span>
    <span class="s1">const expectedArgument = </span><span class="s0">''</span><span class="s1">;</span>
    <span class="s1">const options = {</span>
      <span class="s1">isNot: </span><span class="s2">this</span><span class="s1">.isNot,</span>
      <span class="s1">promise: </span><span class="s2">this</span><span class="s1">.promise</span>
    <span class="s1">};</span>
    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.ensureNoExpected)(expected, matcherName, options);</span>
    <span class="s1">ensureMock(received, matcherName, expectedArgument, options);</span>
    <span class="s1">const receivedName = received.getMockName();</span>

    <span class="s4">// Count return values that correspond only to calls that returned</span>
    <span class="s1">const count = received.mock.results.reduce(</span>
      <span class="s1">(n, result) =&gt; (result.type === </span><span class="s0">'return' </span><span class="s1">? n + </span><span class="s3">1 </span><span class="s1">: n),</span>
      <span class="s3">0</span>
    <span class="s1">);</span>
    <span class="s1">const pass = count &gt; </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s1">const message = pass</span>
      <span class="s1">? () =&gt;</span>
          <span class="s4">// eslint-disable-next-line prefer-template</span>
          <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.matcherHint)(</span>
            <span class="s1">matcherName,</span>
            <span class="s1">receivedName,</span>
            <span class="s1">expectedArgument,</span>
            <span class="s1">options</span>
          <span class="s1">) +</span>
          <span class="s0">'</span><span class="s5">\n\n</span><span class="s0">' </span><span class="s1">+</span>
          <span class="s1">`Expected number of returns: ${(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.printExpected)(</span>
            <span class="s3">0</span>
          <span class="s1">)}\n` +</span>
          <span class="s1">`Received number of returns: ${(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.printReceived)(</span>
            <span class="s1">count</span>
          <span class="s1">)}\n\n` +</span>
          <span class="s1">received.mock.results</span>
            <span class="s1">.reduce((lines, result, i) =&gt; {</span>
              <span class="s2">if </span><span class="s1">(result.type === </span><span class="s0">'return' </span><span class="s1">&amp;&amp; lines.length &lt; PRINT_LIMIT) {</span>
                <span class="s1">lines.push(</span>
                  <span class="s1">`${i + </span><span class="s3">1</span><span class="s1">}: ${(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.printReceived)(</span>
                    <span class="s1">result.value</span>
                  <span class="s1">)}`</span>
                <span class="s1">);</span>
              <span class="s1">}</span>
              <span class="s2">return </span><span class="s1">lines;</span>
            <span class="s1">}, [])</span>
            <span class="s1">.join(</span><span class="s0">'</span><span class="s5">\n</span><span class="s0">'</span><span class="s1">) +</span>
          <span class="s1">(received.mock.calls.length !== count</span>
            <span class="s1">? `\n\nReceived number of calls:   ${(</span><span class="s3">0</span><span class="s1">,</span>
              <span class="s1">_jestMatcherUtils.printReceived)(received.mock.calls.length)}`</span>
            <span class="s1">: </span><span class="s0">''</span><span class="s1">)</span>
      <span class="s1">: () =&gt;</span>
          <span class="s4">// eslint-disable-next-line prefer-template</span>
          <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.matcherHint)(</span>
            <span class="s1">matcherName,</span>
            <span class="s1">receivedName,</span>
            <span class="s1">expectedArgument,</span>
            <span class="s1">options</span>
          <span class="s1">) +</span>
          <span class="s0">'</span><span class="s5">\n\n</span><span class="s0">' </span><span class="s1">+</span>
          <span class="s1">`Expected number of returns: &gt;= ${(</span><span class="s3">0</span><span class="s1">,</span>
          <span class="s1">_jestMatcherUtils.printExpected)(</span><span class="s3">1</span><span class="s1">)}\n` +</span>
          <span class="s1">`Received number of returns:    ${(</span><span class="s3">0</span><span class="s1">,</span>
          <span class="s1">_jestMatcherUtils.printReceived)(count)}` +</span>
          <span class="s1">(received.mock.calls.length !== count</span>
            <span class="s1">? `\nReceived number of calls:      ${(</span><span class="s3">0</span><span class="s1">,</span>
              <span class="s1">_jestMatcherUtils.printReceived)(received.mock.calls.length)}`</span>
            <span class="s1">: </span><span class="s0">''</span><span class="s1">);</span>
    <span class="s2">return </span><span class="s1">{</span>
      <span class="s1">message,</span>
      <span class="s1">pass</span>
    <span class="s1">};</span>
  <span class="s1">};</span>
<span class="s1">const createToBeCalledTimesMatcher = matcherName =&gt;</span>
  <span class="s2">function </span><span class="s1">(received, expected) {</span>
    <span class="s1">const expectedArgument = </span><span class="s0">'expected'</span><span class="s1">;</span>
    <span class="s1">const options = {</span>
      <span class="s1">isNot: </span><span class="s2">this</span><span class="s1">.isNot,</span>
      <span class="s1">promise: </span><span class="s2">this</span><span class="s1">.promise</span>
    <span class="s1">};</span>
    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.ensureExpectedIsNonNegativeInteger)(</span>
      <span class="s1">expected,</span>
      <span class="s1">matcherName,</span>
      <span class="s1">options</span>
    <span class="s1">);</span>
    <span class="s1">ensureMockOrSpy(received, matcherName, expectedArgument, options);</span>
    <span class="s1">const receivedIsSpy = isSpy(received);</span>
    <span class="s1">const receivedName = receivedIsSpy ? </span><span class="s0">'spy' </span><span class="s1">: received.getMockName();</span>
    <span class="s1">const count = receivedIsSpy</span>
      <span class="s1">? received.calls.count()</span>
      <span class="s1">: received.mock.calls.length;</span>
    <span class="s1">const pass = count === expected;</span>
    <span class="s1">const message = pass</span>
      <span class="s1">? () =&gt;</span>
          <span class="s4">// eslint-disable-next-line prefer-template</span>
          <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.matcherHint)(</span>
            <span class="s1">matcherName,</span>
            <span class="s1">receivedName,</span>
            <span class="s1">expectedArgument,</span>
            <span class="s1">options</span>
          <span class="s1">) +</span>
          <span class="s0">'</span><span class="s5">\n\n</span><span class="s0">' </span><span class="s1">+</span>
          <span class="s1">`Expected number of calls: not ${(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.printExpected)(</span>
            <span class="s1">expected</span>
          <span class="s1">)}`</span>
      <span class="s1">: () =&gt;</span>
          <span class="s4">// eslint-disable-next-line prefer-template</span>
          <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.matcherHint)(</span>
            <span class="s1">matcherName,</span>
            <span class="s1">receivedName,</span>
            <span class="s1">expectedArgument,</span>
            <span class="s1">options</span>
          <span class="s1">) +</span>
          <span class="s0">'</span><span class="s5">\n\n</span><span class="s0">' </span><span class="s1">+</span>
          <span class="s1">`Expected number of calls: ${(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.printExpected)(</span>
            <span class="s1">expected</span>
          <span class="s1">)}\n` +</span>
          <span class="s1">`Received number of calls: ${(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.printReceived)(</span>
            <span class="s1">count</span>
          <span class="s1">)}`;</span>
    <span class="s2">return </span><span class="s1">{</span>
      <span class="s1">message,</span>
      <span class="s1">pass</span>
    <span class="s1">};</span>
  <span class="s1">};</span>
<span class="s1">const createToReturnTimesMatcher = matcherName =&gt;</span>
  <span class="s2">function </span><span class="s1">(received, expected) {</span>
    <span class="s1">const expectedArgument = </span><span class="s0">'expected'</span><span class="s1">;</span>
    <span class="s1">const options = {</span>
      <span class="s1">isNot: </span><span class="s2">this</span><span class="s1">.isNot,</span>
      <span class="s1">promise: </span><span class="s2">this</span><span class="s1">.promise</span>
    <span class="s1">};</span>
    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.ensureExpectedIsNonNegativeInteger)(</span>
      <span class="s1">expected,</span>
      <span class="s1">matcherName,</span>
      <span class="s1">options</span>
    <span class="s1">);</span>
    <span class="s1">ensureMock(received, matcherName, expectedArgument, options);</span>
    <span class="s1">const receivedName = received.getMockName();</span>

    <span class="s4">// Count return values that correspond only to calls that returned</span>
    <span class="s1">const count = received.mock.results.reduce(</span>
      <span class="s1">(n, result) =&gt; (result.type === </span><span class="s0">'return' </span><span class="s1">? n + </span><span class="s3">1 </span><span class="s1">: n),</span>
      <span class="s3">0</span>
    <span class="s1">);</span>
    <span class="s1">const pass = count === expected;</span>
    <span class="s1">const message = pass</span>
      <span class="s1">? () =&gt;</span>
          <span class="s4">// eslint-disable-next-line prefer-template</span>
          <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.matcherHint)(</span>
            <span class="s1">matcherName,</span>
            <span class="s1">receivedName,</span>
            <span class="s1">expectedArgument,</span>
            <span class="s1">options</span>
          <span class="s1">) +</span>
          <span class="s0">'</span><span class="s5">\n\n</span><span class="s0">' </span><span class="s1">+</span>
          <span class="s1">`Expected number of returns: not ${(</span><span class="s3">0</span><span class="s1">,</span>
          <span class="s1">_jestMatcherUtils.printExpected)(expected)}` +</span>
          <span class="s1">(received.mock.calls.length !== count</span>
            <span class="s1">? `\n\nReceived number of calls:       ${(</span><span class="s3">0</span><span class="s1">,</span>
              <span class="s1">_jestMatcherUtils.printReceived)(received.mock.calls.length)}`</span>
            <span class="s1">: </span><span class="s0">''</span><span class="s1">)</span>
      <span class="s1">: () =&gt;</span>
          <span class="s4">// eslint-disable-next-line prefer-template</span>
          <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.matcherHint)(</span>
            <span class="s1">matcherName,</span>
            <span class="s1">receivedName,</span>
            <span class="s1">expectedArgument,</span>
            <span class="s1">options</span>
          <span class="s1">) +</span>
          <span class="s0">'</span><span class="s5">\n\n</span><span class="s0">' </span><span class="s1">+</span>
          <span class="s1">`Expected number of returns: ${(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.printExpected)(</span>
            <span class="s1">expected</span>
          <span class="s1">)}\n` +</span>
          <span class="s1">`Received number of returns: ${(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.printReceived)(</span>
            <span class="s1">count</span>
          <span class="s1">)}` +</span>
          <span class="s1">(received.mock.calls.length !== count</span>
            <span class="s1">? `\nReceived number of calls:   ${(</span><span class="s3">0</span><span class="s1">,</span>
              <span class="s1">_jestMatcherUtils.printReceived)(received.mock.calls.length)}`</span>
            <span class="s1">: </span><span class="s0">''</span><span class="s1">);</span>
    <span class="s2">return </span><span class="s1">{</span>
      <span class="s1">message,</span>
      <span class="s1">pass</span>
    <span class="s1">};</span>
  <span class="s1">};</span>
<span class="s1">const createToBeCalledWithMatcher = matcherName =&gt;</span>
  <span class="s2">function </span><span class="s1">(received, ...expected) {</span>
    <span class="s1">const expectedArgument = </span><span class="s0">'...expected'</span><span class="s1">;</span>
    <span class="s1">const options = {</span>
      <span class="s1">isNot: </span><span class="s2">this</span><span class="s1">.isNot,</span>
      <span class="s1">promise: </span><span class="s2">this</span><span class="s1">.promise</span>
    <span class="s1">};</span>
    <span class="s1">ensureMockOrSpy(received, matcherName, expectedArgument, options);</span>
    <span class="s1">const receivedIsSpy = isSpy(received);</span>
    <span class="s1">const receivedName = receivedIsSpy ? </span><span class="s0">'spy' </span><span class="s1">: received.getMockName();</span>
    <span class="s1">const calls = receivedIsSpy</span>
      <span class="s1">? received.calls.all().map(x =&gt; x.args)</span>
      <span class="s1">: received.mock.calls;</span>
    <span class="s1">const pass = calls.some(call =&gt; isEqualCall(expected, call));</span>
    <span class="s1">const message = pass</span>
      <span class="s1">? () =&gt; {</span>
          <span class="s4">// Some examples of calls that are equal to expected value.</span>
          <span class="s1">const indexedCalls = [];</span>
          <span class="s1">let i = </span><span class="s3">0</span><span class="s1">;</span>
          <span class="s2">while </span><span class="s1">(i &lt; calls.length &amp;&amp; indexedCalls.length &lt; PRINT_LIMIT) {</span>
            <span class="s2">if </span><span class="s1">(isEqualCall(expected, calls[i])) {</span>
              <span class="s1">indexedCalls.push([i, calls[i]]);</span>
            <span class="s1">}</span>
            <span class="s1">i += </span><span class="s3">1</span><span class="s1">;</span>
          <span class="s1">}</span>
          <span class="s2">return </span><span class="s1">(</span>
            <span class="s4">// eslint-disable-next-line prefer-template</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.matcherHint)(</span>
              <span class="s1">matcherName,</span>
              <span class="s1">receivedName,</span>
              <span class="s1">expectedArgument,</span>
              <span class="s1">options</span>
            <span class="s1">) +</span>
            <span class="s0">'</span><span class="s5">\n\n</span><span class="s0">' </span><span class="s1">+</span>
            <span class="s1">`Expected: not ${printExpectedArgs(expected)}\n` +</span>
            <span class="s1">(calls.length === </span><span class="s3">1 </span><span class="s1">&amp;&amp;</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.stringify)(calls[</span><span class="s3">0</span><span class="s1">]) ===</span>
              <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.stringify)(expected)</span>
              <span class="s1">? </span><span class="s0">''</span>
              <span class="s1">: printReceivedCallsNegative(</span>
                  <span class="s1">expected,</span>
                  <span class="s1">indexedCalls,</span>
                  <span class="s1">calls.length === </span><span class="s3">1</span>
                <span class="s1">)) +</span>
            <span class="s1">`\nNumber of calls: ${(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.printReceived)(</span>
              <span class="s1">calls.length</span>
            <span class="s1">)}`</span>
          <span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">: () =&gt; {</span>
          <span class="s4">// Some examples of calls that are not equal to expected value.</span>
          <span class="s1">const indexedCalls = [];</span>
          <span class="s1">let i = </span><span class="s3">0</span><span class="s1">;</span>
          <span class="s2">while </span><span class="s1">(i &lt; calls.length &amp;&amp; indexedCalls.length &lt; PRINT_LIMIT) {</span>
            <span class="s1">indexedCalls.push([i, calls[i]]);</span>
            <span class="s1">i += </span><span class="s3">1</span><span class="s1">;</span>
          <span class="s1">}</span>
          <span class="s2">return </span><span class="s1">(</span>
            <span class="s4">// eslint-disable-next-line prefer-template</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.matcherHint)(</span>
              <span class="s1">matcherName,</span>
              <span class="s1">receivedName,</span>
              <span class="s1">expectedArgument,</span>
              <span class="s1">options</span>
            <span class="s1">) +</span>
            <span class="s0">'</span><span class="s5">\n\n</span><span class="s0">' </span><span class="s1">+</span>
            <span class="s1">printExpectedReceivedCallsPositive(</span>
              <span class="s1">expected,</span>
              <span class="s1">indexedCalls,</span>
              <span class="s1">isExpand(</span><span class="s2">this</span><span class="s1">.expand),</span>
              <span class="s1">calls.length === </span><span class="s3">1</span>
            <span class="s1">) +</span>
            <span class="s1">`\nNumber of calls: ${(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.printReceived)(</span>
              <span class="s1">calls.length</span>
            <span class="s1">)}`</span>
          <span class="s1">);</span>
        <span class="s1">};</span>
    <span class="s2">return </span><span class="s1">{</span>
      <span class="s1">message,</span>
      <span class="s1">pass</span>
    <span class="s1">};</span>
  <span class="s1">};</span>
<span class="s1">const createToReturnWithMatcher = matcherName =&gt;</span>
  <span class="s2">function </span><span class="s1">(received, expected) {</span>
    <span class="s1">const expectedArgument = </span><span class="s0">'expected'</span><span class="s1">;</span>
    <span class="s1">const options = {</span>
      <span class="s1">isNot: </span><span class="s2">this</span><span class="s1">.isNot,</span>
      <span class="s1">promise: </span><span class="s2">this</span><span class="s1">.promise</span>
    <span class="s1">};</span>
    <span class="s1">ensureMock(received, matcherName, expectedArgument, options);</span>
    <span class="s1">const receivedName = received.getMockName();</span>
    <span class="s1">const {calls, results} = received.mock;</span>
    <span class="s1">const pass = results.some(result =&gt; isEqualReturn(expected, result));</span>
    <span class="s1">const message = pass</span>
      <span class="s1">? () =&gt; {</span>
          <span class="s4">// Some examples of results that are equal to expected value.</span>
          <span class="s1">const indexedResults = [];</span>
          <span class="s1">let i = </span><span class="s3">0</span><span class="s1">;</span>
          <span class="s2">while </span><span class="s1">(i &lt; results.length &amp;&amp; indexedResults.length &lt; PRINT_LIMIT) {</span>
            <span class="s2">if </span><span class="s1">(isEqualReturn(expected, results[i])) {</span>
              <span class="s1">indexedResults.push([i, results[i]]);</span>
            <span class="s1">}</span>
            <span class="s1">i += </span><span class="s3">1</span><span class="s1">;</span>
          <span class="s1">}</span>
          <span class="s2">return </span><span class="s1">(</span>
            <span class="s4">// eslint-disable-next-line prefer-template</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.matcherHint)(</span>
              <span class="s1">matcherName,</span>
              <span class="s1">receivedName,</span>
              <span class="s1">expectedArgument,</span>
              <span class="s1">options</span>
            <span class="s1">) +</span>
            <span class="s0">'</span><span class="s5">\n\n</span><span class="s0">' </span><span class="s1">+</span>
            <span class="s1">`Expected: not ${(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.printExpected)(</span>
              <span class="s1">expected</span>
            <span class="s1">)}\n` +</span>
            <span class="s1">(results.length === </span><span class="s3">1 </span><span class="s1">&amp;&amp;</span>
            <span class="s1">results[</span><span class="s3">0</span><span class="s1">].type === </span><span class="s0">'return' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.stringify)(results[</span><span class="s3">0</span><span class="s1">].value) ===</span>
              <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.stringify)(expected)</span>
              <span class="s1">? </span><span class="s0">''</span>
              <span class="s1">: printReceivedResults(</span>
                  <span class="s0">'Received:     '</span><span class="s1">,</span>
                  <span class="s1">expected,</span>
                  <span class="s1">indexedResults,</span>
                  <span class="s1">results.length === </span><span class="s3">1</span>
                <span class="s1">)) +</span>
            <span class="s1">printNumberOfReturns(countReturns(results), calls.length)</span>
          <span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">: () =&gt; {</span>
          <span class="s4">// Some examples of results that are not equal to expected value.</span>
          <span class="s1">const indexedResults = [];</span>
          <span class="s1">let i = </span><span class="s3">0</span><span class="s1">;</span>
          <span class="s2">while </span><span class="s1">(i &lt; results.length &amp;&amp; indexedResults.length &lt; PRINT_LIMIT) {</span>
            <span class="s1">indexedResults.push([i, results[i]]);</span>
            <span class="s1">i += </span><span class="s3">1</span><span class="s1">;</span>
          <span class="s1">}</span>
          <span class="s2">return </span><span class="s1">(</span>
            <span class="s4">// eslint-disable-next-line prefer-template</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.matcherHint)(</span>
              <span class="s1">matcherName,</span>
              <span class="s1">receivedName,</span>
              <span class="s1">expectedArgument,</span>
              <span class="s1">options</span>
            <span class="s1">) +</span>
            <span class="s0">'</span><span class="s5">\n\n</span><span class="s0">' </span><span class="s1">+</span>
            <span class="s1">`Expected: ${(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.printExpected)(expected)}\n` +</span>
            <span class="s1">printReceivedResults(</span>
              <span class="s0">'Received: '</span><span class="s1">,</span>
              <span class="s1">expected,</span>
              <span class="s1">indexedResults,</span>
              <span class="s1">results.length === </span><span class="s3">1</span>
            <span class="s1">) +</span>
            <span class="s1">printNumberOfReturns(countReturns(results), calls.length)</span>
          <span class="s1">);</span>
        <span class="s1">};</span>
    <span class="s2">return </span><span class="s1">{</span>
      <span class="s1">message,</span>
      <span class="s1">pass</span>
    <span class="s1">};</span>
  <span class="s1">};</span>
<span class="s1">const createLastCalledWithMatcher = matcherName =&gt;</span>
  <span class="s2">function </span><span class="s1">(received, ...expected) {</span>
    <span class="s1">const expectedArgument = </span><span class="s0">'...expected'</span><span class="s1">;</span>
    <span class="s1">const options = {</span>
      <span class="s1">isNot: </span><span class="s2">this</span><span class="s1">.isNot,</span>
      <span class="s1">promise: </span><span class="s2">this</span><span class="s1">.promise</span>
    <span class="s1">};</span>
    <span class="s1">ensureMockOrSpy(received, matcherName, expectedArgument, options);</span>
    <span class="s1">const receivedIsSpy = isSpy(received);</span>
    <span class="s1">const receivedName = receivedIsSpy ? </span><span class="s0">'spy' </span><span class="s1">: received.getMockName();</span>
    <span class="s1">const calls = receivedIsSpy</span>
      <span class="s1">? received.calls.all().map(x =&gt; x.args)</span>
      <span class="s1">: received.mock.calls;</span>
    <span class="s1">const iLast = calls.length - </span><span class="s3">1</span><span class="s1">;</span>
    <span class="s1">const pass = iLast &gt;= </span><span class="s3">0 </span><span class="s1">&amp;&amp; isEqualCall(expected, calls[iLast]);</span>
    <span class="s1">const message = pass</span>
      <span class="s1">? () =&gt; {</span>
          <span class="s1">const indexedCalls = [];</span>
          <span class="s2">if </span><span class="s1">(iLast &gt; </span><span class="s3">0</span><span class="s1">) {</span>
            <span class="s4">// Display preceding call as context.</span>
            <span class="s1">indexedCalls.push([iLast - </span><span class="s3">1</span><span class="s1">, calls[iLast - </span><span class="s3">1</span><span class="s1">]]);</span>
          <span class="s1">}</span>
          <span class="s1">indexedCalls.push([iLast, calls[iLast]]);</span>
          <span class="s2">return </span><span class="s1">(</span>
            <span class="s4">// eslint-disable-next-line prefer-template</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.matcherHint)(</span>
              <span class="s1">matcherName,</span>
              <span class="s1">receivedName,</span>
              <span class="s1">expectedArgument,</span>
              <span class="s1">options</span>
            <span class="s1">) +</span>
            <span class="s0">'</span><span class="s5">\n\n</span><span class="s0">' </span><span class="s1">+</span>
            <span class="s1">`Expected: not ${printExpectedArgs(expected)}\n` +</span>
            <span class="s1">(calls.length === </span><span class="s3">1 </span><span class="s1">&amp;&amp;</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.stringify)(calls[</span><span class="s3">0</span><span class="s1">]) ===</span>
              <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.stringify)(expected)</span>
              <span class="s1">? </span><span class="s0">''</span>
              <span class="s1">: printReceivedCallsNegative(</span>
                  <span class="s1">expected,</span>
                  <span class="s1">indexedCalls,</span>
                  <span class="s1">calls.length === </span><span class="s3">1</span><span class="s1">,</span>
                  <span class="s1">iLast</span>
                <span class="s1">)) +</span>
            <span class="s1">`\nNumber of calls: ${(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.printReceived)(</span>
              <span class="s1">calls.length</span>
            <span class="s1">)}`</span>
          <span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">: () =&gt; {</span>
          <span class="s1">const indexedCalls = [];</span>
          <span class="s2">if </span><span class="s1">(iLast &gt;= </span><span class="s3">0</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(iLast &gt; </span><span class="s3">0</span><span class="s1">) {</span>
              <span class="s1">let i = iLast - </span><span class="s3">1</span><span class="s1">;</span>
              <span class="s4">// Is there a preceding call that is equal to expected args?</span>
              <span class="s2">while </span><span class="s1">(i &gt;= </span><span class="s3">0 </span><span class="s1">&amp;&amp; !isEqualCall(expected, calls[i])) {</span>
                <span class="s1">i -= </span><span class="s3">1</span><span class="s1">;</span>
              <span class="s1">}</span>
              <span class="s2">if </span><span class="s1">(i &lt; </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s1">i = iLast - </span><span class="s3">1</span><span class="s1">; </span><span class="s4">// otherwise, preceding call</span>
              <span class="s1">}</span>

              <span class="s1">indexedCalls.push([i, calls[i]]);</span>
            <span class="s1">}</span>
            <span class="s1">indexedCalls.push([iLast, calls[iLast]]);</span>
          <span class="s1">}</span>
          <span class="s2">return </span><span class="s1">(</span>
            <span class="s4">// eslint-disable-next-line prefer-template</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.matcherHint)(</span>
              <span class="s1">matcherName,</span>
              <span class="s1">receivedName,</span>
              <span class="s1">expectedArgument,</span>
              <span class="s1">options</span>
            <span class="s1">) +</span>
            <span class="s0">'</span><span class="s5">\n\n</span><span class="s0">' </span><span class="s1">+</span>
            <span class="s1">printExpectedReceivedCallsPositive(</span>
              <span class="s1">expected,</span>
              <span class="s1">indexedCalls,</span>
              <span class="s1">isExpand(</span><span class="s2">this</span><span class="s1">.expand),</span>
              <span class="s1">calls.length === </span><span class="s3">1</span><span class="s1">,</span>
              <span class="s1">iLast</span>
            <span class="s1">) +</span>
            <span class="s1">`\nNumber of calls: ${(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.printReceived)(</span>
              <span class="s1">calls.length</span>
            <span class="s1">)}`</span>
          <span class="s1">);</span>
        <span class="s1">};</span>
    <span class="s2">return </span><span class="s1">{</span>
      <span class="s1">message,</span>
      <span class="s1">pass</span>
    <span class="s1">};</span>
  <span class="s1">};</span>
<span class="s1">const createLastReturnedMatcher = matcherName =&gt;</span>
  <span class="s2">function </span><span class="s1">(received, expected) {</span>
    <span class="s1">const expectedArgument = </span><span class="s0">'expected'</span><span class="s1">;</span>
    <span class="s1">const options = {</span>
      <span class="s1">isNot: </span><span class="s2">this</span><span class="s1">.isNot,</span>
      <span class="s1">promise: </span><span class="s2">this</span><span class="s1">.promise</span>
    <span class="s1">};</span>
    <span class="s1">ensureMock(received, matcherName, expectedArgument, options);</span>
    <span class="s1">const receivedName = received.getMockName();</span>
    <span class="s1">const {calls, results} = received.mock;</span>
    <span class="s1">const iLast = results.length - </span><span class="s3">1</span><span class="s1">;</span>
    <span class="s1">const pass = iLast &gt;= </span><span class="s3">0 </span><span class="s1">&amp;&amp; isEqualReturn(expected, results[iLast]);</span>
    <span class="s1">const message = pass</span>
      <span class="s1">? () =&gt; {</span>
          <span class="s1">const indexedResults = [];</span>
          <span class="s2">if </span><span class="s1">(iLast &gt; </span><span class="s3">0</span><span class="s1">) {</span>
            <span class="s4">// Display preceding result as context.</span>
            <span class="s1">indexedResults.push([iLast - </span><span class="s3">1</span><span class="s1">, results[iLast - </span><span class="s3">1</span><span class="s1">]]);</span>
          <span class="s1">}</span>
          <span class="s1">indexedResults.push([iLast, results[iLast]]);</span>
          <span class="s2">return </span><span class="s1">(</span>
            <span class="s4">// eslint-disable-next-line prefer-template</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.matcherHint)(</span>
              <span class="s1">matcherName,</span>
              <span class="s1">receivedName,</span>
              <span class="s1">expectedArgument,</span>
              <span class="s1">options</span>
            <span class="s1">) +</span>
            <span class="s0">'</span><span class="s5">\n\n</span><span class="s0">' </span><span class="s1">+</span>
            <span class="s1">`Expected: not ${(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.printExpected)(</span>
              <span class="s1">expected</span>
            <span class="s1">)}\n` +</span>
            <span class="s1">(results.length === </span><span class="s3">1 </span><span class="s1">&amp;&amp;</span>
            <span class="s1">results[</span><span class="s3">0</span><span class="s1">].type === </span><span class="s0">'return' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.stringify)(results[</span><span class="s3">0</span><span class="s1">].value) ===</span>
              <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.stringify)(expected)</span>
              <span class="s1">? </span><span class="s0">''</span>
              <span class="s1">: printReceivedResults(</span>
                  <span class="s0">'Received:     '</span><span class="s1">,</span>
                  <span class="s1">expected,</span>
                  <span class="s1">indexedResults,</span>
                  <span class="s1">results.length === </span><span class="s3">1</span><span class="s1">,</span>
                  <span class="s1">iLast</span>
                <span class="s1">)) +</span>
            <span class="s1">printNumberOfReturns(countReturns(results), calls.length)</span>
          <span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">: () =&gt; {</span>
          <span class="s1">const indexedResults = [];</span>
          <span class="s2">if </span><span class="s1">(iLast &gt;= </span><span class="s3">0</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(iLast &gt; </span><span class="s3">0</span><span class="s1">) {</span>
              <span class="s1">let i = iLast - </span><span class="s3">1</span><span class="s1">;</span>
              <span class="s4">// Is there a preceding result that is equal to expected value?</span>
              <span class="s2">while </span><span class="s1">(i &gt;= </span><span class="s3">0 </span><span class="s1">&amp;&amp; !isEqualReturn(expected, results[i])) {</span>
                <span class="s1">i -= </span><span class="s3">1</span><span class="s1">;</span>
              <span class="s1">}</span>
              <span class="s2">if </span><span class="s1">(i &lt; </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s1">i = iLast - </span><span class="s3">1</span><span class="s1">; </span><span class="s4">// otherwise, preceding result</span>
              <span class="s1">}</span>

              <span class="s1">indexedResults.push([i, results[i]]);</span>
            <span class="s1">}</span>
            <span class="s1">indexedResults.push([iLast, results[iLast]]);</span>
          <span class="s1">}</span>
          <span class="s2">return </span><span class="s1">(</span>
            <span class="s4">// eslint-disable-next-line prefer-template</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.matcherHint)(</span>
              <span class="s1">matcherName,</span>
              <span class="s1">receivedName,</span>
              <span class="s1">expectedArgument,</span>
              <span class="s1">options</span>
            <span class="s1">) +</span>
            <span class="s0">'</span><span class="s5">\n\n</span><span class="s0">' </span><span class="s1">+</span>
            <span class="s1">`Expected: ${(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.printExpected)(expected)}\n` +</span>
            <span class="s1">printReceivedResults(</span>
              <span class="s0">'Received: '</span><span class="s1">,</span>
              <span class="s1">expected,</span>
              <span class="s1">indexedResults,</span>
              <span class="s1">results.length === </span><span class="s3">1</span><span class="s1">,</span>
              <span class="s1">iLast</span>
            <span class="s1">) +</span>
            <span class="s1">printNumberOfReturns(countReturns(results), calls.length)</span>
          <span class="s1">);</span>
        <span class="s1">};</span>
    <span class="s2">return </span><span class="s1">{</span>
      <span class="s1">message,</span>
      <span class="s1">pass</span>
    <span class="s1">};</span>
  <span class="s1">};</span>
<span class="s1">const createNthCalledWithMatcher = matcherName =&gt;</span>
  <span class="s2">function </span><span class="s1">(received, nth, ...expected) {</span>
    <span class="s1">const expectedArgument = </span><span class="s0">'n'</span><span class="s1">;</span>
    <span class="s1">const options = {</span>
      <span class="s1">expectedColor: arg =&gt; arg,</span>
      <span class="s1">isNot: </span><span class="s2">this</span><span class="s1">.isNot,</span>
      <span class="s1">promise: </span><span class="s2">this</span><span class="s1">.promise,</span>
      <span class="s1">secondArgument: </span><span class="s0">'...expected'</span>
    <span class="s1">};</span>
    <span class="s1">ensureMockOrSpy(received, matcherName, expectedArgument, options);</span>
    <span class="s2">if </span><span class="s1">(!Number.isSafeInteger(nth) || nth &lt; </span><span class="s3">1</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">Error(</span>
        <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.matcherErrorMessage)(</span>
          <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.matcherHint)(</span>
            <span class="s1">matcherName,</span>
            <span class="s1">undefined,</span>
            <span class="s1">expectedArgument,</span>
            <span class="s1">options</span>
          <span class="s1">),</span>
          <span class="s1">`${expectedArgument} must be a positive integer`,</span>
          <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.printWithType)(</span>
            <span class="s1">expectedArgument,</span>
            <span class="s1">nth,</span>
            <span class="s1">_jestMatcherUtils.stringify</span>
          <span class="s1">)</span>
        <span class="s1">)</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">const receivedIsSpy = isSpy(received);</span>
    <span class="s1">const receivedName = receivedIsSpy ? </span><span class="s0">'spy' </span><span class="s1">: received.getMockName();</span>
    <span class="s1">const calls = receivedIsSpy</span>
      <span class="s1">? received.calls.all().map(x =&gt; x.args)</span>
      <span class="s1">: received.mock.calls;</span>
    <span class="s1">const length = calls.length;</span>
    <span class="s1">const iNth = nth - </span><span class="s3">1</span><span class="s1">;</span>
    <span class="s1">const pass = iNth &lt; length &amp;&amp; isEqualCall(expected, calls[iNth]);</span>
    <span class="s1">const message = pass</span>
      <span class="s1">? () =&gt; {</span>
          <span class="s4">// Display preceding and following calls,</span>
          <span class="s4">// in case assertions fails because index is off by one.</span>
          <span class="s1">const indexedCalls = [];</span>
          <span class="s2">if </span><span class="s1">(iNth - </span><span class="s3">1 </span><span class="s1">&gt;= </span><span class="s3">0</span><span class="s1">) {</span>
            <span class="s1">indexedCalls.push([iNth - </span><span class="s3">1</span><span class="s1">, calls[iNth - </span><span class="s3">1</span><span class="s1">]]);</span>
          <span class="s1">}</span>
          <span class="s1">indexedCalls.push([iNth, calls[iNth]]);</span>
          <span class="s2">if </span><span class="s1">(iNth + </span><span class="s3">1 </span><span class="s1">&lt; length) {</span>
            <span class="s1">indexedCalls.push([iNth + </span><span class="s3">1</span><span class="s1">, calls[iNth + </span><span class="s3">1</span><span class="s1">]]);</span>
          <span class="s1">}</span>
          <span class="s2">return </span><span class="s1">(</span>
            <span class="s4">// eslint-disable-next-line prefer-template</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.matcherHint)(</span>
              <span class="s1">matcherName,</span>
              <span class="s1">receivedName,</span>
              <span class="s1">expectedArgument,</span>
              <span class="s1">options</span>
            <span class="s1">) +</span>
            <span class="s0">'</span><span class="s5">\n\n</span><span class="s0">' </span><span class="s1">+</span>
            <span class="s1">`n: ${nth}\n` +</span>
            <span class="s1">`Expected: not ${printExpectedArgs(expected)}\n` +</span>
            <span class="s1">(calls.length === </span><span class="s3">1 </span><span class="s1">&amp;&amp;</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.stringify)(calls[</span><span class="s3">0</span><span class="s1">]) ===</span>
              <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.stringify)(expected)</span>
              <span class="s1">? </span><span class="s0">''</span>
              <span class="s1">: printReceivedCallsNegative(</span>
                  <span class="s1">expected,</span>
                  <span class="s1">indexedCalls,</span>
                  <span class="s1">calls.length === </span><span class="s3">1</span><span class="s1">,</span>
                  <span class="s1">iNth</span>
                <span class="s1">)) +</span>
            <span class="s1">`\nNumber of calls: ${(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.printReceived)(</span>
              <span class="s1">calls.length</span>
            <span class="s1">)}`</span>
          <span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">: () =&gt; {</span>
          <span class="s4">// Display preceding and following calls:</span>
          <span class="s4">// * nearest call that is equal to expected args</span>
          <span class="s4">// * otherwise, adjacent call</span>
          <span class="s4">// in case assertions fails because of index, especially off by one.</span>
          <span class="s1">const indexedCalls = [];</span>
          <span class="s2">if </span><span class="s1">(iNth &lt; length) {</span>
            <span class="s2">if </span><span class="s1">(iNth - </span><span class="s3">1 </span><span class="s1">&gt;= </span><span class="s3">0</span><span class="s1">) {</span>
              <span class="s1">let i = iNth - </span><span class="s3">1</span><span class="s1">;</span>
              <span class="s4">// Is there a preceding call that is equal to expected args?</span>
              <span class="s2">while </span><span class="s1">(i &gt;= </span><span class="s3">0 </span><span class="s1">&amp;&amp; !isEqualCall(expected, calls[i])) {</span>
                <span class="s1">i -= </span><span class="s3">1</span><span class="s1">;</span>
              <span class="s1">}</span>
              <span class="s2">if </span><span class="s1">(i &lt; </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s1">i = iNth - </span><span class="s3">1</span><span class="s1">; </span><span class="s4">// otherwise, adjacent call</span>
              <span class="s1">}</span>

              <span class="s1">indexedCalls.push([i, calls[i]]);</span>
            <span class="s1">}</span>
            <span class="s1">indexedCalls.push([iNth, calls[iNth]]);</span>
            <span class="s2">if </span><span class="s1">(iNth + </span><span class="s3">1 </span><span class="s1">&lt; length) {</span>
              <span class="s1">let i = iNth + </span><span class="s3">1</span><span class="s1">;</span>
              <span class="s4">// Is there a following call that is equal to expected args?</span>
              <span class="s2">while </span><span class="s1">(i &lt; length &amp;&amp; !isEqualCall(expected, calls[i])) {</span>
                <span class="s1">i += </span><span class="s3">1</span><span class="s1">;</span>
              <span class="s1">}</span>
              <span class="s2">if </span><span class="s1">(i &gt;= length) {</span>
                <span class="s1">i = iNth + </span><span class="s3">1</span><span class="s1">; </span><span class="s4">// otherwise, adjacent call</span>
              <span class="s1">}</span>

              <span class="s1">indexedCalls.push([i, calls[i]]);</span>
            <span class="s1">}</span>
          <span class="s1">} </span><span class="s2">else if </span><span class="s1">(length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
            <span class="s4">// The number of received calls is fewer than the expected number.</span>
            <span class="s1">let i = length - </span><span class="s3">1</span><span class="s1">;</span>
            <span class="s4">// Is there a call that is equal to expected args?</span>
            <span class="s2">while </span><span class="s1">(i &gt;= </span><span class="s3">0 </span><span class="s1">&amp;&amp; !isEqualCall(expected, calls[i])) {</span>
              <span class="s1">i -= </span><span class="s3">1</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(i &lt; </span><span class="s3">0</span><span class="s1">) {</span>
              <span class="s1">i = length - </span><span class="s3">1</span><span class="s1">; </span><span class="s4">// otherwise, last call</span>
            <span class="s1">}</span>

            <span class="s1">indexedCalls.push([i, calls[i]]);</span>
          <span class="s1">}</span>
          <span class="s2">return </span><span class="s1">(</span>
            <span class="s4">// eslint-disable-next-line prefer-template</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.matcherHint)(</span>
              <span class="s1">matcherName,</span>
              <span class="s1">receivedName,</span>
              <span class="s1">expectedArgument,</span>
              <span class="s1">options</span>
            <span class="s1">) +</span>
            <span class="s0">'</span><span class="s5">\n\n</span><span class="s0">' </span><span class="s1">+</span>
            <span class="s1">`n: ${nth}\n` +</span>
            <span class="s1">printExpectedReceivedCallsPositive(</span>
              <span class="s1">expected,</span>
              <span class="s1">indexedCalls,</span>
              <span class="s1">isExpand(</span><span class="s2">this</span><span class="s1">.expand),</span>
              <span class="s1">calls.length === </span><span class="s3">1</span><span class="s1">,</span>
              <span class="s1">iNth</span>
            <span class="s1">) +</span>
            <span class="s1">`\nNumber of calls: ${(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.printReceived)(</span>
              <span class="s1">calls.length</span>
            <span class="s1">)}`</span>
          <span class="s1">);</span>
        <span class="s1">};</span>
    <span class="s2">return </span><span class="s1">{</span>
      <span class="s1">message,</span>
      <span class="s1">pass</span>
    <span class="s1">};</span>
  <span class="s1">};</span>
<span class="s1">const createNthReturnedWithMatcher = matcherName =&gt;</span>
  <span class="s2">function </span><span class="s1">(received, nth, expected) {</span>
    <span class="s1">const expectedArgument = </span><span class="s0">'n'</span><span class="s1">;</span>
    <span class="s1">const options = {</span>
      <span class="s1">expectedColor: arg =&gt; arg,</span>
      <span class="s1">isNot: </span><span class="s2">this</span><span class="s1">.isNot,</span>
      <span class="s1">promise: </span><span class="s2">this</span><span class="s1">.promise,</span>
      <span class="s1">secondArgument: </span><span class="s0">'expected'</span>
    <span class="s1">};</span>
    <span class="s1">ensureMock(received, matcherName, expectedArgument, options);</span>
    <span class="s2">if </span><span class="s1">(!Number.isSafeInteger(nth) || nth &lt; </span><span class="s3">1</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">Error(</span>
        <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.matcherErrorMessage)(</span>
          <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.matcherHint)(</span>
            <span class="s1">matcherName,</span>
            <span class="s1">undefined,</span>
            <span class="s1">expectedArgument,</span>
            <span class="s1">options</span>
          <span class="s1">),</span>
          <span class="s1">`${expectedArgument} must be a positive integer`,</span>
          <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.printWithType)(</span>
            <span class="s1">expectedArgument,</span>
            <span class="s1">nth,</span>
            <span class="s1">_jestMatcherUtils.stringify</span>
          <span class="s1">)</span>
        <span class="s1">)</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">const receivedName = received.getMockName();</span>
    <span class="s1">const {calls, results} = received.mock;</span>
    <span class="s1">const length = results.length;</span>
    <span class="s1">const iNth = nth - </span><span class="s3">1</span><span class="s1">;</span>
    <span class="s1">const pass = iNth &lt; length &amp;&amp; isEqualReturn(expected, results[iNth]);</span>
    <span class="s1">const message = pass</span>
      <span class="s1">? () =&gt; {</span>
          <span class="s4">// Display preceding and following results,</span>
          <span class="s4">// in case assertions fails because index is off by one.</span>
          <span class="s1">const indexedResults = [];</span>
          <span class="s2">if </span><span class="s1">(iNth - </span><span class="s3">1 </span><span class="s1">&gt;= </span><span class="s3">0</span><span class="s1">) {</span>
            <span class="s1">indexedResults.push([iNth - </span><span class="s3">1</span><span class="s1">, results[iNth - </span><span class="s3">1</span><span class="s1">]]);</span>
          <span class="s1">}</span>
          <span class="s1">indexedResults.push([iNth, results[iNth]]);</span>
          <span class="s2">if </span><span class="s1">(iNth + </span><span class="s3">1 </span><span class="s1">&lt; length) {</span>
            <span class="s1">indexedResults.push([iNth + </span><span class="s3">1</span><span class="s1">, results[iNth + </span><span class="s3">1</span><span class="s1">]]);</span>
          <span class="s1">}</span>
          <span class="s2">return </span><span class="s1">(</span>
            <span class="s4">// eslint-disable-next-line prefer-template</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.matcherHint)(</span>
              <span class="s1">matcherName,</span>
              <span class="s1">receivedName,</span>
              <span class="s1">expectedArgument,</span>
              <span class="s1">options</span>
            <span class="s1">) +</span>
            <span class="s0">'</span><span class="s5">\n\n</span><span class="s0">' </span><span class="s1">+</span>
            <span class="s1">`n: ${nth}\n` +</span>
            <span class="s1">`Expected: not ${(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.printExpected)(</span>
              <span class="s1">expected</span>
            <span class="s1">)}\n` +</span>
            <span class="s1">(results.length === </span><span class="s3">1 </span><span class="s1">&amp;&amp;</span>
            <span class="s1">results[</span><span class="s3">0</span><span class="s1">].type === </span><span class="s0">'return' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.stringify)(results[</span><span class="s3">0</span><span class="s1">].value) ===</span>
              <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.stringify)(expected)</span>
              <span class="s1">? </span><span class="s0">''</span>
              <span class="s1">: printReceivedResults(</span>
                  <span class="s0">'Received:     '</span><span class="s1">,</span>
                  <span class="s1">expected,</span>
                  <span class="s1">indexedResults,</span>
                  <span class="s1">results.length === </span><span class="s3">1</span><span class="s1">,</span>
                  <span class="s1">iNth</span>
                <span class="s1">)) +</span>
            <span class="s1">printNumberOfReturns(countReturns(results), calls.length)</span>
          <span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">: () =&gt; {</span>
          <span class="s4">// Display preceding and following results:</span>
          <span class="s4">// * nearest result that is equal to expected value</span>
          <span class="s4">// * otherwise, adjacent result</span>
          <span class="s4">// in case assertions fails because of index, especially off by one.</span>
          <span class="s1">const indexedResults = [];</span>
          <span class="s2">if </span><span class="s1">(iNth &lt; length) {</span>
            <span class="s2">if </span><span class="s1">(iNth - </span><span class="s3">1 </span><span class="s1">&gt;= </span><span class="s3">0</span><span class="s1">) {</span>
              <span class="s1">let i = iNth - </span><span class="s3">1</span><span class="s1">;</span>
              <span class="s4">// Is there a preceding result that is equal to expected value?</span>
              <span class="s2">while </span><span class="s1">(i &gt;= </span><span class="s3">0 </span><span class="s1">&amp;&amp; !isEqualReturn(expected, results[i])) {</span>
                <span class="s1">i -= </span><span class="s3">1</span><span class="s1">;</span>
              <span class="s1">}</span>
              <span class="s2">if </span><span class="s1">(i &lt; </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s1">i = iNth - </span><span class="s3">1</span><span class="s1">; </span><span class="s4">// otherwise, adjacent result</span>
              <span class="s1">}</span>

              <span class="s1">indexedResults.push([i, results[i]]);</span>
            <span class="s1">}</span>
            <span class="s1">indexedResults.push([iNth, results[iNth]]);</span>
            <span class="s2">if </span><span class="s1">(iNth + </span><span class="s3">1 </span><span class="s1">&lt; length) {</span>
              <span class="s1">let i = iNth + </span><span class="s3">1</span><span class="s1">;</span>
              <span class="s4">// Is there a following result that is equal to expected value?</span>
              <span class="s2">while </span><span class="s1">(i &lt; length &amp;&amp; !isEqualReturn(expected, results[i])) {</span>
                <span class="s1">i += </span><span class="s3">1</span><span class="s1">;</span>
              <span class="s1">}</span>
              <span class="s2">if </span><span class="s1">(i &gt;= length) {</span>
                <span class="s1">i = iNth + </span><span class="s3">1</span><span class="s1">; </span><span class="s4">// otherwise, adjacent result</span>
              <span class="s1">}</span>

              <span class="s1">indexedResults.push([i, results[i]]);</span>
            <span class="s1">}</span>
          <span class="s1">} </span><span class="s2">else if </span><span class="s1">(length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
            <span class="s4">// The number of received calls is fewer than the expected number.</span>
            <span class="s1">let i = length - </span><span class="s3">1</span><span class="s1">;</span>
            <span class="s4">// Is there a result that is equal to expected value?</span>
            <span class="s2">while </span><span class="s1">(i &gt;= </span><span class="s3">0 </span><span class="s1">&amp;&amp; !isEqualReturn(expected, results[i])) {</span>
              <span class="s1">i -= </span><span class="s3">1</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(i &lt; </span><span class="s3">0</span><span class="s1">) {</span>
              <span class="s1">i = length - </span><span class="s3">1</span><span class="s1">; </span><span class="s4">// otherwise, last result</span>
            <span class="s1">}</span>

            <span class="s1">indexedResults.push([i, results[i]]);</span>
          <span class="s1">}</span>
          <span class="s2">return </span><span class="s1">(</span>
            <span class="s4">// eslint-disable-next-line prefer-template</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.matcherHint)(</span>
              <span class="s1">matcherName,</span>
              <span class="s1">receivedName,</span>
              <span class="s1">expectedArgument,</span>
              <span class="s1">options</span>
            <span class="s1">) +</span>
            <span class="s0">'</span><span class="s5">\n\n</span><span class="s0">' </span><span class="s1">+</span>
            <span class="s1">`n: ${nth}\n` +</span>
            <span class="s1">`Expected: ${(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.printExpected)(expected)}\n` +</span>
            <span class="s1">printReceivedResults(</span>
              <span class="s0">'Received: '</span><span class="s1">,</span>
              <span class="s1">expected,</span>
              <span class="s1">indexedResults,</span>
              <span class="s1">results.length === </span><span class="s3">1</span><span class="s1">,</span>
              <span class="s1">iNth</span>
            <span class="s1">) +</span>
            <span class="s1">printNumberOfReturns(countReturns(results), calls.length)</span>
          <span class="s1">);</span>
        <span class="s1">};</span>
    <span class="s2">return </span><span class="s1">{</span>
      <span class="s1">message,</span>
      <span class="s1">pass</span>
    <span class="s1">};</span>
  <span class="s1">};</span>
<span class="s1">const spyMatchers = {</span>
  <span class="s1">lastCalledWith: createLastCalledWithMatcher(</span><span class="s0">'lastCalledWith'</span><span class="s1">),</span>
  <span class="s1">lastReturnedWith: createLastReturnedMatcher(</span><span class="s0">'lastReturnedWith'</span><span class="s1">),</span>
  <span class="s1">nthCalledWith: createNthCalledWithMatcher(</span><span class="s0">'nthCalledWith'</span><span class="s1">),</span>
  <span class="s1">nthReturnedWith: createNthReturnedWithMatcher(</span><span class="s0">'nthReturnedWith'</span><span class="s1">),</span>
  <span class="s1">toBeCalled: createToBeCalledMatcher(</span><span class="s0">'toBeCalled'</span><span class="s1">),</span>
  <span class="s1">toBeCalledTimes: createToBeCalledTimesMatcher(</span><span class="s0">'toBeCalledTimes'</span><span class="s1">),</span>
  <span class="s1">toBeCalledWith: createToBeCalledWithMatcher(</span><span class="s0">'toBeCalledWith'</span><span class="s1">),</span>
  <span class="s1">toHaveBeenCalled: createToBeCalledMatcher(</span><span class="s0">'toHaveBeenCalled'</span><span class="s1">),</span>
  <span class="s1">toHaveBeenCalledTimes: createToBeCalledTimesMatcher(</span><span class="s0">'toHaveBeenCalledTimes'</span><span class="s1">),</span>
  <span class="s1">toHaveBeenCalledWith: createToBeCalledWithMatcher(</span><span class="s0">'toHaveBeenCalledWith'</span><span class="s1">),</span>
  <span class="s1">toHaveBeenLastCalledWith: createLastCalledWithMatcher(</span>
    <span class="s0">'toHaveBeenLastCalledWith'</span>
  <span class="s1">),</span>
  <span class="s1">toHaveBeenNthCalledWith: createNthCalledWithMatcher(</span>
    <span class="s0">'toHaveBeenNthCalledWith'</span>
  <span class="s1">),</span>
  <span class="s1">toHaveLastReturnedWith: createLastReturnedMatcher(</span><span class="s0">'toHaveLastReturnedWith'</span><span class="s1">),</span>
  <span class="s1">toHaveNthReturnedWith: createNthReturnedWithMatcher(</span><span class="s0">'toHaveNthReturnedWith'</span><span class="s1">),</span>
  <span class="s1">toHaveReturned: createToReturnMatcher(</span><span class="s0">'toHaveReturned'</span><span class="s1">),</span>
  <span class="s1">toHaveReturnedTimes: createToReturnTimesMatcher(</span><span class="s0">'toHaveReturnedTimes'</span><span class="s1">),</span>
  <span class="s1">toHaveReturnedWith: createToReturnWithMatcher(</span><span class="s0">'toHaveReturnedWith'</span><span class="s1">),</span>
  <span class="s1">toReturn: createToReturnMatcher(</span><span class="s0">'toReturn'</span><span class="s1">),</span>
  <span class="s1">toReturnTimes: createToReturnTimesMatcher(</span><span class="s0">'toReturnTimes'</span><span class="s1">),</span>
  <span class="s1">toReturnWith: createToReturnWithMatcher(</span><span class="s0">'toReturnWith'</span><span class="s1">)</span>
<span class="s1">};</span>
<span class="s1">const isMock = received =&gt;</span>
  <span class="s1">received != </span><span class="s2">null </span><span class="s1">&amp;&amp; received._isMockFunction === </span><span class="s2">true</span><span class="s1">;</span>
<span class="s1">const isSpy = received =&gt;</span>
  <span class="s1">received != </span><span class="s2">null </span><span class="s1">&amp;&amp;</span>
  <span class="s1">received.calls != </span><span class="s2">null </span><span class="s1">&amp;&amp;</span>
  <span class="s2">typeof </span><span class="s1">received.calls.all === </span><span class="s0">'function' </span><span class="s1">&amp;&amp;</span>
  <span class="s2">typeof </span><span class="s1">received.calls.count === </span><span class="s0">'function'</span><span class="s1">;</span>
<span class="s1">const ensureMockOrSpy = (received, matcherName, expectedArgument, options) =&gt; {</span>
  <span class="s2">if </span><span class="s1">(!isMock(received) &amp;&amp; !isSpy(received)) {</span>
    <span class="s2">throw new </span><span class="s1">Error(</span>
      <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.matcherErrorMessage)(</span>
        <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.matcherHint)(</span>
          <span class="s1">matcherName,</span>
          <span class="s1">undefined,</span>
          <span class="s1">expectedArgument,</span>
          <span class="s1">options</span>
        <span class="s1">),</span>
        <span class="s1">`${(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.RECEIVED_COLOR)(</span>
          <span class="s0">'received'</span>
        <span class="s1">)} value must be a mock or spy </span><span class="s2">function</span><span class="s1">`,</span>
        <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.printWithType)(</span>
          <span class="s0">'Received'</span><span class="s1">,</span>
          <span class="s1">received,</span>
          <span class="s1">_jestMatcherUtils.printReceived</span>
        <span class="s1">)</span>
      <span class="s1">)</span>
    <span class="s1">);</span>
  <span class="s1">}</span>
<span class="s1">};</span>
<span class="s1">const ensureMock = (received, matcherName, expectedArgument, options) =&gt; {</span>
  <span class="s2">if </span><span class="s1">(!isMock(received)) {</span>
    <span class="s2">throw new </span><span class="s1">Error(</span>
      <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.matcherErrorMessage)(</span>
        <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.matcherHint)(</span>
          <span class="s1">matcherName,</span>
          <span class="s1">undefined,</span>
          <span class="s1">expectedArgument,</span>
          <span class="s1">options</span>
        <span class="s1">),</span>
        <span class="s1">`${(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.RECEIVED_COLOR)(</span>
          <span class="s0">'received'</span>
        <span class="s1">)} value must be a mock </span><span class="s2">function</span><span class="s1">`,</span>
        <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestMatcherUtils.printWithType)(</span>
          <span class="s0">'Received'</span><span class="s1">,</span>
          <span class="s1">received,</span>
          <span class="s1">_jestMatcherUtils.printReceived</span>
        <span class="s1">)</span>
      <span class="s1">)</span>
    <span class="s1">);</span>
  <span class="s1">}</span>
<span class="s1">};</span>
<span class="s2">var </span><span class="s1">_default = spyMatchers;</span>
<span class="s1">exports.</span><span class="s2">default </span><span class="s1">= _default;</span>
</pre>
</body>
</html>
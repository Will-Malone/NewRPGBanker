<html>
<head>
<title>test.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #cc7832;}
.s2 { color: #a9b7c6;}
.s3 { color: #a9b7c6;}
.s4 { color: #6a8759;}
.s5 { color: #ffc66d;}
.s6 { color: #cc7832; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* The `node:test` module facilitates the creation of JavaScript tests. 
 * To access it: 
 * 
 * ```js 
 * import test from 'node:test'; 
 * ``` 
 * 
 * This module is only available under the `node:` scheme. The following will not 
 * work: 
 * 
 * ```js 
 * import test from 'test'; 
 * ``` 
 * 
 * Tests created via the `test` module consist of a single function that is 
 * processed in one of three ways: 
 * 
 * 1. A synchronous function that is considered failing if it throws an exception, 
 * and is considered passing otherwise. 
 * 2. A function that returns a `Promise` that is considered failing if the`Promise` rejects, and is considered passing if the `Promise` resolves. 
 * 3. A function that receives a callback function. If the callback receives any 
 * truthy value as its first argument, the test is considered failing. If a 
 * falsy value is passed as the first argument to the callback, the test is 
 * considered passing. If the test function receives a callback function and 
 * also returns a `Promise`, the test will fail. 
 * 
 * The following example illustrates how tests are written using the`test` module. 
 * 
 * ```js 
 * test('synchronous passing test', (t) =&gt; { 
 *   // This test passes because it does not throw an exception. 
 *   assert.strictEqual(1, 1); 
 * }); 
 * 
 * test('synchronous failing test', (t) =&gt; { 
 *   // This test fails because it throws an exception. 
 *   assert.strictEqual(1, 2); 
 * }); 
 * 
 * test('asynchronous passing test', async (t) =&gt; { 
 *   // This test passes because the Promise returned by the async 
 *   // function is not rejected. 
 *   assert.strictEqual(1, 1); 
 * }); 
 * 
 * test('asynchronous failing test', async (t) =&gt; { 
 *   // This test fails because the Promise returned by the async 
 *   // function is rejected. 
 *   assert.strictEqual(1, 2); 
 * }); 
 * 
 * test('failing test using Promises', (t) =&gt; { 
 *   // Promises can be used directly as well. 
 *   return new Promise((resolve, reject) =&gt; { 
 *     setImmediate(() =&gt; { 
 *       reject(new Error('this will cause the test to fail')); 
 *     }); 
 *   }); 
 * }); 
 * 
 * test('callback passing test', (t, done) =&gt; { 
 *   // done() is the callback function. When the setImmediate() runs, it invokes 
 *   // done() with no arguments. 
 *   setImmediate(done); 
 * }); 
 * 
 * test('callback failing test', (t, done) =&gt; { 
 *   // When the setImmediate() runs, done() is invoked with an Error object and 
 *   // the test fails. 
 *   setImmediate(() =&gt; { 
 *     done(new Error('callback failure')); 
 *   }); 
 * }); 
 * ``` 
 * 
 * If any tests fail, the process exit code is set to `1`. 
 * </span><span class="s1">@since </span><span class="s0">v18.0.0, v16.17.0 
 * </span><span class="s1">@see </span><span class="s2">[source](https:</span><span class="s0">//github.com/nodejs/node/blob/v20.2.0/lib/test.js) 
 */</span>
<span class="s1">declare module </span><span class="s4">'node:test' </span><span class="s3">{</span>
    <span class="s1">import </span><span class="s3">{ </span><span class="s2">Readable </span><span class="s3">} </span><span class="s1">from </span><span class="s4">'node:stream'</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* ```js 
     * import { tap } from 'node:test/reporters'; 
     * import process from 'node:process'; 
     * 
     * run({ files: [path.resolve('./tests/test.js')] }) 
     *   .compose(tap) 
     *   .pipe(process.stdout); 
     * ``` 
     * </span><span class="s1">@since </span><span class="s0">v18.9.0, v16.19.0 
     * </span><span class="s1">@param </span><span class="s2">options </span><span class="s0">Configuration options for running tests. The following properties are supported: 
     */</span>
    <span class="s1">function </span><span class="s3">run(</span><span class="s2">options</span><span class="s1">?: </span><span class="s2">RunOptions</span><span class="s3">)</span><span class="s1">: </span><span class="s2">TestsStream</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The `test()` function is the value imported from the `test` module. Each 
     * invocation of this function results in reporting the test to the `TestsStream`. 
     * 
     * The `TestContext` object passed to the `fn` argument can be used to perform 
     * actions related to the current test. Examples include skipping the test, adding 
     * additional diagnostic information, or creating subtests. 
     * 
     * `test()` returns a `Promise` that resolves once the test completes. 
     * if `test()` is called within a `describe()` block, it resolve immediately. 
     * The return value can usually be discarded for top level tests. 
     * However, the return value from subtests should be used to prevent the parent 
     * test from finishing first and cancelling the subtest 
     * as shown in the following example. 
     * 
     * ```js 
     * test('top level test', async (t) =&gt; { 
     *   // The setTimeout() in the following subtest would cause it to outlive its 
     *   // parent test if 'await' is removed on the next line. Once the parent test 
     *   // completes, it will cancel any outstanding subtests. 
     *   await t.test('longer running subtest', async (t) =&gt; { 
     *     return new Promise((resolve, reject) =&gt; { 
     *       setTimeout(resolve, 1000); 
     *     }); 
     *   }); 
     * }); 
     * ``` 
     * 
     * The `timeout` option can be used to fail the test if it takes longer than`timeout` milliseconds to complete. However, it is not a reliable mechanism for 
     * canceling tests because a running test might block the application thread and 
     * thus prevent the scheduled cancellation. 
     * </span><span class="s1">@since </span><span class="s0">v18.0.0, v16.17.0 
     * </span><span class="s1">@param </span><span class="s0">[name='The name'] The name of the test, which is displayed when reporting test results. 
     * </span><span class="s1">@param </span><span class="s2">options </span><span class="s0">Configuration options for the test. The following properties are supported: 
     * </span><span class="s1">@param </span><span class="s0">[fn='A no-op function'] The function under test. The first argument to this function is a </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">TestContext} </span><span class="s0">object. If the test uses callbacks, the callback function is passed as the 
     * second argument. 
     * </span><span class="s1">@return </span><span class="s0">Resolved with `undefined` once the test completes, or immediately if the test runs within </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">describe}</span><span class="s0">. 
     */</span>
    <span class="s1">function </span><span class="s3">test(</span><span class="s2">name</span><span class="s1">?: </span><span class="s2">string</span><span class="s3">, </span><span class="s2">fn</span><span class="s1">?: </span><span class="s2">TestFn</span><span class="s3">)</span><span class="s1">: </span><span class="s2">Promise</span><span class="s3">&lt;</span><span class="s2">void</span><span class="s3">&gt;;</span>
    <span class="s1">function </span><span class="s3">test(</span><span class="s2">name</span><span class="s1">?: </span><span class="s2">string</span><span class="s3">, </span><span class="s2">options</span><span class="s1">?: </span><span class="s2">TestOptions</span><span class="s3">, </span><span class="s2">fn</span><span class="s1">?: </span><span class="s2">TestFn</span><span class="s3">)</span><span class="s1">: </span><span class="s2">Promise</span><span class="s3">&lt;</span><span class="s2">void</span><span class="s3">&gt;;</span>
    <span class="s1">function </span><span class="s3">test(</span><span class="s2">options</span><span class="s1">?: </span><span class="s2">TestOptions</span><span class="s3">, </span><span class="s2">fn</span><span class="s1">?: </span><span class="s2">TestFn</span><span class="s3">)</span><span class="s1">: </span><span class="s2">Promise</span><span class="s3">&lt;</span><span class="s2">void</span><span class="s3">&gt;;</span>
    <span class="s1">function </span><span class="s3">test(</span><span class="s2">fn</span><span class="s1">?: </span><span class="s2">TestFn</span><span class="s3">)</span><span class="s1">: </span><span class="s2">Promise</span><span class="s3">&lt;</span><span class="s2">void</span><span class="s3">&gt;;</span>
    <span class="s1">namespace </span><span class="s2">test </span><span class="s3">{</span>
        <span class="s1">export </span><span class="s3">{</span>
            <span class="s2">after</span><span class="s3">,</span>
            <span class="s2">afterEach</span><span class="s3">,</span>
            <span class="s2">before</span><span class="s3">,</span>
            <span class="s2">beforeEach</span><span class="s3">,</span>
            <span class="s2">describe</span><span class="s3">,</span>
            <span class="s2">it</span><span class="s3">,</span>
            <span class="s2">run</span><span class="s3">,</span>
            <span class="s2">mock</span><span class="s3">,</span>
            <span class="s2">test</span><span class="s3">,</span>
            <span class="s2">skip</span><span class="s3">,</span>
            <span class="s2">todo</span><span class="s3">,</span>
            <span class="s2">only</span>
        <span class="s3">};</span>
    <span class="s3">}</span>
    <span class="s0">/**</span>
     <span class="s0">* The `describe()` function imported from the `node:test` module. Each 
     * invocation of this function results in the creation of a Subtest. 
     * After invocation of top level `describe` functions, 
     * all top level tests and suites will execute. 
     * </span><span class="s1">@param </span><span class="s0">[name='The name'] The name of the suite, which is displayed when reporting test results. 
     * </span><span class="s1">@param </span><span class="s2">options </span><span class="s0">Configuration options for the suite. supports the same options as `test([name][, options][, fn])`. 
     * </span><span class="s1">@param </span><span class="s0">[fn='A no-op function'] The function under suite declaring all subtests and subsuites. The first argument to this function is a </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">SuiteContext} </span><span class="s0">object. 
     * </span><span class="s1">@return </span><span class="s0">Immediately fulfilled with `undefined`. 
     */</span>
    <span class="s1">function </span><span class="s3">describe(</span><span class="s2">name</span><span class="s1">?: </span><span class="s2">string</span><span class="s3">, </span><span class="s2">options</span><span class="s1">?: </span><span class="s2">TestOptions</span><span class="s3">, </span><span class="s2">fn</span><span class="s1">?: </span><span class="s2">SuiteFn</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
    <span class="s1">function </span><span class="s3">describe(</span><span class="s2">name</span><span class="s1">?: </span><span class="s2">string</span><span class="s3">, </span><span class="s2">fn</span><span class="s1">?: </span><span class="s2">SuiteFn</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
    <span class="s1">function </span><span class="s3">describe(</span><span class="s2">options</span><span class="s1">?: </span><span class="s2">TestOptions</span><span class="s3">, </span><span class="s2">fn</span><span class="s1">?: </span><span class="s2">SuiteFn</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
    <span class="s1">function </span><span class="s3">describe(</span><span class="s2">fn</span><span class="s1">?: </span><span class="s2">SuiteFn</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
    <span class="s1">namespace </span><span class="s2">describe </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Shorthand for skipping a suite, same as `describe([name], { skip: true }[, fn])`. 
         */</span>
        <span class="s1">function </span><span class="s3">skip(</span><span class="s2">name</span><span class="s1">?: </span><span class="s2">string</span><span class="s3">, </span><span class="s2">options</span><span class="s1">?: </span><span class="s2">TestOptions</span><span class="s3">, </span><span class="s2">fn</span><span class="s1">?: </span><span class="s2">SuiteFn</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s1">function </span><span class="s3">skip(</span><span class="s2">name</span><span class="s1">?: </span><span class="s2">string</span><span class="s3">, </span><span class="s2">fn</span><span class="s1">?: </span><span class="s2">SuiteFn</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s1">function </span><span class="s3">skip(</span><span class="s2">options</span><span class="s1">?: </span><span class="s2">TestOptions</span><span class="s3">, </span><span class="s2">fn</span><span class="s1">?: </span><span class="s2">SuiteFn</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s1">function </span><span class="s3">skip(</span><span class="s2">fn</span><span class="s1">?: </span><span class="s2">SuiteFn</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Shorthand for marking a suite as `TODO`, same as `describe([name], { todo: true }[, fn])`. 
         */</span>
        <span class="s1">function </span><span class="s3">todo(</span><span class="s2">name</span><span class="s1">?: </span><span class="s2">string</span><span class="s3">, </span><span class="s2">options</span><span class="s1">?: </span><span class="s2">TestOptions</span><span class="s3">, </span><span class="s2">fn</span><span class="s1">?: </span><span class="s2">SuiteFn</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s1">function </span><span class="s3">todo(</span><span class="s2">name</span><span class="s1">?: </span><span class="s2">string</span><span class="s3">, </span><span class="s2">fn</span><span class="s1">?: </span><span class="s2">SuiteFn</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s1">function </span><span class="s3">todo(</span><span class="s2">options</span><span class="s1">?: </span><span class="s2">TestOptions</span><span class="s3">, </span><span class="s2">fn</span><span class="s1">?: </span><span class="s2">SuiteFn</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s1">function </span><span class="s3">todo(</span><span class="s2">fn</span><span class="s1">?: </span><span class="s2">SuiteFn</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Shorthand for marking a suite as `only`, same as `describe([name], { only: true }[, fn])`. 
         * </span><span class="s1">@since </span><span class="s0">v18.15.0 
         */</span>
        <span class="s1">function </span><span class="s3">only(</span><span class="s2">name</span><span class="s1">?: </span><span class="s2">string</span><span class="s3">, </span><span class="s2">options</span><span class="s1">?: </span><span class="s2">TestOptions</span><span class="s3">, </span><span class="s2">fn</span><span class="s1">?: </span><span class="s2">SuiteFn</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s1">function </span><span class="s3">only(</span><span class="s2">name</span><span class="s1">?: </span><span class="s2">string</span><span class="s3">, </span><span class="s2">fn</span><span class="s1">?: </span><span class="s2">SuiteFn</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s1">function </span><span class="s3">only(</span><span class="s2">options</span><span class="s1">?: </span><span class="s2">TestOptions</span><span class="s3">, </span><span class="s2">fn</span><span class="s1">?: </span><span class="s2">SuiteFn</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s1">function </span><span class="s3">only(</span><span class="s2">fn</span><span class="s1">?: </span><span class="s2">SuiteFn</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Shorthand for `test()`. 
     * 
     * The `it()` function is imported from the `node:test` module. 
     * </span><span class="s1">@since </span><span class="s0">v18.6.0, v16.17.0 
     */</span>
    <span class="s1">function </span><span class="s3">it(</span><span class="s2">name</span><span class="s1">?: </span><span class="s2">string</span><span class="s3">, </span><span class="s2">options</span><span class="s1">?: </span><span class="s2">TestOptions</span><span class="s3">, </span><span class="s2">fn</span><span class="s1">?: </span><span class="s2">TestFn</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
    <span class="s1">function </span><span class="s3">it(</span><span class="s2">name</span><span class="s1">?: </span><span class="s2">string</span><span class="s3">, </span><span class="s2">fn</span><span class="s1">?: </span><span class="s2">TestFn</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
    <span class="s1">function </span><span class="s3">it(</span><span class="s2">options</span><span class="s1">?: </span><span class="s2">TestOptions</span><span class="s3">, </span><span class="s2">fn</span><span class="s1">?: </span><span class="s2">TestFn</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
    <span class="s1">function </span><span class="s3">it(</span><span class="s2">fn</span><span class="s1">?: </span><span class="s2">TestFn</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
    <span class="s1">namespace </span><span class="s2">it </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Shorthand for skipping a test, same as `it([name], { skip: true }[, fn])`. 
         */</span>
        <span class="s1">function </span><span class="s3">skip(</span><span class="s2">name</span><span class="s1">?: </span><span class="s2">string</span><span class="s3">, </span><span class="s2">options</span><span class="s1">?: </span><span class="s2">TestOptions</span><span class="s3">, </span><span class="s2">fn</span><span class="s1">?: </span><span class="s2">TestFn</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s1">function </span><span class="s3">skip(</span><span class="s2">name</span><span class="s1">?: </span><span class="s2">string</span><span class="s3">, </span><span class="s2">fn</span><span class="s1">?: </span><span class="s2">TestFn</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s1">function </span><span class="s3">skip(</span><span class="s2">options</span><span class="s1">?: </span><span class="s2">TestOptions</span><span class="s3">, </span><span class="s2">fn</span><span class="s1">?: </span><span class="s2">TestFn</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s1">function </span><span class="s3">skip(</span><span class="s2">fn</span><span class="s1">?: </span><span class="s2">TestFn</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Shorthand for marking a test as `TODO`, same as `it([name], { todo: true }[, fn])`. 
         */</span>
        <span class="s1">function </span><span class="s3">todo(</span><span class="s2">name</span><span class="s1">?: </span><span class="s2">string</span><span class="s3">, </span><span class="s2">options</span><span class="s1">?: </span><span class="s2">TestOptions</span><span class="s3">, </span><span class="s2">fn</span><span class="s1">?: </span><span class="s2">TestFn</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s1">function </span><span class="s3">todo(</span><span class="s2">name</span><span class="s1">?: </span><span class="s2">string</span><span class="s3">, </span><span class="s2">fn</span><span class="s1">?: </span><span class="s2">TestFn</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s1">function </span><span class="s3">todo(</span><span class="s2">options</span><span class="s1">?: </span><span class="s2">TestOptions</span><span class="s3">, </span><span class="s2">fn</span><span class="s1">?: </span><span class="s2">TestFn</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s1">function </span><span class="s3">todo(</span><span class="s2">fn</span><span class="s1">?: </span><span class="s2">TestFn</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Shorthand for marking a test as `only`, same as `it([name], { only: true }[, fn])`. 
         * </span><span class="s1">@since </span><span class="s0">v18.15.0 
         */</span>
        <span class="s1">function </span><span class="s3">only(</span><span class="s2">name</span><span class="s1">?: </span><span class="s2">string</span><span class="s3">, </span><span class="s2">options</span><span class="s1">?: </span><span class="s2">TestOptions</span><span class="s3">, </span><span class="s2">fn</span><span class="s1">?: </span><span class="s2">TestFn</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s1">function </span><span class="s3">only(</span><span class="s2">name</span><span class="s1">?: </span><span class="s2">string</span><span class="s3">, </span><span class="s2">fn</span><span class="s1">?: </span><span class="s2">TestFn</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s1">function </span><span class="s3">only(</span><span class="s2">options</span><span class="s1">?: </span><span class="s2">TestOptions</span><span class="s3">, </span><span class="s2">fn</span><span class="s1">?: </span><span class="s2">TestFn</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s1">function </span><span class="s3">only(</span><span class="s2">fn</span><span class="s1">?: </span><span class="s2">TestFn</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Shorthand for skipping a test, same as `test([name], { skip: true }[, fn])`. 
     * </span><span class="s1">@since </span><span class="s0">v20.2.0 
     */</span>
    <span class="s1">function </span><span class="s3">skip(</span><span class="s2">name</span><span class="s1">?: </span><span class="s2">string</span><span class="s3">, </span><span class="s2">options</span><span class="s1">?: </span><span class="s2">TestOptions</span><span class="s3">, </span><span class="s2">fn</span><span class="s1">?: </span><span class="s2">TestFn</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
    <span class="s1">function </span><span class="s3">skip(</span><span class="s2">name</span><span class="s1">?: </span><span class="s2">string</span><span class="s3">, </span><span class="s2">fn</span><span class="s1">?: </span><span class="s2">TestFn</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
    <span class="s1">function </span><span class="s3">skip(</span><span class="s2">options</span><span class="s1">?: </span><span class="s2">TestOptions</span><span class="s3">, </span><span class="s2">fn</span><span class="s1">?: </span><span class="s2">TestFn</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
    <span class="s1">function </span><span class="s3">skip(</span><span class="s2">fn</span><span class="s1">?: </span><span class="s2">TestFn</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Shorthand for marking a test as `TODO`, same as `test([name], { todo: true }[, fn])`. 
     * </span><span class="s1">@since </span><span class="s0">v20.2.0 
     */</span>
    <span class="s1">function </span><span class="s3">todo(</span><span class="s2">name</span><span class="s1">?: </span><span class="s2">string</span><span class="s3">, </span><span class="s2">options</span><span class="s1">?: </span><span class="s2">TestOptions</span><span class="s3">, </span><span class="s2">fn</span><span class="s1">?: </span><span class="s2">TestFn</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
    <span class="s1">function </span><span class="s3">todo(</span><span class="s2">name</span><span class="s1">?: </span><span class="s2">string</span><span class="s3">, </span><span class="s2">fn</span><span class="s1">?: </span><span class="s2">TestFn</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
    <span class="s1">function </span><span class="s3">todo(</span><span class="s2">options</span><span class="s1">?: </span><span class="s2">TestOptions</span><span class="s3">, </span><span class="s2">fn</span><span class="s1">?: </span><span class="s2">TestFn</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
    <span class="s1">function </span><span class="s3">todo(</span><span class="s2">fn</span><span class="s1">?: </span><span class="s2">TestFn</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Shorthand for marking a test as `only`, same as `test([name], { only: true }[, fn])`. 
     * </span><span class="s1">@since </span><span class="s0">v20.2.0 
     */</span>
    <span class="s1">function </span><span class="s3">only(</span><span class="s2">name</span><span class="s1">?: </span><span class="s2">string</span><span class="s3">, </span><span class="s2">options</span><span class="s1">?: </span><span class="s2">TestOptions</span><span class="s3">, </span><span class="s2">fn</span><span class="s1">?: </span><span class="s2">TestFn</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
    <span class="s1">function </span><span class="s3">only(</span><span class="s2">name</span><span class="s1">?: </span><span class="s2">string</span><span class="s3">, </span><span class="s2">fn</span><span class="s1">?: </span><span class="s2">TestFn</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
    <span class="s1">function </span><span class="s3">only(</span><span class="s2">options</span><span class="s1">?: </span><span class="s2">TestOptions</span><span class="s3">, </span><span class="s2">fn</span><span class="s1">?: </span><span class="s2">TestFn</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
    <span class="s1">function </span><span class="s3">only(</span><span class="s2">fn</span><span class="s1">?: </span><span class="s2">TestFn</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The type of a function under test. The first argument to this function is a 
     * </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">TestContext} </span><span class="s0">object. If the test uses callbacks, the callback function is passed as 
     * the second argument. 
     */</span>
    <span class="s1">type </span><span class="s2">TestFn </span><span class="s1">= </span><span class="s3">(</span><span class="s2">t</span><span class="s1">: </span><span class="s2">TestContext</span><span class="s3">, </span><span class="s5">done</span><span class="s1">: </span><span class="s3">(</span><span class="s2">result</span><span class="s1">?: </span><span class="s2">any</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">any</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The type of a function under Suite. 
     * If the test uses callbacks, the callback function is passed as an argument 
     */</span>
    <span class="s1">type </span><span class="s2">SuiteFn </span><span class="s1">= </span><span class="s3">(</span><span class="s5">done</span><span class="s1">: </span><span class="s3">(</span><span class="s2">result</span><span class="s1">?: </span><span class="s2">any</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">;</span>
    <span class="s1">interface </span><span class="s2">RunOptions </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* If a number is provided, then that many files would run in parallel. 
         * If truthy, it would run (number of cpu cores - 1) files in parallel. 
         * If falsy, it would only run one file at a time. 
         * If unspecified, subtests inherit this value from their parent. 
         * </span><span class="s1">@default </span><span class="s2">true</span>
         <span class="s0">*/</span>
        <span class="s3">concurrency</span><span class="s1">?: </span><span class="s2">number </span><span class="s1">| </span><span class="s2">boolean </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* An array containing the list of files to run. 
         * If unspecified, the test runner execution model will be used. 
         */</span>
        <span class="s3">files</span><span class="s1">?: readonly </span><span class="s2">string</span><span class="s3">[] </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Allows aborting an in-progress test execution. 
         * </span><span class="s1">@default </span><span class="s2">undefined</span>
         <span class="s0">*/</span>
        <span class="s3">signal</span><span class="s1">?: </span><span class="s2">AbortSignal </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* A number of milliseconds the test will fail after. 
         * If unspecified, subtests inherit this value from their parent. 
         * </span><span class="s1">@default </span><span class="s2">Infinity</span>
         <span class="s0">*/</span>
        <span class="s3">timeout</span><span class="s1">?: </span><span class="s2">number </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Sets inspector port of test child process. 
         * If a nullish value is provided, each process gets its own port, 
         * incremented from the primary's `process.debugPort`. 
         */</span>
        <span class="s3">inspectPort</span><span class="s1">?: </span><span class="s2">number </span><span class="s1">| </span><span class="s3">(() </span><span class="s1">=&gt; </span><span class="s2">number</span><span class="s3">) </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* That can be used to only run tests whose name matches the provided pattern. 
         * Test name patterns are interpreted as JavaScript regular expressions. 
         * For each test that is executed, any corresponding test hooks, such as `beforeEach()`, are also run. 
         */</span>
        <span class="s3">testNamePatterns</span><span class="s1">?: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">RegExp </span><span class="s1">| </span><span class="s2">string</span><span class="s3">[] </span><span class="s1">| </span><span class="s2">RegExp</span><span class="s3">[];</span>
    <span class="s3">}</span>
    <span class="s0">/**</span>
     <span class="s0">* A successful call to `run()` method will return a new `TestsStream` object, streaming a series of events representing the execution of the tests.`TestsStream` will emit events, in the 
     * order of the tests definition 
     * </span><span class="s1">@since </span><span class="s0">v18.9.0, v16.19.0 
     */</span>
    <span class="s1">class </span><span class="s2">TestsStream </span><span class="s1">extends </span><span class="s2">Readable </span><span class="s1">implements </span><span class="s2">NodeJS</span><span class="s3">.</span><span class="s2">ReadableStream </span><span class="s3">{</span>
        <span class="s3">addListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'test:diagnostic'</span><span class="s3">, </span><span class="s5">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">data</span><span class="s1">: </span><span class="s2">DiagnosticData</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">addListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'test:fail'</span><span class="s3">, </span><span class="s5">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">data</span><span class="s1">: </span><span class="s2">TestFail</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">addListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'test:pass'</span><span class="s3">, </span><span class="s5">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">data</span><span class="s1">: </span><span class="s2">TestPass</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">addListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'test:plan'</span><span class="s3">, </span><span class="s5">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">data</span><span class="s1">: </span><span class="s2">TestPlan</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">addListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'test:start'</span><span class="s3">, </span><span class="s5">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">data</span><span class="s1">: </span><span class="s2">TestStart</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">addListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'test:stderr'</span><span class="s3">, </span><span class="s5">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">data</span><span class="s1">: </span><span class="s2">TestStderr</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">addListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'test:stdout'</span><span class="s3">, </span><span class="s5">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">data</span><span class="s1">: </span><span class="s2">TestStdout</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">addListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s2">string</span><span class="s3">, </span><span class="s5">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s1">...</span><span class="s2">args</span><span class="s1">: </span><span class="s2">any</span><span class="s3">[]) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">emit(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'test:diagnostic'</span><span class="s3">, </span><span class="s2">data</span><span class="s1">: </span><span class="s2">DiagnosticData</span><span class="s3">)</span><span class="s1">: </span><span class="s2">boolean</span><span class="s3">;</span>
        <span class="s3">emit(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'test:fail'</span><span class="s3">, </span><span class="s2">data</span><span class="s1">: </span><span class="s2">TestFail</span><span class="s3">)</span><span class="s1">: </span><span class="s2">boolean</span><span class="s3">;</span>
        <span class="s3">emit(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'test:pass'</span><span class="s3">, </span><span class="s2">data</span><span class="s1">: </span><span class="s2">TestPass</span><span class="s3">)</span><span class="s1">: </span><span class="s2">boolean</span><span class="s3">;</span>
        <span class="s3">emit(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'test:plan'</span><span class="s3">, </span><span class="s2">data</span><span class="s1">: </span><span class="s2">TestPlan</span><span class="s3">)</span><span class="s1">: </span><span class="s2">boolean</span><span class="s3">;</span>
        <span class="s3">emit(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'test:start'</span><span class="s3">, </span><span class="s2">data</span><span class="s1">: </span><span class="s2">TestStart</span><span class="s3">)</span><span class="s1">: </span><span class="s2">boolean</span><span class="s3">;</span>
        <span class="s3">emit(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'test:stderr'</span><span class="s3">, </span><span class="s2">data</span><span class="s1">: </span><span class="s2">TestStderr</span><span class="s3">)</span><span class="s1">: </span><span class="s2">boolean</span><span class="s3">;</span>
        <span class="s3">emit(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'test:stdout'</span><span class="s3">, </span><span class="s2">data</span><span class="s1">: </span><span class="s2">TestStdout</span><span class="s3">)</span><span class="s1">: </span><span class="s2">boolean</span><span class="s3">;</span>
        <span class="s3">emit(</span><span class="s2">event</span><span class="s1">: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">symbol</span><span class="s3">, </span><span class="s1">...</span><span class="s2">args</span><span class="s1">: </span><span class="s2">any</span><span class="s3">[])</span><span class="s1">: </span><span class="s2">boolean</span><span class="s3">;</span>
        <span class="s3">on(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'test:diagnostic'</span><span class="s3">, </span><span class="s5">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">data</span><span class="s1">: </span><span class="s2">DiagnosticData</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">on(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'test:fail'</span><span class="s3">, </span><span class="s5">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">data</span><span class="s1">: </span><span class="s2">TestFail</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">on(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'test:pass'</span><span class="s3">, </span><span class="s5">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">data</span><span class="s1">: </span><span class="s2">TestPass</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">on(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'test:plan'</span><span class="s3">, </span><span class="s5">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">data</span><span class="s1">: </span><span class="s2">TestPlan</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">on(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'test:start'</span><span class="s3">, </span><span class="s5">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">data</span><span class="s1">: </span><span class="s2">TestStart</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">on(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'test:stderr'</span><span class="s3">, </span><span class="s5">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">data</span><span class="s1">: </span><span class="s2">TestStderr</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">on(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'test:stdout'</span><span class="s3">, </span><span class="s5">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">data</span><span class="s1">: </span><span class="s2">TestStdout</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">on(</span><span class="s2">event</span><span class="s1">: </span><span class="s2">string</span><span class="s3">, </span><span class="s5">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s1">...</span><span class="s2">args</span><span class="s1">: </span><span class="s2">any</span><span class="s3">[]) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">once(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'test:diagnostic'</span><span class="s3">, </span><span class="s5">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">data</span><span class="s1">: </span><span class="s2">DiagnosticData</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">once(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'test:fail'</span><span class="s3">, </span><span class="s5">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">data</span><span class="s1">: </span><span class="s2">TestFail</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">once(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'test:pass'</span><span class="s3">, </span><span class="s5">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">data</span><span class="s1">: </span><span class="s2">TestPass</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">once(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'test:plan'</span><span class="s3">, </span><span class="s5">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">data</span><span class="s1">: </span><span class="s2">TestPlan</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">once(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'test:start'</span><span class="s3">, </span><span class="s5">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">data</span><span class="s1">: </span><span class="s2">TestStart</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">once(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'test:stderr'</span><span class="s3">, </span><span class="s5">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">data</span><span class="s1">: </span><span class="s2">TestStderr</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">once(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'test:stdout'</span><span class="s3">, </span><span class="s5">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">data</span><span class="s1">: </span><span class="s2">TestStdout</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">once(</span><span class="s2">event</span><span class="s1">: </span><span class="s2">string</span><span class="s3">, </span><span class="s5">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s1">...</span><span class="s2">args</span><span class="s1">: </span><span class="s2">any</span><span class="s3">[]) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">prependListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'test:diagnostic'</span><span class="s3">, </span><span class="s5">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">data</span><span class="s1">: </span><span class="s2">DiagnosticData</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">prependListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'test:fail'</span><span class="s3">, </span><span class="s5">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">data</span><span class="s1">: </span><span class="s2">TestFail</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">prependListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'test:pass'</span><span class="s3">, </span><span class="s5">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">data</span><span class="s1">: </span><span class="s2">TestPass</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">prependListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'test:plan'</span><span class="s3">, </span><span class="s5">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">data</span><span class="s1">: </span><span class="s2">TestPlan</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">prependListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'test:start'</span><span class="s3">, </span><span class="s5">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">data</span><span class="s1">: </span><span class="s2">TestStart</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">prependListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'test:stderr'</span><span class="s3">, </span><span class="s5">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">data</span><span class="s1">: </span><span class="s2">TestStderr</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">prependListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'test:stdout'</span><span class="s3">, </span><span class="s5">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">data</span><span class="s1">: </span><span class="s2">TestStdout</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">prependListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s2">string</span><span class="s3">, </span><span class="s5">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s1">...</span><span class="s2">args</span><span class="s1">: </span><span class="s2">any</span><span class="s3">[]) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">prependOnceListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'test:diagnostic'</span><span class="s3">, </span><span class="s5">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">data</span><span class="s1">: </span><span class="s2">DiagnosticData</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">prependOnceListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'test:fail'</span><span class="s3">, </span><span class="s5">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">data</span><span class="s1">: </span><span class="s2">TestFail</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">prependOnceListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'test:pass'</span><span class="s3">, </span><span class="s5">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">data</span><span class="s1">: </span><span class="s2">TestPass</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">prependOnceListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'test:plan'</span><span class="s3">, </span><span class="s5">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">data</span><span class="s1">: </span><span class="s2">TestPlan</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">prependOnceListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'test:start'</span><span class="s3">, </span><span class="s5">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">data</span><span class="s1">: </span><span class="s2">TestStart</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">prependOnceListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'test:stderr'</span><span class="s3">, </span><span class="s5">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">data</span><span class="s1">: </span><span class="s2">TestStderr</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">prependOnceListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'test:stdout'</span><span class="s3">, </span><span class="s5">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">data</span><span class="s1">: </span><span class="s2">TestStdout</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">prependOnceListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s2">string</span><span class="s3">, </span><span class="s5">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s1">...</span><span class="s2">args</span><span class="s1">: </span><span class="s2">any</span><span class="s3">[]) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s0">/**</span>
     <span class="s0">* An instance of `TestContext` is passed to each test function in order to 
     * interact with the test runner. However, the `TestContext` constructor is not 
     * exposed as part of the API. 
     * </span><span class="s1">@since </span><span class="s0">v18.0.0, v16.17.0 
     */</span>
    <span class="s1">class </span><span class="s2">TestContext </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* This function is used to create a hook running before subtest of the current test. 
         * </span><span class="s1">@param </span><span class="s2">fn </span><span class="s0">The hook function. If the hook uses callbacks, the callback function is passed as 
         *    the second argument. Default: A no-op function. 
         * </span><span class="s1">@param </span><span class="s2">options </span><span class="s0">Configuration options for the hook. 
         * </span><span class="s1">@since </span><span class="s0">v20.1.0 
         */</span>
        <span class="s3">before</span><span class="s1">: typeof </span><span class="s2">before</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This function is used to create a hook running before each subtest of the current test. 
         * </span><span class="s1">@param </span><span class="s2">fn </span><span class="s0">The hook function. If the hook uses callbacks, the callback function is passed as 
         *    the second argument. Default: A no-op function. 
         * </span><span class="s1">@param </span><span class="s2">options </span><span class="s0">Configuration options for the hook. 
         * </span><span class="s1">@since </span><span class="s0">v18.8.0 
         */</span>
        <span class="s3">beforeEach</span><span class="s1">: typeof </span><span class="s2">beforeEach</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This function is used to create a hook that runs after the current test finishes. 
         * </span><span class="s1">@param </span><span class="s2">fn </span><span class="s0">The hook function. If the hook uses callbacks, the callback function is passed as 
         *    the second argument. Default: A no-op function. 
         * </span><span class="s1">@param </span><span class="s2">options </span><span class="s0">Configuration options for the hook. 
         * </span><span class="s1">@since </span><span class="s0">v18.13.0 
         */</span>
        <span class="s3">after</span><span class="s1">: typeof </span><span class="s2">after</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This function is used to create a hook running after each subtest of the current test. 
         * </span><span class="s1">@param </span><span class="s2">fn </span><span class="s0">The hook function. If the hook uses callbacks, the callback function is passed as 
         *    the second argument. Default: A no-op function. 
         * </span><span class="s1">@param </span><span class="s2">options </span><span class="s0">Configuration options for the hook. 
         * </span><span class="s1">@since </span><span class="s0">v18.8.0 
         */</span>
        <span class="s3">afterEach</span><span class="s1">: typeof </span><span class="s2">afterEach</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This function is used to write diagnostics to the output. Any diagnostic 
         * information is included at the end of the test's results. This function does 
         * not return a value. 
         * 
         * ```js 
         * test('top level test', (t) =&gt; { 
         *   t.diagnostic('A diagnostic message'); 
         * }); 
         * ``` 
         * </span><span class="s1">@since </span><span class="s0">v18.0.0, v16.17.0 
         * </span><span class="s1">@param </span><span class="s2">message </span><span class="s0">Message to be reported. 
         */</span>
        <span class="s3">diagnostic(</span><span class="s2">message</span><span class="s1">: </span><span class="s2">string</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The name of the test. 
         * </span><span class="s1">@since </span><span class="s0">v18.8.0, v16.18.0 
         */</span>
        <span class="s1">readonly </span><span class="s3">name</span><span class="s1">: </span><span class="s2">string</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If `shouldRunOnlyTests` is truthy, the test context will only run tests that 
         * have the `only` option set. Otherwise, all tests are run. If Node.js was not 
         * started with the `--test-only` command-line option, this function is a 
         * no-op. 
         * 
         * ```js 
         * test('top level test', (t) =&gt; { 
         *   // The test context can be set to run subtests with the 'only' option. 
         *   t.runOnly(true); 
         *   return Promise.all([ 
         *     t.test('this subtest is now skipped'), 
         *     t.test('this subtest is run', { only: true }), 
         *   ]); 
         * }); 
         * ``` 
         * </span><span class="s1">@since </span><span class="s0">v18.0.0, v16.17.0 
         * </span><span class="s1">@param </span><span class="s2">shouldRunOnlyTests </span><span class="s0">Whether or not to run `only` tests. 
         */</span>
        <span class="s3">runOnly(</span><span class="s2">shouldRunOnlyTests</span><span class="s1">: </span><span class="s2">boolean</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* ```js 
         * test('top level test', async (t) =&gt; { 
         *   await fetch('some/uri', { signal: t.signal }); 
         * }); 
         * ``` 
         * </span><span class="s1">@since </span><span class="s0">v18.7.0, v16.17.0 
         */</span>
        <span class="s1">readonly </span><span class="s3">signal</span><span class="s1">: </span><span class="s2">AbortSignal</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This function causes the test's output to indicate the test as skipped. If`message` is provided, it is included in the output. Calling `skip()` does 
         * not terminate execution of the test function. This function does not return a 
         * value. 
         * 
         * ```js 
         * test('top level test', (t) =&gt; { 
         *   // Make sure to return here as well if the test contains additional logic. 
         *   t.skip('this is skipped'); 
         * }); 
         * ``` 
         * </span><span class="s1">@since </span><span class="s0">v18.0.0, v16.17.0 
         * </span><span class="s1">@param </span><span class="s2">message </span><span class="s0">Optional skip message. 
         */</span>
        <span class="s3">skip(</span><span class="s2">message</span><span class="s1">?: </span><span class="s2">string</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This function adds a `TODO` directive to the test's output. If `message` is 
         * provided, it is included in the output. Calling `todo()` does not terminate 
         * execution of the test function. This function does not return a value. 
         * 
         * ```js 
         * test('top level test', (t) =&gt; { 
         *   // This test is marked as `TODO` 
         *   t.todo('this is a todo'); 
         * }); 
         * ``` 
         * </span><span class="s1">@since </span><span class="s0">v18.0.0, v16.17.0 
         * </span><span class="s1">@param </span><span class="s2">message </span><span class="s0">Optional `TODO` message. 
         */</span>
        <span class="s3">todo(</span><span class="s2">message</span><span class="s1">?: </span><span class="s2">string</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This function is used to create subtests under the current test. This function behaves in 
         * the same fashion as the top level </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">test} </span><span class="s0">function. 
         * </span><span class="s1">@since </span><span class="s0">v18.0.0 
         * </span><span class="s1">@param </span><span class="s2">name </span><span class="s0">The name of the test, which is displayed when reporting test results. 
         *    Default: The `name` property of fn, or `'&lt;anonymous&gt;'` if `fn` does not have a name. 
         * </span><span class="s1">@param </span><span class="s2">options </span><span class="s0">Configuration options for the test 
         * </span><span class="s1">@param </span><span class="s2">fn </span><span class="s0">The function under test. This first argument to this function is a 
         *    </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">TestContext} </span><span class="s0">object. If the test uses callbacks, the callback function is 
         *    passed as the second argument. Default: A no-op function. 
         * </span><span class="s1">@returns </span><span class="s0">A </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">Promise} </span><span class="s0">resolved with `undefined` once the test completes. 
         */</span>
        <span class="s3">test</span><span class="s1">: typeof </span><span class="s2">test</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Each test provides its own MockTracker instance. 
         */</span>
        <span class="s1">readonly </span><span class="s3">mock</span><span class="s1">: </span><span class="s2">MockTracker</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s1">interface </span><span class="s2">TestOptions </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* If a number is provided, then that many tests would run in parallel. 
         * If truthy, it would run (number of cpu cores - 1) tests in parallel. 
         * For subtests, it will be `Infinity` tests in parallel. 
         * If falsy, it would only run one test at a time. 
         * If unspecified, subtests inherit this value from their parent. 
         * </span><span class="s1">@default </span><span class="s2">false</span>
         <span class="s0">*/</span>
        <span class="s3">concurrency</span><span class="s1">?: </span><span class="s2">number </span><span class="s1">| </span><span class="s2">boolean </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If truthy, and the test context is configured to run `only` tests, then this test will be 
         * run. Otherwise, the test is skipped. 
         * </span><span class="s1">@default </span><span class="s2">false</span>
         <span class="s0">*/</span>
        <span class="s3">only</span><span class="s1">?: </span><span class="s2">boolean </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Allows aborting an in-progress test. 
         * </span><span class="s1">@since </span><span class="s0">v18.8.0 
         */</span>
        <span class="s3">signal</span><span class="s1">?: </span><span class="s2">AbortSignal </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If truthy, the test is skipped. If a string is provided, that string is displayed in the 
         * test results as the reason for skipping the test. 
         * </span><span class="s1">@default </span><span class="s2">false</span>
         <span class="s0">*/</span>
        <span class="s3">skip</span><span class="s1">?: </span><span class="s2">boolean </span><span class="s1">| </span><span class="s2">string </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* A number of milliseconds the test will fail after. If unspecified, subtests inherit this 
         * value from their parent. 
         * </span><span class="s1">@default </span><span class="s2">Infinity</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v18.7.0 
         */</span>
        <span class="s3">timeout</span><span class="s1">?: </span><span class="s2">number </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If truthy, the test marked as `TODO`. If a string is provided, that string is displayed in 
         * the test results as the reason why the test is `TODO`. 
         * </span><span class="s1">@default </span><span class="s2">false</span>
         <span class="s0">*/</span>
        <span class="s3">todo</span><span class="s1">?: </span><span class="s2">boolean </span><span class="s1">| </span><span class="s2">string </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s0">/**</span>
     <span class="s0">* This function is used to create a hook running before running a suite. 
     * 
     * ```js 
     * describe('tests', async () =&gt; { 
     *   before(() =&gt; console.log('about to run some test')); 
     *   it('is a subtest', () =&gt; { 
     *     assert.ok('some relevant assertion here'); 
     *   }); 
     * }); 
     * ``` 
     * </span><span class="s1">@since </span><span class="s0">v18.8.0, v16.18.0 
     * </span><span class="s1">@param </span><span class="s0">[fn='A no-op function'] The hook function. If the hook uses callbacks, the callback function is passed as the second argument. 
     * </span><span class="s1">@param </span><span class="s2">options </span><span class="s0">Configuration options for the hook. The following properties are supported: 
     */</span>
    <span class="s1">function </span><span class="s3">before(</span><span class="s2">fn</span><span class="s1">?: </span><span class="s2">HookFn</span><span class="s3">, </span><span class="s2">options</span><span class="s1">?: </span><span class="s2">HookOptions</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* This function is used to create a hook running after  running a suite. 
     * 
     * ```js 
     * describe('tests', async () =&gt; { 
     *   after(() =&gt; console.log('finished running tests')); 
     *   it('is a subtest', () =&gt; { 
     *     assert.ok('some relevant assertion here'); 
     *   }); 
     * }); 
     * ``` 
     * </span><span class="s1">@since </span><span class="s0">v18.8.0, v16.18.0 
     * </span><span class="s1">@param </span><span class="s0">[fn='A no-op function'] The hook function. If the hook uses callbacks, the callback function is passed as the second argument. 
     * </span><span class="s1">@param </span><span class="s2">options </span><span class="s0">Configuration options for the hook. The following properties are supported: 
     */</span>
    <span class="s1">function </span><span class="s3">after(</span><span class="s2">fn</span><span class="s1">?: </span><span class="s2">HookFn</span><span class="s3">, </span><span class="s2">options</span><span class="s1">?: </span><span class="s2">HookOptions</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* This function is used to create a hook running 
     * before each subtest of the current suite. 
     * 
     * ```js 
     * describe('tests', async () =&gt; { 
     *   beforeEach(() =&gt; console.log('about to run a test')); 
     *   it('is a subtest', () =&gt; { 
     *     assert.ok('some relevant assertion here'); 
     *   }); 
     * }); 
     * ``` 
     * </span><span class="s1">@since </span><span class="s0">v18.8.0, v16.18.0 
     * </span><span class="s1">@param </span><span class="s0">[fn='A no-op function'] The hook function. If the hook uses callbacks, the callback function is passed as the second argument. 
     * </span><span class="s1">@param </span><span class="s2">options </span><span class="s0">Configuration options for the hook. The following properties are supported: 
     */</span>
    <span class="s1">function </span><span class="s3">beforeEach(</span><span class="s2">fn</span><span class="s1">?: </span><span class="s2">HookFn</span><span class="s3">, </span><span class="s2">options</span><span class="s1">?: </span><span class="s2">HookOptions</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* This function is used to create a hook running 
     * after each subtest of the current test. 
     * 
     * ```js 
     * describe('tests', async () =&gt; { 
     *   afterEach(() =&gt; console.log('finished running a test')); 
     *   it('is a subtest', () =&gt; { 
     *     assert.ok('some relevant assertion here'); 
     *   }); 
     * }); 
     * ``` 
     * </span><span class="s1">@since </span><span class="s0">v18.8.0, v16.18.0 
     * </span><span class="s1">@param </span><span class="s0">[fn='A no-op function'] The hook function. If the hook uses callbacks, the callback function is passed as the second argument. 
     * </span><span class="s1">@param </span><span class="s2">options </span><span class="s0">Configuration options for the hook. The following properties are supported: 
     */</span>
    <span class="s1">function </span><span class="s3">afterEach(</span><span class="s2">fn</span><span class="s1">?: </span><span class="s2">HookFn</span><span class="s3">, </span><span class="s2">options</span><span class="s1">?: </span><span class="s2">HookOptions</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The hook function. If the hook uses callbacks, the callback function is passed as the 
     * second argument. 
     */</span>
    <span class="s1">type </span><span class="s2">HookFn </span><span class="s1">= </span><span class="s3">(</span><span class="s5">done</span><span class="s1">: </span><span class="s3">(</span><span class="s2">result</span><span class="s1">?: </span><span class="s2">any</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">any</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Configuration options for hooks. 
     * </span><span class="s1">@since </span><span class="s0">v18.8.0 
     */</span>
    <span class="s1">interface </span><span class="s2">HookOptions </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Allows aborting an in-progress hook. 
         */</span>
        <span class="s3">signal</span><span class="s1">?: </span><span class="s2">AbortSignal </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* A number of milliseconds the hook will fail after. If unspecified, subtests inherit this 
         * value from their parent. 
         * </span><span class="s1">@default </span><span class="s2">Infinity</span>
         <span class="s0">*/</span>
        <span class="s3">timeout</span><span class="s1">?: </span><span class="s2">number </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s1">interface </span><span class="s2">MockFunctionOptions </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* The number of times that the mock will use the behavior of `implementation`. 
         * Once the mock function has been called `times` times, 
         * it will automatically restore the behavior of `original`. 
         * This value must be an integer greater than zero. 
         * </span><span class="s1">@default </span><span class="s2">Infinity</span>
         <span class="s0">*/</span>
        <span class="s3">times</span><span class="s1">?: </span><span class="s2">number </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s1">interface </span><span class="s2">MockMethodOptions </span><span class="s1">extends </span><span class="s2">MockFunctionOptions </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* If `true`, `object[methodName]` is treated as a getter. 
         * This option cannot be used with the `setter` option. 
         */</span>
        <span class="s3">getter</span><span class="s1">?: </span><span class="s2">boolean </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If `true`, `object[methodName]` is treated as a setter. 
         * This option cannot be used with the `getter` option. 
         */</span>
        <span class="s3">setter</span><span class="s1">?: </span><span class="s2">boolean </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s1">type </span><span class="s2">Mock</span><span class="s3">&lt;</span><span class="s2">F </span><span class="s1">extends </span><span class="s2">Function</span><span class="s3">&gt; </span><span class="s1">= </span><span class="s2">F </span><span class="s1">&amp; </span><span class="s3">{</span>
        <span class="s3">mock</span><span class="s1">: </span><span class="s2">MockFunctionContext</span><span class="s3">&lt;</span><span class="s2">F</span><span class="s3">&gt;;</span>
    <span class="s3">};</span>
    <span class="s1">type </span><span class="s2">NoOpFunction </span><span class="s1">= </span><span class="s3">(</span><span class="s1">...</span><span class="s2">args</span><span class="s1">: </span><span class="s2">any</span><span class="s3">[]) </span><span class="s1">=&gt; </span><span class="s2">undefined</span><span class="s3">;</span>
    <span class="s1">type </span><span class="s2">FunctionPropertyNames</span><span class="s3">&lt;</span><span class="s2">T</span><span class="s3">&gt; </span><span class="s1">= </span><span class="s3">{</span>
        <span class="s3">[</span><span class="s2">K </span><span class="s1">in keyof </span><span class="s2">T</span><span class="s3">]</span><span class="s1">: </span><span class="s2">T</span><span class="s3">[</span><span class="s2">K</span><span class="s3">] </span><span class="s1">extends </span><span class="s2">Function </span><span class="s1">? </span><span class="s2">K </span><span class="s1">: </span><span class="s2">never</span><span class="s3">;</span>
    <span class="s3">}[</span><span class="s1">keyof </span><span class="s2">T</span><span class="s3">];</span>
    <span class="s0">/**</span>
     <span class="s0">* The `MockTracker` class is used to manage mocking functionality. The test runner 
     * module provides a top level `mock` export which is a `MockTracker` instance. 
     * Each test also provides its own `MockTracker` instance via the test context's`mock` property. 
     * </span><span class="s1">@since </span><span class="s0">v19.1.0, v18.13.0 
     */</span>
    <span class="s1">class </span><span class="s2">MockTracker </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* This function is used to create a mock function. 
         * 
         * The following example creates a mock function that increments a counter by one 
         * on each invocation. The `times` option is used to modify the mock behavior such 
         * that the first two invocations add two to the counter instead of one. 
         * 
         * ```js 
         * test('mocks a counting function', (t) =&gt; { 
         *   let cnt = 0; 
         * 
         *   function addOne() { 
         *     cnt++; 
         *     return cnt; 
         *   } 
         * 
         *   function addTwo() { 
         *     cnt += 2; 
         *     return cnt; 
         *   } 
         * 
         *   const fn = t.mock.fn(addOne, addTwo, { times: 2 }); 
         * 
         *   assert.strictEqual(fn(), 2); 
         *   assert.strictEqual(fn(), 4); 
         *   assert.strictEqual(fn(), 5); 
         *   assert.strictEqual(fn(), 6); 
         * }); 
         * ``` 
         * </span><span class="s1">@since </span><span class="s0">v19.1.0, v18.13.0 
         * </span><span class="s1">@param </span><span class="s0">[original='A no-op function'] An optional function to create a mock on. 
         * </span><span class="s1">@param </span><span class="s2">implementation </span><span class="s0">An optional function used as the mock implementation for `original`. This is useful for creating mocks that exhibit one behavior for a specified number of calls and 
         * then restore the behavior of `original`. 
         * </span><span class="s1">@param </span><span class="s2">options </span><span class="s0">Optional configuration options for the mock function. The following properties are supported: 
         * </span><span class="s1">@return </span><span class="s0">The mocked function. The mocked function contains a special `mock` property, which is an instance of </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">MockFunctionContext}</span><span class="s0">, and can be used for inspecting and changing the 
         * behavior of the mocked function. 
         */</span>
        <span class="s3">fn&lt;</span><span class="s2">F </span><span class="s1">extends </span><span class="s2">Function </span><span class="s1">= </span><span class="s2">NoOpFunction</span><span class="s3">&gt;(</span><span class="s2">original</span><span class="s1">?: </span><span class="s2">F</span><span class="s3">, </span><span class="s2">options</span><span class="s1">?: </span><span class="s2">MockFunctionOptions</span><span class="s3">)</span><span class="s1">: </span><span class="s2">Mock</span><span class="s3">&lt;</span><span class="s2">F</span><span class="s3">&gt;;</span>
        <span class="s3">fn&lt;</span><span class="s2">F </span><span class="s1">extends </span><span class="s2">Function </span><span class="s1">= </span><span class="s2">NoOpFunction</span><span class="s3">, </span><span class="s2">Implementation </span><span class="s1">extends </span><span class="s2">Function </span><span class="s1">= </span><span class="s2">F</span><span class="s3">&gt;(</span><span class="s2">original</span><span class="s1">?: </span><span class="s2">F</span><span class="s3">, </span><span class="s2">implementation</span><span class="s1">?: </span><span class="s2">Implementation</span><span class="s3">, </span><span class="s2">options</span><span class="s1">?: </span><span class="s2">MockFunctionOptions</span><span class="s3">)</span><span class="s1">: </span><span class="s2">Mock</span><span class="s3">&lt;</span><span class="s2">F </span><span class="s1">| </span><span class="s2">Implementation</span><span class="s3">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* This function is used to create a mock on an existing object method. The 
         * following example demonstrates how a mock is created on an existing object 
         * method. 
         * 
         * ```js 
         * test('spies on an object method', (t) =&gt; { 
         *   const number = { 
         *     value: 5, 
         *     subtract(a) { 
         *       return this.value - a; 
         *     }, 
         *   }; 
         * 
         *   t.mock.method(number, 'subtract'); 
         *   assert.strictEqual(number.subtract.mock.calls.length, 0); 
         *   assert.strictEqual(number.subtract(3), 2); 
         *   assert.strictEqual(number.subtract.mock.calls.length, 1); 
         * 
         *   const call = number.subtract.mock.calls[0]; 
         * 
         *   assert.deepStrictEqual(call.arguments, [3]); 
         *   assert.strictEqual(call.result, 2); 
         *   assert.strictEqual(call.error, undefined); 
         *   assert.strictEqual(call.target, undefined); 
         *   assert.strictEqual(call.this, number); 
         * }); 
         * ``` 
         * </span><span class="s1">@since </span><span class="s0">v19.1.0, v18.13.0 
         * </span><span class="s1">@param </span><span class="s2">object </span><span class="s0">The object whose method is being mocked. 
         * </span><span class="s1">@param </span><span class="s2">methodName </span><span class="s0">The identifier of the method on `object` to mock. If `object[methodName]` is not a function, an error is thrown. 
         * </span><span class="s1">@param </span><span class="s2">implementation </span><span class="s0">An optional function used as the mock implementation for `object[methodName]`. 
         * </span><span class="s1">@param </span><span class="s2">options </span><span class="s0">Optional configuration options for the mock method. The following properties are supported: 
         * </span><span class="s1">@return </span><span class="s0">The mocked method. The mocked method contains a special `mock` property, which is an instance of </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">MockFunctionContext}</span><span class="s0">, and can be used for inspecting and changing the 
         * behavior of the mocked method. 
         */</span>
        <span class="s2">method</span><span class="s1">&lt;</span>
            <span class="s2">MockedObject extends </span><span class="s3">object,</span>
            <span class="s2">MethodName extends FunctionPropertyNames</span><span class="s1">&lt;</span><span class="s2">MockedObject</span><span class="s1">&gt;</span><span class="s3">,</span>
        <span class="s1">&gt;</span><span class="s3">(</span>
            <span class="s2">object</span><span class="s1">: </span><span class="s2">MockedObject</span><span class="s3">,</span>
            <span class="s2">methodName</span><span class="s1">: </span><span class="s2">MethodName</span><span class="s3">,</span>
            <span class="s2">options</span><span class="s1">?: </span><span class="s2">MockFunctionOptions</span><span class="s3">,</span>
        <span class="s3">)</span><span class="s1">: </span><span class="s2">MockedObject</span><span class="s3">[</span><span class="s2">MethodName</span><span class="s3">] </span><span class="s1">extends </span><span class="s2">Function</span>
            <span class="s1">? </span><span class="s2">Mock</span><span class="s3">&lt;</span><span class="s2">MockedObject</span><span class="s3">[</span><span class="s2">MethodName</span><span class="s3">]&gt;</span>
            <span class="s1">: </span><span class="s2">never</span><span class="s3">;</span>
        <span class="s2">method</span><span class="s1">&lt;</span>
            <span class="s2">MockedObject extends </span><span class="s3">object,</span>
            <span class="s2">MethodName extends FunctionPropertyNames</span><span class="s1">&lt;</span><span class="s2">MockedObject</span><span class="s1">&gt;</span><span class="s3">,</span>
            <span class="s2">Implementation extends </span><span class="s3">Function,</span>
        <span class="s1">&gt;</span><span class="s3">(</span>
            <span class="s2">object</span><span class="s1">: </span><span class="s2">MockedObject</span><span class="s3">,</span>
            <span class="s2">methodName</span><span class="s1">: </span><span class="s2">MethodName</span><span class="s3">,</span>
            <span class="s2">implementation</span><span class="s1">: </span><span class="s2">Implementation</span><span class="s3">,</span>
            <span class="s2">options</span><span class="s1">?: </span><span class="s2">MockFunctionOptions</span><span class="s3">,</span>
        <span class="s3">)</span><span class="s1">: </span><span class="s2">MockedObject</span><span class="s3">[</span><span class="s2">MethodName</span><span class="s3">] </span><span class="s1">extends </span><span class="s2">Function</span>
            <span class="s1">? </span><span class="s2">Mock</span><span class="s3">&lt;</span><span class="s2">MockedObject</span><span class="s3">[</span><span class="s2">MethodName</span><span class="s3">] </span><span class="s1">| </span><span class="s2">Implementation</span><span class="s3">&gt;</span>
            <span class="s1">: </span><span class="s2">never</span><span class="s3">;</span>
        <span class="s3">method&lt;</span><span class="s2">MockedObject </span><span class="s1">extends </span><span class="s2">object</span><span class="s3">&gt;(</span>
            <span class="s2">object</span><span class="s1">: </span><span class="s2">MockedObject</span><span class="s3">,</span>
            <span class="s2">methodName</span><span class="s1">: keyof </span><span class="s2">MockedObject</span><span class="s3">,</span>
            <span class="s2">options</span><span class="s1">: </span><span class="s2">MockMethodOptions</span><span class="s3">,</span>
        <span class="s3">)</span><span class="s1">: </span><span class="s2">Mock</span><span class="s3">&lt;</span><span class="s2">Function</span><span class="s3">&gt;;</span>
        <span class="s3">method&lt;</span><span class="s2">MockedObject </span><span class="s1">extends </span><span class="s2">object</span><span class="s3">&gt;(</span>
            <span class="s2">object</span><span class="s1">: </span><span class="s2">MockedObject</span><span class="s3">,</span>
            <span class="s2">methodName</span><span class="s1">: keyof </span><span class="s2">MockedObject</span><span class="s3">,</span>
            <span class="s5">implementation</span><span class="s1">: </span><span class="s2">Function</span><span class="s3">,</span>
            <span class="s2">options</span><span class="s1">: </span><span class="s2">MockMethodOptions</span><span class="s3">,</span>
        <span class="s3">)</span><span class="s1">: </span><span class="s2">Mock</span><span class="s3">&lt;</span><span class="s2">Function</span><span class="s3">&gt;;</span>

        <span class="s0">/**</span>
         <span class="s0">* This function is syntax sugar for `MockTracker.method` with `options.getter`set to `true`. 
         * </span><span class="s1">@since </span><span class="s0">v19.3.0, v18.13.0 
         */</span>
        <span class="s2">getter</span><span class="s1">&lt;</span>
            <span class="s2">MockedObject extends </span><span class="s3">object,</span>
            <span class="s2">MethodName extends keyof </span><span class="s3">MockedObject,</span>
        <span class="s1">&gt;</span><span class="s3">(</span>
            <span class="s2">object</span><span class="s1">: </span><span class="s2">MockedObject</span><span class="s3">,</span>
            <span class="s2">methodName</span><span class="s1">: </span><span class="s2">MethodName</span><span class="s3">,</span>
            <span class="s2">options</span><span class="s1">?: </span><span class="s2">MockFunctionOptions</span><span class="s3">,</span>
        <span class="s3">)</span><span class="s1">: </span><span class="s2">Mock</span><span class="s3">&lt;() </span><span class="s1">=&gt; </span><span class="s2">MockedObject</span><span class="s3">[</span><span class="s2">MethodName</span><span class="s3">]&gt;;</span>
        <span class="s2">getter</span><span class="s1">&lt;</span>
            <span class="s2">MockedObject extends </span><span class="s3">object,</span>
            <span class="s2">MethodName extends keyof </span><span class="s3">MockedObject,</span>
            <span class="s2">Implementation extends </span><span class="s3">Function,</span>
        <span class="s1">&gt;</span><span class="s3">(</span>
            <span class="s2">object</span><span class="s1">: </span><span class="s2">MockedObject</span><span class="s3">,</span>
            <span class="s2">methodName</span><span class="s1">: </span><span class="s2">MethodName</span><span class="s3">,</span>
            <span class="s2">implementation</span><span class="s1">?: </span><span class="s2">Implementation</span><span class="s3">,</span>
            <span class="s2">options</span><span class="s1">?: </span><span class="s2">MockFunctionOptions</span><span class="s3">,</span>
        <span class="s3">)</span><span class="s1">: </span><span class="s2">Mock</span><span class="s3">&lt;(() </span><span class="s1">=&gt; </span><span class="s2">MockedObject</span><span class="s3">[</span><span class="s2">MethodName</span><span class="s3">]) </span><span class="s1">| </span><span class="s2">Implementation</span><span class="s3">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* This function is syntax sugar for `MockTracker.method` with `options.setter`set to `true`. 
         * </span><span class="s1">@since </span><span class="s0">v19.3.0, v18.13.0 
         */</span>
        <span class="s2">setter</span><span class="s1">&lt;</span>
            <span class="s2">MockedObject extends </span><span class="s3">object,</span>
            <span class="s2">MethodName extends keyof </span><span class="s3">MockedObject,</span>
        <span class="s1">&gt;</span><span class="s3">(</span>
            <span class="s2">object</span><span class="s1">: </span><span class="s2">MockedObject</span><span class="s3">,</span>
            <span class="s2">methodName</span><span class="s1">: </span><span class="s2">MethodName</span><span class="s3">,</span>
            <span class="s2">options</span><span class="s1">?: </span><span class="s2">MockFunctionOptions</span><span class="s3">,</span>
        <span class="s3">)</span><span class="s1">: </span><span class="s2">Mock</span><span class="s3">&lt;(</span><span class="s2">value</span><span class="s1">: </span><span class="s2">MockedObject</span><span class="s3">[</span><span class="s2">MethodName</span><span class="s3">]) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">&gt;;</span>
        <span class="s2">setter</span><span class="s1">&lt;</span>
            <span class="s2">MockedObject extends </span><span class="s3">object,</span>
            <span class="s2">MethodName extends keyof </span><span class="s3">MockedObject,</span>
            <span class="s2">Implementation extends </span><span class="s3">Function,</span>
        <span class="s1">&gt;</span><span class="s3">(</span>
            <span class="s2">object</span><span class="s1">: </span><span class="s2">MockedObject</span><span class="s3">,</span>
            <span class="s2">methodName</span><span class="s1">: </span><span class="s2">MethodName</span><span class="s3">,</span>
            <span class="s2">implementation</span><span class="s1">?: </span><span class="s2">Implementation</span><span class="s3">,</span>
            <span class="s2">options</span><span class="s1">?: </span><span class="s2">MockFunctionOptions</span><span class="s3">,</span>
        <span class="s3">)</span><span class="s1">: </span><span class="s2">Mock</span><span class="s3">&lt;((</span><span class="s2">value</span><span class="s1">: </span><span class="s2">MockedObject</span><span class="s3">[</span><span class="s2">MethodName</span><span class="s3">]) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">) </span><span class="s1">| </span><span class="s2">Implementation</span><span class="s3">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* This function restores the default behavior of all mocks that were previously 
         * created by this `MockTracker` and disassociates the mocks from the`MockTracker` instance. Once disassociated, the mocks can still be used, but the`MockTracker` instance can no longer be 
         * used to reset their behavior or 
         * otherwise interact with them. 
         * 
         * After each test completes, this function is called on the test context's`MockTracker`. If the global `MockTracker` is used extensively, calling this 
         * function manually is recommended. 
         * </span><span class="s1">@since </span><span class="s0">v19.1.0, v18.13.0 
         */</span>
        <span class="s3">reset()</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This function restores the default behavior of all mocks that were previously 
         * created by this `MockTracker`. Unlike `mock.reset()`, `mock.restoreAll()` does 
         * not disassociate the mocks from the `MockTracker` instance. 
         * </span><span class="s1">@since </span><span class="s0">v19.1.0, v18.13.0 
         */</span>
        <span class="s3">restoreAll()</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s3">timers</span><span class="s1">: </span><span class="s2">MockTimers</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s1">const </span><span class="s3">mock</span><span class="s1">: </span><span class="s2">MockTracker</span><span class="s3">;</span>
    <span class="s1">interface </span><span class="s2">MockFunctionCall</span><span class="s3">&lt;</span>
        <span class="s2">F </span><span class="s1">extends </span><span class="s2">Function</span><span class="s3">,</span>
        <span class="s2">ReturnType </span><span class="s1">= </span><span class="s2">F </span><span class="s1">extends </span><span class="s3">(</span><span class="s1">...</span><span class="s2">args</span><span class="s1">: </span><span class="s2">any</span><span class="s3">) </span><span class="s1">=&gt; infer </span><span class="s2">T</span>
            <span class="s1">? </span><span class="s2">T</span>
            <span class="s1">: </span><span class="s2">F </span><span class="s1">extends abstract new </span><span class="s3">(</span><span class="s1">...</span><span class="s2">args</span><span class="s1">: </span><span class="s2">any</span><span class="s3">) </span><span class="s1">=&gt; infer </span><span class="s2">T</span>
                <span class="s1">? </span><span class="s2">T</span>
                <span class="s1">: </span><span class="s2">unknown</span><span class="s3">,</span>
        <span class="s2">Args </span><span class="s1">= </span><span class="s2">F </span><span class="s1">extends </span><span class="s3">(</span><span class="s1">...</span><span class="s2">args</span><span class="s1">: infer </span><span class="s2">Y</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">any</span>
            <span class="s1">? </span><span class="s2">Y</span>
            <span class="s1">: </span><span class="s2">F </span><span class="s1">extends abstract new </span><span class="s3">(</span><span class="s1">...</span><span class="s2">args</span><span class="s1">: infer </span><span class="s2">Y</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">any</span>
                <span class="s1">? </span><span class="s2">Y</span>
                <span class="s1">: </span><span class="s2">unknown</span><span class="s3">[],</span>
    <span class="s3">&gt; {</span>
        <span class="s0">/**</span>
         <span class="s0">* An array of the arguments passed to the mock function. 
         */</span>
        <span class="s3">arguments</span><span class="s1">: </span><span class="s2">Args</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If the mocked function threw then this property contains the thrown value. 
         */</span>
        <span class="s3">error</span><span class="s1">: </span><span class="s2">unknown </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The value returned by the mocked function. 
         * 
         * If the mocked function threw, it will be `undefined`. 
         */</span>
        <span class="s3">result</span><span class="s1">: </span><span class="s2">ReturnType </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* An `Error` object whose stack can be used to determine the callsite of the mocked function invocation. 
         */</span>
        <span class="s3">stack</span><span class="s1">: </span><span class="s2">Error</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If the mocked function is a constructor, this field contains the class being constructed. 
         * Otherwise this will be `undefined`. 
         */</span>
        <span class="s3">target</span><span class="s1">: </span><span class="s2">F </span><span class="s1">extends abstract new </span><span class="s3">(</span><span class="s1">...</span><span class="s2">args</span><span class="s1">: </span><span class="s2">any</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">any </span><span class="s1">? </span><span class="s2">F </span><span class="s1">: </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The mocked function's `this` value. 
         */</span>
        <span class="s3">this</span><span class="s1">: </span><span class="s2">unknown</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s0">/**</span>
     <span class="s0">* The `MockFunctionContext` class is used to inspect or manipulate the behavior of 
     * mocks created via the `MockTracker` APIs. 
     * </span><span class="s1">@since </span><span class="s0">v19.1.0, v18.13.0 
     */</span>
    <span class="s1">class </span><span class="s2">MockFunctionContext</span><span class="s3">&lt;</span><span class="s2">F </span><span class="s1">extends </span><span class="s2">Function</span><span class="s3">&gt; {</span>
        <span class="s0">/**</span>
         <span class="s0">* A getter that returns a copy of the internal array used to track calls to the 
         * mock. Each entry in the array is an object with the following properties. 
         * </span><span class="s1">@since </span><span class="s0">v19.1.0, v18.13.0 
         */</span>
        <span class="s1">readonly </span><span class="s3">calls</span><span class="s1">: </span><span class="s2">Array</span><span class="s3">&lt;</span><span class="s2">MockFunctionCall</span><span class="s3">&lt;</span><span class="s2">F</span><span class="s3">&gt;&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* This function returns the number of times that this mock has been invoked. This 
         * function is more efficient than checking `ctx.calls.length` because `ctx.calls`is a getter that creates a copy of the internal call tracking array. 
         * </span><span class="s1">@since </span><span class="s0">v19.1.0, v18.13.0 
         * </span><span class="s1">@return </span><span class="s0">The number of times that this mock has been invoked. 
         */</span>
        <span class="s3">callCount()</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This function is used to change the behavior of an existing mock. 
         * 
         * The following example creates a mock function using `t.mock.fn()`, calls the 
         * mock function, and then changes the mock implementation to a different function. 
         * 
         * ```js 
         * test('changes a mock behavior', (t) =&gt; { 
         *   let cnt = 0; 
         * 
         *   function addOne() { 
         *     cnt++; 
         *     return cnt; 
         *   } 
         * 
         *   function addTwo() { 
         *     cnt += 2; 
         *     return cnt; 
         *   } 
         * 
         *   const fn = t.mock.fn(addOne); 
         * 
         *   assert.strictEqual(fn(), 1); 
         *   fn.mock.mockImplementation(addTwo); 
         *   assert.strictEqual(fn(), 3); 
         *   assert.strictEqual(fn(), 5); 
         * }); 
         * ``` 
         * </span><span class="s1">@since </span><span class="s0">v19.1.0, v18.13.0 
         * </span><span class="s1">@param </span><span class="s2">implementation </span><span class="s0">The function to be used as the mock's new implementation. 
         */</span>
        <span class="s3">mockImplementation(</span><span class="s5">implementation</span><span class="s1">: </span><span class="s2">Function</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This function is used to change the behavior of an existing mock for a single 
         * invocation. Once invocation `onCall` has occurred, the mock will revert to 
         * whatever behavior it would have used had `mockImplementationOnce()` not been 
         * called. 
         * 
         * The following example creates a mock function using `t.mock.fn()`, calls the 
         * mock function, changes the mock implementation to a different function for the 
         * next invocation, and then resumes its previous behavior. 
         * 
         * ```js 
         * test('changes a mock behavior once', (t) =&gt; { 
         *   let cnt = 0; 
         * 
         *   function addOne() { 
         *     cnt++; 
         *     return cnt; 
         *   } 
         * 
         *   function addTwo() { 
         *     cnt += 2; 
         *     return cnt; 
         *   } 
         * 
         *   const fn = t.mock.fn(addOne); 
         * 
         *   assert.strictEqual(fn(), 1); 
         *   fn.mock.mockImplementationOnce(addTwo); 
         *   assert.strictEqual(fn(), 3); 
         *   assert.strictEqual(fn(), 4); 
         * }); 
         * ``` 
         * </span><span class="s1">@since </span><span class="s0">v19.1.0, v18.13.0 
         * </span><span class="s1">@param </span><span class="s2">implementation </span><span class="s0">The function to be used as the mock's implementation for the invocation number specified by `onCall`. 
         * </span><span class="s1">@param </span><span class="s2">onCall </span><span class="s0">The invocation number that will use `implementation`. If the specified invocation has already occurred then an exception is thrown. 
         */</span>
        <span class="s3">mockImplementationOnce(</span><span class="s5">implementation</span><span class="s1">: </span><span class="s2">Function</span><span class="s3">, </span><span class="s2">onCall</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Resets the call history of the mock function. 
         * </span><span class="s1">@since </span><span class="s0">v19.3.0, v18.13.0 
         */</span>
        <span class="s3">resetCalls()</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Resets the implementation of the mock function to its original behavior. The 
         * mock can still be used after calling this function. 
         * </span><span class="s1">@since </span><span class="s0">v19.1.0, v18.13.0 
         */</span>
        <span class="s3">restore()</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s1">type </span><span class="s2">Timer </span><span class="s1">= </span><span class="s4">'setInterval' </span><span class="s1">| </span><span class="s4">'clearInterval' </span><span class="s1">| </span><span class="s4">'setTimeout' </span><span class="s1">| </span><span class="s4">'clearTimeout'</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Mocking timers is a technique commonly used in software testing to simulate and 
     * control the behavior of timers, such as `setInterval` and `setTimeout`, 
     * without actually waiting for the specified time intervals. 
     * 
     * The `MockTracker` provides a top-level `timers` export 
     * which is a `MockTimers` instance. 
     * </span><span class="s1">@since </span><span class="s0">v20.4.0 
     * </span><span class="s1">@experimental</span>
     <span class="s0">*/</span>
    <span class="s1">class </span><span class="s2">MockTimers </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Enables timer mocking for the specified timers. 
         * 
         * **Note:** When you enable mocking for a specific timer, its associated 
         * clear function will also be implicitly mocked. 
         * 
         * Example usage: 
         * 
         * ```js 
         * import { mock } from 'node:test'; 
         * mock.timers.enable(['setInterval']); 
         * ``` 
         * 
         * ```js 
         * const { mock } = require('node:test'); 
         * mock.timers.enable(['setInterval']); 
         * ``` 
         * 
         * The above example enables mocking for the `setInterval` timer and 
         * implicitly mocks the `clearInterval` function. Only the `setInterval`and `clearInterval` functions from `node:timers`,`node:timers/promises`, and`globalThis` will be mocked. 
         * 
         * Alternatively, if you call `mock.timers.enable()` without any parameters: 
         * 
         * All timers (`'setInterval'`, `'clearInterval'`, `'setTimeout'`, and `'clearTimeout'`) 
         * will be mocked. The `setInterval`, `clearInterval`, `setTimeout`, and `clearTimeout`functions from `node:timers`, `node:timers/promises`, 
         * and `globalThis` will be mocked. 
         * </span><span class="s1">@since </span><span class="s0">v20.4.0 
         */</span>
        <span class="s3">enable(</span><span class="s2">timers</span><span class="s1">?: </span><span class="s2">Timer</span><span class="s3">[])</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This function restores the default behavior of all mocks that were previously 
         * created by this `MockTimers` instance and disassociates the mocks 
         * from the `MockTracker` instance. 
         * 
         * **Note:** After each test completes, this function is called on 
         * the test context's `MockTracker`. 
         * 
         * ```js 
         * import { mock } from 'node:test'; 
         * mock.timers.reset(); 
         * ``` 
         * 
         * ```js 
         * const { mock } = require('node:test'); 
         * mock.timers.reset(); 
         * ``` 
         * </span><span class="s1">@since </span><span class="s0">v20.4.0 
         */</span>
        <span class="s3">reset()</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Advances time for all mocked timers. 
         * 
         * **Note:** This diverges from how `setTimeout` in Node.js behaves and accepts 
         * only positive numbers. In Node.js, `setTimeout` with negative numbers is 
         * only supported for web compatibility reasons. 
         * 
         * The following example mocks a `setTimeout` function and 
         * by using `.tick` advances in 
         * time triggering all pending timers. 
         * 
         * ```js 
         * import assert from 'node:assert'; 
         * import { test } from 'node:test'; 
         * 
         * test('mocks setTimeout to be executed synchronously without having to actually wait for it', (context) =&gt; { 
         *   const fn = context.mock.fn(); 
         * 
         *   context.mock.timers.enable(['setTimeout']); 
         * 
         *   setTimeout(fn, 9999); 
         * 
         *   assert.strictEqual(fn.mock.callCount(), 0); 
         * 
         *   // Advance in time 
         *   context.mock.timers.tick(9999); 
         * 
         *   assert.strictEqual(fn.mock.callCount(), 1); 
         * }); 
         * ``` 
         * 
         * ```js 
         * const assert = require('node:assert'); 
         * const { test } = require('node:test'); 
         * 
         * test('mocks setTimeout to be executed synchronously without having to actually wait for it', (context) =&gt; { 
         *   const fn = context.mock.fn(); 
         *   context.mock.timers.enable(['setTimeout']); 
         * 
         *   setTimeout(fn, 9999); 
         *   assert.strictEqual(fn.mock.callCount(), 0); 
         * 
         *   // Advance in time 
         *   context.mock.timers.tick(9999); 
         * 
         *   assert.strictEqual(fn.mock.callCount(), 1); 
         * }); 
         * ``` 
         * 
         * Alternativelly, the `.tick` function can be called many times 
         * 
         * ```js 
         * import assert from 'node:assert'; 
         * import { test } from 'node:test'; 
         * 
         * test('mocks setTimeout to be executed synchronously without having to actually wait for it', (context) =&gt; { 
         *   const fn = context.mock.fn(); 
         *   context.mock.timers.enable(['setTimeout']); 
         *   const nineSecs = 9000; 
         *   setTimeout(fn, nineSecs); 
         * 
         *   const twoSeconds = 3000; 
         *   context.mock.timers.tick(twoSeconds); 
         *   context.mock.timers.tick(twoSeconds); 
         *   context.mock.timers.tick(twoSeconds); 
         * 
         *   assert.strictEqual(fn.mock.callCount(), 1); 
         * }); 
         * ``` 
         * 
         * ```js 
         * const assert = require('node:assert'); 
         * const { test } = require('node:test'); 
         * 
         * test('mocks setTimeout to be executed synchronously without having to actually wait for it', (context) =&gt; { 
         *   const fn = context.mock.fn(); 
         *   context.mock.timers.enable(['setTimeout']); 
         *   const nineSecs = 9000; 
         *   setTimeout(fn, nineSecs); 
         * 
         *   const twoSeconds = 3000; 
         *   context.mock.timers.tick(twoSeconds); 
         *   context.mock.timers.tick(twoSeconds); 
         *   context.mock.timers.tick(twoSeconds); 
         * 
         *   assert.strictEqual(fn.mock.callCount(), 1); 
         * }); 
         * ``` 
         * </span><span class="s1">@since </span><span class="s0">v20.4.0 
         */</span>
        <span class="s3">tick(</span><span class="s2">milliseconds</span><span class="s1">: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Triggers all pending mocked timers immediately. 
         * 
         * The example below triggers all pending timers immediately, 
         * causing them to execute without any delay. 
         * 
         * ```js 
         * import assert from 'node:assert'; 
         * import { test } from 'node:test'; 
         * 
         * test('runAll functions following the given order', (context) =&gt; { 
         *   context.mock.timers.enable(['setTimeout']); 
         *   const results = []; 
         *   setTimeout(() =&gt; results.push(1), 9999); 
         * 
         *   // Notice that if both timers have the same timeout, 
         *   // the order of execution is guaranteed 
         *   setTimeout(() =&gt; results.push(3), 8888); 
         *   setTimeout(() =&gt; results.push(2), 8888); 
         * 
         *   assert.deepStrictEqual(results, []); 
         * 
         *   context.mock.timers.runAll(); 
         * 
         *   assert.deepStrictEqual(results, [3, 2, 1]); 
         * }); 
         * ``` 
         * 
         * ```js 
         * const assert = require('node:assert'); 
         * const { test } = require('node:test'); 
         * 
         * test('runAll functions following the given order', (context) =&gt; { 
         *   context.mock.timers.enable(['setTimeout']); 
         *   const results = []; 
         *   setTimeout(() =&gt; results.push(1), 9999); 
         * 
         *   // Notice that if both timers have the same timeout, 
         *   // the order of execution is guaranteed 
         *   setTimeout(() =&gt; results.push(3), 8888); 
         *   setTimeout(() =&gt; results.push(2), 8888); 
         * 
         *   assert.deepStrictEqual(results, []); 
         * 
         *   context.mock.timers.runAll(); 
         * 
         *   assert.deepStrictEqual(results, [3, 2, 1]); 
         * }); 
         * ``` 
         * 
         * **Note:** The `runAll()` function is specifically designed for 
         * triggering timers in the context of timer mocking. 
         * It does not have any effect on real-time system 
         * clocks or actual timers outside of the mocking environment. 
         * </span><span class="s1">@since </span><span class="s0">v20.4.0 
         */</span>
        <span class="s3">runAll()</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s1">export </span><span class="s3">{ </span><span class="s2">test </span><span class="s1">as default</span><span class="s3">, </span><span class="s2">run</span><span class="s3">, </span><span class="s2">test</span><span class="s3">, </span><span class="s2">describe</span><span class="s3">, </span><span class="s2">it</span><span class="s3">, </span><span class="s2">before</span><span class="s3">, </span><span class="s2">after</span><span class="s3">, </span><span class="s2">beforeEach</span><span class="s3">, </span><span class="s2">afterEach</span><span class="s3">, </span><span class="s2">mock</span><span class="s3">, </span><span class="s2">skip</span><span class="s3">, </span><span class="s2">only</span><span class="s3">, </span><span class="s2">todo </span><span class="s3">};</span>
<span class="s3">}</span>

<span class="s1">interface </span><span class="s2">DiagnosticData </span><span class="s3">{</span>
    <span class="s0">/**</span>
     <span class="s0">* The diagnostic message. 
     */</span>
    <span class="s3">message</span><span class="s1">: </span><span class="s2">string</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The nesting level of the test. 
     */</span>
    <span class="s3">nesting</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The path of the test file, undefined if test is not ran through a file. 
     */</span>
    <span class="s3">file</span><span class="s1">?: </span><span class="s2">string</span><span class="s3">;</span>
<span class="s3">}</span>
<span class="s1">interface </span><span class="s2">TestFail </span><span class="s3">{</span>
    <span class="s0">/**</span>
     <span class="s0">* Additional execution metadata. 
     */</span>
    <span class="s3">details</span><span class="s1">: </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* The duration of the test in milliseconds. 
         */</span>
        <span class="s3">duration</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The error thrown by the test. 
         */</span>
        <span class="s3">error</span><span class="s1">: </span><span class="s2">Error</span><span class="s3">;</span>
    <span class="s3">};</span>
    <span class="s0">/**</span>
     <span class="s0">* The test name. 
     */</span>
    <span class="s3">name</span><span class="s1">: </span><span class="s2">string</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The nesting level of the test. 
     */</span>
    <span class="s3">nesting</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The ordinal number of the test. 
     */</span>
    <span class="s3">testNumber</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Present if `context.todo` is called. 
     */</span>
    <span class="s3">todo</span><span class="s1">?: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">boolean</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Present if `context.skip` is called. 
     */</span>
    <span class="s3">skip</span><span class="s1">?: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">boolean</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The path of the test file, undefined if test is not ran through a file. 
     */</span>
    <span class="s3">file</span><span class="s1">?: </span><span class="s2">string</span><span class="s3">;</span>
<span class="s3">}</span>
<span class="s1">interface </span><span class="s2">TestPass </span><span class="s3">{</span>
    <span class="s0">/**</span>
     <span class="s0">* Additional execution metadata. 
     */</span>
    <span class="s3">details</span><span class="s1">: </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* The duration of the test in milliseconds. 
         */</span>
        <span class="s3">duration</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
    <span class="s3">};</span>
    <span class="s0">/**</span>
     <span class="s0">* The test name. 
     */</span>
    <span class="s3">name</span><span class="s1">: </span><span class="s2">string</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The nesting level of the test. 
     */</span>
    <span class="s3">nesting</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The ordinal number of the test. 
     */</span>
    <span class="s3">testNumber</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Present if `context.todo` is called. 
     */</span>
    <span class="s3">todo</span><span class="s1">?: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">boolean</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Present if `context.skip` is called. 
     */</span>
    <span class="s3">skip</span><span class="s1">?: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">boolean</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The path of the test file, undefined if test is not ran through a file. 
     */</span>
    <span class="s3">file</span><span class="s1">?: </span><span class="s2">string</span><span class="s3">;</span>
<span class="s3">}</span>
<span class="s1">interface </span><span class="s2">TestPlan </span><span class="s3">{</span>
    <span class="s0">/**</span>
     <span class="s0">* The nesting level of the test. 
     */</span>
    <span class="s3">nesting</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The number of subtests that have ran. 
     */</span>
    <span class="s3">count</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The path of the test file, undefined if test is not ran through a file. 
     */</span>
    <span class="s3">file</span><span class="s1">?: </span><span class="s2">string</span><span class="s3">;</span>
<span class="s3">}</span>
<span class="s1">interface </span><span class="s2">TestStart </span><span class="s3">{</span>
    <span class="s0">/**</span>
     <span class="s0">* The test name. 
     */</span>
    <span class="s3">name</span><span class="s1">: </span><span class="s2">string</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The nesting level of the test. 
     */</span>
    <span class="s3">nesting</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The path of the test file, undefined if test is not ran through a file. 
     */</span>
    <span class="s3">file</span><span class="s1">?: </span><span class="s2">string</span><span class="s3">;</span>
<span class="s3">}</span>
<span class="s1">interface </span><span class="s2">TestStderr </span><span class="s3">{</span>
    <span class="s0">/**</span>
     <span class="s0">* The path of the test file, undefined if test is not ran through a file. 
     */</span>
    <span class="s3">file</span><span class="s1">?: </span><span class="s2">string</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The message written to `stderr` 
     */</span>
    <span class="s3">message</span><span class="s1">: </span><span class="s2">string</span><span class="s3">;</span>
<span class="s3">}</span>
<span class="s1">interface </span><span class="s2">TestStdout </span><span class="s3">{</span>
    <span class="s0">/**</span>
     <span class="s0">* The path of the test file, undefined if test is not ran through a file. 
     */</span>
    <span class="s3">file</span><span class="s1">?: </span><span class="s2">string</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The message written to `stdout` 
     */</span>
    <span class="s3">message</span><span class="s1">: </span><span class="s2">string</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">/**</span>
 <span class="s0">* The `node:test/reporters` module exposes the builtin-reporters for `node:test`. 
 * To access it: 
 * 
 * ```js 
 * import test from 'node:test/reporters'; 
 * ``` 
 * 
 * This module is only available under the `node:` scheme. The following will not 
 * work: 
 * 
 * ```js 
 * import test from 'test/reporters'; 
 * ``` 
 * </span><span class="s1">@since </span><span class="s0">v19.9.0 
 * </span><span class="s1">@see </span><span class="s2">[source](https:</span><span class="s0">//github.com/nodejs/node/blob/v20.2.0/lib/test/reporters.js) 
 */</span>
<span class="s1">declare module </span><span class="s4">'node:test/reporters' </span><span class="s3">{</span>
    <span class="s1">import </span><span class="s3">{ </span><span class="s2">Transform </span><span class="s3">} </span><span class="s1">from </span><span class="s4">'node:stream'</span><span class="s3">;</span>

    <span class="s1">type </span><span class="s2">TestEvent </span><span class="s1">=</span>
        <span class="s1">| </span><span class="s3">{ type</span><span class="s1">: </span><span class="s4">'test:diagnostic'</span><span class="s3">, data</span><span class="s1">: </span><span class="s2">DiagnosticData </span><span class="s3">}</span>
        <span class="s1">| </span><span class="s3">{ type</span><span class="s1">: </span><span class="s4">'test:fail'</span><span class="s3">, data</span><span class="s1">: </span><span class="s2">TestFail </span><span class="s3">}</span>
        <span class="s1">| </span><span class="s3">{ type</span><span class="s1">: </span><span class="s4">'test:pass'</span><span class="s3">, data</span><span class="s1">: </span><span class="s2">TestPass </span><span class="s3">}</span>
        <span class="s1">| </span><span class="s3">{ type</span><span class="s1">: </span><span class="s4">'test:plan'</span><span class="s3">, data</span><span class="s1">: </span><span class="s2">TestPlan </span><span class="s3">}</span>
        <span class="s1">| </span><span class="s3">{ type</span><span class="s1">: </span><span class="s4">'test:start'</span><span class="s3">, data</span><span class="s1">: </span><span class="s2">TestStart </span><span class="s3">}</span>
        <span class="s1">| </span><span class="s3">{ type</span><span class="s1">: </span><span class="s4">'test:stderr'</span><span class="s3">, data</span><span class="s1">: </span><span class="s2">TestStderr </span><span class="s3">}</span>
        <span class="s1">| </span><span class="s3">{ type</span><span class="s1">: </span><span class="s4">'test:stdout'</span><span class="s3">, data</span><span class="s1">: </span><span class="s2">TestStdout </span><span class="s3">};</span>
    <span class="s1">type </span><span class="s2">TestEventGenerator </span><span class="s1">= </span><span class="s2">AsyncGenerator</span><span class="s3">&lt;</span><span class="s2">TestEvent</span><span class="s3">, </span><span class="s2">void</span><span class="s3">&gt;;</span>

    <span class="s0">/**</span>
     <span class="s0">* The `dot` reporter outputs the test results in a compact format, 
     * where each passing test is represented by a `.`, 
     * and each failing test is represented by a `X`. 
     */</span>
    <span class="s1">function </span><span class="s3">dot(</span><span class="s2">source</span><span class="s1">: </span><span class="s2">TestEventGenerator</span><span class="s3">)</span><span class="s1">: </span><span class="s2">AsyncGenerator</span><span class="s3">&lt;</span><span class="s4">'</span><span class="s6">\n</span><span class="s4">' </span><span class="s1">| </span><span class="s4">'.' </span><span class="s1">| </span><span class="s4">'X'</span><span class="s3">, </span><span class="s2">void</span><span class="s3">&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* The `tap` reporter outputs the test results in the [TAP](https://testanything.org/) format. 
     */</span>
    <span class="s1">function </span><span class="s3">tap(</span><span class="s2">source</span><span class="s1">: </span><span class="s2">TestEventGenerator</span><span class="s3">)</span><span class="s1">: </span><span class="s2">AsyncGenerator</span><span class="s3">&lt;</span><span class="s2">string</span><span class="s3">, </span><span class="s2">void</span><span class="s3">&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* The `spec` reporter outputs the test results in a human-readable format. 
     */</span>
    <span class="s1">class </span><span class="s2">Spec </span><span class="s1">extends </span><span class="s2">Transform </span><span class="s3">{</span>
        <span class="s1">constructor</span><span class="s3">();</span>
    <span class="s3">}</span>
    <span class="s1">export </span><span class="s3">{ </span><span class="s2">dot</span><span class="s3">, </span><span class="s2">tap</span><span class="s3">, </span><span class="s2">Spec </span><span class="s1">as </span><span class="s2">spec </span><span class="s3">};</span>
<span class="s3">}</span>
</pre>
</body>
</html>
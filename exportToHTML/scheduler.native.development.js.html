<html>
<head>
<title>scheduler.native.development.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
scheduler.native.development.js</font>
</center></td></tr></table>
<pre><span class="s0">/** 
 * @license React 
 * scheduler.native.development.js 
 * 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>

<span class="s2">'use strict'</span><span class="s1">;</span>

<span class="s3">if </span><span class="s1">(process.env.NODE_ENV !== </span><span class="s2">&quot;production&quot;</span><span class="s1">) {</span>
  <span class="s1">(</span><span class="s3">function</span><span class="s1">() {</span>
<span class="s2">'use strict'</span><span class="s1">;</span>

<span class="s3">var </span><span class="s1">enableSchedulerDebugging = </span><span class="s3">false</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">enableProfiling = </span><span class="s3">false</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">frameYieldMs = </span><span class="s4">5</span><span class="s1">;</span>

<span class="s3">function </span><span class="s1">push(heap, node) {</span>
  <span class="s3">var </span><span class="s1">index = heap.length;</span>
  <span class="s1">heap.push(node);</span>
  <span class="s1">siftUp(heap, node, index);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">peek(heap) {</span>
  <span class="s3">return </span><span class="s1">heap.length === </span><span class="s4">0 </span><span class="s1">? </span><span class="s3">null </span><span class="s1">: heap[</span><span class="s4">0</span><span class="s1">];</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">pop(heap) {</span>
  <span class="s3">if </span><span class="s1">(heap.length === </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">first = heap[</span><span class="s4">0</span><span class="s1">];</span>
  <span class="s3">var </span><span class="s1">last = heap.pop();</span>

  <span class="s3">if </span><span class="s1">(last !== first) {</span>
    <span class="s1">heap[</span><span class="s4">0</span><span class="s1">] = last;</span>
    <span class="s1">siftDown(heap, last, </span><span class="s4">0</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">first;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">siftUp(heap, node, i) {</span>
  <span class="s3">var </span><span class="s1">index = i;</span>

  <span class="s3">while </span><span class="s1">(index &gt; </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">parentIndex = index - </span><span class="s4">1 </span><span class="s1">&gt;&gt;&gt; </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">parent = heap[parentIndex];</span>

    <span class="s3">if </span><span class="s1">(compare(parent, node) &gt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s0">// The parent is larger. Swap positions.</span>
      <span class="s1">heap[parentIndex] = node;</span>
      <span class="s1">heap[index] = parent;</span>
      <span class="s1">index = parentIndex;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s0">// The parent is smaller. Exit.</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">siftDown(heap, node, i) {</span>
  <span class="s3">var </span><span class="s1">index = i;</span>
  <span class="s3">var </span><span class="s1">length = heap.length;</span>
  <span class="s3">var </span><span class="s1">halfLength = length &gt;&gt;&gt; </span><span class="s4">1</span><span class="s1">;</span>

  <span class="s3">while </span><span class="s1">(index &lt; halfLength) {</span>
    <span class="s3">var </span><span class="s1">leftIndex = (index + </span><span class="s4">1</span><span class="s1">) * </span><span class="s4">2 </span><span class="s1">- </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">left = heap[leftIndex];</span>
    <span class="s3">var </span><span class="s1">rightIndex = leftIndex + </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">right = heap[rightIndex]; </span><span class="s0">// If the left or right node is smaller, swap with the smaller of those.</span>

    <span class="s3">if </span><span class="s1">(compare(left, node) &lt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(rightIndex &lt; length &amp;&amp; compare(right, left) &lt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">heap[index] = right;</span>
        <span class="s1">heap[rightIndex] = node;</span>
        <span class="s1">index = rightIndex;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">heap[index] = left;</span>
        <span class="s1">heap[leftIndex] = node;</span>
        <span class="s1">index = leftIndex;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(rightIndex &lt; length &amp;&amp; compare(right, node) &lt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s1">heap[index] = right;</span>
      <span class="s1">heap[rightIndex] = node;</span>
      <span class="s1">index = rightIndex;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s0">// Neither child is smaller. Exit.</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">compare(a, b) {</span>
  <span class="s0">// Compare sort index first, then task id.</span>
  <span class="s3">var </span><span class="s1">diff = a.sortIndex - b.sortIndex;</span>
  <span class="s3">return </span><span class="s1">diff !== </span><span class="s4">0 </span><span class="s1">? diff : a.id - b.id;</span>
<span class="s1">}</span>

<span class="s0">// TODO: Use symbols?</span>
<span class="s3">var </span><span class="s1">ImmediatePriority = </span><span class="s4">1</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">UserBlockingPriority = </span><span class="s4">2</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">NormalPriority = </span><span class="s4">3</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">LowPriority = </span><span class="s4">4</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">IdlePriority = </span><span class="s4">5</span><span class="s1">;</span>

<span class="s3">function </span><span class="s1">markTaskErrored(task, ms) {</span>
<span class="s1">}</span>

<span class="s0">/* eslint-disable no-var */</span>
<span class="s3">var </span><span class="s1">getCurrentTime;</span>
<span class="s3">var </span><span class="s1">hasPerformanceNow = </span><span class="s0">// $FlowFixMe[method-unbinding]</span>
<span class="s3">typeof </span><span class="s1">performance === </span><span class="s2">'object' </span><span class="s1">&amp;&amp; </span><span class="s3">typeof </span><span class="s1">performance.now === </span><span class="s2">'function'</span><span class="s1">;</span>

<span class="s3">if </span><span class="s1">(hasPerformanceNow) {</span>
  <span class="s3">var </span><span class="s1">localPerformance = performance;</span>

  <span class="s1">getCurrentTime = </span><span class="s3">function </span><span class="s1">() {</span>
    <span class="s3">return </span><span class="s1">localPerformance.now();</span>
  <span class="s1">};</span>
<span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
  <span class="s3">var </span><span class="s1">localDate = Date;</span>
  <span class="s3">var </span><span class="s1">initialTime = localDate.now();</span>

  <span class="s1">getCurrentTime = </span><span class="s3">function </span><span class="s1">() {</span>
    <span class="s3">return </span><span class="s1">localDate.now() - initialTime;</span>
  <span class="s1">};</span>
<span class="s1">} </span><span class="s0">// Max 31 bit integer. The max integer size in V8 for 32-bit systems.</span>
<span class="s0">// Math.pow(2, 30) - 1</span>
<span class="s0">// 0b111111111111111111111111111111</span>


<span class="s3">var </span><span class="s1">maxSigned31BitInt = </span><span class="s4">1073741823</span><span class="s1">; </span><span class="s0">// Times out immediately</span>

<span class="s3">var </span><span class="s1">IMMEDIATE_PRIORITY_TIMEOUT = -</span><span class="s4">1</span><span class="s1">; </span><span class="s0">// Eventually times out</span>

<span class="s3">var </span><span class="s1">USER_BLOCKING_PRIORITY_TIMEOUT = </span><span class="s4">250</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">NORMAL_PRIORITY_TIMEOUT = </span><span class="s4">5000</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">LOW_PRIORITY_TIMEOUT = </span><span class="s4">10000</span><span class="s1">; </span><span class="s0">// Never times out</span>

<span class="s3">var </span><span class="s1">IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt; </span><span class="s0">// Tasks are stored on a min heap</span>

<span class="s3">var </span><span class="s1">taskQueue = [];</span>
<span class="s3">var </span><span class="s1">timerQueue = []; </span><span class="s0">// Incrementing id counter. Used to maintain insertion order.</span>

<span class="s3">var </span><span class="s1">taskIdCounter = </span><span class="s4">1</span><span class="s1">; </span><span class="s0">// Pausing the scheduler is useful for debugging.</span>
<span class="s3">var </span><span class="s1">currentTask = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">currentPriorityLevel = NormalPriority; </span><span class="s0">// This is set while performing work, to prevent re-entrance.</span>

<span class="s3">var </span><span class="s1">isPerformingWork = </span><span class="s3">false</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">isHostCallbackScheduled = </span><span class="s3">false</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">isHostTimeoutScheduled = </span><span class="s3">false</span><span class="s1">; </span><span class="s0">// Capture local references to native APIs, in case a polyfill overrides them.</span>

<span class="s3">var </span><span class="s1">localSetTimeout = </span><span class="s3">typeof </span><span class="s1">setTimeout === </span><span class="s2">'function' </span><span class="s1">? setTimeout : </span><span class="s3">null</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">localClearTimeout = </span><span class="s3">typeof </span><span class="s1">clearTimeout === </span><span class="s2">'function' </span><span class="s1">? clearTimeout : </span><span class="s3">null</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">localSetImmediate = </span><span class="s3">typeof </span><span class="s1">setImmediate !== </span><span class="s2">'undefined' </span><span class="s1">? setImmediate : </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// IE and Node.js + jsdom</span>

<span class="s3">typeof </span><span class="s1">navigator !== </span><span class="s2">'undefined' </span><span class="s1">&amp;&amp; </span><span class="s0">// $FlowFixMe[prop-missing]</span>
<span class="s1">navigator.scheduling !== undefined &amp;&amp; </span><span class="s0">// $FlowFixMe[incompatible-type]</span>
<span class="s1">navigator.scheduling.isInputPending !== undefined ? navigator.scheduling.isInputPending.bind(navigator.scheduling) : </span><span class="s3">null</span><span class="s1">;</span>

<span class="s3">function </span><span class="s1">advanceTimers(currentTime) {</span>
  <span class="s0">// Check for tasks that are no longer delayed and add them to the queue.</span>
  <span class="s3">var </span><span class="s1">timer = peek(timerQueue);</span>

  <span class="s3">while </span><span class="s1">(timer !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">if </span><span class="s1">(timer.callback === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// Timer was cancelled.</span>
      <span class="s1">pop(timerQueue);</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(timer.startTime &lt;= currentTime) {</span>
      <span class="s0">// Timer fired. Transfer to the task queue.</span>
      <span class="s1">pop(timerQueue);</span>
      <span class="s1">timer.sortIndex = timer.expirationTime;</span>
      <span class="s1">push(taskQueue, timer);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s0">// Remaining timers are pending.</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">timer = peek(timerQueue);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">handleTimeout(currentTime) {</span>
  <span class="s1">isHostTimeoutScheduled = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s1">advanceTimers(currentTime);</span>

  <span class="s3">if </span><span class="s1">(!isHostCallbackScheduled) {</span>
    <span class="s3">if </span><span class="s1">(peek(taskQueue) !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">isHostCallbackScheduled = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">requestHostCallback(flushWork);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">var </span><span class="s1">firstTimer = peek(timerQueue);</span>

      <span class="s3">if </span><span class="s1">(firstTimer !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">flushWork(hasTimeRemaining, initialTime) {</span>


  <span class="s1">isHostCallbackScheduled = </span><span class="s3">false</span><span class="s1">;</span>

  <span class="s3">if </span><span class="s1">(isHostTimeoutScheduled) {</span>
    <span class="s0">// We scheduled a timeout but it's no longer needed. Cancel it.</span>
    <span class="s1">isHostTimeoutScheduled = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">cancelHostTimeout();</span>
  <span class="s1">}</span>

  <span class="s1">isPerformingWork = </span><span class="s3">true</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">previousPriorityLevel = currentPriorityLevel;</span>

  <span class="s3">try </span><span class="s1">{</span>
    <span class="s3">var </span><span class="s1">currentTime; </span><span class="s3">if </span><span class="s1">(enableProfiling) ; </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s0">// No catch in prod code path.</span>
      <span class="s3">return </span><span class="s1">workLoop(hasTimeRemaining, initialTime);</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
    <span class="s1">currentTask = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">currentPriorityLevel = previousPriorityLevel;</span>
    <span class="s1">isPerformingWork = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">workLoop(hasTimeRemaining, initialTime) {</span>
  <span class="s3">var </span><span class="s1">currentTime = initialTime;</span>
  <span class="s1">advanceTimers(currentTime);</span>
  <span class="s1">currentTask = peek(taskQueue);</span>

  <span class="s3">while </span><span class="s1">(currentTask !== </span><span class="s3">null </span><span class="s1">&amp;&amp; !(enableSchedulerDebugging )) {</span>
    <span class="s3">if </span><span class="s1">(currentTask.expirationTime &gt; currentTime &amp;&amp; (!hasTimeRemaining || shouldYieldToHost())) {</span>
      <span class="s0">// This currentTask hasn't expired, and we've reached the deadline.</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s0">// $FlowFixMe[incompatible-use] found when upgrading Flow</span>


    <span class="s3">var </span><span class="s1">callback = currentTask.callback;</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">callback === </span><span class="s2">'function'</span><span class="s1">) {</span>
      <span class="s0">// $FlowFixMe[incompatible-use] found when upgrading Flow</span>
      <span class="s1">currentTask.callback = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// $FlowFixMe[incompatible-use] found when upgrading Flow</span>

      <span class="s1">currentPriorityLevel = currentTask.priorityLevel; </span><span class="s0">// $FlowFixMe[incompatible-use] found when upgrading Flow</span>

      <span class="s3">var </span><span class="s1">didUserCallbackTimeout = currentTask.expirationTime &lt;= currentTime;</span>

      <span class="s3">var </span><span class="s1">continuationCallback = callback(didUserCallbackTimeout);</span>
      <span class="s1">currentTime = getCurrentTime();</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">continuationCallback === </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s0">// If a continuation is returned, immediately yield to the main thread</span>
        <span class="s0">// regardless of how much time is left in the current time slice.</span>
        <span class="s0">// $FlowFixMe[incompatible-use] found when upgrading Flow</span>
        <span class="s1">currentTask.callback = continuationCallback;</span>

        <span class="s1">advanceTimers(currentTime);</span>
        <span class="s3">return true</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>

        <span class="s3">if </span><span class="s1">(currentTask === peek(taskQueue)) {</span>
          <span class="s1">pop(taskQueue);</span>
        <span class="s1">}</span>

        <span class="s1">advanceTimers(currentTime);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">pop(taskQueue);</span>
    <span class="s1">}</span>

    <span class="s1">currentTask = peek(taskQueue);</span>
  <span class="s1">} </span><span class="s0">// Return whether there's additional work</span>


  <span class="s3">if </span><span class="s1">(currentTask !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">return true</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s3">var </span><span class="s1">firstTimer = peek(timerQueue);</span>

    <span class="s3">if </span><span class="s1">(firstTimer !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);</span>
    <span class="s1">}</span>

    <span class="s3">return false</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">unstable_scheduleCallback$1(priorityLevel, callback, options) {</span>
  <span class="s3">var </span><span class="s1">currentTime = getCurrentTime();</span>
  <span class="s3">var </span><span class="s1">startTime;</span>

  <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">options === </span><span class="s2">'object' </span><span class="s1">&amp;&amp; options !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">delay = options.delay;</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">delay === </span><span class="s2">'number' </span><span class="s1">&amp;&amp; delay &gt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s1">startTime = currentTime + delay;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">startTime = currentTime;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">startTime = currentTime;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">timeout;</span>

  <span class="s3">switch </span><span class="s1">(priorityLevel) {</span>
    <span class="s3">case </span><span class="s1">ImmediatePriority:</span>
      <span class="s1">timeout = IMMEDIATE_PRIORITY_TIMEOUT;</span>
      <span class="s3">break</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s1">UserBlockingPriority:</span>
      <span class="s1">timeout = USER_BLOCKING_PRIORITY_TIMEOUT;</span>
      <span class="s3">break</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s1">IdlePriority:</span>
      <span class="s1">timeout = IDLE_PRIORITY_TIMEOUT;</span>
      <span class="s3">break</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s1">LowPriority:</span>
      <span class="s1">timeout = LOW_PRIORITY_TIMEOUT;</span>
      <span class="s3">break</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s1">NormalPriority:</span>
    <span class="s3">default</span><span class="s1">:</span>
      <span class="s1">timeout = NORMAL_PRIORITY_TIMEOUT;</span>
      <span class="s3">break</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">expirationTime = startTime + timeout;</span>
  <span class="s3">var </span><span class="s1">newTask = {</span>
    <span class="s1">id: taskIdCounter++,</span>
    <span class="s1">callback: callback,</span>
    <span class="s1">priorityLevel: priorityLevel,</span>
    <span class="s1">startTime: startTime,</span>
    <span class="s1">expirationTime: expirationTime,</span>
    <span class="s1">sortIndex: -</span><span class="s4">1</span>
  <span class="s1">};</span>

  <span class="s3">if </span><span class="s1">(startTime &gt; currentTime) {</span>
    <span class="s0">// This is a delayed task.</span>
    <span class="s1">newTask.sortIndex = startTime;</span>
    <span class="s1">push(timerQueue, newTask);</span>

    <span class="s3">if </span><span class="s1">(peek(taskQueue) === </span><span class="s3">null </span><span class="s1">&amp;&amp; newTask === peek(timerQueue)) {</span>
      <span class="s0">// All tasks are delayed, and this is the task with the earliest delay.</span>
      <span class="s3">if </span><span class="s1">(isHostTimeoutScheduled) {</span>
        <span class="s0">// Cancel an existing timeout.</span>
        <span class="s1">cancelHostTimeout();</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">isHostTimeoutScheduled = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// Schedule a timeout.</span>


      <span class="s1">requestHostTimeout(handleTimeout, startTime - currentTime);</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">newTask.sortIndex = expirationTime;</span>
    <span class="s1">push(taskQueue, newTask);</span>
    <span class="s0">// wait until the next time we yield.</span>


    <span class="s3">if </span><span class="s1">(!isHostCallbackScheduled &amp;&amp; !isPerformingWork) {</span>
      <span class="s1">isHostCallbackScheduled = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">requestHostCallback(flushWork);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">newTask;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">unstable_cancelCallback$1(task) {</span>
  <span class="s0">// remove from the queue because you can't remove arbitrary nodes from an</span>
  <span class="s0">// array based heap, only the first one.)</span>


  <span class="s1">task.callback = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">unstable_getCurrentPriorityLevel$1() {</span>
  <span class="s3">return </span><span class="s1">currentPriorityLevel;</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">isMessageLoopRunning = </span><span class="s3">false</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">scheduledHostCallback = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">taskTimeoutID = -</span><span class="s4">1</span><span class="s1">; </span><span class="s0">// Scheduler periodically yields in case there is other work on the main</span>
<span class="s0">// thread, like user events. By default, it yields multiple times per frame.</span>
<span class="s0">// It does not attempt to align with frame boundaries, since most tasks don't</span>
<span class="s0">// need to be frame aligned; for those that do, use requestAnimationFrame.</span>

<span class="s3">var </span><span class="s1">frameInterval = frameYieldMs;</span>
<span class="s3">var </span><span class="s1">startTime = -</span><span class="s4">1</span><span class="s1">;</span>

<span class="s3">function </span><span class="s1">shouldYieldToHost() {</span>
  <span class="s3">var </span><span class="s1">timeElapsed = getCurrentTime() - startTime;</span>

  <span class="s3">if </span><span class="s1">(timeElapsed &lt; frameInterval) {</span>
    <span class="s0">// The main thread has only been blocked for a really short amount of time;</span>
    <span class="s0">// smaller than a single frame. Don't yield yet.</span>
    <span class="s3">return false</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s0">// The main thread has been blocked for a non-negligible amount of time. We</span>


  <span class="s3">return true</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">requestPaint() {</span>

<span class="s1">}</span>

<span class="s3">var </span><span class="s1">performWorkUntilDeadline = </span><span class="s3">function </span><span class="s1">() {</span>
  <span class="s3">if </span><span class="s1">(scheduledHostCallback !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">currentTime = getCurrentTime(); </span><span class="s0">// Keep track of the start time so we can measure how long the main thread</span>
    <span class="s0">// has been blocked.</span>

    <span class="s1">startTime = currentTime;</span>
    <span class="s3">var </span><span class="s1">hasTimeRemaining = </span><span class="s3">true</span><span class="s1">; </span><span class="s0">// If a scheduler task throws, exit the current browser task so the</span>
    <span class="s0">// error can be observed.</span>
    <span class="s0">//</span>
    <span class="s0">// Intentionally not using a try-catch, since that makes some debugging</span>
    <span class="s0">// techniques harder. Instead, if `scheduledHostCallback` errors, then</span>
    <span class="s0">// `hasMoreWork` will remain true, and we'll continue the work loop.</span>

    <span class="s3">var </span><span class="s1">hasMoreWork = </span><span class="s3">true</span><span class="s1">;</span>

    <span class="s3">try </span><span class="s1">{</span>
      <span class="s0">// $FlowFixMe[not-a-function] found when upgrading Flow</span>
      <span class="s1">hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);</span>
    <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(hasMoreWork) {</span>
        <span class="s0">// If there's more work, schedule the next message event at the end</span>
        <span class="s0">// of the preceding one.</span>
        <span class="s1">schedulePerformWorkUntilDeadline();</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">isMessageLoopRunning = </span><span class="s3">false</span><span class="s1">;</span>
        <span class="s1">scheduledHostCallback = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">isMessageLoopRunning = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s0">// Yielding to the browser will give it a chance to paint, so we can</span>
<span class="s1">};</span>

<span class="s3">var </span><span class="s1">schedulePerformWorkUntilDeadline;</span>

<span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">localSetImmediate === </span><span class="s2">'function'</span><span class="s1">) {</span>
  <span class="s0">// Node.js and old IE.</span>
  <span class="s0">// There's a few reasons for why we prefer setImmediate.</span>
  <span class="s0">//</span>
  <span class="s0">// Unlike MessageChannel, it doesn't prevent a Node.js process from exiting.</span>
  <span class="s0">// (Even though this is a DOM fork of the Scheduler, you could get here</span>
  <span class="s0">// with a mix of Node.js 15+, which has a MessageChannel, and jsdom.)</span>
  <span class="s0">// https://github.com/facebook/react/issues/20756</span>
  <span class="s0">//</span>
  <span class="s0">// But also, it runs earlier which is the semantic we want.</span>
  <span class="s0">// If other browsers ever implement it, it's better to use it.</span>
  <span class="s0">// Although both of these would be inferior to native scheduling.</span>
  <span class="s1">schedulePerformWorkUntilDeadline = </span><span class="s3">function </span><span class="s1">() {</span>
    <span class="s1">localSetImmediate(performWorkUntilDeadline);</span>
  <span class="s1">};</span>
<span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">MessageChannel !== </span><span class="s2">'undefined'</span><span class="s1">) {</span>
  <span class="s0">// DOM and Worker environments.</span>
  <span class="s0">// We prefer MessageChannel because of the 4ms setTimeout clamping.</span>
  <span class="s3">var </span><span class="s1">channel = </span><span class="s3">new </span><span class="s1">MessageChannel();</span>
  <span class="s3">var </span><span class="s1">port = channel.port2;</span>
  <span class="s1">channel.port1.onmessage = performWorkUntilDeadline;</span>

  <span class="s1">schedulePerformWorkUntilDeadline = </span><span class="s3">function </span><span class="s1">() {</span>
    <span class="s1">port.postMessage(</span><span class="s3">null</span><span class="s1">);</span>
  <span class="s1">};</span>
<span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
  <span class="s0">// We should only fallback here in non-browser environments.</span>
  <span class="s1">schedulePerformWorkUntilDeadline = </span><span class="s3">function </span><span class="s1">() {</span>
    <span class="s0">// $FlowFixMe[not-a-function] nullable value</span>
    <span class="s1">localSetTimeout(performWorkUntilDeadline, </span><span class="s4">0</span><span class="s1">);</span>
  <span class="s1">};</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">requestHostCallback(callback) {</span>
  <span class="s1">scheduledHostCallback = callback;</span>

  <span class="s3">if </span><span class="s1">(!isMessageLoopRunning) {</span>
    <span class="s1">isMessageLoopRunning = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">schedulePerformWorkUntilDeadline();</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">requestHostTimeout(callback, ms) {</span>
  <span class="s0">// $FlowFixMe[not-a-function] nullable value</span>
  <span class="s1">taskTimeoutID = localSetTimeout(</span><span class="s3">function </span><span class="s1">() {</span>
    <span class="s1">callback(getCurrentTime());</span>
  <span class="s1">}, ms);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">cancelHostTimeout() {</span>
  <span class="s0">// $FlowFixMe[not-a-function] nullable value</span>
  <span class="s1">localClearTimeout(taskTimeoutID);</span>
  <span class="s1">taskTimeoutID = -</span><span class="s4">1</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">// https://github.com/facebook/react-native/blob/main/packages/react-native/ReactCommon/react/renderer/runtimescheduler/RuntimeSchedulerBinding.cpp</span>

<span class="s3">var </span><span class="s1">unstable_UserBlockingPriority = </span><span class="s3">typeof </span><span class="s1">nativeRuntimeScheduler !== </span><span class="s2">'undefined' </span><span class="s1">? nativeRuntimeScheduler.unstable_UserBlockingPriority : UserBlockingPriority;</span>
<span class="s3">var </span><span class="s1">unstable_NormalPriority = </span><span class="s3">typeof </span><span class="s1">nativeRuntimeScheduler !== </span><span class="s2">'undefined' </span><span class="s1">? nativeRuntimeScheduler.unstable_NormalPriority : NormalPriority;</span>
<span class="s3">var </span><span class="s1">unstable_IdlePriority = </span><span class="s3">typeof </span><span class="s1">nativeRuntimeScheduler !== </span><span class="s2">'undefined' </span><span class="s1">? nativeRuntimeScheduler.unstable_IdlePriority : IdlePriority;</span>
<span class="s3">var </span><span class="s1">unstable_LowPriority = </span><span class="s3">typeof </span><span class="s1">nativeRuntimeScheduler !== </span><span class="s2">'undefined' </span><span class="s1">? nativeRuntimeScheduler.unstable_LowPriority : LowPriority;</span>
<span class="s3">var </span><span class="s1">unstable_ImmediatePriority = </span><span class="s3">typeof </span><span class="s1">nativeRuntimeScheduler !== </span><span class="s2">'undefined' </span><span class="s1">? nativeRuntimeScheduler.unstable_ImmediatePriority : ImmediatePriority;</span>
<span class="s3">var </span><span class="s1">unstable_scheduleCallback = </span><span class="s3">typeof </span><span class="s1">nativeRuntimeScheduler !== </span><span class="s2">'undefined' </span><span class="s1">? nativeRuntimeScheduler.unstable_scheduleCallback : unstable_scheduleCallback$1;</span>
<span class="s3">var </span><span class="s1">unstable_cancelCallback = </span><span class="s3">typeof </span><span class="s1">nativeRuntimeScheduler !== </span><span class="s2">'undefined' </span><span class="s1">? nativeRuntimeScheduler.unstable_cancelCallback : unstable_cancelCallback$1;</span>
<span class="s3">var </span><span class="s1">unstable_getCurrentPriorityLevel = </span><span class="s3">typeof </span><span class="s1">nativeRuntimeScheduler !== </span><span class="s2">'undefined' </span><span class="s1">? nativeRuntimeScheduler.unstable_getCurrentPriorityLevel : unstable_getCurrentPriorityLevel$1;</span>
<span class="s3">var </span><span class="s1">unstable_shouldYield = </span><span class="s3">typeof </span><span class="s1">nativeRuntimeScheduler !== </span><span class="s2">'undefined' </span><span class="s1">? nativeRuntimeScheduler.unstable_shouldYield : shouldYieldToHost;</span>
<span class="s3">var </span><span class="s1">unstable_requestPaint = </span><span class="s3">typeof </span><span class="s1">nativeRuntimeScheduler !== </span><span class="s2">'undefined' </span><span class="s1">? nativeRuntimeScheduler.unstable_requestPaint : requestPaint;</span>
<span class="s3">var </span><span class="s1">unstable_now = </span><span class="s3">typeof </span><span class="s1">nativeRuntimeScheduler !== </span><span class="s2">'undefined' </span><span class="s1">? nativeRuntimeScheduler.unstable_now : getCurrentTime; </span><span class="s0">// These were never implemented on the native scheduler because React never calls them.</span>
<span class="s0">// For consistency, let's disable them altogether and make them throw.</span>

<span class="s3">var </span><span class="s1">unstable_next = throwNotImplemented;</span>
<span class="s3">var </span><span class="s1">unstable_runWithPriority = throwNotImplemented;</span>
<span class="s3">var </span><span class="s1">unstable_wrapCallback = throwNotImplemented;</span>
<span class="s3">var </span><span class="s1">unstable_continueExecution = throwNotImplemented;</span>
<span class="s3">var </span><span class="s1">unstable_pauseExecution = throwNotImplemented;</span>
<span class="s3">var </span><span class="s1">unstable_getFirstCallbackNode = throwNotImplemented;</span>
<span class="s3">var </span><span class="s1">unstable_forceFrameRate = throwNotImplemented;</span>
<span class="s3">var </span><span class="s1">unstable_Profiling = </span><span class="s3">null</span><span class="s1">;</span>

<span class="s3">function </span><span class="s1">throwNotImplemented() {</span>
  <span class="s3">throw </span><span class="s1">Error(</span><span class="s2">'Not implemented.'</span><span class="s1">);</span>
<span class="s1">} </span><span class="s0">// Flow magic to verify the exports of this file match the original version.</span>

<span class="s1">exports.unstable_IdlePriority = unstable_IdlePriority;</span>
<span class="s1">exports.unstable_ImmediatePriority = unstable_ImmediatePriority;</span>
<span class="s1">exports.unstable_LowPriority = unstable_LowPriority;</span>
<span class="s1">exports.unstable_NormalPriority = unstable_NormalPriority;</span>
<span class="s1">exports.unstable_Profiling = unstable_Profiling;</span>
<span class="s1">exports.unstable_UserBlockingPriority = unstable_UserBlockingPriority;</span>
<span class="s1">exports.unstable_cancelCallback = unstable_cancelCallback;</span>
<span class="s1">exports.unstable_continueExecution = unstable_continueExecution;</span>
<span class="s1">exports.unstable_forceFrameRate = unstable_forceFrameRate;</span>
<span class="s1">exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;</span>
<span class="s1">exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;</span>
<span class="s1">exports.unstable_next = unstable_next;</span>
<span class="s1">exports.unstable_now = unstable_now;</span>
<span class="s1">exports.unstable_pauseExecution = unstable_pauseExecution;</span>
<span class="s1">exports.unstable_requestPaint = unstable_requestPaint;</span>
<span class="s1">exports.unstable_runWithPriority = unstable_runWithPriority;</span>
<span class="s1">exports.unstable_scheduleCallback = unstable_scheduleCallback;</span>
<span class="s1">exports.unstable_shouldYield = unstable_shouldYield;</span>
<span class="s1">exports.unstable_wrapCallback = unstable_wrapCallback;</span>
  <span class="s1">})();</span>
<span class="s1">}</span>
</pre>
</body>
</html>
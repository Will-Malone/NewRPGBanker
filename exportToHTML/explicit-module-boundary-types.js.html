<html>
<head>
<title>explicit-module-boundary-types.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6a8759;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #4646f1;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
explicit-module-boundary-types.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s2">var </span><span class="s1">__createBinding = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__createBinding) || (Object.create ? (</span><span class="s2">function</span><span class="s1">(o, m, k, k2) {</span>
    <span class="s2">if </span><span class="s1">(k2 === undefined) k2 = k;</span>
    <span class="s2">var </span><span class="s1">desc = Object.getOwnPropertyDescriptor(m, k);</span>
    <span class="s2">if </span><span class="s1">(!desc || (</span><span class="s0">&quot;get&quot; </span><span class="s2">in </span><span class="s1">desc ? !m.__esModule : desc.writable || desc.configurable)) {</span>
      <span class="s1">desc = { enumerable: </span><span class="s2">true</span><span class="s1">, get: </span><span class="s2">function</span><span class="s1">() { </span><span class="s2">return </span><span class="s1">m[k]; } };</span>
    <span class="s1">}</span>
    <span class="s1">Object.defineProperty(o, k2, desc);</span>
<span class="s1">}) : (</span><span class="s2">function</span><span class="s1">(o, m, k, k2) {</span>
    <span class="s2">if </span><span class="s1">(k2 === undefined) k2 = k;</span>
    <span class="s1">o[k2] = m[k];</span>
<span class="s1">}));</span>
<span class="s2">var </span><span class="s1">__setModuleDefault = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__setModuleDefault) || (Object.create ? (</span><span class="s2">function</span><span class="s1">(o, v) {</span>
    <span class="s1">Object.defineProperty(o, </span><span class="s0">&quot;default&quot;</span><span class="s1">, { enumerable: </span><span class="s2">true</span><span class="s1">, value: v });</span>
<span class="s1">}) : </span><span class="s2">function</span><span class="s1">(o, v) {</span>
    <span class="s1">o[</span><span class="s0">&quot;default&quot;</span><span class="s1">] = v;</span>
<span class="s1">});</span>
<span class="s2">var </span><span class="s1">__importStar = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__importStar) || </span><span class="s2">function </span><span class="s1">(mod) {</span>
    <span class="s2">if </span><span class="s1">(mod &amp;&amp; mod.__esModule) </span><span class="s2">return </span><span class="s1">mod;</span>
    <span class="s2">var </span><span class="s1">result = {};</span>
    <span class="s2">if </span><span class="s1">(mod != </span><span class="s2">null</span><span class="s1">) </span><span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">k </span><span class="s2">in </span><span class="s1">mod) </span><span class="s2">if </span><span class="s1">(k !== </span><span class="s0">&quot;default&quot; </span><span class="s1">&amp;&amp; Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);</span>
    <span class="s1">__setModuleDefault(result, mod);</span>
    <span class="s2">return </span><span class="s1">result;</span>
<span class="s1">};</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, { value: </span><span class="s2">true </span><span class="s1">});</span>
<span class="s1">const scope_manager_1 = require(</span><span class="s0">&quot;@typescript-eslint/scope-manager&quot;</span><span class="s1">);</span>
<span class="s1">const utils_1 = require(</span><span class="s0">&quot;@typescript-eslint/utils&quot;</span><span class="s1">);</span>
<span class="s1">const util = __importStar(require(</span><span class="s0">&quot;../util&quot;</span><span class="s1">));</span>
<span class="s1">const explicitReturnTypeUtils_1 = require(</span><span class="s0">&quot;../util/explicitReturnTypeUtils&quot;</span><span class="s1">);</span>
<span class="s1">exports.</span><span class="s2">default </span><span class="s1">= util.createRule({</span>
    <span class="s1">name: </span><span class="s0">'explicit-module-boundary-types'</span><span class="s1">,</span>
    <span class="s1">meta: {</span>
        <span class="s1">type: </span><span class="s0">'problem'</span><span class="s1">,</span>
        <span class="s1">docs: {</span>
            <span class="s1">description: </span><span class="s0">&quot;Require explicit return and argument types on exported functions' and classes' public class methods&quot;</span><span class="s1">,</span>
            <span class="s1">recommended: </span><span class="s2">false</span><span class="s1">,</span>
        <span class="s1">},</span>
        <span class="s1">messages: {</span>
            <span class="s1">missingReturnType: </span><span class="s0">'Missing return type on function.'</span><span class="s1">,</span>
            <span class="s1">missingArgType: </span><span class="s0">&quot;Argument '{{name}}' should be typed.&quot;</span><span class="s1">,</span>
            <span class="s1">missingArgTypeUnnamed: </span><span class="s0">'{{type}} argument should be typed.'</span><span class="s1">,</span>
            <span class="s1">anyTypedArg: </span><span class="s0">&quot;Argument '{{name}}' should be typed with a non-any type.&quot;</span><span class="s1">,</span>
            <span class="s1">anyTypedArgUnnamed: </span><span class="s0">'{{type}} argument should be typed with a non-any type.'</span><span class="s1">,</span>
        <span class="s1">},</span>
        <span class="s1">schema: [</span>
            <span class="s1">{</span>
                <span class="s1">type: </span><span class="s0">'object'</span><span class="s1">,</span>
                <span class="s1">properties: {</span>
                    <span class="s1">allowArgumentsExplicitlyTypedAsAny: {</span>
                        <span class="s1">description: </span><span class="s0">'Whether to ignore arguments that are explicitly typed as `any`.'</span><span class="s1">,</span>
                        <span class="s1">type: </span><span class="s0">'boolean'</span><span class="s1">,</span>
                    <span class="s1">},</span>
                    <span class="s1">allowDirectConstAssertionInArrowFunctions: {</span>
                        <span class="s1">description: [</span>
                            <span class="s0">'Whether to ignore return type annotations on body-less arrow functions that return an `as const` type assertion.'</span><span class="s1">,</span>
                            <span class="s0">'You must still type the parameters of the function.'</span><span class="s1">,</span>
                        <span class="s1">].join(</span><span class="s0">'</span><span class="s3">\n</span><span class="s0">'</span><span class="s1">),</span>
                        <span class="s1">type: </span><span class="s0">'boolean'</span><span class="s1">,</span>
                    <span class="s1">},</span>
                    <span class="s1">allowedNames: {</span>
                        <span class="s1">description: </span><span class="s0">'An array of function/method names that will not have their arguments or return values checked.'</span><span class="s1">,</span>
                        <span class="s1">items: {</span>
                            <span class="s1">type: </span><span class="s0">'string'</span><span class="s1">,</span>
                        <span class="s1">},</span>
                        <span class="s1">type: </span><span class="s0">'array'</span><span class="s1">,</span>
                    <span class="s1">},</span>
                    <span class="s1">allowHigherOrderFunctions: {</span>
                        <span class="s1">description: [</span>
                            <span class="s0">'Whether to ignore return type annotations on functions immediately returning another function expression.'</span><span class="s1">,</span>
                            <span class="s0">'You must still type the parameters of the function.'</span><span class="s1">,</span>
                        <span class="s1">].join(</span><span class="s0">'</span><span class="s3">\n</span><span class="s0">'</span><span class="s1">),</span>
                        <span class="s1">type: </span><span class="s0">'boolean'</span><span class="s1">,</span>
                    <span class="s1">},</span>
                    <span class="s1">allowTypedFunctionExpressions: {</span>
                        <span class="s1">description: </span><span class="s0">'Whether to ignore type annotations on the variable of a function expresion.'</span><span class="s1">,</span>
                        <span class="s1">type: </span><span class="s0">'boolean'</span><span class="s1">,</span>
                    <span class="s1">},</span>
                    <span class="s4">// DEPRECATED - To be removed in next major</span>
                    <span class="s1">shouldTrackReferences: {</span>
                        <span class="s1">type: </span><span class="s0">'boolean'</span><span class="s1">,</span>
                    <span class="s1">},</span>
                <span class="s1">},</span>
                <span class="s1">additionalProperties: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">},</span>
        <span class="s1">],</span>
    <span class="s1">},</span>
    <span class="s1">defaultOptions: [</span>
        <span class="s1">{</span>
            <span class="s1">allowArgumentsExplicitlyTypedAsAny: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">allowDirectConstAssertionInArrowFunctions: </span><span class="s2">true</span><span class="s1">,</span>
            <span class="s1">allowedNames: [],</span>
            <span class="s1">allowHigherOrderFunctions: </span><span class="s2">true</span><span class="s1">,</span>
            <span class="s1">allowTypedFunctionExpressions: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">},</span>
    <span class="s1">],</span>
    <span class="s1">create(context, [options]) {</span>
        <span class="s1">const sourceCode = context.getSourceCode();</span>
        <span class="s4">// tracks all of the functions we've already checked</span>
        <span class="s1">const checkedFunctions = </span><span class="s2">new </span><span class="s1">Set();</span>
        <span class="s4">// tracks functions that were found whilst traversing</span>
        <span class="s1">const foundFunctions = [];</span>
        <span class="s4">// all nodes visited, avoids infinite recursion for cyclic references</span>
        <span class="s4">// (such as class member referring to itself)</span>
        <span class="s1">const alreadyVisited = </span><span class="s2">new </span><span class="s1">Set();</span>
        <span class="s4">/* 
        # How the rule works: 
     
        As the rule traverses the AST, it immediately checks every single function that it finds is exported. 
        &quot;exported&quot; means that it is either directly exported, or that its name is exported. 
     
        It also collects a list of every single function it finds on the way, but does not check them. 
        After it's finished traversing the AST, it then iterates through the list of found functions, and checks to see if 
        any of them are part of a higher-order function 
        */</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">ExportDefaultDeclaration(node) {</span>
                <span class="s1">checkNode(node.declaration);</span>
            <span class="s1">},</span>
            <span class="s0">'ExportNamedDeclaration:not([source])'</span><span class="s1">(node) {</span>
                <span class="s2">if </span><span class="s1">(node.declaration) {</span>
                    <span class="s1">checkNode(node.declaration);</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s2">for </span><span class="s1">(const specifier of node.specifiers) {</span>
                        <span class="s1">followReference(specifier.local);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">},</span>
            <span class="s1">TSExportAssignment(node) {</span>
                <span class="s1">checkNode(node.expression);</span>
            <span class="s1">},</span>
            <span class="s0">'ArrowFunctionExpression, FunctionDeclaration, FunctionExpression'</span><span class="s1">(node) {</span>
                <span class="s1">foundFunctions.push(node);</span>
            <span class="s1">},</span>
            <span class="s0">'Program:exit'</span><span class="s1">() {</span>
                <span class="s2">for </span><span class="s1">(const func of foundFunctions) {</span>
                    <span class="s2">if </span><span class="s1">(isExportedHigherOrderFunction(func)) {</span>
                        <span class="s1">checkNode(func);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">},</span>
        <span class="s1">};</span>
        <span class="s2">function </span><span class="s1">checkParameters(node) {</span>
            <span class="s2">function </span><span class="s1">checkParameter(param) {</span>
                <span class="s2">function </span><span class="s1">report(namedMessageId, unnamedMessageId) {</span>
                    <span class="s2">if </span><span class="s1">(param.type === utils_1.AST_NODE_TYPES.Identifier) {</span>
                        <span class="s1">context.report({</span>
                            <span class="s1">node: param,</span>
                            <span class="s1">messageId: namedMessageId,</span>
                            <span class="s1">data: { name: param.name },</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                    <span class="s2">else if </span><span class="s1">(param.type === utils_1.AST_NODE_TYPES.ArrayPattern) {</span>
                        <span class="s1">context.report({</span>
                            <span class="s1">node: param,</span>
                            <span class="s1">messageId: unnamedMessageId,</span>
                            <span class="s1">data: { type: </span><span class="s0">'Array pattern' </span><span class="s1">},</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                    <span class="s2">else if </span><span class="s1">(param.type === utils_1.AST_NODE_TYPES.ObjectPattern) {</span>
                        <span class="s1">context.report({</span>
                            <span class="s1">node: param,</span>
                            <span class="s1">messageId: unnamedMessageId,</span>
                            <span class="s1">data: { type: </span><span class="s0">'Object pattern' </span><span class="s1">},</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                    <span class="s2">else if </span><span class="s1">(param.type === utils_1.AST_NODE_TYPES.RestElement) {</span>
                        <span class="s2">if </span><span class="s1">(param.argument.type === utils_1.AST_NODE_TYPES.Identifier) {</span>
                            <span class="s1">context.report({</span>
                                <span class="s1">node: param,</span>
                                <span class="s1">messageId: namedMessageId,</span>
                                <span class="s1">data: { name: param.argument.name },</span>
                            <span class="s1">});</span>
                        <span class="s1">}</span>
                        <span class="s2">else </span><span class="s1">{</span>
                            <span class="s1">context.report({</span>
                                <span class="s1">node: param,</span>
                                <span class="s1">messageId: unnamedMessageId,</span>
                                <span class="s1">data: { type: </span><span class="s0">'Rest' </span><span class="s1">},</span>
                            <span class="s1">});</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">switch </span><span class="s1">(param.type) {</span>
                    <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.ArrayPattern:</span>
                    <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.Identifier:</span>
                    <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.ObjectPattern:</span>
                    <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.RestElement:</span>
                        <span class="s2">if </span><span class="s1">(!param.typeAnnotation) {</span>
                            <span class="s1">report(</span><span class="s0">'missingArgType'</span><span class="s1">, </span><span class="s0">'missingArgTypeUnnamed'</span><span class="s1">);</span>
                        <span class="s1">}</span>
                        <span class="s2">else if </span><span class="s1">(options.allowArgumentsExplicitlyTypedAsAny !== </span><span class="s2">true </span><span class="s1">&amp;&amp;</span>
                            <span class="s1">param.typeAnnotation.typeAnnotation.type ===</span>
                                <span class="s1">utils_1.AST_NODE_TYPES.TSAnyKeyword) {</span>
                            <span class="s1">report(</span><span class="s0">'anyTypedArg'</span><span class="s1">, </span><span class="s0">'anyTypedArgUnnamed'</span><span class="s1">);</span>
                        <span class="s1">}</span>
                        <span class="s2">return</span><span class="s1">;</span>
                    <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSParameterProperty:</span>
                        <span class="s2">return </span><span class="s1">checkParameter(param.parameter);</span>
                    <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.AssignmentPattern: </span><span class="s4">// ignored as it has a type via its assignment</span>
                        <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">for </span><span class="s1">(const arg of node.params) {</span>
                <span class="s1">checkParameter(arg);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s4">/** 
         * Checks if a function name is allowed and should not be checked. 
         */</span>
        <span class="s2">function </span><span class="s1">isAllowedName(node) {</span>
            <span class="s2">var </span><span class="s1">_a;</span>
            <span class="s2">if </span><span class="s1">(!node || !options.allowedNames || !options.allowedNames.length) {</span>
                <span class="s2">return false</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(node.type === utils_1.AST_NODE_TYPES.VariableDeclarator ||</span>
                <span class="s1">node.type === utils_1.AST_NODE_TYPES.FunctionDeclaration) {</span>
                <span class="s2">return </span><span class="s1">(((_a = node.id) === </span><span class="s2">null </span><span class="s1">|| _a === </span><span class="s2">void </span><span class="s5">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s5">0 </span><span class="s1">: _a.type) === utils_1.AST_NODE_TYPES.Identifier &amp;&amp;</span>
                    <span class="s1">options.allowedNames.includes(node.id.name));</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(node.type === utils_1.AST_NODE_TYPES.MethodDefinition ||</span>
                <span class="s1">node.type === utils_1.AST_NODE_TYPES.TSAbstractMethodDefinition ||</span>
                <span class="s1">(node.type === utils_1.AST_NODE_TYPES.Property &amp;&amp; node.method) ||</span>
                <span class="s1">node.type === utils_1.AST_NODE_TYPES.PropertyDefinition) {</span>
                <span class="s2">if </span><span class="s1">(node.key.type === utils_1.AST_NODE_TYPES.Literal &amp;&amp;</span>
                    <span class="s2">typeof </span><span class="s1">node.key.value === </span><span class="s0">'string'</span><span class="s1">) {</span>
                    <span class="s2">return </span><span class="s1">options.allowedNames.includes(node.key.value);</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(node.key.type === utils_1.AST_NODE_TYPES.TemplateLiteral &amp;&amp;</span>
                    <span class="s1">node.key.expressions.length === </span><span class="s5">0</span><span class="s1">) {</span>
                    <span class="s2">return </span><span class="s1">options.allowedNames.includes(node.key.quasis[</span><span class="s5">0</span><span class="s1">].value.raw);</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(!node.computed &amp;&amp; node.key.type === utils_1.AST_NODE_TYPES.Identifier) {</span>
                    <span class="s2">return </span><span class="s1">options.allowedNames.includes(node.key.name);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">isExportedHigherOrderFunction(node) {</span>
            <span class="s2">var </span><span class="s1">_a;</span>
            <span class="s1">let current = node.parent;</span>
            <span class="s2">while </span><span class="s1">(current) {</span>
                <span class="s2">if </span><span class="s1">(current.type === utils_1.AST_NODE_TYPES.ReturnStatement) {</span>
                    <span class="s4">// the parent of a return will always be a block statement, so we can skip over it</span>
                    <span class="s1">current = (_a = current.parent) === </span><span class="s2">null </span><span class="s1">|| _a === </span><span class="s2">void </span><span class="s5">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s5">0 </span><span class="s1">: _a.parent;</span>
                    <span class="s2">continue</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(!util.isFunction(current) ||</span>
                    <span class="s1">!(</span><span class="s5">0</span><span class="s1">, explicitReturnTypeUtils_1.doesImmediatelyReturnFunctionExpression)(current)) {</span>
                    <span class="s2">return false</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(checkedFunctions.has(current)) {</span>
                    <span class="s2">return true</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s1">current = current.parent;</span>
            <span class="s1">}</span>
            <span class="s2">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">followReference(node) {</span>
            <span class="s1">const scope = context.getScope();</span>
            <span class="s1">const variable = scope.set.get(node.name);</span>
            <span class="s4">/* istanbul ignore if */ </span><span class="s2">if </span><span class="s1">(!variable) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s4">// check all of the definitions</span>
            <span class="s2">for </span><span class="s1">(const definition of variable.defs) {</span>
                <span class="s4">// cases we don't care about in this rule</span>
                <span class="s2">if </span><span class="s1">([</span>
                    <span class="s1">scope_manager_1.DefinitionType.ImplicitGlobalVariable,</span>
                    <span class="s1">scope_manager_1.DefinitionType.ImportBinding,</span>
                    <span class="s1">scope_manager_1.DefinitionType.CatchClause,</span>
                    <span class="s1">scope_manager_1.DefinitionType.Parameter,</span>
                <span class="s1">].includes(definition.type)) {</span>
                    <span class="s2">continue</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s1">checkNode(definition.node);</span>
            <span class="s1">}</span>
            <span class="s4">// follow references to find writes to the variable</span>
            <span class="s2">for </span><span class="s1">(const reference of variable.references) {</span>
                <span class="s2">if </span><span class="s1">(</span>
                <span class="s4">// we don't want to check the initialization ref, as this is handled by the declaration check</span>
                <span class="s1">!reference.init &amp;&amp;</span>
                    <span class="s1">reference.writeExpr) {</span>
                    <span class="s1">checkNode(reference.writeExpr);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">checkNode(node) {</span>
            <span class="s2">if </span><span class="s1">(node == </span><span class="s2">null </span><span class="s1">|| alreadyVisited.has(node)) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">alreadyVisited.add(node);</span>
            <span class="s2">switch </span><span class="s1">(node.type) {</span>
                <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.ArrowFunctionExpression:</span>
                <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.FunctionExpression:</span>
                    <span class="s2">return </span><span class="s1">checkFunctionExpression(node);</span>
                <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.ArrayExpression:</span>
                    <span class="s2">for </span><span class="s1">(const element of node.elements) {</span>
                        <span class="s1">checkNode(element);</span>
                    <span class="s1">}</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.PropertyDefinition:</span>
                    <span class="s2">if </span><span class="s1">(node.accessibility === </span><span class="s0">'private' </span><span class="s1">||</span>
                        <span class="s1">node.key.type === utils_1.AST_NODE_TYPES.PrivateIdentifier) {</span>
                        <span class="s2">return</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s2">return </span><span class="s1">checkNode(node.value);</span>
                <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.ClassDeclaration:</span>
                <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.ClassExpression:</span>
                    <span class="s2">for </span><span class="s1">(const element of node.body.body) {</span>
                        <span class="s1">checkNode(element);</span>
                    <span class="s1">}</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.FunctionDeclaration:</span>
                    <span class="s2">return </span><span class="s1">checkFunction(node);</span>
                <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.MethodDefinition:</span>
                <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSAbstractMethodDefinition:</span>
                    <span class="s2">if </span><span class="s1">(node.accessibility === </span><span class="s0">'private' </span><span class="s1">||</span>
                        <span class="s1">node.key.type === utils_1.AST_NODE_TYPES.PrivateIdentifier) {</span>
                        <span class="s2">return</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s2">return </span><span class="s1">checkNode(node.value);</span>
                <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.Identifier:</span>
                    <span class="s2">return </span><span class="s1">followReference(node);</span>
                <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.ObjectExpression:</span>
                    <span class="s2">for </span><span class="s1">(const property of node.properties) {</span>
                        <span class="s1">checkNode(property);</span>
                    <span class="s1">}</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.Property:</span>
                    <span class="s2">return </span><span class="s1">checkNode(node.value);</span>
                <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSEmptyBodyFunctionExpression:</span>
                    <span class="s2">return </span><span class="s1">checkEmptyBodyFunctionExpression(node);</span>
                <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.VariableDeclaration:</span>
                    <span class="s2">for </span><span class="s1">(const declaration of node.declarations) {</span>
                        <span class="s1">checkNode(declaration);</span>
                    <span class="s1">}</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.VariableDeclarator:</span>
                    <span class="s2">return </span><span class="s1">checkNode(node.init);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">checkEmptyBodyFunctionExpression(node) {</span>
            <span class="s2">var </span><span class="s1">_a, _b, _c;</span>
            <span class="s1">const isConstructor = ((_a = node.parent) === </span><span class="s2">null </span><span class="s1">|| _a === </span><span class="s2">void </span><span class="s5">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s5">0 </span><span class="s1">: _a.type) === utils_1.AST_NODE_TYPES.MethodDefinition &amp;&amp;</span>
                <span class="s1">node.parent.kind === </span><span class="s0">'constructor'</span><span class="s1">;</span>
            <span class="s1">const isSetAccessor = (((_b = node.parent) === </span><span class="s2">null </span><span class="s1">|| _b === </span><span class="s2">void </span><span class="s5">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s5">0 </span><span class="s1">: _b.type) === utils_1.AST_NODE_TYPES.TSAbstractMethodDefinition ||</span>
                <span class="s1">((_c = node.parent) === </span><span class="s2">null </span><span class="s1">|| _c === </span><span class="s2">void </span><span class="s5">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s5">0 </span><span class="s1">: _c.type) === utils_1.AST_NODE_TYPES.MethodDefinition) &amp;&amp;</span>
                <span class="s1">node.parent.kind === </span><span class="s0">'set'</span><span class="s1">;</span>
            <span class="s2">if </span><span class="s1">(!isConstructor &amp;&amp; !isSetAccessor &amp;&amp; !node.returnType) {</span>
                <span class="s1">context.report({</span>
                    <span class="s1">node,</span>
                    <span class="s1">messageId: </span><span class="s0">'missingReturnType'</span><span class="s1">,</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s1">checkParameters(node);</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">checkFunctionExpression(node) {</span>
            <span class="s2">if </span><span class="s1">(checkedFunctions.has(node)) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">checkedFunctions.add(node);</span>
            <span class="s2">if </span><span class="s1">(isAllowedName(node.parent) ||</span>
                <span class="s1">(</span><span class="s5">0</span><span class="s1">, explicitReturnTypeUtils_1.isTypedFunctionExpression)(node, options) ||</span>
                <span class="s1">(</span><span class="s5">0</span><span class="s1">, explicitReturnTypeUtils_1.ancestorHasReturnType)(node)) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">(</span><span class="s5">0</span><span class="s1">, explicitReturnTypeUtils_1.checkFunctionExpressionReturnType)(node, options, sourceCode, loc =&gt; {</span>
                <span class="s1">context.report({</span>
                    <span class="s1">node,</span>
                    <span class="s1">loc,</span>
                    <span class="s1">messageId: </span><span class="s0">'missingReturnType'</span><span class="s1">,</span>
                <span class="s1">});</span>
            <span class="s1">});</span>
            <span class="s1">checkParameters(node);</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">checkFunction(node) {</span>
            <span class="s2">if </span><span class="s1">(checkedFunctions.has(node)) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">checkedFunctions.add(node);</span>
            <span class="s2">if </span><span class="s1">(isAllowedName(node) || (</span><span class="s5">0</span><span class="s1">, explicitReturnTypeUtils_1.ancestorHasReturnType)(node)) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">(</span><span class="s5">0</span><span class="s1">, explicitReturnTypeUtils_1.checkFunctionReturnType)(node, options, sourceCode, loc =&gt; {</span>
                <span class="s1">context.report({</span>
                    <span class="s1">node,</span>
                    <span class="s1">loc,</span>
                    <span class="s1">messageId: </span><span class="s0">'missingReturnType'</span><span class="s1">,</span>
                <span class="s1">});</span>
            <span class="s1">});</span>
            <span class="s1">checkParameters(node);</span>
        <span class="s1">}</span>
    <span class="s1">},</span>
<span class="s1">});</span>
<span class="s4">//# sourceMappingURL=explicit-module-boundary-types.js.map</span></pre>
</body>
</html>
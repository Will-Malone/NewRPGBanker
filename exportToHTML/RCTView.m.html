<html>
<head>
<title>RCTView.m</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #bbb529;}
.s3 { color: #6a8759;}
.s4 { color: #cc7832;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
RCTView.m</font>
</center></td></tr></table>
<pre><span class="s0">/* 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>

<span class="s2">#import </span><span class="s3">&quot;RCTView.h&quot;</span>

<span class="s2">#import </span><span class="s3">&lt;QuartzCore/QuartzCore.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;React/RCTMockDef.h&gt;</span>

<span class="s2">#import </span><span class="s3">&quot;RCTAutoInsetsProtocol.h&quot;</span>
<span class="s2">#import </span><span class="s3">&quot;RCTBorderCurve.h&quot;</span>
<span class="s2">#import </span><span class="s3">&quot;RCTBorderDrawing.h&quot;</span>
<span class="s2">#import </span><span class="s3">&quot;RCTI18nUtil.h&quot;</span>
<span class="s2">#import </span><span class="s3">&quot;RCTLog.h&quot;</span>
<span class="s2">#import </span><span class="s3">&quot;RCTViewUtils.h&quot;</span>
<span class="s2">#import </span><span class="s3">&quot;UIView+React.h&quot;</span>

<span class="s1">RCT_MOCK_DEF(RCTView</span><span class="s4">, </span><span class="s1">RCTContentInsets)</span><span class="s4">;</span>
<span class="s2">#define </span><span class="s1">RCTContentInsets RCT_MOCK_USE(RCTView</span><span class="s4">, </span><span class="s1">RCTContentInsets)</span>

<span class="s1">UIAccessibilityTraits </span><span class="s4">const </span><span class="s1">SwitchAccessibilityTrait = </span><span class="s5">0x20000000000001</span><span class="s4">;</span>

<span class="s4">@implementation </span><span class="s1">UIView (RCTViewUnmounting)</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)react_remountAllSubviews</span>
<span class="s1">{</span>
  <span class="s0">// Normal views don't support unmounting, so all</span>
  <span class="s0">// this does is forward message to our subviews,</span>
  <span class="s0">// in case any of those do support it</span>

  <span class="s4">for </span><span class="s1">(UIView *subview in self.subviews) {</span>
    <span class="s1">[subview react_remountAllSubviews]</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)react_updateClippedSubviewsWithClipRect:(CGRect)clipRect relativeToView:(UIView *)clipView</span>
<span class="s1">{</span>
  <span class="s0">// Even though we don't support subview unmounting</span>
  <span class="s0">// we do support clipsToBounds, so if that's enabled</span>
  <span class="s0">// we'll update the clipping</span>

  <span class="s4">if </span><span class="s1">(self.clipsToBounds &amp;&amp; self.subviews.count &gt; </span><span class="s5">0</span><span class="s1">) {</span>
    <span class="s1">clipRect = [clipView convertRect:clipRect toView:self]</span><span class="s4">;</span>
    <span class="s1">clipRect = CGRectIntersection(clipRect</span><span class="s4">, </span><span class="s1">self.bounds)</span><span class="s4">;</span>
    <span class="s1">clipView = self</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">// Normal views don't support unmounting, so all</span>
  <span class="s0">// this does is forward message to our subviews,</span>
  <span class="s0">// in case any of those do support it</span>

  <span class="s4">for </span><span class="s1">(UIView *subview in self.subviews) {</span>
    <span class="s1">[subview react_updateClippedSubviewsWithClipRect:clipRect relativeToView:clipView]</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (UIView *)react_findClipView</span>
<span class="s1">{</span>
  <span class="s1">UIView *testView = self</span><span class="s4">;</span>
  <span class="s1">UIView *clipView = nil</span><span class="s4">;</span>
  <span class="s1">CGRect clipRect = self.bounds</span><span class="s4">;</span>
  <span class="s0">// We will only look for a clipping view up the view hierarchy until we hit the root view.</span>
  <span class="s4">while </span><span class="s1">(testView) {</span>
    <span class="s4">if </span><span class="s1">(testView.clipsToBounds) {</span>
      <span class="s4">if </span><span class="s1">(clipView) {</span>
        <span class="s1">CGRect testRect = [clipView convertRect:clipRect toView:testView]</span><span class="s4">;</span>
        <span class="s4">if </span><span class="s1">(!CGRectContainsRect(testView.bounds</span><span class="s4">, </span><span class="s1">testRect)) {</span>
          <span class="s1">clipView = testView</span><span class="s4">;</span>
          <span class="s1">clipRect = CGRectIntersection(testView.bounds</span><span class="s4">, </span><span class="s1">testRect)</span><span class="s4">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
        <span class="s1">clipView = testView</span><span class="s4">;</span>
        <span class="s1">clipRect = [self convertRect:self.bounds toView:clipView]</span><span class="s4">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s4">if </span><span class="s1">([testView isReactRootView]) {</span>
      <span class="s4">break;</span>
    <span class="s1">}</span>
    <span class="s1">testView = testView.superview</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">return </span><span class="s1">clipView ?: self.window</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">@end</span>

<span class="s4">static </span><span class="s1">NSString *RCTRecursiveAccessibilityLabel(UIView *view)</span>
<span class="s1">{</span>
  <span class="s1">NSMutableString *str = [NSMutableString stringWithString:</span><span class="s4">@</span><span class="s3">&quot;&quot;</span><span class="s1">]</span><span class="s4">;</span>
  <span class="s4">for </span><span class="s1">(UIView *subview in view.subviews) {</span>
    <span class="s1">NSString *label = subview.accessibilityLabel</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">(!label) {</span>
      <span class="s1">label = RCTRecursiveAccessibilityLabel(subview)</span><span class="s4">;</span>
    <span class="s1">}</span>
    <span class="s4">if </span><span class="s1">(label &amp;&amp; label.length &gt; </span><span class="s5">0</span><span class="s1">) {</span>
      <span class="s4">if </span><span class="s1">(str.length &gt; </span><span class="s5">0</span><span class="s1">) {</span>
        <span class="s1">[str appendString:</span><span class="s4">@</span><span class="s3">&quot; &quot;</span><span class="s1">]</span><span class="s4">;</span>
      <span class="s1">}</span>
      <span class="s1">[str appendString:label]</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s4">return </span><span class="s1">str.length == </span><span class="s5">0 </span><span class="s1">? nil : str</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">@implementation </span><span class="s1">RCTView {</span>
  <span class="s1">UIColor *_backgroundColor</span><span class="s4">;</span>
  <span class="s1">NSMutableDictionary&lt;NSString *</span><span class="s4">, </span><span class="s1">NSDictionary *&gt; *accessibilityActionsNameMap</span><span class="s4">;</span>
  <span class="s1">NSMutableDictionary&lt;NSString *</span><span class="s4">, </span><span class="s1">NSDictionary *&gt; *accessibilityActionsLabelMap</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (instancetype)initWithFrame:(CGRect)frame</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">((self = [super initWithFrame:frame])) {</span>
    <span class="s1">_borderWidth = -</span><span class="s5">1</span><span class="s4">;</span>
    <span class="s1">_borderTopWidth = -</span><span class="s5">1</span><span class="s4">;</span>
    <span class="s1">_borderRightWidth = -</span><span class="s5">1</span><span class="s4">;</span>
    <span class="s1">_borderBottomWidth = -</span><span class="s5">1</span><span class="s4">;</span>
    <span class="s1">_borderLeftWidth = -</span><span class="s5">1</span><span class="s4">;</span>
    <span class="s1">_borderStartWidth = -</span><span class="s5">1</span><span class="s4">;</span>
    <span class="s1">_borderEndWidth = -</span><span class="s5">1</span><span class="s4">;</span>
    <span class="s1">_borderTopLeftRadius = -</span><span class="s5">1</span><span class="s4">;</span>
    <span class="s1">_borderTopRightRadius = -</span><span class="s5">1</span><span class="s4">;</span>
    <span class="s1">_borderTopStartRadius = -</span><span class="s5">1</span><span class="s4">;</span>
    <span class="s1">_borderTopEndRadius = -</span><span class="s5">1</span><span class="s4">;</span>
    <span class="s1">_borderBottomLeftRadius = -</span><span class="s5">1</span><span class="s4">;</span>
    <span class="s1">_borderBottomRightRadius = -</span><span class="s5">1</span><span class="s4">;</span>
    <span class="s1">_borderBottomStartRadius = -</span><span class="s5">1</span><span class="s4">;</span>
    <span class="s1">_borderBottomEndRadius = -</span><span class="s5">1</span><span class="s4">;</span>
    <span class="s1">_borderEndEndRadius = -</span><span class="s5">1</span><span class="s4">;</span>
    <span class="s1">_borderEndStartRadius = -</span><span class="s5">1</span><span class="s4">;</span>
    <span class="s1">_borderStartEndRadius = -</span><span class="s5">1</span><span class="s4">;</span>
    <span class="s1">_borderStartStartRadius = -</span><span class="s5">1</span><span class="s4">;</span>
    <span class="s1">_borderCurve = RCTBorderCurveCircular</span><span class="s4">;</span>
    <span class="s1">_borderStyle = RCTBorderStyleSolid</span><span class="s4">;</span>
    <span class="s1">_hitTestEdgeInsets = UIEdgeInsetsZero</span><span class="s4">;</span>

    <span class="s1">_backgroundColor = super.backgroundColor</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">return </span><span class="s1">self</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">RCT_NOT_IMPLEMENTED(-(instancetype)initWithCoder : unused)</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)setReactLayoutDirection:(UIUserInterfaceLayoutDirection)layoutDirection</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(_reactLayoutDirection != layoutDirection) {</span>
    <span class="s1">_reactLayoutDirection = layoutDirection</span><span class="s4">;</span>
    <span class="s1">[self.layer setNeedsDisplay]</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">([self respondsToSelector:</span><span class="s4">@selector</span><span class="s1">(setSemanticContentAttribute:)]) {</span>
    <span class="s1">self.semanticContentAttribute = layoutDirection == UIUserInterfaceLayoutDirectionLeftToRight</span>
        <span class="s1">? UISemanticContentAttributeForceLeftToRight</span>
        <span class="s1">: UISemanticContentAttributeForceRightToLeft</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">#pragma </span><span class="s1">mark - Hit Testing</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)setPointerEvents:(RCTPointerEvents)pointerEvents</span>
<span class="s1">{</span>
  <span class="s1">_pointerEvents = pointerEvents</span><span class="s4">;</span>
  <span class="s1">self.userInteractionEnabled = (pointerEvents != RCTPointerEventsNone)</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(pointerEvents == RCTPointerEventsBoxNone) {</span>
    <span class="s1">self.accessibilityViewIsModal = NO</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event</span>
<span class="s1">{</span>
  <span class="s1">BOOL canReceiveTouchEvents = ([self isUserInteractionEnabled] &amp;&amp; ![self isHidden])</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(!canReceiveTouchEvents) {</span>
    <span class="s4">return </span><span class="s1">nil</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">// `hitSubview` is the topmost subview which was hit. The hit point can</span>
  <span class="s0">// be outside the bounds of `view` (e.g., if -clipsToBounds is NO).</span>
  <span class="s1">UIView *hitSubview = nil</span><span class="s4">;</span>
  <span class="s1">BOOL isPointInside = [self pointInside:point withEvent:event]</span><span class="s4">;</span>
  <span class="s1">BOOL needsHitSubview = !(_pointerEvents == RCTPointerEventsNone || _pointerEvents == RCTPointerEventsBoxOnly)</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(needsHitSubview &amp;&amp; (![self clipsToBounds] || isPointInside)) {</span>
    <span class="s0">// Take z-index into account when calculating the touch target.</span>
    <span class="s1">NSArray&lt;UIView *&gt; *sortedSubviews = [self reactZIndexSortedSubviews]</span><span class="s4">;</span>

    <span class="s0">// The default behaviour of UIKit is that if a view does not contain a point,</span>
    <span class="s0">// then no subviews will be returned from hit testing, even if they contain</span>
    <span class="s0">// the hit point. By doing hit testing directly on the subviews, we bypass</span>
    <span class="s0">// the strict containment policy (i.e., UIKit guarantees that every ancestor</span>
    <span class="s0">// of the hit view will return YES from -pointInside:withEvent:). See:</span>
    <span class="s0">//  - https://developer.apple.com/library/ios/qa/qa2013/qa1812.html</span>
    <span class="s4">for </span><span class="s1">(UIView *subview in [sortedSubviews reverseObjectEnumerator]) {</span>
      <span class="s1">CGPoint convertedPoint = [subview convertPoint:point fromView:self]</span><span class="s4">;</span>
      <span class="s1">hitSubview = [subview hitTest:convertedPoint withEvent:event]</span><span class="s4">;</span>
      <span class="s4">if </span><span class="s1">(hitSubview != nil) {</span>
        <span class="s4">break;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">UIView *hitView = (isPointInside ? self : nil)</span><span class="s4">;</span>

  <span class="s4">switch </span><span class="s1">(_pointerEvents) {</span>
    <span class="s4">case </span><span class="s1">RCTPointerEventsNone:</span>
      <span class="s4">return </span><span class="s1">nil</span><span class="s4">;</span>
    <span class="s4">case </span><span class="s1">RCTPointerEventsUnspecified:</span>
      <span class="s4">return </span><span class="s1">hitSubview ?: hitView</span><span class="s4">;</span>
    <span class="s4">case </span><span class="s1">RCTPointerEventsBoxOnly:</span>
      <span class="s4">return </span><span class="s1">hitView</span><span class="s4">;</span>
    <span class="s4">case </span><span class="s1">RCTPointerEventsBoxNone:</span>
      <span class="s4">return </span><span class="s1">hitSubview</span><span class="s4">;</span>
    <span class="s4">default</span><span class="s1">:</span>
      <span class="s1">RCTLogInfo(</span><span class="s4">@</span><span class="s3">&quot;Invalid pointer-events specified %lld on %@&quot;</span><span class="s4">, </span><span class="s1">(</span><span class="s4">long long</span><span class="s1">)_pointerEvents</span><span class="s4">, </span><span class="s1">self)</span><span class="s4">;</span>
      <span class="s4">return </span><span class="s1">hitSubview ?: hitView</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(UIEdgeInsetsEqualToEdgeInsets(self.hitTestEdgeInsets</span><span class="s4">, </span><span class="s1">UIEdgeInsetsZero)) {</span>
    <span class="s4">return </span><span class="s1">[super pointInside:point withEvent:event]</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s1">CGRect hitFrame = UIEdgeInsetsInsetRect(self.bounds</span><span class="s4">, </span><span class="s1">self.hitTestEdgeInsets)</span><span class="s4">;</span>
  <span class="s4">return </span><span class="s1">CGRectContainsPoint(hitFrame</span><span class="s4">, </span><span class="s1">point)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s2">#pragma </span><span class="s1">mark - Accessibility</span>

<span class="s1">- (NSString *)accessibilityLabel</span>
<span class="s1">{</span>
  <span class="s1">NSString *label = super.accessibilityLabel</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(label) {</span>
    <span class="s4">return </span><span class="s1">label</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">return </span><span class="s1">RCTRecursiveAccessibilityLabel(self)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (NSArray&lt;UIAccessibilityCustomAction *&gt; *)accessibilityCustomActions</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(!self.accessibilityActions.count) {</span>
    <span class="s4">return </span><span class="s1">nil</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">accessibilityActionsNameMap = [NSMutableDictionary new]</span><span class="s4">;</span>
  <span class="s1">accessibilityActionsLabelMap = [NSMutableDictionary new]</span><span class="s4">;</span>
  <span class="s1">NSMutableArray *actions = [NSMutableArray array]</span><span class="s4">;</span>
  <span class="s4">for </span><span class="s1">(NSDictionary *action in self.accessibilityActions) {</span>
    <span class="s4">if </span><span class="s1">(action[</span><span class="s4">@</span><span class="s3">&quot;name&quot;</span><span class="s1">]) {</span>
      <span class="s1">accessibilityActionsNameMap[action[</span><span class="s4">@</span><span class="s3">&quot;name&quot;</span><span class="s1">]] = action</span><span class="s4">;</span>
    <span class="s1">}</span>
    <span class="s4">if </span><span class="s1">(action[</span><span class="s4">@</span><span class="s3">&quot;label&quot;</span><span class="s1">]) {</span>
      <span class="s1">accessibilityActionsLabelMap[action[</span><span class="s4">@</span><span class="s3">&quot;label&quot;</span><span class="s1">]] = action</span><span class="s4">;</span>
      <span class="s1">[actions addObject:[[UIAccessibilityCustomAction alloc]</span>
                             <span class="s1">initWithName:action[</span><span class="s4">@</span><span class="s3">&quot;label&quot;</span><span class="s1">]</span>
                                   <span class="s1">target:self</span>
                                 <span class="s4">selector</span><span class="s1">:</span><span class="s4">@selector</span><span class="s1">(didActivateAccessibilityCustomAction:)]]</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s4">return </span><span class="s1">[actions copy]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (BOOL)didActivateAccessibilityCustomAction:(UIAccessibilityCustomAction *)action</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(!_onAccessibilityAction || !accessibilityActionsLabelMap) {</span>
    <span class="s4">return </span><span class="s1">NO</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s0">// iOS defines the name as the localized label, so use our map to convert this back to the non-localized action name</span>
  <span class="s0">// when passing to JS. This allows for standard action names across platforms.</span>
  <span class="s1">NSDictionary *actionObject = accessibilityActionsLabelMap[action.name]</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(actionObject) {</span>
    <span class="s1">_onAccessibilityAction(</span><span class="s4">@</span><span class="s1">{</span><span class="s4">@</span><span class="s3">&quot;actionName&quot; </span><span class="s1">: actionObject[</span><span class="s4">@</span><span class="s3">&quot;name&quot;</span><span class="s1">]</span><span class="s4">, @</span><span class="s3">&quot;actionTarget&quot; </span><span class="s1">: self.reactTag})</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">return </span><span class="s1">YES</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (NSString *)accessibilityValue</span>
<span class="s1">{</span>
  <span class="s4">static </span><span class="s1">dispatch_once_t onceToken</span><span class="s4">;</span>
  <span class="s4">static </span><span class="s1">NSDictionary&lt;NSString *</span><span class="s4">, </span><span class="s1">NSString *&gt; *rolesAndStatesDescription = nil</span><span class="s4">;</span>

  <span class="s1">dispatch_once(&amp;onceToken</span><span class="s4">, </span><span class="s1">^{</span>
    <span class="s1">NSString *bundlePath = [[NSBundle mainBundle] pathForResource:</span><span class="s4">@</span><span class="s3">&quot;AccessibilityResources&quot; </span><span class="s1">ofType:</span><span class="s4">@</span><span class="s3">&quot;bundle&quot;</span><span class="s1">]</span><span class="s4">;</span>
    <span class="s1">NSBundle *bundle = [NSBundle bundleWithPath:bundlePath]</span><span class="s4">;</span>

    <span class="s4">if </span><span class="s1">(bundle) {</span>
      <span class="s1">NSURL *url = [bundle URLForResource:</span><span class="s4">@</span><span class="s3">&quot;Localizable&quot; </span><span class="s1">withExtension:</span><span class="s4">@</span><span class="s3">&quot;strings&quot;</span><span class="s1">]</span><span class="s4">;</span>
      <span class="s1">rolesAndStatesDescription = [NSDictionary dictionaryWithContentsOfURL:url error:nil]</span><span class="s4">;</span>
    <span class="s1">}</span>
    <span class="s4">if </span><span class="s1">(rolesAndStatesDescription == nil) {</span>
      <span class="s0">// Falling back to hardcoded English list.</span>
      <span class="s1">NSLog(</span><span class="s4">@</span><span class="s3">&quot;Cannot load localized accessibility strings.&quot;</span><span class="s1">)</span><span class="s4">;</span>
      <span class="s1">rolesAndStatesDescription = </span><span class="s4">@</span><span class="s1">{</span>
        <span class="s4">@</span><span class="s3">&quot;alert&quot; </span><span class="s1">: </span><span class="s4">@</span><span class="s3">&quot;alert&quot;</span><span class="s4">,</span>
        <span class="s4">@</span><span class="s3">&quot;checkbox&quot; </span><span class="s1">: </span><span class="s4">@</span><span class="s3">&quot;checkbox&quot;</span><span class="s4">,</span>
        <span class="s4">@</span><span class="s3">&quot;combobox&quot; </span><span class="s1">: </span><span class="s4">@</span><span class="s3">&quot;combo box&quot;</span><span class="s4">,</span>
        <span class="s4">@</span><span class="s3">&quot;menu&quot; </span><span class="s1">: </span><span class="s4">@</span><span class="s3">&quot;menu&quot;</span><span class="s4">,</span>
        <span class="s4">@</span><span class="s3">&quot;menubar&quot; </span><span class="s1">: </span><span class="s4">@</span><span class="s3">&quot;menu bar&quot;</span><span class="s4">,</span>
        <span class="s4">@</span><span class="s3">&quot;menuitem&quot; </span><span class="s1">: </span><span class="s4">@</span><span class="s3">&quot;menu item&quot;</span><span class="s4">,</span>
        <span class="s4">@</span><span class="s3">&quot;progressbar&quot; </span><span class="s1">: </span><span class="s4">@</span><span class="s3">&quot;progress bar&quot;</span><span class="s4">,</span>
        <span class="s4">@</span><span class="s3">&quot;radio&quot; </span><span class="s1">: </span><span class="s4">@</span><span class="s3">&quot;radio button&quot;</span><span class="s4">,</span>
        <span class="s4">@</span><span class="s3">&quot;radiogroup&quot; </span><span class="s1">: </span><span class="s4">@</span><span class="s3">&quot;radio group&quot;</span><span class="s4">,</span>
        <span class="s4">@</span><span class="s3">&quot;scrollbar&quot; </span><span class="s1">: </span><span class="s4">@</span><span class="s3">&quot;scroll bar&quot;</span><span class="s4">,</span>
        <span class="s4">@</span><span class="s3">&quot;spinbutton&quot; </span><span class="s1">: </span><span class="s4">@</span><span class="s3">&quot;spin button&quot;</span><span class="s4">,</span>
        <span class="s4">@</span><span class="s3">&quot;switch&quot; </span><span class="s1">: </span><span class="s4">@</span><span class="s3">&quot;switch&quot;</span><span class="s4">,</span>
        <span class="s4">@</span><span class="s3">&quot;tab&quot; </span><span class="s1">: </span><span class="s4">@</span><span class="s3">&quot;tab&quot;</span><span class="s4">,</span>
        <span class="s4">@</span><span class="s3">&quot;tablist&quot; </span><span class="s1">: </span><span class="s4">@</span><span class="s3">&quot;tab list&quot;</span><span class="s4">,</span>
        <span class="s4">@</span><span class="s3">&quot;timer&quot; </span><span class="s1">: </span><span class="s4">@</span><span class="s3">&quot;timer&quot;</span><span class="s4">,</span>
        <span class="s4">@</span><span class="s3">&quot;toolbar&quot; </span><span class="s1">: </span><span class="s4">@</span><span class="s3">&quot;tool bar&quot;</span><span class="s4">,</span>
        <span class="s4">@</span><span class="s3">&quot;checked&quot; </span><span class="s1">: </span><span class="s4">@</span><span class="s3">&quot;checked&quot;</span><span class="s4">,</span>
        <span class="s4">@</span><span class="s3">&quot;unchecked&quot; </span><span class="s1">: </span><span class="s4">@</span><span class="s3">&quot;not checked&quot;</span><span class="s4">,</span>
        <span class="s4">@</span><span class="s3">&quot;busy&quot; </span><span class="s1">: </span><span class="s4">@</span><span class="s3">&quot;busy&quot;</span><span class="s4">,</span>
        <span class="s4">@</span><span class="s3">&quot;expanded&quot; </span><span class="s1">: </span><span class="s4">@</span><span class="s3">&quot;expanded&quot;</span><span class="s4">,</span>
        <span class="s4">@</span><span class="s3">&quot;collapsed&quot; </span><span class="s1">: </span><span class="s4">@</span><span class="s3">&quot;collapsed&quot;</span><span class="s4">,</span>
        <span class="s4">@</span><span class="s3">&quot;mixed&quot; </span><span class="s1">: </span><span class="s4">@</span><span class="s3">&quot;mixed&quot;</span><span class="s4">,</span>
      <span class="s1">}</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">})</span><span class="s4">;</span>

  <span class="s0">// Handle Switch.</span>
  <span class="s4">if </span><span class="s1">((self.accessibilityTraits &amp; SwitchAccessibilityTrait) == SwitchAccessibilityTrait) {</span>
    <span class="s4">for </span><span class="s1">(NSString *state in self.accessibilityState) {</span>
      <span class="s1">id val = self.accessibilityState[state]</span><span class="s4">;</span>
      <span class="s4">if </span><span class="s1">(!val) {</span>
        <span class="s4">continue;</span>
      <span class="s1">}</span>
      <span class="s4">if </span><span class="s1">([state isEqualToString:</span><span class="s4">@</span><span class="s3">&quot;checked&quot;</span><span class="s1">] &amp;&amp; [val isKindOfClass:[NSNumber </span><span class="s4">class</span><span class="s1">]]) {</span>
        <span class="s4">return </span><span class="s1">[val boolValue] ? </span><span class="s4">@</span><span class="s3">&quot;1&quot; </span><span class="s1">: </span><span class="s4">@</span><span class="s3">&quot;0&quot;</span><span class="s4">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">NSMutableArray *valueComponents = [NSMutableArray new]</span><span class="s4">;</span>
  <span class="s1">NSString *roleDescription = self.accessibilityRole ? rolesAndStatesDescription[self.accessibilityRole] : nil</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(roleDescription) {</span>
    <span class="s1">[valueComponents addObject:roleDescription]</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">// Handle states which haven't already been handled in RCTViewManager.</span>
  <span class="s4">for </span><span class="s1">(NSString *state in self.accessibilityState) {</span>
    <span class="s1">id val = self.accessibilityState[state]</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">(!val) {</span>
      <span class="s4">continue;</span>
    <span class="s1">}</span>
    <span class="s4">if </span><span class="s1">([state isEqualToString:</span><span class="s4">@</span><span class="s3">&quot;checked&quot;</span><span class="s1">]) {</span>
      <span class="s4">if </span><span class="s1">([val isKindOfClass:[NSNumber </span><span class="s4">class</span><span class="s1">]]) {</span>
        <span class="s1">[valueComponents addObject:rolesAndStatesDescription[[val boolValue] ? </span><span class="s4">@</span><span class="s3">&quot;checked&quot; </span><span class="s1">: </span><span class="s4">@</span><span class="s3">&quot;unchecked&quot;</span><span class="s1">]]</span><span class="s4">;</span>
      <span class="s1">} </span><span class="s4">else if </span><span class="s1">([val isKindOfClass:[NSString </span><span class="s4">class</span><span class="s1">]] &amp;&amp; [val isEqualToString:</span><span class="s4">@</span><span class="s3">&quot;mixed&quot;</span><span class="s1">]) {</span>
        <span class="s1">[valueComponents addObject:rolesAndStatesDescription[</span><span class="s4">@</span><span class="s3">&quot;mixed&quot;</span><span class="s1">]]</span><span class="s4">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s4">if </span><span class="s1">([state isEqualToString:</span><span class="s4">@</span><span class="s3">&quot;expanded&quot;</span><span class="s1">] &amp;&amp; [val isKindOfClass:[NSNumber </span><span class="s4">class</span><span class="s1">]]) {</span>
      <span class="s1">[valueComponents addObject:rolesAndStatesDescription[[val boolValue] ? </span><span class="s4">@</span><span class="s3">&quot;expanded&quot; </span><span class="s1">: </span><span class="s4">@</span><span class="s3">&quot;collapsed&quot;</span><span class="s1">]]</span><span class="s4">;</span>
    <span class="s1">}</span>
    <span class="s4">if </span><span class="s1">([state isEqualToString:</span><span class="s4">@</span><span class="s3">&quot;busy&quot;</span><span class="s1">] &amp;&amp; [val isKindOfClass:[NSNumber </span><span class="s4">class</span><span class="s1">]] &amp;&amp; [val boolValue]) {</span>
      <span class="s1">[valueComponents addObject:rolesAndStatesDescription[</span><span class="s4">@</span><span class="s3">&quot;busy&quot;</span><span class="s1">]]</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">// Handle accessibilityValue.</span>
  <span class="s4">if </span><span class="s1">(self.accessibilityValueInternal) {</span>
    <span class="s1">id min = self.accessibilityValueInternal[</span><span class="s4">@</span><span class="s3">&quot;min&quot;</span><span class="s1">]</span><span class="s4">;</span>
    <span class="s1">id now = self.accessibilityValueInternal[</span><span class="s4">@</span><span class="s3">&quot;now&quot;</span><span class="s1">]</span><span class="s4">;</span>
    <span class="s1">id max = self.accessibilityValueInternal[</span><span class="s4">@</span><span class="s3">&quot;max&quot;</span><span class="s1">]</span><span class="s4">;</span>
    <span class="s1">id text = self.accessibilityValueInternal[</span><span class="s4">@</span><span class="s3">&quot;text&quot;</span><span class="s1">]</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">(text &amp;&amp; [text isKindOfClass:[NSString </span><span class="s4">class</span><span class="s1">]]) {</span>
      <span class="s1">[valueComponents addObject:text]</span><span class="s4">;</span>
    <span class="s1">} </span><span class="s4">else if </span><span class="s1">(</span>
        <span class="s1">[min isKindOfClass:[NSNumber </span><span class="s4">class</span><span class="s1">]] &amp;&amp; [now isKindOfClass:[NSNumber </span><span class="s4">class</span><span class="s1">]] &amp;&amp;</span>
        <span class="s1">[max isKindOfClass:[NSNumber </span><span class="s4">class</span><span class="s1">]] &amp;&amp; ([min intValue] &lt; [max intValue]) &amp;&amp;</span>
        <span class="s1">([min intValue] &lt;= [now intValue] &amp;&amp; [now intValue] &lt;= [max intValue])) {</span>
      <span class="s4">int </span><span class="s1">val = ([now intValue] * </span><span class="s5">100</span><span class="s1">) / ([max intValue] - [min intValue])</span><span class="s4">;</span>
      <span class="s1">[valueComponents addObject:[NSString stringWithFormat:</span><span class="s4">@</span><span class="s3">&quot;%d percent&quot;</span><span class="s4">, </span><span class="s1">val]]</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(valueComponents.count &gt; </span><span class="s5">0</span><span class="s1">) {</span>
    <span class="s4">return </span><span class="s1">[valueComponents componentsJoinedByString:</span><span class="s4">@</span><span class="s3">&quot;, &quot;</span><span class="s1">]</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">return </span><span class="s1">nil</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (UIView *)reactAccessibilityElement</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">self</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (BOOL)isAccessibilityElement</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(self.reactAccessibilityElement == self) {</span>
    <span class="s4">return </span><span class="s1">[super isAccessibilityElement]</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">return </span><span class="s1">NO</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (BOOL)performAccessibilityAction:(NSString *)name</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(_onAccessibilityAction &amp;&amp; accessibilityActionsNameMap[name]) {</span>
    <span class="s1">_onAccessibilityAction(</span><span class="s4">@</span><span class="s1">{</span><span class="s4">@</span><span class="s3">&quot;actionName&quot; </span><span class="s1">: name</span><span class="s4">, @</span><span class="s3">&quot;actionTarget&quot; </span><span class="s1">: self.reactTag})</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">YES</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">return </span><span class="s1">NO</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (BOOL)accessibilityActivate</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">([self performAccessibilityAction:</span><span class="s4">@</span><span class="s3">&quot;activate&quot;</span><span class="s1">]) {</span>
    <span class="s4">return </span><span class="s1">YES</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else if </span><span class="s1">(_onAccessibilityTap) {</span>
    <span class="s1">_onAccessibilityTap(nil)</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">YES</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s4">return </span><span class="s1">NO</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (BOOL)accessibilityPerformMagicTap</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">([self performAccessibilityAction:</span><span class="s4">@</span><span class="s3">&quot;magicTap&quot;</span><span class="s1">]) {</span>
    <span class="s4">return </span><span class="s1">YES</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else if </span><span class="s1">(_onMagicTap) {</span>
    <span class="s1">_onMagicTap(nil)</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">YES</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s4">return </span><span class="s1">NO</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (BOOL)accessibilityPerformEscape</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">([self performAccessibilityAction:</span><span class="s4">@</span><span class="s3">&quot;escape&quot;</span><span class="s1">]) {</span>
    <span class="s4">return </span><span class="s1">YES</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else if </span><span class="s1">(_onAccessibilityEscape) {</span>
    <span class="s1">_onAccessibilityEscape(nil)</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">YES</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s4">return </span><span class="s1">NO</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)accessibilityIncrement</span>
<span class="s1">{</span>
  <span class="s1">[self performAccessibilityAction:</span><span class="s4">@</span><span class="s3">&quot;increment&quot;</span><span class="s1">]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)accessibilityDecrement</span>
<span class="s1">{</span>
  <span class="s1">[self performAccessibilityAction:</span><span class="s4">@</span><span class="s3">&quot;decrement&quot;</span><span class="s1">]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (NSString *)description</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">[[super description] stringByAppendingFormat:</span><span class="s4">@</span><span class="s3">&quot; reactTag: %@; frame = %@; layer = %@&quot;</span><span class="s4">,</span>
                                                      <span class="s1">self.reactTag</span><span class="s4">,</span>
                                                      <span class="s1">NSStringFromCGRect(self.frame)</span><span class="s4">,</span>
                                                      <span class="s1">self.layer]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s2">#pragma </span><span class="s1">mark - Statics </span><span class="s4">for </span><span class="s1">dealing with layoutGuides</span>

<span class="s1">+ (</span><span class="s4">void</span><span class="s1">)autoAdjustInsetsForView:(UIView&lt;RCTAutoInsetsProtocol&gt; *)parentView</span>
                 <span class="s1">withScrollView:(UIScrollView *)scrollView</span>
                   <span class="s1">updateOffset:(BOOL)updateOffset</span>
<span class="s1">{</span>
  <span class="s1">UIEdgeInsets baseInset = parentView.contentInset</span><span class="s4">;</span>
  <span class="s1">CGFloat previousInsetTop = scrollView.contentInset.top</span><span class="s4">;</span>
  <span class="s1">CGPoint contentOffset = scrollView.contentOffset</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(parentView.automaticallyAdjustContentInsets) {</span>
    <span class="s1">UIEdgeInsets autoInset = RCTContentInsets(parentView)</span><span class="s4">;</span>
    <span class="s1">baseInset.top += autoInset.top</span><span class="s4">;</span>
    <span class="s1">baseInset.bottom += autoInset.bottom</span><span class="s4">;</span>
    <span class="s1">baseInset.left += autoInset.left</span><span class="s4">;</span>
    <span class="s1">baseInset.right += autoInset.right</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s1">scrollView.contentInset = baseInset</span><span class="s4">;</span>
  <span class="s1">scrollView.scrollIndicatorInsets = baseInset</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(updateOffset) {</span>
    <span class="s0">// If we're adjusting the top inset, then let's also adjust the contentOffset so that the view</span>
    <span class="s0">// elements above the top guide do not cover the content.</span>
    <span class="s0">// This is generally only needed when your views are initially laid out, for</span>
    <span class="s0">// manual changes to contentOffset, you can optionally disable this step</span>
    <span class="s1">CGFloat currentInsetTop = scrollView.contentInset.top</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">(currentInsetTop != previousInsetTop) {</span>
      <span class="s1">contentOffset.y -= (currentInsetTop - previousInsetTop)</span><span class="s4">;</span>
      <span class="s1">scrollView.contentOffset = contentOffset</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">#pragma </span><span class="s1">mark - View Unmounting</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)react_remountAllSubviews</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(_removeClippedSubviews) {</span>
    <span class="s4">for </span><span class="s1">(UIView *view in self.reactSubviews) {</span>
      <span class="s4">if </span><span class="s1">(view.superview != self) {</span>
        <span class="s1">[self addSubview:view]</span><span class="s4">;</span>
        <span class="s1">[view react_remountAllSubviews]</span><span class="s4">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s0">// If _removeClippedSubviews is false, we must already be showing all subviews</span>
    <span class="s1">[super react_remountAllSubviews]</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)react_updateClippedSubviewsWithClipRect:(CGRect)clipRect relativeToView:(UIView *)clipView</span>
<span class="s1">{</span>
  <span class="s0">// TODO (#5906496): for scrollviews (the primary use-case) we could</span>
  <span class="s0">// optimize this by only doing a range check along the scroll axis,</span>
  <span class="s0">// instead of comparing the whole frame</span>

  <span class="s4">if </span><span class="s1">(!_removeClippedSubviews) {</span>
    <span class="s0">// Use default behavior if unmounting is disabled</span>
    <span class="s4">return </span><span class="s1">[super react_updateClippedSubviewsWithClipRect:clipRect relativeToView:clipView]</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(self.reactSubviews.count == </span><span class="s5">0</span><span class="s1">) {</span>
    <span class="s0">// Do nothing if we have no subviews</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(CGSizeEqualToSize(self.bounds.size</span><span class="s4">, </span><span class="s1">CGSizeZero)) {</span>
    <span class="s0">// Do nothing if layout hasn't happened yet</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>

  <span class="s0">// Convert clipping rect to local coordinates</span>
  <span class="s1">clipRect = [clipView convertRect:clipRect toView:self]</span><span class="s4">;</span>
  <span class="s1">clipRect = CGRectIntersection(clipRect</span><span class="s4">, </span><span class="s1">self.bounds)</span><span class="s4">;</span>
  <span class="s1">clipView = self</span><span class="s4">;</span>

  <span class="s0">// Mount / unmount views</span>
  <span class="s4">for </span><span class="s1">(UIView *view in self.reactSubviews) {</span>
    <span class="s4">if </span><span class="s1">(!CGSizeEqualToSize(CGRectIntersection(clipRect</span><span class="s4">, </span><span class="s1">view.frame).size</span><span class="s4">, </span><span class="s1">CGSizeZero)) {</span>
      <span class="s0">// View is at least partially visible, so remount it if unmounted</span>
      <span class="s1">[self addSubview:view]</span><span class="s4">;</span>

      <span class="s0">// Then test its subviews</span>
      <span class="s4">if </span><span class="s1">(CGRectContainsRect(clipRect</span><span class="s4">, </span><span class="s1">view.frame)) {</span>
        <span class="s0">// View is fully visible, so remount all subviews</span>
        <span class="s1">[view react_remountAllSubviews]</span><span class="s4">;</span>
      <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
        <span class="s0">// View is partially visible, so update clipped subviews</span>
        <span class="s1">[view react_updateClippedSubviewsWithClipRect:clipRect relativeToView:clipView]</span><span class="s4">;</span>
      <span class="s1">}</span>

    <span class="s1">} </span><span class="s4">else if </span><span class="s1">(view.superview) {</span>
      <span class="s0">// View is completely outside the clipRect, so unmount it</span>
      <span class="s1">[view removeFromSuperview]</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)setRemoveClippedSubviews:(BOOL)removeClippedSubviews</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(!removeClippedSubviews &amp;&amp; _removeClippedSubviews) {</span>
    <span class="s1">[self react_remountAllSubviews]</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s1">_removeClippedSubviews = removeClippedSubviews</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)didUpdateReactSubviews</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(_removeClippedSubviews) {</span>
    <span class="s1">[self updateClippedSubviews]</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s1">[super didUpdateReactSubviews]</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)updateClippedSubviews</span>
<span class="s1">{</span>
  <span class="s0">// Find a suitable view to use for clipping</span>
  <span class="s1">UIView *clipView = [self react_findClipView]</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(clipView) {</span>
    <span class="s1">[self react_updateClippedSubviewsWithClipRect:clipView.bounds relativeToView:clipView]</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)layoutSubviews</span>
<span class="s1">{</span>
  <span class="s0">// TODO (#5906496): this a nasty performance drain, but necessary</span>
  <span class="s0">// to prevent gaps appearing when the loading spinner disappears.</span>
  <span class="s0">// We might be able to fix this another way by triggering a call</span>
  <span class="s0">// to updateClippedSubviews manually after loading</span>

  <span class="s1">[super layoutSubviews]</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(_removeClippedSubviews) {</span>
    <span class="s1">[self updateClippedSubviews]</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)traitCollectionDidChange:(UITraitCollection *)previousTraitCollection</span>
<span class="s1">{</span>
  <span class="s1">[super traitCollectionDidChange:previousTraitCollection]</span><span class="s4">;</span>
<span class="s2">#if </span><span class="s1">defined(__IPHONE_OS_VERSION_MAX_ALLOWED) &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= </span><span class="s5">130000</span>
  <span class="s4">if </span><span class="s1">(</span><span class="s4">@available</span><span class="s1">(iOS </span><span class="s5">13.0</span><span class="s4">, </span><span class="s1">*)) {</span>
    <span class="s4">if </span><span class="s1">([self.traitCollection hasDifferentColorAppearanceComparedToTraitCollection:previousTraitCollection]) {</span>
      <span class="s1">[self.layer setNeedsDisplay]</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s2">#endif</span>
<span class="s1">}</span>

<span class="s2">#pragma </span><span class="s1">mark - Borders</span>

<span class="s1">- (UIColor *)backgroundColor</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">_backgroundColor</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)setBackgroundColor:(UIColor *)backgroundColor</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">([_backgroundColor isEqual:backgroundColor]) {</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>

  <span class="s1">_backgroundColor = backgroundColor</span><span class="s4">;</span>
  <span class="s1">[self.layer setNeedsDisplay]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">static </span><span class="s1">CGFloat RCTDefaultIfNegativeTo(CGFloat defaultValue</span><span class="s4">, </span><span class="s1">CGFloat x)</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">x &gt;= </span><span class="s5">0 </span><span class="s1">? x : defaultValue</span><span class="s4">;</span>
<span class="s1">}</span><span class="s4">;</span>

<span class="s1">- (UIEdgeInsets)bordersAsInsets</span>
<span class="s1">{</span>
  <span class="s4">const </span><span class="s1">CGFloat borderWidth = MAX(</span><span class="s5">0</span><span class="s4">, </span><span class="s1">_borderWidth)</span><span class="s4">;</span>
  <span class="s4">const </span><span class="s1">BOOL isRTL = _reactLayoutDirection == UIUserInterfaceLayoutDirectionRightToLeft</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">([[RCTI18nUtil sharedInstance] doLeftAndRightSwapInRTL]) {</span>
    <span class="s4">const </span><span class="s1">CGFloat borderStartWidth = RCTDefaultIfNegativeTo(_borderLeftWidth</span><span class="s4">, </span><span class="s1">_borderStartWidth)</span><span class="s4">;</span>
    <span class="s4">const </span><span class="s1">CGFloat borderEndWidth = RCTDefaultIfNegativeTo(_borderRightWidth</span><span class="s4">, </span><span class="s1">_borderEndWidth)</span><span class="s4">;</span>

    <span class="s4">const </span><span class="s1">CGFloat directionAwareBorderLeftWidth = isRTL ? borderEndWidth : borderStartWidth</span><span class="s4">;</span>
    <span class="s4">const </span><span class="s1">CGFloat directionAwareBorderRightWidth = isRTL ? borderStartWidth : borderEndWidth</span><span class="s4">;</span>

    <span class="s4">return </span><span class="s1">(UIEdgeInsets){</span>
        <span class="s1">RCTDefaultIfNegativeTo(borderWidth</span><span class="s4">, </span><span class="s1">_borderTopWidth)</span><span class="s4">,</span>
        <span class="s1">RCTDefaultIfNegativeTo(borderWidth</span><span class="s4">, </span><span class="s1">directionAwareBorderLeftWidth)</span><span class="s4">,</span>
        <span class="s1">RCTDefaultIfNegativeTo(borderWidth</span><span class="s4">, </span><span class="s1">_borderBottomWidth)</span><span class="s4">,</span>
        <span class="s1">RCTDefaultIfNegativeTo(borderWidth</span><span class="s4">, </span><span class="s1">directionAwareBorderRightWidth)</span><span class="s4">,</span>
    <span class="s1">}</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">const </span><span class="s1">CGFloat directionAwareBorderLeftWidth = isRTL ? _borderEndWidth : _borderStartWidth</span><span class="s4">;</span>
  <span class="s4">const </span><span class="s1">CGFloat directionAwareBorderRightWidth = isRTL ? _borderStartWidth : _borderEndWidth</span><span class="s4">;</span>

  <span class="s4">return </span><span class="s1">(UIEdgeInsets){</span>
      <span class="s1">RCTDefaultIfNegativeTo(borderWidth</span><span class="s4">, </span><span class="s1">_borderTopWidth)</span><span class="s4">,</span>
      <span class="s1">RCTDefaultIfNegativeTo(borderWidth</span><span class="s4">, </span><span class="s1">RCTDefaultIfNegativeTo(_borderLeftWidth</span><span class="s4">, </span><span class="s1">directionAwareBorderLeftWidth))</span><span class="s4">,</span>
      <span class="s1">RCTDefaultIfNegativeTo(borderWidth</span><span class="s4">, </span><span class="s1">_borderBottomWidth)</span><span class="s4">,</span>
      <span class="s1">RCTDefaultIfNegativeTo(borderWidth</span><span class="s4">, </span><span class="s1">RCTDefaultIfNegativeTo(_borderRightWidth</span><span class="s4">, </span><span class="s1">directionAwareBorderRightWidth))</span><span class="s4">,</span>
  <span class="s1">}</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (RCTCornerRadii)cornerRadii</span>
<span class="s1">{</span>
  <span class="s4">const </span><span class="s1">BOOL isRTL = _reactLayoutDirection == UIUserInterfaceLayoutDirectionRightToLeft</span><span class="s4">;</span>
  <span class="s4">const </span><span class="s1">CGFloat radius = MAX(</span><span class="s5">0</span><span class="s4">, </span><span class="s1">_borderRadius)</span><span class="s4">;</span>

  <span class="s1">CGFloat topLeftRadius</span><span class="s4">;</span>
  <span class="s1">CGFloat topRightRadius</span><span class="s4">;</span>
  <span class="s1">CGFloat bottomLeftRadius</span><span class="s4">;</span>
  <span class="s1">CGFloat bottomRightRadius</span><span class="s4">;</span>

  <span class="s4">const </span><span class="s1">CGFloat logicalTopStartRadius = RCTDefaultIfNegativeTo(_borderStartStartRadius</span><span class="s4">, </span><span class="s1">_borderTopStartRadius)</span><span class="s4">;</span>
  <span class="s4">const </span><span class="s1">CGFloat logicalTopEndRadius = RCTDefaultIfNegativeTo(_borderStartEndRadius</span><span class="s4">, </span><span class="s1">_borderTopEndRadius)</span><span class="s4">;</span>
  <span class="s4">const </span><span class="s1">CGFloat logicalBottomStartRadius = RCTDefaultIfNegativeTo(_borderEndStartRadius</span><span class="s4">, </span><span class="s1">_borderBottomStartRadius)</span><span class="s4">;</span>
  <span class="s4">const </span><span class="s1">CGFloat logicalBottomEndRadius = RCTDefaultIfNegativeTo(_borderEndEndRadius</span><span class="s4">, </span><span class="s1">_borderBottomEndRadius)</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">([[RCTI18nUtil sharedInstance] doLeftAndRightSwapInRTL]) {</span>
    <span class="s4">const </span><span class="s1">CGFloat topStartRadius = RCTDefaultIfNegativeTo(_borderTopLeftRadius</span><span class="s4">, </span><span class="s1">logicalTopStartRadius)</span><span class="s4">;</span>
    <span class="s4">const </span><span class="s1">CGFloat topEndRadius = RCTDefaultIfNegativeTo(_borderTopRightRadius</span><span class="s4">, </span><span class="s1">logicalTopEndRadius)</span><span class="s4">;</span>
    <span class="s4">const </span><span class="s1">CGFloat bottomStartRadius = RCTDefaultIfNegativeTo(_borderBottomLeftRadius</span><span class="s4">, </span><span class="s1">logicalBottomStartRadius)</span><span class="s4">;</span>
    <span class="s4">const </span><span class="s1">CGFloat bottomEndRadius = RCTDefaultIfNegativeTo(_borderBottomRightRadius</span><span class="s4">, </span><span class="s1">logicalBottomEndRadius)</span><span class="s4">;</span>

    <span class="s4">const </span><span class="s1">CGFloat directionAwareTopLeftRadius = isRTL ? topEndRadius : topStartRadius</span><span class="s4">;</span>
    <span class="s4">const </span><span class="s1">CGFloat directionAwareTopRightRadius = isRTL ? topStartRadius : topEndRadius</span><span class="s4">;</span>
    <span class="s4">const </span><span class="s1">CGFloat directionAwareBottomLeftRadius = isRTL ? bottomEndRadius : bottomStartRadius</span><span class="s4">;</span>
    <span class="s4">const </span><span class="s1">CGFloat directionAwareBottomRightRadius = isRTL ? bottomStartRadius : bottomEndRadius</span><span class="s4">;</span>

    <span class="s1">topLeftRadius = RCTDefaultIfNegativeTo(radius</span><span class="s4">, </span><span class="s1">directionAwareTopLeftRadius)</span><span class="s4">;</span>
    <span class="s1">topRightRadius = RCTDefaultIfNegativeTo(radius</span><span class="s4">, </span><span class="s1">directionAwareTopRightRadius)</span><span class="s4">;</span>
    <span class="s1">bottomLeftRadius = RCTDefaultIfNegativeTo(radius</span><span class="s4">, </span><span class="s1">directionAwareBottomLeftRadius)</span><span class="s4">;</span>
    <span class="s1">bottomRightRadius = RCTDefaultIfNegativeTo(radius</span><span class="s4">, </span><span class="s1">directionAwareBottomRightRadius)</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s4">const </span><span class="s1">CGFloat directionAwareTopLeftRadius = isRTL ? logicalTopEndRadius : logicalTopStartRadius</span><span class="s4">;</span>
    <span class="s4">const </span><span class="s1">CGFloat directionAwareTopRightRadius = isRTL ? logicalTopStartRadius : logicalTopEndRadius</span><span class="s4">;</span>
    <span class="s4">const </span><span class="s1">CGFloat directionAwareBottomLeftRadius = isRTL ? logicalBottomEndRadius : logicalBottomStartRadius</span><span class="s4">;</span>
    <span class="s4">const </span><span class="s1">CGFloat directionAwareBottomRightRadius = isRTL ? logicalBottomStartRadius : logicalBottomEndRadius</span><span class="s4">;</span>

    <span class="s1">topLeftRadius =</span>
        <span class="s1">RCTDefaultIfNegativeTo(radius</span><span class="s4">, </span><span class="s1">RCTDefaultIfNegativeTo(_borderTopLeftRadius</span><span class="s4">, </span><span class="s1">directionAwareTopLeftRadius))</span><span class="s4">;</span>
    <span class="s1">topRightRadius =</span>
        <span class="s1">RCTDefaultIfNegativeTo(radius</span><span class="s4">, </span><span class="s1">RCTDefaultIfNegativeTo(_borderTopRightRadius</span><span class="s4">, </span><span class="s1">directionAwareTopRightRadius))</span><span class="s4">;</span>
    <span class="s1">bottomLeftRadius =</span>
        <span class="s1">RCTDefaultIfNegativeTo(radius</span><span class="s4">, </span><span class="s1">RCTDefaultIfNegativeTo(_borderBottomLeftRadius</span><span class="s4">, </span><span class="s1">directionAwareBottomLeftRadius))</span><span class="s4">;</span>
    <span class="s1">bottomRightRadius = RCTDefaultIfNegativeTo(</span>
        <span class="s1">radius</span><span class="s4">, </span><span class="s1">RCTDefaultIfNegativeTo(_borderBottomRightRadius</span><span class="s4">, </span><span class="s1">directionAwareBottomRightRadius))</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">// Get scale factors required to prevent radii from overlapping</span>
  <span class="s4">const </span><span class="s1">CGSize size = self.bounds.size</span><span class="s4">;</span>
  <span class="s4">const </span><span class="s1">CGFloat topScaleFactor = RCTZeroIfNaN(MIN(</span><span class="s5">1</span><span class="s4">, </span><span class="s1">size.width / (topLeftRadius + topRightRadius)))</span><span class="s4">;</span>
  <span class="s4">const </span><span class="s1">CGFloat bottomScaleFactor = RCTZeroIfNaN(MIN(</span><span class="s5">1</span><span class="s4">, </span><span class="s1">size.width / (bottomLeftRadius + bottomRightRadius)))</span><span class="s4">;</span>
  <span class="s4">const </span><span class="s1">CGFloat rightScaleFactor = RCTZeroIfNaN(MIN(</span><span class="s5">1</span><span class="s4">, </span><span class="s1">size.height / (topRightRadius + bottomRightRadius)))</span><span class="s4">;</span>
  <span class="s4">const </span><span class="s1">CGFloat leftScaleFactor = RCTZeroIfNaN(MIN(</span><span class="s5">1</span><span class="s4">, </span><span class="s1">size.height / (topLeftRadius + bottomLeftRadius)))</span><span class="s4">;</span>

  <span class="s0">// Return scaled radii</span>
  <span class="s4">return </span><span class="s1">(RCTCornerRadii){</span>
      <span class="s1">topLeftRadius * MIN(topScaleFactor</span><span class="s4">, </span><span class="s1">leftScaleFactor)</span><span class="s4">,</span>
      <span class="s1">topRightRadius * MIN(topScaleFactor</span><span class="s4">, </span><span class="s1">rightScaleFactor)</span><span class="s4">,</span>
      <span class="s1">bottomLeftRadius * MIN(bottomScaleFactor</span><span class="s4">, </span><span class="s1">leftScaleFactor)</span><span class="s4">,</span>
      <span class="s1">bottomRightRadius * MIN(bottomScaleFactor</span><span class="s4">, </span><span class="s1">rightScaleFactor)</span><span class="s4">,</span>
  <span class="s1">}</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (RCTBorderColors)borderColorsWithTraitCollection:(UITraitCollection *)traitCollection</span>
<span class="s1">{</span>
  <span class="s4">const </span><span class="s1">BOOL isRTL = _reactLayoutDirection == UIUserInterfaceLayoutDirectionRightToLeft</span><span class="s4">;</span>

  <span class="s1">UIColor *directionAwareBorderLeftColor = nil</span><span class="s4">;</span>
  <span class="s1">UIColor *directionAwareBorderRightColor = nil</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">([[RCTI18nUtil sharedInstance] doLeftAndRightSwapInRTL]) {</span>
    <span class="s1">UIColor *borderStartColor = _borderStartColor ?: _borderLeftColor</span><span class="s4">;</span>
    <span class="s1">UIColor *borderEndColor = _borderEndColor ?: _borderRightColor</span><span class="s4">;</span>

    <span class="s1">directionAwareBorderLeftColor = isRTL ? borderEndColor : borderStartColor</span><span class="s4">;</span>
    <span class="s1">directionAwareBorderRightColor = isRTL ? borderStartColor : borderEndColor</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s1">directionAwareBorderLeftColor = (isRTL ? _borderEndColor : _borderStartColor) ?: _borderLeftColor</span><span class="s4">;</span>
    <span class="s1">directionAwareBorderRightColor = (isRTL ? _borderStartColor : _borderEndColor) ?: _borderRightColor</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">UIColor *borderColor = _borderColor</span><span class="s4">;</span>
  <span class="s1">UIColor *borderTopColor = _borderTopColor</span><span class="s4">;</span>
  <span class="s1">UIColor *borderBottomColor = _borderBottomColor</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(_borderBlockColor) {</span>
    <span class="s1">borderTopColor = _borderBlockColor</span><span class="s4">;</span>
    <span class="s1">borderBottomColor = _borderBlockColor</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">if </span><span class="s1">(_borderBlockEndColor) {</span>
    <span class="s1">borderBottomColor = _borderBlockEndColor</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">if </span><span class="s1">(_borderBlockStartColor) {</span>
    <span class="s1">borderTopColor = _borderBlockStartColor</span><span class="s4">;</span>
  <span class="s1">}</span>

<span class="s2">#if </span><span class="s1">defined(__IPHONE_OS_VERSION_MAX_ALLOWED) &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= </span><span class="s5">130000</span>
  <span class="s4">if </span><span class="s1">(</span><span class="s4">@available</span><span class="s1">(iOS </span><span class="s5">13.0</span><span class="s4">, </span><span class="s1">*)) {</span>
    <span class="s1">borderColor = [borderColor resolvedColorWithTraitCollection:self.traitCollection]</span><span class="s4">;</span>
    <span class="s1">borderTopColor = [borderTopColor resolvedColorWithTraitCollection:self.traitCollection]</span><span class="s4">;</span>
    <span class="s1">directionAwareBorderLeftColor =</span>
        <span class="s1">[directionAwareBorderLeftColor resolvedColorWithTraitCollection:self.traitCollection]</span><span class="s4">;</span>
    <span class="s1">borderBottomColor = [borderBottomColor resolvedColorWithTraitCollection:self.traitCollection]</span><span class="s4">;</span>
    <span class="s1">directionAwareBorderRightColor =</span>
        <span class="s1">[directionAwareBorderRightColor resolvedColorWithTraitCollection:self.traitCollection]</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s2">#endif</span>

  <span class="s4">return </span><span class="s1">(RCTBorderColors){</span>
      <span class="s1">(borderTopColor ?: borderColor).CGColor</span><span class="s4">,</span>
      <span class="s1">(directionAwareBorderLeftColor ?: borderColor).CGColor</span><span class="s4">,</span>
      <span class="s1">(borderBottomColor ?: borderColor).CGColor</span><span class="s4">,</span>
      <span class="s1">(directionAwareBorderRightColor ?: borderColor).CGColor</span><span class="s4">,</span>
  <span class="s1">}</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)reactSetFrame:(CGRect)frame</span>
<span class="s1">{</span>
  <span class="s0">// If frame is zero, or below the threshold where the border radii can</span>
  <span class="s0">// be rendered as a stretchable image, we'll need to re-render.</span>
  <span class="s0">// TODO: detect up-front if re-rendering is necessary</span>
  <span class="s1">CGSize oldSize = self.bounds.size</span><span class="s4">;</span>
  <span class="s1">[super reactSetFrame:frame]</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(!CGSizeEqualToSize(self.bounds.size</span><span class="s4">, </span><span class="s1">oldSize)) {</span>
    <span class="s1">[self.layer setNeedsDisplay]</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)displayLayer:(CALayer *)layer</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(CGSizeEqualToSize(layer.bounds.size</span><span class="s4">, </span><span class="s1">CGSizeZero)) {</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>

  <span class="s1">RCTUpdateShadowPathForView(self)</span><span class="s4">;</span>

  <span class="s4">const </span><span class="s1">RCTCornerRadii cornerRadii = [self cornerRadii]</span><span class="s4">;</span>
  <span class="s4">const </span><span class="s1">UIEdgeInsets borderInsets = [self bordersAsInsets]</span><span class="s4">;</span>
  <span class="s4">const </span><span class="s1">RCTBorderColors borderColors = [self borderColorsWithTraitCollection:self.traitCollection]</span><span class="s4">;</span>

  <span class="s1">BOOL useIOSBorderRendering = RCTCornerRadiiAreEqual(cornerRadii) &amp;&amp; RCTBorderInsetsAreEqual(borderInsets) &amp;&amp;</span>
      <span class="s1">RCTBorderColorsAreEqual(borderColors) &amp;&amp; _borderStyle == RCTBorderStyleSolid &amp;&amp;</span>

      <span class="s0">// iOS draws borders in front of the content whereas CSS draws them behind</span>
      <span class="s0">// the content. For this reason, only use iOS border drawing when clipping</span>
      <span class="s0">// or when the border is hidden.</span>

      <span class="s1">(borderInsets.top == </span><span class="s5">0 </span><span class="s1">|| (borderColors.top &amp;&amp; CGColorGetAlpha(borderColors.top) == </span><span class="s5">0</span><span class="s1">) || self.clipsToBounds)</span><span class="s4">;</span>

  <span class="s0">// iOS clips to the outside of the border, but CSS clips to the inside. To</span>
  <span class="s0">// solve this, we'll need to add a container view inside the main view to</span>
  <span class="s0">// correctly clip the subviews.</span>

  <span class="s1">CGColorRef backgroundColor</span><span class="s4">;</span>
<span class="s2">#if </span><span class="s1">defined(__IPHONE_OS_VERSION_MAX_ALLOWED) &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= </span><span class="s5">130000</span>
  <span class="s4">if </span><span class="s1">(</span><span class="s4">@available</span><span class="s1">(iOS </span><span class="s5">13.0</span><span class="s4">, </span><span class="s1">*)) {</span>
    <span class="s1">backgroundColor = [_backgroundColor resolvedColorWithTraitCollection:self.traitCollection].CGColor</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s1">backgroundColor = _backgroundColor.CGColor</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s2">#else</span>
  <span class="s1">backgroundColor = _backgroundColor.CGColor</span><span class="s4">;</span>
<span class="s2">#endif</span>

  <span class="s4">if </span><span class="s1">(useIOSBorderRendering) {</span>
    <span class="s1">layer.cornerRadius = cornerRadii.topLeft</span><span class="s4">;</span>
    <span class="s1">layer.borderColor = borderColors.left</span><span class="s4">;</span>
    <span class="s1">layer.borderWidth = borderInsets.left</span><span class="s4">;</span>
    <span class="s1">layer.backgroundColor = backgroundColor</span><span class="s4">;</span>
    <span class="s1">layer.contents = nil</span><span class="s4">;</span>
    <span class="s1">layer.needsDisplayOnBoundsChange = NO</span><span class="s4">;</span>
    <span class="s1">layer.mask = nil</span><span class="s4">;</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>

  <span class="s1">UIImage *image = RCTGetBorderImage(</span>
      <span class="s1">_borderStyle</span><span class="s4">, </span><span class="s1">layer.bounds.size</span><span class="s4">, </span><span class="s1">cornerRadii</span><span class="s4">, </span><span class="s1">borderInsets</span><span class="s4">, </span><span class="s1">borderColors</span><span class="s4">, </span><span class="s1">backgroundColor</span><span class="s4">, </span><span class="s1">self.clipsToBounds)</span><span class="s4">;</span>

  <span class="s1">layer.backgroundColor = NULL</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(image == nil) {</span>
    <span class="s1">layer.contents = nil</span><span class="s4">;</span>
    <span class="s1">layer.needsDisplayOnBoundsChange = NO</span><span class="s4">;</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>

  <span class="s1">CGRect contentsCenter = ({</span>
    <span class="s1">CGSize size = image.size</span><span class="s4">;</span>
    <span class="s1">UIEdgeInsets insets = image.capInsets</span><span class="s4">;</span>
    <span class="s1">CGRectMake(</span>
        <span class="s1">insets.left / size.width</span><span class="s4">, </span><span class="s1">insets.top / size.height</span><span class="s4">, </span><span class="s1">(CGFloat)</span><span class="s5">1.0 </span><span class="s1">/ size.width</span><span class="s4">, </span><span class="s1">(CGFloat)</span><span class="s5">1.0 </span><span class="s1">/ size.height)</span><span class="s4">;</span>
  <span class="s1">})</span><span class="s4">;</span>

  <span class="s1">layer.contents = (id)image.CGImage</span><span class="s4">;</span>
  <span class="s1">layer.contentsScale = image.scale</span><span class="s4">;</span>
  <span class="s1">layer.needsDisplayOnBoundsChange = YES</span><span class="s4">;</span>
  <span class="s1">layer.magnificationFilter = kCAFilterNearest</span><span class="s4">;</span>

  <span class="s4">const </span><span class="s1">BOOL isResizable = !UIEdgeInsetsEqualToEdgeInsets(image.capInsets</span><span class="s4">, </span><span class="s1">UIEdgeInsetsZero)</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(isResizable) {</span>
    <span class="s1">layer.contentsCenter = contentsCenter</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s1">layer.contentsCenter = CGRectMake(</span><span class="s5">0.0</span><span class="s4">, </span><span class="s5">0.0</span><span class="s4">, </span><span class="s5">1.0</span><span class="s4">, </span><span class="s5">1.0</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">[self updateClippingForLayer:layer]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">static </span><span class="s1">BOOL RCTLayerHasShadow(CALayer *layer)</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">layer.shadowOpacity * CGColorGetAlpha(layer.shadowColor) &gt; </span><span class="s5">0</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">static void </span><span class="s1">RCTUpdateShadowPathForView(RCTView *view)</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(RCTLayerHasShadow(view.layer)) {</span>
    <span class="s4">if </span><span class="s1">(CGColorGetAlpha(view.backgroundColor.CGColor) &gt; </span><span class="s5">0.999</span><span class="s1">) {</span>
      <span class="s0">// If view has a solid background color, calculate shadow path from border</span>
      <span class="s4">const </span><span class="s1">RCTCornerRadii cornerRadii = [view cornerRadii]</span><span class="s4">;</span>
      <span class="s4">const </span><span class="s1">RCTCornerInsets cornerInsets = RCTGetCornerInsets(cornerRadii</span><span class="s4">, </span><span class="s1">UIEdgeInsetsZero)</span><span class="s4">;</span>
      <span class="s1">CGPathRef shadowPath = RCTPathCreateWithRoundedRect(view.bounds</span><span class="s4">, </span><span class="s1">cornerInsets</span><span class="s4">, </span><span class="s1">NULL)</span><span class="s4">;</span>
      <span class="s1">view.layer.shadowPath = shadowPath</span><span class="s4">;</span>
      <span class="s1">CGPathRelease(shadowPath)</span><span class="s4">;</span>

    <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
      <span class="s0">// Can't accurately calculate box shadow, so fall back to pixel-based shadow</span>
      <span class="s1">view.layer.shadowPath = nil</span><span class="s4">;</span>

      <span class="s1">RCTLogAdvice(</span>
          <span class="s4">@</span><span class="s3">&quot;View #%@ of type %@ has a shadow set but cannot calculate &quot;</span>
           <span class="s3">&quot;shadow efficiently. Consider setting a background color to &quot;</span>
           <span class="s3">&quot;fix this, or apply the shadow to a more specific component.&quot;</span><span class="s4">,</span>
          <span class="s1">view.reactTag</span><span class="s4">,</span>
          <span class="s1">[view </span><span class="s4">class</span><span class="s1">])</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)updateClippingForLayer:(CALayer *)layer</span>
<span class="s1">{</span>
  <span class="s1">CALayer *mask = nil</span><span class="s4">;</span>
  <span class="s1">CGFloat cornerRadius = </span><span class="s5">0</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(self.clipsToBounds) {</span>
    <span class="s4">const </span><span class="s1">RCTCornerRadii cornerRadii = [self cornerRadii]</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">(RCTCornerRadiiAreEqual(cornerRadii)) {</span>
      <span class="s1">cornerRadius = cornerRadii.topLeft</span><span class="s4">;</span>

    <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
      <span class="s1">CAShapeLayer *shapeLayer = [CAShapeLayer layer]</span><span class="s4">;</span>
      <span class="s1">CGPathRef path =</span>
          <span class="s1">RCTPathCreateWithRoundedRect(self.bounds</span><span class="s4">, </span><span class="s1">RCTGetCornerInsets(cornerRadii</span><span class="s4">, </span><span class="s1">UIEdgeInsetsZero)</span><span class="s4">, </span><span class="s1">NULL)</span><span class="s4">;</span>
      <span class="s1">shapeLayer.path = path</span><span class="s4">;</span>
      <span class="s1">CGPathRelease(path)</span><span class="s4">;</span>
      <span class="s1">mask = shapeLayer</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">layer.cornerRadius = cornerRadius</span><span class="s4">;</span>
  <span class="s1">layer.mask = mask</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s2">#pragma </span><span class="s1">mark Border Color</span>

<span class="s2">#define </span><span class="s1">setBorderColor(side)                       \ 
  -(</span><span class="s4">void</span><span class="s1">)setBorder##side##Color : (UIColor *)color \ 
  {                                                \ 
    </span><span class="s4">if </span><span class="s1">([_border##side##Color isEqual:color]) {    \ 
      </span><span class="s4">return;                                      </span><span class="s1">\ 
    }                                              \ 
    _border##side##Color = color</span><span class="s4">;                  </span><span class="s1">\ 
    [self.layer setNeedsDisplay]</span><span class="s4">;                  </span><span class="s1">\ 
  }</span>

<span class="s1">setBorderColor() setBorderColor(Top) setBorderColor(Right) setBorderColor(Bottom) setBorderColor(Left)</span>
    <span class="s1">setBorderColor(Start) setBorderColor(End) setBorderColor(Block) setBorderColor(BlockEnd) setBorderColor(BlockStart)</span>

<span class="s2">#pragma </span><span class="s1">mark - Border Width</span>

<span class="s2">#define </span><span class="s1">setBorderWidth(side)                     \ 
  -(</span><span class="s4">void</span><span class="s1">)setBorder##side##Width : (CGFloat)width \ 
  {                                              \ 
    </span><span class="s4">if </span><span class="s1">(_border##side##Width == width) {         \ 
      </span><span class="s4">return;                                    </span><span class="s1">\ 
    }                                            \ 
    _border##side##Width = width</span><span class="s4">;                </span><span class="s1">\ 
    [self.layer setNeedsDisplay]</span><span class="s4">;                </span><span class="s1">\ 
  }</span>

        <span class="s1">setBorderWidth() setBorderWidth(Top) setBorderWidth(Right) setBorderWidth(Bottom) setBorderWidth(Left)</span>
            <span class="s1">setBorderWidth(Start) setBorderWidth(End)</span>

<span class="s2">#pragma </span><span class="s1">mark - Border Radius</span>

<span class="s2">#define </span><span class="s1">setBorderRadius(side)                      \ 
  -(</span><span class="s4">void</span><span class="s1">)setBorder##side##Radius : (CGFloat)radius \ 
  {                                                \ 
    </span><span class="s4">if </span><span class="s1">(_border##side##Radius == radius) {         \ 
      </span><span class="s4">return;                                      </span><span class="s1">\ 
    }                                              \ 
    _border##side##Radius = radius</span><span class="s4">;                </span><span class="s1">\ 
    [self.layer setNeedsDisplay]</span><span class="s4">;                  </span><span class="s1">\ 
  }</span>

                <span class="s1">setBorderRadius() setBorderRadius(TopLeft) setBorderRadius(TopRight) setBorderRadius(TopStart)</span>
                    <span class="s1">setBorderRadius(TopEnd) setBorderRadius(BottomLeft) setBorderRadius(BottomRight)</span>
                        <span class="s1">setBorderRadius(BottomStart) setBorderRadius(BottomEnd) setBorderRadius(EndEnd)</span>
                            <span class="s1">setBorderRadius(EndStart) setBorderRadius(StartEnd) setBorderRadius(StartStart)</span>

<span class="s2">#pragma </span><span class="s1">mark - Border Curve</span>

<span class="s2">#define </span><span class="s1">setBorderCurve(side)                            \ 
  -(</span><span class="s4">void</span><span class="s1">)setBorder##side##Curve : (RCTBorderCurve)curve \ 
  {                                                     \ 
    </span><span class="s4">if </span><span class="s1">(_border##side##Curve == curve) {                \ 
      </span><span class="s4">return;                                           </span><span class="s1">\ 
    }                                                   \ 
    _border##side##Curve = curve</span><span class="s4">;                       </span><span class="s1">\ 
    [self.layer setNeedsDisplay]</span><span class="s4">;                       </span><span class="s1">\ 
  }</span>

                                <span class="s1">setBorderCurve()</span>

<span class="s2">#pragma </span><span class="s1">mark - Border Style</span>

<span class="s2">#define </span><span class="s1">setBorderStyle(side)                            \ 
  -(</span><span class="s4">void</span><span class="s1">)setBorder##side##Style : (RCTBorderStyle)style \ 
  {                                                     \ 
    </span><span class="s4">if </span><span class="s1">(_border##side##Style == style) {                \ 
      </span><span class="s4">return;                                           </span><span class="s1">\ 
    }                                                   \ 
    _border##side##Style = style</span><span class="s4">;                       </span><span class="s1">\ 
    [self.layer setNeedsDisplay]</span><span class="s4">;                       </span><span class="s1">\ 
  }</span>

                                    <span class="s1">setBorderStyle()</span>

                                        <span class="s4">@end</span>
</pre>
</body>
</html>
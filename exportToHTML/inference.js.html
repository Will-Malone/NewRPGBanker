<html>
<head>
<title>inference.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
inference.js</font>
</center></td></tr></table>
<pre><span class="s0">/*********************************************************************** 
 
  A JavaScript tokenizer / parser / beautifier / compressor. 
  https://github.com/mishoo/UglifyJS2 
 
  -------------------------------- (C) --------------------------------- 
 
                           Author: Mihai Bazon 
                         &lt;mihai.bazon@gmail.com&gt; 
                       http://mihai.bazon.net/blog 
 
  Distributed under the BSD license: 
 
    Copyright 2012 (c) Mihai Bazon &lt;mihai.bazon@gmail.com&gt; 
 
    Redistribution and use in source and binary forms, with or without 
    modification, are permitted provided that the following conditions 
    are met: 
 
        * Redistributions of source code must retain the above 
          copyright notice, this list of conditions and the following 
          disclaimer. 
 
        * Redistributions in binary form must reproduce the above 
          copyright notice, this list of conditions and the following 
          disclaimer in the documentation and/or other materials 
          provided with the distribution. 
 
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY 
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE 
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, 
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF 
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
    SUCH DAMAGE. 
 
 ***********************************************************************/</span>

<span class="s1">import {</span>
  <span class="s1">AST_Array,</span>
  <span class="s1">AST_Arrow,</span>
  <span class="s1">AST_Assign,</span>
  <span class="s1">AST_BigInt,</span>
  <span class="s1">AST_Binary,</span>
  <span class="s1">AST_Block,</span>
  <span class="s1">AST_BlockStatement,</span>
  <span class="s1">AST_Call,</span>
  <span class="s1">AST_Case,</span>
  <span class="s1">AST_Chain,</span>
  <span class="s1">AST_Class,</span>
  <span class="s1">AST_DefClass,</span>
  <span class="s1">AST_ClassStaticBlock,</span>
  <span class="s1">AST_ClassProperty,</span>
  <span class="s1">AST_ConciseMethod,</span>
  <span class="s1">AST_Conditional,</span>
  <span class="s1">AST_Constant,</span>
  <span class="s1">AST_Definitions,</span>
  <span class="s1">AST_Dot,</span>
  <span class="s1">AST_EmptyStatement,</span>
  <span class="s1">AST_Expansion,</span>
  <span class="s1">AST_False,</span>
  <span class="s1">AST_ForIn,</span>
  <span class="s1">AST_Function,</span>
  <span class="s1">AST_If,</span>
  <span class="s1">AST_Import,</span>
  <span class="s1">AST_ImportMeta,</span>
  <span class="s1">AST_Jump,</span>
  <span class="s1">AST_LabeledStatement,</span>
  <span class="s1">AST_Lambda,</span>
  <span class="s1">AST_New,</span>
  <span class="s1">AST_Node,</span>
  <span class="s1">AST_Null,</span>
  <span class="s1">AST_Number,</span>
  <span class="s1">AST_Object,</span>
  <span class="s1">AST_ObjectGetter,</span>
  <span class="s1">AST_ObjectKeyVal,</span>
  <span class="s1">AST_ObjectProperty,</span>
  <span class="s1">AST_ObjectSetter,</span>
  <span class="s1">AST_PropAccess,</span>
  <span class="s1">AST_RegExp,</span>
  <span class="s1">AST_Return,</span>
  <span class="s1">AST_Scope,</span>
  <span class="s1">AST_Sequence,</span>
  <span class="s1">AST_SimpleStatement,</span>
  <span class="s1">AST_Statement,</span>
  <span class="s1">AST_String,</span>
  <span class="s1">AST_Sub,</span>
  <span class="s1">AST_Switch,</span>
  <span class="s1">AST_SwitchBranch,</span>
  <span class="s1">AST_SymbolClassProperty,</span>
  <span class="s1">AST_SymbolDeclaration,</span>
  <span class="s1">AST_SymbolRef,</span>
  <span class="s1">AST_TemplateSegment,</span>
  <span class="s1">AST_TemplateString,</span>
  <span class="s1">AST_This,</span>
  <span class="s1">AST_Toplevel,</span>
  <span class="s1">AST_True,</span>
  <span class="s1">AST_Try,</span>
  <span class="s1">AST_Unary,</span>
  <span class="s1">AST_UnaryPostfix,</span>
  <span class="s1">AST_UnaryPrefix,</span>
  <span class="s1">AST_Undefined,</span>
  <span class="s1">AST_VarDef,</span>

  <span class="s1">TreeTransformer,</span>
  <span class="s1">walk,</span>
  <span class="s1">walk_abort,</span>

  <span class="s1">_PURE</span>
<span class="s1">} from </span><span class="s2">&quot;../ast.js&quot;</span><span class="s1">;</span>
<span class="s1">import {</span>
    <span class="s1">makePredicate,</span>
    <span class="s1">return_true,</span>
    <span class="s1">return_false,</span>
    <span class="s1">return_null,</span>
    <span class="s1">return_this,</span>
    <span class="s1">make_node,</span>
    <span class="s1">member,</span>
    <span class="s1">noop,</span>
    <span class="s1">has_annotation,</span>
    <span class="s1">HOP</span>
<span class="s1">} from </span><span class="s2">&quot;../utils/index.js&quot;</span><span class="s1">;</span>
<span class="s1">import { make_node_from_constant, make_sequence, best_of_expression, read_property } from </span><span class="s2">&quot;./common.js&quot;</span><span class="s1">;</span>

<span class="s1">import { INLINED, UNDEFINED, has_flag } from </span><span class="s2">&quot;./compressor-flags.js&quot;</span><span class="s1">;</span>
<span class="s1">import { pure_prop_access_globals, is_pure_native_fn, is_pure_native_method } from </span><span class="s2">&quot;./native-objects.js&quot;</span><span class="s1">;</span>

<span class="s0">// Functions and methods to infer certain facts about expressions</span>
<span class="s0">// It's not always possible to be 100% sure about something just by static analysis,</span>
<span class="s0">// so `true` means yes, and `false` means maybe</span>

<span class="s1">export const is_undeclared_ref = (node) =&gt;</span>
    <span class="s1">node </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef &amp;&amp; node.definition().undeclared;</span>

<span class="s1">export const lazy_op = makePredicate(</span><span class="s2">&quot;&amp;&amp; || ??&quot;</span><span class="s1">);</span>
<span class="s1">export const unary_side_effects = makePredicate(</span><span class="s2">&quot;delete ++ --&quot;</span><span class="s1">);</span>

<span class="s0">// methods to determine whether an expression has a boolean result type</span>
<span class="s1">(</span><span class="s3">function</span><span class="s1">(def_is_boolean) {</span>
    <span class="s1">const unary_bool = makePredicate(</span><span class="s2">&quot;! delete&quot;</span><span class="s1">);</span>
    <span class="s1">const binary_bool = makePredicate(</span><span class="s2">&quot;in instanceof == != === !== &lt; &lt;= &gt;= &gt;&quot;</span><span class="s1">);</span>
    <span class="s1">def_is_boolean(AST_Node, return_false);</span>
    <span class="s1">def_is_boolean(AST_UnaryPrefix, </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">unary_bool.has(</span><span class="s3">this</span><span class="s1">.operator);</span>
    <span class="s1">});</span>
    <span class="s1">def_is_boolean(AST_Binary, </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">binary_bool.has(</span><span class="s3">this</span><span class="s1">.operator)</span>
            <span class="s1">|| lazy_op.has(</span><span class="s3">this</span><span class="s1">.operator)</span>
                <span class="s1">&amp;&amp; </span><span class="s3">this</span><span class="s1">.left.is_boolean()</span>
                <span class="s1">&amp;&amp; </span><span class="s3">this</span><span class="s1">.right.is_boolean();</span>
    <span class="s1">});</span>
    <span class="s1">def_is_boolean(AST_Conditional, </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return this</span><span class="s1">.consequent.is_boolean() &amp;&amp; </span><span class="s3">this</span><span class="s1">.alternative.is_boolean();</span>
    <span class="s1">});</span>
    <span class="s1">def_is_boolean(AST_Assign, </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return this</span><span class="s1">.operator == </span><span class="s2">&quot;=&quot; </span><span class="s1">&amp;&amp; </span><span class="s3">this</span><span class="s1">.right.is_boolean();</span>
    <span class="s1">});</span>
    <span class="s1">def_is_boolean(AST_Sequence, </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return this</span><span class="s1">.tail_node().is_boolean();</span>
    <span class="s1">});</span>
    <span class="s1">def_is_boolean(AST_True, return_true);</span>
    <span class="s1">def_is_boolean(AST_False, return_true);</span>
<span class="s1">})(</span><span class="s3">function</span><span class="s1">(node, func) {</span>
    <span class="s1">node.DEFMETHOD(</span><span class="s2">&quot;is_boolean&quot;</span><span class="s1">, func);</span>
<span class="s1">});</span>

<span class="s0">// methods to determine if an expression has a numeric result type</span>
<span class="s1">(</span><span class="s3">function</span><span class="s1">(def_is_number) {</span>
    <span class="s1">def_is_number(AST_Node, return_false);</span>
    <span class="s1">def_is_number(AST_Number, return_true);</span>
    <span class="s1">const unary = makePredicate(</span><span class="s2">&quot;+ - ~ ++ --&quot;</span><span class="s1">);</span>
    <span class="s1">def_is_number(AST_Unary, </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">unary.has(</span><span class="s3">this</span><span class="s1">.operator) &amp;&amp; !(</span><span class="s3">this</span><span class="s1">.expression </span><span class="s3">instanceof </span><span class="s1">AST_BigInt);</span>
    <span class="s1">});</span>
    <span class="s1">const numeric_ops = makePredicate(</span><span class="s2">&quot;- * / % &amp; | ^ &lt;&lt; &gt;&gt; &gt;&gt;&gt;&quot;</span><span class="s1">);</span>
    <span class="s1">def_is_number(AST_Binary, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">return </span><span class="s1">numeric_ops.has(</span><span class="s3">this</span><span class="s1">.operator) || </span><span class="s3">this</span><span class="s1">.operator == </span><span class="s2">&quot;+&quot;</span>
            <span class="s1">&amp;&amp; </span><span class="s3">this</span><span class="s1">.left.is_number(compressor)</span>
            <span class="s1">&amp;&amp; </span><span class="s3">this</span><span class="s1">.right.is_number(compressor);</span>
    <span class="s1">});</span>
    <span class="s1">def_is_number(AST_Assign, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">return </span><span class="s1">numeric_ops.has(</span><span class="s3">this</span><span class="s1">.operator.slice(</span><span class="s4">0</span><span class="s1">, -</span><span class="s4">1</span><span class="s1">))</span>
            <span class="s1">|| </span><span class="s3">this</span><span class="s1">.operator == </span><span class="s2">&quot;=&quot; </span><span class="s1">&amp;&amp; </span><span class="s3">this</span><span class="s1">.right.is_number(compressor);</span>
    <span class="s1">});</span>
    <span class="s1">def_is_number(AST_Sequence, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">return this</span><span class="s1">.tail_node().is_number(compressor);</span>
    <span class="s1">});</span>
    <span class="s1">def_is_number(AST_Conditional, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">return this</span><span class="s1">.consequent.is_number(compressor) &amp;&amp; </span><span class="s3">this</span><span class="s1">.alternative.is_number(compressor);</span>
    <span class="s1">});</span>
<span class="s1">})(</span><span class="s3">function</span><span class="s1">(node, func) {</span>
    <span class="s1">node.DEFMETHOD(</span><span class="s2">&quot;is_number&quot;</span><span class="s1">, func);</span>
<span class="s1">});</span>

<span class="s0">// methods to determine if an expression has a string result type</span>
<span class="s1">(</span><span class="s3">function</span><span class="s1">(def_is_string) {</span>
    <span class="s1">def_is_string(AST_Node, return_false);</span>
    <span class="s1">def_is_string(AST_String, return_true);</span>
    <span class="s1">def_is_string(AST_TemplateString, return_true);</span>
    <span class="s1">def_is_string(AST_UnaryPrefix, </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return this</span><span class="s1">.operator == </span><span class="s2">&quot;typeof&quot;</span><span class="s1">;</span>
    <span class="s1">});</span>
    <span class="s1">def_is_string(AST_Binary, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">return this</span><span class="s1">.operator == </span><span class="s2">&quot;+&quot; </span><span class="s1">&amp;&amp;</span>
            <span class="s1">(</span><span class="s3">this</span><span class="s1">.left.is_string(compressor) || </span><span class="s3">this</span><span class="s1">.right.is_string(compressor));</span>
    <span class="s1">});</span>
    <span class="s1">def_is_string(AST_Assign, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">return </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.operator == </span><span class="s2">&quot;=&quot; </span><span class="s1">|| </span><span class="s3">this</span><span class="s1">.operator == </span><span class="s2">&quot;+=&quot;</span><span class="s1">) &amp;&amp; </span><span class="s3">this</span><span class="s1">.right.is_string(compressor);</span>
    <span class="s1">});</span>
    <span class="s1">def_is_string(AST_Sequence, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">return this</span><span class="s1">.tail_node().is_string(compressor);</span>
    <span class="s1">});</span>
    <span class="s1">def_is_string(AST_Conditional, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">return this</span><span class="s1">.consequent.is_string(compressor) &amp;&amp; </span><span class="s3">this</span><span class="s1">.alternative.is_string(compressor);</span>
    <span class="s1">});</span>
<span class="s1">})(</span><span class="s3">function</span><span class="s1">(node, func) {</span>
    <span class="s1">node.DEFMETHOD(</span><span class="s2">&quot;is_string&quot;</span><span class="s1">, func);</span>
<span class="s1">});</span>

<span class="s1">export </span><span class="s3">function </span><span class="s1">is_undefined(node, compressor) {</span>
    <span class="s3">return </span><span class="s1">(</span>
        <span class="s1">has_flag(node, UNDEFINED)</span>
        <span class="s1">|| node </span><span class="s3">instanceof </span><span class="s1">AST_Undefined</span>
        <span class="s1">|| node </span><span class="s3">instanceof </span><span class="s1">AST_UnaryPrefix</span>
            <span class="s1">&amp;&amp; node.operator == </span><span class="s2">&quot;void&quot;</span>
            <span class="s1">&amp;&amp; !node.expression.has_side_effects(compressor)</span>
    <span class="s1">);</span>
<span class="s1">}</span>

<span class="s0">// Is the node explicitly null or undefined.</span>
<span class="s3">function </span><span class="s1">is_null_or_undefined(node, compressor) {</span>
    <span class="s1">let fixed;</span>
    <span class="s3">return </span><span class="s1">(</span>
        <span class="s1">node </span><span class="s3">instanceof </span><span class="s1">AST_Null</span>
        <span class="s1">|| is_undefined(node, compressor)</span>
        <span class="s1">|| (</span>
            <span class="s1">node </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef</span>
            <span class="s1">&amp;&amp; (fixed = node.definition().fixed) </span><span class="s3">instanceof </span><span class="s1">AST_Node</span>
            <span class="s1">&amp;&amp; is_nullish(fixed, compressor)</span>
        <span class="s1">)</span>
    <span class="s1">);</span>
<span class="s1">}</span>

<span class="s0">// Find out if this expression is optionally chained from a base-point that we</span>
<span class="s0">// can statically analyze as null or undefined.</span>
<span class="s1">export </span><span class="s3">function </span><span class="s1">is_nullish_shortcircuited(node, compressor) {</span>
    <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_PropAccess || node </span><span class="s3">instanceof </span><span class="s1">AST_Call) {</span>
        <span class="s3">return </span><span class="s1">(</span>
            <span class="s1">(node.optional &amp;&amp; is_null_or_undefined(node.expression, compressor))</span>
            <span class="s1">|| is_nullish_shortcircuited(node.expression, compressor)</span>
        <span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Chain) </span><span class="s3">return </span><span class="s1">is_nullish_shortcircuited(node.expression, compressor);</span>
    <span class="s3">return false</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">// Find out if something is == null, or can short circuit into nullish.</span>
<span class="s0">// Used to optimize ?. and ??</span>
<span class="s1">export </span><span class="s3">function </span><span class="s1">is_nullish(node, compressor) {</span>
    <span class="s3">if </span><span class="s1">(is_null_or_undefined(node, compressor)) </span><span class="s3">return true</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s1">is_nullish_shortcircuited(node, compressor);</span>
<span class="s1">}</span>

<span class="s0">// Determine if expression might cause side effects</span>
<span class="s0">// If there's a possibility that a node may change something when it's executed, this returns true</span>
<span class="s1">(</span><span class="s3">function</span><span class="s1">(def_has_side_effects) {</span>
    <span class="s1">def_has_side_effects(AST_Node, return_true);</span>

    <span class="s1">def_has_side_effects(AST_EmptyStatement, return_false);</span>
    <span class="s1">def_has_side_effects(AST_Constant, return_false);</span>
    <span class="s1">def_has_side_effects(AST_This, return_false);</span>

    <span class="s3">function </span><span class="s1">any(list, compressor) {</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = list.length; --i &gt;= </span><span class="s4">0</span><span class="s1">;)</span>
            <span class="s3">if </span><span class="s1">(list[i].has_side_effects(compressor))</span>
                <span class="s3">return true</span><span class="s1">;</span>
        <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">def_has_side_effects(AST_Block, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">return </span><span class="s1">any(</span><span class="s3">this</span><span class="s1">.body, compressor);</span>
    <span class="s1">});</span>
    <span class="s1">def_has_side_effects(AST_Call, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">if </span><span class="s1">(</span>
            <span class="s1">!</span><span class="s3">this</span><span class="s1">.is_callee_pure(compressor)</span>
            <span class="s1">&amp;&amp; (!</span><span class="s3">this</span><span class="s1">.expression.is_call_pure(compressor)</span>
                <span class="s1">|| </span><span class="s3">this</span><span class="s1">.expression.has_side_effects(compressor))</span>
        <span class="s1">) {</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">any(</span><span class="s3">this</span><span class="s1">.args, compressor);</span>
    <span class="s1">});</span>
    <span class="s1">def_has_side_effects(AST_Switch, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">return this</span><span class="s1">.expression.has_side_effects(compressor)</span>
            <span class="s1">|| any(</span><span class="s3">this</span><span class="s1">.body, compressor);</span>
    <span class="s1">});</span>
    <span class="s1">def_has_side_effects(AST_Case, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">return this</span><span class="s1">.expression.has_side_effects(compressor)</span>
            <span class="s1">|| any(</span><span class="s3">this</span><span class="s1">.body, compressor);</span>
    <span class="s1">});</span>
    <span class="s1">def_has_side_effects(AST_Try, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">return this</span><span class="s1">.body.has_side_effects(compressor)</span>
            <span class="s1">|| </span><span class="s3">this</span><span class="s1">.bcatch &amp;&amp; </span><span class="s3">this</span><span class="s1">.bcatch.has_side_effects(compressor)</span>
            <span class="s1">|| </span><span class="s3">this</span><span class="s1">.bfinally &amp;&amp; </span><span class="s3">this</span><span class="s1">.bfinally.has_side_effects(compressor);</span>
    <span class="s1">});</span>
    <span class="s1">def_has_side_effects(AST_If, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">return this</span><span class="s1">.condition.has_side_effects(compressor)</span>
            <span class="s1">|| </span><span class="s3">this</span><span class="s1">.body &amp;&amp; </span><span class="s3">this</span><span class="s1">.body.has_side_effects(compressor)</span>
            <span class="s1">|| </span><span class="s3">this</span><span class="s1">.alternative &amp;&amp; </span><span class="s3">this</span><span class="s1">.alternative.has_side_effects(compressor);</span>
    <span class="s1">});</span>
    <span class="s1">def_has_side_effects(AST_ImportMeta, return_false);</span>
    <span class="s1">def_has_side_effects(AST_LabeledStatement, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">return this</span><span class="s1">.body.has_side_effects(compressor);</span>
    <span class="s1">});</span>
    <span class="s1">def_has_side_effects(AST_SimpleStatement, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">return this</span><span class="s1">.body.has_side_effects(compressor);</span>
    <span class="s1">});</span>
    <span class="s1">def_has_side_effects(AST_Lambda, return_false);</span>
    <span class="s1">def_has_side_effects(AST_Class, </span><span class="s3">function </span><span class="s1">(compressor) {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.extends &amp;&amp; </span><span class="s3">this</span><span class="s1">.extends.has_side_effects(compressor)) {</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">any(</span><span class="s3">this</span><span class="s1">.properties, compressor);</span>
    <span class="s1">});</span>
    <span class="s1">def_has_side_effects(AST_ClassStaticBlock, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">return </span><span class="s1">any(</span><span class="s3">this</span><span class="s1">.body, compressor);</span>
    <span class="s1">});</span>
    <span class="s1">def_has_side_effects(AST_Binary, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">return this</span><span class="s1">.left.has_side_effects(compressor)</span>
            <span class="s1">|| </span><span class="s3">this</span><span class="s1">.right.has_side_effects(compressor);</span>
    <span class="s1">});</span>
    <span class="s1">def_has_side_effects(AST_Assign, return_true);</span>
    <span class="s1">def_has_side_effects(AST_Conditional, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">return this</span><span class="s1">.condition.has_side_effects(compressor)</span>
            <span class="s1">|| </span><span class="s3">this</span><span class="s1">.consequent.has_side_effects(compressor)</span>
            <span class="s1">|| </span><span class="s3">this</span><span class="s1">.alternative.has_side_effects(compressor);</span>
    <span class="s1">});</span>
    <span class="s1">def_has_side_effects(AST_Unary, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">return </span><span class="s1">unary_side_effects.has(</span><span class="s3">this</span><span class="s1">.operator)</span>
            <span class="s1">|| </span><span class="s3">this</span><span class="s1">.expression.has_side_effects(compressor);</span>
    <span class="s1">});</span>
    <span class="s1">def_has_side_effects(AST_SymbolRef, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">return </span><span class="s1">!</span><span class="s3">this</span><span class="s1">.is_declared(compressor) &amp;&amp; !pure_prop_access_globals.has(</span><span class="s3">this</span><span class="s1">.name);</span>
    <span class="s1">});</span>
    <span class="s1">def_has_side_effects(AST_SymbolClassProperty, return_false);</span>
    <span class="s1">def_has_side_effects(AST_SymbolDeclaration, return_false);</span>
    <span class="s1">def_has_side_effects(AST_Object, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">return </span><span class="s1">any(</span><span class="s3">this</span><span class="s1">.properties, compressor);</span>
    <span class="s1">});</span>
    <span class="s1">def_has_side_effects(AST_ObjectProperty, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">return </span><span class="s1">(</span>
            <span class="s3">this</span><span class="s1">.computed_key() &amp;&amp; </span><span class="s3">this</span><span class="s1">.key.has_side_effects(compressor)</span>
            <span class="s1">|| </span><span class="s3">this</span><span class="s1">.value &amp;&amp; </span><span class="s3">this</span><span class="s1">.value.has_side_effects(compressor)</span>
        <span class="s1">);</span>
    <span class="s1">});</span>
    <span class="s1">def_has_side_effects(AST_ClassProperty, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">return </span><span class="s1">(</span>
            <span class="s3">this</span><span class="s1">.computed_key() &amp;&amp; </span><span class="s3">this</span><span class="s1">.key.has_side_effects(compressor)</span>
            <span class="s1">|| </span><span class="s3">this</span><span class="s1">.static &amp;&amp; </span><span class="s3">this</span><span class="s1">.value &amp;&amp; </span><span class="s3">this</span><span class="s1">.value.has_side_effects(compressor)</span>
        <span class="s1">);</span>
    <span class="s1">});</span>
    <span class="s1">def_has_side_effects(AST_ConciseMethod, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">return this</span><span class="s1">.computed_key() &amp;&amp; </span><span class="s3">this</span><span class="s1">.key.has_side_effects(compressor);</span>
    <span class="s1">});</span>
    <span class="s1">def_has_side_effects(AST_ObjectGetter, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">return this</span><span class="s1">.computed_key() &amp;&amp; </span><span class="s3">this</span><span class="s1">.key.has_side_effects(compressor);</span>
    <span class="s1">});</span>
    <span class="s1">def_has_side_effects(AST_ObjectSetter, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">return this</span><span class="s1">.computed_key() &amp;&amp; </span><span class="s3">this</span><span class="s1">.key.has_side_effects(compressor);</span>
    <span class="s1">});</span>
    <span class="s1">def_has_side_effects(AST_Array, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">return </span><span class="s1">any(</span><span class="s3">this</span><span class="s1">.elements, compressor);</span>
    <span class="s1">});</span>
    <span class="s1">def_has_side_effects(AST_Dot, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">if </span><span class="s1">(is_nullish(</span><span class="s3">this</span><span class="s1">, compressor)) </span><span class="s3">return false</span><span class="s1">;</span>
        <span class="s3">return </span><span class="s1">!</span><span class="s3">this</span><span class="s1">.optional &amp;&amp; </span><span class="s3">this</span><span class="s1">.expression.may_throw_on_access(compressor)</span>
            <span class="s1">|| </span><span class="s3">this</span><span class="s1">.expression.has_side_effects(compressor);</span>
    <span class="s1">});</span>
    <span class="s1">def_has_side_effects(AST_Sub, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">if </span><span class="s1">(is_nullish(</span><span class="s3">this</span><span class="s1">, compressor)) </span><span class="s3">return false</span><span class="s1">;</span>

        <span class="s3">return </span><span class="s1">!</span><span class="s3">this</span><span class="s1">.optional &amp;&amp; </span><span class="s3">this</span><span class="s1">.expression.may_throw_on_access(compressor)</span>
            <span class="s1">|| </span><span class="s3">this</span><span class="s1">.expression.has_side_effects(compressor)</span>
            <span class="s1">|| </span><span class="s3">this</span><span class="s1">.property.has_side_effects(compressor);</span>
    <span class="s1">});</span>
    <span class="s1">def_has_side_effects(AST_Chain, </span><span class="s3">function </span><span class="s1">(compressor) {</span>
        <span class="s3">return this</span><span class="s1">.expression.has_side_effects(compressor);</span>
    <span class="s1">});</span>
    <span class="s1">def_has_side_effects(AST_Sequence, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">return </span><span class="s1">any(</span><span class="s3">this</span><span class="s1">.expressions, compressor);</span>
    <span class="s1">});</span>
    <span class="s1">def_has_side_effects(AST_Definitions, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">return </span><span class="s1">any(</span><span class="s3">this</span><span class="s1">.definitions, compressor);</span>
    <span class="s1">});</span>
    <span class="s1">def_has_side_effects(AST_VarDef, </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return this</span><span class="s1">.value;</span>
    <span class="s1">});</span>
    <span class="s1">def_has_side_effects(AST_TemplateSegment, return_false);</span>
    <span class="s1">def_has_side_effects(AST_TemplateString, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">return </span><span class="s1">any(</span><span class="s3">this</span><span class="s1">.segments, compressor);</span>
    <span class="s1">});</span>
<span class="s1">})(</span><span class="s3">function</span><span class="s1">(node, func) {</span>
    <span class="s1">node.DEFMETHOD(</span><span class="s2">&quot;has_side_effects&quot;</span><span class="s1">, func);</span>
<span class="s1">});</span>

<span class="s0">// determine if expression may throw</span>
<span class="s1">(</span><span class="s3">function</span><span class="s1">(def_may_throw) {</span>
    <span class="s1">def_may_throw(AST_Node, return_true);</span>

    <span class="s1">def_may_throw(AST_Constant, return_false);</span>
    <span class="s1">def_may_throw(AST_EmptyStatement, return_false);</span>
    <span class="s1">def_may_throw(AST_Lambda, return_false);</span>
    <span class="s1">def_may_throw(AST_SymbolDeclaration, return_false);</span>
    <span class="s1">def_may_throw(AST_This, return_false);</span>
    <span class="s1">def_may_throw(AST_ImportMeta, return_false);</span>

    <span class="s3">function </span><span class="s1">any(list, compressor) {</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = list.length; --i &gt;= </span><span class="s4">0</span><span class="s1">;)</span>
            <span class="s3">if </span><span class="s1">(list[i].may_throw(compressor))</span>
                <span class="s3">return true</span><span class="s1">;</span>
        <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">def_may_throw(AST_Class, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.extends &amp;&amp; </span><span class="s3">this</span><span class="s1">.extends.may_throw(compressor)) </span><span class="s3">return true</span><span class="s1">;</span>
        <span class="s3">return </span><span class="s1">any(</span><span class="s3">this</span><span class="s1">.properties, compressor);</span>
    <span class="s1">});</span>
    <span class="s1">def_may_throw(AST_ClassStaticBlock, </span><span class="s3">function </span><span class="s1">(compressor) {</span>
        <span class="s3">return </span><span class="s1">any(</span><span class="s3">this</span><span class="s1">.body, compressor);</span>
    <span class="s1">});</span>

    <span class="s1">def_may_throw(AST_Array, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">return </span><span class="s1">any(</span><span class="s3">this</span><span class="s1">.elements, compressor);</span>
    <span class="s1">});</span>
    <span class="s1">def_may_throw(AST_Assign, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.right.may_throw(compressor)) </span><span class="s3">return true</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s1">(!compressor.has_directive(</span><span class="s2">&quot;use strict&quot;</span><span class="s1">)</span>
            <span class="s1">&amp;&amp; </span><span class="s3">this</span><span class="s1">.operator == </span><span class="s2">&quot;=&quot;</span>
            <span class="s1">&amp;&amp; </span><span class="s3">this</span><span class="s1">.left </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef) {</span>
            <span class="s3">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">return this</span><span class="s1">.left.may_throw(compressor);</span>
    <span class="s1">});</span>
    <span class="s1">def_may_throw(AST_Binary, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">return this</span><span class="s1">.left.may_throw(compressor)</span>
            <span class="s1">|| </span><span class="s3">this</span><span class="s1">.right.may_throw(compressor);</span>
    <span class="s1">});</span>
    <span class="s1">def_may_throw(AST_Block, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">return </span><span class="s1">any(</span><span class="s3">this</span><span class="s1">.body, compressor);</span>
    <span class="s1">});</span>
    <span class="s1">def_may_throw(AST_Call, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">if </span><span class="s1">(is_nullish(</span><span class="s3">this</span><span class="s1">, compressor)) </span><span class="s3">return false</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s1">(any(</span><span class="s3">this</span><span class="s1">.args, compressor)) </span><span class="s3">return true</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.is_callee_pure(compressor)) </span><span class="s3">return false</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.expression.may_throw(compressor)) </span><span class="s3">return true</span><span class="s1">;</span>
        <span class="s3">return </span><span class="s1">!(</span><span class="s3">this</span><span class="s1">.expression </span><span class="s3">instanceof </span><span class="s1">AST_Lambda)</span>
            <span class="s1">|| any(</span><span class="s3">this</span><span class="s1">.expression.body, compressor);</span>
    <span class="s1">});</span>
    <span class="s1">def_may_throw(AST_Case, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">return this</span><span class="s1">.expression.may_throw(compressor)</span>
            <span class="s1">|| any(</span><span class="s3">this</span><span class="s1">.body, compressor);</span>
    <span class="s1">});</span>
    <span class="s1">def_may_throw(AST_Conditional, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">return this</span><span class="s1">.condition.may_throw(compressor)</span>
            <span class="s1">|| </span><span class="s3">this</span><span class="s1">.consequent.may_throw(compressor)</span>
            <span class="s1">|| </span><span class="s3">this</span><span class="s1">.alternative.may_throw(compressor);</span>
    <span class="s1">});</span>
    <span class="s1">def_may_throw(AST_Definitions, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">return </span><span class="s1">any(</span><span class="s3">this</span><span class="s1">.definitions, compressor);</span>
    <span class="s1">});</span>
    <span class="s1">def_may_throw(AST_If, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">return this</span><span class="s1">.condition.may_throw(compressor)</span>
            <span class="s1">|| </span><span class="s3">this</span><span class="s1">.body &amp;&amp; </span><span class="s3">this</span><span class="s1">.body.may_throw(compressor)</span>
            <span class="s1">|| </span><span class="s3">this</span><span class="s1">.alternative &amp;&amp; </span><span class="s3">this</span><span class="s1">.alternative.may_throw(compressor);</span>
    <span class="s1">});</span>
    <span class="s1">def_may_throw(AST_LabeledStatement, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">return this</span><span class="s1">.body.may_throw(compressor);</span>
    <span class="s1">});</span>
    <span class="s1">def_may_throw(AST_Object, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">return </span><span class="s1">any(</span><span class="s3">this</span><span class="s1">.properties, compressor);</span>
    <span class="s1">});</span>
    <span class="s1">def_may_throw(AST_ObjectProperty, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s0">// TODO key may throw too</span>
        <span class="s3">return this</span><span class="s1">.value ? </span><span class="s3">this</span><span class="s1">.value.may_throw(compressor) : </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">});</span>
    <span class="s1">def_may_throw(AST_ClassProperty, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">return </span><span class="s1">(</span>
            <span class="s3">this</span><span class="s1">.computed_key() &amp;&amp; </span><span class="s3">this</span><span class="s1">.key.may_throw(compressor)</span>
            <span class="s1">|| </span><span class="s3">this</span><span class="s1">.static &amp;&amp; </span><span class="s3">this</span><span class="s1">.value &amp;&amp; </span><span class="s3">this</span><span class="s1">.value.may_throw(compressor)</span>
        <span class="s1">);</span>
    <span class="s1">});</span>
    <span class="s1">def_may_throw(AST_ConciseMethod, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">return this</span><span class="s1">.computed_key() &amp;&amp; </span><span class="s3">this</span><span class="s1">.key.may_throw(compressor);</span>
    <span class="s1">});</span>
    <span class="s1">def_may_throw(AST_ObjectGetter, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">return this</span><span class="s1">.computed_key() &amp;&amp; </span><span class="s3">this</span><span class="s1">.key.may_throw(compressor);</span>
    <span class="s1">});</span>
    <span class="s1">def_may_throw(AST_ObjectSetter, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">return this</span><span class="s1">.computed_key() &amp;&amp; </span><span class="s3">this</span><span class="s1">.key.may_throw(compressor);</span>
    <span class="s1">});</span>
    <span class="s1">def_may_throw(AST_Return, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">return this</span><span class="s1">.value &amp;&amp; </span><span class="s3">this</span><span class="s1">.value.may_throw(compressor);</span>
    <span class="s1">});</span>
    <span class="s1">def_may_throw(AST_Sequence, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">return </span><span class="s1">any(</span><span class="s3">this</span><span class="s1">.expressions, compressor);</span>
    <span class="s1">});</span>
    <span class="s1">def_may_throw(AST_SimpleStatement, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">return this</span><span class="s1">.body.may_throw(compressor);</span>
    <span class="s1">});</span>
    <span class="s1">def_may_throw(AST_Dot, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">if </span><span class="s1">(is_nullish(</span><span class="s3">this</span><span class="s1">, compressor)) </span><span class="s3">return false</span><span class="s1">;</span>
        <span class="s3">return </span><span class="s1">!</span><span class="s3">this</span><span class="s1">.optional &amp;&amp; </span><span class="s3">this</span><span class="s1">.expression.may_throw_on_access(compressor)</span>
            <span class="s1">|| </span><span class="s3">this</span><span class="s1">.expression.may_throw(compressor);</span>
    <span class="s1">});</span>
    <span class="s1">def_may_throw(AST_Sub, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">if </span><span class="s1">(is_nullish(</span><span class="s3">this</span><span class="s1">, compressor)) </span><span class="s3">return false</span><span class="s1">;</span>
        <span class="s3">return </span><span class="s1">!</span><span class="s3">this</span><span class="s1">.optional &amp;&amp; </span><span class="s3">this</span><span class="s1">.expression.may_throw_on_access(compressor)</span>
            <span class="s1">|| </span><span class="s3">this</span><span class="s1">.expression.may_throw(compressor)</span>
            <span class="s1">|| </span><span class="s3">this</span><span class="s1">.property.may_throw(compressor);</span>
    <span class="s1">});</span>
    <span class="s1">def_may_throw(AST_Chain, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">return this</span><span class="s1">.expression.may_throw(compressor);</span>
    <span class="s1">});</span>
    <span class="s1">def_may_throw(AST_Switch, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">return this</span><span class="s1">.expression.may_throw(compressor)</span>
            <span class="s1">|| any(</span><span class="s3">this</span><span class="s1">.body, compressor);</span>
    <span class="s1">});</span>
    <span class="s1">def_may_throw(AST_SymbolRef, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">return </span><span class="s1">!</span><span class="s3">this</span><span class="s1">.is_declared(compressor) &amp;&amp; !pure_prop_access_globals.has(</span><span class="s3">this</span><span class="s1">.name);</span>
    <span class="s1">});</span>
    <span class="s1">def_may_throw(AST_SymbolClassProperty, return_false);</span>
    <span class="s1">def_may_throw(AST_Try, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">return this</span><span class="s1">.bcatch ? </span><span class="s3">this</span><span class="s1">.bcatch.may_throw(compressor) : </span><span class="s3">this</span><span class="s1">.body.may_throw(compressor)</span>
            <span class="s1">|| </span><span class="s3">this</span><span class="s1">.bfinally &amp;&amp; </span><span class="s3">this</span><span class="s1">.bfinally.may_throw(compressor);</span>
    <span class="s1">});</span>
    <span class="s1">def_may_throw(AST_Unary, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.operator == </span><span class="s2">&quot;typeof&quot; </span><span class="s1">&amp;&amp; </span><span class="s3">this</span><span class="s1">.expression </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef)</span>
            <span class="s3">return false</span><span class="s1">;</span>
        <span class="s3">return this</span><span class="s1">.expression.may_throw(compressor);</span>
    <span class="s1">});</span>
    <span class="s1">def_may_throw(AST_VarDef, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">if </span><span class="s1">(!</span><span class="s3">this</span><span class="s1">.value) </span><span class="s3">return false</span><span class="s1">;</span>
        <span class="s3">return this</span><span class="s1">.value.may_throw(compressor);</span>
    <span class="s1">});</span>
<span class="s1">})(</span><span class="s3">function</span><span class="s1">(node, func) {</span>
    <span class="s1">node.DEFMETHOD(</span><span class="s2">&quot;may_throw&quot;</span><span class="s1">, func);</span>
<span class="s1">});</span>

<span class="s0">// determine if expression is constant</span>
<span class="s1">(</span><span class="s3">function</span><span class="s1">(def_is_constant_expression) {</span>
    <span class="s3">function </span><span class="s1">all_refs_local(scope) {</span>
        <span class="s1">let result = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s1">walk(</span><span class="s3">this</span><span class="s1">, node =&gt; {</span>
            <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef) {</span>
                <span class="s3">if </span><span class="s1">(has_flag(</span><span class="s3">this</span><span class="s1">, INLINED)) {</span>
                    <span class="s1">result = </span><span class="s3">false</span><span class="s1">;</span>
                    <span class="s3">return </span><span class="s1">walk_abort;</span>
                <span class="s1">}</span>
                <span class="s3">var </span><span class="s1">def = node.definition();</span>
                <span class="s3">if </span><span class="s1">(</span>
                    <span class="s1">member(def, </span><span class="s3">this</span><span class="s1">.enclosed)</span>
                    <span class="s1">&amp;&amp; !</span><span class="s3">this</span><span class="s1">.variables.has(def.name)</span>
                <span class="s1">) {</span>
                    <span class="s3">if </span><span class="s1">(scope) {</span>
                        <span class="s3">var </span><span class="s1">scope_def = scope.find_variable(node);</span>
                        <span class="s3">if </span><span class="s1">(def.undeclared ? !scope_def : scope_def === def) {</span>
                            <span class="s1">result = </span><span class="s2">&quot;f&quot;</span><span class="s1">;</span>
                            <span class="s3">return true</span><span class="s1">;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s1">result = </span><span class="s3">false</span><span class="s1">;</span>
                    <span class="s3">return </span><span class="s1">walk_abort;</span>
                <span class="s1">}</span>
                <span class="s3">return true</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_This &amp;&amp; </span><span class="s3">this instanceof </span><span class="s1">AST_Arrow) {</span>
                <span class="s1">result = </span><span class="s3">false</span><span class="s1">;</span>
                <span class="s3">return </span><span class="s1">walk_abort;</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
        <span class="s3">return </span><span class="s1">result;</span>
    <span class="s1">}</span>

    <span class="s1">def_is_constant_expression(AST_Node, return_false);</span>
    <span class="s1">def_is_constant_expression(AST_Constant, return_true);</span>
    <span class="s1">def_is_constant_expression(AST_Class, </span><span class="s3">function</span><span class="s1">(scope) {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.extends &amp;&amp; !</span><span class="s3">this</span><span class="s1">.extends.is_constant_expression(scope)) {</span>
            <span class="s3">return false</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">for </span><span class="s1">(const prop of </span><span class="s3">this</span><span class="s1">.properties) {</span>
            <span class="s3">if </span><span class="s1">(prop.computed_key() &amp;&amp; !prop.key.is_constant_expression(scope)) {</span>
                <span class="s3">return false</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(prop.static &amp;&amp; prop.value &amp;&amp; !prop.value.is_constant_expression(scope)) {</span>
                <span class="s3">return false</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(prop </span><span class="s3">instanceof </span><span class="s1">AST_ClassStaticBlock) {</span>
                <span class="s3">return false</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">return </span><span class="s1">all_refs_local.call(</span><span class="s3">this</span><span class="s1">, scope);</span>
    <span class="s1">});</span>
    <span class="s1">def_is_constant_expression(AST_Lambda, all_refs_local);</span>
    <span class="s1">def_is_constant_expression(AST_Unary, </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return this</span><span class="s1">.expression.is_constant_expression();</span>
    <span class="s1">});</span>
    <span class="s1">def_is_constant_expression(AST_Binary, </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return this</span><span class="s1">.left.is_constant_expression()</span>
            <span class="s1">&amp;&amp; </span><span class="s3">this</span><span class="s1">.right.is_constant_expression();</span>
    <span class="s1">});</span>
    <span class="s1">def_is_constant_expression(AST_Array, </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return this</span><span class="s1">.elements.every((l) =&gt; l.is_constant_expression());</span>
    <span class="s1">});</span>
    <span class="s1">def_is_constant_expression(AST_Object, </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return this</span><span class="s1">.properties.every((l) =&gt; l.is_constant_expression());</span>
    <span class="s1">});</span>
    <span class="s1">def_is_constant_expression(AST_ObjectProperty, </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">!!(!(</span><span class="s3">this</span><span class="s1">.key </span><span class="s3">instanceof </span><span class="s1">AST_Node) &amp;&amp; </span><span class="s3">this</span><span class="s1">.value &amp;&amp; </span><span class="s3">this</span><span class="s1">.value.is_constant_expression());</span>
    <span class="s1">});</span>
<span class="s1">})(</span><span class="s3">function</span><span class="s1">(node, func) {</span>
    <span class="s1">node.DEFMETHOD(</span><span class="s2">&quot;is_constant_expression&quot;</span><span class="s1">, func);</span>
<span class="s1">});</span>


<span class="s0">// may_throw_on_access()</span>
<span class="s0">// returns true if this node may be null, undefined or contain `AST_Accessor`</span>
<span class="s1">(</span><span class="s3">function</span><span class="s1">(def_may_throw_on_access) {</span>
    <span class="s1">AST_Node.DEFMETHOD(</span><span class="s2">&quot;may_throw_on_access&quot;</span><span class="s1">, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">return </span><span class="s1">!compressor.option(</span><span class="s2">&quot;pure_getters&quot;</span><span class="s1">)</span>
            <span class="s1">|| </span><span class="s3">this</span><span class="s1">._dot_throw(compressor);</span>
    <span class="s1">});</span>

    <span class="s3">function </span><span class="s1">is_strict(compressor) {</span>
        <span class="s3">return </span><span class="s1">/strict/.test(compressor.option(</span><span class="s2">&quot;pure_getters&quot;</span><span class="s1">));</span>
    <span class="s1">}</span>

    <span class="s1">def_may_throw_on_access(AST_Node, is_strict);</span>
    <span class="s1">def_may_throw_on_access(AST_Null, return_true);</span>
    <span class="s1">def_may_throw_on_access(AST_Undefined, return_true);</span>
    <span class="s1">def_may_throw_on_access(AST_Constant, return_false);</span>
    <span class="s1">def_may_throw_on_access(AST_Array, return_false);</span>
    <span class="s1">def_may_throw_on_access(AST_Object, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">if </span><span class="s1">(!is_strict(compressor)) </span><span class="s3">return false</span><span class="s1">;</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s3">this</span><span class="s1">.properties.length; --i &gt;=</span><span class="s4">0</span><span class="s1">;)</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.properties[i]._dot_throw(compressor)) </span><span class="s3">return true</span><span class="s1">;</span>
        <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">});</span>
    <span class="s0">// Do not be as strict with classes as we are with objects.</span>
    <span class="s0">// Hopefully the community is not going to abuse static getters and setters.</span>
    <span class="s0">// https://github.com/terser/terser/issues/724#issuecomment-643655656</span>
    <span class="s1">def_may_throw_on_access(AST_Class, return_false);</span>
    <span class="s1">def_may_throw_on_access(AST_ObjectProperty, return_false);</span>
    <span class="s1">def_may_throw_on_access(AST_ObjectGetter, return_true);</span>
    <span class="s1">def_may_throw_on_access(AST_Expansion, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">return this</span><span class="s1">.expression._dot_throw(compressor);</span>
    <span class="s1">});</span>
    <span class="s1">def_may_throw_on_access(AST_Function, return_false);</span>
    <span class="s1">def_may_throw_on_access(AST_Arrow, return_false);</span>
    <span class="s1">def_may_throw_on_access(AST_UnaryPostfix, return_false);</span>
    <span class="s1">def_may_throw_on_access(AST_UnaryPrefix, </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return this</span><span class="s1">.operator == </span><span class="s2">&quot;void&quot;</span><span class="s1">;</span>
    <span class="s1">});</span>
    <span class="s1">def_may_throw_on_access(AST_Binary, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">return </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.operator == </span><span class="s2">&quot;&amp;&amp;&quot; </span><span class="s1">|| </span><span class="s3">this</span><span class="s1">.operator == </span><span class="s2">&quot;||&quot; </span><span class="s1">|| </span><span class="s3">this</span><span class="s1">.operator == </span><span class="s2">&quot;??&quot;</span><span class="s1">)</span>
            <span class="s1">&amp;&amp; (</span><span class="s3">this</span><span class="s1">.left._dot_throw(compressor) || </span><span class="s3">this</span><span class="s1">.right._dot_throw(compressor));</span>
    <span class="s1">});</span>
    <span class="s1">def_may_throw_on_access(AST_Assign, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.logical) </span><span class="s3">return true</span><span class="s1">;</span>

        <span class="s3">return this</span><span class="s1">.operator == </span><span class="s2">&quot;=&quot;</span>
            <span class="s1">&amp;&amp; </span><span class="s3">this</span><span class="s1">.right._dot_throw(compressor);</span>
    <span class="s1">});</span>
    <span class="s1">def_may_throw_on_access(AST_Conditional, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">return this</span><span class="s1">.consequent._dot_throw(compressor)</span>
            <span class="s1">|| </span><span class="s3">this</span><span class="s1">.alternative._dot_throw(compressor);</span>
    <span class="s1">});</span>
    <span class="s1">def_may_throw_on_access(AST_Dot, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">if </span><span class="s1">(!is_strict(compressor)) </span><span class="s3">return false</span><span class="s1">;</span>

        <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.property == </span><span class="s2">&quot;prototype&quot;</span><span class="s1">) {</span>
            <span class="s3">return </span><span class="s1">!(</span>
                <span class="s3">this</span><span class="s1">.expression </span><span class="s3">instanceof </span><span class="s1">AST_Function</span>
                <span class="s1">|| </span><span class="s3">this</span><span class="s1">.expression </span><span class="s3">instanceof </span><span class="s1">AST_Class</span>
            <span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">});</span>
    <span class="s1">def_may_throw_on_access(AST_Chain, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">return this</span><span class="s1">.expression._dot_throw(compressor);</span>
    <span class="s1">});</span>
    <span class="s1">def_may_throw_on_access(AST_Sequence, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">return this</span><span class="s1">.tail_node()._dot_throw(compressor);</span>
    <span class="s1">});</span>
    <span class="s1">def_may_throw_on_access(AST_SymbolRef, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.name === </span><span class="s2">&quot;arguments&quot; </span><span class="s1">&amp;&amp; </span><span class="s3">this</span><span class="s1">.scope </span><span class="s3">instanceof </span><span class="s1">AST_Lambda) </span><span class="s3">return false</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s1">(has_flag(</span><span class="s3">this</span><span class="s1">, UNDEFINED)) </span><span class="s3">return true</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s1">(!is_strict(compressor)) </span><span class="s3">return false</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s1">(is_undeclared_ref(</span><span class="s3">this</span><span class="s1">) &amp;&amp; </span><span class="s3">this</span><span class="s1">.is_declared(compressor)) </span><span class="s3">return false</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.is_immutable()) </span><span class="s3">return false</span><span class="s1">;</span>
        <span class="s3">var </span><span class="s1">fixed = </span><span class="s3">this</span><span class="s1">.fixed_value();</span>
        <span class="s3">return </span><span class="s1">!fixed || fixed._dot_throw(compressor);</span>
    <span class="s1">});</span>
<span class="s1">})(</span><span class="s3">function</span><span class="s1">(node, func) {</span>
    <span class="s1">node.DEFMETHOD(</span><span class="s2">&quot;_dot_throw&quot;</span><span class="s1">, func);</span>
<span class="s1">});</span>

<span class="s1">export </span><span class="s3">function </span><span class="s1">is_lhs(node, parent) {</span>
    <span class="s3">if </span><span class="s1">(parent </span><span class="s3">instanceof </span><span class="s1">AST_Unary &amp;&amp; unary_side_effects.has(parent.operator)) </span><span class="s3">return </span><span class="s1">parent.expression;</span>
    <span class="s3">if </span><span class="s1">(parent </span><span class="s3">instanceof </span><span class="s1">AST_Assign &amp;&amp; parent.left === node) </span><span class="s3">return </span><span class="s1">node;</span>
    <span class="s3">if </span><span class="s1">(parent </span><span class="s3">instanceof </span><span class="s1">AST_ForIn &amp;&amp; parent.init === node) </span><span class="s3">return </span><span class="s1">node;</span>
<span class="s1">}</span>

<span class="s1">(</span><span class="s3">function</span><span class="s1">(def_find_defs) {</span>
    <span class="s3">function </span><span class="s1">to_node(value, orig) {</span>
        <span class="s3">if </span><span class="s1">(value </span><span class="s3">instanceof </span><span class="s1">AST_Node) {</span>
            <span class="s3">if </span><span class="s1">(!(value </span><span class="s3">instanceof </span><span class="s1">AST_Constant)) {</span>
                <span class="s0">// Value may be a function, an array including functions and even a complex assign / block expression,</span>
                <span class="s0">// so it should never be shared in different places.</span>
                <span class="s0">// Otherwise wrong information may be used in the compression phase</span>
                <span class="s1">value = value.clone(</span><span class="s3">true</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s3">return </span><span class="s1">make_node(value.CTOR, orig, value);</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(Array.isArray(value)) </span><span class="s3">return </span><span class="s1">make_node(AST_Array, orig, {</span>
            <span class="s1">elements: value.map(</span><span class="s3">function</span><span class="s1">(value) {</span>
                <span class="s3">return </span><span class="s1">to_node(value, orig);</span>
            <span class="s1">})</span>
        <span class="s1">});</span>
        <span class="s3">if </span><span class="s1">(value &amp;&amp; </span><span class="s3">typeof </span><span class="s1">value == </span><span class="s2">&quot;object&quot;</span><span class="s1">) {</span>
            <span class="s3">var </span><span class="s1">props = [];</span>
            <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">key </span><span class="s3">in </span><span class="s1">value) </span><span class="s3">if </span><span class="s1">(HOP(value, key)) {</span>
                <span class="s1">props.push(make_node(AST_ObjectKeyVal, orig, {</span>
                    <span class="s1">key: key,</span>
                    <span class="s1">value: to_node(value[key], orig)</span>
                <span class="s1">}));</span>
            <span class="s1">}</span>
            <span class="s3">return </span><span class="s1">make_node(AST_Object, orig, {</span>
                <span class="s1">properties: props</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">make_node_from_constant(value, orig);</span>
    <span class="s1">}</span>

    <span class="s1">AST_Toplevel.DEFMETHOD(</span><span class="s2">&quot;resolve_defines&quot;</span><span class="s1">, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">if </span><span class="s1">(!compressor.option(</span><span class="s2">&quot;global_defs&quot;</span><span class="s1">)) </span><span class="s3">return this</span><span class="s1">;</span>
        <span class="s3">this</span><span class="s1">.figure_out_scope({ ie8: compressor.option(</span><span class="s2">&quot;ie8&quot;</span><span class="s1">) });</span>
        <span class="s3">return this</span><span class="s1">.transform(</span><span class="s3">new </span><span class="s1">TreeTransformer(</span><span class="s3">function</span><span class="s1">(node) {</span>
            <span class="s3">var </span><span class="s1">def = node._find_defs(compressor, </span><span class="s2">&quot;&quot;</span><span class="s1">);</span>
            <span class="s3">if </span><span class="s1">(!def) </span><span class="s3">return</span><span class="s1">;</span>
            <span class="s3">var </span><span class="s1">level = </span><span class="s4">0</span><span class="s1">, child = node, parent;</span>
            <span class="s3">while </span><span class="s1">(parent = </span><span class="s3">this</span><span class="s1">.parent(level++)) {</span>
                <span class="s3">if </span><span class="s1">(!(parent </span><span class="s3">instanceof </span><span class="s1">AST_PropAccess)) </span><span class="s3">break</span><span class="s1">;</span>
                <span class="s3">if </span><span class="s1">(parent.expression !== child) </span><span class="s3">break</span><span class="s1">;</span>
                <span class="s1">child = parent;</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(is_lhs(child, parent)) {</span>
                <span class="s3">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">return </span><span class="s1">def;</span>
        <span class="s1">}));</span>
    <span class="s1">});</span>
    <span class="s1">def_find_defs(AST_Node, noop);</span>
    <span class="s1">def_find_defs(AST_Chain, </span><span class="s3">function</span><span class="s1">(compressor, suffix) {</span>
        <span class="s3">return this</span><span class="s1">.expression._find_defs(compressor, suffix);</span>
    <span class="s1">});</span>
    <span class="s1">def_find_defs(AST_Dot, </span><span class="s3">function</span><span class="s1">(compressor, suffix) {</span>
        <span class="s3">return this</span><span class="s1">.expression._find_defs(compressor, </span><span class="s2">&quot;.&quot; </span><span class="s1">+ </span><span class="s3">this</span><span class="s1">.property + suffix);</span>
    <span class="s1">});</span>
    <span class="s1">def_find_defs(AST_SymbolDeclaration, </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">if </span><span class="s1">(!</span><span class="s3">this</span><span class="s1">.global()) </span><span class="s3">return</span><span class="s1">;</span>
    <span class="s1">});</span>
    <span class="s1">def_find_defs(AST_SymbolRef, </span><span class="s3">function</span><span class="s1">(compressor, suffix) {</span>
        <span class="s3">if </span><span class="s1">(!</span><span class="s3">this</span><span class="s1">.global()) </span><span class="s3">return</span><span class="s1">;</span>
        <span class="s3">var </span><span class="s1">defines = compressor.option(</span><span class="s2">&quot;global_defs&quot;</span><span class="s1">);</span>
        <span class="s3">var </span><span class="s1">name = </span><span class="s3">this</span><span class="s1">.name + suffix;</span>
        <span class="s3">if </span><span class="s1">(HOP(defines, name)) </span><span class="s3">return </span><span class="s1">to_node(defines[name], </span><span class="s3">this</span><span class="s1">);</span>
    <span class="s1">});</span>
    <span class="s1">def_find_defs(AST_ImportMeta, </span><span class="s3">function</span><span class="s1">(compressor, suffix) {</span>
        <span class="s3">var </span><span class="s1">defines = compressor.option(</span><span class="s2">&quot;global_defs&quot;</span><span class="s1">);</span>
        <span class="s3">var </span><span class="s1">name = </span><span class="s2">&quot;import.meta&quot; </span><span class="s1">+ suffix;</span>
        <span class="s3">if </span><span class="s1">(HOP(defines, name)) </span><span class="s3">return </span><span class="s1">to_node(defines[name], </span><span class="s3">this</span><span class="s1">);</span>
    <span class="s1">});</span>
<span class="s1">})(</span><span class="s3">function</span><span class="s1">(node, func) {</span>
    <span class="s1">node.DEFMETHOD(</span><span class="s2">&quot;_find_defs&quot;</span><span class="s1">, func);</span>
<span class="s1">});</span>

<span class="s0">// method to negate an expression</span>
<span class="s1">(</span><span class="s3">function</span><span class="s1">(def_negate) {</span>
    <span class="s3">function </span><span class="s1">basic_negation(exp) {</span>
        <span class="s3">return </span><span class="s1">make_node(AST_UnaryPrefix, exp, {</span>
            <span class="s1">operator: </span><span class="s2">&quot;!&quot;</span><span class="s1">,</span>
            <span class="s1">expression: exp</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">best(orig, alt, first_in_statement) {</span>
        <span class="s3">var </span><span class="s1">negated = basic_negation(orig);</span>
        <span class="s3">if </span><span class="s1">(first_in_statement) {</span>
            <span class="s3">var </span><span class="s1">stat = make_node(AST_SimpleStatement, alt, {</span>
                <span class="s1">body: alt</span>
            <span class="s1">});</span>
            <span class="s3">return </span><span class="s1">best_of_expression(negated, stat) === stat ? alt : negated;</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">best_of_expression(negated, alt);</span>
    <span class="s1">}</span>
    <span class="s1">def_negate(AST_Node, </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">basic_negation(</span><span class="s3">this</span><span class="s1">);</span>
    <span class="s1">});</span>
    <span class="s1">def_negate(AST_Statement, </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Cannot negate a statement&quot;</span><span class="s1">);</span>
    <span class="s1">});</span>
    <span class="s1">def_negate(AST_Function, </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">basic_negation(</span><span class="s3">this</span><span class="s1">);</span>
    <span class="s1">});</span>
    <span class="s1">def_negate(AST_Class, </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">basic_negation(</span><span class="s3">this</span><span class="s1">);</span>
    <span class="s1">});</span>
    <span class="s1">def_negate(AST_Arrow, </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">basic_negation(</span><span class="s3">this</span><span class="s1">);</span>
    <span class="s1">});</span>
    <span class="s1">def_negate(AST_UnaryPrefix, </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.operator == </span><span class="s2">&quot;!&quot;</span><span class="s1">)</span>
            <span class="s3">return this</span><span class="s1">.expression;</span>
        <span class="s3">return </span><span class="s1">basic_negation(</span><span class="s3">this</span><span class="s1">);</span>
    <span class="s1">});</span>
    <span class="s1">def_negate(AST_Sequence, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
        <span class="s3">var </span><span class="s1">expressions = </span><span class="s3">this</span><span class="s1">.expressions.slice();</span>
        <span class="s1">expressions.push(expressions.pop().negate(compressor));</span>
        <span class="s3">return </span><span class="s1">make_sequence(</span><span class="s3">this</span><span class="s1">, expressions);</span>
    <span class="s1">});</span>
    <span class="s1">def_negate(AST_Conditional, </span><span class="s3">function</span><span class="s1">(compressor, first_in_statement) {</span>
        <span class="s3">var </span><span class="s1">self = </span><span class="s3">this</span><span class="s1">.clone();</span>
        <span class="s1">self.consequent = self.consequent.negate(compressor);</span>
        <span class="s1">self.alternative = self.alternative.negate(compressor);</span>
        <span class="s3">return </span><span class="s1">best(</span><span class="s3">this</span><span class="s1">, self, first_in_statement);</span>
    <span class="s1">});</span>
    <span class="s1">def_negate(AST_Binary, </span><span class="s3">function</span><span class="s1">(compressor, first_in_statement) {</span>
        <span class="s3">var </span><span class="s1">self = </span><span class="s3">this</span><span class="s1">.clone(), op = </span><span class="s3">this</span><span class="s1">.operator;</span>
        <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;unsafe_comps&quot;</span><span class="s1">)) {</span>
            <span class="s3">switch </span><span class="s1">(op) {</span>
              <span class="s3">case </span><span class="s2">&quot;&lt;=&quot; </span><span class="s1">: self.operator = </span><span class="s2">&quot;&gt;&quot;  </span><span class="s1">; </span><span class="s3">return </span><span class="s1">self;</span>
              <span class="s3">case </span><span class="s2">&quot;&lt;&quot;  </span><span class="s1">: self.operator = </span><span class="s2">&quot;&gt;=&quot; </span><span class="s1">; </span><span class="s3">return </span><span class="s1">self;</span>
              <span class="s3">case </span><span class="s2">&quot;&gt;=&quot; </span><span class="s1">: self.operator = </span><span class="s2">&quot;&lt;&quot;  </span><span class="s1">; </span><span class="s3">return </span><span class="s1">self;</span>
              <span class="s3">case </span><span class="s2">&quot;&gt;&quot;  </span><span class="s1">: self.operator = </span><span class="s2">&quot;&lt;=&quot; </span><span class="s1">; </span><span class="s3">return </span><span class="s1">self;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">switch </span><span class="s1">(op) {</span>
          <span class="s3">case </span><span class="s2">&quot;==&quot; </span><span class="s1">: self.operator = </span><span class="s2">&quot;!=&quot;</span><span class="s1">; </span><span class="s3">return </span><span class="s1">self;</span>
          <span class="s3">case </span><span class="s2">&quot;!=&quot; </span><span class="s1">: self.operator = </span><span class="s2">&quot;==&quot;</span><span class="s1">; </span><span class="s3">return </span><span class="s1">self;</span>
          <span class="s3">case </span><span class="s2">&quot;===&quot;</span><span class="s1">: self.operator = </span><span class="s2">&quot;!==&quot;</span><span class="s1">; </span><span class="s3">return </span><span class="s1">self;</span>
          <span class="s3">case </span><span class="s2">&quot;!==&quot;</span><span class="s1">: self.operator = </span><span class="s2">&quot;===&quot;</span><span class="s1">; </span><span class="s3">return </span><span class="s1">self;</span>
          <span class="s3">case </span><span class="s2">&quot;&amp;&amp;&quot;</span><span class="s1">:</span>
            <span class="s1">self.operator = </span><span class="s2">&quot;||&quot;</span><span class="s1">;</span>
            <span class="s1">self.left = self.left.negate(compressor, first_in_statement);</span>
            <span class="s1">self.right = self.right.negate(compressor);</span>
            <span class="s3">return </span><span class="s1">best(</span><span class="s3">this</span><span class="s1">, self, first_in_statement);</span>
          <span class="s3">case </span><span class="s2">&quot;||&quot;</span><span class="s1">:</span>
            <span class="s1">self.operator = </span><span class="s2">&quot;&amp;&amp;&quot;</span><span class="s1">;</span>
            <span class="s1">self.left = self.left.negate(compressor, first_in_statement);</span>
            <span class="s1">self.right = self.right.negate(compressor);</span>
            <span class="s3">return </span><span class="s1">best(</span><span class="s3">this</span><span class="s1">, self, first_in_statement);</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">basic_negation(</span><span class="s3">this</span><span class="s1">);</span>
    <span class="s1">});</span>
<span class="s1">})(</span><span class="s3">function</span><span class="s1">(node, func) {</span>
    <span class="s1">node.DEFMETHOD(</span><span class="s2">&quot;negate&quot;</span><span class="s1">, </span><span class="s3">function</span><span class="s1">(compressor, first_in_statement) {</span>
        <span class="s3">return </span><span class="s1">func.call(</span><span class="s3">this</span><span class="s1">, compressor, first_in_statement);</span>
    <span class="s1">});</span>
<span class="s1">});</span>

<span class="s0">// Is the callee of this function pure?</span>
<span class="s3">var </span><span class="s1">global_pure_fns = makePredicate(</span><span class="s2">&quot;Boolean decodeURI decodeURIComponent Date encodeURI encodeURIComponent Error escape EvalError isFinite isNaN Number Object parseFloat parseInt RangeError ReferenceError String SyntaxError TypeError unescape URIError&quot;</span><span class="s1">);</span>
<span class="s1">AST_Call.DEFMETHOD(</span><span class="s2">&quot;is_callee_pure&quot;</span><span class="s1">, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
    <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;unsafe&quot;</span><span class="s1">)) {</span>
        <span class="s3">var </span><span class="s1">expr = </span><span class="s3">this</span><span class="s1">.expression;</span>
        <span class="s3">var </span><span class="s1">first_arg = (</span><span class="s3">this</span><span class="s1">.args &amp;&amp; </span><span class="s3">this</span><span class="s1">.args[</span><span class="s4">0</span><span class="s1">] &amp;&amp; </span><span class="s3">this</span><span class="s1">.args[</span><span class="s4">0</span><span class="s1">].evaluate(compressor));</span>
        <span class="s3">if </span><span class="s1">(</span>
            <span class="s1">expr.expression &amp;&amp; expr.expression.name === </span><span class="s2">&quot;hasOwnProperty&quot; </span><span class="s1">&amp;&amp;</span>
            <span class="s1">(first_arg == </span><span class="s3">null </span><span class="s1">|| first_arg.thedef &amp;&amp; first_arg.thedef.undeclared)</span>
        <span class="s1">) {</span>
            <span class="s3">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(is_undeclared_ref(expr) &amp;&amp; global_pure_fns.has(expr.name)) </span><span class="s3">return true</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s1">(</span>
            <span class="s1">expr </span><span class="s3">instanceof </span><span class="s1">AST_Dot</span>
            <span class="s1">&amp;&amp; is_undeclared_ref(expr.expression)</span>
            <span class="s1">&amp;&amp; is_pure_native_fn(expr.expression.name, expr.property)</span>
        <span class="s1">) {</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s1">!!has_annotation(</span><span class="s3">this</span><span class="s1">, _PURE) || !compressor.pure_funcs(</span><span class="s3">this</span><span class="s1">);</span>
<span class="s1">});</span>

<span class="s0">// If I call this, is it a pure function?</span>
<span class="s1">AST_Node.DEFMETHOD(</span><span class="s2">&quot;is_call_pure&quot;</span><span class="s1">, return_false);</span>
<span class="s1">AST_Dot.DEFMETHOD(</span><span class="s2">&quot;is_call_pure&quot;</span><span class="s1">, </span><span class="s3">function</span><span class="s1">(compressor) {</span>
    <span class="s3">if </span><span class="s1">(!compressor.option(</span><span class="s2">&quot;unsafe&quot;</span><span class="s1">)) </span><span class="s3">return</span><span class="s1">;</span>
    <span class="s1">const expr = </span><span class="s3">this</span><span class="s1">.expression;</span>

    <span class="s1">let native_obj;</span>
    <span class="s3">if </span><span class="s1">(expr </span><span class="s3">instanceof </span><span class="s1">AST_Array) {</span>
        <span class="s1">native_obj = </span><span class="s2">&quot;Array&quot;</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(expr.is_boolean()) {</span>
        <span class="s1">native_obj = </span><span class="s2">&quot;Boolean&quot;</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(expr.is_number(compressor)) {</span>
        <span class="s1">native_obj = </span><span class="s2">&quot;Number&quot;</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(expr </span><span class="s3">instanceof </span><span class="s1">AST_RegExp) {</span>
        <span class="s1">native_obj = </span><span class="s2">&quot;RegExp&quot;</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(expr.is_string(compressor)) {</span>
        <span class="s1">native_obj = </span><span class="s2">&quot;String&quot;</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(!</span><span class="s3">this</span><span class="s1">.may_throw_on_access(compressor)) {</span>
        <span class="s1">native_obj = </span><span class="s2">&quot;Object&quot;</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s1">native_obj != </span><span class="s3">null </span><span class="s1">&amp;&amp; is_pure_native_method(native_obj, </span><span class="s3">this</span><span class="s1">.property);</span>
<span class="s1">});</span>

<span class="s0">// tell me if a statement aborts</span>
<span class="s1">export const aborts = (thing) =&gt; thing &amp;&amp; thing.aborts();</span>

<span class="s1">(</span><span class="s3">function</span><span class="s1">(def_aborts) {</span>
    <span class="s1">def_aborts(AST_Statement, return_null);</span>
    <span class="s1">def_aborts(AST_Jump, return_this);</span>
    <span class="s3">function </span><span class="s1">block_aborts() {</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; </span><span class="s3">this</span><span class="s1">.body.length; i++) {</span>
            <span class="s3">if </span><span class="s1">(aborts(</span><span class="s3">this</span><span class="s1">.body[i])) {</span>
                <span class="s3">return this</span><span class="s1">.body[i];</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">def_aborts(AST_Import, return_null);</span>
    <span class="s1">def_aborts(AST_BlockStatement, block_aborts);</span>
    <span class="s1">def_aborts(AST_SwitchBranch, block_aborts);</span>
    <span class="s1">def_aborts(AST_DefClass, </span><span class="s3">function </span><span class="s1">() {</span>
        <span class="s3">for </span><span class="s1">(const prop of </span><span class="s3">this</span><span class="s1">.properties) {</span>
            <span class="s3">if </span><span class="s1">(prop </span><span class="s3">instanceof </span><span class="s1">AST_ClassStaticBlock) {</span>
                <span class="s3">if </span><span class="s1">(prop.aborts()) </span><span class="s3">return </span><span class="s1">prop;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">});</span>
    <span class="s1">def_aborts(AST_ClassStaticBlock, block_aborts);</span>
    <span class="s1">def_aborts(AST_If, </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return this</span><span class="s1">.alternative &amp;&amp; aborts(</span><span class="s3">this</span><span class="s1">.body) &amp;&amp; aborts(</span><span class="s3">this</span><span class="s1">.alternative) &amp;&amp; </span><span class="s3">this</span><span class="s1">;</span>
    <span class="s1">});</span>
<span class="s1">})(</span><span class="s3">function</span><span class="s1">(node, func) {</span>
    <span class="s1">node.DEFMETHOD(</span><span class="s2">&quot;aborts&quot;</span><span class="s1">, func);</span>
<span class="s1">});</span>

<span class="s1">AST_Node.DEFMETHOD(</span><span class="s2">&quot;contains_this&quot;</span><span class="s1">, </span><span class="s3">function</span><span class="s1">() {</span>
    <span class="s3">return </span><span class="s1">walk(</span><span class="s3">this</span><span class="s1">, node =&gt; {</span>
        <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_This) </span><span class="s3">return </span><span class="s1">walk_abort;</span>
        <span class="s3">if </span><span class="s1">(</span>
            <span class="s1">node !== </span><span class="s3">this</span>
            <span class="s1">&amp;&amp; node </span><span class="s3">instanceof </span><span class="s1">AST_Scope</span>
            <span class="s1">&amp;&amp; !(node </span><span class="s3">instanceof </span><span class="s1">AST_Arrow)</span>
        <span class="s1">) {</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
<span class="s1">});</span>

<span class="s1">export </span><span class="s3">function </span><span class="s1">is_modified(compressor, tw, node, value, level, immutable) {</span>
    <span class="s3">var </span><span class="s1">parent = tw.parent(level);</span>
    <span class="s3">var </span><span class="s1">lhs = is_lhs(node, parent);</span>
    <span class="s3">if </span><span class="s1">(lhs) </span><span class="s3">return </span><span class="s1">lhs;</span>
    <span class="s3">if </span><span class="s1">(!immutable</span>
        <span class="s1">&amp;&amp; parent </span><span class="s3">instanceof </span><span class="s1">AST_Call</span>
        <span class="s1">&amp;&amp; parent.expression === node</span>
        <span class="s1">&amp;&amp; !(value </span><span class="s3">instanceof </span><span class="s1">AST_Arrow)</span>
        <span class="s1">&amp;&amp; !(value </span><span class="s3">instanceof </span><span class="s1">AST_Class)</span>
        <span class="s1">&amp;&amp; !parent.is_callee_pure(compressor)</span>
        <span class="s1">&amp;&amp; (!(value </span><span class="s3">instanceof </span><span class="s1">AST_Function)</span>
            <span class="s1">|| !(parent </span><span class="s3">instanceof </span><span class="s1">AST_New) &amp;&amp; value.contains_this())) {</span>
        <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(parent </span><span class="s3">instanceof </span><span class="s1">AST_Array) {</span>
        <span class="s3">return </span><span class="s1">is_modified(compressor, tw, parent, parent, level + </span><span class="s4">1</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(parent </span><span class="s3">instanceof </span><span class="s1">AST_ObjectKeyVal &amp;&amp; node === parent.value) {</span>
        <span class="s3">var </span><span class="s1">obj = tw.parent(level + </span><span class="s4">1</span><span class="s1">);</span>
        <span class="s3">return </span><span class="s1">is_modified(compressor, tw, obj, obj, level + </span><span class="s4">2</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(parent </span><span class="s3">instanceof </span><span class="s1">AST_PropAccess &amp;&amp; parent.expression === node) {</span>
        <span class="s3">var </span><span class="s1">prop = read_property(value, parent.property);</span>
        <span class="s3">return </span><span class="s1">!immutable &amp;&amp; is_modified(compressor, tw, parent, prop, level + </span><span class="s4">1</span><span class="s1">);</span>
    <span class="s1">}</span>
<span class="s1">}</span>
</pre>
</body>
</html>
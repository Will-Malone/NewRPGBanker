<html>
<head>
<title>createEventsSocketEndpoint.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
.s1 { color: #6a8759;}
.s2 { color: #6897bb; font-style: italic;}
.s3 { color: #cc7832; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
createEventsSocketEndpoint.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;PROTOCOL_VERSION&quot;</span><span class="s0">,</span><span class="s1">&quot;parseMessage&quot;</span><span class="s0">,</span><span class="s1">&quot;data&quot;</span><span class="s0">,</span><span class="s1">&quot;message&quot;</span><span class="s0">,</span><span class="s1">&quot;JSON&quot;</span><span class="s0">,</span><span class="s1">&quot;parse&quot;</span><span class="s0">,</span><span class="s1">&quot;version&quot;</span><span class="s0">,</span><span class="s1">&quot;logger&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;serializeMessage&quot;</span><span class="s0">,</span><span class="s1">&quot;toSerialize&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;prettyFormat&quot;</span><span class="s0">,</span><span class="s1">&quot;escapeString&quot;</span><span class="s0">,</span><span class="s1">&quot;highlight&quot;</span><span class="s0">,</span><span class="s1">&quot;maxDepth&quot;</span><span class="s0">,</span><span class="s1">&quot;min&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;item&quot;</span><span class="s0">,</span><span class="s1">&quot;plugins&quot;</span><span class="s0">,</span><span class="s1">&quot;ReactElement&quot;</span><span class="s0">,</span><span class="s1">&quot;stringify&quot;</span><span class="s0">,</span><span class="s1">&quot;e&quot;</span><span class="s0">,</span><span class="s1">&quot;createEventsSocketEndpoint&quot;</span><span class="s0">,</span><span class="s1">&quot;broadcast&quot;</span><span class="s0">,</span><span class="s1">&quot;wss&quot;</span><span class="s0">,</span><span class="s1">&quot;WebSocketServer&quot;</span><span class="s0">,</span><span class="s1">&quot;noServer&quot;</span><span class="s0">,</span><span class="s1">&quot;verifyClient&quot;</span><span class="s0">,</span><span class="s1">&quot;origin&quot;</span><span class="s0">,</span><span class="s1">&quot;startsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;clients&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;nextClientId&quot;</span><span class="s0">,</span><span class="s1">&quot;broadCastEvent&quot;</span><span class="s0">,</span><span class="s1">&quot;size&quot;</span><span class="s0">,</span><span class="s1">&quot;serialized&quot;</span><span class="s0">,</span><span class="s1">&quot;ws&quot;</span><span class="s0">,</span><span class="s1">&quot;values&quot;</span><span class="s0">,</span><span class="s1">&quot;send&quot;</span><span class="s0">,</span><span class="s1">&quot;toString&quot;</span><span class="s0">,</span><span class="s1">&quot;on&quot;</span><span class="s0">,</span><span class="s1">&quot;clientWs&quot;</span><span class="s0">,</span><span class="s1">&quot;clientId&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;onclose&quot;</span><span class="s0">,</span><span class="s1">&quot;onerror&quot;</span><span class="s0">,</span><span class="s1">&quot;delete&quot;</span><span class="s0">,</span><span class="s1">&quot;onmessage&quot;</span><span class="s0">,</span><span class="s1">&quot;event&quot;</span><span class="s0">,</span><span class="s1">&quot;command&quot;</span><span class="s0">,</span><span class="s1">&quot;params&quot;</span><span class="s0">,</span><span class="s1">&quot;server&quot;</span><span class="s0">,</span><span class="s1">&quot;reportEvent&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/websocket/createEventsSocketEndpoint.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import {Server as WebSocketServer} from 'ws';</span><span class="s3">\n</span><span class="s1">import {logger} from '@react-native-community/cli-tools';</span><span class="s3">\n</span><span class="s1">import prettyFormat from 'pretty-format';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The eventsSocket websocket listens at the 'events/` for websocket</span><span class="s3">\n </span><span class="s1">* connections, on which all Metro reports will be emitted.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This is mostly useful for developer tools (clients) that wants to monitor Metro,</span><span class="s3">\n </span><span class="s1">* and the apps connected to Metro.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* The eventsSocket provides the following features:</span><span class="s3">\n </span><span class="s1">* - it reports any Metro event (that is reported through a reporter) to all clients</span><span class="s3">\n </span><span class="s1">* - it reports any console.log's (and friends) from the connected app to all clients</span><span class="s3">\n </span><span class="s1">*   (as client_log event)</span><span class="s3">\n </span><span class="s1">* - it allows connected clients to send commands through Metro to the connected app.</span><span class="s3">\n </span><span class="s1">*   This reuses the generic command mechanism.</span><span class="s3">\n </span><span class="s1">*   Two useful commands are 'reload' and 'devmenu'.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">type Command = {</span><span class="s3">\n  </span><span class="s1">version: number;</span><span class="s3">\n  </span><span class="s1">type: 'command';</span><span class="s3">\n  </span><span class="s1">command: string;</span><span class="s3">\n  </span><span class="s1">params?: any;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This number is used to version the communication protocol between</span><span class="s3">\n </span><span class="s1">* Dev tooling like Flipper and Metro, so that in the future we can recognize</span><span class="s3">\n </span><span class="s1">* messages coming from old clients, so that it will be simpler to implement</span><span class="s3">\n </span><span class="s1">* backward compatibility.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* We start at 2 as the protocol is currently the same as used internally at FB,</span><span class="s3">\n </span><span class="s1">* which happens to be at version 2 as well.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const PROTOCOL_VERSION = 2;</span><span class="s3">\n\n</span><span class="s1">function parseMessage&lt;T extends Object&gt;(data: string): T | undefined {</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">const message = JSON.parse(data);</span><span class="s3">\n    </span><span class="s1">if (message.version === PROTOCOL_VERSION) {</span><span class="s3">\n      </span><span class="s1">return message;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">logger.error(</span><span class="s3">\n      </span><span class="s1">'Received message had wrong protocol version: ' + message.version,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">} catch {</span><span class="s3">\n    </span><span class="s1">logger.error('Failed to parse the message as JSON:</span><span class="s3">\\</span><span class="s1">n' + data);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return undefined;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Two types of messages will arrive in this function,</span><span class="s3">\n </span><span class="s1">* 1) messages generated by Metro itself (through the reporter abstraction)</span><span class="s3">\n </span><span class="s1">*    those are yet to be serialized, and can contain any kind of data structure</span><span class="s3">\n </span><span class="s1">* 2) a specific event generated by Metro is `client_log`, which describes</span><span class="s3">\n </span><span class="s1">*    console.* calls in the app.</span><span class="s3">\n </span><span class="s1">*    The arguments send to the console are pretty printed so that they can be</span><span class="s3">\n </span><span class="s1">*    displayed in a nicer way in dev tools</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param message</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function serializeMessage(message: any) {</span><span class="s3">\n  </span><span class="s1">// We do want to send Metro report messages, but their contents is not guaranteed to be serializable.</span><span class="s3">\n  </span><span class="s1">// For some known types we will pretty print otherwise not serializable parts first:</span><span class="s3">\n  </span><span class="s1">let toSerialize = message;</span><span class="s3">\n  </span><span class="s1">if (message &amp;&amp; message.error &amp;&amp; message.error instanceof Error) {</span><span class="s3">\n    </span><span class="s1">toSerialize = {</span><span class="s3">\n      </span><span class="s1">...message,</span><span class="s3">\n      </span><span class="s1">error: prettyFormat(message.error, {</span><span class="s3">\n        </span><span class="s1">escapeString: true,</span><span class="s3">\n        </span><span class="s1">highlight: true,</span><span class="s3">\n        </span><span class="s1">maxDepth: 3,</span><span class="s3">\n        </span><span class="s1">min: true,</span><span class="s3">\n      </span><span class="s1">}),</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">} else if (message &amp;&amp; message.type === 'client_log') {</span><span class="s3">\n    </span><span class="s1">toSerialize = {</span><span class="s3">\n      </span><span class="s1">...message,</span><span class="s3">\n      </span><span class="s1">data: message.data.map((item: any) =&gt;</span><span class="s3">\n        </span><span class="s1">typeof item === 'string'</span><span class="s3">\n          </span><span class="s1">? item</span><span class="s3">\n          </span><span class="s1">: prettyFormat(item, {</span><span class="s3">\n              </span><span class="s1">escapeString: true,</span><span class="s3">\n              </span><span class="s1">highlight: true,</span><span class="s3">\n              </span><span class="s1">maxDepth: 3,</span><span class="s3">\n              </span><span class="s1">min: true,</span><span class="s3">\n              </span><span class="s1">plugins: [prettyFormat.plugins.ReactElement],</span><span class="s3">\n            </span><span class="s1">}),</span><span class="s3">\n      </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">return JSON.stringify(toSerialize);</span><span class="s3">\n  </span><span class="s1">} catch (e) {</span><span class="s3">\n    </span><span class="s1">logger.error('Failed to serialize: ' + e);</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Starts the eventsSocket at the given path</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function createEventsSocketEndpoint(</span><span class="s3">\n  </span><span class="s1">broadcast: (method: string, params?: Record&lt;string, any&gt;) =&gt; void,</span><span class="s3">\n</span><span class="s1">): {</span><span class="s3">\n  </span><span class="s1">server: WebSocketServer;</span><span class="s3">\n  </span><span class="s1">reportEvent: (event: any) =&gt; void;</span><span class="s3">\n</span><span class="s1">} {</span><span class="s3">\n  </span><span class="s1">const wss = new WebSocketServer({</span><span class="s3">\n    </span><span class="s1">noServer: true,</span><span class="s3">\n    </span><span class="s1">verifyClient({origin}: {origin: string}) {</span><span class="s3">\n      </span><span class="s1">// This exposes the full JS logs and enables issuing commands like reload</span><span class="s3">\n      </span><span class="s1">// so let's make sure only locally running stuff can connect to it</span><span class="s3">\n      </span><span class="s1">// origin is only checked if it is set, e.g. when the request is made from a (CORS) browser</span><span class="s3">\n      </span><span class="s1">// any 'back-end' connection isn't CORS at all, and has full control over the origin header,</span><span class="s3">\n      </span><span class="s1">// so there is no point in checking it security wise</span><span class="s3">\n      </span><span class="s1">return (</span><span class="s3">\n        </span><span class="s1">!origin ||</span><span class="s3">\n        </span><span class="s1">origin.startsWith('http://localhost:') ||</span><span class="s3">\n        </span><span class="s1">origin.startsWith('file:')</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">const clients = new Map();</span><span class="s3">\n  </span><span class="s1">let nextClientId = 0;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* broadCastEvent is called by reportEvent (below), which is called by the</span><span class="s3">\n   </span><span class="s1">* default reporter of this server, to make sure that all Metro events are</span><span class="s3">\n   </span><span class="s1">* broadcasted to all connected clients</span><span class="s3">\n   </span><span class="s1">* (that is, all devtools such as Flipper, _not_: connected apps)</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param message</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">function broadCastEvent(message: any) {</span><span class="s3">\n    </span><span class="s1">if (!clients.size) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const serialized = serializeMessage(message);</span><span class="s3">\n    </span><span class="s1">if (!serialized) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">for (const ws of clients.values()) {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">ws.send(serialized);</span><span class="s3">\n      </span><span class="s1">} catch (e) {</span><span class="s3">\n        </span><span class="s1">logger.error(</span><span class="s3">\n          </span><span class="s1">`Failed to send broadcast to client due to:</span><span class="s3">\\</span><span class="s1">n ${(e as any).toString()}`,</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">wss.on('connection', function (clientWs) {</span><span class="s3">\n    </span><span class="s1">const clientId = `client#${nextClientId++}`;</span><span class="s3">\n\n    </span><span class="s1">clients.set(clientId, clientWs);</span><span class="s3">\n\n    </span><span class="s1">clientWs.onclose = clientWs.onerror = () =&gt; {</span><span class="s3">\n      </span><span class="s1">clients.delete(clientId);</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">clientWs.onmessage = (event) =&gt; {</span><span class="s3">\n      </span><span class="s1">const message: Command | undefined = parseMessage(event.data.toString());</span><span class="s3">\n      </span><span class="s1">if (message == null) {</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (message.type === 'command') {</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n          </span><span class="s1">/**</span><span class="s3">\n           </span><span class="s1">* messageSocket.broadcast (not to be confused with our own broadcast above)</span><span class="s3">\n           </span><span class="s1">* forwards a command to all connected React Native applications.</span><span class="s3">\n           </span><span class="s1">*/</span><span class="s3">\n          </span><span class="s1">broadcast(message.command, message.params);</span><span class="s3">\n        </span><span class="s1">} catch (e) {</span><span class="s3">\n          </span><span class="s1">logger.error('Failed to forward message to clients: ', e as any);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">logger.error('Unknown message type: ', message.type);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">server: wss,</span><span class="s3">\n    </span><span class="s1">reportEvent: (event: any) =&gt; {</span><span class="s3">\n      </span><span class="s1">broadCastEvent(event);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">}</span></pre>
</body>
</html>
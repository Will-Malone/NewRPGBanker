<html>
<head>
<title>eslint-plugin-react-hooks.production.min.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
.s5 { color: #4646f1;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
eslint-plugin-react-hooks.production.min.js</font>
</center></td></tr></table>
<pre><span class="s0">/** 
 * @license React 
 * eslint-plugin-react-hooks.production.min.js 
 * 
 * Copyright (c) Facebook, Inc. and its affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>
<span class="s2">'use strict'</span><span class="s1">;</span><span class="s3">function </span><span class="s1">ca(a,c){</span><span class="s3">if</span><span class="s1">(a){</span><span class="s3">if</span><span class="s1">(</span><span class="s2">&quot;string&quot;</span><span class="s1">===</span><span class="s3">typeof </span><span class="s1">a)</span><span class="s3">return </span><span class="s1">da(a,c);</span><span class="s3">var </span><span class="s1">b=Object.prototype.toString.call(a).slice(</span><span class="s4">8</span><span class="s1">,-</span><span class="s4">1</span><span class="s1">);</span><span class="s2">&quot;Object&quot;</span><span class="s1">===b&amp;&amp;a.constructor&amp;&amp;(b=a.constructor.name);</span><span class="s3">if</span><span class="s1">(</span><span class="s2">&quot;Map&quot;</span><span class="s1">===b||</span><span class="s2">&quot;Set&quot;</span><span class="s1">===b)</span><span class="s3">return </span><span class="s1">Array.from(a);</span><span class="s3">if</span><span class="s1">(</span><span class="s2">&quot;Arguments&quot;</span><span class="s1">===b||/^(?:Ui|I)nt(?:</span><span class="s4">8</span><span class="s1">|</span><span class="s4">16</span><span class="s1">|</span><span class="s4">32</span><span class="s1">)(?:Clamped)?Array$/.test(b))</span><span class="s3">return </span><span class="s1">da(a,c)}}</span><span class="s3">function </span><span class="s1">da(a,c){</span><span class="s3">if</span><span class="s1">(</span><span class="s3">null</span><span class="s1">==c||c&gt;a.length)c=a.length;</span><span class="s3">for</span><span class="s1">(</span><span class="s3">var </span><span class="s1">b=</span><span class="s4">0</span><span class="s1">,d=Array(c);b&lt;c;b++)d[b]=a[b];</span><span class="s3">return </span><span class="s1">d}</span>
<span class="s3">function </span><span class="s1">D(a,c){</span><span class="s3">var </span><span class="s1">b;</span><span class="s3">if</span><span class="s1">(</span><span class="s2">&quot;undefined&quot;</span><span class="s1">===</span><span class="s3">typeof </span><span class="s1">Symbol||</span><span class="s3">null</span><span class="s1">==a[Symbol.iterator]){</span><span class="s3">if</span><span class="s1">(Array.isArray(a)||(b=ca(a))||c&amp;&amp;a&amp;&amp;</span><span class="s2">&quot;number&quot;</span><span class="s1">===</span><span class="s3">typeof </span><span class="s1">a.length){b&amp;&amp;(a=b);</span><span class="s3">var </span><span class="s1">d=</span><span class="s4">0</span><span class="s1">;c=</span><span class="s3">function</span><span class="s1">(){};</span><span class="s3">return</span><span class="s1">{s:c,n:</span><span class="s3">function</span><span class="s1">(){</span><span class="s3">return </span><span class="s1">d&gt;=a.length?{done:!</span><span class="s4">0</span><span class="s1">}:{done:!</span><span class="s4">1</span><span class="s1">,value:a[d++]}},e:</span><span class="s3">function</span><span class="s1">(a){</span><span class="s3">throw </span><span class="s1">a;},f:c}}</span><span class="s3">throw new </span><span class="s1">TypeError(</span><span class="s2">&quot;Invalid attempt to iterate non-iterable instance.</span><span class="s5">\n</span><span class="s2">In order to be iterable, non-array objects must have a [Symbol.iterator]() method.&quot;</span><span class="s1">);}</span><span class="s3">var </span><span class="s1">f=!</span><span class="s4">0</span><span class="s1">,p=!</span><span class="s4">1</span><span class="s1">,g;</span><span class="s3">return</span><span class="s1">{s:</span><span class="s3">function</span><span class="s1">(){b=a[Symbol.iterator]()},</span>
<span class="s1">n:</span><span class="s3">function</span><span class="s1">(){</span><span class="s3">var </span><span class="s1">a=b.next();f=a.done;</span><span class="s3">return </span><span class="s1">a},e:</span><span class="s3">function</span><span class="s1">(a){p=!</span><span class="s4">0</span><span class="s1">;g=a},f:</span><span class="s3">function</span><span class="s1">(){</span><span class="s3">try</span><span class="s1">{f||</span><span class="s3">null</span><span class="s1">==b.</span><span class="s3">return</span><span class="s1">||b.</span><span class="s3">return</span><span class="s1">()}</span><span class="s3">finally</span><span class="s1">{</span><span class="s3">if</span><span class="s1">(p)</span><span class="s3">throw </span><span class="s1">g;}}}}</span><span class="s3">function </span><span class="s1">G(a){</span><span class="s3">if</span><span class="s1">(</span><span class="s2">&quot;Identifier&quot;</span><span class="s1">===a.type)</span><span class="s3">return</span><span class="s1">/^use[A-Z0-9].*$/.test(a.name);</span><span class="s3">if</span><span class="s1">(</span><span class="s2">&quot;MemberExpression&quot;</span><span class="s1">===a.type&amp;&amp;!a.computed&amp;&amp;G(a.property)){a=a.object;</span><span class="s3">var </span><span class="s1">c=/^[A-Z].*/;</span><span class="s3">return</span><span class="s2">&quot;Identifier&quot;</span><span class="s1">===a.type&amp;&amp;c.test(a.name)}</span><span class="s3">return</span><span class="s1">!</span><span class="s4">1</span><span class="s1">}</span><span class="s3">function </span><span class="s1">ea(a){</span><span class="s3">return</span><span class="s2">&quot;Identifier&quot;</span><span class="s1">===a.type?!/^[a-z]/.test(a.name):!</span><span class="s4">1</span><span class="s1">}</span>
<span class="s3">function </span><span class="s1">fa(a,c){</span><span class="s3">return </span><span class="s1">a.name===c||</span><span class="s2">&quot;MemberExpression&quot;</span><span class="s1">===a.type&amp;&amp;</span><span class="s2">&quot;React&quot;</span><span class="s1">===a.object.name&amp;&amp;a.property.name===c}</span><span class="s3">function </span><span class="s1">ha(a){</span><span class="s3">return</span><span class="s1">!!(a.parent&amp;&amp;a.parent.callee&amp;&amp;fa(a.parent.callee,</span><span class="s2">&quot;forwardRef&quot;</span><span class="s1">))}</span><span class="s3">function </span><span class="s1">ia(a){</span><span class="s3">return</span><span class="s1">!!(a.parent&amp;&amp;a.parent.callee&amp;&amp;fa(a.parent.callee,</span><span class="s2">&quot;memo&quot;</span><span class="s1">))}</span><span class="s3">function </span><span class="s1">ma(a){</span><span class="s3">for</span><span class="s1">(;a;){</span><span class="s3">var </span><span class="s1">c=na(a);</span><span class="s3">if</span><span class="s1">(c&amp;&amp;(ea(c)||G(c))||ha(a)||ia(a))</span><span class="s3">return</span><span class="s1">!</span><span class="s4">0</span><span class="s1">;a=a.parent}</span><span class="s3">return</span><span class="s1">!</span><span class="s4">1</span><span class="s1">}</span>
<span class="s3">function </span><span class="s1">na(a){</span><span class="s3">if</span><span class="s1">(</span><span class="s2">&quot;FunctionDeclaration&quot;</span><span class="s1">===a.type||</span><span class="s2">&quot;FunctionExpression&quot;</span><span class="s1">===a.type&amp;&amp;a.id)</span><span class="s3">return </span><span class="s1">a.id;</span><span class="s3">if</span><span class="s1">(</span><span class="s2">&quot;FunctionExpression&quot;</span><span class="s1">===a.type||</span><span class="s2">&quot;ArrowFunctionExpression&quot;</span><span class="s1">===a.type)</span><span class="s3">return</span><span class="s2">&quot;VariableDeclarator&quot;</span><span class="s1">===a.parent.type&amp;&amp;a.parent.init===a?a.parent.id:</span><span class="s2">&quot;AssignmentExpression&quot;</span><span class="s1">===a.parent.type&amp;&amp;a.parent.right===a&amp;&amp;</span><span class="s2">&quot;=&quot;</span><span class="s1">===a.parent.operator?a.parent.left:</span><span class="s2">&quot;Property&quot;</span><span class="s1">!==a.parent.type||a.parent.value!==a||a.parent.computed?</span><span class="s2">&quot;AssignmentPattern&quot;</span><span class="s1">!==a.parent.type||a.parent.right!==a||a.parent.computed?</span><span class="s3">void </span><span class="s4">0</span><span class="s1">:a.parent.left:</span>
<span class="s1">a.parent.key}</span>
<span class="s3">function </span><span class="s1">H(a){</span><span class="s3">function </span><span class="s1">c(){</span><span class="s3">return</span><span class="s1">{isUsed:!</span><span class="s4">1</span><span class="s1">,isSatisfiedRecursively:!</span><span class="s4">1</span><span class="s1">,isSubtreeUsed:!</span><span class="s4">1</span><span class="s1">,children:</span><span class="s3">new </span><span class="s1">Map}}</span><span class="s3">function </span><span class="s1">b(a,b){b=b.split(</span><span class="s2">&quot;.&quot;</span><span class="s1">);b=D(b);</span><span class="s3">var </span><span class="s1">h;</span><span class="s3">try</span><span class="s1">{</span><span class="s3">for</span><span class="s1">(b.s();!(h=b.n()).done;){</span><span class="s3">var </span><span class="s1">d=h.value,f=a.children.get(d);f||(f=c(),a.children.set(d,f));a=f}}</span><span class="s3">catch</span><span class="s1">(F){b.e(F)}</span><span class="s3">finally</span><span class="s1">{b.f()}</span><span class="s3">return </span><span class="s1">a}</span><span class="s3">function </span><span class="s1">d(a,c,b){c=c.split(</span><span class="s2">&quot;.&quot;</span><span class="s1">);c=D(c);</span><span class="s3">var </span><span class="s1">d;</span><span class="s3">try</span><span class="s1">{</span><span class="s3">for</span><span class="s1">(c.s();!(d=c.n()).done;){</span><span class="s3">var </span><span class="s1">h=a.children.get(d.value);</span><span class="s3">if</span><span class="s1">(!h)</span><span class="s3">break</span><span class="s1">;b(h);a=h}}</span><span class="s3">catch</span><span class="s1">(F){c.e(F)}</span><span class="s3">finally</span><span class="s1">{c.f()}}</span><span class="s3">function </span><span class="s1">f(a,c,b,d){a.children.forEach(</span><span class="s3">function</span><span class="s1">(a,h){</span><span class="s3">var </span><span class="s1">e=</span>
<span class="s1">d(h);a.isSatisfiedRecursively?a.isSubtreeUsed&amp;&amp;b.add(e):a.isUsed?c.add(e):f(a,c,b,</span><span class="s3">function</span><span class="s1">(a){</span><span class="s3">return </span><span class="s1">e+</span><span class="s2">&quot;.&quot;</span><span class="s1">+a})})}</span><span class="s3">var </span><span class="s1">p=a.dependencies,g=a.declaredDependencies,w=a.stableDependencies,m=a.externalDependencies,E=a.isEffect,x=c();p.forEach(</span><span class="s3">function</span><span class="s1">(a,c){b(x,c).isUsed=!</span><span class="s4">0</span><span class="s1">;d(x,c,</span><span class="s3">function</span><span class="s1">(a){a.isSubtreeUsed=!</span><span class="s4">0</span><span class="s1">})});g.forEach(</span><span class="s3">function</span><span class="s1">(a){b(x,a.key).isSatisfiedRecursively=!</span><span class="s4">0</span><span class="s1">});w.forEach(</span><span class="s3">function</span><span class="s1">(a){b(x,a).isSatisfiedRecursively=!</span><span class="s4">0</span><span class="s1">});a=</span><span class="s3">new </span><span class="s1">Set;</span><span class="s3">var </span><span class="s1">r=</span><span class="s3">new </span><span class="s1">Set;f(x,a,r,</span><span class="s3">function</span><span class="s1">(a){</span><span class="s3">return </span><span class="s1">a});</span><span class="s3">var </span><span class="s1">e=[],C=</span><span class="s3">new </span><span class="s1">Set,t=</span>
<span class="s3">new </span><span class="s1">Set;g.forEach(</span><span class="s3">function</span><span class="s1">(a){a=a.key;r.has(a)?-</span><span class="s4">1</span><span class="s1">===e.indexOf(a)?e.push(a):t.add(a):!E||a.endsWith(</span><span class="s2">&quot;.current&quot;</span><span class="s1">)||m.has(a)?C.add(a):-</span><span class="s4">1</span><span class="s1">===e.indexOf(a)&amp;&amp;e.push(a)});a.forEach(</span><span class="s3">function</span><span class="s1">(a){e.push(a)});</span><span class="s3">return</span><span class="s1">{suggestedDependencies:e,unnecessaryDependencies:C,duplicateDependencies:t,missingDependencies:a}}</span>
<span class="s3">function </span><span class="s1">Q(a){</span><span class="s3">switch</span><span class="s1">(a.type){</span><span class="s3">case </span><span class="s2">&quot;ObjectExpression&quot;</span><span class="s1">:</span><span class="s3">return</span><span class="s2">&quot;object&quot;</span><span class="s1">;</span><span class="s3">case </span><span class="s2">&quot;ArrayExpression&quot;</span><span class="s1">:</span><span class="s3">return</span><span class="s2">&quot;array&quot;</span><span class="s1">;</span><span class="s3">case </span><span class="s2">&quot;ArrowFunctionExpression&quot;</span><span class="s1">:</span><span class="s3">case </span><span class="s2">&quot;FunctionExpression&quot;</span><span class="s1">:</span><span class="s3">return</span><span class="s2">&quot;function&quot;</span><span class="s1">;</span><span class="s3">case </span><span class="s2">&quot;ClassExpression&quot;</span><span class="s1">:</span><span class="s3">return</span><span class="s2">&quot;class&quot;</span><span class="s1">;</span><span class="s3">case </span><span class="s2">&quot;ConditionalExpression&quot;</span><span class="s1">:</span><span class="s3">if</span><span class="s1">(</span><span class="s3">null</span><span class="s1">!=Q(a.consequent)||</span><span class="s3">null</span><span class="s1">!=Q(a.alternate))</span><span class="s3">return</span><span class="s2">&quot;conditional&quot;</span><span class="s1">;</span><span class="s3">break</span><span class="s1">;</span><span class="s3">case </span><span class="s2">&quot;LogicalExpression&quot;</span><span class="s1">:</span><span class="s3">if</span><span class="s1">(</span><span class="s3">null</span><span class="s1">!=Q(a.left)||</span><span class="s3">null</span><span class="s1">!=Q(a.right))</span><span class="s3">return</span><span class="s2">&quot;logical expression&quot;</span><span class="s1">;</span><span class="s3">break</span><span class="s1">;</span><span class="s3">case </span><span class="s2">&quot;JSXFragment&quot;</span><span class="s1">:</span><span class="s3">return</span><span class="s2">&quot;JSX fragment&quot;</span><span class="s1">;</span><span class="s3">case </span><span class="s2">&quot;JSXElement&quot;</span><span class="s1">:</span><span class="s3">return</span><span class="s2">&quot;JSX element&quot;</span><span class="s1">;</span><span class="s3">case </span><span class="s2">&quot;AssignmentExpression&quot;</span><span class="s1">:</span><span class="s3">if</span><span class="s1">(</span><span class="s3">null</span><span class="s1">!=</span>
<span class="s1">Q(a.right))</span><span class="s3">return</span><span class="s2">&quot;assignment expression&quot;</span><span class="s1">;</span><span class="s3">break</span><span class="s1">;</span><span class="s3">case </span><span class="s2">&quot;NewExpression&quot;</span><span class="s1">:</span><span class="s3">return</span><span class="s2">&quot;object construction&quot;</span><span class="s1">;</span><span class="s3">case </span><span class="s2">&quot;Literal&quot;</span><span class="s1">:</span><span class="s3">if</span><span class="s1">(a.value </span><span class="s3">instanceof </span><span class="s1">RegExp)</span><span class="s3">return</span><span class="s2">&quot;regular expression&quot;</span><span class="s1">;</span><span class="s3">break</span><span class="s1">;</span><span class="s3">case </span><span class="s2">&quot;TypeCastExpression&quot;</span><span class="s1">:</span><span class="s3">return </span><span class="s1">Q(a.expression);</span><span class="s3">case </span><span class="s2">&quot;TSAsExpression&quot;</span><span class="s1">:</span><span class="s3">return </span><span class="s1">Q(a.expression)}</span><span class="s3">return null</span><span class="s1">}</span>
<span class="s3">function </span><span class="s1">oa(a){</span><span class="s3">var </span><span class="s1">c=a.declaredDependenciesNode,b=a.componentScope,d=a.scope;</span><span class="s3">return </span><span class="s1">a.declaredDependencies.map(</span><span class="s3">function</span><span class="s1">(a){</span><span class="s3">var </span><span class="s1">c=a.key;a=b.variables.find(</span><span class="s3">function</span><span class="s1">(a){</span><span class="s3">return </span><span class="s1">a.name===c});</span><span class="s3">if</span><span class="s1">(</span><span class="s3">null</span><span class="s1">==a)</span><span class="s3">return null</span><span class="s1">;</span><span class="s3">var </span><span class="s1">d=a.defs[</span><span class="s4">0</span><span class="s1">];</span><span class="s3">if</span><span class="s1">(</span><span class="s3">null</span><span class="s1">==d)</span><span class="s3">return null</span><span class="s1">;</span><span class="s3">if</span><span class="s1">(</span><span class="s2">&quot;Variable&quot;</span><span class="s1">===d.type&amp;&amp;</span><span class="s2">&quot;VariableDeclarator&quot;</span><span class="s1">===d.node.type&amp;&amp;</span><span class="s2">&quot;Identifier&quot;</span><span class="s1">===d.node.id.type&amp;&amp;</span><span class="s3">null</span><span class="s1">!=d.node.init){</span><span class="s3">var </span><span class="s1">f=Q(d.node.init);</span><span class="s3">if</span><span class="s1">(</span><span class="s3">null</span><span class="s1">!=f)</span><span class="s3">return</span><span class="s1">[a,f]}</span><span class="s3">return</span><span class="s2">&quot;FunctionName&quot;</span><span class="s1">===d.type&amp;&amp;</span><span class="s2">&quot;FunctionDeclaration&quot;</span><span class="s1">===d.node.type?[a,</span><span class="s2">&quot;function&quot;</span><span class="s1">]:</span><span class="s2">&quot;ClassName&quot;</span><span class="s1">===d.type&amp;&amp;</span>
<span class="s2">&quot;ClassDeclaration&quot;</span><span class="s1">===d.node.type?[a,</span><span class="s2">&quot;class&quot;</span><span class="s1">]:</span><span class="s3">null</span><span class="s1">}).filter(Boolean).map(</span><span class="s3">function</span><span class="s1">(a){</span><span class="s3">var </span><span class="s1">b=a[</span><span class="s4">0</span><span class="s1">];a=a[</span><span class="s4">1</span><span class="s1">];</span><span class="s3">var </span><span class="s1">f=b.defs[</span><span class="s4">0</span><span class="s1">];a:{</span><span class="s3">for</span><span class="s1">(</span><span class="s3">var </span><span class="s1">w=!</span><span class="s4">1</span><span class="s1">,m=</span><span class="s4">0</span><span class="s1">;m&lt;b.references.length;m++){</span><span class="s3">var </span><span class="s1">E=b.references[m];</span><span class="s3">if</span><span class="s1">(E.writeExpr)</span><span class="s3">if</span><span class="s1">(w){b=!</span><span class="s4">0</span><span class="s1">;</span><span class="s3">break </span><span class="s1">a}</span><span class="s3">else</span><span class="s1">{w=!</span><span class="s4">0</span><span class="s1">;</span><span class="s3">continue</span><span class="s1">}</span><span class="s3">for</span><span class="s1">(</span><span class="s3">var </span><span class="s1">x=E.from;x!==d&amp;&amp;</span><span class="s3">null</span><span class="s1">!=x;)x=x.upper;</span><span class="s3">if</span><span class="s1">(x!==d&amp;&amp;!pa(c,E.identifier)){b=!</span><span class="s4">0</span><span class="s1">;</span><span class="s3">break </span><span class="s1">a}}b=!</span><span class="s4">1</span><span class="s1">}</span><span class="s3">return</span><span class="s1">{construction:f,depType:a,isUsedOutsideOfHook:b}})}</span>
<span class="s3">function </span><span class="s1">sa(a){</span><span class="s3">return</span><span class="s2">&quot;MemberExpression&quot;</span><span class="s1">!==a.parent.type&amp;&amp;</span><span class="s2">&quot;OptionalMemberExpression&quot;</span><span class="s1">!==a.parent.type||a.parent.object!==a||</span><span class="s2">&quot;current&quot;</span><span class="s1">===a.parent.property.name||a.parent.computed||</span><span class="s3">null</span><span class="s1">!=a.parent.parent&amp;&amp;(</span><span class="s2">&quot;CallExpression&quot;</span><span class="s1">===a.parent.parent.type||</span><span class="s2">&quot;OptionalCallExpression&quot;</span><span class="s1">===a.parent.parent.type)&amp;&amp;a.parent.parent.callee===a.parent?</span><span class="s2">&quot;MemberExpression&quot;</span><span class="s1">===a.type&amp;&amp;a.parent&amp;&amp;</span><span class="s2">&quot;AssignmentExpression&quot;</span><span class="s1">===a.parent.type&amp;&amp;a.parent.left===a?a.object:a:sa(a.parent)}</span>
<span class="s3">function </span><span class="s1">W(a,c,b){c&amp;&amp;(a.optional?c.has(b)||c.set(b,!</span><span class="s4">0</span><span class="s1">):c.set(b,!</span><span class="s4">1</span><span class="s1">))}</span>
<span class="s3">function </span><span class="s1">X(a,c){</span><span class="s3">if</span><span class="s1">(</span><span class="s2">&quot;Identifier&quot;</span><span class="s1">===a.type||</span><span class="s2">&quot;JSXIdentifier&quot;</span><span class="s1">===a.type)</span><span class="s3">return </span><span class="s1">a=a.name,c&amp;&amp;c.set(a,!</span><span class="s4">1</span><span class="s1">),a;</span><span class="s3">if</span><span class="s1">(</span><span class="s2">&quot;MemberExpression&quot;</span><span class="s1">!==a.type||a.computed){</span><span class="s3">if</span><span class="s1">(</span><span class="s2">&quot;OptionalMemberExpression&quot;</span><span class="s1">!==a.type||a.computed){</span><span class="s3">if</span><span class="s1">(</span><span class="s2">&quot;ChainExpression&quot;</span><span class="s1">!==a.type||a.computed)</span><span class="s3">throw </span><span class="s1">Error(</span><span class="s2">&quot;Unsupported node type: &quot;</span><span class="s1">+a.type);a=a.expression;</span><span class="s3">if</span><span class="s1">(</span><span class="s2">&quot;CallExpression&quot;</span><span class="s1">===a.type)</span><span class="s3">throw </span><span class="s1">Error(</span><span class="s2">&quot;Unsupported node type: &quot;</span><span class="s1">+a.type);</span><span class="s3">var </span><span class="s1">b=X(a.object,c),d=X(a.property,</span><span class="s3">null</span><span class="s1">);b=b+</span><span class="s2">&quot;.&quot;</span><span class="s1">+d;W(a,c,b);</span><span class="s3">return </span><span class="s1">b}b=X(a.object,c);d=X(a.property,</span><span class="s3">null</span><span class="s1">);b=b+</span><span class="s2">&quot;.&quot;</span><span class="s1">+d;W(a,c,b);</span><span class="s3">return </span><span class="s1">b}b=</span>
<span class="s1">X(a.object,c);d=X(a.property,</span><span class="s3">null</span><span class="s1">);b=b+</span><span class="s2">&quot;.&quot;</span><span class="s1">+d;W(a,c,b);</span><span class="s3">return </span><span class="s1">b}</span><span class="s3">function </span><span class="s1">ta(a){</span><span class="s3">return</span><span class="s2">&quot;MemberExpression&quot;</span><span class="s1">!==a.type||</span><span class="s2">&quot;Identifier&quot;</span><span class="s1">!==a.object.type||</span><span class="s2">&quot;React&quot;</span><span class="s1">!==a.object.name||</span><span class="s2">&quot;Identifier&quot;</span><span class="s1">!==a.property.type||a.computed?a:a.property}</span>
<span class="s3">function </span><span class="s1">ua(a,c){</span><span class="s3">var </span><span class="s1">b=ta(a);</span><span class="s3">if</span><span class="s1">(</span><span class="s2">&quot;Identifier&quot;</span><span class="s1">!==b.type)</span><span class="s3">return</span><span class="s1">-</span><span class="s4">1</span><span class="s1">;</span><span class="s3">switch</span><span class="s1">(b.name){</span><span class="s3">case </span><span class="s2">&quot;useEffect&quot;</span><span class="s1">:</span><span class="s3">case </span><span class="s2">&quot;useLayoutEffect&quot;</span><span class="s1">:</span><span class="s3">case </span><span class="s2">&quot;useCallback&quot;</span><span class="s1">:</span><span class="s3">case </span><span class="s2">&quot;useMemo&quot;</span><span class="s1">:</span><span class="s3">return </span><span class="s4">0</span><span class="s1">;</span><span class="s3">case </span><span class="s2">&quot;useImperativeHandle&quot;</span><span class="s1">:</span><span class="s3">return </span><span class="s4">1</span><span class="s1">;</span><span class="s3">default</span><span class="s1">:</span><span class="s3">if</span><span class="s1">(b===a&amp;&amp;c&amp;&amp;c.additionalHooks){</span><span class="s3">try</span><span class="s1">{</span><span class="s3">var </span><span class="s1">d=X(b,</span><span class="s3">null</span><span class="s1">)}</span><span class="s3">catch</span><span class="s1">(f){</span><span class="s3">if</span><span class="s1">(/Unsupported node type/.test(f.message))</span><span class="s3">return </span><span class="s4">0</span><span class="s1">;</span><span class="s3">throw </span><span class="s1">f;}</span><span class="s3">return </span><span class="s1">c.additionalHooks.test(d)?</span><span class="s4">0</span><span class="s1">:-</span><span class="s4">1</span><span class="s1">}</span><span class="s3">return</span><span class="s1">-</span><span class="s4">1</span><span class="s1">}}</span>
<span class="s3">function </span><span class="s1">Y(a,c){</span><span class="s3">for</span><span class="s1">(</span><span class="s3">var </span><span class="s1">b=[a],d=</span><span class="s3">null</span><span class="s1">;b.length;){d=b.shift();</span><span class="s3">if</span><span class="s1">((</span><span class="s2">&quot;Identifier&quot;</span><span class="s1">===d.type||</span><span class="s2">&quot;JSXIdentifier&quot;</span><span class="s1">===d.type)&amp;&amp;d.type===c.type&amp;&amp;d.name===c.name&amp;&amp;d.range[</span><span class="s4">0</span><span class="s1">]===c.range[</span><span class="s4">0</span><span class="s1">]&amp;&amp;d.range[</span><span class="s4">1</span><span class="s1">]===c.range[</span><span class="s4">1</span><span class="s1">])</span><span class="s3">return </span><span class="s1">d;</span><span class="s3">if</span><span class="s1">(pa(d,c)){a=</span><span class="s4">0</span><span class="s1">;</span><span class="s3">for</span><span class="s1">(</span><span class="s3">var </span><span class="s1">f=Object.entries(d);a&lt;f.length;a++){</span><span class="s3">var </span><span class="s1">p=f[a],g=p[</span><span class="s4">1</span><span class="s1">];</span><span class="s2">&quot;parent&quot;</span><span class="s1">!==p[</span><span class="s4">0</span><span class="s1">]&amp;&amp;(va(g)?(g.parent=d,b.push(g)):Array.isArray(g)&amp;&amp;g.forEach(</span><span class="s3">function</span><span class="s1">(a){va(a)&amp;&amp;(a.parent=d,b.push(a))}))}}}</span><span class="s3">return null</span><span class="s1">}</span>
<span class="s3">function </span><span class="s1">wa(a){</span><span class="s3">for</span><span class="s1">(</span><span class="s3">var </span><span class="s1">c=</span><span class="s2">&quot;&quot;</span><span class="s1">,b=</span><span class="s4">0</span><span class="s1">;b&lt;a.length;b++)c+=a[b],</span><span class="s4">0</span><span class="s1">===b&amp;&amp;</span><span class="s4">2</span><span class="s1">===a.length?c+=</span><span class="s2">&quot; and &quot;</span><span class="s1">:b===a.length-2&amp;&amp;</span><span class="s4">2</span><span class="s1">&lt;a.length?c+=</span><span class="s2">&quot;, and &quot;</span><span class="s1">:b&lt;a.length-1&amp;&amp;(c+=</span><span class="s2">&quot;, &quot;</span><span class="s1">);</span><span class="s3">return </span><span class="s1">c}</span><span class="s3">function </span><span class="s1">va(a){</span><span class="s3">return</span><span class="s2">&quot;object&quot;</span><span class="s1">===</span><span class="s3">typeof </span><span class="s1">a&amp;&amp;</span><span class="s3">null</span><span class="s1">!==a&amp;&amp;!Array.isArray(a)&amp;&amp;</span><span class="s2">&quot;string&quot;</span><span class="s1">===</span><span class="s3">typeof </span><span class="s1">a.type}</span><span class="s3">function </span><span class="s1">pa(a,c){</span><span class="s3">return </span><span class="s1">a.range[</span><span class="s4">0</span><span class="s1">]&lt;=c.range[</span><span class="s4">0</span><span class="s1">]&amp;&amp;a.range[</span><span class="s4">1</span><span class="s1">]&gt;=c.range[</span><span class="s4">1</span><span class="s1">]}exports.configs={recommended:{plugins:[</span><span class="s2">&quot;react-hooks&quot;</span><span class="s1">],rules:{</span><span class="s2">&quot;react-hooks/rules-of-hooks&quot;</span><span class="s1">:</span><span class="s2">&quot;error&quot;</span><span class="s1">,</span><span class="s2">&quot;react-hooks/exhaustive-deps&quot;</span><span class="s1">:</span><span class="s2">&quot;warn&quot;</span><span class="s1">}}};</span>
<span class="s1">exports.rules={</span><span class="s2">&quot;rules-of-hooks&quot;</span><span class="s1">:{meta:{type:</span><span class="s2">&quot;problem&quot;</span><span class="s1">,docs:{description:</span><span class="s2">&quot;enforces the Rules of Hooks&quot;</span><span class="s1">,recommended:!</span><span class="s4">0</span><span class="s1">,url:</span><span class="s2">&quot;https://reactjs.org/docs/hooks-rules.html&quot;</span><span class="s1">}},create:</span><span class="s3">function</span><span class="s1">(a){</span><span class="s3">var </span><span class="s1">c=[],b=[];</span><span class="s3">return</span><span class="s1">{onCodePathSegmentStart:</span><span class="s3">function</span><span class="s1">(a){</span><span class="s3">return </span><span class="s1">b.push(a)},onCodePathSegmentEnd:</span><span class="s3">function</span><span class="s1">(){</span><span class="s3">return </span><span class="s1">b.pop()},onCodePathStart:</span><span class="s3">function</span><span class="s1">(){</span><span class="s3">return </span><span class="s1">c.push(</span><span class="s3">new </span><span class="s1">Map)},onCodePathEnd:</span><span class="s3">function</span><span class="s1">(b,f){</span><span class="s3">function </span><span class="s1">d(a,c){</span><span class="s3">var </span><span class="s1">e=d.cache,f=e.get(a.id);c=</span><span class="s3">new </span><span class="s1">Set(c);</span><span class="s3">if</span><span class="s1">(c.has(a.id)){e=[].concat(c);a=e.slice(e.indexOf(a.id)+</span>
<span class="s4">1</span><span class="s1">);a=D(a);</span><span class="s3">var </span><span class="s1">l;</span><span class="s3">try</span><span class="s1">{</span><span class="s3">for</span><span class="s1">(a.s();!(l=a.n()).done;)E.add(l.value)}</span><span class="s3">catch</span><span class="s1">(u){a.e(u)}</span><span class="s3">finally</span><span class="s1">{a.f()}</span><span class="s3">return </span><span class="s1">BigInt(</span><span class="s2">&quot;0&quot;</span><span class="s1">)}c.add(a.id);</span><span class="s3">if</span><span class="s1">(</span><span class="s3">void </span><span class="s4">0</span><span class="s1">!==f)</span><span class="s3">return </span><span class="s1">f;</span><span class="s3">if</span><span class="s1">(b.thrownSegments.includes(a))f=BigInt(</span><span class="s2">&quot;0&quot;</span><span class="s1">);</span><span class="s3">else if</span><span class="s1">(</span><span class="s4">0</span><span class="s1">===a.prevSegments.length)f=BigInt(</span><span class="s2">&quot;1&quot;</span><span class="s1">);</span><span class="s3">else</span><span class="s1">{f=BigInt(</span><span class="s2">&quot;0&quot;</span><span class="s1">);l=D(a.prevSegments);</span><span class="s3">var </span><span class="s1">r;</span><span class="s3">try</span><span class="s1">{</span><span class="s3">for</span><span class="s1">(l.s();!(r=l.n()).done;)f+=d(r.value,c)}</span><span class="s3">catch</span><span class="s1">(u){l.e(u)}</span><span class="s3">finally</span><span class="s1">{l.f()}}a.reachable&amp;&amp;f===BigInt(</span><span class="s2">&quot;0&quot;</span><span class="s1">)?e.</span><span class="s3">delete</span><span class="s1">(a.id):e.set(a.id,f);</span><span class="s3">return </span><span class="s1">f}</span><span class="s3">function </span><span class="s1">g(a,c){</span><span class="s3">var </span><span class="s1">d=g.cache,e=d.get(a.id);c=</span><span class="s3">new </span><span class="s1">Set(c);</span><span class="s3">if</span><span class="s1">(c.has(a.id)){d=</span>
<span class="s1">Array.from(c);a=d.slice(d.indexOf(a.id)+</span><span class="s4">1</span><span class="s1">);a=D(a);</span><span class="s3">var </span><span class="s1">f;</span><span class="s3">try</span><span class="s1">{</span><span class="s3">for</span><span class="s1">(a.s();!(f=a.n()).done;)E.add(f.value)}</span><span class="s3">catch</span><span class="s1">(u){a.e(u)}</span><span class="s3">finally</span><span class="s1">{a.f()}</span><span class="s3">return </span><span class="s1">BigInt(</span><span class="s2">&quot;0&quot;</span><span class="s1">)}c.add(a.id);</span><span class="s3">if</span><span class="s1">(</span><span class="s3">void </span><span class="s4">0</span><span class="s1">!==e)</span><span class="s3">return </span><span class="s1">e;</span><span class="s3">if</span><span class="s1">(b.thrownSegments.includes(a))e=BigInt(</span><span class="s2">&quot;0&quot;</span><span class="s1">);</span><span class="s3">else if</span><span class="s1">(</span><span class="s4">0</span><span class="s1">===a.nextSegments.length)e=BigInt(</span><span class="s2">&quot;1&quot;</span><span class="s1">);</span><span class="s3">else</span><span class="s1">{e=BigInt(</span><span class="s2">&quot;0&quot;</span><span class="s1">);f=D(a.nextSegments);</span><span class="s3">var </span><span class="s1">r;</span><span class="s3">try</span><span class="s1">{</span><span class="s3">for</span><span class="s1">(f.s();!(r=f.n()).done;)e+=g(r.value,c)}</span><span class="s3">catch</span><span class="s1">(u){f.e(u)}</span><span class="s3">finally</span><span class="s1">{f.f()}}d.set(a.id,e);</span><span class="s3">return </span><span class="s1">e}</span><span class="s3">function </span><span class="s1">w(a){</span><span class="s3">var </span><span class="s1">c=w.cache,b=c.get(a.id);</span><span class="s3">if</span><span class="s1">(</span><span class="s3">null</span><span class="s1">===b)</span><span class="s3">return </span><span class="s1">Infinity;</span><span class="s3">if</span><span class="s1">(</span><span class="s3">void </span><span class="s4">0</span><span class="s1">!==</span>
<span class="s1">b)</span><span class="s3">return </span><span class="s1">b;c.set(a.id,</span><span class="s3">null</span><span class="s1">);</span><span class="s3">if</span><span class="s1">(</span><span class="s4">0</span><span class="s1">===a.prevSegments.length)b=</span><span class="s4">1</span><span class="s1">;</span><span class="s3">else</span><span class="s1">{b=Infinity;</span><span class="s3">var </span><span class="s1">d=D(a.prevSegments),e;</span><span class="s3">try</span><span class="s1">{</span><span class="s3">for</span><span class="s1">(d.s();!(e=d.n()).done;){</span><span class="s3">var </span><span class="s1">f=w(e.value);f&lt;b&amp;&amp;(b=f)}}</span><span class="s3">catch</span><span class="s1">(u){d.e(u)}</span><span class="s3">finally</span><span class="s1">{d.f()}b+=</span><span class="s4">1</span><span class="s1">}c.set(a.id,b);</span><span class="s3">return </span><span class="s1">b}</span><span class="s3">var </span><span class="s1">m=c.pop();</span><span class="s3">if</span><span class="s1">(</span><span class="s4">0</span><span class="s1">!==m.size){</span><span class="s3">var </span><span class="s1">E=</span><span class="s3">new </span><span class="s1">Set;d.cache=</span><span class="s3">new </span><span class="s1">Map;g.cache=</span><span class="s3">new </span><span class="s1">Map;w.cache=</span><span class="s3">new </span><span class="s1">Map;</span><span class="s3">var </span><span class="s1">x=g(b.initialSegment),r=na(f),e=ma(f),C=r?ea(r)||G(r):ha(f)||ia(f),t=Infinity,h=D(b.finalSegments),ja;</span><span class="s3">try</span><span class="s1">{</span><span class="s3">for</span><span class="s1">(h.s();!(ja=h.n()).done;){</span><span class="s3">var </span><span class="s1">ka=ja.value;</span><span class="s3">if</span><span class="s1">(ka.reachable){</span><span class="s3">var </span><span class="s1">la=w(ka);la&lt;</span>
<span class="s1">t&amp;&amp;(t=la)}}}</span><span class="s3">catch</span><span class="s1">(l){h.e(l)}</span><span class="s3">finally</span><span class="s1">{h.f()}m=D(m);</span><span class="s3">var </span><span class="s1">A;</span><span class="s3">try</span><span class="s1">{</span><span class="s3">for</span><span class="s1">(m.s();!(A=m.n()).done;){</span><span class="s3">var </span><span class="s1">F=A.value,q=F[</span><span class="s4">0</span><span class="s1">],B=F[</span><span class="s4">1</span><span class="s1">];</span><span class="s3">if</span><span class="s1">(q.reachable){</span><span class="s3">var </span><span class="s1">N=</span><span class="s4">0</span><span class="s1">===q.nextSegments.length?t&lt;=w(q):t&lt;w(q),T=d(q)*g(q),U=E.has(q.id),J=D(B),y;</span><span class="s3">try</span><span class="s1">{</span><span class="s3">for</span><span class="s1">(J.s();!(y=J.n()).done;){</span><span class="s3">var </span><span class="s1">z=y.value;U&amp;&amp;a.report({node:z,message:</span><span class="s2">'React Hook &quot;'</span><span class="s1">+a.getSource(z)+</span><span class="s2">'&quot; may be executed more than once. Possibly because it is called in a loop. React Hooks must be called in the exact same order in every component render.'</span><span class="s1">});</span><span class="s3">if</span><span class="s1">(C){</span><span class="s3">if</span><span class="s1">(!U&amp;&amp;T!==x){</span><span class="s3">var </span><span class="s1">O=</span><span class="s2">'React Hook &quot;'</span><span class="s1">+</span>
<span class="s1">a.getSource(z)+</span><span class="s2">'&quot; is called conditionally. React Hooks must be called in the exact same order in every component render.'</span><span class="s1">+(N?</span><span class="s2">&quot; Did you accidentally call a React Hook after an early return?&quot;</span><span class="s1">:</span><span class="s2">&quot;&quot;</span><span class="s1">);a.report({node:z,message:O})}}</span><span class="s3">else if</span><span class="s1">(f.parent&amp;&amp;(</span><span class="s2">&quot;MethodDefinition&quot;</span><span class="s1">===f.parent.type||</span><span class="s2">&quot;ClassProperty&quot;</span><span class="s1">===f.parent.type)&amp;&amp;f.parent.value===f){</span><span class="s3">var </span><span class="s1">M=</span><span class="s2">'React Hook &quot;'</span><span class="s1">+a.getSource(z)+</span><span class="s2">'&quot; cannot be called in a class component. React Hooks must be called in a React function component or a custom React Hook function.'</span><span class="s1">;</span>
<span class="s1">a.report({node:z,message:M})}</span><span class="s3">else if</span><span class="s1">(r){</span><span class="s3">var </span><span class="s1">K=</span><span class="s2">'React Hook &quot;'</span><span class="s1">+a.getSource(z)+</span><span class="s2">'&quot; is called in function &quot;'</span><span class="s1">+(a.getSource(r)+</span><span class="s2">'&quot; that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word &quot;use&quot;.'</span><span class="s1">);a.report({node:z,message:K})}</span><span class="s3">else if</span><span class="s1">(</span><span class="s2">&quot;Program&quot;</span><span class="s1">===f.type){</span><span class="s3">var </span><span class="s1">L=</span><span class="s2">'React Hook &quot;'</span><span class="s1">+a.getSource(z)+</span><span class="s2">'&quot; cannot be called at the top level. React Hooks must be called in a React function component or a custom React Hook function.'</span><span class="s1">;</span>
<span class="s1">a.report({node:z,message:L})}</span><span class="s3">else if</span><span class="s1">(e){</span><span class="s3">var </span><span class="s1">n=</span><span class="s2">'React Hook &quot;'</span><span class="s1">+a.getSource(z)+</span><span class="s2">'&quot; cannot be called inside a callback. React Hooks must be called in a React function component or a custom React Hook function.'</span><span class="s1">;a.report({node:z,message:n})}}}</span><span class="s3">catch</span><span class="s1">(l){J.e(l)}</span><span class="s3">finally</span><span class="s1">{J.f()}}}}</span><span class="s3">catch</span><span class="s1">(l){m.e(l)}</span><span class="s3">finally</span><span class="s1">{m.f()}}},CallExpression:</span><span class="s3">function</span><span class="s1">(a){</span><span class="s3">if</span><span class="s1">(G(a.callee)){</span><span class="s3">var </span><span class="s1">d=c[c.length-1],p=b[b.length-1],g=d.get(p);g||(g=[],d.set(p,g));g.push(a.callee)}}}}},</span><span class="s2">&quot;exhaustive-deps&quot;</span><span class="s1">:{meta:{type:</span><span class="s2">&quot;suggestion&quot;</span><span class="s1">,docs:{description:</span><span class="s2">&quot;verifies the list of dependencies for Hooks like useEffect and similar&quot;</span><span class="s1">,</span>
<span class="s1">recommended:!</span><span class="s4">0</span><span class="s1">,url:</span><span class="s2">&quot;https://github.com/facebook/react/issues/14920&quot;</span><span class="s1">},fixable:</span><span class="s2">&quot;code&quot;</span><span class="s1">,hasSuggestions:!</span><span class="s4">0</span><span class="s1">,schema:[{type:</span><span class="s2">&quot;object&quot;</span><span class="s1">,additionalProperties:!</span><span class="s4">1</span><span class="s1">,enableDangerousAutofixThisMayCauseInfiniteLoops:!</span><span class="s4">1</span><span class="s1">,properties:{additionalHooks:{type:</span><span class="s2">&quot;string&quot;</span><span class="s1">},enableDangerousAutofixThisMayCauseInfiniteLoops:{type:</span><span class="s2">&quot;boolean&quot;</span><span class="s1">}}}]},create:</span><span class="s3">function</span><span class="s1">(a){</span><span class="s3">function </span><span class="s1">c(c){f&amp;&amp;Array.isArray(c.suggest)&amp;&amp;</span><span class="s4">0</span><span class="s1">&lt;c.suggest.length&amp;&amp;(c.fix=c.suggest[</span><span class="s4">0</span><span class="s1">].fix);a.report(c)}</span><span class="s3">function </span><span class="s1">b(a,c){</span><span class="s3">return function</span><span class="s1">(b){</span><span class="s3">if</span><span class="s1">(c.has(b))</span><span class="s3">return </span><span class="s1">c.get(b);</span><span class="s3">var </span><span class="s1">d=</span>
<span class="s1">a(b);c.set(b,d);</span><span class="s3">return </span><span class="s1">d}}</span><span class="s3">function </span><span class="s1">d(d,e,f,t,h){</span><span class="s3">function </span><span class="s1">r(a){</span><span class="s3">var </span><span class="s1">c=D(a.references),b;</span><span class="s3">try</span><span class="s1">{</span><span class="s3">for</span><span class="s1">(c.s();!(b=c.n()).done;){</span><span class="s3">var </span><span class="s1">k=b.value;</span><span class="s3">if</span><span class="s1">(k.resolved&amp;&amp;F.has(k.resolved.scope)){</span><span class="s3">var </span><span class="s1">f=Y(d,k.identifier),e=sa(f),g=X(e,z),t;</span><span class="s3">if</span><span class="s1">(t=h&amp;&amp;</span><span class="s2">&quot;Identifier&quot;</span><span class="s1">===e.type&amp;&amp;(</span><span class="s2">&quot;MemberExpression&quot;</span><span class="s1">===e.parent.type||</span><span class="s2">&quot;OptionalMemberExpression&quot;</span><span class="s1">===e.parent.type)&amp;&amp;!e.parent.computed&amp;&amp;</span><span class="s2">&quot;Identifier&quot;</span><span class="s1">===e.parent.property.type&amp;&amp;</span><span class="s2">&quot;current&quot;</span><span class="s1">===e.parent.property.name){</span><span class="s3">for</span><span class="s1">(</span><span class="s3">var </span><span class="s1">l=k.from,n=!</span><span class="s4">1</span><span class="s1">;l.block!==d;)</span><span class="s2">&quot;function&quot;</span><span class="s1">===l.type&amp;&amp;(n=</span><span class="s3">null</span><span class="s1">!=l.block.parent&amp;&amp;</span>
<span class="s2">&quot;ReturnStatement&quot;</span><span class="s1">===l.block.parent.type),l=l.upper;t=n}t&amp;&amp;J.set(g,{reference:k,dependencyNode:e});</span><span class="s3">if</span><span class="s1">(</span><span class="s2">&quot;TSTypeQuery&quot;</span><span class="s1">!==e.parent.type&amp;&amp;</span><span class="s2">&quot;TSTypeReference&quot;</span><span class="s1">!==e.parent.type){</span><span class="s3">var </span><span class="s1">C=k.resolved.defs[</span><span class="s4">0</span><span class="s1">];</span><span class="s3">if</span><span class="s1">(</span><span class="s3">null</span><span class="s1">!=C&amp;&amp;(</span><span class="s3">null</span><span class="s1">==C.node||C.node.init!==d.parent)&amp;&amp;</span><span class="s2">&quot;TypeParameter&quot;</span><span class="s1">!==C.type)</span><span class="s3">if</span><span class="s1">(y.has(g))y.get(g).references.push(k);</span><span class="s3">else</span><span class="s1">{</span><span class="s3">var </span><span class="s1">p=k.resolved,q=T(p)||U(p);y.set(g,{isStable:q,references:[k]})}}}}}</span><span class="s3">catch</span><span class="s1">(aa){c.e(aa)}</span><span class="s3">finally</span><span class="s1">{c.f()}a=D(a.childScopes);</span><span class="s3">var </span><span class="s1">m;</span><span class="s3">try</span><span class="s1">{</span><span class="s3">for</span><span class="s1">(a.s();!(m=a.n()).done;)r(m.value)}</span><span class="s3">catch</span><span class="s1">(aa){a.e(aa)}</span><span class="s3">finally</span><span class="s1">{a.f()}}</span>
<span class="s3">function </span><span class="s1">C(a){a=a.split(</span><span class="s2">&quot;.&quot;</span><span class="s1">);</span><span class="s3">for</span><span class="s1">(</span><span class="s3">var </span><span class="s1">c=</span><span class="s2">&quot;&quot;</span><span class="s1">,b=</span><span class="s4">0</span><span class="s1">;b&lt;a.length;b++){</span><span class="s3">if</span><span class="s1">(</span><span class="s4">0</span><span class="s1">!==b){</span><span class="s3">var </span><span class="s1">k=a.slice(</span><span class="s4">0</span><span class="s1">,b+</span><span class="s4">1</span><span class="s1">).join(</span><span class="s2">&quot;.&quot;</span><span class="s1">);k=!</span><span class="s4">0</span><span class="s1">===z.get(k);c+=k?</span><span class="s2">&quot;?.&quot;</span><span class="s1">:</span><span class="s2">&quot;.&quot;</span><span class="s1">}c+=a[b]}</span><span class="s3">return </span><span class="s1">c}</span><span class="s3">function </span><span class="s1">p(a,c,b,d){</span><span class="s3">return </span><span class="s4">0</span><span class="s1">===a.size?</span><span class="s3">null</span><span class="s1">:(</span><span class="s4">1</span><span class="s1">&lt;a.size?</span><span class="s2">&quot;&quot;</span><span class="s1">:c+</span><span class="s2">&quot; &quot;</span><span class="s1">)+b+</span><span class="s2">&quot; &quot;</span><span class="s1">+(</span><span class="s4">1</span><span class="s1">&lt;a.size?</span><span class="s2">&quot;dependencies&quot;</span><span class="s1">:</span><span class="s2">&quot;dependency&quot;</span><span class="s1">)+</span><span class="s2">&quot;: &quot;</span><span class="s1">+wa(Array.from(a).sort().map(</span><span class="s3">function</span><span class="s1">(a){</span><span class="s3">return</span><span class="s2">&quot;'&quot;</span><span class="s1">+C(a)+</span><span class="s2">&quot;'&quot;</span><span class="s1">}))+(</span><span class="s2">&quot;. Either &quot;</span><span class="s1">+d+</span><span class="s2">&quot; &quot;</span><span class="s1">+(</span><span class="s4">1</span><span class="s1">&lt;a.size?</span><span class="s2">&quot;them&quot;</span><span class="s1">:</span><span class="s2">&quot;it&quot;</span><span class="s1">)+</span><span class="s2">&quot; or remove the dependency array.&quot;</span><span class="s1">)}h&amp;&amp;d.async&amp;&amp;c({node:d,message:</span><span class="s2">&quot;Effect callbacks are synchronous to prevent race conditions. Put the async function inside:</span><span class="s5">\n\n</span><span class="s2">useEffect(() =&gt; {</span><span class="s5">\n  </span><span class="s2">async function fetchData() {</span><span class="s5">\n    </span><span class="s2">// You can await here</span><span class="s5">\n    </span><span class="s2">const response = await MyAPI.getData(someId);</span><span class="s5">\n    </span><span class="s2">// ...</span><span class="s5">\n  </span><span class="s2">}</span><span class="s5">\n  </span><span class="s2">fetchData();</span><span class="s5">\n</span><span class="s2">}, [someId]); // Or [] if effect doesn't need props or state</span><span class="s5">\n\n</span><span class="s2">Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching&quot;</span><span class="s1">});</span>
<span class="s3">for</span><span class="s1">(</span><span class="s3">var </span><span class="s1">A=g.acquire(d),F=</span><span class="s3">new </span><span class="s1">Set,q=</span><span class="s3">null</span><span class="s1">,B=A.upper;B;){F.add(B);</span><span class="s3">if</span><span class="s1">(</span><span class="s2">&quot;function&quot;</span><span class="s1">===B.type)</span><span class="s3">break</span><span class="s1">;B=B.upper}</span><span class="s3">if</span><span class="s1">(B){q=B;</span><span class="s3">var </span><span class="s1">N=Array.isArray,T=b(</span><span class="s3">function</span><span class="s1">(a){</span><span class="s3">if</span><span class="s1">(!N(a.defs))</span><span class="s3">return</span><span class="s1">!</span><span class="s4">1</span><span class="s1">;</span><span class="s3">var </span><span class="s1">c=a.defs[</span><span class="s4">0</span><span class="s1">];</span><span class="s3">if</span><span class="s1">(</span><span class="s3">null</span><span class="s1">==c||</span><span class="s2">&quot;VariableDeclarator&quot;</span><span class="s1">!==c.node.type)</span><span class="s3">return</span><span class="s1">!</span><span class="s4">1</span><span class="s1">;</span><span class="s3">var </span><span class="s1">b=c.node.init;</span><span class="s3">if</span><span class="s1">(</span><span class="s3">null</span><span class="s1">==b)</span><span class="s3">return</span><span class="s1">!</span><span class="s4">1</span><span class="s1">;</span><span class="s3">for</span><span class="s1">(;</span><span class="s2">&quot;TSAsExpression&quot;</span><span class="s1">===b.type;)b=b.expression;</span><span class="s3">var </span><span class="s1">d=c.node.parent;</span><span class="s3">if</span><span class="s1">(</span><span class="s3">null</span><span class="s1">==d&amp;&amp;(Y(q.block,c.node.id),d=c.node.parent,</span><span class="s3">null</span><span class="s1">==d))</span><span class="s3">return</span><span class="s1">!</span><span class="s4">1</span><span class="s1">;</span><span class="s3">if</span><span class="s1">(</span><span class="s2">&quot;const&quot;</span><span class="s1">===d.kind&amp;&amp;</span><span class="s2">&quot;Literal&quot;</span><span class="s1">===b.type&amp;&amp;(</span><span class="s2">&quot;string&quot;</span><span class="s1">===</span><span class="s3">typeof </span><span class="s1">b.value||</span><span class="s2">&quot;number&quot;</span><span class="s1">===</span><span class="s3">typeof </span><span class="s1">b.value||</span>
<span class="s3">null</span><span class="s1">===b.value))</span><span class="s3">return</span><span class="s1">!</span><span class="s4">0</span><span class="s1">;</span><span class="s3">if</span><span class="s1">(</span><span class="s2">&quot;CallExpression&quot;</span><span class="s1">!==b.type)</span><span class="s3">return</span><span class="s1">!</span><span class="s4">1</span><span class="s1">;b=b.callee;</span><span class="s2">&quot;MemberExpression&quot;</span><span class="s1">!==b.type||</span><span class="s2">&quot;React&quot;</span><span class="s1">!==b.object.name||</span><span class="s3">null</span><span class="s1">==b.property||b.computed||(b=b.property);</span><span class="s3">if</span><span class="s1">(</span><span class="s2">&quot;Identifier&quot;</span><span class="s1">!==b.type)</span><span class="s3">return</span><span class="s1">!</span><span class="s4">1</span><span class="s1">;c=c.node.id;b=b.name;</span><span class="s3">if</span><span class="s1">(</span><span class="s2">&quot;useRef&quot;</span><span class="s1">===b&amp;&amp;</span><span class="s2">&quot;Identifier&quot;</span><span class="s1">===c.type)</span><span class="s3">return</span><span class="s1">!</span><span class="s4">0</span><span class="s1">;</span><span class="s3">if</span><span class="s1">(</span><span class="s2">&quot;useState&quot;</span><span class="s1">===b||</span><span class="s2">&quot;useReducer&quot;</span><span class="s1">===b){</span><span class="s3">if</span><span class="s1">(</span><span class="s2">&quot;ArrayPattern&quot;</span><span class="s1">===c.type&amp;&amp;</span><span class="s4">2</span><span class="s1">===c.elements.length&amp;&amp;N(a.identifiers)){</span><span class="s3">if</span><span class="s1">(c.elements[</span><span class="s4">1</span><span class="s1">]===a.identifiers[</span><span class="s4">0</span><span class="s1">]){</span><span class="s3">if</span><span class="s1">(</span><span class="s2">&quot;useState&quot;</span><span class="s1">===b)</span><span class="s3">for</span><span class="s1">(a=a.references,d=b=</span><span class="s4">0</span><span class="s1">;d&lt;a.length;d++){a[d].isWrite()&amp;&amp;b++;</span><span class="s3">if</span><span class="s1">(</span><span class="s4">1</span><span class="s1">&lt;</span>
<span class="s1">b)</span><span class="s3">return</span><span class="s1">!</span><span class="s4">1</span><span class="s1">;w.set(a[d].identifier,c.elements[</span><span class="s4">0</span><span class="s1">])}</span><span class="s3">return</span><span class="s1">!</span><span class="s4">0</span><span class="s1">}</span><span class="s3">if</span><span class="s1">(c.elements[</span><span class="s4">0</span><span class="s1">]===a.identifiers[</span><span class="s4">0</span><span class="s1">]&amp;&amp;</span><span class="s2">&quot;useState&quot;</span><span class="s1">===b)</span><span class="s3">for</span><span class="s1">(a=a.references,c=</span><span class="s4">0</span><span class="s1">;c&lt;a.length;c++)m.add(a[c].identifier)}}</span><span class="s3">else if</span><span class="s1">(</span><span class="s2">&quot;useTransition&quot;</span><span class="s1">===b&amp;&amp;</span><span class="s2">&quot;ArrayPattern&quot;</span><span class="s1">===c.type&amp;&amp;</span><span class="s4">2</span><span class="s1">===c.elements.length&amp;&amp;Array.isArray(a.identifiers)&amp;&amp;c.elements[</span><span class="s4">1</span><span class="s1">]===a.identifiers[</span><span class="s4">0</span><span class="s1">])</span><span class="s3">return</span><span class="s1">!</span><span class="s4">0</span><span class="s1">;</span><span class="s3">return</span><span class="s1">!</span><span class="s4">1</span><span class="s1">},E),U=b(</span><span class="s3">function</span><span class="s1">(a){</span><span class="s3">if</span><span class="s1">(!N(a.defs))</span><span class="s3">return</span><span class="s1">!</span><span class="s4">1</span><span class="s1">;a=a.defs[</span><span class="s4">0</span><span class="s1">];</span><span class="s3">if</span><span class="s1">(</span><span class="s3">null</span><span class="s1">==a||</span><span class="s3">null</span><span class="s1">==a.node||</span><span class="s3">null</span><span class="s1">==a.node.id)</span><span class="s3">return</span><span class="s1">!</span><span class="s4">1</span><span class="s1">;</span><span class="s3">var </span><span class="s1">c=a.node,b=q.childScopes;a=</span><span class="s3">null</span><span class="s1">;</span><span class="s3">var </span><span class="s1">d;</span><span class="s3">for</span><span class="s1">(d=</span><span class="s4">0</span><span class="s1">;d&lt;b.length;d++){</span><span class="s3">var </span><span class="s1">e=</span>
<span class="s1">b[d],k=e.block;</span><span class="s3">if</span><span class="s1">(</span><span class="s2">&quot;FunctionDeclaration&quot;</span><span class="s1">===c.type&amp;&amp;k===c||</span><span class="s2">&quot;VariableDeclarator&quot;</span><span class="s1">===c.type&amp;&amp;k.parent===c){a=e;</span><span class="s3">break</span><span class="s1">}}</span><span class="s3">if</span><span class="s1">(</span><span class="s3">null</span><span class="s1">==a)</span><span class="s3">return</span><span class="s1">!</span><span class="s4">1</span><span class="s1">;</span><span class="s3">for</span><span class="s1">(d=</span><span class="s4">0</span><span class="s1">;d&lt;a.through.length;d++)</span><span class="s3">if</span><span class="s1">(c=a.through[d],</span><span class="s3">null</span><span class="s1">!=c.resolved&amp;&amp;F.has(c.resolved.scope)&amp;&amp;!T(c.resolved))</span><span class="s3">return</span><span class="s1">!</span><span class="s4">1</span><span class="s1">;</span><span class="s3">return</span><span class="s1">!</span><span class="s4">0</span><span class="s1">},x),J=</span><span class="s3">new </span><span class="s1">Map,y=</span><span class="s3">new </span><span class="s1">Map,z=</span><span class="s3">new </span><span class="s1">Map;r(A);J.forEach(</span><span class="s3">function</span><span class="s1">(a,b){</span><span class="s3">var </span><span class="s1">d=a.dependencyNode;a=a.reference.resolved.references;</span><span class="s3">for</span><span class="s1">(</span><span class="s3">var </span><span class="s1">e=!</span><span class="s4">1</span><span class="s1">,f=</span><span class="s4">0</span><span class="s1">;f&lt;a.length;f++){</span><span class="s3">var </span><span class="s1">k=a[f].identifier.parent;</span><span class="s3">if</span><span class="s1">(</span><span class="s3">null</span><span class="s1">!=k&amp;&amp;</span><span class="s2">&quot;MemberExpression&quot;</span><span class="s1">===k.type&amp;&amp;!k.computed&amp;&amp;</span><span class="s2">&quot;Identifier&quot;</span><span class="s1">===</span>
<span class="s1">k.property.type&amp;&amp;</span><span class="s2">&quot;current&quot;</span><span class="s1">===k.property.name&amp;&amp;</span><span class="s2">&quot;AssignmentExpression&quot;</span><span class="s1">===k.parent.type&amp;&amp;k.parent.left===k){e=!</span><span class="s4">0</span><span class="s1">;</span><span class="s3">break</span><span class="s1">}}e||c({node:d.parent.property,message:</span><span class="s2">&quot;The ref value '&quot;</span><span class="s1">+b+</span><span class="s2">&quot;.current' will likely have changed by the time this effect cleanup function runs. If this ref points to a node rendered by React, copy '&quot;</span><span class="s1">+(b+</span><span class="s2">&quot;.current' to a variable inside the effect, and use that variable in the cleanup function.&quot;</span><span class="s1">)})});</span><span class="s3">var </span><span class="s1">O=</span><span class="s3">new </span><span class="s1">Set,M=</span><span class="s3">new </span><span class="s1">Set;y.forEach(</span><span class="s3">function</span><span class="s1">(b,d){</span><span class="s3">var </span><span class="s1">e=b.references;b.isStable&amp;&amp;M.add(d);</span>
<span class="s1">e.forEach(</span><span class="s3">function</span><span class="s1">(b){b.writeExpr&amp;&amp;(b=b.writeExpr,O.has(d)||(O.add(d),c({node:b,message:</span><span class="s2">&quot;Assignments to the '&quot;</span><span class="s1">+d+</span><span class="s2">&quot;' variable from inside React Hook &quot;</span><span class="s1">+(a.getSource(f)+</span><span class="s2">&quot; will be lost after each render. To preserve the value over time, store it in a useRef Hook and keep the mutable value in the '.current' property. Otherwise, you can move this variable directly inside &quot;</span><span class="s1">)+(a.getSource(f)+</span><span class="s2">&quot;.&quot;</span><span class="s1">)})))})});</span><span class="s3">if</span><span class="s1">(!(</span><span class="s4">0</span><span class="s1">&lt;O.size))</span><span class="s3">if</span><span class="s1">(e){</span><span class="s3">var </span><span class="s1">K=[],L=</span><span class="s3">new </span><span class="s1">Set;</span><span class="s2">&quot;ArrayExpression&quot;</span><span class="s1">!==e.type?c({node:e,message:</span><span class="s2">&quot;React Hook &quot;</span><span class="s1">+a.getSource(f)+</span>
<span class="s2">&quot; was passed a dependency list that is not an array literal. This means we can't statically verify whether you've passed the correct dependencies.&quot;</span><span class="s1">}):e.elements.forEach(</span><span class="s3">function</span><span class="s1">(b){</span><span class="s3">if</span><span class="s1">(</span><span class="s3">null</span><span class="s1">!==b)</span><span class="s3">if</span><span class="s1">(</span><span class="s2">&quot;SpreadElement&quot;</span><span class="s1">===b.type)c({node:b,message:</span><span class="s2">&quot;React Hook &quot;</span><span class="s1">+a.getSource(f)+</span><span class="s2">&quot; has a spread element in its dependency array. This means we can't statically verify whether you've passed the correct dependencies.&quot;</span><span class="s1">});</span><span class="s3">else</span><span class="s1">{</span><span class="s3">try</span><span class="s1">{</span><span class="s3">var </span><span class="s1">d=X(b,</span><span class="s3">null</span><span class="s1">)}</span><span class="s3">catch</span><span class="s1">(ra){</span><span class="s3">if</span><span class="s1">(/Unsupported node type/.test(ra.message)){</span><span class="s2">&quot;Literal&quot;</span><span class="s1">===b.type?</span>
<span class="s1">y.has(b.value)?c({node:b,message:</span><span class="s2">&quot;The &quot;</span><span class="s1">+b.raw+</span><span class="s2">&quot; literal is not a valid dependency because it never changes. Did you mean to include &quot;</span><span class="s1">+(b.value+</span><span class="s2">&quot; in the array instead?&quot;</span><span class="s1">)}):c({node:b,message:</span><span class="s2">&quot;The &quot;</span><span class="s1">+b.raw+</span><span class="s2">&quot; literal is not a valid dependency because it never changes. You can safely remove it.&quot;</span><span class="s1">}):c({node:b,message:</span><span class="s2">&quot;React Hook &quot;</span><span class="s1">+a.getSource(f)+</span><span class="s2">&quot; has a complex expression in the dependency array. Extract it to a separate variable so it can be statically checked.&quot;</span><span class="s1">});</span><span class="s3">return</span><span class="s1">}</span><span class="s3">throw </span><span class="s1">ra;}</span><span class="s3">for</span><span class="s1">(</span><span class="s3">var </span><span class="s1">e=b;</span><span class="s2">&quot;MemberExpression&quot;</span><span class="s1">===</span>
<span class="s1">e.type||</span><span class="s2">&quot;OptionalMemberExpression&quot;</span><span class="s1">===e.type||</span><span class="s2">&quot;ChainExpression&quot;</span><span class="s1">===e.type;)e=e.object||e.expression.object;</span><span class="s3">var </span><span class="s1">k=!q.through.some(</span><span class="s3">function</span><span class="s1">(a){</span><span class="s3">return </span><span class="s1">a.identifier===e});K.push({key:d,node:b});k||L.add(d)}});</span><span class="s3">var </span><span class="s1">n=H({dependencies:y,declaredDependencies:K,stableDependencies:M,externalDependencies:L,isEffect:h});B=n.unnecessaryDependencies;</span><span class="s3">var </span><span class="s1">l=n.missingDependencies,qa=n.duplicateDependencies,R=n.suggestedDependencies;</span><span class="s3">if</span><span class="s1">(</span><span class="s4">0</span><span class="s1">===qa.size+l.size+B.size)oa({declaredDependencies:K,declaredDependenciesNode:e,componentScope:q,</span>
<span class="s1">scope:A}).forEach(</span><span class="s3">function</span><span class="s1">(a){</span><span class="s3">var </span><span class="s1">b=a.construction,d=a.isUsedOutsideOfHook;a=a.depType;</span><span class="s3">var </span><span class="s1">f=</span><span class="s2">&quot;function&quot;</span><span class="s1">===a?</span><span class="s2">&quot;useCallback&quot;</span><span class="s1">:</span><span class="s2">&quot;useMemo&quot;</span><span class="s1">,k=</span><span class="s2">&quot;function&quot;</span><span class="s1">===a?</span><span class="s2">&quot;definition&quot;</span><span class="s1">:</span><span class="s2">&quot;initialization&quot;</span><span class="s1">,h=</span><span class="s2">&quot;wrap the &quot;</span><span class="s1">+k+</span><span class="s2">&quot; of '&quot;</span><span class="s1">+b.name.name+</span><span class="s2">&quot;' in its own &quot;</span><span class="s1">+f+</span><span class="s2">&quot;() Hook.&quot;</span><span class="s1">;h=</span><span class="s2">&quot;The '&quot;</span><span class="s1">+b.name.name+</span><span class="s2">&quot;' &quot;</span><span class="s1">+a+</span><span class="s2">&quot; &quot;</span><span class="s1">+(</span><span class="s2">&quot;conditional&quot;</span><span class="s1">===a||</span><span class="s2">&quot;logical expression&quot;</span><span class="s1">===a?</span><span class="s2">&quot;could make&quot;</span><span class="s1">:</span><span class="s2">&quot;makes&quot;</span><span class="s1">)+</span><span class="s2">&quot; the dependencies of &quot;</span><span class="s1">+(t+</span><span class="s2">&quot; Hook (at line &quot;</span><span class="s1">+e.loc.start.line+</span><span class="s2">&quot;) change on every render. &quot;</span><span class="s1">)+(d?</span><span class="s2">&quot;To fix this, &quot;</span><span class="s1">+h:</span><span class="s2">&quot;Move it inside the &quot;</span><span class="s1">+t+</span><span class="s2">&quot; callback. Alternatively, &quot;</span><span class="s1">+</span>
<span class="s1">h);</span><span class="s3">var </span><span class="s1">g;d&amp;&amp;</span><span class="s2">&quot;Variable&quot;</span><span class="s1">===b.type&amp;&amp;</span><span class="s2">&quot;function&quot;</span><span class="s1">===a&amp;&amp;(g=[{desc:</span><span class="s2">&quot;Wrap the &quot;</span><span class="s1">+k+</span><span class="s2">&quot; of '&quot;</span><span class="s1">+b.name.name+</span><span class="s2">&quot;' in its own &quot;</span><span class="s1">+f+</span><span class="s2">&quot;() Hook.&quot;</span><span class="s1">,fix:</span><span class="s3">function</span><span class="s1">(a){</span><span class="s3">var </span><span class="s1">c=</span><span class="s2">&quot;useMemo&quot;</span><span class="s1">===f?[</span><span class="s2">&quot;useMemo(() =&gt; { return &quot;</span><span class="s1">,</span><span class="s2">&quot;; })&quot;</span><span class="s1">]:[</span><span class="s2">&quot;useCallback(&quot;</span><span class="s1">,</span><span class="s2">&quot;)&quot;</span><span class="s1">],d=c[</span><span class="s4">1</span><span class="s1">];</span><span class="s3">return</span><span class="s1">[a.insertTextBefore(b.node.init,c[</span><span class="s4">0</span><span class="s1">]),a.insertTextAfter(b.node.init,d)]}}]);c({node:b.node,message:h,suggest:g})});</span><span class="s3">else</span><span class="s1">{!h&amp;&amp;</span><span class="s4">0</span><span class="s1">&lt;l.size&amp;&amp;(R=H({dependencies:y,declaredDependencies:[],stableDependencies:M,externalDependencies:L,isEffect:h}).suggestedDependencies);(</span><span class="s3">function</span><span class="s1">(){</span><span class="s3">if</span><span class="s1">(</span><span class="s4">0</span><span class="s1">===</span>
<span class="s1">K.length)</span><span class="s3">return</span><span class="s1">!</span><span class="s4">0</span><span class="s1">;</span><span class="s3">var </span><span class="s1">a=K.map(</span><span class="s3">function</span><span class="s1">(a){</span><span class="s3">return </span><span class="s1">a.key}),b=a.slice().sort();</span><span class="s3">return </span><span class="s1">a.join(</span><span class="s2">&quot;,&quot;</span><span class="s1">)===b.join(</span><span class="s2">&quot;,&quot;</span><span class="s1">)})()&amp;&amp;R.sort();n=</span><span class="s2">&quot;&quot;</span><span class="s1">;</span><span class="s3">if</span><span class="s1">(</span><span class="s4">0</span><span class="s1">&lt;B.size){</span><span class="s3">var </span><span class="s1">S=</span><span class="s3">null</span><span class="s1">;Array.from(B.keys()).forEach(</span><span class="s3">function</span><span class="s1">(a){</span><span class="s3">null</span><span class="s1">===S&amp;&amp;a.endsWith(</span><span class="s2">&quot;.current&quot;</span><span class="s1">)&amp;&amp;(S=a)});</span><span class="s3">if</span><span class="s1">(</span><span class="s3">null</span><span class="s1">!==S)n=</span><span class="s2">&quot; Mutable values like '&quot;</span><span class="s1">+S+</span><span class="s2">&quot;' aren't valid dependencies because mutating them doesn't re-render the component.&quot;</span><span class="s1">;</span><span class="s3">else if</span><span class="s1">(</span><span class="s4">0</span><span class="s1">&lt;L.size){</span><span class="s3">var </span><span class="s1">I=Array.from(L)[</span><span class="s4">0</span><span class="s1">];A.set.has(I)||(n=</span><span class="s2">&quot; Outer scope values like '&quot;</span><span class="s1">+I+</span><span class="s2">&quot;' aren't valid dependencies because mutating them doesn't re-render the component.&quot;</span><span class="s1">)}}</span><span class="s3">if</span><span class="s1">(!n&amp;&amp;</span>
<span class="s1">l.has(</span><span class="s2">&quot;props&quot;</span><span class="s1">)){A=y.get(</span><span class="s2">&quot;props&quot;</span><span class="s1">);</span><span class="s3">if</span><span class="s1">(</span><span class="s3">null</span><span class="s1">==A)</span><span class="s3">return</span><span class="s1">;A=A.references;</span><span class="s3">if</span><span class="s1">(!Array.isArray(A))</span><span class="s3">return</span><span class="s1">;I=!</span><span class="s4">0</span><span class="s1">;</span><span class="s3">for</span><span class="s1">(</span><span class="s3">var </span><span class="s1">Z=</span><span class="s4">0</span><span class="s1">;Z&lt;A.length;Z++){</span><span class="s3">var </span><span class="s1">u=Y(q.block,A[Z].identifier);</span><span class="s3">if</span><span class="s1">(!u){I=!</span><span class="s4">1</span><span class="s1">;</span><span class="s3">break</span><span class="s1">}u=u.parent;</span><span class="s3">if</span><span class="s1">(</span><span class="s3">null</span><span class="s1">==u){I=!</span><span class="s4">1</span><span class="s1">;</span><span class="s3">break</span><span class="s1">}</span><span class="s3">if</span><span class="s1">(</span><span class="s2">&quot;MemberExpression&quot;</span><span class="s1">!==u.type&amp;&amp;</span><span class="s2">&quot;OptionalMemberExpression&quot;</span><span class="s1">!==u.type){I=!</span><span class="s4">1</span><span class="s1">;</span><span class="s3">break</span><span class="s1">}}I&amp;&amp;(n=</span><span class="s2">&quot; However, 'props' will change when *any* prop changes, so the preferred fix is to destructure the 'props' object outside of the &quot;</span><span class="s1">+(t+</span><span class="s2">&quot; call and refer to those specific props inside &quot;</span><span class="s1">)+(a.getSource(f)+</span><span class="s2">&quot;.&quot;</span><span class="s1">))}</span><span class="s3">if</span><span class="s1">(!n&amp;&amp;</span>
<span class="s4">0</span><span class="s1">&lt;l.size){</span><span class="s3">var </span><span class="s1">V=</span><span class="s3">null</span><span class="s1">;l.forEach(</span><span class="s3">function</span><span class="s1">(a){</span><span class="s3">if</span><span class="s1">(!V){</span><span class="s3">var </span><span class="s1">b=q.set.get(a),c=y.get(a);</span><span class="s3">if</span><span class="s1">(c.references[</span><span class="s4">0</span><span class="s1">].resolved===b&amp;&amp;(b=b.defs[</span><span class="s4">0</span><span class="s1">],</span><span class="s3">null</span><span class="s1">!=b&amp;&amp;</span><span class="s3">null</span><span class="s1">!=b.name&amp;&amp;</span><span class="s2">&quot;Parameter&quot;</span><span class="s1">===b.type)){b=!</span><span class="s4">1</span><span class="s1">;</span><span class="s3">for</span><span class="s1">(</span><span class="s3">var </span><span class="s1">d,e=</span><span class="s4">0</span><span class="s1">;e&lt;c.references.length;e++)</span><span class="s3">if</span><span class="s1">(d=c.references[e].identifier,</span><span class="s3">null</span><span class="s1">!=d&amp;&amp;</span><span class="s3">null</span><span class="s1">!=d.parent&amp;&amp;(</span><span class="s2">&quot;CallExpression&quot;</span><span class="s1">===d.parent.type||</span><span class="s2">&quot;OptionalCallExpression&quot;</span><span class="s1">===d.parent.type)&amp;&amp;d.parent.callee===d){b=!</span><span class="s4">0</span><span class="s1">;</span><span class="s3">break</span><span class="s1">}b&amp;&amp;(V=a)}}});</span><span class="s3">null</span><span class="s1">!==V&amp;&amp;(n=</span><span class="s2">&quot; If '&quot;</span><span class="s1">+V+</span><span class="s2">&quot;' changes too often, find the parent component that defines it and wrap that definition in useCallback.&quot;</span><span class="s1">)}</span><span class="s3">if</span><span class="s1">(!n&amp;&amp;</span>
<span class="s4">0</span><span class="s1">&lt;l.size){</span><span class="s3">var </span><span class="s1">v=</span><span class="s3">null</span><span class="s1">;l.forEach(</span><span class="s3">function</span><span class="s1">(a){</span><span class="s3">if</span><span class="s1">(</span><span class="s3">null</span><span class="s1">===v)</span><span class="s3">for</span><span class="s1">(</span><span class="s3">var </span><span class="s1">b=y.get(a).references,c,d,e=</span><span class="s4">0</span><span class="s1">;e&lt;b.length;e++){c=b[e].identifier;</span><span class="s3">for</span><span class="s1">(d=c.parent;</span><span class="s3">null</span><span class="s1">!=d&amp;&amp;d!==q.block;){</span><span class="s3">if</span><span class="s1">(</span><span class="s2">&quot;CallExpression&quot;</span><span class="s1">===d.type){</span><span class="s3">var </span><span class="s1">f=w.get(d.callee);</span><span class="s3">if</span><span class="s1">(</span><span class="s3">null</span><span class="s1">!=f){f.name===a?v={missingDep:a,setter:d.callee.name,form:</span><span class="s2">&quot;updater&quot;</span><span class="s1">}:m.has(c)?v={missingDep:a,setter:d.callee.name,form:</span><span class="s2">&quot;reducer&quot;</span><span class="s1">}:(c=b[e].resolved,</span><span class="s3">null</span><span class="s1">!=c&amp;&amp;(c=c.defs[</span><span class="s4">0</span><span class="s1">],</span><span class="s3">null</span><span class="s1">!=c&amp;&amp;</span><span class="s2">&quot;Parameter&quot;</span><span class="s1">===c.type&amp;&amp;(v={missingDep:a,setter:d.callee.name,form:</span><span class="s2">&quot;inlineReducer&quot;</span><span class="s1">})));</span><span class="s3">break</span><span class="s1">}}d=d.parent}</span><span class="s3">if</span><span class="s1">(</span><span class="s3">null</span><span class="s1">!==</span>
<span class="s1">v)</span><span class="s3">break</span><span class="s1">}});</span><span class="s3">if</span><span class="s1">(</span><span class="s3">null</span><span class="s1">!==v)</span><span class="s3">switch</span><span class="s1">(v.form){</span><span class="s3">case </span><span class="s2">&quot;reducer&quot;</span><span class="s1">:n=</span><span class="s2">&quot; You can also replace multiple useState variables with useReducer if '&quot;</span><span class="s1">+(v.setter+</span><span class="s2">&quot;' needs the current value of '&quot;</span><span class="s1">)+(v.missingDep+</span><span class="s2">&quot;'.&quot;</span><span class="s1">);</span><span class="s3">break</span><span class="s1">;</span><span class="s3">case </span><span class="s2">&quot;inlineReducer&quot;</span><span class="s1">:n=</span><span class="s2">&quot; If '&quot;</span><span class="s1">+v.setter+</span><span class="s2">&quot;' needs the current value of '&quot;</span><span class="s1">+(v.missingDep+</span><span class="s2">&quot;', you can also switch to useReducer instead of useState and read '&quot;</span><span class="s1">)+(v.missingDep+</span><span class="s2">&quot;' in the reducer.&quot;</span><span class="s1">);</span><span class="s3">break</span><span class="s1">;</span><span class="s3">case </span><span class="s2">&quot;updater&quot;</span><span class="s1">:n=</span><span class="s2">&quot; You can also do a functional update '&quot;</span><span class="s1">+v.setter+</span><span class="s2">&quot;(&quot;</span><span class="s1">+v.missingDep.substring(</span><span class="s4">0</span><span class="s1">,</span><span class="s4">1</span><span class="s1">)+</span><span class="s2">&quot; =&gt; ...)' if you only need '&quot;</span><span class="s1">+</span>
<span class="s1">v.missingDep+</span><span class="s2">&quot;' in the '&quot;</span><span class="s1">+(v.setter+</span><span class="s2">&quot;' call.&quot;</span><span class="s1">);</span><span class="s3">break</span><span class="s1">;</span><span class="s3">default</span><span class="s1">:</span><span class="s3">throw </span><span class="s1">Error(</span><span class="s2">&quot;Unknown case.&quot;</span><span class="s1">);}}c({node:e,message:</span><span class="s2">&quot;React Hook &quot;</span><span class="s1">+a.getSource(f)+</span><span class="s2">&quot; has &quot;</span><span class="s1">+(p(l,</span><span class="s2">&quot;a&quot;</span><span class="s1">,</span><span class="s2">&quot;missing&quot;</span><span class="s1">,</span><span class="s2">&quot;include&quot;</span><span class="s1">)||p(B,</span><span class="s2">&quot;an&quot;</span><span class="s1">,</span><span class="s2">&quot;unnecessary&quot;</span><span class="s1">,</span><span class="s2">&quot;exclude&quot;</span><span class="s1">)||p(qa,</span><span class="s2">&quot;a&quot;</span><span class="s1">,</span><span class="s2">&quot;duplicate&quot;</span><span class="s1">,</span><span class="s2">&quot;omit&quot;</span><span class="s1">))+n,suggest:[{desc:</span><span class="s2">&quot;Update the dependencies array to be: [&quot;</span><span class="s1">+R.map(C).join(</span><span class="s2">&quot;, &quot;</span><span class="s1">)+</span><span class="s2">&quot;]&quot;</span><span class="s1">,fix:</span><span class="s3">function</span><span class="s1">(a){</span><span class="s3">return </span><span class="s1">a.replaceText(e,</span><span class="s2">&quot;[&quot;</span><span class="s1">+R.map(C).join(</span><span class="s2">&quot;, &quot;</span><span class="s1">)+</span><span class="s2">&quot;]&quot;</span><span class="s1">)}}]})}}</span><span class="s3">else</span><span class="s1">{</span><span class="s3">var </span><span class="s1">P=</span><span class="s3">null</span><span class="s1">;y.forEach(</span><span class="s3">function</span><span class="s1">(a,b){P||a.references.forEach(</span><span class="s3">function</span><span class="s1">(a){</span><span class="s3">if</span><span class="s1">(!P&amp;&amp;w.has(a.identifier)){</span><span class="s3">for</span><span class="s1">(a=</span>
<span class="s1">a.from;</span><span class="s2">&quot;function&quot;</span><span class="s1">!==a.type;)a=a.upper;a.block===d&amp;&amp;(P=b)}})});</span><span class="s3">if</span><span class="s1">(P){</span><span class="s3">var </span><span class="s1">ba=H({dependencies:y,declaredDependencies:[],stableDependencies:M,externalDependencies:</span><span class="s3">new </span><span class="s1">Set,isEffect:!</span><span class="s4">0</span><span class="s1">}).suggestedDependencies;c({node:f,message:</span><span class="s2">&quot;React Hook &quot;</span><span class="s1">+t+</span><span class="s2">&quot; contains a call to '&quot;</span><span class="s1">+P+</span><span class="s2">&quot;'. Without a list of dependencies, this can lead to an infinite chain of updates. To fix this, pass [&quot;</span><span class="s1">+ba.join(</span><span class="s2">&quot;, &quot;</span><span class="s1">)+(</span><span class="s2">&quot;] as a second argument to the &quot;</span><span class="s1">+t+</span><span class="s2">&quot; Hook.&quot;</span><span class="s1">),suggest:[{desc:</span><span class="s2">&quot;Add dependencies array: [&quot;</span><span class="s1">+ba.join(</span><span class="s2">&quot;, &quot;</span><span class="s1">)+</span><span class="s2">&quot;]&quot;</span><span class="s1">,fix:</span><span class="s3">function</span><span class="s1">(a){</span><span class="s3">return </span><span class="s1">a.insertTextAfter(d,</span>
<span class="s2">&quot;, [&quot;</span><span class="s1">+ba.join(</span><span class="s2">&quot;, &quot;</span><span class="s1">)+</span><span class="s2">&quot;]&quot;</span><span class="s1">)}}]})}}}}</span><span class="s3">var </span><span class="s1">f=a.options&amp;&amp;a.options[</span><span class="s4">0</span><span class="s1">]&amp;&amp;a.options[</span><span class="s4">0</span><span class="s1">].enableDangerousAutofixThisMayCauseInfiniteLoops||!</span><span class="s4">1</span><span class="s1">,p={additionalHooks:a.options&amp;&amp;a.options[</span><span class="s4">0</span><span class="s1">]&amp;&amp;a.options[</span><span class="s4">0</span><span class="s1">].additionalHooks?</span><span class="s3">new </span><span class="s1">RegExp(a.options[</span><span class="s4">0</span><span class="s1">].additionalHooks):</span><span class="s3">void </span><span class="s4">0</span><span class="s1">,enableDangerousAutofixThisMayCauseInfiniteLoops:f},g=a.getSourceCode().scopeManager,w=</span><span class="s3">new </span><span class="s1">WeakMap,m=</span><span class="s3">new </span><span class="s1">WeakSet,E=</span><span class="s3">new </span><span class="s1">WeakMap,x=</span><span class="s3">new </span><span class="s1">WeakMap;</span><span class="s3">return</span><span class="s1">{CallExpression:</span><span class="s3">function</span><span class="s1">(b){</span><span class="s3">var </span><span class="s1">e=ua(b.callee,p);</span><span class="s3">if</span><span class="s1">(-</span><span class="s4">1</span><span class="s1">!==e){</span><span class="s3">var </span><span class="s1">f=b.arguments[e],g=b.callee,h=ta(g).name,</span>
<span class="s1">m=b.arguments[e+</span><span class="s4">1</span><span class="s1">];b=/Effect($|[^a-z])/g.test(h);</span><span class="s3">if</span><span class="s1">(f)</span><span class="s3">if</span><span class="s1">(m||b){</span><span class="s3">switch</span><span class="s1">(f.type){</span><span class="s3">case </span><span class="s2">&quot;FunctionExpression&quot;</span><span class="s1">:</span><span class="s3">case </span><span class="s2">&quot;ArrowFunctionExpression&quot;</span><span class="s1">:d(f,m,g,h,b);</span><span class="s3">return</span><span class="s1">;</span><span class="s3">case </span><span class="s2">&quot;Identifier&quot;</span><span class="s1">:</span><span class="s3">if</span><span class="s1">(!m||m.elements&amp;&amp;m.elements.some(</span><span class="s3">function</span><span class="s1">(a){</span><span class="s3">return </span><span class="s1">a&amp;&amp;</span><span class="s2">&quot;Identifier&quot;</span><span class="s1">===a.type&amp;&amp;a.name===f.name}))</span><span class="s3">return</span><span class="s1">;e=a.getScope().set.get(f.name);</span><span class="s3">if</span><span class="s1">(</span><span class="s3">null</span><span class="s1">==e||</span><span class="s3">null</span><span class="s1">==e.defs)</span><span class="s3">return</span><span class="s1">;e=e.defs[</span><span class="s4">0</span><span class="s1">];</span><span class="s3">if</span><span class="s1">(!e||!e.node)</span><span class="s3">break</span><span class="s1">;</span><span class="s3">if</span><span class="s1">(</span><span class="s2">&quot;Variable&quot;</span><span class="s1">!==e.type&amp;&amp;</span><span class="s2">&quot;FunctionName&quot;</span><span class="s1">!==e.type)</span><span class="s3">break</span><span class="s1">;</span><span class="s3">switch</span><span class="s1">(e.node.type){</span><span class="s3">case </span><span class="s2">&quot;FunctionDeclaration&quot;</span><span class="s1">:d(e.node,m,g,h,b);</span><span class="s3">return</span><span class="s1">;</span><span class="s3">case </span><span class="s2">&quot;VariableDeclarator&quot;</span><span class="s1">:</span><span class="s3">if</span><span class="s1">(e=</span>
<span class="s1">e.node.init)</span><span class="s3">switch</span><span class="s1">(e.type){</span><span class="s3">case </span><span class="s2">&quot;ArrowFunctionExpression&quot;</span><span class="s1">:</span><span class="s3">case </span><span class="s2">&quot;FunctionExpression&quot;</span><span class="s1">:d(e,m,g,h,b);</span><span class="s3">return</span><span class="s1">}}</span><span class="s3">break</span><span class="s1">;</span><span class="s3">default</span><span class="s1">:c({node:g,message:</span><span class="s2">&quot;React Hook &quot;</span><span class="s1">+h+</span><span class="s2">&quot; received a function whose dependencies are unknown. Pass an inline function instead.&quot;</span><span class="s1">});</span><span class="s3">return</span><span class="s1">}c({node:g,message:</span><span class="s2">&quot;React Hook &quot;</span><span class="s1">+h+</span><span class="s2">&quot; has a missing dependency: '&quot;</span><span class="s1">+f.name+</span><span class="s2">&quot;'. Either include it or remove the dependency array.&quot;</span><span class="s1">,suggest:[{desc:</span><span class="s2">&quot;Update the dependencies array to be: [&quot;</span><span class="s1">+f.name+</span><span class="s2">&quot;]&quot;</span><span class="s1">,fix:</span><span class="s3">function</span><span class="s1">(a){</span><span class="s3">return </span><span class="s1">a.replaceText(m,</span><span class="s2">&quot;[&quot;</span><span class="s1">+f.name+</span><span class="s2">&quot;]&quot;</span><span class="s1">)}}]})}</span><span class="s3">else</span><span class="s2">&quot;useMemo&quot;</span><span class="s1">!==</span>
<span class="s1">h&amp;&amp;</span><span class="s2">&quot;useCallback&quot;</span><span class="s1">!==h||c({node:g,message:</span><span class="s2">&quot;React Hook &quot;</span><span class="s1">+h+</span><span class="s2">&quot; does nothing when called with only one argument. Did you forget to pass an array of dependencies?&quot;</span><span class="s1">});</span><span class="s3">else </span><span class="s1">c({node:g,message:</span><span class="s2">&quot;React Hook &quot;</span><span class="s1">+h+</span><span class="s2">&quot; requires an effect callback. Did you forget to pass a callback to the hook?&quot;</span><span class="s1">})}}}}}};</span>
</pre>
</body>
</html>
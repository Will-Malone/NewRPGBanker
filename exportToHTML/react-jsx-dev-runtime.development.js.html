<html>
<head>
<title>react-jsx-dev-runtime.development.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
.s5 { color: #4646f1;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
react-jsx-dev-runtime.development.js</font>
</center></td></tr></table>
<pre><span class="s0">/** 
 * @license React 
 * react-jsx-dev-runtime.development.js 
 * 
 * Copyright (c) Facebook, Inc. and its affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>

<span class="s2">'use strict'</span><span class="s1">;</span>

<span class="s3">if </span><span class="s1">(process.env.NODE_ENV !== </span><span class="s2">&quot;production&quot;</span><span class="s1">) {</span>
  <span class="s1">(</span><span class="s3">function</span><span class="s1">() {</span>
<span class="s2">'use strict'</span><span class="s1">;</span>

<span class="s3">var </span><span class="s1">React = require(</span><span class="s2">'react'</span><span class="s1">);</span>

<span class="s0">// ATTENTION</span>
<span class="s0">// When adding new symbols to this file,</span>
<span class="s0">// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'</span>
<span class="s0">// The Symbol used to tag the ReactElement-like types.</span>
<span class="s3">var </span><span class="s1">REACT_ELEMENT_TYPE = Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">'react.element'</span><span class="s1">);</span>
<span class="s3">var </span><span class="s1">REACT_PORTAL_TYPE = Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">'react.portal'</span><span class="s1">);</span>
<span class="s3">var </span><span class="s1">REACT_FRAGMENT_TYPE = Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">'react.fragment'</span><span class="s1">);</span>
<span class="s3">var </span><span class="s1">REACT_STRICT_MODE_TYPE = Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">'react.strict_mode'</span><span class="s1">);</span>
<span class="s3">var </span><span class="s1">REACT_PROFILER_TYPE = Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">'react.profiler'</span><span class="s1">);</span>
<span class="s3">var </span><span class="s1">REACT_PROVIDER_TYPE = Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">'react.provider'</span><span class="s1">);</span>
<span class="s3">var </span><span class="s1">REACT_CONTEXT_TYPE = Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">'react.context'</span><span class="s1">);</span>
<span class="s3">var </span><span class="s1">REACT_FORWARD_REF_TYPE = Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">'react.forward_ref'</span><span class="s1">);</span>
<span class="s3">var </span><span class="s1">REACT_SUSPENSE_TYPE = Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">'react.suspense'</span><span class="s1">);</span>
<span class="s3">var </span><span class="s1">REACT_SUSPENSE_LIST_TYPE = Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">'react.suspense_list'</span><span class="s1">);</span>
<span class="s3">var </span><span class="s1">REACT_MEMO_TYPE = Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">'react.memo'</span><span class="s1">);</span>
<span class="s3">var </span><span class="s1">REACT_LAZY_TYPE = Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">'react.lazy'</span><span class="s1">);</span>
<span class="s3">var </span><span class="s1">REACT_OFFSCREEN_TYPE = Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">'react.offscreen'</span><span class="s1">);</span>
<span class="s3">var </span><span class="s1">MAYBE_ITERATOR_SYMBOL = Symbol.iterator;</span>
<span class="s3">var </span><span class="s1">FAUX_ITERATOR_SYMBOL = </span><span class="s2">'@@iterator'</span><span class="s1">;</span>
<span class="s3">function </span><span class="s1">getIteratorFn(maybeIterable) {</span>
  <span class="s3">if </span><span class="s1">(maybeIterable === </span><span class="s3">null </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">maybeIterable !== </span><span class="s2">'object'</span><span class="s1">) {</span>
    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">maybeIterator = MAYBE_ITERATOR_SYMBOL &amp;&amp; maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];</span>

  <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">maybeIterator === </span><span class="s2">'function'</span><span class="s1">) {</span>
    <span class="s3">return </span><span class="s1">maybeIterator;</span>
  <span class="s1">}</span>

  <span class="s3">return null</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;</span>

<span class="s3">function </span><span class="s1">error(format) {</span>
  <span class="s1">{</span>
    <span class="s1">{</span>
      <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">_len2 = arguments.length, args = </span><span class="s3">new </span><span class="s1">Array(_len2 &gt; </span><span class="s4">1 </span><span class="s1">? _len2 - </span><span class="s4">1 </span><span class="s1">: </span><span class="s4">0</span><span class="s1">), _key2 = </span><span class="s4">1</span><span class="s1">; _key2 &lt; _len2; _key2++) {</span>
        <span class="s1">args[_key2 - </span><span class="s4">1</span><span class="s1">] = arguments[_key2];</span>
      <span class="s1">}</span>

      <span class="s1">printWarning(</span><span class="s2">'error'</span><span class="s1">, format, args);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">printWarning(level, format, args) {</span>
  <span class="s0">// When changing this logic, you might want to also</span>
  <span class="s0">// update consoleWithStackDev.www.js as well.</span>
  <span class="s1">{</span>
    <span class="s3">var </span><span class="s1">ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;</span>
    <span class="s3">var </span><span class="s1">stack = ReactDebugCurrentFrame.getStackAddendum();</span>

    <span class="s3">if </span><span class="s1">(stack !== </span><span class="s2">''</span><span class="s1">) {</span>
      <span class="s1">format += </span><span class="s2">'%s'</span><span class="s1">;</span>
      <span class="s1">args = args.concat([stack]);</span>
    <span class="s1">} </span><span class="s0">// eslint-disable-next-line react-internal/safe-string-coercion</span>


    <span class="s3">var </span><span class="s1">argsWithFormat = args.map(</span><span class="s3">function </span><span class="s1">(item) {</span>
      <span class="s3">return </span><span class="s1">String(item);</span>
    <span class="s1">}); </span><span class="s0">// Careful: RN currently depends on this prefix</span>

    <span class="s1">argsWithFormat.unshift(</span><span class="s2">'Warning: ' </span><span class="s1">+ format); </span><span class="s0">// We intentionally don't use spread (or .apply) directly because it</span>
    <span class="s0">// breaks IE9: https://github.com/facebook/react/issues/13610</span>
    <span class="s0">// eslint-disable-next-line react-internal/no-production-logging</span>

    <span class="s1">Function.prototype.apply.call(console[level], console, argsWithFormat);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">// -----------------------------------------------------------------------------</span>

<span class="s3">var </span><span class="s1">enableScopeAPI = </span><span class="s3">false</span><span class="s1">; </span><span class="s0">// Experimental Create Event Handle API.</span>
<span class="s3">var </span><span class="s1">enableCacheElement = </span><span class="s3">false</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">enableTransitionTracing = </span><span class="s3">false</span><span class="s1">; </span><span class="s0">// No known bugs, but needs performance testing</span>

<span class="s3">var </span><span class="s1">enableLegacyHidden = </span><span class="s3">false</span><span class="s1">; </span><span class="s0">// Enables unstable_avoidThisFallback feature in Fiber</span>
<span class="s0">// stuff. Intended to enable React core members to more easily debug scheduling</span>
<span class="s0">// issues in DEV builds.</span>

<span class="s3">var </span><span class="s1">enableDebugTracing = </span><span class="s3">false</span><span class="s1">; </span><span class="s0">// Track which Fiber(s) schedule render work.</span>

<span class="s3">var </span><span class="s1">REACT_MODULE_REFERENCE;</span>

<span class="s1">{</span>
  <span class="s1">REACT_MODULE_REFERENCE = Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">'react.module.reference'</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">isValidElementType(type) {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">type === </span><span class="s2">'string' </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">type === </span><span class="s2">'function'</span><span class="s1">) {</span>
    <span class="s3">return true</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s0">// Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).</span>


  <span class="s3">if </span><span class="s1">(type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {</span>
    <span class="s3">return true</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">type === </span><span class="s2">'object' </span><span class="s1">&amp;&amp; type !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">if </span><span class="s1">(type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || </span><span class="s0">// This needs to include all possible module reference object</span>
    <span class="s0">// types supported by any Flight configuration anywhere since</span>
    <span class="s0">// we don't know which Flight build this will end up being used</span>
    <span class="s0">// with.</span>
    <span class="s1">type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {</span>
      <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">return false</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">getWrappedName(outerType, innerType, wrapperName) {</span>
  <span class="s3">var </span><span class="s1">displayName = outerType.displayName;</span>

  <span class="s3">if </span><span class="s1">(displayName) {</span>
    <span class="s3">return </span><span class="s1">displayName;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">functionName = innerType.displayName || innerType.name || </span><span class="s2">''</span><span class="s1">;</span>
  <span class="s3">return </span><span class="s1">functionName !== </span><span class="s2">'' </span><span class="s1">? wrapperName + </span><span class="s2">&quot;(&quot; </span><span class="s1">+ functionName + </span><span class="s2">&quot;)&quot; </span><span class="s1">: wrapperName;</span>
<span class="s1">} </span><span class="s0">// Keep in sync with react-reconciler/getComponentNameFromFiber</span>


<span class="s3">function </span><span class="s1">getContextName(type) {</span>
  <span class="s3">return </span><span class="s1">type.displayName || </span><span class="s2">'Context'</span><span class="s1">;</span>
<span class="s1">} </span><span class="s0">// Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.</span>


<span class="s3">function </span><span class="s1">getComponentNameFromType(type) {</span>
  <span class="s3">if </span><span class="s1">(type == </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s0">// Host root, text node or just invalid type.</span>
    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">type.tag === </span><span class="s2">'number'</span><span class="s1">) {</span>
      <span class="s1">error(</span><span class="s2">'Received an unexpected object in getComponentNameFromType(). ' </span><span class="s1">+ </span><span class="s2">'This is likely a bug in React. Please file an issue.'</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">type === </span><span class="s2">'function'</span><span class="s1">) {</span>
    <span class="s3">return </span><span class="s1">type.displayName || type.name || </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">type === </span><span class="s2">'string'</span><span class="s1">) {</span>
    <span class="s3">return </span><span class="s1">type;</span>
  <span class="s1">}</span>

  <span class="s3">switch </span><span class="s1">(type) {</span>
    <span class="s3">case </span><span class="s1">REACT_FRAGMENT_TYPE:</span>
      <span class="s3">return </span><span class="s2">'Fragment'</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s1">REACT_PORTAL_TYPE:</span>
      <span class="s3">return </span><span class="s2">'Portal'</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s1">REACT_PROFILER_TYPE:</span>
      <span class="s3">return </span><span class="s2">'Profiler'</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s1">REACT_STRICT_MODE_TYPE:</span>
      <span class="s3">return </span><span class="s2">'StrictMode'</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s1">REACT_SUSPENSE_TYPE:</span>
      <span class="s3">return </span><span class="s2">'Suspense'</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s1">REACT_SUSPENSE_LIST_TYPE:</span>
      <span class="s3">return </span><span class="s2">'SuspenseList'</span><span class="s1">;</span>

  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">type === </span><span class="s2">'object'</span><span class="s1">) {</span>
    <span class="s3">switch </span><span class="s1">(type.$$typeof) {</span>
      <span class="s3">case </span><span class="s1">REACT_CONTEXT_TYPE:</span>
        <span class="s3">var </span><span class="s1">context = type;</span>
        <span class="s3">return </span><span class="s1">getContextName(context) + </span><span class="s2">'.Consumer'</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s1">REACT_PROVIDER_TYPE:</span>
        <span class="s3">var </span><span class="s1">provider = type;</span>
        <span class="s3">return </span><span class="s1">getContextName(provider._context) + </span><span class="s2">'.Provider'</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s1">REACT_FORWARD_REF_TYPE:</span>
        <span class="s3">return </span><span class="s1">getWrappedName(type, type.render, </span><span class="s2">'ForwardRef'</span><span class="s1">);</span>

      <span class="s3">case </span><span class="s1">REACT_MEMO_TYPE:</span>
        <span class="s3">var </span><span class="s1">outerName = type.displayName || </span><span class="s3">null</span><span class="s1">;</span>

        <span class="s3">if </span><span class="s1">(outerName !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s3">return </span><span class="s1">outerName;</span>
        <span class="s1">}</span>

        <span class="s3">return </span><span class="s1">getComponentNameFromType(type.type) || </span><span class="s2">'Memo'</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s1">REACT_LAZY_TYPE:</span>
        <span class="s1">{</span>
          <span class="s3">var </span><span class="s1">lazyComponent = type;</span>
          <span class="s3">var </span><span class="s1">payload = lazyComponent._payload;</span>
          <span class="s3">var </span><span class="s1">init = lazyComponent._init;</span>

          <span class="s3">try </span><span class="s1">{</span>
            <span class="s3">return </span><span class="s1">getComponentNameFromType(init(payload));</span>
          <span class="s1">} </span><span class="s3">catch </span><span class="s1">(x) {</span>
            <span class="s3">return null</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

      <span class="s0">// eslint-disable-next-line no-fallthrough</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">return null</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">assign = Object.assign;</span>

<span class="s0">// Helpers to patch console.logs to avoid logging during side-effect free</span>
<span class="s0">// replaying on render function. This currently only patches the object</span>
<span class="s0">// lazily which won't cover if the log function was extracted eagerly.</span>
<span class="s0">// We could also eagerly patch the method.</span>
<span class="s3">var </span><span class="s1">disabledDepth = </span><span class="s4">0</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">prevLog;</span>
<span class="s3">var </span><span class="s1">prevInfo;</span>
<span class="s3">var </span><span class="s1">prevWarn;</span>
<span class="s3">var </span><span class="s1">prevError;</span>
<span class="s3">var </span><span class="s1">prevGroup;</span>
<span class="s3">var </span><span class="s1">prevGroupCollapsed;</span>
<span class="s3">var </span><span class="s1">prevGroupEnd;</span>

<span class="s3">function </span><span class="s1">disabledLog() {}</span>

<span class="s1">disabledLog.__reactDisabledLog = </span><span class="s3">true</span><span class="s1">;</span>
<span class="s3">function </span><span class="s1">disableLogs() {</span>
  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(disabledDepth === </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s0">/* eslint-disable react-internal/no-production-logging */</span>
      <span class="s1">prevLog = console.log;</span>
      <span class="s1">prevInfo = console.info;</span>
      <span class="s1">prevWarn = console.warn;</span>
      <span class="s1">prevError = console.error;</span>
      <span class="s1">prevGroup = console.group;</span>
      <span class="s1">prevGroupCollapsed = console.groupCollapsed;</span>
      <span class="s1">prevGroupEnd = console.groupEnd; </span><span class="s0">// https://github.com/facebook/react/issues/19099</span>

      <span class="s3">var </span><span class="s1">props = {</span>
        <span class="s1">configurable: </span><span class="s3">true</span><span class="s1">,</span>
        <span class="s1">enumerable: </span><span class="s3">true</span><span class="s1">,</span>
        <span class="s1">value: disabledLog,</span>
        <span class="s1">writable: </span><span class="s3">true</span>
      <span class="s1">}; </span><span class="s0">// $FlowFixMe Flow thinks console is immutable.</span>

      <span class="s1">Object.defineProperties(console, {</span>
        <span class="s1">info: props,</span>
        <span class="s1">log: props,</span>
        <span class="s1">warn: props,</span>
        <span class="s1">error: props,</span>
        <span class="s1">group: props,</span>
        <span class="s1">groupCollapsed: props,</span>
        <span class="s1">groupEnd: props</span>
      <span class="s1">});</span>
      <span class="s0">/* eslint-enable react-internal/no-production-logging */</span>
    <span class="s1">}</span>

    <span class="s1">disabledDepth++;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">reenableLogs() {</span>
  <span class="s1">{</span>
    <span class="s1">disabledDepth--;</span>

    <span class="s3">if </span><span class="s1">(disabledDepth === </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s0">/* eslint-disable react-internal/no-production-logging */</span>
      <span class="s3">var </span><span class="s1">props = {</span>
        <span class="s1">configurable: </span><span class="s3">true</span><span class="s1">,</span>
        <span class="s1">enumerable: </span><span class="s3">true</span><span class="s1">,</span>
        <span class="s1">writable: </span><span class="s3">true</span>
      <span class="s1">}; </span><span class="s0">// $FlowFixMe Flow thinks console is immutable.</span>

      <span class="s1">Object.defineProperties(console, {</span>
        <span class="s1">log: assign({}, props, {</span>
          <span class="s1">value: prevLog</span>
        <span class="s1">}),</span>
        <span class="s1">info: assign({}, props, {</span>
          <span class="s1">value: prevInfo</span>
        <span class="s1">}),</span>
        <span class="s1">warn: assign({}, props, {</span>
          <span class="s1">value: prevWarn</span>
        <span class="s1">}),</span>
        <span class="s1">error: assign({}, props, {</span>
          <span class="s1">value: prevError</span>
        <span class="s1">}),</span>
        <span class="s1">group: assign({}, props, {</span>
          <span class="s1">value: prevGroup</span>
        <span class="s1">}),</span>
        <span class="s1">groupCollapsed: assign({}, props, {</span>
          <span class="s1">value: prevGroupCollapsed</span>
        <span class="s1">}),</span>
        <span class="s1">groupEnd: assign({}, props, {</span>
          <span class="s1">value: prevGroupEnd</span>
        <span class="s1">})</span>
      <span class="s1">});</span>
      <span class="s0">/* eslint-enable react-internal/no-production-logging */</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(disabledDepth &lt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s1">error(</span><span class="s2">'disabledDepth fell below zero. ' </span><span class="s1">+ </span><span class="s2">'This is a bug in React. Please file an issue.'</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;</span>
<span class="s3">var </span><span class="s1">prefix;</span>
<span class="s3">function </span><span class="s1">describeBuiltInComponentFrame(name, source, ownerFn) {</span>
  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(prefix === undefined) {</span>
      <span class="s0">// Extract the VM specific prefix used by each line.</span>
      <span class="s3">try </span><span class="s1">{</span>
        <span class="s3">throw </span><span class="s1">Error();</span>
      <span class="s1">} </span><span class="s3">catch </span><span class="s1">(x) {</span>
        <span class="s3">var </span><span class="s1">match = x.stack.trim().match(/\n( *(at )?)/);</span>
        <span class="s1">prefix = match &amp;&amp; match[</span><span class="s4">1</span><span class="s1">] || </span><span class="s2">''</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// We use the prefix to ensure our stacks line up with native stack frames.</span>


    <span class="s3">return </span><span class="s2">'</span><span class="s5">\n</span><span class="s2">' </span><span class="s1">+ prefix + name;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">var </span><span class="s1">reentry = </span><span class="s3">false</span><span class="s1">;</span>
<span class="s3">var </span><span class="s1">componentFrameCache;</span>

<span class="s1">{</span>
  <span class="s3">var </span><span class="s1">PossiblyWeakMap = </span><span class="s3">typeof </span><span class="s1">WeakMap === </span><span class="s2">'function' </span><span class="s1">? WeakMap : Map;</span>
  <span class="s1">componentFrameCache = </span><span class="s3">new </span><span class="s1">PossiblyWeakMap();</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">describeNativeComponentFrame(fn, construct) {</span>
  <span class="s0">// If something asked for a stack inside a fake render, it should get ignored.</span>
  <span class="s3">if </span><span class="s1">( !fn || reentry) {</span>
    <span class="s3">return </span><span class="s2">''</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s1">{</span>
    <span class="s3">var </span><span class="s1">frame = componentFrameCache.get(fn);</span>

    <span class="s3">if </span><span class="s1">(frame !== undefined) {</span>
      <span class="s3">return </span><span class="s1">frame;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">control;</span>
  <span class="s1">reentry = </span><span class="s3">true</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">previousPrepareStackTrace = Error.prepareStackTrace; </span><span class="s0">// $FlowFixMe It does accept undefined.</span>

  <span class="s1">Error.prepareStackTrace = undefined;</span>
  <span class="s3">var </span><span class="s1">previousDispatcher;</span>

  <span class="s1">{</span>
    <span class="s1">previousDispatcher = ReactCurrentDispatcher.current; </span><span class="s0">// Set the dispatcher in DEV because this might be call in the render function</span>
    <span class="s0">// for warnings.</span>

    <span class="s1">ReactCurrentDispatcher.current = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">disableLogs();</span>
  <span class="s1">}</span>

  <span class="s3">try </span><span class="s1">{</span>
    <span class="s0">// This should throw.</span>
    <span class="s3">if </span><span class="s1">(construct) {</span>
      <span class="s0">// Something should be setting the props in the constructor.</span>
      <span class="s3">var </span><span class="s1">Fake = </span><span class="s3">function </span><span class="s1">() {</span>
        <span class="s3">throw </span><span class="s1">Error();</span>
      <span class="s1">}; </span><span class="s0">// $FlowFixMe</span>


      <span class="s1">Object.defineProperty(Fake.prototype, </span><span class="s2">'props'</span><span class="s1">, {</span>
        <span class="s1">set: </span><span class="s3">function </span><span class="s1">() {</span>
          <span class="s0">// We use a throwing setter instead of frozen or non-writable props</span>
          <span class="s0">// because that won't throw in a non-strict mode function.</span>
          <span class="s3">throw </span><span class="s1">Error();</span>
        <span class="s1">}</span>
      <span class="s1">});</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">Reflect === </span><span class="s2">'object' </span><span class="s1">&amp;&amp; Reflect.construct) {</span>
        <span class="s0">// We construct a different control for this case to include any extra</span>
        <span class="s0">// frames added by the construct call.</span>
        <span class="s3">try </span><span class="s1">{</span>
          <span class="s1">Reflect.construct(Fake, []);</span>
        <span class="s1">} </span><span class="s3">catch </span><span class="s1">(x) {</span>
          <span class="s1">control = x;</span>
        <span class="s1">}</span>

        <span class="s1">Reflect.construct(fn, [], Fake);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s3">try </span><span class="s1">{</span>
          <span class="s1">Fake.call();</span>
        <span class="s1">} </span><span class="s3">catch </span><span class="s1">(x) {</span>
          <span class="s1">control = x;</span>
        <span class="s1">}</span>

        <span class="s1">fn.call(Fake.prototype);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">try </span><span class="s1">{</span>
        <span class="s3">throw </span><span class="s1">Error();</span>
      <span class="s1">} </span><span class="s3">catch </span><span class="s1">(x) {</span>
        <span class="s1">control = x;</span>
      <span class="s1">}</span>

      <span class="s1">fn();</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s3">catch </span><span class="s1">(sample) {</span>
    <span class="s0">// This is inlined manually because closure doesn't do it for us.</span>
    <span class="s3">if </span><span class="s1">(sample &amp;&amp; control &amp;&amp; </span><span class="s3">typeof </span><span class="s1">sample.stack === </span><span class="s2">'string'</span><span class="s1">) {</span>
      <span class="s0">// This extracts the first frame from the sample that isn't also in the control.</span>
      <span class="s0">// Skipping one frame that we assume is the frame that calls the two.</span>
      <span class="s3">var </span><span class="s1">sampleLines = sample.stack.split(</span><span class="s2">'</span><span class="s5">\n</span><span class="s2">'</span><span class="s1">);</span>
      <span class="s3">var </span><span class="s1">controlLines = control.stack.split(</span><span class="s2">'</span><span class="s5">\n</span><span class="s2">'</span><span class="s1">);</span>
      <span class="s3">var </span><span class="s1">s = sampleLines.length - </span><span class="s4">1</span><span class="s1">;</span>
      <span class="s3">var </span><span class="s1">c = controlLines.length - </span><span class="s4">1</span><span class="s1">;</span>

      <span class="s3">while </span><span class="s1">(s &gt;= </span><span class="s4">1 </span><span class="s1">&amp;&amp; c &gt;= </span><span class="s4">0 </span><span class="s1">&amp;&amp; sampleLines[s] !== controlLines[c]) {</span>
        <span class="s0">// We expect at least one stack frame to be shared.</span>
        <span class="s0">// Typically this will be the root most one. However, stack frames may be</span>
        <span class="s0">// cut off due to maximum stack limits. In this case, one maybe cut off</span>
        <span class="s0">// earlier than the other. We assume that the sample is longer or the same</span>
        <span class="s0">// and there for cut off earlier. So we should find the root most frame in</span>
        <span class="s0">// the sample somewhere in the control.</span>
        <span class="s1">c--;</span>
      <span class="s1">}</span>

      <span class="s3">for </span><span class="s1">(; s &gt;= </span><span class="s4">1 </span><span class="s1">&amp;&amp; c &gt;= </span><span class="s4">0</span><span class="s1">; s--, c--) {</span>
        <span class="s0">// Next we find the first one that isn't the same which should be the</span>
        <span class="s0">// frame that called our sample function and the control.</span>
        <span class="s3">if </span><span class="s1">(sampleLines[s] !== controlLines[c]) {</span>
          <span class="s0">// In V8, the first line is describing the message but other VMs don't.</span>
          <span class="s0">// If we're about to return the first line, and the control is also on the same</span>
          <span class="s0">// line, that's a pretty good indicator that our sample threw at same line as</span>
          <span class="s0">// the control. I.e. before we entered the sample frame. So we ignore this result.</span>
          <span class="s0">// This can happen if you passed a class to function component, or non-function.</span>
          <span class="s3">if </span><span class="s1">(s !== </span><span class="s4">1 </span><span class="s1">|| c !== </span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s3">do </span><span class="s1">{</span>
              <span class="s1">s--;</span>
              <span class="s1">c--; </span><span class="s0">// We may still have similar intermediate frames from the construct call.</span>
              <span class="s0">// The next one that isn't the same should be our match though.</span>

              <span class="s3">if </span><span class="s1">(c &lt; </span><span class="s4">0 </span><span class="s1">|| sampleLines[s] !== controlLines[c]) {</span>
                <span class="s0">// V8 adds a &quot;new&quot; prefix for native classes. Let's remove it to make it prettier.</span>
                <span class="s3">var </span><span class="s1">_frame = </span><span class="s2">'</span><span class="s5">\n</span><span class="s2">' </span><span class="s1">+ sampleLines[s].replace(</span><span class="s2">' at new '</span><span class="s1">, </span><span class="s2">' at '</span><span class="s1">); </span><span class="s0">// If our component frame is labeled &quot;&lt;anonymous&gt;&quot;</span>
                <span class="s0">// but we have a user-provided &quot;displayName&quot;</span>
                <span class="s0">// splice it in to make the stack more readable.</span>


                <span class="s3">if </span><span class="s1">(fn.displayName &amp;&amp; _frame.includes(</span><span class="s2">'&lt;anonymous&gt;'</span><span class="s1">)) {</span>
                  <span class="s1">_frame = _frame.replace(</span><span class="s2">'&lt;anonymous&gt;'</span><span class="s1">, fn.displayName);</span>
                <span class="s1">}</span>

                <span class="s1">{</span>
                  <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">fn === </span><span class="s2">'function'</span><span class="s1">) {</span>
                    <span class="s1">componentFrameCache.set(fn, _frame);</span>
                  <span class="s1">}</span>
                <span class="s1">} </span><span class="s0">// Return the line we found.</span>


                <span class="s3">return </span><span class="s1">_frame;</span>
              <span class="s1">}</span>
            <span class="s1">} </span><span class="s3">while </span><span class="s1">(s &gt;= </span><span class="s4">1 </span><span class="s1">&amp;&amp; c &gt;= </span><span class="s4">0</span><span class="s1">);</span>
          <span class="s1">}</span>

          <span class="s3">break</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
    <span class="s1">reentry = </span><span class="s3">false</span><span class="s1">;</span>

    <span class="s1">{</span>
      <span class="s1">ReactCurrentDispatcher.current = previousDispatcher;</span>
      <span class="s1">reenableLogs();</span>
    <span class="s1">}</span>

    <span class="s1">Error.prepareStackTrace = previousPrepareStackTrace;</span>
  <span class="s1">} </span><span class="s0">// Fallback to just using the name if we couldn't make it throw.</span>


  <span class="s3">var </span><span class="s1">name = fn ? fn.displayName || fn.name : </span><span class="s2">''</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">syntheticFrame = name ? describeBuiltInComponentFrame(name) : </span><span class="s2">''</span><span class="s1">;</span>

  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">fn === </span><span class="s2">'function'</span><span class="s1">) {</span>
      <span class="s1">componentFrameCache.set(fn, syntheticFrame);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">syntheticFrame;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">describeFunctionComponentFrame(fn, source, ownerFn) {</span>
  <span class="s1">{</span>
    <span class="s3">return </span><span class="s1">describeNativeComponentFrame(fn, </span><span class="s3">false</span><span class="s1">);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">shouldConstruct(Component) {</span>
  <span class="s3">var </span><span class="s1">prototype = Component.prototype;</span>
  <span class="s3">return </span><span class="s1">!!(prototype &amp;&amp; prototype.isReactComponent);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {</span>

  <span class="s3">if </span><span class="s1">(type == </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">return </span><span class="s2">''</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">type === </span><span class="s2">'function'</span><span class="s1">) {</span>
    <span class="s1">{</span>
      <span class="s3">return </span><span class="s1">describeNativeComponentFrame(type, shouldConstruct(type));</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">type === </span><span class="s2">'string'</span><span class="s1">) {</span>
    <span class="s3">return </span><span class="s1">describeBuiltInComponentFrame(type);</span>
  <span class="s1">}</span>

  <span class="s3">switch </span><span class="s1">(type) {</span>
    <span class="s3">case </span><span class="s1">REACT_SUSPENSE_TYPE:</span>
      <span class="s3">return </span><span class="s1">describeBuiltInComponentFrame(</span><span class="s2">'Suspense'</span><span class="s1">);</span>

    <span class="s3">case </span><span class="s1">REACT_SUSPENSE_LIST_TYPE:</span>
      <span class="s3">return </span><span class="s1">describeBuiltInComponentFrame(</span><span class="s2">'SuspenseList'</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">type === </span><span class="s2">'object'</span><span class="s1">) {</span>
    <span class="s3">switch </span><span class="s1">(type.$$typeof) {</span>
      <span class="s3">case </span><span class="s1">REACT_FORWARD_REF_TYPE:</span>
        <span class="s3">return </span><span class="s1">describeFunctionComponentFrame(type.render);</span>

      <span class="s3">case </span><span class="s1">REACT_MEMO_TYPE:</span>
        <span class="s0">// Memo may contain any component type so we recursively resolve it.</span>
        <span class="s3">return </span><span class="s1">describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);</span>

      <span class="s3">case </span><span class="s1">REACT_LAZY_TYPE:</span>
        <span class="s1">{</span>
          <span class="s3">var </span><span class="s1">lazyComponent = type;</span>
          <span class="s3">var </span><span class="s1">payload = lazyComponent._payload;</span>
          <span class="s3">var </span><span class="s1">init = lazyComponent._init;</span>

          <span class="s3">try </span><span class="s1">{</span>
            <span class="s0">// Lazy may contain any component type so we recursively resolve it.</span>
            <span class="s3">return </span><span class="s1">describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);</span>
          <span class="s1">} </span><span class="s3">catch </span><span class="s1">(x) {}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s2">''</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">hasOwnProperty = Object.prototype.hasOwnProperty;</span>

<span class="s3">var </span><span class="s1">loggedTypeFailures = {};</span>
<span class="s3">var </span><span class="s1">ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;</span>

<span class="s3">function </span><span class="s1">setCurrentlyValidatingElement(element) {</span>
  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(element) {</span>
      <span class="s3">var </span><span class="s1">owner = element._owner;</span>
      <span class="s3">var </span><span class="s1">stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : </span><span class="s3">null</span><span class="s1">);</span>
      <span class="s1">ReactDebugCurrentFrame.setExtraStackFrame(stack);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">ReactDebugCurrentFrame.setExtraStackFrame(</span><span class="s3">null</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">checkPropTypes(typeSpecs, values, location, componentName, element) {</span>
  <span class="s1">{</span>
    <span class="s0">// $FlowFixMe This is okay but Flow doesn't know it.</span>
    <span class="s3">var </span><span class="s1">has = Function.call.bind(hasOwnProperty);</span>

    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">typeSpecName </span><span class="s3">in </span><span class="s1">typeSpecs) {</span>
      <span class="s3">if </span><span class="s1">(has(typeSpecs, typeSpecName)) {</span>
        <span class="s3">var </span><span class="s1">error$1 = </span><span class="s3">void </span><span class="s4">0</span><span class="s1">; </span><span class="s0">// Prop type validation may throw. In case they do, we don't want to</span>
        <span class="s0">// fail the render phase where it didn't fail before. So we log it.</span>
        <span class="s0">// After these have been cleaned up, we'll let them throw.</span>

        <span class="s3">try </span><span class="s1">{</span>
          <span class="s0">// This is intentionally an invariant that gets caught. It's the same</span>
          <span class="s0">// behavior as without this statement except with a better message.</span>
          <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">typeSpecs[typeSpecName] !== </span><span class="s2">'function'</span><span class="s1">) {</span>
            <span class="s0">// eslint-disable-next-line react-internal/prod-error-codes</span>
            <span class="s3">var </span><span class="s1">err = Error((componentName || </span><span class="s2">'React class'</span><span class="s1">) + </span><span class="s2">': ' </span><span class="s1">+ location + </span><span class="s2">' type `' </span><span class="s1">+ typeSpecName + </span><span class="s2">'` is invalid; ' </span><span class="s1">+ </span><span class="s2">'it must be a function, usually from the `prop-types` package, but received `' </span><span class="s1">+ </span><span class="s3">typeof </span><span class="s1">typeSpecs[typeSpecName] + </span><span class="s2">'`.' </span><span class="s1">+ </span><span class="s2">'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.'</span><span class="s1">);</span>
            <span class="s1">err.name = </span><span class="s2">'Invariant Violation'</span><span class="s1">;</span>
            <span class="s3">throw </span><span class="s1">err;</span>
          <span class="s1">}</span>

          <span class="s1">error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, </span><span class="s3">null</span><span class="s1">, </span><span class="s2">'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED'</span><span class="s1">);</span>
        <span class="s1">} </span><span class="s3">catch </span><span class="s1">(ex) {</span>
          <span class="s1">error$1 = ex;</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(error$1 &amp;&amp; !(error$1 </span><span class="s3">instanceof </span><span class="s1">Error)) {</span>
          <span class="s1">setCurrentlyValidatingElement(element);</span>

          <span class="s1">error(</span><span class="s2">'%s: type specification of %s' </span><span class="s1">+ </span><span class="s2">' `%s` is invalid; the type checker ' </span><span class="s1">+ </span><span class="s2">'function must return `null` or an `Error` but returned a %s. ' </span><span class="s1">+ </span><span class="s2">'You may have forgotten to pass an argument to the type checker ' </span><span class="s1">+ </span><span class="s2">'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' </span><span class="s1">+ </span><span class="s2">'shape all require an argument).'</span><span class="s1">, componentName || </span><span class="s2">'React class'</span><span class="s1">, location, typeSpecName, </span><span class="s3">typeof </span><span class="s1">error$1);</span>

          <span class="s1">setCurrentlyValidatingElement(</span><span class="s3">null</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(error$1 </span><span class="s3">instanceof </span><span class="s1">Error &amp;&amp; !(error$1.message </span><span class="s3">in </span><span class="s1">loggedTypeFailures)) {</span>
          <span class="s0">// Only monitor this failure once because there tends to be a lot of the</span>
          <span class="s0">// same error.</span>
          <span class="s1">loggedTypeFailures[error$1.message] = </span><span class="s3">true</span><span class="s1">;</span>
          <span class="s1">setCurrentlyValidatingElement(element);</span>

          <span class="s1">error(</span><span class="s2">'Failed %s type: %s'</span><span class="s1">, location, error$1.message);</span>

          <span class="s1">setCurrentlyValidatingElement(</span><span class="s3">null</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">isArrayImpl = Array.isArray; </span><span class="s0">// eslint-disable-next-line no-redeclare</span>

<span class="s3">function </span><span class="s1">isArray(a) {</span>
  <span class="s3">return </span><span class="s1">isArrayImpl(a);</span>
<span class="s1">}</span>

<span class="s0">/* 
 * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol 
 * and Temporal.* types. See https://github.com/facebook/react/pull/22064. 
 * 
 * The functions in this module will throw an easier-to-understand, 
 * easier-to-debug exception with a clear errors message message explaining the 
 * problem. (Instead of a confusing exception thrown inside the implementation 
 * of the `value` object). 
 */</span>
<span class="s0">// $FlowFixMe only called in DEV, so void return is not possible.</span>
<span class="s3">function </span><span class="s1">typeName(value) {</span>
  <span class="s1">{</span>
    <span class="s0">// toStringTag is needed for namespaced types like Temporal.Instant</span>
    <span class="s3">var </span><span class="s1">hasToStringTag = </span><span class="s3">typeof </span><span class="s1">Symbol === </span><span class="s2">'function' </span><span class="s1">&amp;&amp; Symbol.toStringTag;</span>
    <span class="s3">var </span><span class="s1">type = hasToStringTag &amp;&amp; value[Symbol.toStringTag] || value.constructor.name || </span><span class="s2">'Object'</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s1">type;</span>
  <span class="s1">}</span>
<span class="s1">} </span><span class="s0">// $FlowFixMe only called in DEV, so void return is not possible.</span>


<span class="s3">function </span><span class="s1">willCoercionThrow(value) {</span>
  <span class="s1">{</span>
    <span class="s3">try </span><span class="s1">{</span>
      <span class="s1">testStringCoercion(value);</span>
      <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">catch </span><span class="s1">(e) {</span>
      <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">testStringCoercion(value) {</span>
  <span class="s0">// If you ended up here by following an exception call stack, here's what's</span>
  <span class="s0">// happened: you supplied an object or symbol value to React (as a prop, key,</span>
  <span class="s0">// DOM attribute, CSS property, string ref, etc.) and when React tried to</span>
  <span class="s0">// coerce it to a string using `'' + value`, an exception was thrown.</span>
  <span class="s0">//</span>
  <span class="s0">// The most common types that will cause this exception are `Symbol` instances</span>
  <span class="s0">// and Temporal objects like `Temporal.Instant`. But any object that has a</span>
  <span class="s0">// `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this</span>
  <span class="s0">// exception. (Library authors do this to prevent users from using built-in</span>
  <span class="s0">// numeric operators like `+` or comparison operators like `&gt;=` because custom</span>
  <span class="s0">// methods are needed to perform accurate arithmetic or comparison.)</span>
  <span class="s0">//</span>
  <span class="s0">// To fix the problem, coerce this object or symbol value to a string before</span>
  <span class="s0">// passing it to React. The most reliable way is usually `String(value)`.</span>
  <span class="s0">//</span>
  <span class="s0">// To find which value is throwing, check the browser or debugger console.</span>
  <span class="s0">// Before this exception was thrown, there should be `console.error` output</span>
  <span class="s0">// that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the</span>
  <span class="s0">// problem and how that type was used: key, atrribute, input value prop, etc.</span>
  <span class="s0">// In most cases, this console output also shows the component and its</span>
  <span class="s0">// ancestor components where the exception happened.</span>
  <span class="s0">//</span>
  <span class="s0">// eslint-disable-next-line react-internal/safe-string-coercion</span>
  <span class="s3">return </span><span class="s2">'' </span><span class="s1">+ value;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">checkKeyStringCoercion(value) {</span>
  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(willCoercionThrow(value)) {</span>
      <span class="s1">error(</span><span class="s2">'The provided key is an unsupported type %s.' </span><span class="s1">+ </span><span class="s2">' This value must be coerced to a string before before using it here.'</span><span class="s1">, typeName(value));</span>

      <span class="s3">return </span><span class="s1">testStringCoercion(value); </span><span class="s0">// throw (to help callers find troubleshooting comments)</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;</span>
<span class="s3">var </span><span class="s1">RESERVED_PROPS = {</span>
  <span class="s1">key: </span><span class="s3">true</span><span class="s1">,</span>
  <span class="s1">ref: </span><span class="s3">true</span><span class="s1">,</span>
  <span class="s1">__self: </span><span class="s3">true</span><span class="s1">,</span>
  <span class="s1">__source: </span><span class="s3">true</span>
<span class="s1">};</span>
<span class="s3">var </span><span class="s1">specialPropKeyWarningShown;</span>
<span class="s3">var </span><span class="s1">specialPropRefWarningShown;</span>
<span class="s3">var </span><span class="s1">didWarnAboutStringRefs;</span>

<span class="s1">{</span>
  <span class="s1">didWarnAboutStringRefs = {};</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">hasValidRef(config) {</span>
  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(hasOwnProperty.call(config, </span><span class="s2">'ref'</span><span class="s1">)) {</span>
      <span class="s3">var </span><span class="s1">getter = Object.getOwnPropertyDescriptor(config, </span><span class="s2">'ref'</span><span class="s1">).get;</span>

      <span class="s3">if </span><span class="s1">(getter &amp;&amp; getter.isReactWarning) {</span>
        <span class="s3">return false</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">config.ref !== undefined;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">hasValidKey(config) {</span>
  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(hasOwnProperty.call(config, </span><span class="s2">'key'</span><span class="s1">)) {</span>
      <span class="s3">var </span><span class="s1">getter = Object.getOwnPropertyDescriptor(config, </span><span class="s2">'key'</span><span class="s1">).get;</span>

      <span class="s3">if </span><span class="s1">(getter &amp;&amp; getter.isReactWarning) {</span>
        <span class="s3">return false</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">config.key !== undefined;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">warnIfStringRefCannotBeAutoConverted(config, self) {</span>
  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">config.ref === </span><span class="s2">'string' </span><span class="s1">&amp;&amp; ReactCurrentOwner.current &amp;&amp; self &amp;&amp; ReactCurrentOwner.current.stateNode !== self) {</span>
      <span class="s3">var </span><span class="s1">componentName = getComponentNameFromType(ReactCurrentOwner.current.type);</span>

      <span class="s3">if </span><span class="s1">(!didWarnAboutStringRefs[componentName]) {</span>
        <span class="s1">error(</span><span class="s2">'Component &quot;%s&quot; contains the string ref &quot;%s&quot;. ' </span><span class="s1">+ </span><span class="s2">'Support for string refs will be removed in a future major release. ' </span><span class="s1">+ </span><span class="s2">'This case cannot be automatically converted to an arrow function. ' </span><span class="s1">+ </span><span class="s2">'We ask you to manually fix this case by using useRef() or createRef() instead. ' </span><span class="s1">+ </span><span class="s2">'Learn more about using refs safely here: ' </span><span class="s1">+ </span><span class="s2">'https://reactjs.org/link/strict-mode-string-ref'</span><span class="s1">, getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);</span>

        <span class="s1">didWarnAboutStringRefs[componentName] = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">defineKeyPropWarningGetter(props, displayName) {</span>
  <span class="s1">{</span>
    <span class="s3">var </span><span class="s1">warnAboutAccessingKey = </span><span class="s3">function </span><span class="s1">() {</span>
      <span class="s3">if </span><span class="s1">(!specialPropKeyWarningShown) {</span>
        <span class="s1">specialPropKeyWarningShown = </span><span class="s3">true</span><span class="s1">;</span>

        <span class="s1">error(</span><span class="s2">'%s: `key` is not a prop. Trying to access it will result ' </span><span class="s1">+ </span><span class="s2">'in `undefined` being returned. If you need to access the same ' </span><span class="s1">+ </span><span class="s2">'value within the child component, you should pass it as a different ' </span><span class="s1">+ </span><span class="s2">'prop. (https://reactjs.org/link/special-props)'</span><span class="s1">, displayName);</span>
      <span class="s1">}</span>
    <span class="s1">};</span>

    <span class="s1">warnAboutAccessingKey.isReactWarning = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">Object.defineProperty(props, </span><span class="s2">'key'</span><span class="s1">, {</span>
      <span class="s1">get: warnAboutAccessingKey,</span>
      <span class="s1">configurable: </span><span class="s3">true</span>
    <span class="s1">});</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">defineRefPropWarningGetter(props, displayName) {</span>
  <span class="s1">{</span>
    <span class="s3">var </span><span class="s1">warnAboutAccessingRef = </span><span class="s3">function </span><span class="s1">() {</span>
      <span class="s3">if </span><span class="s1">(!specialPropRefWarningShown) {</span>
        <span class="s1">specialPropRefWarningShown = </span><span class="s3">true</span><span class="s1">;</span>

        <span class="s1">error(</span><span class="s2">'%s: `ref` is not a prop. Trying to access it will result ' </span><span class="s1">+ </span><span class="s2">'in `undefined` being returned. If you need to access the same ' </span><span class="s1">+ </span><span class="s2">'value within the child component, you should pass it as a different ' </span><span class="s1">+ </span><span class="s2">'prop. (https://reactjs.org/link/special-props)'</span><span class="s1">, displayName);</span>
      <span class="s1">}</span>
    <span class="s1">};</span>

    <span class="s1">warnAboutAccessingRef.isReactWarning = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">Object.defineProperty(props, </span><span class="s2">'ref'</span><span class="s1">, {</span>
      <span class="s1">get: warnAboutAccessingRef,</span>
      <span class="s1">configurable: </span><span class="s3">true</span>
    <span class="s1">});</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">/** 
 * Factory method to create a new React element. This no longer adheres to 
 * the class pattern, so do not use new to call it. Also, instanceof check 
 * will not work. Instead test $$typeof field against Symbol.for('react.element') to check 
 * if something is a React Element. 
 * 
 * @param {*} type 
 * @param {*} props 
 * @param {*} key 
 * @param {string|object} ref 
 * @param {*} owner 
 * @param {*} self A *temporary* helper to detect places where `this` is 
 * different from the `owner` when React.createElement is called, so that we 
 * can warn. We want to get rid of owner and replace string `ref`s with arrow 
 * functions, and as long as `this` and owner are the same, there will be no 
 * change in behavior. 
 * @param {*} source An annotation object (added by a transpiler or otherwise) 
 * indicating filename, line number, and/or other information. 
 * @internal 
 */</span>


<span class="s3">var </span><span class="s1">ReactElement = </span><span class="s3">function </span><span class="s1">(type, key, ref, self, source, owner, props) {</span>
  <span class="s3">var </span><span class="s1">element = {</span>
    <span class="s0">// This tag allows us to uniquely identify this as a React Element</span>
    <span class="s1">$$typeof: REACT_ELEMENT_TYPE,</span>
    <span class="s0">// Built-in properties that belong on the element</span>
    <span class="s1">type: type,</span>
    <span class="s1">key: key,</span>
    <span class="s1">ref: ref,</span>
    <span class="s1">props: props,</span>
    <span class="s0">// Record the component responsible for creating this element.</span>
    <span class="s1">_owner: owner</span>
  <span class="s1">};</span>

  <span class="s1">{</span>
    <span class="s0">// The validation flag is currently mutative. We put it on</span>
    <span class="s0">// an external backing store so that we can freeze the whole object.</span>
    <span class="s0">// This can be replaced with a WeakMap once they are implemented in</span>
    <span class="s0">// commonly used development environments.</span>
    <span class="s1">element._store = {}; </span><span class="s0">// To make comparing ReactElements easier for testing purposes, we make</span>
    <span class="s0">// the validation flag non-enumerable (where possible, which should</span>
    <span class="s0">// include every environment we run tests in), so the test framework</span>
    <span class="s0">// ignores it.</span>

    <span class="s1">Object.defineProperty(element._store, </span><span class="s2">'validated'</span><span class="s1">, {</span>
      <span class="s1">configurable: </span><span class="s3">false</span><span class="s1">,</span>
      <span class="s1">enumerable: </span><span class="s3">false</span><span class="s1">,</span>
      <span class="s1">writable: </span><span class="s3">true</span><span class="s1">,</span>
      <span class="s1">value: </span><span class="s3">false</span>
    <span class="s1">}); </span><span class="s0">// self and source are DEV only properties.</span>

    <span class="s1">Object.defineProperty(element, </span><span class="s2">'_self'</span><span class="s1">, {</span>
      <span class="s1">configurable: </span><span class="s3">false</span><span class="s1">,</span>
      <span class="s1">enumerable: </span><span class="s3">false</span><span class="s1">,</span>
      <span class="s1">writable: </span><span class="s3">false</span><span class="s1">,</span>
      <span class="s1">value: self</span>
    <span class="s1">}); </span><span class="s0">// Two elements created in two different places should be considered</span>
    <span class="s0">// equal for testing purposes and therefore we hide it from enumeration.</span>

    <span class="s1">Object.defineProperty(element, </span><span class="s2">'_source'</span><span class="s1">, {</span>
      <span class="s1">configurable: </span><span class="s3">false</span><span class="s1">,</span>
      <span class="s1">enumerable: </span><span class="s3">false</span><span class="s1">,</span>
      <span class="s1">writable: </span><span class="s3">false</span><span class="s1">,</span>
      <span class="s1">value: source</span>
    <span class="s1">});</span>

    <span class="s3">if </span><span class="s1">(Object.freeze) {</span>
      <span class="s1">Object.freeze(element.props);</span>
      <span class="s1">Object.freeze(element);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">element;</span>
<span class="s1">};</span>
<span class="s0">/** 
 * https://github.com/reactjs/rfcs/pull/107 
 * @param {*} type 
 * @param {object} props 
 * @param {string} key 
 */</span>

<span class="s3">function </span><span class="s1">jsxDEV(type, config, maybeKey, source, self) {</span>
  <span class="s1">{</span>
    <span class="s3">var </span><span class="s1">propName; </span><span class="s0">// Reserved names are extracted</span>

    <span class="s3">var </span><span class="s1">props = {};</span>
    <span class="s3">var </span><span class="s1">key = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">ref = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// Currently, key can be spread in as a prop. This causes a potential</span>
    <span class="s0">// issue if key is also explicitly declared (ie. &lt;div {...props} key=&quot;Hi&quot; /&gt;</span>
    <span class="s0">// or &lt;div key=&quot;Hi&quot; {...props} /&gt; ). We want to deprecate key spread,</span>
    <span class="s0">// but as an intermediary step, we will use jsxDEV for everything except</span>
    <span class="s0">// &lt;div {...props} key=&quot;Hi&quot; /&gt;, because we aren't currently able to tell if</span>
    <span class="s0">// key is explicitly declared to be undefined or not.</span>

    <span class="s3">if </span><span class="s1">(maybeKey !== undefined) {</span>
      <span class="s1">{</span>
        <span class="s1">checkKeyStringCoercion(maybeKey);</span>
      <span class="s1">}</span>

      <span class="s1">key = </span><span class="s2">'' </span><span class="s1">+ maybeKey;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(hasValidKey(config)) {</span>
      <span class="s1">{</span>
        <span class="s1">checkKeyStringCoercion(config.key);</span>
      <span class="s1">}</span>

      <span class="s1">key = </span><span class="s2">'' </span><span class="s1">+ config.key;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(hasValidRef(config)) {</span>
      <span class="s1">ref = config.ref;</span>
      <span class="s1">warnIfStringRefCannotBeAutoConverted(config, self);</span>
    <span class="s1">} </span><span class="s0">// Remaining properties are added to a new props object</span>


    <span class="s3">for </span><span class="s1">(propName </span><span class="s3">in </span><span class="s1">config) {</span>
      <span class="s3">if </span><span class="s1">(hasOwnProperty.call(config, propName) &amp;&amp; !RESERVED_PROPS.hasOwnProperty(propName)) {</span>
        <span class="s1">props[propName] = config[propName];</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// Resolve default props</span>


    <span class="s3">if </span><span class="s1">(type &amp;&amp; type.defaultProps) {</span>
      <span class="s3">var </span><span class="s1">defaultProps = type.defaultProps;</span>

      <span class="s3">for </span><span class="s1">(propName </span><span class="s3">in </span><span class="s1">defaultProps) {</span>
        <span class="s3">if </span><span class="s1">(props[propName] === undefined) {</span>
          <span class="s1">props[propName] = defaultProps[propName];</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(key || ref) {</span>
      <span class="s3">var </span><span class="s1">displayName = </span><span class="s3">typeof </span><span class="s1">type === </span><span class="s2">'function' </span><span class="s1">? type.displayName || type.name || </span><span class="s2">'Unknown' </span><span class="s1">: type;</span>

      <span class="s3">if </span><span class="s1">(key) {</span>
        <span class="s1">defineKeyPropWarningGetter(props, displayName);</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(ref) {</span>
        <span class="s1">defineRefPropWarningGetter(props, displayName);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;</span>
<span class="s3">var </span><span class="s1">ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;</span>

<span class="s3">function </span><span class="s1">setCurrentlyValidatingElement$1(element) {</span>
  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(element) {</span>
      <span class="s3">var </span><span class="s1">owner = element._owner;</span>
      <span class="s3">var </span><span class="s1">stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : </span><span class="s3">null</span><span class="s1">);</span>
      <span class="s1">ReactDebugCurrentFrame$1.setExtraStackFrame(stack);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">ReactDebugCurrentFrame$1.setExtraStackFrame(</span><span class="s3">null</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">propTypesMisspellWarningShown;</span>

<span class="s1">{</span>
  <span class="s1">propTypesMisspellWarningShown = </span><span class="s3">false</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s0">/** 
 * Verifies the object is a ReactElement. 
 * See https://reactjs.org/docs/react-api.html#isvalidelement 
 * @param {?object} object 
 * @return {boolean} True if `object` is a ReactElement. 
 * @final 
 */</span>


<span class="s3">function </span><span class="s1">isValidElement(object) {</span>
  <span class="s1">{</span>
    <span class="s3">return typeof </span><span class="s1">object === </span><span class="s2">'object' </span><span class="s1">&amp;&amp; object !== </span><span class="s3">null </span><span class="s1">&amp;&amp; object.$$typeof === REACT_ELEMENT_TYPE;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">getDeclarationErrorAddendum() {</span>
  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(ReactCurrentOwner$1.current) {</span>
      <span class="s3">var </span><span class="s1">name = getComponentNameFromType(ReactCurrentOwner$1.current.type);</span>

      <span class="s3">if </span><span class="s1">(name) {</span>
        <span class="s3">return </span><span class="s2">'</span><span class="s5">\n\n</span><span class="s2">Check the render method of `' </span><span class="s1">+ name + </span><span class="s2">'`.'</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s2">''</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">getSourceInfoErrorAddendum(source) {</span>
  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(source !== undefined) {</span>
      <span class="s3">var </span><span class="s1">fileName = source.fileName.replace(/^.*[\\\/]/, </span><span class="s2">''</span><span class="s1">);</span>
      <span class="s3">var </span><span class="s1">lineNumber = source.lineNumber;</span>
      <span class="s3">return </span><span class="s2">'</span><span class="s5">\n\n</span><span class="s2">Check your code at ' </span><span class="s1">+ fileName + </span><span class="s2">':' </span><span class="s1">+ lineNumber + </span><span class="s2">'.'</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s2">''</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">/** 
 * Warn if there's no key explicitly set on dynamic arrays of children or 
 * object keys are not valid. This allows us to keep track of children between 
 * updates. 
 */</span>


<span class="s3">var </span><span class="s1">ownerHasKeyUseWarning = {};</span>

<span class="s3">function </span><span class="s1">getCurrentComponentErrorInfo(parentType) {</span>
  <span class="s1">{</span>
    <span class="s3">var </span><span class="s1">info = getDeclarationErrorAddendum();</span>

    <span class="s3">if </span><span class="s1">(!info) {</span>
      <span class="s3">var </span><span class="s1">parentName = </span><span class="s3">typeof </span><span class="s1">parentType === </span><span class="s2">'string' </span><span class="s1">? parentType : parentType.displayName || parentType.name;</span>

      <span class="s3">if </span><span class="s1">(parentName) {</span>
        <span class="s1">info = </span><span class="s2">&quot;</span><span class="s5">\n\n</span><span class="s2">Check the top-level render call using &lt;&quot; </span><span class="s1">+ parentName + </span><span class="s2">&quot;&gt;.&quot;</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">info;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">/** 
 * Warn if the element doesn't have an explicit key assigned to it. 
 * This element is in an array. The array could grow and shrink or be 
 * reordered. All children that haven't already been validated are required to 
 * have a &quot;key&quot; property assigned to it. Error statuses are cached so a warning 
 * will only be shown once. 
 * 
 * @internal 
 * @param {ReactElement} element Element that requires a key. 
 * @param {*} parentType element's parent's type. 
 */</span>


<span class="s3">function </span><span class="s1">validateExplicitKey(element, parentType) {</span>
  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(!element._store || element._store.validated || element.key != </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">element._store.validated = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);</span>

    <span class="s3">if </span><span class="s1">(ownerHasKeyUseWarning[currentComponentErrorInfo]) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">ownerHasKeyUseWarning[currentComponentErrorInfo] = </span><span class="s3">true</span><span class="s1">; </span><span class="s0">// Usually the current owner is the offender, but if it accepts children as a</span>
    <span class="s0">// property, it may be the creator of the child that's responsible for</span>
    <span class="s0">// assigning it a key.</span>

    <span class="s3">var </span><span class="s1">childOwner = </span><span class="s2">''</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s1">(element &amp;&amp; element._owner &amp;&amp; element._owner !== ReactCurrentOwner$1.current) {</span>
      <span class="s0">// Give the component that originally created this child.</span>
      <span class="s1">childOwner = </span><span class="s2">&quot; It was passed a child from &quot; </span><span class="s1">+ getComponentNameFromType(element._owner.type) + </span><span class="s2">&quot;.&quot;</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">setCurrentlyValidatingElement$1(element);</span>

    <span class="s1">error(</span><span class="s2">'Each child in a list should have a unique &quot;key&quot; prop.' </span><span class="s1">+ </span><span class="s2">'%s%s See https://reactjs.org/link/warning-keys for more information.'</span><span class="s1">, currentComponentErrorInfo, childOwner);</span>

    <span class="s1">setCurrentlyValidatingElement$1(</span><span class="s3">null</span><span class="s1">);</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">/** 
 * Ensure that every element either is passed in a static location, in an 
 * array with an explicit keys property defined, or in an object literal 
 * with valid key property. 
 * 
 * @internal 
 * @param {ReactNode} node Statically passed child of any type. 
 * @param {*} parentType node's parent's type. 
 */</span>


<span class="s3">function </span><span class="s1">validateChildKeys(node, parentType) {</span>
  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">node !== </span><span class="s2">'object'</span><span class="s1">) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(isArray(node)) {</span>
      <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; node.length; i++) {</span>
        <span class="s3">var </span><span class="s1">child = node[i];</span>

        <span class="s3">if </span><span class="s1">(isValidElement(child)) {</span>
          <span class="s1">validateExplicitKey(child, parentType);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(isValidElement(node)) {</span>
      <span class="s0">// This element was passed in a valid location.</span>
      <span class="s3">if </span><span class="s1">(node._store) {</span>
        <span class="s1">node._store.validated = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(node) {</span>
      <span class="s3">var </span><span class="s1">iteratorFn = getIteratorFn(node);</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">iteratorFn === </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s0">// Entry iterators used to provide implicit keys,</span>
        <span class="s0">// but now we print a separate warning for them later.</span>
        <span class="s3">if </span><span class="s1">(iteratorFn !== node.entries) {</span>
          <span class="s3">var </span><span class="s1">iterator = iteratorFn.call(node);</span>
          <span class="s3">var </span><span class="s1">step;</span>

          <span class="s3">while </span><span class="s1">(!(step = iterator.next()).done) {</span>
            <span class="s3">if </span><span class="s1">(isValidElement(step.value)) {</span>
              <span class="s1">validateExplicitKey(step.value, parentType);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">/** 
 * Given an element, validate that its props follow the propTypes definition, 
 * provided by the type. 
 * 
 * @param {ReactElement} element 
 */</span>


<span class="s3">function </span><span class="s1">validatePropTypes(element) {</span>
  <span class="s1">{</span>
    <span class="s3">var </span><span class="s1">type = element.type;</span>

    <span class="s3">if </span><span class="s1">(type === </span><span class="s3">null </span><span class="s1">|| type === undefined || </span><span class="s3">typeof </span><span class="s1">type === </span><span class="s2">'string'</span><span class="s1">) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">propTypes;</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">type === </span><span class="s2">'function'</span><span class="s1">) {</span>
      <span class="s1">propTypes = type.propTypes;</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">type === </span><span class="s2">'object' </span><span class="s1">&amp;&amp; (type.$$typeof === REACT_FORWARD_REF_TYPE || </span><span class="s0">// Note: Memo only checks outer props here.</span>
    <span class="s0">// Inner props are checked in the reconciler.</span>
    <span class="s1">type.$$typeof === REACT_MEMO_TYPE)) {</span>
      <span class="s1">propTypes = type.propTypes;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(propTypes) {</span>
      <span class="s0">// Intentionally inside to avoid triggering lazy initializers:</span>
      <span class="s3">var </span><span class="s1">name = getComponentNameFromType(type);</span>
      <span class="s1">checkPropTypes(propTypes, element.props, </span><span class="s2">'prop'</span><span class="s1">, name, element);</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(type.PropTypes !== undefined &amp;&amp; !propTypesMisspellWarningShown) {</span>
      <span class="s1">propTypesMisspellWarningShown = </span><span class="s3">true</span><span class="s1">; </span><span class="s0">// Intentionally inside to avoid triggering lazy initializers:</span>

      <span class="s3">var </span><span class="s1">_name = getComponentNameFromType(type);</span>

      <span class="s1">error(</span><span class="s2">'Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?'</span><span class="s1">, _name || </span><span class="s2">'Unknown'</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">type.getDefaultProps === </span><span class="s2">'function' </span><span class="s1">&amp;&amp; !type.getDefaultProps.isReactClassApproved) {</span>
      <span class="s1">error(</span><span class="s2">'getDefaultProps is only used on classic React.createClass ' </span><span class="s1">+ </span><span class="s2">'definitions. Use a static property named `defaultProps` instead.'</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">/** 
 * Given a fragment, validate that it can only be provided with fragment props 
 * @param {ReactElement} fragment 
 */</span>


<span class="s3">function </span><span class="s1">validateFragmentProps(fragment) {</span>
  <span class="s1">{</span>
    <span class="s3">var </span><span class="s1">keys = Object.keys(fragment.props);</span>

    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; keys.length; i++) {</span>
      <span class="s3">var </span><span class="s1">key = keys[i];</span>

      <span class="s3">if </span><span class="s1">(key !== </span><span class="s2">'children' </span><span class="s1">&amp;&amp; key !== </span><span class="s2">'key'</span><span class="s1">) {</span>
        <span class="s1">setCurrentlyValidatingElement$1(fragment);</span>

        <span class="s1">error(</span><span class="s2">'Invalid prop `%s` supplied to `React.Fragment`. ' </span><span class="s1">+ </span><span class="s2">'React.Fragment can only have `key` and `children` props.'</span><span class="s1">, key);</span>

        <span class="s1">setCurrentlyValidatingElement$1(</span><span class="s3">null</span><span class="s1">);</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(fragment.ref !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">setCurrentlyValidatingElement$1(fragment);</span>

      <span class="s1">error(</span><span class="s2">'Invalid attribute `ref` supplied to `React.Fragment`.'</span><span class="s1">);</span>

      <span class="s1">setCurrentlyValidatingElement$1(</span><span class="s3">null</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">jsxWithValidation(type, props, key, isStaticChildren, source, self) {</span>
  <span class="s1">{</span>
    <span class="s3">var </span><span class="s1">validType = isValidElementType(type); </span><span class="s0">// We warn in this case but don't throw. We expect the element creation to</span>
    <span class="s0">// succeed and there will likely be errors in render.</span>

    <span class="s3">if </span><span class="s1">(!validType) {</span>
      <span class="s3">var </span><span class="s1">info = </span><span class="s2">''</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s1">(type === undefined || </span><span class="s3">typeof </span><span class="s1">type === </span><span class="s2">'object' </span><span class="s1">&amp;&amp; type !== </span><span class="s3">null </span><span class="s1">&amp;&amp; Object.keys(type).length === </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">info += </span><span class="s2">' You likely forgot to export your component from the file ' </span><span class="s1">+ </span><span class="s2">&quot;it's defined in, or you might have mixed up default and named imports.&quot;</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">sourceInfo = getSourceInfoErrorAddendum(source);</span>

      <span class="s3">if </span><span class="s1">(sourceInfo) {</span>
        <span class="s1">info += sourceInfo;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">info += getDeclarationErrorAddendum();</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">typeString;</span>

      <span class="s3">if </span><span class="s1">(type === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">typeString = </span><span class="s2">'null'</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(isArray(type)) {</span>
        <span class="s1">typeString = </span><span class="s2">'array'</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(type !== undefined &amp;&amp; type.$$typeof === REACT_ELEMENT_TYPE) {</span>
        <span class="s1">typeString = </span><span class="s2">&quot;&lt;&quot; </span><span class="s1">+ (getComponentNameFromType(type.type) || </span><span class="s2">'Unknown'</span><span class="s1">) + </span><span class="s2">&quot; /&gt;&quot;</span><span class="s1">;</span>
        <span class="s1">info = </span><span class="s2">' Did you accidentally export a JSX literal instead of a component?'</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">typeString = </span><span class="s3">typeof </span><span class="s1">type;</span>
      <span class="s1">}</span>

      <span class="s1">error(</span><span class="s2">'React.jsx: type is invalid -- expected a string (for ' </span><span class="s1">+ </span><span class="s2">'built-in components) or a class/function (for composite ' </span><span class="s1">+ </span><span class="s2">'components) but got: %s.%s'</span><span class="s1">, typeString, info);</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">element = jsxDEV(type, props, key, source, self); </span><span class="s0">// The result can be nullish if a mock or a custom function is used.</span>
    <span class="s0">// TODO: Drop this when these are no longer allowed as the type argument.</span>

    <span class="s3">if </span><span class="s1">(element == </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">return </span><span class="s1">element;</span>
    <span class="s1">} </span><span class="s0">// Skip key warning if the type isn't valid since our key validation logic</span>
    <span class="s0">// doesn't expect a non-string/function type and can throw confusing errors.</span>
    <span class="s0">// We don't want exception behavior to differ between dev and prod.</span>
    <span class="s0">// (Rendering will throw with a helpful message and as soon as the type is</span>
    <span class="s0">// fixed, the key warnings will appear.)</span>


    <span class="s3">if </span><span class="s1">(validType) {</span>
      <span class="s3">var </span><span class="s1">children = props.children;</span>

      <span class="s3">if </span><span class="s1">(children !== undefined) {</span>
        <span class="s3">if </span><span class="s1">(isStaticChildren) {</span>
          <span class="s3">if </span><span class="s1">(isArray(children)) {</span>
            <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; children.length; i++) {</span>
              <span class="s1">validateChildKeys(children[i], type);</span>
            <span class="s1">}</span>

            <span class="s3">if </span><span class="s1">(Object.freeze) {</span>
              <span class="s1">Object.freeze(children);</span>
            <span class="s1">}</span>
          <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">error(</span><span class="s2">'React.jsx: Static children should always be an array. ' </span><span class="s1">+ </span><span class="s2">'You are likely explicitly calling React.jsxs or React.jsxDEV. ' </span><span class="s1">+ </span><span class="s2">'Use the Babel transform instead.'</span><span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s1">validateChildKeys(children, type);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(type === REACT_FRAGMENT_TYPE) {</span>
      <span class="s1">validateFragmentProps(element);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">validatePropTypes(element);</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">element;</span>
  <span class="s1">}</span>
<span class="s1">} </span><span class="s0">// These two functions exist to still get child warnings in dev</span>

<span class="s3">var </span><span class="s1">jsxDEV$1 =  jsxWithValidation ;</span>

<span class="s1">exports.Fragment = REACT_FRAGMENT_TYPE;</span>
<span class="s1">exports.jsxDEV = jsxDEV$1;</span>
  <span class="s1">})();</span>
<span class="s1">}</span>
</pre>
</body>
</html>
<html>
<head>
<title>RCTTurboModule.mm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #bbb529;}
.s3 { color: #6a8759;}
.s4 { color: #cc7832;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
RCTTurboModule.mm</font>
</center></td></tr></table>
<pre><span class="s0">/* 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>

<span class="s2">#import </span><span class="s3">&quot;RCTTurboModule.h&quot;</span>
<span class="s2">#import </span><span class="s3">&quot;RCTBlockGuard.h&quot;</span>

<span class="s2">#import </span><span class="s3">&lt;objc/message.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;objc/runtime.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;atomic&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;iostream&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;sstream&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;vector&gt;</span>

<span class="s2">#import </span><span class="s3">&lt;React/RCTBridgeModule.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;React/RCTConvert.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;React/RCTCxxConvert.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;React/RCTManagedPointer.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;React/RCTModuleMethod.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;React/RCTUtils.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;ReactCommon/CallInvoker.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;ReactCommon/LongLivedObject.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;ReactCommon/TurboModule.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;ReactCommon/TurboModulePerfLogger.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;ReactCommon/TurboModuleUtils.h&gt;</span>

<span class="s4">using namespace </span><span class="s1">facebook</span><span class="s4">;</span>
<span class="s4">using namespace </span><span class="s1">facebook::react</span><span class="s4">;</span>

<span class="s4">static </span><span class="s1">int32_t getUniqueId()</span>
<span class="s1">{</span>
  <span class="s4">static </span><span class="s1">int32_t counter = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s4">return </span><span class="s1">counter++</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s0">/** 
 * All static helper functions are ObjC++ specific. 
 */</span>
<span class="s4">static </span><span class="s1">jsi::Value convertNSNumberToJSIBoolean(jsi::Runtime &amp;runtime</span><span class="s4">, </span><span class="s1">NSNumber *value)</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">jsi::Value((</span><span class="s4">bool</span><span class="s1">)[value boolValue])</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">static </span><span class="s1">jsi::Value convertNSNumberToJSINumber(jsi::Runtime &amp;runtime</span><span class="s4">, </span><span class="s1">NSNumber *value)</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">jsi::Value([value doubleValue])</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">static </span><span class="s1">jsi::String convertNSStringToJSIString(jsi::Runtime &amp;runtime</span><span class="s4">, </span><span class="s1">NSString *value)</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">jsi::String::createFromUtf8(runtime</span><span class="s4">, </span><span class="s1">[value UTF8String] ?: </span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">static </span><span class="s1">jsi::Value convertObjCObjectToJSIValue(jsi::Runtime &amp;runtime</span><span class="s4">, </span><span class="s1">id value)</span><span class="s4">;</span>
<span class="s4">static </span><span class="s1">jsi::Object convertNSDictionaryToJSIObject(jsi::Runtime &amp;runtime</span><span class="s4">, </span><span class="s1">NSDictionary *value)</span>
<span class="s1">{</span>
  <span class="s1">jsi::Object result = jsi::Object(runtime)</span><span class="s4">;</span>
  <span class="s4">for </span><span class="s1">(NSString *k in value) {</span>
    <span class="s1">result.setProperty(runtime</span><span class="s4">, </span><span class="s1">convertNSStringToJSIString(runtime</span><span class="s4">, </span><span class="s1">k)</span><span class="s4">, </span><span class="s1">convertObjCObjectToJSIValue(runtime</span><span class="s4">, </span><span class="s1">value[k]))</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">return </span><span class="s1">result</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">static </span><span class="s1">jsi::Array convertNSArrayToJSIArray(jsi::Runtime &amp;runtime</span><span class="s4">, </span><span class="s1">NSArray *value)</span>
<span class="s1">{</span>
  <span class="s1">jsi::Array result = jsi::Array(runtime</span><span class="s4">, </span><span class="s1">value.count)</span><span class="s4">;</span>
  <span class="s4">for </span><span class="s1">(size_t i = </span><span class="s5">0</span><span class="s4">; </span><span class="s1">i &lt; value.count</span><span class="s4">; </span><span class="s1">i++) {</span>
    <span class="s1">result.setValueAtIndex(runtime</span><span class="s4">, </span><span class="s1">i</span><span class="s4">, </span><span class="s1">convertObjCObjectToJSIValue(runtime</span><span class="s4">, </span><span class="s1">value[i]))</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">return </span><span class="s1">result</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">static </span><span class="s1">std::vector&lt;jsi::Value&gt; convertNSArrayToStdVector(jsi::Runtime &amp;runtime</span><span class="s4">, </span><span class="s1">NSArray *value)</span>
<span class="s1">{</span>
  <span class="s1">std::vector&lt;jsi::Value&gt; result</span><span class="s4">;</span>
  <span class="s4">for </span><span class="s1">(size_t i = </span><span class="s5">0</span><span class="s4">; </span><span class="s1">i &lt; value.count</span><span class="s4">; </span><span class="s1">i++) {</span>
    <span class="s1">result.emplace_back(convertObjCObjectToJSIValue(runtime</span><span class="s4">, </span><span class="s1">value[i]))</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">return </span><span class="s1">result</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">static </span><span class="s1">jsi::Value convertObjCObjectToJSIValue(jsi::Runtime &amp;runtime</span><span class="s4">, </span><span class="s1">id value)</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">([value isKindOfClass:[NSString </span><span class="s4">class</span><span class="s1">]]) {</span>
    <span class="s4">return </span><span class="s1">convertNSStringToJSIString(runtime</span><span class="s4">, </span><span class="s1">(NSString *)value)</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else if </span><span class="s1">([value isKindOfClass:[NSNumber </span><span class="s4">class</span><span class="s1">]]) {</span>
    <span class="s4">if </span><span class="s1">([value isKindOfClass:[</span><span class="s4">@</span><span class="s1">YES </span><span class="s4">class</span><span class="s1">]]) {</span>
      <span class="s4">return </span><span class="s1">convertNSNumberToJSIBoolean(runtime</span><span class="s4">, </span><span class="s1">(NSNumber *)value)</span><span class="s4">;</span>
    <span class="s1">}</span>
    <span class="s4">return </span><span class="s1">convertNSNumberToJSINumber(runtime</span><span class="s4">, </span><span class="s1">(NSNumber *)value)</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else if </span><span class="s1">([value isKindOfClass:[NSDictionary </span><span class="s4">class</span><span class="s1">]]) {</span>
    <span class="s4">return </span><span class="s1">convertNSDictionaryToJSIObject(runtime</span><span class="s4">, </span><span class="s1">(NSDictionary *)value)</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else if </span><span class="s1">([value isKindOfClass:[NSArray </span><span class="s4">class</span><span class="s1">]]) {</span>
    <span class="s4">return </span><span class="s1">convertNSArrayToJSIArray(runtime</span><span class="s4">, </span><span class="s1">(NSArray *)value)</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else if </span><span class="s1">(value == (id)kCFNull) {</span>
    <span class="s4">return </span><span class="s1">jsi::Value::null()</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">return </span><span class="s1">jsi::Value::undefined()</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">static </span><span class="s1">id</span>
<span class="s1">convertJSIValueToObjCObject(jsi::Runtime &amp;runtime</span><span class="s4">, const </span><span class="s1">jsi::Value &amp;value</span><span class="s4">, </span><span class="s1">std::shared_ptr&lt;CallInvoker&gt; jsInvoker)</span><span class="s4">;</span>
<span class="s4">static </span><span class="s1">NSString *convertJSIStringToNSString(jsi::Runtime &amp;runtime</span><span class="s4">, const </span><span class="s1">jsi::String &amp;value)</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">[NSString stringWithUTF8String:value.utf8(runtime).c_str()]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">static </span><span class="s1">NSArray *</span>
<span class="s1">convertJSIArrayToNSArray(jsi::Runtime &amp;runtime</span><span class="s4">, const </span><span class="s1">jsi::Array &amp;value</span><span class="s4">, </span><span class="s1">std::shared_ptr&lt;CallInvoker&gt; jsInvoker)</span>
<span class="s1">{</span>
  <span class="s1">size_t size = value.size(runtime)</span><span class="s4">;</span>
  <span class="s1">NSMutableArray *result = [NSMutableArray </span><span class="s4">new</span><span class="s1">]</span><span class="s4">;</span>
  <span class="s4">for </span><span class="s1">(size_t i = </span><span class="s5">0</span><span class="s4">; </span><span class="s1">i &lt; size</span><span class="s4">; </span><span class="s1">i++) {</span>
    <span class="s0">// Insert kCFNull when it's `undefined` value to preserve the indices.</span>
    <span class="s1">[result</span>
        <span class="s1">addObject:convertJSIValueToObjCObject(runtime</span><span class="s4">, </span><span class="s1">value.getValueAtIndex(runtime</span><span class="s4">, </span><span class="s1">i)</span><span class="s4">, </span><span class="s1">jsInvoker) ?: (id)kCFNull]</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">return </span><span class="s1">[result copy]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">static </span><span class="s1">NSDictionary *</span>
<span class="s1">convertJSIObjectToNSDictionary(jsi::Runtime &amp;runtime</span><span class="s4">, const </span><span class="s1">jsi::Object &amp;value</span><span class="s4">, </span><span class="s1">std::shared_ptr&lt;CallInvoker&gt; jsInvoker)</span>
<span class="s1">{</span>
  <span class="s1">jsi::Array propertyNames = value.getPropertyNames(runtime)</span><span class="s4">;</span>
  <span class="s1">size_t size = propertyNames.size(runtime)</span><span class="s4">;</span>
  <span class="s1">NSMutableDictionary *result = [NSMutableDictionary </span><span class="s4">new</span><span class="s1">]</span><span class="s4">;</span>
  <span class="s4">for </span><span class="s1">(size_t i = </span><span class="s5">0</span><span class="s4">; </span><span class="s1">i &lt; size</span><span class="s4">; </span><span class="s1">i++) {</span>
    <span class="s1">jsi::String name = propertyNames.getValueAtIndex(runtime</span><span class="s4">, </span><span class="s1">i).getString(runtime)</span><span class="s4">;</span>
    <span class="s1">NSString *k = convertJSIStringToNSString(runtime</span><span class="s4">, </span><span class="s1">name)</span><span class="s4">;</span>
    <span class="s1">id v = convertJSIValueToObjCObject(runtime</span><span class="s4">, </span><span class="s1">value.getProperty(runtime</span><span class="s4">, </span><span class="s1">name)</span><span class="s4">, </span><span class="s1">jsInvoker)</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">(v) {</span>
      <span class="s1">result[k] = v</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s4">return </span><span class="s1">[result copy]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">static </span><span class="s1">RCTResponseSenderBlock</span>
<span class="s1">convertJSIFunctionToCallback(jsi::Runtime &amp;runtime</span><span class="s4">, const </span><span class="s1">jsi::Function &amp;value</span><span class="s4">, </span><span class="s1">std::shared_ptr&lt;CallInvoker&gt; jsInvoker)</span><span class="s4">;</span>
<span class="s4">static </span><span class="s1">id</span>
<span class="s1">convertJSIValueToObjCObject(jsi::Runtime &amp;runtime</span><span class="s4">, const </span><span class="s1">jsi::Value &amp;value</span><span class="s4">, </span><span class="s1">std::shared_ptr&lt;CallInvoker&gt; jsInvoker)</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(value.isUndefined() || value.isNull()) {</span>
    <span class="s4">return </span><span class="s1">nil</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">if </span><span class="s1">(value.isBool()) {</span>
    <span class="s4">return @</span><span class="s1">(value.getBool())</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">if </span><span class="s1">(value.isNumber()) {</span>
    <span class="s4">return @</span><span class="s1">(value.getNumber())</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">if </span><span class="s1">(value.isString()) {</span>
    <span class="s4">return </span><span class="s1">convertJSIStringToNSString(runtime</span><span class="s4">, </span><span class="s1">value.getString(runtime))</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">if </span><span class="s1">(value.isObject()) {</span>
    <span class="s1">jsi::Object o = value.getObject(runtime)</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">(o.isArray(runtime)) {</span>
      <span class="s4">return </span><span class="s1">convertJSIArrayToNSArray(runtime</span><span class="s4">, </span><span class="s1">o.getArray(runtime)</span><span class="s4">, </span><span class="s1">jsInvoker)</span><span class="s4">;</span>
    <span class="s1">}</span>
    <span class="s4">if </span><span class="s1">(o.isFunction(runtime)) {</span>
      <span class="s4">return </span><span class="s1">convertJSIFunctionToCallback(runtime</span><span class="s4">, </span><span class="s1">std::move(o.getFunction(runtime))</span><span class="s4">, </span><span class="s1">jsInvoker)</span><span class="s4">;</span>
    <span class="s1">}</span>
    <span class="s4">return </span><span class="s1">convertJSIObjectToNSDictionary(runtime</span><span class="s4">, </span><span class="s1">o</span><span class="s4">, </span><span class="s1">jsInvoker)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">throw </span><span class="s1">std::runtime_error(</span><span class="s3">&quot;Unsupported jsi::jsi::Value kind&quot;</span><span class="s1">)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">static </span><span class="s1">RCTResponseSenderBlock</span>
<span class="s1">convertJSIFunctionToCallback(jsi::Runtime &amp;runtime</span><span class="s4">, const </span><span class="s1">jsi::Function &amp;value</span><span class="s4">, </span><span class="s1">std::shared_ptr&lt;CallInvoker&gt; jsInvoker)</span>
<span class="s1">{</span>
  <span class="s4">auto </span><span class="s1">weakWrapper = CallbackWrapper::createWeak(value.getFunction(runtime)</span><span class="s4">, </span><span class="s1">runtime</span><span class="s4">, </span><span class="s1">jsInvoker)</span><span class="s4">;</span>
  <span class="s1">RCTBlockGuard *blockGuard = [[RCTBlockGuard alloc] initWithCleanup:^() {</span>
    <span class="s4">auto </span><span class="s1">strongWrapper = weakWrapper.lock()</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">(strongWrapper) {</span>
      <span class="s1">strongWrapper-&gt;destroy()</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}]</span><span class="s4">;</span>

  <span class="s1">BOOL __block wrapperWasCalled = NO</span><span class="s4">;</span>
  <span class="s1">RCTResponseSenderBlock callback = ^(NSArray *responses) {</span>
    <span class="s4">if </span><span class="s1">(wrapperWasCalled) {</span>
      <span class="s4">throw </span><span class="s1">std::runtime_error(</span><span class="s3">&quot;callback arg cannot be called more than once&quot;</span><span class="s1">)</span><span class="s4">;</span>
    <span class="s1">}</span>

    <span class="s4">auto </span><span class="s1">strongWrapper = weakWrapper.lock()</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">(!strongWrapper) {</span>
      <span class="s4">return;</span>
    <span class="s1">}</span>

    <span class="s1">strongWrapper-&gt;jsInvoker().invokeAsync([weakWrapper</span><span class="s4">, </span><span class="s1">responses</span><span class="s4">, </span><span class="s1">blockGuard]() {</span>
      <span class="s4">auto </span><span class="s1">strongWrapper2 = weakWrapper.lock()</span><span class="s4">;</span>
      <span class="s4">if </span><span class="s1">(!strongWrapper2) {</span>
        <span class="s4">return;</span>
      <span class="s1">}</span>

      <span class="s1">std::vector&lt;jsi::Value&gt; args = convertNSArrayToStdVector(strongWrapper2-&gt;runtime()</span><span class="s4">, </span><span class="s1">responses)</span><span class="s4">;</span>
      <span class="s1">strongWrapper2-&gt;callback().call(strongWrapper2-&gt;runtime()</span><span class="s4">, </span><span class="s1">(</span><span class="s4">const </span><span class="s1">jsi::Value *)args.data()</span><span class="s4">, </span><span class="s1">args.size())</span><span class="s4">;</span>
      <span class="s1">strongWrapper2-&gt;destroy()</span><span class="s4">;</span>

      <span class="s0">// Delete the CallbackWrapper when the block gets dealloced without being invoked.</span>
      <span class="s1">(</span><span class="s4">void</span><span class="s1">)blockGuard</span><span class="s4">;</span>
    <span class="s1">})</span><span class="s4">;</span>

    <span class="s1">wrapperWasCalled = YES</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>

  <span class="s4">return </span><span class="s1">[callback copy]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">namespace </span><span class="s1">facebook {</span>
<span class="s4">namespace </span><span class="s1">react {</span>

<span class="s1">jsi::Value ObjCTurboModule::createPromise(jsi::Runtime &amp;runtime</span><span class="s4">, </span><span class="s1">std::string methodName</span><span class="s4">, </span><span class="s1">PromiseInvocationBlock invoke)</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(!invoke) {</span>
    <span class="s4">return </span><span class="s1">jsi::Value::undefined()</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">jsi::Function Promise = runtime.global().getPropertyAsFunction(runtime</span><span class="s4">, </span><span class="s3">&quot;Promise&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">std::string moduleName = name_</span><span class="s4">;</span>

  <span class="s0">// Note: the passed invoke() block is not retained by default, so let's retain it here to help keep it longer.</span>
  <span class="s0">// Otherwise, there's a risk of it getting released before the promise function below executes.</span>
  <span class="s1">PromiseInvocationBlock invokeCopy = [invoke copy]</span><span class="s4">;</span>
  <span class="s1">jsi::Function fn = jsi::Function::createFromHostFunction(</span>
      <span class="s1">runtime</span><span class="s4">,</span>
      <span class="s1">jsi::PropNameID::forAscii(runtime</span><span class="s4">, </span><span class="s3">&quot;fn&quot;</span><span class="s1">)</span><span class="s4">,</span>
      <span class="s5">2</span><span class="s4">,</span>
      <span class="s1">[invokeCopy</span><span class="s4">, </span><span class="s1">jsInvoker = jsInvoker_</span><span class="s4">, </span><span class="s1">moduleName</span><span class="s4">, </span><span class="s1">methodName](</span>
          <span class="s1">jsi::Runtime &amp;rt</span><span class="s4">, const </span><span class="s1">jsi::Value &amp;thisVal</span><span class="s4">, const </span><span class="s1">jsi::Value *args</span><span class="s4">, </span><span class="s1">size_t count) {</span>
        <span class="s1">std::string moduleMethod = moduleName + </span><span class="s3">&quot;.&quot; </span><span class="s1">+ methodName + </span><span class="s3">&quot;()&quot;</span><span class="s4">;</span>

        <span class="s4">if </span><span class="s1">(count != </span><span class="s5">2</span><span class="s1">) {</span>
          <span class="s4">throw </span><span class="s1">std::invalid_argument(</span>
              <span class="s1">moduleMethod + </span><span class="s3">&quot;: Promise must pass constructor function two args. Passed &quot; </span><span class="s1">+ std::to_string(count) +</span>
              <span class="s3">&quot; args.&quot;</span><span class="s1">)</span><span class="s4">;</span>
        <span class="s1">}</span>
        <span class="s4">if </span><span class="s1">(!invokeCopy) {</span>
          <span class="s4">return </span><span class="s1">jsi::Value::undefined()</span><span class="s4">;</span>
        <span class="s1">}</span>

        <span class="s4">auto </span><span class="s1">weakResolveWrapper = CallbackWrapper::createWeak(args[</span><span class="s5">0</span><span class="s1">].getObject(rt).getFunction(rt)</span><span class="s4">, </span><span class="s1">rt</span><span class="s4">, </span><span class="s1">jsInvoker)</span><span class="s4">;</span>
        <span class="s4">auto </span><span class="s1">weakRejectWrapper = CallbackWrapper::createWeak(args[</span><span class="s5">1</span><span class="s1">].getObject(rt).getFunction(rt)</span><span class="s4">, </span><span class="s1">rt</span><span class="s4">, </span><span class="s1">jsInvoker)</span><span class="s4">;</span>

        <span class="s1">__block BOOL resolveWasCalled = NO</span><span class="s4">;</span>
        <span class="s1">__block BOOL rejectWasCalled = NO</span><span class="s4">;</span>

        <span class="s1">RCTBlockGuard *blockGuard = [[RCTBlockGuard alloc] initWithCleanup:^() {</span>
          <span class="s4">auto </span><span class="s1">strongResolveWrapper = weakResolveWrapper.lock()</span><span class="s4">;</span>
          <span class="s4">if </span><span class="s1">(strongResolveWrapper) {</span>
            <span class="s1">strongResolveWrapper-&gt;destroy()</span><span class="s4">;</span>
          <span class="s1">}</span>

          <span class="s4">auto </span><span class="s1">strongRejectWrapper = weakRejectWrapper.lock()</span><span class="s4">;</span>
          <span class="s4">if </span><span class="s1">(strongRejectWrapper) {</span>
            <span class="s1">strongRejectWrapper-&gt;destroy()</span><span class="s4">;</span>
          <span class="s1">}</span>
        <span class="s1">}]</span><span class="s4">;</span>

        <span class="s1">RCTPromiseResolveBlock resolveBlock = ^(id result) {</span>
          <span class="s4">if </span><span class="s1">(rejectWasCalled) {</span>
            <span class="s1">RCTLogError(</span><span class="s4">@</span><span class="s3">&quot;%s: Tried to resolve a promise after it's already been rejected.&quot;</span><span class="s4">, </span><span class="s1">moduleMethod.c_str())</span><span class="s4">;</span>
            <span class="s4">return;</span>
          <span class="s1">}</span>

          <span class="s4">if </span><span class="s1">(resolveWasCalled) {</span>
            <span class="s1">RCTLogError(</span><span class="s4">@</span><span class="s3">&quot;%s: Tried to resolve a promise more than once.&quot;</span><span class="s4">, </span><span class="s1">moduleMethod.c_str())</span><span class="s4">;</span>
            <span class="s4">return;</span>
          <span class="s1">}</span>

          <span class="s4">auto </span><span class="s1">strongResolveWrapper = weakResolveWrapper.lock()</span><span class="s4">;</span>
          <span class="s4">auto </span><span class="s1">strongRejectWrapper = weakRejectWrapper.lock()</span><span class="s4">;</span>
          <span class="s4">if </span><span class="s1">(!strongResolveWrapper || !strongRejectWrapper) {</span>
            <span class="s4">return;</span>
          <span class="s1">}</span>

          <span class="s1">strongResolveWrapper-&gt;jsInvoker().invokeAsync([weakResolveWrapper</span><span class="s4">, </span><span class="s1">weakRejectWrapper</span><span class="s4">, </span><span class="s1">result</span><span class="s4">, </span><span class="s1">blockGuard]() {</span>
            <span class="s4">auto </span><span class="s1">strongResolveWrapper2 = weakResolveWrapper.lock()</span><span class="s4">;</span>
            <span class="s4">auto </span><span class="s1">strongRejectWrapper2 = weakRejectWrapper.lock()</span><span class="s4">;</span>
            <span class="s4">if </span><span class="s1">(!strongResolveWrapper2 || !strongRejectWrapper2) {</span>
              <span class="s4">return;</span>
            <span class="s1">}</span>

            <span class="s1">jsi::Runtime &amp;rt = strongResolveWrapper2-&gt;runtime()</span><span class="s4">;</span>
            <span class="s1">jsi::Value arg = convertObjCObjectToJSIValue(rt</span><span class="s4">, </span><span class="s1">result)</span><span class="s4">;</span>
            <span class="s1">strongResolveWrapper2-&gt;callback().call(rt</span><span class="s4">, </span><span class="s1">arg)</span><span class="s4">;</span>

            <span class="s1">strongResolveWrapper2-&gt;destroy()</span><span class="s4">;</span>
            <span class="s1">strongRejectWrapper2-&gt;destroy()</span><span class="s4">;</span>
            <span class="s1">(</span><span class="s4">void</span><span class="s1">)blockGuard</span><span class="s4">;</span>
          <span class="s1">})</span><span class="s4">;</span>

          <span class="s1">resolveWasCalled = YES</span><span class="s4">;</span>
        <span class="s1">}</span><span class="s4">;</span>

        <span class="s1">RCTPromiseRejectBlock rejectBlock = ^(NSString *code</span><span class="s4">, </span><span class="s1">NSString *message</span><span class="s4">, </span><span class="s1">NSError *error) {</span>
          <span class="s4">if </span><span class="s1">(resolveWasCalled) {</span>
            <span class="s1">RCTLogError(</span><span class="s4">@</span><span class="s3">&quot;%s: Tried to reject a promise after it's already been resolved.&quot;</span><span class="s4">, </span><span class="s1">moduleMethod.c_str())</span><span class="s4">;</span>
            <span class="s4">return;</span>
          <span class="s1">}</span>

          <span class="s4">if </span><span class="s1">(rejectWasCalled) {</span>
            <span class="s1">RCTLogError(</span><span class="s4">@</span><span class="s3">&quot;%s: Tried to reject a promise more than once.&quot;</span><span class="s4">, </span><span class="s1">moduleMethod.c_str())</span><span class="s4">;</span>
            <span class="s4">return;</span>
          <span class="s1">}</span>

          <span class="s4">auto </span><span class="s1">strongResolveWrapper = weakResolveWrapper.lock()</span><span class="s4">;</span>
          <span class="s4">auto </span><span class="s1">strongRejectWrapper = weakRejectWrapper.lock()</span><span class="s4">;</span>
          <span class="s4">if </span><span class="s1">(!strongResolveWrapper || !strongRejectWrapper) {</span>
            <span class="s4">return;</span>
          <span class="s1">}</span>

          <span class="s1">NSDictionary *jsError = RCTJSErrorFromCodeMessageAndNSError(code</span><span class="s4">, </span><span class="s1">message</span><span class="s4">, </span><span class="s1">error)</span><span class="s4">;</span>
          <span class="s1">strongRejectWrapper-&gt;jsInvoker().invokeAsync([weakResolveWrapper</span><span class="s4">, </span><span class="s1">weakRejectWrapper</span><span class="s4">, </span><span class="s1">jsError</span><span class="s4">, </span><span class="s1">blockGuard]() {</span>
            <span class="s4">auto </span><span class="s1">strongResolveWrapper2 = weakResolveWrapper.lock()</span><span class="s4">;</span>
            <span class="s4">auto </span><span class="s1">strongRejectWrapper2 = weakRejectWrapper.lock()</span><span class="s4">;</span>
            <span class="s4">if </span><span class="s1">(!strongResolveWrapper2 || !strongRejectWrapper2) {</span>
              <span class="s4">return;</span>
            <span class="s1">}</span>

            <span class="s1">jsi::Runtime &amp;rt = strongRejectWrapper2-&gt;runtime()</span><span class="s4">;</span>
            <span class="s1">jsi::Value arg = convertNSDictionaryToJSIObject(rt</span><span class="s4">, </span><span class="s1">jsError)</span><span class="s4">;</span>
            <span class="s1">strongRejectWrapper2-&gt;callback().call(rt</span><span class="s4">, </span><span class="s1">arg)</span><span class="s4">;</span>

            <span class="s1">strongResolveWrapper2-&gt;destroy()</span><span class="s4">;</span>
            <span class="s1">strongRejectWrapper2-&gt;destroy()</span><span class="s4">;</span>
            <span class="s1">(</span><span class="s4">void</span><span class="s1">)blockGuard</span><span class="s4">;</span>
          <span class="s1">})</span><span class="s4">;</span>

          <span class="s1">rejectWasCalled = YES</span><span class="s4">;</span>
        <span class="s1">}</span><span class="s4">;</span>

        <span class="s1">invokeCopy(resolveBlock</span><span class="s4">, </span><span class="s1">rejectBlock)</span><span class="s4">;</span>
        <span class="s4">return </span><span class="s1">jsi::Value::undefined()</span><span class="s4">;</span>
      <span class="s1">})</span><span class="s4">;</span>

  <span class="s4">return </span><span class="s1">Promise.callAsConstructor(runtime</span><span class="s4">, </span><span class="s1">fn)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Perform method invocation on a specific queue as configured by the module class. 
 * This serves as a backward-compatible support for RCTBridgeModule's methodQueue API. 
 * 
 * In the future: 
 * - This methodQueue support may be removed for simplicity and consistency with Android. 
 * - ObjC module methods will be always be called from JS thread. 
 *   They may decide to dispatch to a different queue as needed. 
 */</span>
<span class="s1">jsi::Value ObjCTurboModule::performMethodInvocation(</span>
    <span class="s1">jsi::Runtime &amp;runtime</span><span class="s4">,</span>
    <span class="s1">TurboModuleMethodValueKind returnType</span><span class="s4">,</span>
    <span class="s4">const char </span><span class="s1">*methodName</span><span class="s4">,</span>
    <span class="s1">NSInvocation *inv</span><span class="s4">,</span>
    <span class="s1">NSMutableArray *retainedObjectsForInvocation)</span>
<span class="s1">{</span>
  <span class="s1">__block id result</span><span class="s4">;</span>
  <span class="s1">jsi::Runtime *rt = &amp;runtime</span><span class="s4">;</span>
  <span class="s4">__weak </span><span class="s1">id&lt;RCTTurboModule&gt; weakModule = instance_</span><span class="s4">;</span>
  <span class="s4">const char </span><span class="s1">*moduleName = name_.c_str()</span><span class="s4">;</span>
  <span class="s1">std::string methodNameStr{methodName}</span><span class="s4">;</span>
  <span class="s1">__block int32_t asyncCallCounter = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s4">bool </span><span class="s1">wasMethodSync = isMethodSync(returnType)</span><span class="s4">;</span>

  <span class="s4">void </span><span class="s1">(^block)() = ^{</span>
    <span class="s1">id&lt;RCTTurboModule&gt; strongModule = weakModule</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">(!strongModule) {</span>
      <span class="s4">return;</span>
    <span class="s1">}</span>

    <span class="s4">if </span><span class="s1">(wasMethodSync) {</span>
      <span class="s1">TurboModulePerfLogger::syncMethodCallExecutionStart(moduleName</span><span class="s4">, </span><span class="s1">methodNameStr.c_str())</span><span class="s4">;</span>
    <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
      <span class="s1">TurboModulePerfLogger::asyncMethodCallExecutionStart(moduleName</span><span class="s4">, </span><span class="s1">methodNameStr.c_str()</span><span class="s4">, </span><span class="s1">asyncCallCounter)</span><span class="s4">;</span>
    <span class="s1">}</span>

    <span class="s0">// TODO(T66699874) Should we guard this with a try/catch?</span>
    <span class="s1">[inv invokeWithTarget:strongModule]</span><span class="s4">;</span>
    <span class="s1">[retainedObjectsForInvocation removeAllObjects]</span><span class="s4">;</span>

    <span class="s4">if </span><span class="s1">(!wasMethodSync) {</span>
      <span class="s1">TurboModulePerfLogger::asyncMethodCallExecutionEnd(moduleName</span><span class="s4">, </span><span class="s1">methodNameStr.c_str()</span><span class="s4">, </span><span class="s1">asyncCallCounter)</span><span class="s4">;</span>
      <span class="s4">return;</span>
    <span class="s1">}</span>

    <span class="s1">TurboModulePerfLogger::syncMethodCallExecutionEnd(moduleName</span><span class="s4">, </span><span class="s1">methodNameStr.c_str())</span><span class="s4">;</span>
    <span class="s1">TurboModulePerfLogger::syncMethodCallReturnConversionStart(moduleName</span><span class="s4">, </span><span class="s1">methodNameStr.c_str())</span><span class="s4">;</span>

    <span class="s4">void </span><span class="s1">*rawResult</span><span class="s4">;</span>
    <span class="s1">[inv getReturnValue:&amp;rawResult]</span><span class="s4">;</span>
    <span class="s1">result = (</span><span class="s4">__bridge </span><span class="s1">id)rawResult</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(wasMethodSync) {</span>
    <span class="s1">block()</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s1">asyncCallCounter = getUniqueId()</span><span class="s4">;</span>
    <span class="s1">TurboModulePerfLogger::asyncMethodCallDispatch(moduleName</span><span class="s4">, </span><span class="s1">methodName)</span><span class="s4">;</span>
    <span class="s1">nativeInvoker_-&gt;invokeAsync([block]() -&gt; </span><span class="s4">void </span><span class="s1">{ block()</span><span class="s4">; </span><span class="s1">})</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">jsi::Value::undefined()</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(result == (id)kCFNull || result == nil) {</span>
    <span class="s4">return </span><span class="s1">jsi::Value::null()</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">jsi::Value returnValue = jsi::Value::undefined()</span><span class="s4">;</span>

  <span class="s0">// TODO: Re-use value conversion logic from existing impl, if possible.</span>
  <span class="s4">switch </span><span class="s1">(returnType) {</span>
    <span class="s4">case </span><span class="s1">VoidKind: {</span>
      <span class="s4">break;</span>
    <span class="s1">}</span>
    <span class="s4">case </span><span class="s1">BooleanKind: {</span>
      <span class="s1">returnValue = convertNSNumberToJSIBoolean(*rt</span><span class="s4">, </span><span class="s1">(NSNumber *)result)</span><span class="s4">;</span>
      <span class="s4">break;</span>
    <span class="s1">}</span>
    <span class="s4">case </span><span class="s1">NumberKind: {</span>
      <span class="s1">returnValue = convertNSNumberToJSINumber(*rt</span><span class="s4">, </span><span class="s1">(NSNumber *)result)</span><span class="s4">;</span>
      <span class="s4">break;</span>
    <span class="s1">}</span>
    <span class="s4">case </span><span class="s1">StringKind: {</span>
      <span class="s1">returnValue = convertNSStringToJSIString(*rt</span><span class="s4">, </span><span class="s1">(NSString *)result)</span><span class="s4">;</span>
      <span class="s4">break;</span>
    <span class="s1">}</span>
    <span class="s4">case </span><span class="s1">ObjectKind: {</span>
      <span class="s1">returnValue = convertNSDictionaryToJSIObject(*rt</span><span class="s4">, </span><span class="s1">(NSDictionary *)result)</span><span class="s4">;</span>
      <span class="s4">break;</span>
    <span class="s1">}</span>
    <span class="s4">case </span><span class="s1">ArrayKind: {</span>
      <span class="s1">returnValue = convertNSArrayToJSIArray(*rt</span><span class="s4">, </span><span class="s1">(NSArray *)result)</span><span class="s4">;</span>
      <span class="s4">break;</span>
    <span class="s1">}</span>
    <span class="s4">case </span><span class="s1">FunctionKind:</span>
      <span class="s4">throw </span><span class="s1">std::runtime_error(</span><span class="s3">&quot;convertInvocationResultToJSIValue: FunctionKind is not supported yet.&quot;</span><span class="s1">)</span><span class="s4">;</span>
    <span class="s4">case </span><span class="s1">PromiseKind:</span>
      <span class="s4">throw </span><span class="s1">std::runtime_error(</span><span class="s3">&quot;convertInvocationResultToJSIValue: PromiseKind wasn't handled properly.&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">TurboModulePerfLogger::syncMethodCallReturnConversionEnd(moduleName</span><span class="s4">, </span><span class="s1">methodName)</span><span class="s4">;</span>
  <span class="s4">return </span><span class="s1">returnValue</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Given a method name, and an argument index, return type of that argument. 
 * Prerequisite: You must wrap the method declaration inside some variant of the 
 * RCT_EXPORT_METHOD macro. 
 * 
 * This method returns nil if the method for which you're querying the argument type 
 * is not wrapped in an RCT_EXPORT_METHOD. 
 * 
 * Note: This is only being introduced for backward compatibility. It will be removed 
 *       in the future. 
 */</span>
<span class="s1">NSString *ObjCTurboModule::getArgumentTypeName(NSString *methodName</span><span class="s4">, int </span><span class="s1">argIndex)</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(!methodArgumentTypeNames_) {</span>
    <span class="s1">NSMutableDictionary&lt;NSString *</span><span class="s4">, </span><span class="s1">NSArray&lt;NSString *&gt; *&gt; *methodArgumentTypeNames = [NSMutableDictionary </span><span class="s4">new</span><span class="s1">]</span><span class="s4">;</span>

    <span class="s4">unsigned int </span><span class="s1">numberOfMethods</span><span class="s4">;</span>
    <span class="s1">Class cls = [instance_ </span><span class="s4">class</span><span class="s1">]</span><span class="s4">;</span>
    <span class="s1">Method *methods = class_copyMethodList(object_getClass(cls)</span><span class="s4">, </span><span class="s1">&amp;numberOfMethods)</span><span class="s4">;</span>

    <span class="s4">if </span><span class="s1">(methods) {</span>
      <span class="s4">for </span><span class="s1">(</span><span class="s4">unsigned int </span><span class="s1">i = </span><span class="s5">0</span><span class="s4">; </span><span class="s1">i &lt; numberOfMethods</span><span class="s4">; </span><span class="s1">i++) {</span>
        <span class="s1">SEL s = method_getName(methods[i])</span><span class="s4">;</span>
        <span class="s1">NSString *mName = NSStringFromSelector(s)</span><span class="s4">;</span>
        <span class="s4">if </span><span class="s1">(![mName hasPrefix:</span><span class="s4">@</span><span class="s3">&quot;__rct_export__&quot;</span><span class="s1">]) {</span>
          <span class="s4">continue;</span>
        <span class="s1">}</span>

        <span class="s0">// Message dispatch logic from old infra</span>
        <span class="s1">RCTMethodInfo *(*getMethodInfo)(id</span><span class="s4">, </span><span class="s1">SEL) = (</span><span class="s4">__typeof__</span><span class="s1">(getMethodInfo))objc_msgSend</span><span class="s4">;</span>
        <span class="s1">RCTMethodInfo *methodInfo = getMethodInfo(cls</span><span class="s4">, </span><span class="s1">s)</span><span class="s4">;</span>

        <span class="s1">NSArray&lt;RCTMethodArgument *&gt; *arguments</span><span class="s4">;</span>
        <span class="s1">NSString *otherMethodName = RCTParseMethodSignature(methodInfo-&gt;objcName</span><span class="s4">, </span><span class="s1">&amp;arguments)</span><span class="s4">;</span>

        <span class="s1">NSMutableArray *argumentTypes = [NSMutableArray arrayWithCapacity:[arguments count]]</span><span class="s4">;</span>
        <span class="s4">for </span><span class="s1">(</span><span class="s4">int </span><span class="s1">j = </span><span class="s5">0</span><span class="s4">; </span><span class="s1">j &lt; [arguments count]</span><span class="s4">; </span><span class="s1">j += </span><span class="s5">1</span><span class="s1">) {</span>
          <span class="s1">[argumentTypes addObject:arguments[j].type]</span><span class="s4">;</span>
        <span class="s1">}</span>

        <span class="s1">NSString *normalizedOtherMethodName = [otherMethodName componentsSeparatedByString:</span><span class="s4">@</span><span class="s3">&quot;:&quot;</span><span class="s1">][</span><span class="s5">0</span><span class="s1">]</span><span class="s4">;</span>
        <span class="s1">methodArgumentTypeNames[normalizedOtherMethodName] = argumentTypes</span><span class="s4">;</span>
      <span class="s1">}</span>

      <span class="s1">free(methods)</span><span class="s4">;</span>
    <span class="s1">}</span>

    <span class="s1">methodArgumentTypeNames_ = methodArgumentTypeNames</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(methodArgumentTypeNames_[methodName]) {</span>
    <span class="s1">assert([methodArgumentTypeNames_[methodName] count] &gt; argIndex)</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">methodArgumentTypeNames_[methodName][argIndex]</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">return </span><span class="s1">nil</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">NSInvocation *ObjCTurboModule::getMethodInvocation(</span>
    <span class="s1">jsi::Runtime &amp;runtime</span><span class="s4">,</span>
    <span class="s1">TurboModuleMethodValueKind returnType</span><span class="s4">,</span>
    <span class="s4">const char </span><span class="s1">*methodName</span><span class="s4">,</span>
    <span class="s1">SEL </span><span class="s4">selector,</span>
    <span class="s4">const </span><span class="s1">jsi::Value *args</span><span class="s4">,</span>
    <span class="s1">size_t count</span><span class="s4">,</span>
    <span class="s1">NSMutableArray *retainedObjectsForInvocation)</span>
<span class="s1">{</span>
  <span class="s4">const char </span><span class="s1">*moduleName = name_.c_str()</span><span class="s4">;</span>
  <span class="s4">const </span><span class="s1">id&lt;RCTTurboModule&gt; module = instance_</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(isMethodSync(returnType)) {</span>
    <span class="s1">TurboModulePerfLogger::syncMethodCallArgConversionStart(moduleName</span><span class="s4">, </span><span class="s1">methodName)</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s1">TurboModulePerfLogger::asyncMethodCallArgConversionStart(moduleName</span><span class="s4">, </span><span class="s1">methodName)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">NSInvocation *inv =</span>
      <span class="s1">[NSInvocation invocationWithMethodSignature:[[module </span><span class="s4">class</span><span class="s1">] instanceMethodSignatureForSelector:</span><span class="s4">selector</span><span class="s1">]]</span><span class="s4">;</span>
  <span class="s1">[inv setSelector:</span><span class="s4">selector</span><span class="s1">]</span><span class="s4">;</span>

  <span class="s1">NSMethodSignature *methodSignature = [[module </span><span class="s4">class</span><span class="s1">] instanceMethodSignatureForSelector:</span><span class="s4">selector</span><span class="s1">]</span><span class="s4">;</span>

  <span class="s4">for </span><span class="s1">(size_t i = </span><span class="s5">0</span><span class="s4">; </span><span class="s1">i &lt; count</span><span class="s4">; </span><span class="s1">i++) {</span>
    <span class="s4">const </span><span class="s1">jsi::Value *arg = &amp;args[i]</span><span class="s4">;</span>
    <span class="s4">const </span><span class="s1">std::string objCArgType = [methodSignature getArgumentTypeAtIndex:i + </span><span class="s5">2</span><span class="s1">]</span><span class="s4">;</span>

    <span class="s4">if </span><span class="s1">(arg-&gt;isBool()) {</span>
      <span class="s4">bool </span><span class="s1">v = arg-&gt;getBool()</span><span class="s4">;</span>

      <span class="s0">/** 
       * JS type checking ensures the Objective C argument here is either a BOOL or NSNumber*. 
       */</span>
      <span class="s4">if </span><span class="s1">(objCArgType == </span><span class="s4">@encode</span><span class="s1">(id)) {</span>
        <span class="s1">id objCArg = [NSNumber numberWithBool:v]</span><span class="s4">;</span>
        <span class="s1">[inv setArgument:(</span><span class="s4">void </span><span class="s1">*)&amp;objCArg atIndex:i + </span><span class="s5">2</span><span class="s1">]</span><span class="s4">;</span>
        <span class="s1">[retainedObjectsForInvocation addObject:objCArg]</span><span class="s4">;</span>
      <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
        <span class="s1">[inv setArgument:(</span><span class="s4">void </span><span class="s1">*)&amp;v atIndex:i + </span><span class="s5">2</span><span class="s1">]</span><span class="s4">;</span>
      <span class="s1">}</span>

      <span class="s4">continue;</span>
    <span class="s1">}</span>

    <span class="s4">if </span><span class="s1">(arg-&gt;isNumber()) {</span>
      <span class="s4">double </span><span class="s1">v = arg-&gt;getNumber()</span><span class="s4">;</span>

      <span class="s0">/** 
       * JS type checking ensures the Objective C argument here is either a double or NSNumber*. 
       */</span>
      <span class="s4">if </span><span class="s1">(objCArgType == </span><span class="s4">@encode</span><span class="s1">(id)) {</span>
        <span class="s1">id objCArg = [NSNumber numberWithDouble:v]</span><span class="s4">;</span>
        <span class="s1">[inv setArgument:(</span><span class="s4">void </span><span class="s1">*)&amp;objCArg atIndex:i + </span><span class="s5">2</span><span class="s1">]</span><span class="s4">;</span>
        <span class="s1">[retainedObjectsForInvocation addObject:objCArg]</span><span class="s4">;</span>
      <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
        <span class="s1">[inv setArgument:(</span><span class="s4">void </span><span class="s1">*)&amp;v atIndex:i + </span><span class="s5">2</span><span class="s1">]</span><span class="s4">;</span>
      <span class="s1">}</span>

      <span class="s4">continue;</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Convert arg to ObjC objects. 
     */</span>
    <span class="s1">id objCArg = convertJSIValueToObjCObject(runtime</span><span class="s4">, </span><span class="s1">*arg</span><span class="s4">, </span><span class="s1">jsInvoker_)</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">(objCArg) {</span>
      <span class="s1">NSString *methodNameNSString = </span><span class="s4">@</span><span class="s1">(methodName)</span><span class="s4">;</span>

      <span class="s0">/** 
       * Convert objects using RCTConvert. 
       */</span>
      <span class="s4">if </span><span class="s1">(objCArgType == </span><span class="s4">@encode</span><span class="s1">(id)) {</span>
        <span class="s1">NSString *argumentType = getArgumentTypeName(methodNameNSString</span><span class="s4">, </span><span class="s1">i)</span><span class="s4">;</span>
        <span class="s4">if </span><span class="s1">(argumentType != nil) {</span>
          <span class="s1">NSString *rctConvertMethodName = [NSString stringWithFormat:</span><span class="s4">@</span><span class="s3">&quot;%@:&quot;</span><span class="s4">, </span><span class="s1">argumentType]</span><span class="s4">;</span>
          <span class="s1">SEL rctConvertSelector = NSSelectorFromString(rctConvertMethodName)</span><span class="s4">;</span>

          <span class="s4">if </span><span class="s1">([RCTConvert respondsToSelector:rctConvertSelector]) {</span>
            <span class="s0">// Message dispatch logic from old infra</span>
            <span class="s1">id (*convert)(id</span><span class="s4">, </span><span class="s1">SEL</span><span class="s4">, </span><span class="s1">id) = (</span><span class="s4">__typeof__</span><span class="s1">(convert))objc_msgSend</span><span class="s4">;</span>
            <span class="s1">id convertedObjCArg = convert([RCTConvert </span><span class="s4">class</span><span class="s1">]</span><span class="s4">, </span><span class="s1">rctConvertSelector</span><span class="s4">, </span><span class="s1">objCArg)</span><span class="s4">;</span>

            <span class="s1">[inv setArgument:(</span><span class="s4">void </span><span class="s1">*)&amp;convertedObjCArg atIndex:i + </span><span class="s5">2</span><span class="s1">]</span><span class="s4">;</span>
            <span class="s4">if </span><span class="s1">(convertedObjCArg) {</span>
              <span class="s1">[retainedObjectsForInvocation addObject:convertedObjCArg]</span><span class="s4">;</span>
            <span class="s1">}</span>
            <span class="s4">continue;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s0">/** 
       * Convert objects using RCTCxxConvert to structs. 
       */</span>
      <span class="s4">if </span><span class="s1">([objCArg isKindOfClass:[NSDictionary </span><span class="s4">class</span><span class="s1">]] &amp;&amp; hasMethodArgConversionSelector(methodNameNSString</span><span class="s4">, </span><span class="s1">i)) {</span>
        <span class="s1">SEL methodArgConversionSelector = getMethodArgConversionSelector(methodNameNSString</span><span class="s4">, </span><span class="s1">i)</span><span class="s4">;</span>

        <span class="s0">// Message dispatch logic from old infra (link:</span>
        <span class="s0">// https://github.com/facebook/react-native/commit/6783694158057662fd7b11fc123c339b2b21bfe6#diff-263fc157dfce55895cdc16495b55d190R350)</span>
        <span class="s1">RCTManagedPointer *(*convert)(id</span><span class="s4">, </span><span class="s1">SEL</span><span class="s4">, </span><span class="s1">id) = (</span><span class="s4">__typeof__</span><span class="s1">(convert))objc_msgSend</span><span class="s4">;</span>
        <span class="s1">RCTManagedPointer *box = convert([RCTCxxConvert </span><span class="s4">class</span><span class="s1">]</span><span class="s4">, </span><span class="s1">methodArgConversionSelector</span><span class="s4">, </span><span class="s1">objCArg)</span><span class="s4">;</span>

        <span class="s4">void </span><span class="s1">*pointer = box.voidPointer</span><span class="s4">;</span>
        <span class="s1">[inv setArgument:&amp;pointer atIndex:i + </span><span class="s5">2</span><span class="s1">]</span><span class="s4">;</span>
        <span class="s1">[retainedObjectsForInvocation addObject:box]</span><span class="s4">;</span>
        <span class="s4">continue;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">/** 
     * Insert converted args unmodified. 
     */</span>
    <span class="s1">[inv setArgument:(</span><span class="s4">void </span><span class="s1">*)&amp;objCArg atIndex:i + </span><span class="s5">2</span><span class="s1">]</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">(objCArg) {</span>
      <span class="s1">[retainedObjectsForInvocation addObject:objCArg]</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(isMethodSync(returnType)) {</span>
    <span class="s1">TurboModulePerfLogger::syncMethodCallArgConversionEnd(moduleName</span><span class="s4">, </span><span class="s1">methodName)</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s1">TurboModulePerfLogger::asyncMethodCallArgConversionEnd(moduleName</span><span class="s4">, </span><span class="s1">methodName)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">return </span><span class="s1">inv</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">bool </span><span class="s1">ObjCTurboModule::isMethodSync(TurboModuleMethodValueKind returnType)</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">isSyncModule_ || !(returnType == VoidKind || returnType == PromiseKind)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">ObjCTurboModule::ObjCTurboModule(</span><span class="s4">const </span><span class="s1">InitParams &amp;params)</span>
    <span class="s1">: TurboModule(params.moduleName</span><span class="s4">, </span><span class="s1">params.jsInvoker)</span><span class="s4">,</span>
      <span class="s1">instance_(params.instance)</span><span class="s4">,</span>
      <span class="s1">nativeInvoker_(params.nativeInvoker)</span><span class="s4">,</span>
      <span class="s1">isSyncModule_(params.isSyncModule)</span>
<span class="s1">{</span>
<span class="s1">}</span>

<span class="s1">jsi::Value ObjCTurboModule::invokeObjCMethod(</span>
    <span class="s1">jsi::Runtime &amp;runtime</span><span class="s4">,</span>
    <span class="s1">TurboModuleMethodValueKind returnType</span><span class="s4">,</span>
    <span class="s4">const </span><span class="s1">std::string &amp;methodNameStr</span><span class="s4">,</span>
    <span class="s1">SEL </span><span class="s4">selector,</span>
    <span class="s4">const </span><span class="s1">jsi::Value *args</span><span class="s4">,</span>
    <span class="s1">size_t count)</span>
<span class="s1">{</span>
  <span class="s4">const char </span><span class="s1">*moduleName = name_.c_str()</span><span class="s4">;</span>
  <span class="s4">const char </span><span class="s1">*methodName = methodNameStr.c_str()</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(isMethodSync(returnType)) {</span>
    <span class="s1">TurboModulePerfLogger::syncMethodCallStart(moduleName</span><span class="s4">, </span><span class="s1">methodName)</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s1">TurboModulePerfLogger::asyncMethodCallStart(moduleName</span><span class="s4">, </span><span class="s1">methodName)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">NSMutableArray *retainedObjectsForInvocation = [NSMutableArray arrayWithCapacity:count + </span><span class="s5">2</span><span class="s1">]</span><span class="s4">;</span>
  <span class="s1">NSInvocation *inv =</span>
      <span class="s1">getMethodInvocation(runtime</span><span class="s4">, </span><span class="s1">returnType</span><span class="s4">, </span><span class="s1">methodName</span><span class="s4">, selector, </span><span class="s1">args</span><span class="s4">, </span><span class="s1">count</span><span class="s4">, </span><span class="s1">retainedObjectsForInvocation)</span><span class="s4">;</span>

  <span class="s1">jsi::Value returnValue = returnType == PromiseKind</span>
      <span class="s1">? createPromise(</span>
            <span class="s1">runtime</span><span class="s4">,</span>
            <span class="s1">methodNameStr</span><span class="s4">,</span>
            <span class="s1">^(RCTPromiseResolveBlock resolveBlock</span><span class="s4">, </span><span class="s1">RCTPromiseRejectBlock rejectBlock) {</span>
              <span class="s1">RCTPromiseResolveBlock resolveCopy = [resolveBlock copy]</span><span class="s4">;</span>
              <span class="s1">RCTPromiseRejectBlock rejectCopy = [rejectBlock copy]</span><span class="s4">;</span>

              <span class="s1">[inv setArgument:(</span><span class="s4">void </span><span class="s1">*)&amp;resolveCopy atIndex:count + </span><span class="s5">2</span><span class="s1">]</span><span class="s4">;</span>
              <span class="s1">[inv setArgument:(</span><span class="s4">void </span><span class="s1">*)&amp;rejectCopy atIndex:count + </span><span class="s5">3</span><span class="s1">]</span><span class="s4">;</span>
              <span class="s1">[retainedObjectsForInvocation addObject:resolveCopy]</span><span class="s4">;</span>
              <span class="s1">[retainedObjectsForInvocation addObject:rejectCopy]</span><span class="s4">;</span>
              <span class="s0">// The return type becomes void in the ObjC side.</span>
              <span class="s1">performMethodInvocation(runtime</span><span class="s4">, </span><span class="s1">VoidKind</span><span class="s4">, </span><span class="s1">methodName</span><span class="s4">, </span><span class="s1">inv</span><span class="s4">, </span><span class="s1">retainedObjectsForInvocation)</span><span class="s4">;</span>
            <span class="s1">})</span>
      <span class="s1">: performMethodInvocation(runtime</span><span class="s4">, </span><span class="s1">returnType</span><span class="s4">, </span><span class="s1">methodName</span><span class="s4">, </span><span class="s1">inv</span><span class="s4">, </span><span class="s1">retainedObjectsForInvocation)</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(isMethodSync(returnType)) {</span>
    <span class="s1">TurboModulePerfLogger::syncMethodCallEnd(moduleName</span><span class="s4">, </span><span class="s1">methodName)</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s1">TurboModulePerfLogger::asyncMethodCallEnd(moduleName</span><span class="s4">, </span><span class="s1">methodName)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">return </span><span class="s1">returnValue</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">BOOL ObjCTurboModule::hasMethodArgConversionSelector(NSString *methodName</span><span class="s4">, int </span><span class="s1">argIndex)</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">methodArgConversionSelectors_ &amp;&amp; methodArgConversionSelectors_[methodName] &amp;&amp;</span>
      <span class="s1">![methodArgConversionSelectors_[methodName][argIndex] isEqual:[NSNull null]]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">SEL ObjCTurboModule::getMethodArgConversionSelector(NSString *methodName</span><span class="s4">, int </span><span class="s1">argIndex)</span>
<span class="s1">{</span>
  <span class="s1">assert(hasMethodArgConversionSelector(methodName</span><span class="s4">, </span><span class="s1">argIndex))</span><span class="s4">;</span>
  <span class="s4">return </span><span class="s1">(SEL)((NSValue *)methodArgConversionSelectors_[methodName][argIndex]).pointerValue</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">ObjCTurboModule::setMethodArgConversionSelector(NSString *methodName</span><span class="s4">, int </span><span class="s1">argIndex</span><span class="s4">, </span><span class="s1">NSString *fnName)</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(!methodArgConversionSelectors_) {</span>
    <span class="s1">methodArgConversionSelectors_ = [NSMutableDictionary </span><span class="s4">new</span><span class="s1">]</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(!methodArgConversionSelectors_[methodName]) {</span>
    <span class="s4">auto </span><span class="s1">metaData = methodMap_.at([methodName UTF8String])</span><span class="s4">;</span>
    <span class="s4">auto </span><span class="s1">argCount = metaData.argCount</span><span class="s4">;</span>

    <span class="s1">methodArgConversionSelectors_[methodName] = [NSMutableArray arrayWithCapacity:argCount]</span><span class="s4">;</span>
    <span class="s4">for </span><span class="s1">(</span><span class="s4">int </span><span class="s1">i = </span><span class="s5">0</span><span class="s4">; </span><span class="s1">i &lt; argCount</span><span class="s4">; </span><span class="s1">i += </span><span class="s5">1</span><span class="s1">) {</span>
      <span class="s1">[methodArgConversionSelectors_[methodName] addObject:[NSNull null]]</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">SEL </span><span class="s4">selector </span><span class="s1">= NSSelectorFromString(fnName)</span><span class="s4">;</span>
  <span class="s1">NSValue *selectorValue = [NSValue valueWithPointer:</span><span class="s4">selector</span><span class="s1">]</span><span class="s4">;</span>

  <span class="s1">methodArgConversionSelectors_[methodName][argIndex] = selectorValue</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">} </span><span class="s0">// namespace react</span>
<span class="s1">} </span><span class="s0">// namespace facebook</span>
</pre>
</body>
</html>
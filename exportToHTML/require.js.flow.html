<html>
<head>
<title>require.js.flow</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
require.js.flow</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* Copyright (c) Meta Platforms, Inc. and affiliates.</span>
 <span class="s0">*</span>
 <span class="s0">* This source code is licensed under the MIT license found in the</span>
 <span class="s0">* LICENSE file in the root directory of this source tree.</span>
 <span class="s0">*</span>
 <span class="s0">* @flow</span>
 <span class="s0">* @format</span>
 <span class="s0">* @oncall react_native</span>
 <span class="s0">* @polyfill</span>
 <span class="s0">*/</span>

<span class="s0">'use strict';</span>

<span class="s0">/* eslint-disable no-bitwise */</span>

<span class="s0">declare var __DEV__: boolean;</span>
<span class="s0">declare var __METRO_GLOBAL_PREFIX__: string;</span>

<span class="s0">// A simpler $ArrayLike&lt;T&gt;. Not iterable and doesn't have a `length`.</span>
<span class="s0">// This is compatible with actual arrays as well as with objects that look like</span>
<span class="s0">// {0: 'value', 1: '...'}</span>
<span class="s0">type ArrayIndexable&lt;T&gt; = interface {</span>
  <span class="s0">+[indexer: number]: T,</span>
<span class="s0">};</span>
<span class="s0">type DependencyMap = $ReadOnly&lt;</span>
  <span class="s0">ArrayIndexable&lt;ModuleID&gt; &amp; {</span>
    <span class="s0">paths?: {[id: ModuleID]: string},</span>
  <span class="s0">},</span>
<span class="s0">&gt;;</span>
<span class="s0">type InverseDependencyMap = {[key: ModuleID]: Array&lt;ModuleID&gt;, ...};</span>
<span class="s0">type Exports = any;</span>
<span class="s0">type FactoryFn = (</span>
  <span class="s0">global: Object,</span>
  <span class="s0">require: RequireFn,</span>
  <span class="s0">metroImportDefault: RequireFn,</span>
  <span class="s0">metroImportAll: RequireFn,</span>
  <span class="s0">moduleObject: {exports: {...}, ...},</span>
  <span class="s0">exports: {...},</span>
  <span class="s0">dependencyMap: ?DependencyMap,</span>
<span class="s0">) =&gt; void;</span>
<span class="s0">type HotModuleReloadingCallback = () =&gt; void;</span>
<span class="s0">type HotModuleReloadingData = {</span>
  <span class="s0">_acceptCallback: ?HotModuleReloadingCallback,</span>
  <span class="s0">_disposeCallback: ?HotModuleReloadingCallback,</span>
  <span class="s0">_didAccept: boolean,</span>
  <span class="s0">accept: (callback?: HotModuleReloadingCallback) =&gt; void,</span>
  <span class="s0">dispose: (callback?: HotModuleReloadingCallback) =&gt; void,</span>
<span class="s0">};</span>
<span class="s0">type ModuleID = number;</span>
<span class="s0">type Module = {</span>
  <span class="s0">id?: ModuleID,</span>
  <span class="s0">exports: Exports,</span>
  <span class="s0">hot?: HotModuleReloadingData,</span>
  <span class="s0">...</span>
<span class="s0">};</span>
<span class="s0">type ModuleDefinition = {</span>
  <span class="s0">dependencyMap: ?DependencyMap,</span>
  <span class="s0">error?: any,</span>
  <span class="s0">factory: FactoryFn,</span>
  <span class="s0">hasError: boolean,</span>
  <span class="s0">hot?: HotModuleReloadingData,</span>
  <span class="s0">importedAll: any,</span>
  <span class="s0">importedDefault: any,</span>
  <span class="s0">isInitialized: boolean,</span>
  <span class="s0">path?: string,</span>
  <span class="s0">publicModule: Module,</span>
  <span class="s0">verboseName?: string,</span>
<span class="s0">};</span>
<span class="s0">type ModuleList = {</span>
  <span class="s0">[number]: ?ModuleDefinition,</span>
  <span class="s0">__proto__: null,</span>
  <span class="s0">...</span>
<span class="s0">};</span>
<span class="s0">export type RequireFn = (id: ModuleID | VerboseModuleNameForDev) =&gt; Exports;</span>
<span class="s0">export type DefineFn = (</span>
  <span class="s0">factory: FactoryFn,</span>
  <span class="s0">moduleId: number,</span>
  <span class="s0">dependencyMap?: DependencyMap,</span>
  <span class="s0">verboseName?: string,</span>
  <span class="s0">inverseDependencies?: InverseDependencyMap,</span>
<span class="s0">) =&gt; void;</span>

<span class="s0">type VerboseModuleNameForDev = string;</span>
<span class="s0">type ModuleDefiner = (moduleId: ModuleID) =&gt; void;</span>

<span class="s0">global.__r = (metroRequire: RequireFn);</span>
<span class="s0">global[`${__METRO_GLOBAL_PREFIX__}__d`] = (define: DefineFn);</span>
<span class="s0">global.__c = clear;</span>
<span class="s0">global.__registerSegment = registerSegment;</span>

<span class="s0">var modules = clear();</span>

<span class="s0">// Don't use a Symbol here, it would pull in an extra polyfill with all sorts of</span>
<span class="s0">// additional stuff (e.g. Array.from).</span>
<span class="s0">const EMPTY = {};</span>
<span class="s0">const CYCLE_DETECTED = {};</span>
<span class="s0">const {hasOwnProperty} = {};</span>

<span class="s0">if (__DEV__) {</span>
  <span class="s0">global.$RefreshReg$ = () =&gt; {};</span>
  <span class="s0">global.$RefreshSig$ = () =&gt; type =&gt; type;</span>
<span class="s0">}</span>

<span class="s0">function clear(): ModuleList {</span>
  <span class="s0">modules = (Object.create(null): ModuleList);</span>

  <span class="s0">// We return modules here so that we can assign an initial value to modules</span>
  <span class="s0">// when defining it. Otherwise, we would have to do &quot;let modules = null&quot;,</span>
  <span class="s0">// which will force us to add &quot;nullthrows&quot; everywhere.</span>
  <span class="s0">return modules;</span>
<span class="s0">}</span>

<span class="s0">if (__DEV__) {</span>
  <span class="s0">var verboseNamesToModuleIds: {</span>
    <span class="s0">[key: string]: number,</span>
    <span class="s0">__proto__: null,</span>
    <span class="s0">...</span>
  <span class="s0">} = Object.create(null);</span>
  <span class="s0">var initializingModuleIds: Array&lt;number&gt; = [];</span>
<span class="s0">}</span>

<span class="s0">function define(</span>
  <span class="s0">factory: FactoryFn,</span>
  <span class="s0">moduleId: number,</span>
  <span class="s0">dependencyMap?: DependencyMap,</span>
<span class="s0">): void {</span>
  <span class="s0">if (modules[moduleId] != null) {</span>
    <span class="s0">if (__DEV__) {</span>
      <span class="s0">// (We take `inverseDependencies` from `arguments` to avoid an unused</span>
      <span class="s0">// named parameter in `define` in production.</span>
      <span class="s0">const inverseDependencies = arguments[4];</span>

      <span class="s0">// If the module has already been defined and the define method has been</span>
      <span class="s0">// called with inverseDependencies, we can hot reload it.</span>
      <span class="s0">if (inverseDependencies) {</span>
        <span class="s0">global.__accept(moduleId, factory, dependencyMap, inverseDependencies);</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s0">// prevent repeated calls to `global.nativeRequire` to overwrite modules</span>
    <span class="s0">// that are already loaded</span>
    <span class="s0">return;</span>
  <span class="s0">}</span>

  <span class="s0">const mod: ModuleDefinition = {</span>
    <span class="s0">dependencyMap,</span>
    <span class="s0">factory,</span>
    <span class="s0">hasError: false,</span>
    <span class="s0">importedAll: EMPTY,</span>
    <span class="s0">importedDefault: EMPTY,</span>
    <span class="s0">isInitialized: false,</span>
    <span class="s0">publicModule: {exports: {}},</span>
  <span class="s0">};</span>

  <span class="s0">modules[moduleId] = mod;</span>

  <span class="s0">if (__DEV__) {</span>
    <span class="s0">// HMR</span>
    <span class="s0">mod.hot = createHotReloadingObject();</span>

    <span class="s0">// DEBUGGABLE MODULES NAMES</span>
    <span class="s0">// we take `verboseName` from `arguments` to avoid an unused named parameter</span>
    <span class="s0">// in `define` in production.</span>
    <span class="s0">const verboseName: string | void = arguments[3];</span>
    <span class="s0">if (verboseName) {</span>
      <span class="s0">mod.verboseName = verboseName;</span>
      <span class="s0">verboseNamesToModuleIds[verboseName] = moduleId;</span>
    <span class="s0">}</span>
  <span class="s0">}</span>
<span class="s0">}</span>

<span class="s0">function metroRequire(moduleId: ModuleID | VerboseModuleNameForDev): Exports {</span>
  <span class="s0">if (__DEV__ &amp;&amp; typeof moduleId === 'string') {</span>
    <span class="s0">const verboseName = moduleId;</span>
    <span class="s0">moduleId = verboseNamesToModuleIds[verboseName];</span>
    <span class="s0">if (moduleId == null) {</span>
      <span class="s0">throw new Error(`Unknown named module: &quot;${verboseName}&quot;`);</span>
    <span class="s0">} else {</span>
      <span class="s0">console.warn(</span>
        <span class="s0">`Requiring module &quot;${verboseName}&quot; by name is only supported for ` +</span>
          <span class="s0">'debugging purposes and will BREAK IN PRODUCTION!',</span>
      <span class="s0">);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s0">//$FlowFixMe: at this point we know that moduleId is a number</span>
  <span class="s0">const moduleIdReallyIsNumber: number = moduleId;</span>

  <span class="s0">if (__DEV__) {</span>
    <span class="s0">const initializingIndex = initializingModuleIds.indexOf(</span>
      <span class="s0">moduleIdReallyIsNumber,</span>
    <span class="s0">);</span>
    <span class="s0">if (initializingIndex !== -1) {</span>
      <span class="s0">const cycle = initializingModuleIds</span>
        <span class="s0">.slice(initializingIndex)</span>
        <span class="s0">.map((id: number) =&gt;</span>
          <span class="s0">modules[id] ? modules[id].verboseName : '[unknown]',</span>
        <span class="s0">);</span>

      <span class="s0">if (shouldPrintRequireCycle(cycle)) {</span>
        <span class="s0">cycle.push(cycle[0]); // We want to print A -&gt; B -&gt; A:</span>
        <span class="s0">console.warn(</span>
          <span class="s0">`Require cycle: ${cycle.join(' -&gt; ')}\n\n` +</span>
            <span class="s0">'Require cycles are allowed, but can result in uninitialized values. ' +</span>
            <span class="s0">'Consider refactoring to remove the need for a cycle.',</span>
        <span class="s0">);</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s0">const module = modules[moduleIdReallyIsNumber];</span>

  <span class="s0">return module &amp;&amp; module.isInitialized</span>
    <span class="s0">? module.publicModule.exports</span>
    <span class="s0">: guardedLoadModule(moduleIdReallyIsNumber, module);</span>
<span class="s0">}</span>

<span class="s0">// We print require cycles unless they match a pattern in the</span>
<span class="s0">// `requireCycleIgnorePatterns` configuration.</span>
<span class="s0">function shouldPrintRequireCycle(modules: $ReadOnlyArray&lt;?string&gt;): boolean {</span>
  <span class="s0">const regExps =</span>
    <span class="s0">global[__METRO_GLOBAL_PREFIX__ + '__requireCycleIgnorePatterns'];</span>
  <span class="s0">if (!Array.isArray(regExps)) {</span>
    <span class="s0">return true;</span>
  <span class="s0">}</span>

  <span class="s0">const isIgnored = (module: ?string) =&gt;</span>
    <span class="s0">module != null &amp;&amp; regExps.some(regExp =&gt; regExp.test(module));</span>

  <span class="s0">// Print the cycle unless any part of it is ignored</span>
  <span class="s0">return modules.every(module =&gt; !isIgnored(module));</span>
<span class="s0">}</span>

<span class="s0">function metroImportDefault(</span>
  <span class="s0">moduleId: ModuleID | VerboseModuleNameForDev,</span>
<span class="s0">): any | Exports {</span>
  <span class="s0">if (__DEV__ &amp;&amp; typeof moduleId === 'string') {</span>
    <span class="s0">const verboseName = moduleId;</span>
    <span class="s0">moduleId = verboseNamesToModuleIds[verboseName];</span>
  <span class="s0">}</span>

  <span class="s0">//$FlowFixMe: at this point we know that moduleId is a number</span>
  <span class="s0">const moduleIdReallyIsNumber: number = moduleId;</span>

  <span class="s0">if (</span>
    <span class="s0">modules[moduleIdReallyIsNumber] &amp;&amp;</span>
    <span class="s0">modules[moduleIdReallyIsNumber].importedDefault !== EMPTY</span>
  <span class="s0">) {</span>
    <span class="s0">return modules[moduleIdReallyIsNumber].importedDefault;</span>
  <span class="s0">}</span>

  <span class="s0">const exports: Exports = metroRequire(moduleIdReallyIsNumber);</span>
  <span class="s0">const importedDefault: any | Exports =</span>
    <span class="s0">exports &amp;&amp; exports.__esModule ? exports.default : exports;</span>

  <span class="s0">// $FlowFixMe The metroRequire call above will throw if modules[id] is null</span>
  <span class="s0">return (modules[moduleIdReallyIsNumber].importedDefault = importedDefault);</span>
<span class="s0">}</span>
<span class="s0">metroRequire.importDefault = metroImportDefault;</span>

<span class="s0">function metroImportAll(</span>
  <span class="s0">moduleId: ModuleID | VerboseModuleNameForDev | number,</span>
<span class="s0">): any | Exports | {[string]: any} {</span>
  <span class="s0">if (__DEV__ &amp;&amp; typeof moduleId === 'string') {</span>
    <span class="s0">const verboseName = moduleId;</span>
    <span class="s0">moduleId = verboseNamesToModuleIds[verboseName];</span>
  <span class="s0">}</span>

  <span class="s0">//$FlowFixMe: at this point we know that moduleId is a number</span>
  <span class="s0">const moduleIdReallyIsNumber: number = moduleId;</span>

  <span class="s0">if (</span>
    <span class="s0">modules[moduleIdReallyIsNumber] &amp;&amp;</span>
    <span class="s0">modules[moduleIdReallyIsNumber].importedAll !== EMPTY</span>
  <span class="s0">) {</span>
    <span class="s0">return modules[moduleIdReallyIsNumber].importedAll;</span>
  <span class="s0">}</span>

  <span class="s0">const exports: Exports = metroRequire(moduleIdReallyIsNumber);</span>
  <span class="s0">let importedAll: Exports | {[string]: any};</span>

  <span class="s0">if (exports &amp;&amp; exports.__esModule) {</span>
    <span class="s0">importedAll = exports;</span>
  <span class="s0">} else {</span>
    <span class="s0">importedAll = ({}: {[string]: any});</span>

    <span class="s0">// Refrain from using Object.assign, it has to work in ES3 environments.</span>
    <span class="s0">if (exports) {</span>
      <span class="s0">for (const key: string in exports) {</span>
        <span class="s0">if (hasOwnProperty.call(exports, key)) {</span>
          <span class="s0">importedAll[key] = exports[key];</span>
        <span class="s0">}</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s0">importedAll.default = exports;</span>
  <span class="s0">}</span>

  <span class="s0">// $FlowFixMe The metroRequire call above will throw if modules[id] is null</span>
  <span class="s0">return (modules[moduleIdReallyIsNumber].importedAll = importedAll);</span>
<span class="s0">}</span>
<span class="s0">metroRequire.importAll = metroImportAll;</span>

<span class="s0">// The `require.context()` syntax is never executed in the runtime because it is converted</span>
<span class="s0">// to `require()` in `metro/src/ModuleGraph/worker/collectDependencies.js` after collecting</span>
<span class="s0">// dependencies. If the feature flag is not enabled then the conversion never takes place and this error is thrown (development only).</span>
<span class="s0">metroRequire.context = function fallbackRequireContext() {</span>
  <span class="s0">if (__DEV__) {</span>
    <span class="s0">throw new Error(</span>
      <span class="s0">'The experimental Metro feature `require.context` is not enabled in your project.\nThis can be enabled by setting the `transformer.unstable_allowRequireContext` property to `true` in your Metro configuration.',</span>
    <span class="s0">);</span>
  <span class="s0">}</span>
  <span class="s0">throw new Error(</span>
    <span class="s0">'The experimental Metro feature `require.context` is not enabled in your project.',</span>
  <span class="s0">);</span>
<span class="s0">};</span>

<span class="s0">// `require.resolveWeak()` is a compile-time primitive (see collectDependencies.js)</span>
<span class="s0">metroRequire.resolveWeak = function fallbackRequireResolveWeak() {</span>
  <span class="s0">if (__DEV__) {</span>
    <span class="s0">throw new Error(</span>
      <span class="s0">'require.resolveWeak cannot be called dynamically. Ensure you are using the same version of `metro` and `metro-runtime`.',</span>
    <span class="s0">);</span>
  <span class="s0">}</span>
  <span class="s0">throw new Error('require.resolveWeak cannot be called dynamically.');</span>
<span class="s0">};</span>

<span class="s0">let inGuard = false;</span>
<span class="s0">function guardedLoadModule(</span>
  <span class="s0">moduleId: ModuleID,</span>
  <span class="s0">module: ?ModuleDefinition,</span>
<span class="s0">): Exports {</span>
  <span class="s0">if (!inGuard &amp;&amp; global.ErrorUtils) {</span>
    <span class="s0">inGuard = true;</span>
    <span class="s0">let returnValue;</span>
    <span class="s0">try {</span>
      <span class="s0">returnValue = loadModuleImplementation(moduleId, module);</span>
    <span class="s0">} catch (e) {</span>
      <span class="s0">// TODO: (moti) T48204692 Type this use of ErrorUtils.</span>
      <span class="s0">global.ErrorUtils.reportFatalError(e);</span>
    <span class="s0">}</span>
    <span class="s0">inGuard = false;</span>
    <span class="s0">return returnValue;</span>
  <span class="s0">} else {</span>
    <span class="s0">return loadModuleImplementation(moduleId, module);</span>
  <span class="s0">}</span>
<span class="s0">}</span>

<span class="s0">const ID_MASK_SHIFT = 16;</span>
<span class="s0">const LOCAL_ID_MASK = ~0 &gt;&gt;&gt; ID_MASK_SHIFT;</span>

<span class="s0">function unpackModuleId(moduleId: ModuleID): {</span>
  <span class="s0">localId: number,</span>
  <span class="s0">segmentId: number,</span>
  <span class="s0">...</span>
<span class="s0">} {</span>
  <span class="s0">const segmentId = moduleId &gt;&gt;&gt; ID_MASK_SHIFT;</span>
  <span class="s0">const localId = moduleId &amp; LOCAL_ID_MASK;</span>
  <span class="s0">return {segmentId, localId};</span>
<span class="s0">}</span>
<span class="s0">metroRequire.unpackModuleId = unpackModuleId;</span>

<span class="s0">function packModuleId(value: {</span>
  <span class="s0">localId: number,</span>
  <span class="s0">segmentId: number,</span>
  <span class="s0">...</span>
<span class="s0">}): ModuleID {</span>
  <span class="s0">return (value.segmentId &lt;&lt; ID_MASK_SHIFT) + value.localId;</span>
<span class="s0">}</span>
<span class="s0">metroRequire.packModuleId = packModuleId;</span>

<span class="s0">const moduleDefinersBySegmentID: Array&lt;?ModuleDefiner&gt; = [];</span>
<span class="s0">const definingSegmentByModuleID: Map&lt;ModuleID, number&gt; = new Map();</span>

<span class="s0">function registerSegment(</span>
  <span class="s0">segmentId: number,</span>
  <span class="s0">moduleDefiner: ModuleDefiner,</span>
  <span class="s0">moduleIds: ?$ReadOnlyArray&lt;ModuleID&gt;,</span>
<span class="s0">): void {</span>
  <span class="s0">moduleDefinersBySegmentID[segmentId] = moduleDefiner;</span>
  <span class="s0">if (__DEV__) {</span>
    <span class="s0">if (segmentId === 0 &amp;&amp; moduleIds) {</span>
      <span class="s0">throw new Error(</span>
        <span class="s0">'registerSegment: Expected moduleIds to be null for main segment',</span>
      <span class="s0">);</span>
    <span class="s0">}</span>
    <span class="s0">if (segmentId !== 0 &amp;&amp; !moduleIds) {</span>
      <span class="s0">throw new Error(</span>
        <span class="s0">'registerSegment: Expected moduleIds to be passed for segment #' +</span>
          <span class="s0">segmentId,</span>
      <span class="s0">);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>
  <span class="s0">if (moduleIds) {</span>
    <span class="s0">moduleIds.forEach(moduleId =&gt; {</span>
      <span class="s0">if (!modules[moduleId] &amp;&amp; !definingSegmentByModuleID.has(moduleId)) {</span>
        <span class="s0">definingSegmentByModuleID.set(moduleId, segmentId);</span>
      <span class="s0">}</span>
    <span class="s0">});</span>
  <span class="s0">}</span>
<span class="s0">}</span>

<span class="s0">function loadModuleImplementation(</span>
  <span class="s0">moduleId: ModuleID,</span>
  <span class="s0">module: ?ModuleDefinition,</span>
<span class="s0">): Exports {</span>
  <span class="s0">if (!module &amp;&amp; moduleDefinersBySegmentID.length &gt; 0) {</span>
    <span class="s0">const segmentId = definingSegmentByModuleID.get(moduleId) ?? 0;</span>
    <span class="s0">const definer = moduleDefinersBySegmentID[segmentId];</span>
    <span class="s0">if (definer != null) {</span>
      <span class="s0">definer(moduleId);</span>
      <span class="s0">module = modules[moduleId];</span>
      <span class="s0">definingSegmentByModuleID.delete(moduleId);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s0">const nativeRequire = global.nativeRequire;</span>
  <span class="s0">if (!module &amp;&amp; nativeRequire) {</span>
    <span class="s0">const {segmentId, localId} = unpackModuleId(moduleId);</span>
    <span class="s0">nativeRequire(localId, segmentId);</span>
    <span class="s0">module = modules[moduleId];</span>
  <span class="s0">}</span>

  <span class="s0">if (!module) {</span>
    <span class="s0">throw unknownModuleError(moduleId);</span>
  <span class="s0">}</span>

  <span class="s0">if (module.hasError) {</span>
    <span class="s0">throw module.error;</span>
  <span class="s0">}</span>

  <span class="s0">if (__DEV__) {</span>
    <span class="s0">var Systrace = requireSystrace();</span>
    <span class="s0">var Refresh = requireRefresh();</span>
  <span class="s0">}</span>

  <span class="s0">// We must optimistically mark module as initialized before running the</span>
  <span class="s0">// factory to keep any require cycles inside the factory from causing an</span>
  <span class="s0">// infinite require loop.</span>
  <span class="s0">module.isInitialized = true;</span>

  <span class="s0">const {factory, dependencyMap} = module;</span>
  <span class="s0">if (__DEV__) {</span>
    <span class="s0">initializingModuleIds.push(moduleId);</span>
  <span class="s0">}</span>
  <span class="s0">try {</span>
    <span class="s0">if (__DEV__) {</span>
      <span class="s0">// $FlowIgnore: we know that __DEV__ is const and `Systrace` exists</span>
      <span class="s0">Systrace.beginEvent('JS_require_' + (module.verboseName || moduleId));</span>
    <span class="s0">}</span>

    <span class="s0">const moduleObject: Module = module.publicModule;</span>

    <span class="s0">if (__DEV__) {</span>
      <span class="s0">moduleObject.hot = module.hot;</span>

      <span class="s0">var prevRefreshReg = global.$RefreshReg$;</span>
      <span class="s0">var prevRefreshSig = global.$RefreshSig$;</span>
      <span class="s0">if (Refresh != null) {</span>
        <span class="s0">const RefreshRuntime = Refresh;</span>
        <span class="s0">global.$RefreshReg$ = (type, id) =&gt; {</span>
          <span class="s0">RefreshRuntime.register(type, moduleId + ' ' + id);</span>
        <span class="s0">};</span>
        <span class="s0">global.$RefreshSig$ =</span>
          <span class="s0">RefreshRuntime.createSignatureFunctionForTransform;</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">moduleObject.id = moduleId;</span>

    <span class="s0">// keep args in sync with with defineModuleCode in</span>
    <span class="s0">// metro/src/Resolver/index.js</span>
    <span class="s0">// and metro/src/ModuleGraph/worker.js</span>
    <span class="s0">factory(</span>
      <span class="s0">global,</span>
      <span class="s0">metroRequire,</span>
      <span class="s0">metroImportDefault,</span>
      <span class="s0">metroImportAll,</span>
      <span class="s0">moduleObject,</span>
      <span class="s0">moduleObject.exports,</span>
      <span class="s0">dependencyMap,</span>
    <span class="s0">);</span>

    <span class="s0">// avoid removing factory in DEV mode as it breaks HMR</span>
    <span class="s0">if (!__DEV__) {</span>
      <span class="s0">// $FlowFixMe: This is only sound because we never access `factory` again</span>
      <span class="s0">module.factory = undefined;</span>
      <span class="s0">module.dependencyMap = undefined;</span>
    <span class="s0">}</span>

    <span class="s0">if (__DEV__) {</span>
      <span class="s0">// $FlowIgnore: we know that __DEV__ is const and `Systrace` exists</span>
      <span class="s0">Systrace.endEvent();</span>

      <span class="s0">if (Refresh != null) {</span>
        <span class="s0">registerExportsForReactRefresh(Refresh, moduleObject.exports, moduleId);</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s0">return moduleObject.exports;</span>
  <span class="s0">} catch (e) {</span>
    <span class="s0">module.hasError = true;</span>
    <span class="s0">module.error = e;</span>
    <span class="s0">module.isInitialized = false;</span>
    <span class="s0">module.publicModule.exports = undefined;</span>
    <span class="s0">throw e;</span>
  <span class="s0">} finally {</span>
    <span class="s0">if (__DEV__) {</span>
      <span class="s0">if (initializingModuleIds.pop() !== moduleId) {</span>
        <span class="s0">throw new Error(</span>
          <span class="s0">'initializingModuleIds is corrupt; something is terribly wrong',</span>
        <span class="s0">);</span>
      <span class="s0">}</span>
      <span class="s0">global.$RefreshReg$ = prevRefreshReg;</span>
      <span class="s0">global.$RefreshSig$ = prevRefreshSig;</span>
    <span class="s0">}</span>
  <span class="s0">}</span>
<span class="s0">}</span>

<span class="s0">function unknownModuleError(id: ModuleID): Error {</span>
  <span class="s0">let message = 'Requiring unknown module &quot;' + id + '&quot;.';</span>
  <span class="s0">if (__DEV__) {</span>
    <span class="s0">message +=</span>
      <span class="s0">' If you are sure the module exists, try restarting Metro. ' +</span>
      <span class="s0">'You may also want to run `yarn` or `npm install`.';</span>
  <span class="s0">}</span>
  <span class="s0">return Error(message);</span>
<span class="s0">}</span>

<span class="s0">if (__DEV__) {</span>
  <span class="s0">// $FlowFixMe[prop-missing]</span>
  <span class="s0">metroRequire.Systrace = {</span>
    <span class="s0">beginEvent: (): void =&gt; {},</span>
    <span class="s0">endEvent: (): void =&gt; {},</span>
  <span class="s0">};</span>
  <span class="s0">// $FlowFixMe[prop-missing]</span>
  <span class="s0">metroRequire.getModules = (): ModuleList =&gt; {</span>
    <span class="s0">return modules;</span>
  <span class="s0">};</span>

  <span class="s0">// HOT MODULE RELOADING</span>
  <span class="s0">var createHotReloadingObject = function () {</span>
    <span class="s0">const hot: HotModuleReloadingData = {</span>
      <span class="s0">_acceptCallback: null,</span>
      <span class="s0">_disposeCallback: null,</span>
      <span class="s0">_didAccept: false,</span>
      <span class="s0">accept: (callback?: HotModuleReloadingCallback): void =&gt; {</span>
        <span class="s0">hot._didAccept = true;</span>
        <span class="s0">hot._acceptCallback = callback;</span>
      <span class="s0">},</span>
      <span class="s0">dispose: (callback?: HotModuleReloadingCallback): void =&gt; {</span>
        <span class="s0">hot._disposeCallback = callback;</span>
      <span class="s0">},</span>
    <span class="s0">};</span>
    <span class="s0">return hot;</span>
  <span class="s0">};</span>

  <span class="s0">let reactRefreshTimeout: null | TimeoutID = null;</span>

  <span class="s0">const metroHotUpdateModule = function (</span>
    <span class="s0">id: ModuleID,</span>
    <span class="s0">factory: FactoryFn,</span>
    <span class="s0">dependencyMap: DependencyMap,</span>
    <span class="s0">inverseDependencies: InverseDependencyMap,</span>
  <span class="s0">) {</span>
    <span class="s0">const mod = modules[id];</span>
    <span class="s0">if (!mod) {</span>
      <span class="s0">if (factory) {</span>
        <span class="s0">// New modules are going to be handled by the define() method.</span>
        <span class="s0">return;</span>
      <span class="s0">}</span>
      <span class="s0">throw unknownModuleError(id);</span>
    <span class="s0">}</span>

    <span class="s0">if (!mod.hasError &amp;&amp; !mod.isInitialized) {</span>
      <span class="s0">// The module hasn't actually been executed yet,</span>
      <span class="s0">// so we can always safely replace it.</span>
      <span class="s0">mod.factory = factory;</span>
      <span class="s0">mod.dependencyMap = dependencyMap;</span>
      <span class="s0">return;</span>
    <span class="s0">}</span>

    <span class="s0">const Refresh = requireRefresh();</span>
    <span class="s0">const refreshBoundaryIDs = new Set&lt;ModuleID&gt;();</span>

    <span class="s0">// In this loop, we will traverse the dependency tree upwards from the</span>
    <span class="s0">// changed module. Updates &quot;bubble&quot; up to the closest accepted parent.</span>
    <span class="s0">//</span>
    <span class="s0">// If we reach the module root and nothing along the way accepted the update,</span>
    <span class="s0">// we know hot reload is going to fail. In that case we return false.</span>
    <span class="s0">//</span>
    <span class="s0">// The main purpose of this loop is to figure out whether it's safe to apply</span>
    <span class="s0">// a hot update. It is only safe when the update was accepted somewhere</span>
    <span class="s0">// along the way upwards for each of its parent dependency module chains.</span>
    <span class="s0">//</span>
    <span class="s0">// We perform a topological sort because we may discover the same</span>
    <span class="s0">// module more than once in the list of things to re-execute, and</span>
    <span class="s0">// we want to execute modules before modules that depend on them.</span>
    <span class="s0">//</span>
    <span class="s0">// If we didn't have this check, we'd risk re-evaluating modules that</span>
    <span class="s0">// have side effects and lead to confusing and meaningless crashes.</span>

    <span class="s0">let didBailOut = false;</span>
    <span class="s0">let updatedModuleIDs;</span>
    <span class="s0">try {</span>
      <span class="s0">updatedModuleIDs = topologicalSort(</span>
        <span class="s0">[id], // Start with the changed module and go upwards</span>
        <span class="s0">pendingID =&gt; {</span>
          <span class="s0">const pendingModule = modules[pendingID];</span>
          <span class="s0">if (pendingModule == null) {</span>
            <span class="s0">// Nothing to do.</span>
            <span class="s0">return [];</span>
          <span class="s0">}</span>
          <span class="s0">const pendingHot = pendingModule.hot;</span>
          <span class="s0">if (pendingHot == null) {</span>
            <span class="s0">throw new Error(</span>
              <span class="s0">'[Refresh] Expected module.hot to always exist in DEV.',</span>
            <span class="s0">);</span>
          <span class="s0">}</span>
          <span class="s0">// A module can be accepted manually from within itself.</span>
          <span class="s0">let canAccept = pendingHot._didAccept;</span>
          <span class="s0">if (!canAccept &amp;&amp; Refresh != null) {</span>
            <span class="s0">// Or React Refresh may mark it accepted based on exports.</span>
            <span class="s0">const isBoundary = isReactRefreshBoundary(</span>
              <span class="s0">Refresh,</span>
              <span class="s0">pendingModule.publicModule.exports,</span>
            <span class="s0">);</span>
            <span class="s0">if (isBoundary) {</span>
              <span class="s0">canAccept = true;</span>
              <span class="s0">refreshBoundaryIDs.add(pendingID);</span>
            <span class="s0">}</span>
          <span class="s0">}</span>
          <span class="s0">if (canAccept) {</span>
            <span class="s0">// Don't look at parents.</span>
            <span class="s0">return [];</span>
          <span class="s0">}</span>
          <span class="s0">// If we bubble through the roof, there is no way to do a hot update.</span>
          <span class="s0">// Bail out altogether. This is the failure case.</span>
          <span class="s0">const parentIDs = inverseDependencies[pendingID];</span>
          <span class="s0">if (parentIDs.length === 0) {</span>
            <span class="s0">// Reload the app because the hot reload can't succeed.</span>
            <span class="s0">// This should work both on web and React Native.</span>
            <span class="s0">performFullRefresh('No root boundary', {</span>
              <span class="s0">source: mod,</span>
              <span class="s0">failed: pendingModule,</span>
            <span class="s0">});</span>
            <span class="s0">didBailOut = true;</span>
            <span class="s0">return [];</span>
          <span class="s0">}</span>
          <span class="s0">// This module can't handle the update but maybe all its parents can?</span>
          <span class="s0">// Put them all in the queue to run the same set of checks.</span>
          <span class="s0">return parentIDs;</span>
        <span class="s0">},</span>
        <span class="s0">() =&gt; didBailOut, // Should we stop?</span>
      <span class="s0">).reverse();</span>
    <span class="s0">} catch (e) {</span>
      <span class="s0">if (e === CYCLE_DETECTED) {</span>
        <span class="s0">performFullRefresh('Dependency cycle', {</span>
          <span class="s0">source: mod,</span>
        <span class="s0">});</span>
        <span class="s0">return;</span>
      <span class="s0">}</span>
      <span class="s0">throw e;</span>
    <span class="s0">}</span>

    <span class="s0">if (didBailOut) {</span>
      <span class="s0">return;</span>
    <span class="s0">}</span>

    <span class="s0">// If we reached here, it is likely that hot reload will be successful.</span>
    <span class="s0">// Run the actual factories.</span>
    <span class="s0">const seenModuleIDs = new Set&lt;ModuleID&gt;();</span>
    <span class="s0">for (let i = 0; i &lt; updatedModuleIDs.length; i++) {</span>
      <span class="s0">const updatedID = updatedModuleIDs[i];</span>
      <span class="s0">if (seenModuleIDs.has(updatedID)) {</span>
        <span class="s0">continue;</span>
      <span class="s0">}</span>
      <span class="s0">seenModuleIDs.add(updatedID);</span>

      <span class="s0">const updatedMod = modules[updatedID];</span>
      <span class="s0">if (updatedMod == null) {</span>
        <span class="s0">throw new Error('[Refresh] Expected to find the updated module.');</span>
      <span class="s0">}</span>
      <span class="s0">const prevExports = updatedMod.publicModule.exports;</span>
      <span class="s0">const didError = runUpdatedModule(</span>
        <span class="s0">updatedID,</span>
        <span class="s0">updatedID === id ? factory : undefined,</span>
        <span class="s0">updatedID === id ? dependencyMap : undefined,</span>
      <span class="s0">);</span>
      <span class="s0">const nextExports = updatedMod.publicModule.exports;</span>

      <span class="s0">if (didError) {</span>
        <span class="s0">// The user was shown a redbox about module initialization.</span>
        <span class="s0">// There's nothing for us to do here until it's fixed.</span>
        <span class="s0">return;</span>
      <span class="s0">}</span>

      <span class="s0">if (refreshBoundaryIDs.has(updatedID)) {</span>
        <span class="s0">// Since we just executed the code for it, it's possible</span>
        <span class="s0">// that the new exports make it ineligible for being a boundary.</span>
        <span class="s0">const isNoLongerABoundary = !isReactRefreshBoundary(</span>
          <span class="s0">Refresh,</span>
          <span class="s0">nextExports,</span>
        <span class="s0">);</span>
        <span class="s0">// It can also become ineligible if its exports are incompatible</span>
        <span class="s0">// with the previous exports.</span>
        <span class="s0">// For example, if you add/remove/change exports, we'll want</span>
        <span class="s0">// to re-execute the importing modules, and force those components</span>
        <span class="s0">// to re-render. Similarly, if you convert a class component</span>
        <span class="s0">// to a function, we want to invalidate the boundary.</span>
        <span class="s0">const didInvalidate = shouldInvalidateReactRefreshBoundary(</span>
          <span class="s0">Refresh,</span>
          <span class="s0">prevExports,</span>
          <span class="s0">nextExports,</span>
        <span class="s0">);</span>
        <span class="s0">if (isNoLongerABoundary || didInvalidate) {</span>
          <span class="s0">// We'll be conservative. The only case in which we won't do a full</span>
          <span class="s0">// reload is if all parent modules are also refresh boundaries.</span>
          <span class="s0">// In that case we'll add them to the current queue.</span>
          <span class="s0">const parentIDs = inverseDependencies[updatedID];</span>
          <span class="s0">if (parentIDs.length === 0) {</span>
            <span class="s0">// Looks like we bubbled to the root. Can't recover from that.</span>
            <span class="s0">performFullRefresh(</span>
              <span class="s0">isNoLongerABoundary</span>
                <span class="s0">? 'No longer a boundary'</span>
                <span class="s0">: 'Invalidated boundary',</span>
              <span class="s0">{</span>
                <span class="s0">source: mod,</span>
                <span class="s0">failed: updatedMod,</span>
              <span class="s0">},</span>
            <span class="s0">);</span>
            <span class="s0">return;</span>
          <span class="s0">}</span>
          <span class="s0">// Schedule all parent refresh boundaries to re-run in this loop.</span>
          <span class="s0">for (let j = 0; j &lt; parentIDs.length; j++) {</span>
            <span class="s0">const parentID = parentIDs[j];</span>
            <span class="s0">const parentMod = modules[parentID];</span>
            <span class="s0">if (parentMod == null) {</span>
              <span class="s0">throw new Error('[Refresh] Expected to find parent module.');</span>
            <span class="s0">}</span>
            <span class="s0">const canAcceptParent = isReactRefreshBoundary(</span>
              <span class="s0">Refresh,</span>
              <span class="s0">parentMod.publicModule.exports,</span>
            <span class="s0">);</span>
            <span class="s0">if (canAcceptParent) {</span>
              <span class="s0">// All parents will have to re-run too.</span>
              <span class="s0">refreshBoundaryIDs.add(parentID);</span>
              <span class="s0">updatedModuleIDs.push(parentID);</span>
            <span class="s0">} else {</span>
              <span class="s0">performFullRefresh('Invalidated boundary', {</span>
                <span class="s0">source: mod,</span>
                <span class="s0">failed: parentMod,</span>
              <span class="s0">});</span>
              <span class="s0">return;</span>
            <span class="s0">}</span>
          <span class="s0">}</span>
        <span class="s0">}</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s0">if (Refresh != null) {</span>
      <span class="s0">// Debounce a little in case there are multiple updates queued up.</span>
      <span class="s0">// This is also useful because __accept may be called multiple times.</span>
      <span class="s0">if (reactRefreshTimeout == null) {</span>
        <span class="s0">reactRefreshTimeout = setTimeout(() =&gt; {</span>
          <span class="s0">reactRefreshTimeout = null;</span>
          <span class="s0">// Update React components.</span>
          <span class="s0">Refresh.performReactRefresh();</span>
        <span class="s0">}, 30);</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
  <span class="s0">};</span>

  <span class="s0">const topologicalSort = function &lt;T&gt;(</span>
    <span class="s0">roots: Array&lt;T&gt;,</span>
    <span class="s0">getEdges: T =&gt; Array&lt;T&gt;,</span>
    <span class="s0">earlyStop: T =&gt; boolean,</span>
  <span class="s0">): Array&lt;T&gt; {</span>
    <span class="s0">const result = [];</span>
    <span class="s0">const visited = new Set&lt;mixed&gt;();</span>
    <span class="s0">const stack = new Set&lt;mixed&gt;();</span>
    <span class="s0">function traverseDependentNodes(node: T): void {</span>
      <span class="s0">if (stack.has(node)) {</span>
        <span class="s0">throw CYCLE_DETECTED;</span>
      <span class="s0">}</span>
      <span class="s0">if (visited.has(node)) {</span>
        <span class="s0">return;</span>
      <span class="s0">}</span>
      <span class="s0">visited.add(node);</span>
      <span class="s0">stack.add(node);</span>
      <span class="s0">const dependentNodes = getEdges(node);</span>
      <span class="s0">if (earlyStop(node)) {</span>
        <span class="s0">stack.delete(node);</span>
        <span class="s0">return;</span>
      <span class="s0">}</span>
      <span class="s0">dependentNodes.forEach(dependent =&gt; {</span>
        <span class="s0">traverseDependentNodes(dependent);</span>
      <span class="s0">});</span>
      <span class="s0">stack.delete(node);</span>
      <span class="s0">result.push(node);</span>
    <span class="s0">}</span>
    <span class="s0">roots.forEach(root =&gt; {</span>
      <span class="s0">traverseDependentNodes(root);</span>
    <span class="s0">});</span>
    <span class="s0">return result;</span>
  <span class="s0">};</span>

  <span class="s0">const runUpdatedModule = function (</span>
    <span class="s0">id: ModuleID,</span>
    <span class="s0">factory?: FactoryFn,</span>
    <span class="s0">dependencyMap?: DependencyMap,</span>
  <span class="s0">): boolean {</span>
    <span class="s0">const mod = modules[id];</span>
    <span class="s0">if (mod == null) {</span>
      <span class="s0">throw new Error('[Refresh] Expected to find the module.');</span>
    <span class="s0">}</span>

    <span class="s0">const {hot} = mod;</span>
    <span class="s0">if (!hot) {</span>
      <span class="s0">throw new Error('[Refresh] Expected module.hot to always exist in DEV.');</span>
    <span class="s0">}</span>

    <span class="s0">if (hot._disposeCallback) {</span>
      <span class="s0">try {</span>
        <span class="s0">hot._disposeCallback();</span>
      <span class="s0">} catch (error) {</span>
        <span class="s0">console.error(</span>
          <span class="s0">`Error while calling dispose handler for module ${id}: `,</span>
          <span class="s0">error,</span>
        <span class="s0">);</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s0">if (factory) {</span>
      <span class="s0">mod.factory = factory;</span>
    <span class="s0">}</span>
    <span class="s0">if (dependencyMap) {</span>
      <span class="s0">mod.dependencyMap = dependencyMap;</span>
    <span class="s0">}</span>
    <span class="s0">mod.hasError = false;</span>
    <span class="s0">mod.error = undefined;</span>
    <span class="s0">mod.importedAll = EMPTY;</span>
    <span class="s0">mod.importedDefault = EMPTY;</span>
    <span class="s0">mod.isInitialized = false;</span>
    <span class="s0">const prevExports = mod.publicModule.exports;</span>
    <span class="s0">mod.publicModule.exports = {};</span>
    <span class="s0">hot._didAccept = false;</span>
    <span class="s0">hot._acceptCallback = null;</span>
    <span class="s0">hot._disposeCallback = null;</span>
    <span class="s0">metroRequire(id);</span>

    <span class="s0">if (mod.hasError) {</span>
      <span class="s0">// This error has already been reported via a redbox.</span>
      <span class="s0">// We know it's likely a typo or some mistake that was just introduced.</span>
      <span class="s0">// Our goal now is to keep the rest of the application working so that by</span>
      <span class="s0">// the time user fixes the error, the app isn't completely destroyed</span>
      <span class="s0">// underneath the redbox. So we'll revert the module object to the last</span>
      <span class="s0">// successful export and stop propagating this update.</span>
      <span class="s0">mod.hasError = false;</span>
      <span class="s0">mod.isInitialized = true;</span>
      <span class="s0">mod.error = null;</span>
      <span class="s0">mod.publicModule.exports = prevExports;</span>
      <span class="s0">// We errored. Stop the update.</span>
      <span class="s0">return true;</span>
    <span class="s0">}</span>

    <span class="s0">if (hot._acceptCallback) {</span>
      <span class="s0">try {</span>
        <span class="s0">hot._acceptCallback();</span>
      <span class="s0">} catch (error) {</span>
        <span class="s0">console.error(</span>
          <span class="s0">`Error while calling accept handler for module ${id}: `,</span>
          <span class="s0">error,</span>
        <span class="s0">);</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">// No error.</span>
    <span class="s0">return false;</span>
  <span class="s0">};</span>

  <span class="s0">const performFullRefresh = (</span>
    <span class="s0">reason: string,</span>
    <span class="s0">modules: $ReadOnly&lt;{</span>
      <span class="s0">source?: ModuleDefinition,</span>
      <span class="s0">failed?: ModuleDefinition,</span>
    <span class="s0">}&gt;,</span>
  <span class="s0">) =&gt; {</span>
    <span class="s0">/* global window */</span>
    <span class="s0">if (</span>
      <span class="s0">typeof window !== 'undefined' &amp;&amp;</span>
      <span class="s0">window.location != null &amp;&amp;</span>
      <span class="s0">typeof window.location.reload === 'function'</span>
    <span class="s0">) {</span>
      <span class="s0">window.location.reload();</span>
    <span class="s0">} else {</span>
      <span class="s0">const Refresh = requireRefresh();</span>
      <span class="s0">if (Refresh != null) {</span>
        <span class="s0">const sourceName = modules.source?.verboseName ?? 'unknown';</span>
        <span class="s0">const failedName = modules.failed?.verboseName ?? 'unknown';</span>
        <span class="s0">Refresh.performFullRefresh(</span>
          <span class="s0">`Fast Refresh - ${reason} &lt;${sourceName}&gt; &lt;${failedName}&gt;`,</span>
        <span class="s0">);</span>
      <span class="s0">} else {</span>
        <span class="s0">console.warn('Could not reload the application after an edit.');</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
  <span class="s0">};</span>

  <span class="s0">// Modules that only export components become React Refresh boundaries.</span>
  <span class="s0">var isReactRefreshBoundary = function (</span>
    <span class="s0">Refresh: any,</span>
    <span class="s0">moduleExports: Exports,</span>
  <span class="s0">): boolean {</span>
    <span class="s0">if (Refresh.isLikelyComponentType(moduleExports)) {</span>
      <span class="s0">return true;</span>
    <span class="s0">}</span>
    <span class="s0">if (moduleExports == null || typeof moduleExports !== 'object') {</span>
      <span class="s0">// Exit if we can't iterate over exports.</span>
      <span class="s0">return false;</span>
    <span class="s0">}</span>
    <span class="s0">let hasExports = false;</span>
    <span class="s0">let areAllExportsComponents = true;</span>
    <span class="s0">for (const key in moduleExports) {</span>
      <span class="s0">hasExports = true;</span>
      <span class="s0">if (key === '__esModule') {</span>
        <span class="s0">continue;</span>
      <span class="s0">}</span>
      <span class="s0">const desc = Object.getOwnPropertyDescriptor&lt;any&gt;(moduleExports, key);</span>
      <span class="s0">if (desc &amp;&amp; desc.get) {</span>
        <span class="s0">// Don't invoke getters as they may have side effects.</span>
        <span class="s0">return false;</span>
      <span class="s0">}</span>
      <span class="s0">const exportValue = moduleExports[key];</span>
      <span class="s0">if (!Refresh.isLikelyComponentType(exportValue)) {</span>
        <span class="s0">areAllExportsComponents = false;</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">return hasExports &amp;&amp; areAllExportsComponents;</span>
  <span class="s0">};</span>

  <span class="s0">var shouldInvalidateReactRefreshBoundary = (</span>
    <span class="s0">Refresh: any,</span>
    <span class="s0">prevExports: Exports,</span>
    <span class="s0">nextExports: Exports,</span>
  <span class="s0">) =&gt; {</span>
    <span class="s0">const prevSignature = getRefreshBoundarySignature(Refresh, prevExports);</span>
    <span class="s0">const nextSignature = getRefreshBoundarySignature(Refresh, nextExports);</span>
    <span class="s0">if (prevSignature.length !== nextSignature.length) {</span>
      <span class="s0">return true;</span>
    <span class="s0">}</span>
    <span class="s0">for (let i = 0; i &lt; nextSignature.length; i++) {</span>
      <span class="s0">if (prevSignature[i] !== nextSignature[i]) {</span>
        <span class="s0">return true;</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">return false;</span>
  <span class="s0">};</span>

  <span class="s0">// When this signature changes, it's unsafe to stop at this refresh boundary.</span>
  <span class="s0">var getRefreshBoundarySignature = (</span>
    <span class="s0">Refresh: any,</span>
    <span class="s0">moduleExports: Exports,</span>
  <span class="s0">): Array&lt;mixed&gt; =&gt; {</span>
    <span class="s0">const signature = [];</span>
    <span class="s0">signature.push(Refresh.getFamilyByType(moduleExports));</span>
    <span class="s0">if (moduleExports == null || typeof moduleExports !== 'object') {</span>
      <span class="s0">// Exit if we can't iterate over exports.</span>
      <span class="s0">// (This is important for legacy environments.)</span>
      <span class="s0">return signature;</span>
    <span class="s0">}</span>
    <span class="s0">for (const key in moduleExports) {</span>
      <span class="s0">if (key === '__esModule') {</span>
        <span class="s0">continue;</span>
      <span class="s0">}</span>
      <span class="s0">const desc = Object.getOwnPropertyDescriptor&lt;any&gt;(moduleExports, key);</span>
      <span class="s0">if (desc &amp;&amp; desc.get) {</span>
        <span class="s0">continue;</span>
      <span class="s0">}</span>
      <span class="s0">const exportValue = moduleExports[key];</span>
      <span class="s0">signature.push(key);</span>
      <span class="s0">signature.push(Refresh.getFamilyByType(exportValue));</span>
    <span class="s0">}</span>
    <span class="s0">return signature;</span>
  <span class="s0">};</span>

  <span class="s0">var registerExportsForReactRefresh = (</span>
    <span class="s0">Refresh: any,</span>
    <span class="s0">moduleExports: Exports,</span>
    <span class="s0">moduleID: ModuleID,</span>
  <span class="s0">) =&gt; {</span>
    <span class="s0">Refresh.register(moduleExports, moduleID + ' %exports%');</span>
    <span class="s0">if (moduleExports == null || typeof moduleExports !== 'object') {</span>
      <span class="s0">// Exit if we can't iterate over exports.</span>
      <span class="s0">// (This is important for legacy environments.)</span>
      <span class="s0">return;</span>
    <span class="s0">}</span>
    <span class="s0">for (const key in moduleExports) {</span>
      <span class="s0">const desc = Object.getOwnPropertyDescriptor&lt;any&gt;(moduleExports, key);</span>
      <span class="s0">if (desc &amp;&amp; desc.get) {</span>
        <span class="s0">// Don't invoke getters as they may have side effects.</span>
        <span class="s0">continue;</span>
      <span class="s0">}</span>
      <span class="s0">const exportValue = moduleExports[key];</span>
      <span class="s0">const typeID = moduleID + ' %exports% ' + key;</span>
      <span class="s0">Refresh.register(exportValue, typeID);</span>
    <span class="s0">}</span>
  <span class="s0">};</span>

  <span class="s0">global.__accept = metroHotUpdateModule;</span>
<span class="s0">}</span>

<span class="s0">if (__DEV__) {</span>
  <span class="s0">// The metro require polyfill can not have module dependencies.</span>
  <span class="s0">// The Systrace and ReactRefresh dependencies are, therefore, made publicly</span>
  <span class="s0">// available. Ideally, the dependency would be inversed in a way that</span>
  <span class="s0">// Systrace / ReactRefresh could integrate into Metro rather than</span>
  <span class="s0">// having to make them publicly available.</span>

  <span class="s0">var requireSystrace = function requireSystrace() {</span>
    <span class="s0">return (</span>
      <span class="s0">// $FlowFixMe[prop-missing]</span>
      <span class="s0">global[__METRO_GLOBAL_PREFIX__ + '__SYSTRACE'] || metroRequire.Systrace</span>
    <span class="s0">);</span>
  <span class="s0">};</span>

  <span class="s0">var requireRefresh = function requireRefresh() {</span>
    <span class="s0">return (</span>
      <span class="s0">// $FlowFixMe[prop-missing]</span>
      <span class="s0">global[__METRO_GLOBAL_PREFIX__ + '__ReactRefresh'] || metroRequire.Refresh</span>
    <span class="s0">);</span>
  <span class="s0">};</span>
<span class="s0">}</span>
</pre>
</body>
</html>
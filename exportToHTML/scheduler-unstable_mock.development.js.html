<html>
<head>
<title>scheduler-unstable_mock.development.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
scheduler-unstable_mock.development.js</font>
</center></td></tr></table>
<pre><span class="s0">/** 
 * @license React 
 * scheduler-unstable_mock.development.js 
 * 
 * Copyright (c) Facebook, Inc. and its affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>
<span class="s1">(</span><span class="s2">function </span><span class="s1">(global, factory) {</span>
  <span class="s2">typeof </span><span class="s1">exports === </span><span class="s3">'object' </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">module !== </span><span class="s3">'undefined' </span><span class="s1">? factory(exports) :</span>
  <span class="s2">typeof </span><span class="s1">define === </span><span class="s3">'function' </span><span class="s1">&amp;&amp; define.amd ? define([</span><span class="s3">'exports'</span><span class="s1">], factory) :</span>
  <span class="s1">(global = global || self, factory(global.SchedulerMock = {}));</span>
<span class="s1">}(</span><span class="s2">this</span><span class="s1">, (</span><span class="s2">function </span><span class="s1">(exports) { </span><span class="s3">'use strict'</span><span class="s1">;</span>

  <span class="s2">var </span><span class="s1">enableSchedulerDebugging = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">enableProfiling = </span><span class="s2">false</span><span class="s1">;</span>

  <span class="s2">function </span><span class="s1">push(heap, node) {</span>
    <span class="s2">var </span><span class="s1">index = heap.length;</span>
    <span class="s1">heap.push(node);</span>
    <span class="s1">siftUp(heap, node, index);</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">peek(heap) {</span>
    <span class="s2">return </span><span class="s1">heap.length === </span><span class="s4">0 </span><span class="s1">? </span><span class="s2">null </span><span class="s1">: heap[</span><span class="s4">0</span><span class="s1">];</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">pop(heap) {</span>
    <span class="s2">if </span><span class="s1">(heap.length === </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">first = heap[</span><span class="s4">0</span><span class="s1">];</span>
    <span class="s2">var </span><span class="s1">last = heap.pop();</span>

    <span class="s2">if </span><span class="s1">(last !== first) {</span>
      <span class="s1">heap[</span><span class="s4">0</span><span class="s1">] = last;</span>
      <span class="s1">siftDown(heap, last, </span><span class="s4">0</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">first;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">siftUp(heap, node, i) {</span>
    <span class="s2">var </span><span class="s1">index = i;</span>

    <span class="s2">while </span><span class="s1">(index &gt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">parentIndex = index - </span><span class="s4">1 </span><span class="s1">&gt;&gt;&gt; </span><span class="s4">1</span><span class="s1">;</span>
      <span class="s2">var </span><span class="s1">parent = heap[parentIndex];</span>

      <span class="s2">if </span><span class="s1">(compare(parent, node) &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s0">// The parent is larger. Swap positions.</span>
        <span class="s1">heap[parentIndex] = node;</span>
        <span class="s1">heap[index] = parent;</span>
        <span class="s1">index = parentIndex;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s0">// The parent is smaller. Exit.</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">siftDown(heap, node, i) {</span>
    <span class="s2">var </span><span class="s1">index = i;</span>
    <span class="s2">var </span><span class="s1">length = heap.length;</span>
    <span class="s2">var </span><span class="s1">halfLength = length &gt;&gt;&gt; </span><span class="s4">1</span><span class="s1">;</span>

    <span class="s2">while </span><span class="s1">(index &lt; halfLength) {</span>
      <span class="s2">var </span><span class="s1">leftIndex = (index + </span><span class="s4">1</span><span class="s1">) * </span><span class="s4">2 </span><span class="s1">- </span><span class="s4">1</span><span class="s1">;</span>
      <span class="s2">var </span><span class="s1">left = heap[leftIndex];</span>
      <span class="s2">var </span><span class="s1">rightIndex = leftIndex + </span><span class="s4">1</span><span class="s1">;</span>
      <span class="s2">var </span><span class="s1">right = heap[rightIndex]; </span><span class="s0">// If the left or right node is smaller, swap with the smaller of those.</span>

      <span class="s2">if </span><span class="s1">(compare(left, node) &lt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(rightIndex &lt; length &amp;&amp; compare(right, left) &lt; </span><span class="s4">0</span><span class="s1">) {</span>
          <span class="s1">heap[index] = right;</span>
          <span class="s1">heap[rightIndex] = node;</span>
          <span class="s1">index = rightIndex;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">heap[index] = left;</span>
          <span class="s1">heap[leftIndex] = node;</span>
          <span class="s1">index = leftIndex;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(rightIndex &lt; length &amp;&amp; compare(right, node) &lt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">heap[index] = right;</span>
        <span class="s1">heap[rightIndex] = node;</span>
        <span class="s1">index = rightIndex;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s0">// Neither child is smaller. Exit.</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">compare(a, b) {</span>
    <span class="s0">// Compare sort index first, then task id.</span>
    <span class="s2">var </span><span class="s1">diff = a.sortIndex - b.sortIndex;</span>
    <span class="s2">return </span><span class="s1">diff !== </span><span class="s4">0 </span><span class="s1">? diff : a.id - b.id;</span>
  <span class="s1">}</span>

  <span class="s0">// TODO: Use symbols?</span>
  <span class="s2">var </span><span class="s1">ImmediatePriority = </span><span class="s4">1</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">UserBlockingPriority = </span><span class="s4">2</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">NormalPriority = </span><span class="s4">3</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">LowPriority = </span><span class="s4">4</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">IdlePriority = </span><span class="s4">5</span><span class="s1">;</span>

  <span class="s2">function </span><span class="s1">markTaskErrored(task, ms) {</span>
  <span class="s1">}</span>

  <span class="s0">/* eslint-disable no-var */</span>
  <span class="s0">// Math.pow(2, 30) - 1</span>
  <span class="s0">// 0b111111111111111111111111111111</span>

  <span class="s2">var </span><span class="s1">maxSigned31BitInt = </span><span class="s4">1073741823</span><span class="s1">; </span><span class="s0">// Times out immediately</span>

  <span class="s2">var </span><span class="s1">IMMEDIATE_PRIORITY_TIMEOUT = -</span><span class="s4">1</span><span class="s1">; </span><span class="s0">// Eventually times out</span>

  <span class="s2">var </span><span class="s1">USER_BLOCKING_PRIORITY_TIMEOUT = </span><span class="s4">250</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">NORMAL_PRIORITY_TIMEOUT = </span><span class="s4">5000</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">LOW_PRIORITY_TIMEOUT = </span><span class="s4">10000</span><span class="s1">; </span><span class="s0">// Never times out</span>

  <span class="s2">var </span><span class="s1">IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt; </span><span class="s0">// Tasks are stored on a min heap</span>

  <span class="s2">var </span><span class="s1">taskQueue = [];</span>
  <span class="s2">var </span><span class="s1">timerQueue = []; </span><span class="s0">// Incrementing id counter. Used to maintain insertion order.</span>

  <span class="s2">var </span><span class="s1">taskIdCounter = </span><span class="s4">1</span><span class="s1">; </span><span class="s0">// Pausing the scheduler is useful for debugging.</span>
  <span class="s2">var </span><span class="s1">currentTask = </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">currentPriorityLevel = NormalPriority; </span><span class="s0">// This is set while performing work, to prevent re-entrance.</span>

  <span class="s2">var </span><span class="s1">isPerformingWork = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">isHostCallbackScheduled = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">isHostTimeoutScheduled = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">currentMockTime = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">scheduledCallback = </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">scheduledTimeout = </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">timeoutTime = -</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">yieldedValues = </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">expectedNumberOfYields = -</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">didStop = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">isFlushing = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">needsPaint = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">shouldYieldForPaint = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">disableYieldValue = </span><span class="s2">false</span><span class="s1">;</span>

  <span class="s2">function </span><span class="s1">setDisableYieldValue(newValue) {</span>
    <span class="s1">disableYieldValue = newValue;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">advanceTimers(currentTime) {</span>
    <span class="s0">// Check for tasks that are no longer delayed and add them to the queue.</span>
    <span class="s2">var </span><span class="s1">timer = peek(timerQueue);</span>

    <span class="s2">while </span><span class="s1">(timer !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(timer.callback === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s0">// Timer was cancelled.</span>
        <span class="s1">pop(timerQueue);</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(timer.startTime &lt;= currentTime) {</span>
        <span class="s0">// Timer fired. Transfer to the task queue.</span>
        <span class="s1">pop(timerQueue);</span>
        <span class="s1">timer.sortIndex = timer.expirationTime;</span>
        <span class="s1">push(taskQueue, timer);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s0">// Remaining timers are pending.</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">timer = peek(timerQueue);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">handleTimeout(currentTime) {</span>
    <span class="s1">isHostTimeoutScheduled = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">advanceTimers(currentTime);</span>

    <span class="s2">if </span><span class="s1">(!isHostCallbackScheduled) {</span>
      <span class="s2">if </span><span class="s1">(peek(taskQueue) !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">isHostCallbackScheduled = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">requestHostCallback(flushWork);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">var </span><span class="s1">firstTimer = peek(timerQueue);</span>

        <span class="s2">if </span><span class="s1">(firstTimer !== </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">flushWork(hasTimeRemaining, initialTime) {</span>


    <span class="s1">isHostCallbackScheduled = </span><span class="s2">false</span><span class="s1">;</span>

    <span class="s2">if </span><span class="s1">(isHostTimeoutScheduled) {</span>
      <span class="s0">// We scheduled a timeout but it's no longer needed. Cancel it.</span>
      <span class="s1">isHostTimeoutScheduled = </span><span class="s2">false</span><span class="s1">;</span>
      <span class="s1">cancelHostTimeout();</span>
    <span class="s1">}</span>

    <span class="s1">isPerformingWork = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s2">var </span><span class="s1">previousPriorityLevel = currentPriorityLevel;</span>

    <span class="s2">try </span><span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(enableProfiling) {</span>
        <span class="s2">try </span><span class="s1">{</span>
          <span class="s2">return </span><span class="s1">workLoop(hasTimeRemaining, initialTime);</span>
        <span class="s1">} </span><span class="s2">catch </span><span class="s1">(error) {</span>
          <span class="s2">if </span><span class="s1">(currentTask !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">var </span><span class="s1">currentTime = getCurrentTime();</span>
            <span class="s1">markTaskErrored(currentTask, currentTime);</span>
            <span class="s1">currentTask.isQueued = </span><span class="s2">false</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s2">throw </span><span class="s1">error;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s0">// No catch in prod code path.</span>
        <span class="s2">return </span><span class="s1">workLoop(hasTimeRemaining, initialTime);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
      <span class="s1">currentTask = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">currentPriorityLevel = previousPriorityLevel;</span>
      <span class="s1">isPerformingWork = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">workLoop(hasTimeRemaining, initialTime) {</span>
    <span class="s2">var </span><span class="s1">currentTime = initialTime;</span>
    <span class="s1">advanceTimers(currentTime);</span>
    <span class="s1">currentTask = peek(taskQueue);</span>

    <span class="s2">while </span><span class="s1">(currentTask !== </span><span class="s2">null </span><span class="s1">&amp;&amp; !(enableSchedulerDebugging )) {</span>
      <span class="s2">if </span><span class="s1">(currentTask.expirationTime &gt; currentTime &amp;&amp; (!hasTimeRemaining || shouldYieldToHost())) {</span>
        <span class="s0">// This currentTask hasn't expired, and we've reached the deadline.</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">callback = currentTask.callback;</span>

      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">callback === </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s1">currentTask.callback = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s1">currentPriorityLevel = currentTask.priorityLevel;</span>
        <span class="s2">var </span><span class="s1">didUserCallbackTimeout = currentTask.expirationTime &lt;= currentTime;</span>

        <span class="s2">var </span><span class="s1">continuationCallback = callback(didUserCallbackTimeout);</span>
        <span class="s1">currentTime = getCurrentTime();</span>

        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">continuationCallback === </span><span class="s3">'function'</span><span class="s1">) {</span>
          <span class="s1">currentTask.callback = continuationCallback;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>

          <span class="s2">if </span><span class="s1">(currentTask === peek(taskQueue)) {</span>
            <span class="s1">pop(taskQueue);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s1">advanceTimers(currentTime);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">pop(taskQueue);</span>
      <span class="s1">}</span>

      <span class="s1">currentTask = peek(taskQueue);</span>
    <span class="s1">} </span><span class="s0">// Return whether there's additional work</span>


    <span class="s2">if </span><span class="s1">(currentTask !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">var </span><span class="s1">firstTimer = peek(timerQueue);</span>

      <span class="s2">if </span><span class="s1">(firstTimer !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);</span>
      <span class="s1">}</span>

      <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">unstable_runWithPriority(priorityLevel, eventHandler) {</span>
    <span class="s2">switch </span><span class="s1">(priorityLevel) {</span>
      <span class="s2">case </span><span class="s1">ImmediatePriority:</span>
      <span class="s2">case </span><span class="s1">UserBlockingPriority:</span>
      <span class="s2">case </span><span class="s1">NormalPriority:</span>
      <span class="s2">case </span><span class="s1">LowPriority:</span>
      <span class="s2">case </span><span class="s1">IdlePriority:</span>
        <span class="s2">break</span><span class="s1">;</span>

      <span class="s2">default</span><span class="s1">:</span>
        <span class="s1">priorityLevel = NormalPriority;</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">previousPriorityLevel = currentPriorityLevel;</span>
    <span class="s1">currentPriorityLevel = priorityLevel;</span>

    <span class="s2">try </span><span class="s1">{</span>
      <span class="s2">return </span><span class="s1">eventHandler();</span>
    <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
      <span class="s1">currentPriorityLevel = previousPriorityLevel;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">unstable_next(eventHandler) {</span>
    <span class="s2">var </span><span class="s1">priorityLevel;</span>

    <span class="s2">switch </span><span class="s1">(currentPriorityLevel) {</span>
      <span class="s2">case </span><span class="s1">ImmediatePriority:</span>
      <span class="s2">case </span><span class="s1">UserBlockingPriority:</span>
      <span class="s2">case </span><span class="s1">NormalPriority:</span>
        <span class="s0">// Shift down to normal priority</span>
        <span class="s1">priorityLevel = NormalPriority;</span>
        <span class="s2">break</span><span class="s1">;</span>

      <span class="s2">default</span><span class="s1">:</span>
        <span class="s0">// Anything lower than normal priority should remain at the current level.</span>
        <span class="s1">priorityLevel = currentPriorityLevel;</span>
        <span class="s2">break</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">previousPriorityLevel = currentPriorityLevel;</span>
    <span class="s1">currentPriorityLevel = priorityLevel;</span>

    <span class="s2">try </span><span class="s1">{</span>
      <span class="s2">return </span><span class="s1">eventHandler();</span>
    <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
      <span class="s1">currentPriorityLevel = previousPriorityLevel;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">unstable_wrapCallback(callback) {</span>
    <span class="s2">var </span><span class="s1">parentPriorityLevel = currentPriorityLevel;</span>
    <span class="s2">return function </span><span class="s1">() {</span>
      <span class="s0">// This is a fork of runWithPriority, inlined for performance.</span>
      <span class="s2">var </span><span class="s1">previousPriorityLevel = currentPriorityLevel;</span>
      <span class="s1">currentPriorityLevel = parentPriorityLevel;</span>

      <span class="s2">try </span><span class="s1">{</span>
        <span class="s2">return </span><span class="s1">callback.apply(</span><span class="s2">this</span><span class="s1">, arguments);</span>
      <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
        <span class="s1">currentPriorityLevel = previousPriorityLevel;</span>
      <span class="s1">}</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">unstable_scheduleCallback(priorityLevel, callback, options) {</span>
    <span class="s2">var </span><span class="s1">currentTime = getCurrentTime();</span>
    <span class="s2">var </span><span class="s1">startTime;</span>

    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">options === </span><span class="s3">'object' </span><span class="s1">&amp;&amp; options !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">delay = options.delay;</span>

      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">delay === </span><span class="s3">'number' </span><span class="s1">&amp;&amp; delay &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">startTime = currentTime + delay;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">startTime = currentTime;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">startTime = currentTime;</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">timeout;</span>

    <span class="s2">switch </span><span class="s1">(priorityLevel) {</span>
      <span class="s2">case </span><span class="s1">ImmediatePriority:</span>
        <span class="s1">timeout = IMMEDIATE_PRIORITY_TIMEOUT;</span>
        <span class="s2">break</span><span class="s1">;</span>

      <span class="s2">case </span><span class="s1">UserBlockingPriority:</span>
        <span class="s1">timeout = USER_BLOCKING_PRIORITY_TIMEOUT;</span>
        <span class="s2">break</span><span class="s1">;</span>

      <span class="s2">case </span><span class="s1">IdlePriority:</span>
        <span class="s1">timeout = IDLE_PRIORITY_TIMEOUT;</span>
        <span class="s2">break</span><span class="s1">;</span>

      <span class="s2">case </span><span class="s1">LowPriority:</span>
        <span class="s1">timeout = LOW_PRIORITY_TIMEOUT;</span>
        <span class="s2">break</span><span class="s1">;</span>

      <span class="s2">case </span><span class="s1">NormalPriority:</span>
      <span class="s2">default</span><span class="s1">:</span>
        <span class="s1">timeout = NORMAL_PRIORITY_TIMEOUT;</span>
        <span class="s2">break</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">expirationTime = startTime + timeout;</span>
    <span class="s2">var </span><span class="s1">newTask = {</span>
      <span class="s1">id: taskIdCounter++,</span>
      <span class="s1">callback: callback,</span>
      <span class="s1">priorityLevel: priorityLevel,</span>
      <span class="s1">startTime: startTime,</span>
      <span class="s1">expirationTime: expirationTime,</span>
      <span class="s1">sortIndex: -</span><span class="s4">1</span>
    <span class="s1">};</span>

    <span class="s2">if </span><span class="s1">(startTime &gt; currentTime) {</span>
      <span class="s0">// This is a delayed task.</span>
      <span class="s1">newTask.sortIndex = startTime;</span>
      <span class="s1">push(timerQueue, newTask);</span>

      <span class="s2">if </span><span class="s1">(peek(taskQueue) === </span><span class="s2">null </span><span class="s1">&amp;&amp; newTask === peek(timerQueue)) {</span>
        <span class="s0">// All tasks are delayed, and this is the task with the earliest delay.</span>
        <span class="s2">if </span><span class="s1">(isHostTimeoutScheduled) {</span>
          <span class="s0">// Cancel an existing timeout.</span>
          <span class="s1">cancelHostTimeout();</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">isHostTimeoutScheduled = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s0">// Schedule a timeout.</span>


        <span class="s1">requestHostTimeout(handleTimeout, startTime - currentTime);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">newTask.sortIndex = expirationTime;</span>
      <span class="s1">push(taskQueue, newTask);</span>
      <span class="s0">// wait until the next time we yield.</span>


      <span class="s2">if </span><span class="s1">(!isHostCallbackScheduled &amp;&amp; !isPerformingWork) {</span>
        <span class="s1">isHostCallbackScheduled = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">requestHostCallback(flushWork);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">newTask;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">unstable_pauseExecution() {</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">unstable_continueExecution() {</span>

    <span class="s2">if </span><span class="s1">(!isHostCallbackScheduled &amp;&amp; !isPerformingWork) {</span>
      <span class="s1">isHostCallbackScheduled = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s1">requestHostCallback(flushWork);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">unstable_getFirstCallbackNode() {</span>
    <span class="s2">return </span><span class="s1">peek(taskQueue);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">unstable_cancelCallback(task) {</span>
    <span class="s0">// remove from the queue because you can't remove arbitrary nodes from an</span>
    <span class="s0">// array based heap, only the first one.)</span>


    <span class="s1">task.callback = </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">unstable_getCurrentPriorityLevel() {</span>
    <span class="s2">return </span><span class="s1">currentPriorityLevel;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">requestHostCallback(callback) {</span>
    <span class="s1">scheduledCallback = callback;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">requestHostTimeout(callback, ms) {</span>
    <span class="s1">scheduledTimeout = callback;</span>
    <span class="s1">timeoutTime = currentMockTime + ms;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">cancelHostTimeout() {</span>
    <span class="s1">scheduledTimeout = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">timeoutTime = -</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">shouldYieldToHost() {</span>
    <span class="s2">if </span><span class="s1">(expectedNumberOfYields === </span><span class="s4">0 </span><span class="s1">&amp;&amp; yieldedValues === </span><span class="s2">null </span><span class="s1">|| expectedNumberOfYields !== -</span><span class="s4">1 </span><span class="s1">&amp;&amp; yieldedValues !== </span><span class="s2">null </span><span class="s1">&amp;&amp; yieldedValues.length &gt;= expectedNumberOfYields || shouldYieldForPaint &amp;&amp; needsPaint) {</span>
      <span class="s0">// We yielded at least as many values as expected. Stop flushing.</span>
      <span class="s1">didStop = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">return false</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">getCurrentTime() {</span>
    <span class="s2">return </span><span class="s1">currentMockTime;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">forceFrameRate() {</span><span class="s0">// No-op</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">reset() {</span>
    <span class="s2">if </span><span class="s1">(isFlushing) {</span>
      <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Cannot reset while already flushing work.'</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s1">currentMockTime = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">scheduledCallback = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">scheduledTimeout = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">timeoutTime = -</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">yieldedValues = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">expectedNumberOfYields = -</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">didStop = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">isFlushing = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">needsPaint = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s0">// Should only be used via an assertion helper that inspects the yielded values.</span>


  <span class="s2">function </span><span class="s1">unstable_flushNumberOfYields(count) {</span>
    <span class="s2">if </span><span class="s1">(isFlushing) {</span>
      <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Already flushing work.'</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(scheduledCallback !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">cb = scheduledCallback;</span>
      <span class="s1">expectedNumberOfYields = count;</span>
      <span class="s1">isFlushing = </span><span class="s2">true</span><span class="s1">;</span>

      <span class="s2">try </span><span class="s1">{</span>
        <span class="s2">var </span><span class="s1">hasMoreWork = </span><span class="s2">true</span><span class="s1">;</span>

        <span class="s2">do </span><span class="s1">{</span>
          <span class="s1">hasMoreWork = cb(</span><span class="s2">true</span><span class="s1">, currentMockTime);</span>
        <span class="s1">} </span><span class="s2">while </span><span class="s1">(hasMoreWork &amp;&amp; !didStop);</span>

        <span class="s2">if </span><span class="s1">(!hasMoreWork) {</span>
          <span class="s1">scheduledCallback = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
        <span class="s1">expectedNumberOfYields = -</span><span class="s4">1</span><span class="s1">;</span>
        <span class="s1">didStop = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s1">isFlushing = </span><span class="s2">false</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">unstable_flushUntilNextPaint() {</span>
    <span class="s2">if </span><span class="s1">(isFlushing) {</span>
      <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Already flushing work.'</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(scheduledCallback !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">cb = scheduledCallback;</span>
      <span class="s1">shouldYieldForPaint = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s1">needsPaint = </span><span class="s2">false</span><span class="s1">;</span>
      <span class="s1">isFlushing = </span><span class="s2">true</span><span class="s1">;</span>

      <span class="s2">try </span><span class="s1">{</span>
        <span class="s2">var </span><span class="s1">hasMoreWork = </span><span class="s2">true</span><span class="s1">;</span>

        <span class="s2">do </span><span class="s1">{</span>
          <span class="s1">hasMoreWork = cb(</span><span class="s2">true</span><span class="s1">, currentMockTime);</span>
        <span class="s1">} </span><span class="s2">while </span><span class="s1">(hasMoreWork &amp;&amp; !didStop);</span>

        <span class="s2">if </span><span class="s1">(!hasMoreWork) {</span>
          <span class="s1">scheduledCallback = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
        <span class="s1">shouldYieldForPaint = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s1">didStop = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s1">isFlushing = </span><span class="s2">false</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">unstable_flushExpired() {</span>
    <span class="s2">if </span><span class="s1">(isFlushing) {</span>
      <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Already flushing work.'</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(scheduledCallback !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">isFlushing = </span><span class="s2">true</span><span class="s1">;</span>

      <span class="s2">try </span><span class="s1">{</span>
        <span class="s2">var </span><span class="s1">hasMoreWork = scheduledCallback(</span><span class="s2">false</span><span class="s1">, currentMockTime);</span>

        <span class="s2">if </span><span class="s1">(!hasMoreWork) {</span>
          <span class="s1">scheduledCallback = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
        <span class="s1">isFlushing = </span><span class="s2">false</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">unstable_flushAllWithoutAsserting() {</span>
    <span class="s0">// Returns false if no work was flushed.</span>
    <span class="s2">if </span><span class="s1">(isFlushing) {</span>
      <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Already flushing work.'</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(scheduledCallback !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">cb = scheduledCallback;</span>
      <span class="s1">isFlushing = </span><span class="s2">true</span><span class="s1">;</span>

      <span class="s2">try </span><span class="s1">{</span>
        <span class="s2">var </span><span class="s1">hasMoreWork = </span><span class="s2">true</span><span class="s1">;</span>

        <span class="s2">do </span><span class="s1">{</span>
          <span class="s1">hasMoreWork = cb(</span><span class="s2">true</span><span class="s1">, currentMockTime);</span>
        <span class="s1">} </span><span class="s2">while </span><span class="s1">(hasMoreWork);</span>

        <span class="s2">if </span><span class="s1">(!hasMoreWork) {</span>
          <span class="s1">scheduledCallback = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s2">return true</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
        <span class="s1">isFlushing = </span><span class="s2">false</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">unstable_clearYields() {</span>
    <span class="s2">if </span><span class="s1">(yieldedValues === </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">[];</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">values = yieldedValues;</span>
    <span class="s1">yieldedValues = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">return </span><span class="s1">values;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">unstable_flushAll() {</span>
    <span class="s2">if </span><span class="s1">(yieldedValues !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Log is not empty. Assert on the log of yielded values before ' </span><span class="s1">+ </span><span class="s3">'flushing additional work.'</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s1">unstable_flushAllWithoutAsserting();</span>

    <span class="s2">if </span><span class="s1">(yieldedValues !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'While flushing work, something yielded a value. Use an ' </span><span class="s1">+ </span><span class="s3">'assertion helper to assert on the log of yielded values, e.g. ' </span><span class="s1">+ </span><span class="s3">'expect(Scheduler).toFlushAndYield([...])'</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">unstable_yieldValue(value) {</span>
    <span class="s0">// eslint-disable-next-line react-internal/no-production-logging</span>
    <span class="s2">if </span><span class="s1">(console.log.name === </span><span class="s3">'disabledLog' </span><span class="s1">|| disableYieldValue) {</span>
      <span class="s0">// If console.log has been patched, we assume we're in render</span>
      <span class="s0">// replaying and we ignore any values yielding in the second pass.</span>
      <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(yieldedValues === </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">yieldedValues = [value];</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">yieldedValues.push(value);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">unstable_advanceTime(ms) {</span>
    <span class="s0">// eslint-disable-next-line react-internal/no-production-logging</span>
    <span class="s2">if </span><span class="s1">(console.log.name === </span><span class="s3">'disabledLog' </span><span class="s1">|| disableYieldValue) {</span>
      <span class="s0">// If console.log has been patched, we assume we're in render</span>
      <span class="s0">// replaying and we ignore any time advancing in the second pass.</span>
      <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">currentMockTime += ms;</span>

    <span class="s2">if </span><span class="s1">(scheduledTimeout !== </span><span class="s2">null </span><span class="s1">&amp;&amp; timeoutTime &lt;= currentMockTime) {</span>
      <span class="s1">scheduledTimeout(currentMockTime);</span>
      <span class="s1">timeoutTime = -</span><span class="s4">1</span><span class="s1">;</span>
      <span class="s1">scheduledTimeout = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">requestPaint() {</span>
    <span class="s1">needsPaint = </span><span class="s2">true</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">var </span><span class="s1">unstable_Profiling =  </span><span class="s2">null</span><span class="s1">;</span>

  <span class="s1">exports.reset = reset;</span>
  <span class="s1">exports.unstable_IdlePriority = IdlePriority;</span>
  <span class="s1">exports.unstable_ImmediatePriority = ImmediatePriority;</span>
  <span class="s1">exports.unstable_LowPriority = LowPriority;</span>
  <span class="s1">exports.unstable_NormalPriority = NormalPriority;</span>
  <span class="s1">exports.unstable_Profiling = unstable_Profiling;</span>
  <span class="s1">exports.unstable_UserBlockingPriority = UserBlockingPriority;</span>
  <span class="s1">exports.unstable_advanceTime = unstable_advanceTime;</span>
  <span class="s1">exports.unstable_cancelCallback = unstable_cancelCallback;</span>
  <span class="s1">exports.unstable_clearYields = unstable_clearYields;</span>
  <span class="s1">exports.unstable_continueExecution = unstable_continueExecution;</span>
  <span class="s1">exports.unstable_flushAll = unstable_flushAll;</span>
  <span class="s1">exports.unstable_flushAllWithoutAsserting = unstable_flushAllWithoutAsserting;</span>
  <span class="s1">exports.unstable_flushExpired = unstable_flushExpired;</span>
  <span class="s1">exports.unstable_flushNumberOfYields = unstable_flushNumberOfYields;</span>
  <span class="s1">exports.unstable_flushUntilNextPaint = unstable_flushUntilNextPaint;</span>
  <span class="s1">exports.unstable_forceFrameRate = forceFrameRate;</span>
  <span class="s1">exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;</span>
  <span class="s1">exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;</span>
  <span class="s1">exports.unstable_next = unstable_next;</span>
  <span class="s1">exports.unstable_now = getCurrentTime;</span>
  <span class="s1">exports.unstable_pauseExecution = unstable_pauseExecution;</span>
  <span class="s1">exports.unstable_requestPaint = requestPaint;</span>
  <span class="s1">exports.unstable_runWithPriority = unstable_runWithPriority;</span>
  <span class="s1">exports.unstable_scheduleCallback = unstable_scheduleCallback;</span>
  <span class="s1">exports.unstable_setDisableYieldValue = setDisableYieldValue;</span>
  <span class="s1">exports.unstable_shouldYield = shouldYieldToHost;</span>
  <span class="s1">exports.unstable_wrapCallback = unstable_wrapCallback;</span>
  <span class="s1">exports.unstable_yieldValue = unstable_yieldValue;</span>

<span class="s1">})));</span>
</pre>
</body>
</html>
<html>
<head>
<title>GestureDetector.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6a8759;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
.s5 { color: #4646f1;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
GestureDetector.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>

<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
  <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s1">exports.GestureDetector = </span><span class="s2">void </span><span class="s3">0</span><span class="s1">;</span>

<span class="s2">var </span><span class="s1">_react = _interopRequireWildcard(require(</span><span class="s0">&quot;react&quot;</span><span class="s1">));</span>

<span class="s2">var </span><span class="s1">_gesture = require(</span><span class="s0">&quot;./gesture&quot;</span><span class="s1">);</span>

<span class="s2">var </span><span class="s1">_reanimatedWrapper = require(</span><span class="s0">&quot;./reanimatedWrapper&quot;</span><span class="s1">);</span>

<span class="s2">var </span><span class="s1">_handlersRegistry = require(</span><span class="s0">&quot;../handlersRegistry&quot;</span><span class="s1">);</span>

<span class="s2">var </span><span class="s1">_RNGestureHandlerModule = _interopRequireDefault(require(</span><span class="s0">&quot;../../RNGestureHandlerModule&quot;</span><span class="s1">));</span>

<span class="s2">var </span><span class="s1">_gestureHandlerCommon = require(</span><span class="s0">&quot;../gestureHandlerCommon&quot;</span><span class="s1">);</span>

<span class="s2">var </span><span class="s1">_gestureStateManager = require(</span><span class="s0">&quot;./gestureStateManager&quot;</span><span class="s1">);</span>

<span class="s2">var </span><span class="s1">_FlingGestureHandler = require(</span><span class="s0">&quot;../FlingGestureHandler&quot;</span><span class="s1">);</span>

<span class="s2">var </span><span class="s1">_ForceTouchGestureHandler = require(</span><span class="s0">&quot;../ForceTouchGestureHandler&quot;</span><span class="s1">);</span>

<span class="s2">var </span><span class="s1">_LongPressGestureHandler = require(</span><span class="s0">&quot;../LongPressGestureHandler&quot;</span><span class="s1">);</span>

<span class="s2">var </span><span class="s1">_PanGestureHandler = require(</span><span class="s0">&quot;../PanGestureHandler&quot;</span><span class="s1">);</span>

<span class="s2">var </span><span class="s1">_TapGestureHandler = require(</span><span class="s0">&quot;../TapGestureHandler&quot;</span><span class="s1">);</span>

<span class="s2">var </span><span class="s1">_State = require(</span><span class="s0">&quot;../../State&quot;</span><span class="s1">);</span>

<span class="s2">var </span><span class="s1">_TouchEventType = require(</span><span class="s0">&quot;../../TouchEventType&quot;</span><span class="s1">);</span>

<span class="s2">var </span><span class="s1">_ActionType = require(</span><span class="s0">&quot;../../ActionType&quot;</span><span class="s1">);</span>

<span class="s2">var </span><span class="s1">_utils = require(</span><span class="s0">&quot;../../utils&quot;</span><span class="s1">);</span>

<span class="s2">var </span><span class="s1">_getShadowNodeFromRef = require(</span><span class="s0">&quot;../../getShadowNodeFromRef&quot;</span><span class="s1">);</span>

<span class="s2">var </span><span class="s1">_reactNative = require(</span><span class="s0">&quot;react-native&quot;</span><span class="s1">);</span>

<span class="s2">var </span><span class="s1">_eventReceiver = require(</span><span class="s0">&quot;./eventReceiver&quot;</span><span class="s1">);</span>

<span class="s2">var </span><span class="s1">_RNRenderer = require(</span><span class="s0">&quot;../../RNRenderer&quot;</span><span class="s1">);</span>

<span class="s2">var </span><span class="s1">_EnableNewWebImplementation = require(</span><span class="s0">&quot;../../EnableNewWebImplementation&quot;</span><span class="s1">);</span>

<span class="s2">var </span><span class="s1">_NativeViewGestureHandler = require(</span><span class="s0">&quot;../NativeViewGestureHandler&quot;</span><span class="s1">);</span>

<span class="s2">var </span><span class="s1">_GestureHandlerRootViewContext = _interopRequireDefault(require(</span><span class="s0">&quot;../../GestureHandlerRootViewContext&quot;</span><span class="s1">));</span>

<span class="s2">var </span><span class="s1">_Reanimated$default$c, _Reanimated$default;</span>

<span class="s2">function </span><span class="s1">_interopRequireDefault(obj) { </span><span class="s2">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : { </span><span class="s2">default</span><span class="s1">: obj }; }</span>

<span class="s2">function </span><span class="s1">_getRequireWildcardCache() { </span><span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">WeakMap !== </span><span class="s0">&quot;function&quot;</span><span class="s1">) </span><span class="s2">return null</span><span class="s1">; </span><span class="s2">var </span><span class="s1">cache = </span><span class="s2">new </span><span class="s1">WeakMap(); _getRequireWildcardCache = </span><span class="s2">function </span><span class="s1">() { </span><span class="s2">return </span><span class="s1">cache; }; </span><span class="s2">return </span><span class="s1">cache; }</span>

<span class="s2">function </span><span class="s1">_interopRequireWildcard(obj) { </span><span class="s2">if </span><span class="s1">(obj &amp;&amp; obj.__esModule) { </span><span class="s2">return </span><span class="s1">obj; } </span><span class="s2">if </span><span class="s1">(obj === </span><span class="s2">null </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">obj !== </span><span class="s0">&quot;object&quot; </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">obj !== </span><span class="s0">&quot;function&quot;</span><span class="s1">) { </span><span class="s2">return </span><span class="s1">{ </span><span class="s2">default</span><span class="s1">: obj }; } </span><span class="s2">var </span><span class="s1">cache = _getRequireWildcardCache(); </span><span class="s2">if </span><span class="s1">(cache &amp;&amp; cache.has(obj)) { </span><span class="s2">return </span><span class="s1">cache.get(obj); } </span><span class="s2">var </span><span class="s1">newObj = {}; </span><span class="s2">var </span><span class="s1">hasPropertyDescriptor = Object.defineProperty &amp;&amp; Object.getOwnPropertyDescriptor; </span><span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">key </span><span class="s2">in </span><span class="s1">obj) { </span><span class="s2">if </span><span class="s1">(Object.prototype.hasOwnProperty.call(obj, key)) { </span><span class="s2">var </span><span class="s1">desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : </span><span class="s2">null</span><span class="s1">; </span><span class="s2">if </span><span class="s1">(desc &amp;&amp; (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } </span><span class="s2">else </span><span class="s1">{ newObj[key] = obj[key]; } } } newObj.</span><span class="s2">default </span><span class="s1">= obj; </span><span class="s2">if </span><span class="s1">(cache) { cache.set(obj, newObj); } </span><span class="s2">return </span><span class="s1">newObj; }</span>

<span class="s1">const ALLOWED_PROPS = [..._gestureHandlerCommon.baseGestureHandlerWithMonitorProps, ..._TapGestureHandler.tapGestureHandlerProps, ..._PanGestureHandler.panGestureHandlerProps, ..._PanGestureHandler.panGestureHandlerCustomNativeProps, ..._LongPressGestureHandler.longPressGestureHandlerProps, ..._ForceTouchGestureHandler.forceTouchGestureHandlerProps, ..._FlingGestureHandler.flingGestureHandlerProps, ..._NativeViewGestureHandler.nativeViewGestureHandlerProps];</span>

<span class="s2">function </span><span class="s1">convertToHandlerTag(ref) {</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">ref === </span><span class="s0">'number'</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s1">ref;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(ref </span><span class="s2">instanceof </span><span class="s1">_gesture.BaseGesture) {</span>
    <span class="s2">return </span><span class="s1">ref.handlerTag;</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s2">var </span><span class="s1">_ref$current$handlerT, _ref$current;</span>

    <span class="s4">// @ts-ignore in this case it should be a ref either to gesture object or</span>
    <span class="s4">// a gesture handler component, in both cases handlerTag property exists</span>
    <span class="s2">return </span><span class="s1">(_ref$current$handlerT = (_ref$current = ref.current) === </span><span class="s2">null </span><span class="s1">|| _ref$current === </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _ref$current.handlerTag) !== </span><span class="s2">null </span><span class="s1">&amp;&amp; _ref$current$handlerT !== </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? _ref$current$handlerT : -</span><span class="s3">1</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">extractValidHandlerTags(interactionGroup) {</span>
  <span class="s2">var </span><span class="s1">_interactionGroup$map, _interactionGroup$map2;</span>

  <span class="s2">return </span><span class="s1">(_interactionGroup$map = interactionGroup === </span><span class="s2">null </span><span class="s1">|| interactionGroup === </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: (_interactionGroup$map2 = interactionGroup.map(convertToHandlerTag)) === </span><span class="s2">null </span><span class="s1">|| _interactionGroup$map2 === </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _interactionGroup$map2.filter(tag =&gt; tag &gt; </span><span class="s3">0</span><span class="s1">)) !== </span><span class="s2">null </span><span class="s1">&amp;&amp; _interactionGroup$map !== </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? _interactionGroup$map : [];</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">dropHandlers(preparedGesture) {</span>
  <span class="s2">for </span><span class="s1">(const handler of preparedGesture.config) {</span>
    <span class="s1">_RNGestureHandlerModule.</span><span class="s2">default</span><span class="s1">.dropGestureHandler(handler.handlerTag);</span>

    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _handlersRegistry.unregisterHandler)(handler.handlerTag, handler.config.testId);</span>
  <span class="s1">}</span>

  <span class="s1">(</span><span class="s3">0</span><span class="s1">, _gestureHandlerCommon.scheduleFlushOperations)();</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">checkGestureCallbacksForWorklets(gesture) {</span>
  <span class="s4">// if a gesture is explicitly marked to run on the JS thread there is no need to check</span>
  <span class="s4">// if callbacks are worklets as the user is aware they will be ran on the JS thread</span>
  <span class="s2">if </span><span class="s1">(gesture.config.runOnJS) {</span>
    <span class="s2">return</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s1">const areSomeNotWorklets = gesture.handlers.isWorklet.includes(</span><span class="s2">false</span><span class="s1">);</span>
  <span class="s1">const areSomeWorklets = gesture.handlers.isWorklet.includes(</span><span class="s2">true</span><span class="s1">); </span><span class="s4">// if some of the callbacks are worklets and some are not, and the gesture is not</span>
  <span class="s4">// explicitly marked with `.runOnJS(true)` show an error</span>

  <span class="s2">if </span><span class="s1">(areSomeNotWorklets &amp;&amp; areSomeWorklets) {</span>
    <span class="s1">console.error((</span><span class="s3">0</span><span class="s1">, _utils.tagMessage)(`Some of the callbacks </span><span class="s2">in </span><span class="s1">the gesture are worklets and some are not. Either make sure that all calbacks are marked as </span><span class="s0">'worklet' </span><span class="s2">if </span><span class="s1">you wish to run them on the UI thread or use </span><span class="s0">'.runOnJS(true)' </span><span class="s1">modifier on the gesture explicitly to run all callbacks on the JS thread.`));</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">attachHandlers({</span>
  <span class="s1">preparedGesture,</span>
  <span class="s1">gestureConfig,</span>
  <span class="s1">gesture,</span>
  <span class="s1">viewTag,</span>
  <span class="s1">webEventHandlersRef,</span>
  <span class="s1">mountedRef</span>
<span class="s1">}) {</span>
  <span class="s2">if </span><span class="s1">(!preparedGesture.firstExecution) {</span>
    <span class="s1">gestureConfig.initialize();</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s1">preparedGesture.firstExecution = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s4">// use queueMicrotask to extract handlerTags, because all refs should be initialized</span>
  <span class="s4">// when it's ran</span>


  <span class="s1">queueMicrotask(() =&gt; {</span>
    <span class="s2">if </span><span class="s1">(!mountedRef.current) {</span>
      <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">gestureConfig.prepare();</span>
  <span class="s1">});</span>

  <span class="s2">for </span><span class="s1">(const handler of gesture) {</span>
    <span class="s1">checkGestureCallbacksForWorklets(handler);</span>

    <span class="s1">_RNGestureHandlerModule.</span><span class="s2">default</span><span class="s1">.createGestureHandler(handler.handlerName, handler.handlerTag, (</span><span class="s3">0</span><span class="s1">, _gestureHandlerCommon.filterConfig)(handler.config, ALLOWED_PROPS));</span>

    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _handlersRegistry.registerHandler)(handler.handlerTag, handler, handler.config.testId);</span>
  <span class="s1">} </span><span class="s4">// use queueMicrotask to extract handlerTags, because all refs should be initialized</span>
  <span class="s4">// when it's ran</span>


  <span class="s1">queueMicrotask(() =&gt; {</span>
    <span class="s2">if </span><span class="s1">(!mountedRef.current) {</span>
      <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">for </span><span class="s1">(const handler of gesture) {</span>
      <span class="s1">let requireToFail = [];</span>

      <span class="s2">if </span><span class="s1">(handler.config.requireToFail) {</span>
        <span class="s1">requireToFail = extractValidHandlerTags(handler.config.requireToFail);</span>
      <span class="s1">}</span>

      <span class="s1">let simultaneousWith = [];</span>

      <span class="s2">if </span><span class="s1">(handler.config.simultaneousWith) {</span>
        <span class="s1">simultaneousWith = extractValidHandlerTags(handler.config.simultaneousWith);</span>
      <span class="s1">}</span>

      <span class="s1">_RNGestureHandlerModule.</span><span class="s2">default</span><span class="s1">.updateGestureHandler(handler.handlerTag, (</span><span class="s3">0</span><span class="s1">, _gestureHandlerCommon.filterConfig)(handler.config, ALLOWED_PROPS, {</span>
        <span class="s1">simultaneousHandlers: simultaneousWith,</span>
        <span class="s1">waitFor: requireToFail</span>
      <span class="s1">}));</span>
    <span class="s1">}</span>

    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _gestureHandlerCommon.scheduleFlushOperations)();</span>
  <span class="s1">});</span>
  <span class="s1">preparedGesture.config = gesture;</span>

  <span class="s2">for </span><span class="s1">(const gesture of preparedGesture.config) {</span>
    <span class="s1">const actionType = gesture.shouldUseReanimated ? _ActionType.ActionType.REANIMATED_WORKLET : _ActionType.ActionType.JS_FUNCTION_NEW_API;</span>

    <span class="s2">if </span><span class="s1">(_reactNative.Platform.OS === </span><span class="s0">'web'</span><span class="s1">) {</span>
      <span class="s1">_RNGestureHandlerModule.</span><span class="s2">default</span><span class="s1">.attachGestureHandler(gesture.handlerTag, viewTag, _ActionType.ActionType.JS_FUNCTION_OLD_API, </span><span class="s4">// ignored on web</span>
      <span class="s1">webEventHandlersRef);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">_RNGestureHandlerModule.</span><span class="s2">default</span><span class="s1">.attachGestureHandler(gesture.handlerTag, viewTag, actionType);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(preparedGesture.animatedHandlers) {</span>
    <span class="s1">const isAnimatedGesture = g =&gt; g.shouldUseReanimated;</span>

    <span class="s1">preparedGesture.animatedHandlers.value = gesture.filter(isAnimatedGesture).map(g =&gt; g.handlers);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">updateHandlers(preparedGesture, gestureConfig, gesture, mountedRef) {</span>
  <span class="s1">gestureConfig.prepare();</span>

  <span class="s2">for </span><span class="s1">(let i = </span><span class="s3">0</span><span class="s1">; i &lt; gesture.length; i++) {</span>
    <span class="s1">const handler = preparedGesture.config[i];</span>
    <span class="s1">checkGestureCallbacksForWorklets(handler); </span><span class="s4">// only update handlerTag when it's actually different, it may be the same</span>
    <span class="s4">// if gesture config object is wrapped with useMemo</span>

    <span class="s2">if </span><span class="s1">(gesture[i].handlerTag !== handler.handlerTag) {</span>
      <span class="s1">gesture[i].handlerTag = handler.handlerTag;</span>
      <span class="s1">gesture[i].handlers.handlerTag = handler.handlerTag;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s4">// use queueMicrotask to extract handlerTags, because when it's ran, all refs should be updated</span>
  <span class="s4">// and handlerTags in BaseGesture references should be updated in the loop above (we need to wait</span>
  <span class="s4">// in case of external relations)</span>


  <span class="s1">queueMicrotask(() =&gt; {</span>
    <span class="s2">if </span><span class="s1">(!mountedRef.current) {</span>
      <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">for </span><span class="s1">(let i = </span><span class="s3">0</span><span class="s1">; i &lt; gesture.length; i++) {</span>
      <span class="s1">const handler = preparedGesture.config[i];</span>
      <span class="s1">handler.config = gesture[i].config;</span>
      <span class="s1">handler.handlers = gesture[i].handlers;</span>
      <span class="s1">const requireToFail = extractValidHandlerTags(handler.config.requireToFail);</span>
      <span class="s1">const simultaneousWith = extractValidHandlerTags(handler.config.simultaneousWith);</span>

      <span class="s1">_RNGestureHandlerModule.</span><span class="s2">default</span><span class="s1">.updateGestureHandler(handler.handlerTag, (</span><span class="s3">0</span><span class="s1">, _gestureHandlerCommon.filterConfig)(handler.config, ALLOWED_PROPS, {</span>
        <span class="s1">simultaneousHandlers: simultaneousWith,</span>
        <span class="s1">waitFor: requireToFail</span>
      <span class="s1">}));</span>

      <span class="s1">(</span><span class="s3">0</span><span class="s1">, _handlersRegistry.registerHandler)(handler.handlerTag, handler, handler.config.testId);</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(preparedGesture.animatedHandlers) {</span>
      <span class="s2">var </span><span class="s1">_preparedGesture$anim;</span>

      <span class="s1">const previousHandlersValue = (_preparedGesture$anim = preparedGesture.animatedHandlers.value) !== </span><span class="s2">null </span><span class="s1">&amp;&amp; _preparedGesture$anim !== </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? _preparedGesture$anim : [];</span>
      <span class="s1">const newHandlersValue = preparedGesture.config.filter(g =&gt; g.shouldUseReanimated) </span><span class="s4">// ignore gestures that shouldn't run on UI</span>
      <span class="s1">.map(g =&gt; g.handlers); </span><span class="s4">// if amount of gesture configs changes, we need to update the callbacks in shared value</span>

      <span class="s1">let shouldUpdateSharedValue = previousHandlersValue.length !== newHandlersValue.length;</span>

      <span class="s2">if </span><span class="s1">(!shouldUpdateSharedValue) {</span>
        <span class="s4">// if the amount is the same, we need to check if any of the configs inside has changed</span>
        <span class="s2">for </span><span class="s1">(let i = </span><span class="s3">0</span><span class="s1">; i &lt; newHandlersValue.length; i++) {</span>
          <span class="s2">if </span><span class="s1">( </span><span class="s4">// we can use the `gestureId` prop as it's unique for every config instance</span>
          <span class="s1">newHandlersValue[i].gestureId !== previousHandlersValue[i].gestureId) {</span>
            <span class="s1">shouldUpdateSharedValue = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s2">break</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(shouldUpdateSharedValue) {</span>
        <span class="s1">preparedGesture.animatedHandlers.value = newHandlersValue;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _gestureHandlerCommon.scheduleFlushOperations)();</span>
  <span class="s1">});</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">needsToReattach(preparedGesture, gesture) {</span>
  <span class="s2">if </span><span class="s1">(gesture.length !== preparedGesture.config.length) {</span>
    <span class="s2">return true</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">for </span><span class="s1">(let i = </span><span class="s3">0</span><span class="s1">; i &lt; gesture.length; i++) {</span>
    <span class="s2">if </span><span class="s1">(gesture[i].handlerName !== preparedGesture.config[i].handlerName || gesture[i].shouldUseReanimated !== preparedGesture.config[i].shouldUseReanimated) {</span>
      <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">return false</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">isStateChangeEvent(event) {</span>
  <span class="s0">'worklet'</span><span class="s1">; </span><span class="s4">// @ts-ignore Yes, the oldState prop is missing on GestureTouchEvent, that's the point</span>

  <span class="s2">return </span><span class="s1">event.oldState != </span><span class="s2">null</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">isTouchEvent(event) {</span>
  <span class="s0">'worklet'</span><span class="s1">;</span>

  <span class="s2">return </span><span class="s1">event.eventType != </span><span class="s2">null</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">getHandler(type, gesture) {</span>
  <span class="s0">'worklet'</span><span class="s1">;</span>

  <span class="s2">switch </span><span class="s1">(type) {</span>
    <span class="s2">case </span><span class="s1">_gesture.CALLBACK_TYPE.BEGAN:</span>
      <span class="s2">return </span><span class="s1">gesture.onBegin;</span>

    <span class="s2">case </span><span class="s1">_gesture.CALLBACK_TYPE.START:</span>
      <span class="s2">return </span><span class="s1">gesture.onStart;</span>

    <span class="s2">case </span><span class="s1">_gesture.CALLBACK_TYPE.UPDATE:</span>
      <span class="s2">return </span><span class="s1">gesture.onUpdate;</span>

    <span class="s2">case </span><span class="s1">_gesture.CALLBACK_TYPE.CHANGE:</span>
      <span class="s2">return </span><span class="s1">gesture.onChange;</span>

    <span class="s2">case </span><span class="s1">_gesture.CALLBACK_TYPE.END:</span>
      <span class="s2">return </span><span class="s1">gesture.onEnd;</span>

    <span class="s2">case </span><span class="s1">_gesture.CALLBACK_TYPE.FINALIZE:</span>
      <span class="s2">return </span><span class="s1">gesture.onFinalize;</span>

    <span class="s2">case </span><span class="s1">_gesture.CALLBACK_TYPE.TOUCHES_DOWN:</span>
      <span class="s2">return </span><span class="s1">gesture.onTouchesDown;</span>

    <span class="s2">case </span><span class="s1">_gesture.CALLBACK_TYPE.TOUCHES_MOVE:</span>
      <span class="s2">return </span><span class="s1">gesture.onTouchesMove;</span>

    <span class="s2">case </span><span class="s1">_gesture.CALLBACK_TYPE.TOUCHES_UP:</span>
      <span class="s2">return </span><span class="s1">gesture.onTouchesUp;</span>

    <span class="s2">case </span><span class="s1">_gesture.CALLBACK_TYPE.TOUCHES_CANCELLED:</span>
      <span class="s2">return </span><span class="s1">gesture.onTouchesCancelled;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">touchEventTypeToCallbackType(eventType) {</span>
  <span class="s0">'worklet'</span><span class="s1">;</span>

  <span class="s2">switch </span><span class="s1">(eventType) {</span>
    <span class="s2">case </span><span class="s1">_TouchEventType.TouchEventType.TOUCHES_DOWN:</span>
      <span class="s2">return </span><span class="s1">_gesture.CALLBACK_TYPE.TOUCHES_DOWN;</span>

    <span class="s2">case </span><span class="s1">_TouchEventType.TouchEventType.TOUCHES_MOVE:</span>
      <span class="s2">return </span><span class="s1">_gesture.CALLBACK_TYPE.TOUCHES_MOVE;</span>

    <span class="s2">case </span><span class="s1">_TouchEventType.TouchEventType.TOUCHES_UP:</span>
      <span class="s2">return </span><span class="s1">_gesture.CALLBACK_TYPE.TOUCHES_UP;</span>

    <span class="s2">case </span><span class="s1">_TouchEventType.TouchEventType.TOUCHES_CANCELLED:</span>
      <span class="s2">return </span><span class="s1">_gesture.CALLBACK_TYPE.TOUCHES_CANCELLED;</span>
  <span class="s1">}</span>

  <span class="s2">return </span><span class="s1">_gesture.CALLBACK_TYPE.UNDEFINED;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">runWorklet(type, gesture, event, ...args) {</span>
  <span class="s0">'worklet'</span><span class="s1">;</span>

  <span class="s1">const handler = getHandler(type, gesture);</span>

  <span class="s2">if </span><span class="s1">(gesture.isWorklet[type]) {</span>
    <span class="s4">// @ts-ignore Logic below makes sure the correct event is send to the</span>
    <span class="s4">// correct handler.</span>
    <span class="s1">handler === </span><span class="s2">null </span><span class="s1">|| handler === </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: handler(event, ...args);</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(handler) {</span>
    <span class="s1">console.warn((</span><span class="s3">0</span><span class="s1">, _utils.tagMessage)(</span><span class="s0">'Animated gesture callback must be a worklet'</span><span class="s1">));</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">useAnimatedGesture(preparedGesture, needsRebuild) {</span>
  <span class="s2">if </span><span class="s1">(!_reanimatedWrapper.Reanimated) {</span>
    <span class="s2">return</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s4">// Hooks are called conditionally, but the condition is whether the</span>
  <span class="s4">// react-native-reanimated is installed, which shouldn't change while running</span>
  <span class="s4">// eslint-disable-next-line react-hooks/rules-of-hooks</span>


  <span class="s1">const sharedHandlersCallbacks = _reanimatedWrapper.Reanimated.useSharedValue(</span><span class="s2">null</span><span class="s1">); </span><span class="s4">// eslint-disable-next-line react-hooks/rules-of-hooks</span>


  <span class="s1">const lastUpdateEvent = _reanimatedWrapper.Reanimated.useSharedValue([]); </span><span class="s4">// not every gesture needs a state controller, init them lazily</span>


  <span class="s1">const stateControllers = [];</span>

  <span class="s1">const callback = event =&gt; {</span>
    <span class="s0">'worklet'</span><span class="s1">;</span>

    <span class="s1">const currentCallback = sharedHandlersCallbacks.value;</span>

    <span class="s2">if </span><span class="s1">(!currentCallback) {</span>
      <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">for </span><span class="s1">(let i = </span><span class="s3">0</span><span class="s1">; i &lt; currentCallback.length; i++) {</span>
      <span class="s1">const gesture = currentCallback[i];</span>

      <span class="s2">if </span><span class="s1">(event.handlerTag === gesture.handlerTag) {</span>
        <span class="s2">if </span><span class="s1">(isStateChangeEvent(event)) {</span>
          <span class="s2">if </span><span class="s1">(event.oldState === _State.State.UNDETERMINED &amp;&amp; event.state === _State.State.BEGAN) {</span>
            <span class="s1">runWorklet(_gesture.CALLBACK_TYPE.BEGAN, gesture, event);</span>
          <span class="s1">} </span><span class="s2">else if </span><span class="s1">((event.oldState === _State.State.BEGAN || event.oldState === _State.State.UNDETERMINED) &amp;&amp; event.state === _State.State.ACTIVE) {</span>
            <span class="s1">runWorklet(_gesture.CALLBACK_TYPE.START, gesture, event);</span>
            <span class="s1">lastUpdateEvent.value[gesture.handlerTag] = undefined;</span>
          <span class="s1">} </span><span class="s2">else if </span><span class="s1">(event.oldState !== event.state &amp;&amp; event.state === _State.State.END) {</span>
            <span class="s2">if </span><span class="s1">(event.oldState === _State.State.ACTIVE) {</span>
              <span class="s1">runWorklet(_gesture.CALLBACK_TYPE.END, gesture, event, </span><span class="s2">true</span><span class="s1">);</span>
            <span class="s1">}</span>

            <span class="s1">runWorklet(_gesture.CALLBACK_TYPE.FINALIZE, gesture, event, </span><span class="s2">true</span><span class="s1">);</span>
          <span class="s1">} </span><span class="s2">else if </span><span class="s1">((event.state === _State.State.FAILED || event.state === _State.State.CANCELLED) &amp;&amp; event.state !== event.oldState) {</span>
            <span class="s2">if </span><span class="s1">(event.oldState === _State.State.ACTIVE) {</span>
              <span class="s1">runWorklet(_gesture.CALLBACK_TYPE.END, gesture, event, </span><span class="s2">false</span><span class="s1">);</span>
            <span class="s1">}</span>

            <span class="s1">runWorklet(_gesture.CALLBACK_TYPE.FINALIZE, gesture, event, </span><span class="s2">false</span><span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isTouchEvent(event)) {</span>
          <span class="s2">if </span><span class="s1">(!stateControllers[i]) {</span>
            <span class="s1">stateControllers[i] = _gestureStateManager.GestureStateManager.create(event.handlerTag);</span>
          <span class="s1">}</span>

          <span class="s2">if </span><span class="s1">(event.eventType !== _TouchEventType.TouchEventType.UNDETERMINED) {</span>
            <span class="s1">runWorklet(touchEventTypeToCallbackType(event.eventType), gesture, event, stateControllers[i]);</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">runWorklet(_gesture.CALLBACK_TYPE.UPDATE, gesture, event);</span>

          <span class="s2">if </span><span class="s1">(gesture.onChange &amp;&amp; gesture.changeEventCalculator) {</span>
            <span class="s2">var </span><span class="s1">_gesture$changeEventC;</span>

            <span class="s1">runWorklet(_gesture.CALLBACK_TYPE.CHANGE, gesture, (_gesture$changeEventC = gesture.changeEventCalculator) === </span><span class="s2">null </span><span class="s1">|| _gesture$changeEventC === </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _gesture$changeEventC.call(gesture, event, lastUpdateEvent.value[gesture.handlerTag]));</span>
            <span class="s1">lastUpdateEvent.value[gesture.handlerTag] = event;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}; </span><span class="s4">// eslint-disable-next-line react-hooks/rules-of-hooks</span>


  <span class="s1">const event = _reanimatedWrapper.Reanimated.useEvent(callback, [</span><span class="s0">'onGestureHandlerStateChange'</span><span class="s1">, </span><span class="s0">'onGestureHandlerEvent'</span><span class="s1">], needsRebuild);</span>

  <span class="s1">preparedGesture.animatedEventHandler = event;</span>
  <span class="s1">preparedGesture.animatedHandlers = sharedHandlersCallbacks;</span>
<span class="s1">} </span><span class="s4">// eslint-disable-next-line @typescript-eslint/no-explicit-any</span>


<span class="s2">function </span><span class="s1">validateDetectorChildren(ref) {</span>
  <span class="s4">// finds the first native view under the Wrap component and traverses the fiber tree upwards</span>
  <span class="s4">// to check whether there is more than one native view as a pseudo-direct child of GestureDetector</span>
  <span class="s4">// i.e. this is not ok:</span>
  <span class="s4">//            Wrap</span>
  <span class="s4">//             |</span>
  <span class="s4">//            / \</span>
  <span class="s4">//           /   \</span>
  <span class="s4">//          /     \</span>
  <span class="s4">//         /       \</span>
  <span class="s4">//   NativeView  NativeView</span>
  <span class="s4">//</span>
  <span class="s4">// but this is fine:</span>
  <span class="s4">//            Wrap</span>
  <span class="s4">//             |</span>
  <span class="s4">//         NativeView</span>
  <span class="s4">//             |</span>
  <span class="s4">//            / \</span>
  <span class="s4">//           /   \</span>
  <span class="s4">//          /     \</span>
  <span class="s4">//         /       \</span>
  <span class="s4">//   NativeView  NativeView</span>
  <span class="s2">if </span><span class="s1">(__DEV__ &amp;&amp; _reactNative.Platform.OS !== </span><span class="s0">'web'</span><span class="s1">) {</span>
    <span class="s4">// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment</span>
    <span class="s1">const wrapType = _utils.REACT_NATIVE_VERSION.minor &gt; </span><span class="s3">63 </span><span class="s1">|| _utils.REACT_NATIVE_VERSION.major &gt; </span><span class="s3">0 </span><span class="s1">? </span><span class="s4">// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access</span>
    <span class="s1">ref._reactInternals.elementType : </span><span class="s4">// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access</span>
    <span class="s1">ref._reactInternalFiber.elementType; </span><span class="s4">// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment</span>

    <span class="s1">let instance = _RNRenderer.RNRenderer.findHostInstance_DEPRECATED(ref)._internalFiberInstanceHandleDEV; </span><span class="s4">// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access</span>


    <span class="s2">while </span><span class="s1">(instance &amp;&amp; instance.elementType !== wrapType) {</span>
      <span class="s4">// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access</span>
      <span class="s2">if </span><span class="s1">(instance.sibling) {</span>
        <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">'GestureDetector has more than one native view as its children. This can happen if you are using a custom component that renders multiple views, like React.Fragment. You should wrap content of GestureDetector with a &lt;View&gt; or &lt;Animated.View&gt;.'</span><span class="s1">);</span>
      <span class="s1">} </span><span class="s4">// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access</span>


      <span class="s1">instance = instance.</span><span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">const applyUserSelectProp = (userSelect, gesture) =&gt; {</span>
  <span class="s2">for </span><span class="s1">(const g of gesture.toGestureArray()) {</span>
    <span class="s1">g.config.userSelect = userSelect;</span>
  <span class="s1">}</span>
<span class="s1">};</span>

<span class="s1">const GestureDetector = props =&gt; {</span>
  <span class="s1">const rootViewContext = (</span><span class="s3">0</span><span class="s1">, _react.useContext)(_GestureHandlerRootViewContext.</span><span class="s2">default</span><span class="s1">);</span>

  <span class="s2">if </span><span class="s1">(__DEV__ &amp;&amp; !rootViewContext &amp;&amp; !(</span><span class="s3">0</span><span class="s1">, _utils.isJestEnv)()) {</span>
    <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">'GestureDetector must be used as a descendant of GestureHandlerRootView. Otherwise the gestures will not be recognized. See https://docs.swmansion.com/react-native-gesture-handler/docs/installation for more details.'</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s1">const gestureConfig = props.gesture;</span>

  <span class="s2">if </span><span class="s1">(props.userSelect) {</span>
    <span class="s1">applyUserSelectProp(props.userSelect, gestureConfig);</span>
  <span class="s1">}</span>

  <span class="s1">const gesture = gestureConfig.toGestureArray();</span>
  <span class="s1">const useReanimatedHook = gesture.some(g =&gt; g.shouldUseReanimated); </span><span class="s4">// store state in ref to prevent unnecessary renders</span>

  <span class="s1">const state = (</span><span class="s3">0</span><span class="s1">, _react.useRef)({</span>
    <span class="s1">firstRender: </span><span class="s2">true</span><span class="s1">,</span>
    <span class="s1">viewRef: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">previousViewTag: -</span><span class="s3">1</span><span class="s1">,</span>
    <span class="s1">forceReattach: </span><span class="s2">false</span>
  <span class="s1">}).current;</span>
  <span class="s1">const mountedRef = (</span><span class="s3">0</span><span class="s1">, _react.useRef)(</span><span class="s2">false</span><span class="s1">);</span>
  <span class="s1">const webEventHandlersRef = (</span><span class="s3">0</span><span class="s1">, _react.useRef)({</span>
    <span class="s1">onGestureHandlerEvent: e =&gt; {</span>
      <span class="s1">(</span><span class="s3">0</span><span class="s1">, _eventReceiver.onGestureHandlerEvent)(e.nativeEvent);</span>
    <span class="s1">},</span>
    <span class="s1">onGestureHandlerStateChange: (</span><span class="s3">0</span><span class="s1">, _EnableNewWebImplementation.isNewWebImplementationEnabled)() ? e =&gt; {</span>
      <span class="s1">(</span><span class="s3">0</span><span class="s1">, _eventReceiver.onGestureHandlerEvent)(e.nativeEvent);</span>
    <span class="s1">} : undefined</span>
  <span class="s1">});</span>
  <span class="s1">const [renderState, setRenderState] = (</span><span class="s3">0</span><span class="s1">, _react.useState)(</span><span class="s2">false</span><span class="s1">);</span>

  <span class="s2">function </span><span class="s1">forceRender() {</span>
    <span class="s1">setRenderState(!renderState);</span>
  <span class="s1">}</span>

  <span class="s1">const preparedGesture = _react.</span><span class="s2">default</span><span class="s1">.useRef({</span>
    <span class="s1">config: gesture,</span>
    <span class="s1">animatedEventHandler: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">animatedHandlers: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">firstExecution: </span><span class="s2">true</span><span class="s1">,</span>
    <span class="s1">useReanimatedHook: useReanimatedHook</span>
  <span class="s1">}).current;</span>

  <span class="s2">if </span><span class="s1">(useReanimatedHook !== preparedGesture.useReanimatedHook) {</span>
    <span class="s2">throw new </span><span class="s1">Error((</span><span class="s3">0</span><span class="s1">, _utils.tagMessage)(</span><span class="s0">'You cannot change the thread the callbacks are ran on while the app is running'</span><span class="s1">));</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">onHandlersUpdate(skipConfigUpdate) {</span>
    <span class="s4">// if the underlying view has changed we need to reattach handlers to the new view</span>
    <span class="s1">const viewTag = (</span><span class="s3">0</span><span class="s1">, _gestureHandlerCommon.findNodeHandle)(state.viewRef);</span>
    <span class="s1">const forceReattach = viewTag !== state.previousViewTag;</span>

    <span class="s2">if </span><span class="s1">(forceReattach || needsToReattach(preparedGesture, gesture)) {</span>
      <span class="s1">validateDetectorChildren(state.viewRef);</span>
      <span class="s1">dropHandlers(preparedGesture);</span>
      <span class="s1">attachHandlers({</span>
        <span class="s1">preparedGesture,</span>
        <span class="s1">gestureConfig,</span>
        <span class="s1">gesture,</span>
        <span class="s1">webEventHandlersRef,</span>
        <span class="s1">viewTag,</span>
        <span class="s1">mountedRef</span>
      <span class="s1">});</span>
      <span class="s1">state.previousViewTag = viewTag;</span>
      <span class="s1">state.forceReattach = forceReattach;</span>

      <span class="s2">if </span><span class="s1">(forceReattach) {</span>
        <span class="s1">forceRender();</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!skipConfigUpdate) {</span>
      <span class="s1">updateHandlers(preparedGesture, gestureConfig, gesture, mountedRef);</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s4">// Reanimated event should be rebuilt only when gestures are reattached, otherwise</span>
  <span class="s4">// config update will be enough as all necessary items are stored in shared values anyway</span>


  <span class="s1">const needsToRebuildReanimatedEvent = preparedGesture.firstExecution || needsToReattach(preparedGesture, gesture) || state.forceReattach;</span>
  <span class="s1">state.forceReattach = </span><span class="s2">false</span><span class="s1">;</span>

  <span class="s2">if </span><span class="s1">(preparedGesture.firstExecution) {</span>
    <span class="s1">gestureConfig.initialize();</span>
  <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(useReanimatedHook) {</span>
    <span class="s4">// Whether animatedGesture or gesture is used shouldn't change while the app is running</span>
    <span class="s4">// eslint-disable-next-line react-hooks/rules-of-hooks</span>
    <span class="s1">useAnimatedGesture(preparedGesture, needsToRebuildReanimatedEvent);</span>
  <span class="s1">}</span>

  <span class="s1">(</span><span class="s3">0</span><span class="s1">, _react.useEffect)(() =&gt; {</span>
    <span class="s1">const viewTag = (</span><span class="s3">0</span><span class="s1">, _gestureHandlerCommon.findNodeHandle)(state.viewRef);</span>
    <span class="s1">state.firstRender = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">mountedRef.current = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">validateDetectorChildren(state.viewRef);</span>
    <span class="s1">attachHandlers({</span>
      <span class="s1">preparedGesture,</span>
      <span class="s1">gestureConfig,</span>
      <span class="s1">gesture,</span>
      <span class="s1">webEventHandlersRef,</span>
      <span class="s1">viewTag,</span>
      <span class="s1">mountedRef</span>
    <span class="s1">});</span>
    <span class="s2">return </span><span class="s1">() =&gt; {</span>
      <span class="s1">mountedRef.current = </span><span class="s2">false</span><span class="s1">;</span>
      <span class="s1">dropHandlers(preparedGesture);</span>
    <span class="s1">};</span>
  <span class="s1">}, []);</span>
  <span class="s1">(</span><span class="s3">0</span><span class="s1">, _react.useEffect)(() =&gt; {</span>
    <span class="s2">if </span><span class="s1">(!state.firstRender) {</span>
      <span class="s1">onHandlersUpdate();</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">state.firstRender = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}, [props]);</span>

  <span class="s1">const refFunction = ref =&gt; {</span>
    <span class="s2">if </span><span class="s1">(ref !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s4">// @ts-ignore Just setting the view ref</span>
      <span class="s1">state.viewRef = ref; </span><span class="s4">// if it's the first render, also set the previousViewTag to prevent reattaching gestures when not needed</span>

      <span class="s2">if </span><span class="s1">(state.previousViewTag === -</span><span class="s3">1</span><span class="s1">) {</span>
        <span class="s1">state.previousViewTag = (</span><span class="s3">0</span><span class="s1">, _gestureHandlerCommon.findNodeHandle)(state.viewRef);</span>
      <span class="s1">} </span><span class="s4">// pass true as `skipConfigUpdate`, here we only want to trigger the eventual reattaching of handlers</span>
      <span class="s4">// in case the view has changed, while config update would be handled be the `useEffect` above</span>


      <span class="s1">onHandlersUpdate(</span><span class="s2">true</span><span class="s1">);</span>

      <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _utils.isFabric)()) {</span>
        <span class="s1">const node = (</span><span class="s3">0</span><span class="s1">, _getShadowNodeFromRef.getShadowNodeFromRef)(ref);</span>

        <span class="s2">if </span><span class="s1">(global.isFormsStackingContext(node) === </span><span class="s2">false</span><span class="s1">) {</span>
          <span class="s1">console.error((</span><span class="s3">0</span><span class="s1">, _utils.tagMessage)(</span><span class="s0">'GestureDetector has received a child that may get view-flattened. ' </span><span class="s1">+ </span><span class="s0">'</span><span class="s5">\n</span><span class="s0">To prevent it from misbehaving you need to wrap the child with a `&lt;View collapsable={false}&gt;`.'</span><span class="s1">));</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s2">if </span><span class="s1">(useReanimatedHook) {</span>
    <span class="s2">return </span><span class="s4">/*#__PURE__*/</span><span class="s1">_react.</span><span class="s2">default</span><span class="s1">.createElement(AnimatedWrap, {</span>
      <span class="s1">ref: refFunction,</span>
      <span class="s1">onGestureHandlerEvent: preparedGesture.animatedEventHandler</span>
    <span class="s1">}, props.children);</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s2">return </span><span class="s4">/*#__PURE__*/</span><span class="s1">_react.</span><span class="s2">default</span><span class="s1">.createElement(Wrap, {</span>
      <span class="s1">ref: refFunction</span>
    <span class="s1">}, props.children);</span>
  <span class="s1">}</span>
<span class="s1">};</span>

<span class="s1">exports.GestureDetector = GestureDetector;</span>

<span class="s1">class Wrap extends _react.</span><span class="s2">default</span><span class="s1">.Component {</span>
  <span class="s1">render() {</span>
    <span class="s2">try </span><span class="s1">{</span>
      <span class="s4">// I don't think that fighting with types over such a simple function is worth it</span>
      <span class="s4">// The only thing it does is add 'collapsable: false' to the child component</span>
      <span class="s4">// to make sure it is in the native view hierarchy so the detector can find</span>
      <span class="s4">// correct viewTag to attach to.</span>
      <span class="s4">// eslint-disable-next-line @typescript-eslint/no-explicit-any</span>
      <span class="s1">const child = _react.</span><span class="s2">default</span><span class="s1">.Children.only(</span><span class="s2">this</span><span class="s1">.props.children);</span>

      <span class="s2">return </span><span class="s4">/*#__PURE__*/</span><span class="s1">_react.</span><span class="s2">default</span><span class="s1">.cloneElement(child, {</span>
        <span class="s1">collapsable: </span><span class="s2">false</span>
      <span class="s1">}, </span><span class="s4">// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access</span>
      <span class="s1">child.props.children);</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(e) {</span>
      <span class="s2">throw new </span><span class="s1">Error((</span><span class="s3">0</span><span class="s1">, _utils.tagMessage)(`GestureDetector got more than one view as a child. If you want the gesture to work on multiple views, wrap them </span><span class="s2">with </span><span class="s1">a common parent and attach the gesture to that view.`));</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

<span class="s1">}</span>

<span class="s1">const AnimatedWrap = (_Reanimated$default$c = _reanimatedWrapper.Reanimated === </span><span class="s2">null </span><span class="s1">|| _reanimatedWrapper.Reanimated === </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: (_Reanimated$default = _reanimatedWrapper.Reanimated.</span><span class="s2">default</span><span class="s1">) === </span><span class="s2">null </span><span class="s1">|| _Reanimated$default === </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _Reanimated$default.createAnimatedComponent(Wrap)) !== </span><span class="s2">null </span><span class="s1">&amp;&amp; _Reanimated$default$c !== </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? _Reanimated$default$c : Wrap;</span>
<span class="s4">//# sourceMappingURL=GestureDetector.js.map</span></pre>
</body>
</html>
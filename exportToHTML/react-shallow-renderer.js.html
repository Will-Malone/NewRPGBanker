<html>
<head>
<title>react-shallow-renderer.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #4646f1;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
react-shallow-renderer.js</font>
</center></td></tr></table>
<pre><span class="s0">/** @license ReactShallowRenderer v16.15.0 
 * react-shallow-renderer.js 
 * 
 * Copyright (c) Facebook, Inc. and its affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>

<span class="s1">(</span><span class="s2">function </span><span class="s1">(global, factory) {</span>
	<span class="s2">typeof </span><span class="s1">exports === </span><span class="s3">'object' </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">module !== </span><span class="s3">'undefined' </span><span class="s1">? module.exports = factory(require(</span><span class="s3">'react'</span><span class="s1">)) :</span>
	<span class="s2">typeof </span><span class="s1">define === </span><span class="s3">'function' </span><span class="s1">&amp;&amp; define.amd ? define([</span><span class="s3">'react'</span><span class="s1">], factory) :</span>
	<span class="s1">(global = global || self, global.ReactShallowRenderer = factory(global.React));</span>
<span class="s1">}(</span><span class="s2">this</span><span class="s1">, (</span><span class="s2">function </span><span class="s1">(React) { </span><span class="s3">'use strict'</span><span class="s1">;</span>

	<span class="s0">/* 
    object-assign 
    (c) Sindre Sorhus 
    @license MIT 
    */</span>
	<span class="s0">/* eslint-disable no-unused-vars */</span>
	<span class="s2">var </span><span class="s1">getOwnPropertySymbols = Object.getOwnPropertySymbols;</span>
	<span class="s2">var </span><span class="s1">hasOwnProperty = Object.prototype.hasOwnProperty;</span>
	<span class="s2">var </span><span class="s1">propIsEnumerable = Object.prototype.propertyIsEnumerable;</span>

	<span class="s2">function </span><span class="s1">toObject(val) {</span>
		<span class="s2">if </span><span class="s1">(val === </span><span class="s2">null </span><span class="s1">|| val === undefined) {</span>
			<span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s3">'Object.assign cannot be called with null or undefined'</span><span class="s1">);</span>
		<span class="s1">}</span>

		<span class="s2">return </span><span class="s1">Object(val);</span>
	<span class="s1">}</span>

	<span class="s2">function </span><span class="s1">shouldUseNative() {</span>
		<span class="s2">try </span><span class="s1">{</span>
			<span class="s2">if </span><span class="s1">(!Object.assign) {</span>
				<span class="s2">return false</span><span class="s1">;</span>
			<span class="s1">}</span>

			<span class="s0">// Detect buggy property enumeration order in older V8 versions.</span>

			<span class="s0">// https://bugs.chromium.org/p/v8/issues/detail?id=4118</span>
			<span class="s2">var </span><span class="s1">test1 = </span><span class="s2">new </span><span class="s1">String(</span><span class="s3">'abc'</span><span class="s1">);  </span><span class="s0">// eslint-disable-line no-new-wrappers</span>
			<span class="s1">test1[</span><span class="s4">5</span><span class="s1">] = </span><span class="s3">'de'</span><span class="s1">;</span>
			<span class="s2">if </span><span class="s1">(Object.getOwnPropertyNames(test1)[</span><span class="s4">0</span><span class="s1">] === </span><span class="s3">'5'</span><span class="s1">) {</span>
				<span class="s2">return false</span><span class="s1">;</span>
			<span class="s1">}</span>

			<span class="s0">// https://bugs.chromium.org/p/v8/issues/detail?id=3056</span>
			<span class="s2">var </span><span class="s1">test2 = {};</span>
			<span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; </span><span class="s4">10</span><span class="s1">; i++) {</span>
				<span class="s1">test2[</span><span class="s3">'_' </span><span class="s1">+ String.fromCharCode(i)] = i;</span>
			<span class="s1">}</span>
			<span class="s2">var </span><span class="s1">order2 = Object.getOwnPropertyNames(test2).map(</span><span class="s2">function </span><span class="s1">(n) {</span>
				<span class="s2">return </span><span class="s1">test2[n];</span>
			<span class="s1">});</span>
			<span class="s2">if </span><span class="s1">(order2.join(</span><span class="s3">''</span><span class="s1">) !== </span><span class="s3">'0123456789'</span><span class="s1">) {</span>
				<span class="s2">return false</span><span class="s1">;</span>
			<span class="s1">}</span>

			<span class="s0">// https://bugs.chromium.org/p/v8/issues/detail?id=3056</span>
			<span class="s2">var </span><span class="s1">test3 = {};</span>
			<span class="s3">'abcdefghijklmnopqrst'</span><span class="s1">.split(</span><span class="s3">''</span><span class="s1">).forEach(</span><span class="s2">function </span><span class="s1">(letter) {</span>
				<span class="s1">test3[letter] = letter;</span>
			<span class="s1">});</span>
			<span class="s2">if </span><span class="s1">(Object.keys(Object.assign({}, test3)).join(</span><span class="s3">''</span><span class="s1">) !==</span>
					<span class="s3">'abcdefghijklmnopqrst'</span><span class="s1">) {</span>
				<span class="s2">return false</span><span class="s1">;</span>
			<span class="s1">}</span>

			<span class="s2">return true</span><span class="s1">;</span>
		<span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
			<span class="s0">// We don't expect any of the above to throw, but better to be safe.</span>
			<span class="s2">return false</span><span class="s1">;</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s2">var </span><span class="s1">objectAssign = shouldUseNative() ? Object.assign : </span><span class="s2">function </span><span class="s1">(target, source) {</span>
		<span class="s2">var </span><span class="s1">from;</span>
		<span class="s2">var </span><span class="s1">to = toObject(target);</span>
		<span class="s2">var </span><span class="s1">symbols;</span>

		<span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">s = </span><span class="s4">1</span><span class="s1">; s &lt; arguments.length; s++) {</span>
			<span class="s1">from = Object(arguments[s]);</span>

			<span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">key </span><span class="s2">in </span><span class="s1">from) {</span>
				<span class="s2">if </span><span class="s1">(hasOwnProperty.call(from, key)) {</span>
					<span class="s1">to[key] = from[key];</span>
				<span class="s1">}</span>
			<span class="s1">}</span>

			<span class="s2">if </span><span class="s1">(getOwnPropertySymbols) {</span>
				<span class="s1">symbols = getOwnPropertySymbols(from);</span>
				<span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; symbols.length; i++) {</span>
					<span class="s2">if </span><span class="s1">(propIsEnumerable.call(from, symbols[i])) {</span>
						<span class="s1">to[symbols[i]] = from[symbols[i]];</span>
					<span class="s1">}</span>
				<span class="s1">}</span>
			<span class="s1">}</span>
		<span class="s1">}</span>

		<span class="s2">return </span><span class="s1">to;</span>
	<span class="s1">};</span>

	<span class="s2">function </span><span class="s1">createCommonjsModule(fn, module) {</span>
		<span class="s2">return </span><span class="s1">module = { exports: {} }, fn(module, module.exports), module.exports;</span>
	<span class="s1">}</span>

	<span class="s2">var </span><span class="s1">reactIs_development = createCommonjsModule(</span><span class="s2">function </span><span class="s1">(module, exports) {</span>

	<span class="s1">{</span>
	  <span class="s1">(</span><span class="s2">function</span><span class="s1">() {</span>

	<span class="s0">// ATTENTION</span>
	<span class="s0">// When adding new symbols to this file,</span>
	<span class="s0">// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'</span>
	<span class="s0">// The Symbol used to tag the ReactElement-like types.</span>
	<span class="s2">var </span><span class="s1">REACT_ELEMENT_TYPE = Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.element'</span><span class="s1">);</span>
	<span class="s2">var </span><span class="s1">REACT_PORTAL_TYPE = Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.portal'</span><span class="s1">);</span>
	<span class="s2">var </span><span class="s1">REACT_FRAGMENT_TYPE = Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.fragment'</span><span class="s1">);</span>
	<span class="s2">var </span><span class="s1">REACT_STRICT_MODE_TYPE = Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.strict_mode'</span><span class="s1">);</span>
	<span class="s2">var </span><span class="s1">REACT_PROFILER_TYPE = Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.profiler'</span><span class="s1">);</span>
	<span class="s2">var </span><span class="s1">REACT_PROVIDER_TYPE = Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.provider'</span><span class="s1">);</span>
	<span class="s2">var </span><span class="s1">REACT_CONTEXT_TYPE = Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.context'</span><span class="s1">);</span>
	<span class="s2">var </span><span class="s1">REACT_SERVER_CONTEXT_TYPE = Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.server_context'</span><span class="s1">);</span>
	<span class="s2">var </span><span class="s1">REACT_FORWARD_REF_TYPE = Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.forward_ref'</span><span class="s1">);</span>
	<span class="s2">var </span><span class="s1">REACT_SUSPENSE_TYPE = Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.suspense'</span><span class="s1">);</span>
	<span class="s2">var </span><span class="s1">REACT_SUSPENSE_LIST_TYPE = Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.suspense_list'</span><span class="s1">);</span>
	<span class="s2">var </span><span class="s1">REACT_MEMO_TYPE = Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.memo'</span><span class="s1">);</span>
	<span class="s2">var </span><span class="s1">REACT_LAZY_TYPE = Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.lazy'</span><span class="s1">);</span>
	<span class="s2">var </span><span class="s1">REACT_OFFSCREEN_TYPE = Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.offscreen'</span><span class="s1">);</span>

	<span class="s0">// -----------------------------------------------------------------------------</span>

	<span class="s2">var </span><span class="s1">enableScopeAPI = </span><span class="s2">false</span><span class="s1">; </span><span class="s0">// Experimental Create Event Handle API.</span>
	<span class="s2">var </span><span class="s1">enableCacheElement = </span><span class="s2">false</span><span class="s1">;</span>
	<span class="s2">var </span><span class="s1">enableTransitionTracing = </span><span class="s2">false</span><span class="s1">; </span><span class="s0">// No known bugs, but needs performance testing</span>

	<span class="s2">var </span><span class="s1">enableLegacyHidden = </span><span class="s2">false</span><span class="s1">; </span><span class="s0">// Enables unstable_avoidThisFallback feature in Fiber</span>
	<span class="s0">// stuff. Intended to enable React core members to more easily debug scheduling</span>
	<span class="s0">// issues in DEV builds.</span>

	<span class="s2">var </span><span class="s1">enableDebugTracing = </span><span class="s2">false</span><span class="s1">; </span><span class="s0">// Track which Fiber(s) schedule render work.</span>

	<span class="s2">var </span><span class="s1">REACT_MODULE_REFERENCE = Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.module.reference'</span><span class="s1">);</span>
	<span class="s2">function </span><span class="s1">isValidElementType(type) {</span>
	  <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">type === </span><span class="s3">'string' </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">type === </span><span class="s3">'function'</span><span class="s1">) {</span>
	    <span class="s2">return true</span><span class="s1">;</span>
	  <span class="s1">} </span><span class="s0">// Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).</span>


	  <span class="s2">if </span><span class="s1">(type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {</span>
	    <span class="s2">return true</span><span class="s1">;</span>
	  <span class="s1">}</span>

	  <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">type === </span><span class="s3">'object' </span><span class="s1">&amp;&amp; type !== </span><span class="s2">null</span><span class="s1">) {</span>
	    <span class="s2">if </span><span class="s1">(type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || </span><span class="s0">// This needs to include all possible module reference object</span>
	    <span class="s0">// types supported by any Flight configuration anywhere since</span>
	    <span class="s0">// we don't know which Flight build this will end up being used</span>
	    <span class="s0">// with.</span>
	    <span class="s1">type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {</span>
	      <span class="s2">return true</span><span class="s1">;</span>
	    <span class="s1">}</span>
	  <span class="s1">}</span>

	  <span class="s2">return false</span><span class="s1">;</span>
	<span class="s1">}</span>

	<span class="s2">function </span><span class="s1">typeOf(object) {</span>
	  <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">object === </span><span class="s3">'object' </span><span class="s1">&amp;&amp; object !== </span><span class="s2">null</span><span class="s1">) {</span>
	    <span class="s2">var </span><span class="s1">$$typeof = object.$$typeof;</span>

	    <span class="s2">switch </span><span class="s1">($$typeof) {</span>
	      <span class="s2">case </span><span class="s1">REACT_ELEMENT_TYPE:</span>
	        <span class="s2">var </span><span class="s1">type = object.type;</span>

	        <span class="s2">switch </span><span class="s1">(type) {</span>
	          <span class="s2">case </span><span class="s1">REACT_FRAGMENT_TYPE:</span>
	          <span class="s2">case </span><span class="s1">REACT_PROFILER_TYPE:</span>
	          <span class="s2">case </span><span class="s1">REACT_STRICT_MODE_TYPE:</span>
	          <span class="s2">case </span><span class="s1">REACT_SUSPENSE_TYPE:</span>
	          <span class="s2">case </span><span class="s1">REACT_SUSPENSE_LIST_TYPE:</span>
	            <span class="s2">return </span><span class="s1">type;</span>

	          <span class="s2">default</span><span class="s1">:</span>
	            <span class="s2">var </span><span class="s1">$$typeofType = type &amp;&amp; type.$$typeof;</span>

	            <span class="s2">switch </span><span class="s1">($$typeofType) {</span>
	              <span class="s2">case </span><span class="s1">REACT_SERVER_CONTEXT_TYPE:</span>
	              <span class="s2">case </span><span class="s1">REACT_CONTEXT_TYPE:</span>
	              <span class="s2">case </span><span class="s1">REACT_FORWARD_REF_TYPE:</span>
	              <span class="s2">case </span><span class="s1">REACT_LAZY_TYPE:</span>
	              <span class="s2">case </span><span class="s1">REACT_MEMO_TYPE:</span>
	              <span class="s2">case </span><span class="s1">REACT_PROVIDER_TYPE:</span>
	                <span class="s2">return </span><span class="s1">$$typeofType;</span>

	              <span class="s2">default</span><span class="s1">:</span>
	                <span class="s2">return </span><span class="s1">$$typeof;</span>
	            <span class="s1">}</span>

	        <span class="s1">}</span>

	      <span class="s2">case </span><span class="s1">REACT_PORTAL_TYPE:</span>
	        <span class="s2">return </span><span class="s1">$$typeof;</span>
	    <span class="s1">}</span>
	  <span class="s1">}</span>

	  <span class="s2">return </span><span class="s1">undefined;</span>
	<span class="s1">}</span>
	<span class="s2">var </span><span class="s1">ContextConsumer = REACT_CONTEXT_TYPE;</span>
	<span class="s2">var </span><span class="s1">ContextProvider = REACT_PROVIDER_TYPE;</span>
	<span class="s2">var </span><span class="s1">Element = REACT_ELEMENT_TYPE;</span>
	<span class="s2">var </span><span class="s1">ForwardRef = REACT_FORWARD_REF_TYPE;</span>
	<span class="s2">var </span><span class="s1">Fragment = REACT_FRAGMENT_TYPE;</span>
	<span class="s2">var </span><span class="s1">Lazy = REACT_LAZY_TYPE;</span>
	<span class="s2">var </span><span class="s1">Memo = REACT_MEMO_TYPE;</span>
	<span class="s2">var </span><span class="s1">Portal = REACT_PORTAL_TYPE;</span>
	<span class="s2">var </span><span class="s1">Profiler = REACT_PROFILER_TYPE;</span>
	<span class="s2">var </span><span class="s1">StrictMode = REACT_STRICT_MODE_TYPE;</span>
	<span class="s2">var </span><span class="s1">Suspense = REACT_SUSPENSE_TYPE;</span>
	<span class="s2">var </span><span class="s1">SuspenseList = REACT_SUSPENSE_LIST_TYPE;</span>
	<span class="s2">var </span><span class="s1">hasWarnedAboutDeprecatedIsAsyncMode = </span><span class="s2">false</span><span class="s1">;</span>
	<span class="s2">var </span><span class="s1">hasWarnedAboutDeprecatedIsConcurrentMode = </span><span class="s2">false</span><span class="s1">; </span><span class="s0">// AsyncMode should be deprecated</span>

	<span class="s2">function </span><span class="s1">isAsyncMode(object) {</span>
	  <span class="s1">{</span>
	    <span class="s2">if </span><span class="s1">(!hasWarnedAboutDeprecatedIsAsyncMode) {</span>
	      <span class="s1">hasWarnedAboutDeprecatedIsAsyncMode = </span><span class="s2">true</span><span class="s1">; </span><span class="s0">// Using console['warn'] to evade Babel and ESLint</span>

	      <span class="s1">console[</span><span class="s3">'warn'</span><span class="s1">](</span><span class="s3">'The ReactIs.isAsyncMode() alias has been deprecated, ' </span><span class="s1">+ </span><span class="s3">'and will be removed in React 18+.'</span><span class="s1">);</span>
	    <span class="s1">}</span>
	  <span class="s1">}</span>

	  <span class="s2">return false</span><span class="s1">;</span>
	<span class="s1">}</span>
	<span class="s2">function </span><span class="s1">isConcurrentMode(object) {</span>
	  <span class="s1">{</span>
	    <span class="s2">if </span><span class="s1">(!hasWarnedAboutDeprecatedIsConcurrentMode) {</span>
	      <span class="s1">hasWarnedAboutDeprecatedIsConcurrentMode = </span><span class="s2">true</span><span class="s1">; </span><span class="s0">// Using console['warn'] to evade Babel and ESLint</span>

	      <span class="s1">console[</span><span class="s3">'warn'</span><span class="s1">](</span><span class="s3">'The ReactIs.isConcurrentMode() alias has been deprecated, ' </span><span class="s1">+ </span><span class="s3">'and will be removed in React 18+.'</span><span class="s1">);</span>
	    <span class="s1">}</span>
	  <span class="s1">}</span>

	  <span class="s2">return false</span><span class="s1">;</span>
	<span class="s1">}</span>
	<span class="s2">function </span><span class="s1">isContextConsumer(object) {</span>
	  <span class="s2">return </span><span class="s1">typeOf(object) === REACT_CONTEXT_TYPE;</span>
	<span class="s1">}</span>
	<span class="s2">function </span><span class="s1">isContextProvider(object) {</span>
	  <span class="s2">return </span><span class="s1">typeOf(object) === REACT_PROVIDER_TYPE;</span>
	<span class="s1">}</span>
	<span class="s2">function </span><span class="s1">isElement(object) {</span>
	  <span class="s2">return typeof </span><span class="s1">object === </span><span class="s3">'object' </span><span class="s1">&amp;&amp; object !== </span><span class="s2">null </span><span class="s1">&amp;&amp; object.$$typeof === REACT_ELEMENT_TYPE;</span>
	<span class="s1">}</span>
	<span class="s2">function </span><span class="s1">isForwardRef(object) {</span>
	  <span class="s2">return </span><span class="s1">typeOf(object) === REACT_FORWARD_REF_TYPE;</span>
	<span class="s1">}</span>
	<span class="s2">function </span><span class="s1">isFragment(object) {</span>
	  <span class="s2">return </span><span class="s1">typeOf(object) === REACT_FRAGMENT_TYPE;</span>
	<span class="s1">}</span>
	<span class="s2">function </span><span class="s1">isLazy(object) {</span>
	  <span class="s2">return </span><span class="s1">typeOf(object) === REACT_LAZY_TYPE;</span>
	<span class="s1">}</span>
	<span class="s2">function </span><span class="s1">isMemo(object) {</span>
	  <span class="s2">return </span><span class="s1">typeOf(object) === REACT_MEMO_TYPE;</span>
	<span class="s1">}</span>
	<span class="s2">function </span><span class="s1">isPortal(object) {</span>
	  <span class="s2">return </span><span class="s1">typeOf(object) === REACT_PORTAL_TYPE;</span>
	<span class="s1">}</span>
	<span class="s2">function </span><span class="s1">isProfiler(object) {</span>
	  <span class="s2">return </span><span class="s1">typeOf(object) === REACT_PROFILER_TYPE;</span>
	<span class="s1">}</span>
	<span class="s2">function </span><span class="s1">isStrictMode(object) {</span>
	  <span class="s2">return </span><span class="s1">typeOf(object) === REACT_STRICT_MODE_TYPE;</span>
	<span class="s1">}</span>
	<span class="s2">function </span><span class="s1">isSuspense(object) {</span>
	  <span class="s2">return </span><span class="s1">typeOf(object) === REACT_SUSPENSE_TYPE;</span>
	<span class="s1">}</span>
	<span class="s2">function </span><span class="s1">isSuspenseList(object) {</span>
	  <span class="s2">return </span><span class="s1">typeOf(object) === REACT_SUSPENSE_LIST_TYPE;</span>
	<span class="s1">}</span>

	<span class="s1">exports.ContextConsumer = ContextConsumer;</span>
	<span class="s1">exports.ContextProvider = ContextProvider;</span>
	<span class="s1">exports.Element = Element;</span>
	<span class="s1">exports.ForwardRef = ForwardRef;</span>
	<span class="s1">exports.Fragment = Fragment;</span>
	<span class="s1">exports.Lazy = Lazy;</span>
	<span class="s1">exports.Memo = Memo;</span>
	<span class="s1">exports.Portal = Portal;</span>
	<span class="s1">exports.Profiler = Profiler;</span>
	<span class="s1">exports.StrictMode = StrictMode;</span>
	<span class="s1">exports.Suspense = Suspense;</span>
	<span class="s1">exports.SuspenseList = SuspenseList;</span>
	<span class="s1">exports.isAsyncMode = isAsyncMode;</span>
	<span class="s1">exports.isConcurrentMode = isConcurrentMode;</span>
	<span class="s1">exports.isContextConsumer = isContextConsumer;</span>
	<span class="s1">exports.isContextProvider = isContextProvider;</span>
	<span class="s1">exports.isElement = isElement;</span>
	<span class="s1">exports.isForwardRef = isForwardRef;</span>
	<span class="s1">exports.isFragment = isFragment;</span>
	<span class="s1">exports.isLazy = isLazy;</span>
	<span class="s1">exports.isMemo = isMemo;</span>
	<span class="s1">exports.isPortal = isPortal;</span>
	<span class="s1">exports.isProfiler = isProfiler;</span>
	<span class="s1">exports.isStrictMode = isStrictMode;</span>
	<span class="s1">exports.isSuspense = isSuspense;</span>
	<span class="s1">exports.isSuspenseList = isSuspenseList;</span>
	<span class="s1">exports.isValidElementType = isValidElementType;</span>
	<span class="s1">exports.typeOf = typeOf;</span>
	  <span class="s1">})();</span>
	<span class="s1">}</span>
	<span class="s1">});</span>
	<span class="s2">var </span><span class="s1">reactIs_development_1 = reactIs_development.ContextConsumer;</span>
	<span class="s2">var </span><span class="s1">reactIs_development_2 = reactIs_development.ContextProvider;</span>
	<span class="s2">var </span><span class="s1">reactIs_development_3 = reactIs_development.Element;</span>
	<span class="s2">var </span><span class="s1">reactIs_development_4 = reactIs_development.ForwardRef;</span>
	<span class="s2">var </span><span class="s1">reactIs_development_5 = reactIs_development.Fragment;</span>
	<span class="s2">var </span><span class="s1">reactIs_development_6 = reactIs_development.Lazy;</span>
	<span class="s2">var </span><span class="s1">reactIs_development_7 = reactIs_development.Memo;</span>
	<span class="s2">var </span><span class="s1">reactIs_development_8 = reactIs_development.Portal;</span>
	<span class="s2">var </span><span class="s1">reactIs_development_9 = reactIs_development.Profiler;</span>
	<span class="s2">var </span><span class="s1">reactIs_development_10 = reactIs_development.StrictMode;</span>
	<span class="s2">var </span><span class="s1">reactIs_development_11 = reactIs_development.Suspense;</span>
	<span class="s2">var </span><span class="s1">reactIs_development_12 = reactIs_development.SuspenseList;</span>
	<span class="s2">var </span><span class="s1">reactIs_development_13 = reactIs_development.isAsyncMode;</span>
	<span class="s2">var </span><span class="s1">reactIs_development_14 = reactIs_development.isConcurrentMode;</span>
	<span class="s2">var </span><span class="s1">reactIs_development_15 = reactIs_development.isContextConsumer;</span>
	<span class="s2">var </span><span class="s1">reactIs_development_16 = reactIs_development.isContextProvider;</span>
	<span class="s2">var </span><span class="s1">reactIs_development_17 = reactIs_development.isElement;</span>
	<span class="s2">var </span><span class="s1">reactIs_development_18 = reactIs_development.isForwardRef;</span>
	<span class="s2">var </span><span class="s1">reactIs_development_19 = reactIs_development.isFragment;</span>
	<span class="s2">var </span><span class="s1">reactIs_development_20 = reactIs_development.isLazy;</span>
	<span class="s2">var </span><span class="s1">reactIs_development_21 = reactIs_development.isMemo;</span>
	<span class="s2">var </span><span class="s1">reactIs_development_22 = reactIs_development.isPortal;</span>
	<span class="s2">var </span><span class="s1">reactIs_development_23 = reactIs_development.isProfiler;</span>
	<span class="s2">var </span><span class="s1">reactIs_development_24 = reactIs_development.isStrictMode;</span>
	<span class="s2">var </span><span class="s1">reactIs_development_25 = reactIs_development.isSuspense;</span>
	<span class="s2">var </span><span class="s1">reactIs_development_26 = reactIs_development.isSuspenseList;</span>
	<span class="s2">var </span><span class="s1">reactIs_development_27 = reactIs_development.isValidElementType;</span>
	<span class="s2">var </span><span class="s1">reactIs_development_28 = reactIs_development.typeOf;</span>

	<span class="s2">var </span><span class="s1">reactIs = createCommonjsModule(</span><span class="s2">function </span><span class="s1">(module) {</span>

	<span class="s1">{</span>
	  <span class="s1">module.exports = reactIs_development;</span>
	<span class="s1">}</span>
	<span class="s1">});</span>
	<span class="s2">var </span><span class="s1">reactIs_1 = reactIs.isForwardRef;</span>
	<span class="s2">var </span><span class="s1">reactIs_2 = reactIs.isMemo;</span>
	<span class="s2">var </span><span class="s1">reactIs_3 = reactIs.ForwardRef;</span>

	<span class="s2">var </span><span class="s1">BEFORE_SLASH_RE = /^(.*)[\\\/]/;</span>
	<span class="s2">function </span><span class="s1">describeComponentFrame (name, source, ownerName) {</span>
	  <span class="s2">var </span><span class="s1">sourceInfo = </span><span class="s3">''</span><span class="s1">;</span>

	  <span class="s2">if </span><span class="s1">(source) {</span>
	    <span class="s2">var </span><span class="s1">path = source.fileName;</span>
	    <span class="s2">var </span><span class="s1">fileName = path.replace(BEFORE_SLASH_RE, </span><span class="s3">''</span><span class="s1">);</span>

	    <span class="s1">{</span>
	      <span class="s0">// In DEV, include code for a common special case:</span>
	      <span class="s0">// prefer &quot;folder/index.js&quot; instead of just &quot;index.js&quot;.</span>
	      <span class="s2">if </span><span class="s1">(/^index\./.test(fileName)) {</span>
	        <span class="s2">var </span><span class="s1">match = path.match(BEFORE_SLASH_RE);</span>

	        <span class="s2">if </span><span class="s1">(match) {</span>
	          <span class="s2">var </span><span class="s1">pathBeforeSlash = match[</span><span class="s4">1</span><span class="s1">];</span>

	          <span class="s2">if </span><span class="s1">(pathBeforeSlash) {</span>
	            <span class="s2">var </span><span class="s1">folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, </span><span class="s3">''</span><span class="s1">);</span>
	            <span class="s1">fileName = folderName + </span><span class="s3">'/' </span><span class="s1">+ fileName;</span>
	          <span class="s1">}</span>
	        <span class="s1">}</span>
	      <span class="s1">}</span>
	    <span class="s1">}</span>

	    <span class="s1">sourceInfo = </span><span class="s3">' (at ' </span><span class="s1">+ fileName + </span><span class="s3">':' </span><span class="s1">+ source.lineNumber + </span><span class="s3">')'</span><span class="s1">;</span>
	  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(ownerName) {</span>
	    <span class="s1">sourceInfo = </span><span class="s3">' (created by ' </span><span class="s1">+ ownerName + </span><span class="s3">')'</span><span class="s1">;</span>
	  <span class="s1">}</span>

	  <span class="s2">return </span><span class="s3">'</span><span class="s5">\n    </span><span class="s3">in ' </span><span class="s1">+ (name || </span><span class="s3">'Unknown'</span><span class="s1">) + sourceInfo;</span>
	<span class="s1">}</span>

	<span class="s2">var </span><span class="s1">ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;</span>
	<span class="s2">var </span><span class="s1">hasOwnProperty$1 = Object.prototype.hasOwnProperty; </span><span class="s0">// Prevent newer renderers from RTE when used with older react package versions.</span>
	<span class="s0">// Current owner and dispatcher used to share the same ref,</span>
	<span class="s0">// but PR #14548 split them out to better support the react-debug-tools package.</span>

	<span class="s2">if </span><span class="s1">(!hasOwnProperty$1.call(ReactSharedInternals, </span><span class="s3">'ReactCurrentDispatcher'</span><span class="s1">)) {</span>
	  <span class="s1">ReactSharedInternals.ReactCurrentDispatcher = {</span>
	    <span class="s1">current: </span><span class="s2">null</span>
	  <span class="s1">};</span>
	<span class="s1">}</span>

	<span class="s2">if </span><span class="s1">(!hasOwnProperty$1.call(ReactSharedInternals, </span><span class="s3">'ReactCurrentBatchConfig'</span><span class="s1">)) {</span>
	  <span class="s1">ReactSharedInternals.ReactCurrentBatchConfig = {</span>
	    <span class="s1">suspense: </span><span class="s2">null</span>
	  <span class="s1">};</span>
	<span class="s1">}</span>

	<span class="s2">function </span><span class="s1">error(format) {</span>
	  <span class="s1">{</span>
	    <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">_len2 = arguments.length, args = </span><span class="s2">new </span><span class="s1">Array(_len2 &gt; </span><span class="s4">1 </span><span class="s1">? _len2 - </span><span class="s4">1 </span><span class="s1">: </span><span class="s4">0</span><span class="s1">), _key2 = </span><span class="s4">1</span><span class="s1">; _key2 &lt; _len2; _key2++) {</span>
	      <span class="s1">args[_key2 - </span><span class="s4">1</span><span class="s1">] = arguments[_key2];</span>
	    <span class="s1">}</span>

	    <span class="s1">printWarning(</span><span class="s3">'error'</span><span class="s1">, format, args);</span>
	  <span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s2">function </span><span class="s1">printWarning(level, format, args) {</span>
	  <span class="s1">{</span>
	    <span class="s2">var </span><span class="s1">hasExistingStack = args.length &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">args[args.length - </span><span class="s4">1</span><span class="s1">] === </span><span class="s3">'string' </span><span class="s1">&amp;&amp; args[args.length - </span><span class="s4">1</span><span class="s1">].indexOf(</span><span class="s3">'</span><span class="s5">\n    </span><span class="s3">in'</span><span class="s1">) === </span><span class="s4">0</span><span class="s1">;</span>

	    <span class="s2">if </span><span class="s1">(!hasExistingStack) {</span>
	      <span class="s2">var </span><span class="s1">ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;</span>
	      <span class="s2">var </span><span class="s1">stack = ReactDebugCurrentFrame.getStackAddendum();</span>

	      <span class="s2">if </span><span class="s1">(stack !== </span><span class="s3">''</span><span class="s1">) {</span>
	        <span class="s1">format += </span><span class="s3">'%s'</span><span class="s1">;</span>
	        <span class="s1">args = args.concat([stack]);</span>
	      <span class="s1">}</span>
	    <span class="s1">}</span>

	    <span class="s2">var </span><span class="s1">argsWithFormat = args.map(</span><span class="s2">function </span><span class="s1">(item) {</span>
	      <span class="s2">return </span><span class="s3">'' </span><span class="s1">+ item;</span>
	    <span class="s1">}); </span><span class="s0">// Careful: RN currently depends on this prefix</span>

	    <span class="s1">argsWithFormat.unshift(</span><span class="s3">'Warning: ' </span><span class="s1">+ format); </span><span class="s0">// We intentionally don't use spread (or .apply) directly because it</span>
	    <span class="s0">// breaks IE9: https://github.com/facebook/react/issues/13610</span>
	    <span class="s0">// eslint-disable-next-line no-console</span>

	    <span class="s1">Function.prototype.apply.call(console[level], console, argsWithFormat);</span>

	    <span class="s2">try </span><span class="s1">{</span>
	      <span class="s0">// --- Welcome to debugging React ---</span>
	      <span class="s0">// This error was thrown as a convenience so that you can use this stack</span>
	      <span class="s0">// to find the callsite that caused this warning to fire.</span>
	      <span class="s2">var </span><span class="s1">argIndex = </span><span class="s4">0</span><span class="s1">;</span>
	      <span class="s2">var </span><span class="s1">message = </span><span class="s3">'Warning: ' </span><span class="s1">+ format.replace(/%s/g, </span><span class="s2">function </span><span class="s1">() {</span>
	        <span class="s2">return </span><span class="s1">args[argIndex++];</span>
	      <span class="s1">});</span>
	      <span class="s2">throw new </span><span class="s1">Error(message);</span>
	    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(x) {}</span>
	  <span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s0">// The Symbol used to tag the ReactElement-like types. If there is no native Symbol</span>
	<span class="s0">// nor polyfill, then a plain number is used for performance.</span>
	<span class="s2">var </span><span class="s1">hasSymbol = </span><span class="s2">typeof </span><span class="s1">Symbol === </span><span class="s3">'function' </span><span class="s1">&amp;&amp; Symbol.</span><span class="s2">for</span><span class="s1">;</span>
	<span class="s2">var </span><span class="s1">REACT_PORTAL_TYPE = hasSymbol ? Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.portal'</span><span class="s1">) : </span><span class="s4">0</span><span class="s1">xeaca;</span>
	<span class="s2">var </span><span class="s1">REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.fragment'</span><span class="s1">) : </span><span class="s4">0</span><span class="s1">xeacb;</span>
	<span class="s2">var </span><span class="s1">REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.strict_mode'</span><span class="s1">) : </span><span class="s4">0</span><span class="s1">xeacc;</span>
	<span class="s2">var </span><span class="s1">REACT_PROFILER_TYPE = hasSymbol ? Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.profiler'</span><span class="s1">) : </span><span class="s4">0</span><span class="s1">xead2;</span>
	<span class="s2">var </span><span class="s1">REACT_PROVIDER_TYPE = hasSymbol ? Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.provider'</span><span class="s1">) : </span><span class="s4">0</span><span class="s1">xeacd;</span>
	<span class="s2">var </span><span class="s1">REACT_CONTEXT_TYPE = hasSymbol ? Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.context'</span><span class="s1">) : </span><span class="s4">0</span><span class="s1">xeace; </span><span class="s0">// TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary</span>
	<span class="s2">var </span><span class="s1">REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.forward_ref'</span><span class="s1">) : </span><span class="s4">0</span><span class="s1">xead0;</span>
	<span class="s2">var </span><span class="s1">REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.suspense'</span><span class="s1">) : </span><span class="s4">0</span><span class="s1">xead1;</span>
	<span class="s2">var </span><span class="s1">REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.suspense_list'</span><span class="s1">) : </span><span class="s4">0</span><span class="s1">xead8;</span>
	<span class="s2">var </span><span class="s1">REACT_MEMO_TYPE = hasSymbol ? Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.memo'</span><span class="s1">) : </span><span class="s4">0</span><span class="s1">xead3;</span>
	<span class="s2">var </span><span class="s1">REACT_LAZY_TYPE = hasSymbol ? Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.lazy'</span><span class="s1">) : </span><span class="s4">0</span><span class="s1">xead4;</span>
	<span class="s2">var </span><span class="s1">REACT_CHUNK_TYPE = hasSymbol ? Symbol.</span><span class="s2">for</span><span class="s1">(</span><span class="s3">'react.chunk'</span><span class="s1">) : </span><span class="s4">0</span><span class="s1">xead9;</span>

	<span class="s2">var </span><span class="s1">Resolved = </span><span class="s4">1</span><span class="s1">;</span>
	<span class="s2">function </span><span class="s1">refineResolvedLazyComponent(lazyComponent) {</span>
	  <span class="s2">return </span><span class="s1">lazyComponent._status === Resolved ? lazyComponent._result : </span><span class="s2">null</span><span class="s1">;</span>
	<span class="s1">}</span>

	<span class="s2">function </span><span class="s1">getWrappedName(outerType, innerType, wrapperName) {</span>
	  <span class="s2">var </span><span class="s1">functionName = innerType.displayName || innerType.name || </span><span class="s3">''</span><span class="s1">;</span>
	  <span class="s2">return </span><span class="s1">outerType.displayName || (functionName !== </span><span class="s3">'' </span><span class="s1">? wrapperName + </span><span class="s3">&quot;(&quot; </span><span class="s1">+ functionName + </span><span class="s3">&quot;)&quot; </span><span class="s1">: wrapperName);</span>
	<span class="s1">}</span>

	<span class="s2">function </span><span class="s1">getComponentName(type) {</span>
	  <span class="s2">if </span><span class="s1">(type == </span><span class="s2">null</span><span class="s1">) {</span>
	    <span class="s0">// Host root, text node or just invalid type.</span>
	    <span class="s2">return null</span><span class="s1">;</span>
	  <span class="s1">}</span>

	  <span class="s1">{</span>
	    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">type.tag === </span><span class="s3">'number'</span><span class="s1">) {</span>
	      <span class="s1">error(</span><span class="s3">'Received an unexpected object in getComponentName(). ' </span><span class="s1">+ </span><span class="s3">'This is likely a bug in React. Please file an issue.'</span><span class="s1">);</span>
	    <span class="s1">}</span>
	  <span class="s1">}</span>

	  <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">type === </span><span class="s3">'function'</span><span class="s1">) {</span>
	    <span class="s2">return </span><span class="s1">type.displayName || type.name || </span><span class="s2">null</span><span class="s1">;</span>
	  <span class="s1">}</span>

	  <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">type === </span><span class="s3">'string'</span><span class="s1">) {</span>
	    <span class="s2">return </span><span class="s1">type;</span>
	  <span class="s1">}</span>

	  <span class="s2">switch </span><span class="s1">(type) {</span>
	    <span class="s2">case </span><span class="s1">REACT_FRAGMENT_TYPE:</span>
	      <span class="s2">return </span><span class="s3">'Fragment'</span><span class="s1">;</span>

	    <span class="s2">case </span><span class="s1">REACT_PORTAL_TYPE:</span>
	      <span class="s2">return </span><span class="s3">'Portal'</span><span class="s1">;</span>

	    <span class="s2">case </span><span class="s1">REACT_PROFILER_TYPE:</span>
	      <span class="s2">return </span><span class="s3">&quot;Profiler&quot;</span><span class="s1">;</span>

	    <span class="s2">case </span><span class="s1">REACT_STRICT_MODE_TYPE:</span>
	      <span class="s2">return </span><span class="s3">'StrictMode'</span><span class="s1">;</span>

	    <span class="s2">case </span><span class="s1">REACT_SUSPENSE_TYPE:</span>
	      <span class="s2">return </span><span class="s3">'Suspense'</span><span class="s1">;</span>

	    <span class="s2">case </span><span class="s1">REACT_SUSPENSE_LIST_TYPE:</span>
	      <span class="s2">return </span><span class="s3">'SuspenseList'</span><span class="s1">;</span>
	  <span class="s1">}</span>

	  <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">type === </span><span class="s3">'object'</span><span class="s1">) {</span>
	    <span class="s2">switch </span><span class="s1">(type.$$typeof) {</span>
	      <span class="s2">case </span><span class="s1">REACT_CONTEXT_TYPE:</span>
	        <span class="s2">return </span><span class="s3">'Context.Consumer'</span><span class="s1">;</span>

	      <span class="s2">case </span><span class="s1">REACT_PROVIDER_TYPE:</span>
	        <span class="s2">return </span><span class="s3">'Context.Provider'</span><span class="s1">;</span>

	      <span class="s2">case </span><span class="s1">REACT_FORWARD_REF_TYPE:</span>
	        <span class="s2">return </span><span class="s1">getWrappedName(type, type.render, </span><span class="s3">'ForwardRef'</span><span class="s1">);</span>

	      <span class="s2">case </span><span class="s1">REACT_MEMO_TYPE:</span>
	        <span class="s2">return </span><span class="s1">getComponentName(type.type);</span>

	      <span class="s2">case </span><span class="s1">REACT_CHUNK_TYPE:</span>
	        <span class="s2">return </span><span class="s1">getComponentName(type.render);</span>

	      <span class="s2">case </span><span class="s1">REACT_LAZY_TYPE:</span>
	        <span class="s1">{</span>
	          <span class="s2">var </span><span class="s1">thenable = type;</span>
	          <span class="s2">var </span><span class="s1">resolvedThenable = refineResolvedLazyComponent(thenable);</span>

	          <span class="s2">if </span><span class="s1">(resolvedThenable) {</span>
	            <span class="s2">return </span><span class="s1">getComponentName(resolvedThenable);</span>
	          <span class="s1">}</span>

	          <span class="s2">break</span><span class="s1">;</span>
	        <span class="s1">}</span>
	    <span class="s1">}</span>
	  <span class="s1">}</span>

	  <span class="s2">return null</span><span class="s1">;</span>
	<span class="s1">}</span>

	<span class="s0">/** 
     * inlined Object.is polyfill to avoid requiring consumers ship their own 
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is 
     */</span>
	<span class="s2">function </span><span class="s1">is(x, y) {</span>
	  <span class="s2">return </span><span class="s1">x === y &amp;&amp; (x !== </span><span class="s4">0 </span><span class="s1">|| </span><span class="s4">1 </span><span class="s1">/ x === </span><span class="s4">1 </span><span class="s1">/ y) || x !== x &amp;&amp; y !== y </span><span class="s0">// eslint-disable-line no-self-compare</span>
	  <span class="s1">;</span>
	<span class="s1">}</span>

	<span class="s2">var </span><span class="s1">objectIs = </span><span class="s2">typeof </span><span class="s1">Object.is === </span><span class="s3">'function' </span><span class="s1">? Object.is : is;</span>

	<span class="s2">var </span><span class="s1">hasOwnProperty$2 = Object.prototype.hasOwnProperty;</span>
	<span class="s0">/** 
     * Performs equality by iterating through keys on an object and returning false 
     * when any key has values which are not strictly equal between the arguments. 
     * Returns true when the values of all keys are strictly equal. 
     */</span>

	<span class="s2">function </span><span class="s1">shallowEqual(objA, objB) {</span>
	  <span class="s2">if </span><span class="s1">(objectIs(objA, objB)) {</span>
	    <span class="s2">return true</span><span class="s1">;</span>
	  <span class="s1">}</span>

	  <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">objA !== </span><span class="s3">'object' </span><span class="s1">|| objA === </span><span class="s2">null </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">objB !== </span><span class="s3">'object' </span><span class="s1">|| objB === </span><span class="s2">null</span><span class="s1">) {</span>
	    <span class="s2">return false</span><span class="s1">;</span>
	  <span class="s1">}</span>

	  <span class="s2">var </span><span class="s1">keysA = Object.keys(objA);</span>
	  <span class="s2">var </span><span class="s1">keysB = Object.keys(objB);</span>

	  <span class="s2">if </span><span class="s1">(keysA.length !== keysB.length) {</span>
	    <span class="s2">return false</span><span class="s1">;</span>
	  <span class="s1">} </span><span class="s0">// Test for A's keys different from B.</span>


	  <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; keysA.length; i++) {</span>
	    <span class="s2">if </span><span class="s1">(!hasOwnProperty$2.call(objB, keysA[i]) || !objectIs(objA[keysA[i]], objB[keysA[i]])) {</span>
	      <span class="s2">return false</span><span class="s1">;</span>
	    <span class="s1">}</span>
	  <span class="s1">}</span>

	  <span class="s2">return true</span><span class="s1">;</span>
	<span class="s1">}</span>

	<span class="s2">var </span><span class="s1">loggedTypeFailures = {};</span>
	<span class="s2">function </span><span class="s1">checkPropTypes(typeSpecs, values, location, componentName) {</span>
	  <span class="s1">{</span>
	    <span class="s2">var </span><span class="s1">has = Function.call.bind(Object.prototype.hasOwnProperty);</span>

	    <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">typeSpecName </span><span class="s2">in </span><span class="s1">typeSpecs) {</span>
	      <span class="s2">if </span><span class="s1">(has(typeSpecs, typeSpecName)) {</span>
	        <span class="s2">var </span><span class="s1">error$1 = </span><span class="s2">void </span><span class="s4">0</span><span class="s1">; </span><span class="s0">// Prop type validation may throw. In case they do, we don't want to</span>
	        <span class="s0">// fail the render phase where it didn't fail before. So we log it.</span>
	        <span class="s0">// After these have been cleaned up, we'll let them throw.</span>

	        <span class="s2">try </span><span class="s1">{</span>
	          <span class="s0">// This is intentionally an invariant that gets caught. It's the same</span>
	          <span class="s0">// behavior as without this statement except with a better message.</span>
	          <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">typeSpecs[typeSpecName] !== </span><span class="s3">'function'</span><span class="s1">) {</span>
	            <span class="s2">var </span><span class="s1">err = Error((componentName || </span><span class="s3">'React class'</span><span class="s1">) + </span><span class="s3">': ' </span><span class="s1">+ location + </span><span class="s3">' type `' </span><span class="s1">+ typeSpecName + </span><span class="s3">'` is invalid; ' </span><span class="s1">+ </span><span class="s3">'it must be a function, usually from the `prop-types` package, but received `' </span><span class="s1">+ </span><span class="s2">typeof </span><span class="s1">typeSpecs[typeSpecName] + </span><span class="s3">'`.' </span><span class="s1">+ </span><span class="s3">'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.'</span><span class="s1">);</span>
	            <span class="s1">err.name = </span><span class="s3">'Invariant Violation'</span><span class="s1">;</span>
	            <span class="s2">throw </span><span class="s1">err;</span>
	          <span class="s1">}</span>

	          <span class="s1">error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, </span><span class="s2">null</span><span class="s1">, </span><span class="s3">'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED'</span><span class="s1">);</span>
	        <span class="s1">} </span><span class="s2">catch </span><span class="s1">(ex) {</span>
	          <span class="s1">error$1 = ex;</span>
	        <span class="s1">}</span>

	        <span class="s2">if </span><span class="s1">(error$1 &amp;&amp; !(error$1 </span><span class="s2">instanceof </span><span class="s1">Error)) {</span>
	          <span class="s1">error(</span><span class="s3">'%s: type specification of %s' </span><span class="s1">+ </span><span class="s3">' `%s` is invalid; the type checker ' </span><span class="s1">+ </span><span class="s3">'function must return `null` or an `Error` but returned a %s. ' </span><span class="s1">+ </span><span class="s3">'You may have forgotten to pass an argument to the type checker ' </span><span class="s1">+ </span><span class="s3">'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' </span><span class="s1">+ </span><span class="s3">'shape all require an argument).'</span><span class="s1">, componentName || </span><span class="s3">'React class'</span><span class="s1">, location, typeSpecName, </span><span class="s2">typeof </span><span class="s1">error$1);</span>
	        <span class="s1">}</span>

	        <span class="s2">if </span><span class="s1">(error$1 </span><span class="s2">instanceof </span><span class="s1">Error &amp;&amp; !(error$1.message </span><span class="s2">in </span><span class="s1">loggedTypeFailures)) {</span>
	          <span class="s0">// Only monitor this failure once because there tends to be a lot of the</span>
	          <span class="s0">// same error.</span>
	          <span class="s1">loggedTypeFailures[error$1.message] = </span><span class="s2">true</span><span class="s1">;</span>
	          <span class="s1">error(</span><span class="s3">'Failed %s type: %s'</span><span class="s1">, location, error$1.message);</span>
	        <span class="s1">}</span>
	      <span class="s1">}</span>
	    <span class="s1">}</span>
	  <span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s2">var </span><span class="s1">ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher,</span>
	    <span class="s1">ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;</span>
	<span class="s2">var </span><span class="s1">RE_RENDER_LIMIT = </span><span class="s4">25</span><span class="s1">;</span>
	<span class="s2">var </span><span class="s1">emptyObject = {};</span>

	<span class="s1">{</span>
	  <span class="s1">Object.freeze(emptyObject);</span>
	<span class="s1">} </span><span class="s0">// In DEV, this is the name of the currently executing primitive hook</span>


	<span class="s2">var </span><span class="s1">currentHookNameInDev;</span>

	<span class="s2">function </span><span class="s1">areHookInputsEqual(nextDeps, prevDeps) {</span>
	  <span class="s2">if </span><span class="s1">(prevDeps === </span><span class="s2">null</span><span class="s1">) {</span>
	    <span class="s1">{</span>
	      <span class="s1">error(</span><span class="s3">'%s received a final argument during this render, but not during ' </span><span class="s1">+ </span><span class="s3">'the previous render. Even though the final argument is optional, ' </span><span class="s1">+ </span><span class="s3">'its type cannot change between renders.'</span><span class="s1">, currentHookNameInDev);</span>
	    <span class="s1">}</span>

	    <span class="s2">return false</span><span class="s1">;</span>
	  <span class="s1">}</span>

	  <span class="s1">{</span>
	    <span class="s0">// Don't bother comparing lengths in prod because these arrays should be</span>
	    <span class="s0">// passed inline.</span>
	    <span class="s2">if </span><span class="s1">(nextDeps.length !== prevDeps.length) {</span>
	      <span class="s1">error(</span><span class="s3">'The final argument passed to %s changed size between renders. The ' </span><span class="s1">+ </span><span class="s3">'order and size of this array must remain constant.</span><span class="s5">\n\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">'Previous: %s</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">'Incoming: %s'</span><span class="s1">, currentHookNameInDev, </span><span class="s3">&quot;[&quot; </span><span class="s1">+ nextDeps.join(</span><span class="s3">', '</span><span class="s1">) + </span><span class="s3">&quot;]&quot;</span><span class="s1">, </span><span class="s3">&quot;[&quot; </span><span class="s1">+ prevDeps.join(</span><span class="s3">', '</span><span class="s1">) + </span><span class="s3">&quot;]&quot;</span><span class="s1">);</span>
	    <span class="s1">}</span>
	  <span class="s1">}</span>

	  <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; prevDeps.length &amp;&amp; i &lt; nextDeps.length; i++) {</span>
	    <span class="s2">if </span><span class="s1">(objectIs(nextDeps[i], prevDeps[i])) {</span>
	      <span class="s2">continue</span><span class="s1">;</span>
	    <span class="s1">}</span>

	    <span class="s2">return false</span><span class="s1">;</span>
	  <span class="s1">}</span>

	  <span class="s2">return true</span><span class="s1">;</span>
	<span class="s1">}</span>

	<span class="s2">var </span><span class="s1">Updater = </span><span class="s0">/*#__PURE__*/</span><span class="s2">function </span><span class="s1">() {</span>
	  <span class="s2">function </span><span class="s1">Updater(renderer) {</span>
	    <span class="s2">this</span><span class="s1">._renderer = renderer;</span>
	    <span class="s2">this</span><span class="s1">._callbacks = [];</span>
	  <span class="s1">}</span>

	  <span class="s2">var </span><span class="s1">_proto = Updater.prototype;</span>

	  <span class="s1">_proto._enqueueCallback = </span><span class="s2">function </span><span class="s1">_enqueueCallback(callback, publicInstance) {</span>
	    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">callback === </span><span class="s3">'function' </span><span class="s1">&amp;&amp; publicInstance) {</span>
	      <span class="s2">this</span><span class="s1">._callbacks.push({</span>
	        <span class="s1">callback: callback,</span>
	        <span class="s1">publicInstance: publicInstance</span>
	      <span class="s1">});</span>
	    <span class="s1">}</span>
	  <span class="s1">};</span>

	  <span class="s1">_proto._invokeCallbacks = </span><span class="s2">function </span><span class="s1">_invokeCallbacks() {</span>
	    <span class="s2">var </span><span class="s1">callbacks = </span><span class="s2">this</span><span class="s1">._callbacks;</span>
	    <span class="s2">this</span><span class="s1">._callbacks = [];</span>
	    <span class="s1">callbacks.forEach(</span><span class="s2">function </span><span class="s1">(_ref) {</span>
	      <span class="s2">var </span><span class="s1">callback = _ref.callback,</span>
	          <span class="s1">publicInstance = _ref.publicInstance;</span>
	      <span class="s1">callback.call(publicInstance);</span>
	    <span class="s1">});</span>
	  <span class="s1">};</span>

	  <span class="s1">_proto.isMounted = </span><span class="s2">function </span><span class="s1">isMounted(publicInstance) {</span>
	    <span class="s2">return </span><span class="s1">!!</span><span class="s2">this</span><span class="s1">._renderer._element;</span>
	  <span class="s1">};</span>

	  <span class="s1">_proto.enqueueForceUpdate = </span><span class="s2">function </span><span class="s1">enqueueForceUpdate(publicInstance, callback, callerName) {</span>
	    <span class="s2">this</span><span class="s1">._enqueueCallback(callback, publicInstance);</span>

	    <span class="s2">this</span><span class="s1">._renderer._forcedUpdate = </span><span class="s2">true</span><span class="s1">;</span>

	    <span class="s2">this</span><span class="s1">._renderer.render(</span><span class="s2">this</span><span class="s1">._renderer._element, </span><span class="s2">this</span><span class="s1">._renderer._context);</span>
	  <span class="s1">};</span>

	  <span class="s1">_proto.enqueueReplaceState = </span><span class="s2">function </span><span class="s1">enqueueReplaceState(publicInstance, completeState, callback, callerName) {</span>
	    <span class="s2">this</span><span class="s1">._enqueueCallback(callback, publicInstance);</span>

	    <span class="s2">this</span><span class="s1">._renderer._newState = completeState;</span>

	    <span class="s2">this</span><span class="s1">._renderer.render(</span><span class="s2">this</span><span class="s1">._renderer._element, </span><span class="s2">this</span><span class="s1">._renderer._context);</span>
	  <span class="s1">};</span>

	  <span class="s1">_proto.enqueueSetState = </span><span class="s2">function </span><span class="s1">enqueueSetState(publicInstance, partialState, callback, callerName) {</span>
	    <span class="s2">this</span><span class="s1">._enqueueCallback(callback, publicInstance);</span>

	    <span class="s2">var </span><span class="s1">currentState = </span><span class="s2">this</span><span class="s1">._renderer._newState || publicInstance.state;</span>

	    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">partialState === </span><span class="s3">'function'</span><span class="s1">) {</span>
	      <span class="s1">partialState = partialState.call(publicInstance, currentState, publicInstance.props);</span>
	    <span class="s1">} </span><span class="s0">// Null and undefined are treated as no-ops.</span>


	    <span class="s2">if </span><span class="s1">(partialState === </span><span class="s2">null </span><span class="s1">|| partialState === undefined) {</span>
	      <span class="s2">return</span><span class="s1">;</span>
	    <span class="s1">}</span>

	    <span class="s2">this</span><span class="s1">._renderer._newState = objectAssign({}, currentState, partialState);</span>

	    <span class="s2">this</span><span class="s1">._renderer.render(</span><span class="s2">this</span><span class="s1">._renderer._element, </span><span class="s2">this</span><span class="s1">._renderer._context);</span>
	  <span class="s1">};</span>

	  <span class="s2">return </span><span class="s1">Updater;</span>
	<span class="s1">}();</span>

	<span class="s2">function </span><span class="s1">createHook() {</span>
	  <span class="s2">return </span><span class="s1">{</span>
	    <span class="s1">memoizedState: </span><span class="s2">null</span><span class="s1">,</span>
	    <span class="s1">queue: </span><span class="s2">null</span><span class="s1">,</span>
	    <span class="s1">next: </span><span class="s2">null</span>
	  <span class="s1">};</span>
	<span class="s1">}</span>

	<span class="s2">function </span><span class="s1">basicStateReducer(state, action) {</span>
	  <span class="s2">return typeof </span><span class="s1">action === </span><span class="s3">'function' </span><span class="s1">? action(state) : action;</span>
	<span class="s1">}</span>

	<span class="s2">var </span><span class="s1">ReactShallowRenderer = </span><span class="s0">/*#__PURE__*/</span><span class="s2">function </span><span class="s1">() {</span>
	  <span class="s2">function </span><span class="s1">ReactShallowRenderer() {</span>
	    <span class="s2">this</span><span class="s1">._reset();</span>
	  <span class="s1">}</span>

	  <span class="s2">var </span><span class="s1">_proto2 = ReactShallowRenderer.prototype;</span>

	  <span class="s1">_proto2._reset = </span><span class="s2">function </span><span class="s1">_reset() {</span>
	    <span class="s2">this</span><span class="s1">._context = </span><span class="s2">null</span><span class="s1">;</span>
	    <span class="s2">this</span><span class="s1">._element = </span><span class="s2">null</span><span class="s1">;</span>
	    <span class="s2">this</span><span class="s1">._instance = </span><span class="s2">null</span><span class="s1">;</span>
	    <span class="s2">this</span><span class="s1">._newState = </span><span class="s2">null</span><span class="s1">;</span>
	    <span class="s2">this</span><span class="s1">._rendered = </span><span class="s2">null</span><span class="s1">;</span>
	    <span class="s2">this</span><span class="s1">._rendering = </span><span class="s2">false</span><span class="s1">;</span>
	    <span class="s2">this</span><span class="s1">._forcedUpdate = </span><span class="s2">false</span><span class="s1">;</span>
	    <span class="s2">this</span><span class="s1">._updater = </span><span class="s2">new </span><span class="s1">Updater(</span><span class="s2">this</span><span class="s1">);</span>
	    <span class="s2">this</span><span class="s1">._dispatcher = </span><span class="s2">this</span><span class="s1">._createDispatcher();</span>
	    <span class="s2">this</span><span class="s1">._workInProgressHook = </span><span class="s2">null</span><span class="s1">;</span>
	    <span class="s2">this</span><span class="s1">._firstWorkInProgressHook = </span><span class="s2">null</span><span class="s1">;</span>
	    <span class="s2">this</span><span class="s1">._isReRender = </span><span class="s2">false</span><span class="s1">;</span>
	    <span class="s2">this</span><span class="s1">._didScheduleRenderPhaseUpdate = </span><span class="s2">false</span><span class="s1">;</span>
	    <span class="s2">this</span><span class="s1">._renderPhaseUpdates = </span><span class="s2">null</span><span class="s1">;</span>
	    <span class="s2">this</span><span class="s1">._numberOfReRenders = </span><span class="s4">0</span><span class="s1">;</span>
	    <span class="s2">this</span><span class="s1">._idCounter = </span><span class="s4">0</span><span class="s1">;</span>
	  <span class="s1">};</span>

	  <span class="s1">_proto2._validateCurrentlyRenderingComponent = </span><span class="s2">function </span><span class="s1">_validateCurrentlyRenderingComponent() {</span>
	    <span class="s2">if </span><span class="s1">(!(</span><span class="s2">this</span><span class="s1">._rendering &amp;&amp; !</span><span class="s2">this</span><span class="s1">._instance)) {</span>
	      <span class="s2">throw </span><span class="s1">Error(</span><span class="s3">&quot;Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:</span><span class="s5">\n</span><span class="s3">1. You might have mismatching versions of React and the renderer (such as React DOM)</span><span class="s5">\n</span><span class="s3">2. You might be breaking the Rules of Hooks</span><span class="s5">\n</span><span class="s3">3. You might have more than one copy of React in the same app</span><span class="s5">\n</span><span class="s3">See https://fb.me/react-invalid-hook-call for tips about how to debug and fix this problem.&quot;</span><span class="s1">);</span>
	    <span class="s1">}</span>
	  <span class="s1">};</span>

	  <span class="s1">_proto2._createDispatcher = </span><span class="s2">function </span><span class="s1">_createDispatcher() {</span>
	    <span class="s2">var </span><span class="s1">_this = </span><span class="s2">this</span><span class="s1">;</span>

	    <span class="s2">var </span><span class="s1">useReducer = </span><span class="s2">function </span><span class="s1">useReducer(reducer, initialArg, init) {</span>
	      <span class="s1">_this._validateCurrentlyRenderingComponent();</span>

	      <span class="s1">_this._createWorkInProgressHook();</span>

	      <span class="s2">var </span><span class="s1">workInProgressHook = _this._workInProgressHook;</span>

	      <span class="s2">if </span><span class="s1">(_this._isReRender) {</span>
	        <span class="s0">// This is a re-render.</span>
	        <span class="s2">var </span><span class="s1">queue = workInProgressHook.queue;</span>
	        <span class="s2">var </span><span class="s1">dispatch = queue.dispatch;</span>

	        <span class="s2">if </span><span class="s1">(_this._numberOfReRenders &gt; </span><span class="s4">0</span><span class="s1">) {</span>
	          <span class="s0">// Apply the new render phase updates to the previous current hook.</span>
	          <span class="s2">if </span><span class="s1">(_this._renderPhaseUpdates !== </span><span class="s2">null</span><span class="s1">) {</span>
	            <span class="s0">// Render phase updates are stored in a map of queue -&gt; linked list</span>
	            <span class="s2">var </span><span class="s1">firstRenderPhaseUpdate = _this._renderPhaseUpdates.get(queue);</span>

	            <span class="s2">if </span><span class="s1">(firstRenderPhaseUpdate !== undefined) {</span>
	              <span class="s1">_this._renderPhaseUpdates.</span><span class="s2">delete</span><span class="s1">(queue);</span>

	              <span class="s2">var </span><span class="s1">_newState = workInProgressHook.memoizedState;</span>
	              <span class="s2">var </span><span class="s1">_update = firstRenderPhaseUpdate;</span>

	              <span class="s2">do </span><span class="s1">{</span>
	                <span class="s2">var </span><span class="s1">action = _update.action;</span>
	                <span class="s1">_newState = reducer(_newState, action);</span>
	                <span class="s1">_update = _update.next;</span>
	              <span class="s1">} </span><span class="s2">while </span><span class="s1">(_update !== </span><span class="s2">null</span><span class="s1">);</span>

	              <span class="s1">workInProgressHook.memoizedState = _newState;</span>
	              <span class="s2">return </span><span class="s1">[_newState, dispatch];</span>
	            <span class="s1">}</span>
	          <span class="s1">}</span>

	          <span class="s2">return </span><span class="s1">[workInProgressHook.memoizedState, dispatch];</span>
	        <span class="s1">} </span><span class="s0">// Process updates outside of render</span>


	        <span class="s2">var </span><span class="s1">newState = workInProgressHook.memoizedState;</span>
	        <span class="s2">var </span><span class="s1">update = queue.first;</span>

	        <span class="s2">if </span><span class="s1">(update !== </span><span class="s2">null</span><span class="s1">) {</span>
	          <span class="s2">do </span><span class="s1">{</span>
	            <span class="s2">var </span><span class="s1">_action = update.action;</span>
	            <span class="s1">newState = reducer(newState, _action);</span>
	            <span class="s1">update = update.next;</span>
	          <span class="s1">} </span><span class="s2">while </span><span class="s1">(update !== </span><span class="s2">null</span><span class="s1">);</span>

	          <span class="s1">queue.first = </span><span class="s2">null</span><span class="s1">;</span>
	          <span class="s1">workInProgressHook.memoizedState = newState;</span>
	        <span class="s1">}</span>

	        <span class="s2">return </span><span class="s1">[newState, dispatch];</span>
	      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
	        <span class="s2">var </span><span class="s1">initialState;</span>

	        <span class="s2">if </span><span class="s1">(reducer === basicStateReducer) {</span>
	          <span class="s0">// Special case for `useState`.</span>
	          <span class="s1">initialState = </span><span class="s2">typeof </span><span class="s1">initialArg === </span><span class="s3">'function' </span><span class="s1">? initialArg() : initialArg;</span>
	        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
	          <span class="s1">initialState = init !== undefined ? init(initialArg) : initialArg;</span>
	        <span class="s1">}</span>

	        <span class="s1">workInProgressHook.memoizedState = initialState;</span>

	        <span class="s2">var </span><span class="s1">_queue = workInProgressHook.queue = {</span>
	          <span class="s1">first: </span><span class="s2">null</span><span class="s1">,</span>
	          <span class="s1">dispatch: </span><span class="s2">null</span>
	        <span class="s1">};</span>

	        <span class="s2">var </span><span class="s1">_dispatch = _queue.dispatch = _this._dispatchAction.bind(_this, _queue);</span>

	        <span class="s2">return </span><span class="s1">[workInProgressHook.memoizedState, _dispatch];</span>
	      <span class="s1">}</span>
	    <span class="s1">};</span>

	    <span class="s2">var </span><span class="s1">useState = </span><span class="s2">function </span><span class="s1">useState(initialState) {</span>
	      <span class="s2">return </span><span class="s1">useReducer(basicStateReducer, </span><span class="s0">// useReducer has a special case to support lazy useState initializers</span>
	      <span class="s1">initialState);</span>
	    <span class="s1">};</span>

	    <span class="s2">var </span><span class="s1">useMemo = </span><span class="s2">function </span><span class="s1">useMemo(nextCreate, deps) {</span>
	      <span class="s1">_this._validateCurrentlyRenderingComponent();</span>

	      <span class="s1">_this._createWorkInProgressHook();</span>

	      <span class="s2">var </span><span class="s1">nextDeps = deps !== undefined ? deps : </span><span class="s2">null</span><span class="s1">;</span>

	      <span class="s2">if </span><span class="s1">(_this._workInProgressHook !== </span><span class="s2">null </span><span class="s1">&amp;&amp; _this._workInProgressHook.memoizedState !== </span><span class="s2">null</span><span class="s1">) {</span>
	        <span class="s2">var </span><span class="s1">prevState = _this._workInProgressHook.memoizedState;</span>
	        <span class="s2">var </span><span class="s1">prevDeps = prevState[</span><span class="s4">1</span><span class="s1">];</span>

	        <span class="s2">if </span><span class="s1">(nextDeps !== </span><span class="s2">null</span><span class="s1">) {</span>
	          <span class="s2">if </span><span class="s1">(areHookInputsEqual(nextDeps, prevDeps)) {</span>
	            <span class="s2">return </span><span class="s1">prevState[</span><span class="s4">0</span><span class="s1">];</span>
	          <span class="s1">}</span>
	        <span class="s1">}</span>
	      <span class="s1">}</span>

	      <span class="s2">var </span><span class="s1">nextValue = nextCreate();</span>
	      <span class="s1">_this._workInProgressHook.memoizedState = [nextValue, nextDeps];</span>
	      <span class="s2">return </span><span class="s1">nextValue;</span>
	    <span class="s1">};</span>

	    <span class="s2">var </span><span class="s1">useRef = </span><span class="s2">function </span><span class="s1">useRef(initialValue) {</span>
	      <span class="s1">_this._validateCurrentlyRenderingComponent();</span>

	      <span class="s1">_this._createWorkInProgressHook();</span>

	      <span class="s2">var </span><span class="s1">previousRef = _this._workInProgressHook.memoizedState;</span>

	      <span class="s2">if </span><span class="s1">(previousRef === </span><span class="s2">null</span><span class="s1">) {</span>
	        <span class="s2">var </span><span class="s1">ref = {</span>
	          <span class="s1">current: initialValue</span>
	        <span class="s1">};</span>

	        <span class="s1">{</span>
	          <span class="s1">Object.seal(ref);</span>
	        <span class="s1">}</span>

	        <span class="s1">_this._workInProgressHook.memoizedState = ref;</span>
	        <span class="s2">return </span><span class="s1">ref;</span>
	      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
	        <span class="s2">return </span><span class="s1">previousRef;</span>
	      <span class="s1">}</span>
	    <span class="s1">};</span>

	    <span class="s2">var </span><span class="s1">readContext = </span><span class="s2">function </span><span class="s1">readContext(context, observedBits) {</span>
	      <span class="s2">return </span><span class="s1">context._currentValue;</span>
	    <span class="s1">};</span>

	    <span class="s2">var </span><span class="s1">noOp = </span><span class="s2">function </span><span class="s1">noOp() {</span>
	      <span class="s1">_this._validateCurrentlyRenderingComponent();</span>
	    <span class="s1">};</span>

	    <span class="s2">var </span><span class="s1">identity = </span><span class="s2">function </span><span class="s1">identity(fn) {</span>
	      <span class="s2">return </span><span class="s1">fn;</span>
	    <span class="s1">};</span>

	    <span class="s2">var </span><span class="s1">useResponder = </span><span class="s2">function </span><span class="s1">useResponder(responder, props) {</span>
	      <span class="s2">return </span><span class="s1">{</span>
	        <span class="s1">props: props,</span>
	        <span class="s1">responder: responder</span>
	      <span class="s1">};</span>
	    <span class="s1">};</span>

	    <span class="s2">var </span><span class="s1">useTransition = </span><span class="s2">function </span><span class="s1">useTransition(config) {</span>
	      <span class="s1">_this._validateCurrentlyRenderingComponent();</span>

	      <span class="s2">var </span><span class="s1">startTransition = </span><span class="s2">function </span><span class="s1">startTransition(callback) {</span>
	        <span class="s1">callback();</span>
	      <span class="s1">};</span>

	      <span class="s2">return </span><span class="s1">[startTransition, </span><span class="s2">false</span><span class="s1">];</span>
	    <span class="s1">};</span>

	    <span class="s2">var </span><span class="s1">useDeferredValue = </span><span class="s2">function </span><span class="s1">useDeferredValue(value, config) {</span>
	      <span class="s1">_this._validateCurrentlyRenderingComponent();</span>

	      <span class="s2">return </span><span class="s1">value;</span>
	    <span class="s1">};</span>

	    <span class="s2">var </span><span class="s1">useId = </span><span class="s2">function </span><span class="s1">useId() {</span>
	      <span class="s1">_this._validateCurrentlyRenderingComponent();</span>

	      <span class="s2">var </span><span class="s1">nextId = ++_this._idCounter;</span>
	      <span class="s2">return </span><span class="s3">':r' </span><span class="s1">+ nextId + </span><span class="s3">':'</span><span class="s1">;</span>
	    <span class="s1">};</span>

	    <span class="s2">var </span><span class="s1">useSyncExternalStore = </span><span class="s2">function </span><span class="s1">useSyncExternalStore(subscribe, getSnapshot) {</span>
	      <span class="s1">_this._validateCurrentlyRenderingComponent();</span>

	      <span class="s2">return </span><span class="s1">getSnapshot();</span>
	    <span class="s1">};</span>

	    <span class="s2">return </span><span class="s1">{</span>
	      <span class="s1">readContext: readContext,</span>
	      <span class="s1">useCallback: identity,</span>
	      <span class="s1">useContext: </span><span class="s2">function </span><span class="s1">useContext(context) {</span>
	        <span class="s1">_this._validateCurrentlyRenderingComponent();</span>

	        <span class="s2">return </span><span class="s1">readContext(context);</span>
	      <span class="s1">},</span>
	      <span class="s1">useDebugValue: noOp,</span>
	      <span class="s1">useEffect: noOp,</span>
	      <span class="s1">useImperativeHandle: noOp,</span>
	      <span class="s1">useLayoutEffect: noOp,</span>
	      <span class="s1">useInsertionEffect: noOp,</span>
	      <span class="s1">useMemo: useMemo,</span>
	      <span class="s1">useReducer: useReducer,</span>
	      <span class="s1">useRef: useRef,</span>
	      <span class="s1">useState: useState,</span>
	      <span class="s1">useResponder: useResponder,</span>
	      <span class="s1">useId: useId,</span>
	      <span class="s1">useTransition: useTransition,</span>
	      <span class="s1">useDeferredValue: useDeferredValue,</span>
	      <span class="s1">useSyncExternalStore: useSyncExternalStore</span>
	    <span class="s1">};</span>
	  <span class="s1">};</span>

	  <span class="s1">_proto2._dispatchAction = </span><span class="s2">function </span><span class="s1">_dispatchAction(queue, action) {</span>
	    <span class="s2">if </span><span class="s1">(!(</span><span class="s2">this</span><span class="s1">._numberOfReRenders &lt; RE_RENDER_LIMIT)) {</span>
	      <span class="s2">throw </span><span class="s1">Error(</span><span class="s3">&quot;Too many re-renders. React limits the number of renders to prevent an infinite loop.&quot;</span><span class="s1">);</span>
	    <span class="s1">}</span>

	    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">._rendering) {</span>
	      <span class="s0">// This is a render phase update. Stash it in a lazily-created map of</span>
	      <span class="s0">// queue -&gt; linked list of updates. After this render pass, we'll restart</span>
	      <span class="s0">// and apply the stashed updates on top of the work-in-progress hook.</span>
	      <span class="s2">this</span><span class="s1">._didScheduleRenderPhaseUpdate = </span><span class="s2">true</span><span class="s1">;</span>
	      <span class="s2">var </span><span class="s1">update = {</span>
	        <span class="s1">action: action,</span>
	        <span class="s1">next: </span><span class="s2">null</span>
	      <span class="s1">};</span>
	      <span class="s2">var </span><span class="s1">renderPhaseUpdates = </span><span class="s2">this</span><span class="s1">._renderPhaseUpdates;</span>

	      <span class="s2">if </span><span class="s1">(renderPhaseUpdates === </span><span class="s2">null</span><span class="s1">) {</span>
	        <span class="s2">this</span><span class="s1">._renderPhaseUpdates = renderPhaseUpdates = </span><span class="s2">new </span><span class="s1">Map();</span>
	      <span class="s1">}</span>

	      <span class="s2">var </span><span class="s1">firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);</span>

	      <span class="s2">if </span><span class="s1">(firstRenderPhaseUpdate === undefined) {</span>
	        <span class="s1">renderPhaseUpdates.set(queue, update);</span>
	      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
	        <span class="s0">// Append the update to the end of the list.</span>
	        <span class="s2">var </span><span class="s1">lastRenderPhaseUpdate = firstRenderPhaseUpdate;</span>

	        <span class="s2">while </span><span class="s1">(lastRenderPhaseUpdate.next !== </span><span class="s2">null</span><span class="s1">) {</span>
	          <span class="s1">lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;</span>
	        <span class="s1">}</span>

	        <span class="s1">lastRenderPhaseUpdate.next = update;</span>
	      <span class="s1">}</span>
	    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
	      <span class="s2">var </span><span class="s1">_update2 = {</span>
	        <span class="s1">action: action,</span>
	        <span class="s1">next: </span><span class="s2">null</span>
	      <span class="s1">}; </span><span class="s0">// Append the update to the end of the list.</span>

	      <span class="s2">var </span><span class="s1">last = queue.first;</span>

	      <span class="s2">if </span><span class="s1">(last === </span><span class="s2">null</span><span class="s1">) {</span>
	        <span class="s1">queue.first = _update2;</span>
	      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
	        <span class="s2">while </span><span class="s1">(last.next !== </span><span class="s2">null</span><span class="s1">) {</span>
	          <span class="s1">last = last.next;</span>
	        <span class="s1">}</span>

	        <span class="s1">last.next = _update2;</span>
	      <span class="s1">} </span><span class="s0">// Re-render now.</span>


	      <span class="s2">this</span><span class="s1">.render(</span><span class="s2">this</span><span class="s1">._element, </span><span class="s2">this</span><span class="s1">._context);</span>
	    <span class="s1">}</span>
	  <span class="s1">};</span>

	  <span class="s1">_proto2._createWorkInProgressHook = </span><span class="s2">function </span><span class="s1">_createWorkInProgressHook() {</span>
	    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">._workInProgressHook === </span><span class="s2">null</span><span class="s1">) {</span>
	      <span class="s0">// This is the first hook in the list</span>
	      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">._firstWorkInProgressHook === </span><span class="s2">null</span><span class="s1">) {</span>
	        <span class="s2">this</span><span class="s1">._isReRender = </span><span class="s2">false</span><span class="s1">;</span>
	        <span class="s2">this</span><span class="s1">._firstWorkInProgressHook = </span><span class="s2">this</span><span class="s1">._workInProgressHook = createHook();</span>
	      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
	        <span class="s0">// There's already a work-in-progress. Reuse it.</span>
	        <span class="s2">this</span><span class="s1">._isReRender = </span><span class="s2">true</span><span class="s1">;</span>
	        <span class="s2">this</span><span class="s1">._workInProgressHook = </span><span class="s2">this</span><span class="s1">._firstWorkInProgressHook;</span>
	      <span class="s1">}</span>
	    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
	      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">._workInProgressHook.next === </span><span class="s2">null</span><span class="s1">) {</span>
	        <span class="s2">this</span><span class="s1">._isReRender = </span><span class="s2">false</span><span class="s1">; </span><span class="s0">// Append to the end of the list</span>

	        <span class="s2">this</span><span class="s1">._workInProgressHook = </span><span class="s2">this</span><span class="s1">._workInProgressHook.next = createHook();</span>
	      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
	        <span class="s0">// There's already a work-in-progress. Reuse it.</span>
	        <span class="s2">this</span><span class="s1">._isReRender = </span><span class="s2">true</span><span class="s1">;</span>
	        <span class="s2">this</span><span class="s1">._workInProgressHook = </span><span class="s2">this</span><span class="s1">._workInProgressHook.next;</span>
	      <span class="s1">}</span>
	    <span class="s1">}</span>

	    <span class="s2">return this</span><span class="s1">._workInProgressHook;</span>
	  <span class="s1">};</span>

	  <span class="s1">_proto2._finishHooks = </span><span class="s2">function </span><span class="s1">_finishHooks(element, context) {</span>
	    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">._didScheduleRenderPhaseUpdate) {</span>
	      <span class="s0">// Updates were scheduled during the render phase. They are stored in</span>
	      <span class="s0">// the `renderPhaseUpdates` map. Call the component again, reusing the</span>
	      <span class="s0">// work-in-progress hooks and applying the additional updates on top. Keep</span>
	      <span class="s0">// restarting until no more updates are scheduled.</span>
	      <span class="s2">this</span><span class="s1">._didScheduleRenderPhaseUpdate = </span><span class="s2">false</span><span class="s1">;</span>
	      <span class="s2">this</span><span class="s1">._numberOfReRenders += </span><span class="s4">1</span><span class="s1">; </span><span class="s0">// Start over from the beginning of the list</span>

	      <span class="s2">this</span><span class="s1">._workInProgressHook = </span><span class="s2">null</span><span class="s1">;</span>
	      <span class="s2">this</span><span class="s1">._rendering = </span><span class="s2">false</span><span class="s1">;</span>
	      <span class="s2">this</span><span class="s1">._idCounter = </span><span class="s4">0</span><span class="s1">;</span>
	      <span class="s2">this</span><span class="s1">.render(element, context);</span>
	    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
	      <span class="s2">this</span><span class="s1">._workInProgressHook = </span><span class="s2">null</span><span class="s1">;</span>
	      <span class="s2">this</span><span class="s1">._renderPhaseUpdates = </span><span class="s2">null</span><span class="s1">;</span>
	      <span class="s2">this</span><span class="s1">._numberOfReRenders = </span><span class="s4">0</span><span class="s1">;</span>
	      <span class="s2">this</span><span class="s1">._idCounter = </span><span class="s4">0</span><span class="s1">;</span>
	    <span class="s1">}</span>
	  <span class="s1">};</span>

	  <span class="s1">_proto2.getMountedInstance = </span><span class="s2">function </span><span class="s1">getMountedInstance() {</span>
	    <span class="s2">return this</span><span class="s1">._instance;</span>
	  <span class="s1">};</span>

	  <span class="s1">_proto2.getRenderOutput = </span><span class="s2">function </span><span class="s1">getRenderOutput() {</span>
	    <span class="s2">return this</span><span class="s1">._rendered;</span>
	  <span class="s1">};</span>

	  <span class="s1">_proto2.render = </span><span class="s2">function </span><span class="s1">render(element) {</span>
	    <span class="s2">var </span><span class="s1">context = arguments.length &gt; </span><span class="s4">1 </span><span class="s1">&amp;&amp; arguments[</span><span class="s4">1</span><span class="s1">] !== undefined ? arguments[</span><span class="s4">1</span><span class="s1">] : emptyObject;</span>

	    <span class="s2">if </span><span class="s1">(! </span><span class="s0">/*#__PURE__*/</span><span class="s1">React.isValidElement(element)) {</span>
	      <span class="s2">throw </span><span class="s1">Error(</span><span class="s3">&quot;ReactShallowRenderer render(): Invalid component element.&quot; </span><span class="s1">+ (</span><span class="s2">typeof </span><span class="s1">element === </span><span class="s3">'function' </span><span class="s1">? </span><span class="s3">' Instead of passing a component class, make sure to instantiate ' </span><span class="s1">+ </span><span class="s3">'it by passing it to React.createElement.' </span><span class="s1">: </span><span class="s3">''</span><span class="s1">));</span>
	    <span class="s1">} </span><span class="s0">// Show a special message for host elements since it's a common case.</span>


	    <span class="s2">if </span><span class="s1">(!(</span><span class="s2">typeof </span><span class="s1">element.type !== </span><span class="s3">'string'</span><span class="s1">)) {</span>
	      <span class="s2">throw </span><span class="s1">Error(</span><span class="s3">&quot;ReactShallowRenderer render(): Shallow rendering works only with custom components, not primitives (&quot; </span><span class="s1">+ element.type + </span><span class="s3">&quot;). Instead of calling `.render(el)` and inspecting the rendered output, look at `el.props` directly instead.&quot;</span><span class="s1">);</span>
	    <span class="s1">}</span>

	    <span class="s2">if </span><span class="s1">(!(reactIs_1(element) || </span><span class="s2">typeof </span><span class="s1">element.type === </span><span class="s3">'function' </span><span class="s1">|| reactIs_2(element))) {</span>
	      <span class="s2">throw </span><span class="s1">Error(</span><span class="s3">&quot;ReactShallowRenderer render(): Shallow rendering works only with custom components, but the provided element type was `&quot; </span><span class="s1">+ (Array.isArray(element.type) ? </span><span class="s3">'array' </span><span class="s1">: element.type === </span><span class="s2">null </span><span class="s1">? </span><span class="s3">'null' </span><span class="s1">: </span><span class="s2">typeof </span><span class="s1">element.type) + </span><span class="s3">&quot;`.&quot;</span><span class="s1">);</span>
	    <span class="s1">}</span>

	    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">._rendering) {</span>
	      <span class="s2">return</span><span class="s1">;</span>
	    <span class="s1">}</span>

	    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">._element != </span><span class="s2">null </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">._element.type !== element.type) {</span>
	      <span class="s2">this</span><span class="s1">._reset();</span>
	    <span class="s1">}</span>

	    <span class="s2">var </span><span class="s1">elementType = reactIs_2(element) ? element.type.type : element.type;</span>
	    <span class="s2">var </span><span class="s1">previousElement = </span><span class="s2">this</span><span class="s1">._element;</span>
	    <span class="s2">this</span><span class="s1">._rendering = </span><span class="s2">true</span><span class="s1">;</span>
	    <span class="s2">this</span><span class="s1">._element = element;</span>
	    <span class="s2">this</span><span class="s1">._context = getMaskedContext(elementType.contextTypes, context); </span><span class="s0">// Inner memo component props aren't currently validated in createElement.</span>

	    <span class="s2">var </span><span class="s1">prevGetStack;</span>

	    <span class="s1">{</span>
	      <span class="s1">prevGetStack = ReactDebugCurrentFrame.getCurrentStack;</span>
	      <span class="s1">ReactDebugCurrentFrame.getCurrentStack = getStackAddendum;</span>
	    <span class="s1">}</span>

	    <span class="s2">try </span><span class="s1">{</span>
	      <span class="s2">if </span><span class="s1">(reactIs_2(element) &amp;&amp; elementType.propTypes) {</span>
	        <span class="s1">currentlyValidatingElement = element;</span>
	        <span class="s1">checkPropTypes(elementType.propTypes, element.props, </span><span class="s3">'prop'</span><span class="s1">, getComponentName(elementType));</span>
	      <span class="s1">}</span>

	      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">._instance) {</span>
	        <span class="s2">this</span><span class="s1">._updateClassComponent(elementType, element, </span><span class="s2">this</span><span class="s1">._context);</span>
	      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
	        <span class="s2">if </span><span class="s1">(shouldConstruct(elementType)) {</span>
	          <span class="s2">this</span><span class="s1">._instance = </span><span class="s2">new </span><span class="s1">elementType(element.props, </span><span class="s2">this</span><span class="s1">._context, </span><span class="s2">this</span><span class="s1">._updater);</span>

	          <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">elementType.getDerivedStateFromProps === </span><span class="s3">'function'</span><span class="s1">) {</span>
	            <span class="s2">var </span><span class="s1">partialState = elementType.getDerivedStateFromProps.call(</span><span class="s2">null</span><span class="s1">, element.props, </span><span class="s2">this</span><span class="s1">._instance.state);</span>

	            <span class="s2">if </span><span class="s1">(partialState != </span><span class="s2">null</span><span class="s1">) {</span>
	              <span class="s2">this</span><span class="s1">._instance.state = objectAssign({}, </span><span class="s2">this</span><span class="s1">._instance.state, partialState);</span>
	            <span class="s1">}</span>
	          <span class="s1">}</span>

	          <span class="s2">if </span><span class="s1">(elementType.contextTypes) {</span>
	            <span class="s1">currentlyValidatingElement = element;</span>
	            <span class="s1">checkPropTypes(elementType.contextTypes, </span><span class="s2">this</span><span class="s1">._context, </span><span class="s3">'context'</span><span class="s1">, getName(elementType, </span><span class="s2">this</span><span class="s1">._instance));</span>
	            <span class="s1">currentlyValidatingElement = </span><span class="s2">null</span><span class="s1">;</span>
	          <span class="s1">}</span>

	          <span class="s2">this</span><span class="s1">._mountClassComponent(elementType, element, </span><span class="s2">this</span><span class="s1">._context);</span>
	        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
	          <span class="s2">var </span><span class="s1">shouldRender = </span><span class="s2">true</span><span class="s1">;</span>

	          <span class="s2">if </span><span class="s1">(reactIs_2(element) &amp;&amp; previousElement !== </span><span class="s2">null</span><span class="s1">) {</span>
	            <span class="s0">// This is a Memo component that is being re-rendered.</span>
	            <span class="s2">var </span><span class="s1">compare = element.type.compare || shallowEqual;</span>

	            <span class="s2">if </span><span class="s1">(compare(previousElement.props, element.props)) {</span>
	              <span class="s1">shouldRender = </span><span class="s2">false</span><span class="s1">;</span>
	            <span class="s1">}</span>
	          <span class="s1">}</span>

	          <span class="s2">if </span><span class="s1">(shouldRender) {</span>
	            <span class="s2">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher.current;</span>
	            <span class="s1">ReactCurrentDispatcher.current = </span><span class="s2">this</span><span class="s1">._dispatcher;</span>

	            <span class="s2">try </span><span class="s1">{</span>
	              <span class="s0">// elementType could still be a ForwardRef if it was</span>
	              <span class="s0">// nested inside Memo.</span>
	              <span class="s2">if </span><span class="s1">(elementType.$$typeof === reactIs_3) {</span>
	                <span class="s2">if </span><span class="s1">(!(</span><span class="s2">typeof </span><span class="s1">elementType.render === </span><span class="s3">'function'</span><span class="s1">)) {</span>
	                  <span class="s2">throw </span><span class="s1">Error(</span><span class="s3">&quot;forwardRef requires a render function but was given &quot; </span><span class="s1">+ </span><span class="s2">typeof </span><span class="s1">elementType.render + </span><span class="s3">&quot;.&quot;</span><span class="s1">);</span>
	                <span class="s1">}</span>

	                <span class="s2">this</span><span class="s1">._rendered = elementType.render.call(undefined, element.props, element.ref);</span>
	              <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
	                <span class="s2">this</span><span class="s1">._rendered = elementType(element.props, </span><span class="s2">this</span><span class="s1">._context);</span>
	              <span class="s1">}</span>
	            <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
	              <span class="s1">ReactCurrentDispatcher.current = prevDispatcher;</span>
	            <span class="s1">}</span>

	            <span class="s2">this</span><span class="s1">._finishHooks(element, context);</span>
	          <span class="s1">}</span>
	        <span class="s1">}</span>
	      <span class="s1">}</span>
	    <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
	      <span class="s1">{</span>
	        <span class="s1">ReactDebugCurrentFrame.getCurrentStack = prevGetStack;</span>
	      <span class="s1">}</span>
	    <span class="s1">}</span>

	    <span class="s2">this</span><span class="s1">._rendering = </span><span class="s2">false</span><span class="s1">;</span>

	    <span class="s2">this</span><span class="s1">._updater._invokeCallbacks();</span>

	    <span class="s2">return this</span><span class="s1">.getRenderOutput();</span>
	  <span class="s1">};</span>

	  <span class="s1">_proto2.unmount = </span><span class="s2">function </span><span class="s1">unmount() {</span>
	    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">._instance) {</span>
	      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof this</span><span class="s1">._instance.componentWillUnmount === </span><span class="s3">'function'</span><span class="s1">) {</span>
	        <span class="s2">this</span><span class="s1">._instance.componentWillUnmount();</span>
	      <span class="s1">}</span>
	    <span class="s1">}</span>

	    <span class="s2">this</span><span class="s1">._reset();</span>
	  <span class="s1">};</span>

	  <span class="s1">_proto2._mountClassComponent = </span><span class="s2">function </span><span class="s1">_mountClassComponent(elementType, element, context) {</span>
	    <span class="s2">this</span><span class="s1">._instance.context = context;</span>
	    <span class="s2">this</span><span class="s1">._instance.props = element.props;</span>
	    <span class="s2">this</span><span class="s1">._instance.state = </span><span class="s2">this</span><span class="s1">._instance.state || </span><span class="s2">null</span><span class="s1">;</span>
	    <span class="s2">this</span><span class="s1">._instance.updater = </span><span class="s2">this</span><span class="s1">._updater;</span>

	    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof this</span><span class="s1">._instance.UNSAFE_componentWillMount === </span><span class="s3">'function' </span><span class="s1">|| </span><span class="s2">typeof this</span><span class="s1">._instance.componentWillMount === </span><span class="s3">'function'</span><span class="s1">) {</span>
	      <span class="s2">var </span><span class="s1">beforeState = </span><span class="s2">this</span><span class="s1">._newState; </span><span class="s0">// In order to support react-lifecycles-compat polyfilled components,</span>
	      <span class="s0">// Unsafe lifecycles should not be invoked for components using the new APIs.</span>

	      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">elementType.getDerivedStateFromProps !== </span><span class="s3">'function' </span><span class="s1">&amp;&amp; </span><span class="s2">typeof this</span><span class="s1">._instance.getSnapshotBeforeUpdate !== </span><span class="s3">'function'</span><span class="s1">) {</span>
	        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof this</span><span class="s1">._instance.componentWillMount === </span><span class="s3">'function'</span><span class="s1">) {</span>
	          <span class="s2">this</span><span class="s1">._instance.componentWillMount();</span>
	        <span class="s1">}</span>

	        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof this</span><span class="s1">._instance.UNSAFE_componentWillMount === </span><span class="s3">'function'</span><span class="s1">) {</span>
	          <span class="s2">this</span><span class="s1">._instance.UNSAFE_componentWillMount();</span>
	        <span class="s1">}</span>
	      <span class="s1">} </span><span class="s0">// setState may have been called during cWM</span>


	      <span class="s2">if </span><span class="s1">(beforeState !== </span><span class="s2">this</span><span class="s1">._newState) {</span>
	        <span class="s2">this</span><span class="s1">._instance.state = </span><span class="s2">this</span><span class="s1">._newState || emptyObject;</span>
	      <span class="s1">}</span>
	    <span class="s1">}</span>

	    <span class="s2">this</span><span class="s1">._rendered = </span><span class="s2">this</span><span class="s1">._instance.render(); </span><span class="s0">// Intentionally do not call componentDidMount()</span>
	    <span class="s0">// because DOM refs are not available.</span>
	  <span class="s1">};</span>

	  <span class="s1">_proto2._updateClassComponent = </span><span class="s2">function </span><span class="s1">_updateClassComponent(elementType, element, context) {</span>
	    <span class="s2">var </span><span class="s1">props = element.props;</span>
	    <span class="s2">var </span><span class="s1">oldState = </span><span class="s2">this</span><span class="s1">._instance.state || emptyObject;</span>
	    <span class="s2">var </span><span class="s1">oldProps = </span><span class="s2">this</span><span class="s1">._instance.props;</span>

	    <span class="s2">if </span><span class="s1">(oldProps !== props) {</span>
	      <span class="s0">// In order to support react-lifecycles-compat polyfilled components,</span>
	      <span class="s0">// Unsafe lifecycles should not be invoked for components using the new APIs.</span>
	      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">elementType.getDerivedStateFromProps !== </span><span class="s3">'function' </span><span class="s1">&amp;&amp; </span><span class="s2">typeof this</span><span class="s1">._instance.getSnapshotBeforeUpdate !== </span><span class="s3">'function'</span><span class="s1">) {</span>
	        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof this</span><span class="s1">._instance.componentWillReceiveProps === </span><span class="s3">'function'</span><span class="s1">) {</span>
	          <span class="s2">this</span><span class="s1">._instance.componentWillReceiveProps(props, context);</span>
	        <span class="s1">}</span>

	        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof this</span><span class="s1">._instance.UNSAFE_componentWillReceiveProps === </span><span class="s3">'function'</span><span class="s1">) {</span>
	          <span class="s2">this</span><span class="s1">._instance.UNSAFE_componentWillReceiveProps(props, context);</span>
	        <span class="s1">}</span>
	      <span class="s1">}</span>
	    <span class="s1">} </span><span class="s0">// Read state after cWRP in case it calls setState</span>


	    <span class="s2">var </span><span class="s1">state = </span><span class="s2">this</span><span class="s1">._newState || oldState;</span>

	    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">elementType.getDerivedStateFromProps === </span><span class="s3">'function'</span><span class="s1">) {</span>
	      <span class="s2">var </span><span class="s1">partialState = elementType.getDerivedStateFromProps.call(</span><span class="s2">null</span><span class="s1">, props, state);</span>

	      <span class="s2">if </span><span class="s1">(partialState != </span><span class="s2">null</span><span class="s1">) {</span>
	        <span class="s1">state = objectAssign({}, state, partialState);</span>
	      <span class="s1">}</span>
	    <span class="s1">}</span>

	    <span class="s2">var </span><span class="s1">shouldUpdate = </span><span class="s2">true</span><span class="s1">;</span>

	    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">._forcedUpdate) {</span>
	      <span class="s1">shouldUpdate = </span><span class="s2">true</span><span class="s1">;</span>
	      <span class="s2">this</span><span class="s1">._forcedUpdate = </span><span class="s2">false</span><span class="s1">;</span>
	    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">typeof this</span><span class="s1">._instance.shouldComponentUpdate === </span><span class="s3">'function'</span><span class="s1">) {</span>
	      <span class="s1">shouldUpdate = !!</span><span class="s2">this</span><span class="s1">._instance.shouldComponentUpdate(props, state, context);</span>
	    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(elementType.prototype &amp;&amp; elementType.prototype.isPureReactComponent) {</span>
	      <span class="s1">shouldUpdate = !shallowEqual(oldProps, props) || !shallowEqual(oldState, state);</span>
	    <span class="s1">}</span>

	    <span class="s2">if </span><span class="s1">(shouldUpdate) {</span>
	      <span class="s0">// In order to support react-lifecycles-compat polyfilled components,</span>
	      <span class="s0">// Unsafe lifecycles should not be invoked for components using the new APIs.</span>
	      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">elementType.getDerivedStateFromProps !== </span><span class="s3">'function' </span><span class="s1">&amp;&amp; </span><span class="s2">typeof this</span><span class="s1">._instance.getSnapshotBeforeUpdate !== </span><span class="s3">'function'</span><span class="s1">) {</span>
	        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof this</span><span class="s1">._instance.componentWillUpdate === </span><span class="s3">'function'</span><span class="s1">) {</span>
	          <span class="s2">this</span><span class="s1">._instance.componentWillUpdate(props, state, context);</span>
	        <span class="s1">}</span>

	        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof this</span><span class="s1">._instance.UNSAFE_componentWillUpdate === </span><span class="s3">'function'</span><span class="s1">) {</span>
	          <span class="s2">this</span><span class="s1">._instance.UNSAFE_componentWillUpdate(props, state, context);</span>
	        <span class="s1">}</span>
	      <span class="s1">}</span>
	    <span class="s1">}</span>

	    <span class="s2">this</span><span class="s1">._instance.context = context;</span>
	    <span class="s2">this</span><span class="s1">._instance.props = props;</span>
	    <span class="s2">this</span><span class="s1">._instance.state = state;</span>
	    <span class="s2">this</span><span class="s1">._newState = </span><span class="s2">null</span><span class="s1">;</span>

	    <span class="s2">if </span><span class="s1">(shouldUpdate) {</span>
	      <span class="s2">this</span><span class="s1">._rendered = </span><span class="s2">this</span><span class="s1">._instance.render();</span>
	    <span class="s1">} </span><span class="s0">// Intentionally do not call componentDidUpdate()</span>
	    <span class="s0">// because DOM refs are not available.</span>

	  <span class="s1">};</span>

	  <span class="s2">return </span><span class="s1">ReactShallowRenderer;</span>
	<span class="s1">}();</span>

	<span class="s1">ReactShallowRenderer.createRenderer = </span><span class="s2">function </span><span class="s1">() {</span>
	  <span class="s2">return new </span><span class="s1">ReactShallowRenderer();</span>
	<span class="s1">};</span>

	<span class="s2">var </span><span class="s1">currentlyValidatingElement = </span><span class="s2">null</span><span class="s1">;</span>

	<span class="s2">function </span><span class="s1">getDisplayName(element) {</span>
	  <span class="s2">if </span><span class="s1">(element == </span><span class="s2">null</span><span class="s1">) {</span>
	    <span class="s2">return </span><span class="s3">'#empty'</span><span class="s1">;</span>
	  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">element === </span><span class="s3">'string' </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">element === </span><span class="s3">'number'</span><span class="s1">) {</span>
	    <span class="s2">return </span><span class="s3">'#text'</span><span class="s1">;</span>
	  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">element.type === </span><span class="s3">'string'</span><span class="s1">) {</span>
	    <span class="s2">return </span><span class="s1">element.type;</span>
	  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
	    <span class="s2">var </span><span class="s1">elementType = reactIs_2(element) ? element.type.type : element.type;</span>
	    <span class="s2">return </span><span class="s1">elementType.displayName || elementType.name || </span><span class="s3">'Unknown'</span><span class="s1">;</span>
	  <span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s2">function </span><span class="s1">getStackAddendum() {</span>
	  <span class="s2">var </span><span class="s1">stack = </span><span class="s3">''</span><span class="s1">;</span>

	  <span class="s2">if </span><span class="s1">(currentlyValidatingElement) {</span>
	    <span class="s2">var </span><span class="s1">name = getDisplayName(currentlyValidatingElement);</span>
	    <span class="s2">var </span><span class="s1">owner = currentlyValidatingElement._owner;</span>
	    <span class="s1">stack += describeComponentFrame(name, currentlyValidatingElement._source, owner &amp;&amp; getComponentName(owner.type));</span>
	  <span class="s1">}</span>

	  <span class="s2">return </span><span class="s1">stack;</span>
	<span class="s1">}</span>

	<span class="s2">function </span><span class="s1">getName(type, instance) {</span>
	  <span class="s2">var </span><span class="s1">constructor = instance &amp;&amp; instance.constructor;</span>
	  <span class="s2">return </span><span class="s1">type.displayName || constructor &amp;&amp; constructor.displayName || type.name || constructor &amp;&amp; constructor.name || </span><span class="s2">null</span><span class="s1">;</span>
	<span class="s1">}</span>

	<span class="s2">function </span><span class="s1">shouldConstruct(Component) {</span>
	  <span class="s2">return </span><span class="s1">!!(Component.prototype &amp;&amp; Component.prototype.isReactComponent);</span>
	<span class="s1">}</span>

	<span class="s2">function </span><span class="s1">getMaskedContext(contextTypes, unmaskedContext) {</span>
	  <span class="s2">if </span><span class="s1">(!contextTypes || !unmaskedContext) {</span>
	    <span class="s2">return </span><span class="s1">emptyObject;</span>
	  <span class="s1">}</span>

	  <span class="s2">var </span><span class="s1">context = {};</span>

	  <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">key </span><span class="s2">in </span><span class="s1">contextTypes) {</span>
	    <span class="s1">context[key] = unmaskedContext[key];</span>
	  <span class="s1">}</span>

	  <span class="s2">return </span><span class="s1">context;</span>
	<span class="s1">}</span>

	<span class="s2">return </span><span class="s1">ReactShallowRenderer;</span>

<span class="s1">})));</span>
</pre>
</body>
</html>
<html>
<head>
<title>decorator.h</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #bbb529;}
.s3 { color: #6a8759;}
.s4 { color: #cc7832;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
decorator.h</font>
</center></td></tr></table>
<pre><span class="s0">/* 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>

<span class="s2">#pragma </span><span class="s1">once</span>

<span class="s2">#include </span><span class="s3">&lt;tuple&gt;</span>

<span class="s2">#include </span><span class="s3">&lt;jsi/instrumentation.h&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;jsi/jsi.h&gt;</span>

<span class="s0">// This file contains objects to help API users create their own</span>
<span class="s0">// runtime adapters, i.e. if you want to compose runtimes to add your</span>
<span class="s0">// own behavior.</span>

<span class="s4">namespace </span><span class="s1">facebook {</span>
<span class="s4">namespace </span><span class="s1">jsi {</span>

<span class="s0">// Use this to wrap host functions. It will pass the member runtime as</span>
<span class="s0">// the first arg to the callback.  The first argument to the ctor</span>
<span class="s0">// should be the decorated runtime, not the plain one.</span>
<span class="s4">class </span><span class="s1">DecoratedHostFunction {</span>
 <span class="s4">public</span><span class="s1">:</span>
  <span class="s1">DecoratedHostFunction(Runtime&amp; drt</span><span class="s4">, </span><span class="s1">HostFunctionType plainHF)</span>
      <span class="s1">: drt_(drt)</span><span class="s4">, </span><span class="s1">plainHF_(std::move(plainHF)) {}</span>

  <span class="s1">Runtime&amp; decoratedRuntime() {</span>
    <span class="s4">return </span><span class="s1">drt_</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">Value</span>
  <span class="s4">operator</span><span class="s1">()(Runtime&amp;</span><span class="s4">, const </span><span class="s1">Value&amp; thisVal</span><span class="s4">, const </span><span class="s1">Value* args</span><span class="s4">, </span><span class="s1">size_t count) {</span>
    <span class="s4">return </span><span class="s1">plainHF_(decoratedRuntime()</span><span class="s4">, </span><span class="s1">thisVal</span><span class="s4">, </span><span class="s1">args</span><span class="s4">, </span><span class="s1">count)</span><span class="s4">;</span>
  <span class="s1">}</span>

 <span class="s4">private</span><span class="s1">:</span>
  <span class="s4">template </span><span class="s1">&lt;</span><span class="s4">typename </span><span class="s1">Plain</span><span class="s4">, typename </span><span class="s1">Base&gt;</span>
  <span class="s4">friend class </span><span class="s1">RuntimeDecorator</span><span class="s4">;</span>

  <span class="s1">Runtime&amp; drt_</span><span class="s4">;</span>
  <span class="s1">HostFunctionType plainHF_</span><span class="s4">;</span>
<span class="s1">}</span><span class="s4">;</span>

<span class="s0">// From the perspective of the caller, a plain HostObject is passed to</span>
<span class="s0">// the decorated Runtime, and the HostObject methods expect to get</span>
<span class="s0">// passed that Runtime.  But the plain Runtime will pass itself to its</span>
<span class="s0">// callback, so we need a helper here which curries the decorated</span>
<span class="s0">// Runtime, and calls the plain HostObject with it.</span>
<span class="s0">//</span>
<span class="s0">// If the concrete RuntimeDecorator derives DecoratedHostObject, it</span>
<span class="s0">// should call the base class get() and set() to invoke the plain</span>
<span class="s0">// HostObject functionality.  The Runtime&amp; it passes does not matter,</span>
<span class="s0">// as it is not used.</span>
<span class="s4">class </span><span class="s1">DecoratedHostObject : </span><span class="s4">public </span><span class="s1">HostObject {</span>
 <span class="s4">public</span><span class="s1">:</span>
  <span class="s1">DecoratedHostObject(Runtime&amp; drt</span><span class="s4">, </span><span class="s1">std::shared_ptr&lt;HostObject&gt; plainHO)</span>
      <span class="s1">: drt_(drt)</span><span class="s4">, </span><span class="s1">plainHO_(plainHO) {}</span>

  <span class="s0">// The derived class methods can call this to get a reference to the</span>
  <span class="s0">// decorated runtime, since the rt passed to the callback will be</span>
  <span class="s0">// the plain runtime.</span>
  <span class="s1">Runtime&amp; decoratedRuntime() {</span>
    <span class="s4">return </span><span class="s1">drt_</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">Value get(Runtime&amp;</span><span class="s4">, const </span><span class="s1">PropNameID&amp; name) override {</span>
    <span class="s4">return </span><span class="s1">plainHO_-&gt;get(decoratedRuntime()</span><span class="s4">, </span><span class="s1">name)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">void </span><span class="s1">set(Runtime&amp;</span><span class="s4">, const </span><span class="s1">PropNameID&amp; name</span><span class="s4">, const </span><span class="s1">Value&amp; value) override {</span>
    <span class="s1">plainHO_-&gt;set(decoratedRuntime()</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">value)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">std::vector&lt;PropNameID&gt; getPropertyNames(Runtime&amp;) override {</span>
    <span class="s4">return </span><span class="s1">plainHO_-&gt;getPropertyNames(decoratedRuntime())</span><span class="s4">;</span>
  <span class="s1">}</span>

 <span class="s4">private</span><span class="s1">:</span>
  <span class="s4">template </span><span class="s1">&lt;</span><span class="s4">typename </span><span class="s1">Plain</span><span class="s4">, typename </span><span class="s1">Base&gt;</span>
  <span class="s4">friend class </span><span class="s1">RuntimeDecorator</span><span class="s4">;</span>

  <span class="s1">Runtime&amp; drt_</span><span class="s4">;</span>
  <span class="s1">std::shared_ptr&lt;HostObject&gt; plainHO_</span><span class="s4">;</span>
<span class="s1">}</span><span class="s4">;</span>

<span class="s0">/// C++ variant on a standard Decorator pattern, using template</span>
<span class="s0">/// parameters.  The \c Plain template parameter type is the</span>
<span class="s0">/// undecorated Runtime type.  You can usually use \c Runtime here,</span>
<span class="s0">/// but if you know the concrete type ahead of time and it's final,</span>
<span class="s0">/// the compiler can devirtualize calls to the decorated</span>
<span class="s0">/// implementation.  The \c Base template parameter type will be used</span>
<span class="s0">/// as the base class of the decorated type.  Here, too, you can</span>
<span class="s0">/// usually use \c Runtime, but if you want the decorated type to</span>
<span class="s0">/// implement a derived class of Runtime, you can specify that here.</span>
<span class="s0">/// For an example, see threadsafe.h.</span>
<span class="s4">template </span><span class="s1">&lt;</span><span class="s4">typename </span><span class="s1">Plain = Runtime</span><span class="s4">, typename </span><span class="s1">Base = Runtime&gt;</span>
<span class="s4">class </span><span class="s1">RuntimeDecorator : </span><span class="s4">public </span><span class="s1">Base</span><span class="s4">, private </span><span class="s1">jsi::Instrumentation {</span>
 <span class="s4">public</span><span class="s1">:</span>
  <span class="s1">Plain&amp; plain() {</span>
    <span class="s4">static_assert</span><span class="s1">(</span>
        <span class="s1">std::is_base_of&lt;Runtime</span><span class="s4">, </span><span class="s1">Plain&gt;::value</span><span class="s4">,</span>
        <span class="s3">&quot;RuntimeDecorator's Plain type must derive from jsi::Runtime&quot;</span><span class="s1">)</span><span class="s4">;</span>
    <span class="s4">static_assert</span><span class="s1">(</span>
        <span class="s1">std::is_base_of&lt;Runtime</span><span class="s4">, </span><span class="s1">Base&gt;::value</span><span class="s4">,</span>
        <span class="s3">&quot;RuntimeDecorator's Base type must derive from jsi::Runtime&quot;</span><span class="s1">)</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">plain_</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">const </span><span class="s1">Plain&amp; plain() </span><span class="s4">const </span><span class="s1">{</span>
    <span class="s4">return </span><span class="s1">plain_</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">Value evaluateJavaScript(</span>
      <span class="s4">const </span><span class="s1">std::shared_ptr&lt;</span><span class="s4">const </span><span class="s1">Buffer&gt;&amp; buffer</span><span class="s4">,</span>
      <span class="s4">const </span><span class="s1">std::string&amp; sourceURL) override {</span>
    <span class="s4">return </span><span class="s1">plain().evaluateJavaScript(buffer</span><span class="s4">, </span><span class="s1">sourceURL)</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s1">std::shared_ptr&lt;</span><span class="s4">const </span><span class="s1">PreparedJavaScript&gt; prepareJavaScript(</span>
      <span class="s4">const </span><span class="s1">std::shared_ptr&lt;</span><span class="s4">const </span><span class="s1">Buffer&gt;&amp; buffer</span><span class="s4">,</span>
      <span class="s1">std::string sourceURL) override {</span>
    <span class="s4">return </span><span class="s1">plain().prepareJavaScript(buffer</span><span class="s4">, </span><span class="s1">std::move(sourceURL))</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s1">Value evaluatePreparedJavaScript(</span>
      <span class="s4">const </span><span class="s1">std::shared_ptr&lt;</span><span class="s4">const </span><span class="s1">PreparedJavaScript&gt;&amp; js) override {</span>
    <span class="s4">return </span><span class="s1">plain().evaluatePreparedJavaScript(js)</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">bool </span><span class="s1">drainMicrotasks(</span><span class="s4">int </span><span class="s1">maxMicrotasksHint) override {</span>
    <span class="s4">return </span><span class="s1">plain().drainMicrotasks(maxMicrotasksHint)</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s1">Object global() override {</span>
    <span class="s4">return </span><span class="s1">plain().global()</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s1">std::string description() override {</span>
    <span class="s4">return </span><span class="s1">plain().description()</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s4">bool </span><span class="s1">isInspectable() override {</span>
    <span class="s4">return </span><span class="s1">plain().isInspectable()</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s1">Instrumentation&amp; instrumentation() override {</span>
    <span class="s4">return </span><span class="s1">*</span><span class="s4">this;</span>
  <span class="s1">}</span>

 <span class="s4">protected</span><span class="s1">:</span>
  <span class="s0">// plain is generally going to be a reference to an object managed</span>
  <span class="s0">// by a derived class.  We cache it here so this class can be</span>
  <span class="s0">// concrete, and avoid making virtual calls to find the plain</span>
  <span class="s0">// Runtime.  Note that the ctor and dtor do not access through the</span>
  <span class="s0">// reference, so passing a reference to an object before its</span>
  <span class="s0">// lifetime has started is ok.</span>
  <span class="s1">RuntimeDecorator(Plain&amp; plain) : plain_(plain) {}</span>

  <span class="s1">Runtime::PointerValue* cloneSymbol(</span><span class="s4">const </span><span class="s1">Runtime::PointerValue* pv) override {</span>
    <span class="s4">return </span><span class="s1">plain_.cloneSymbol(pv)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s1">Runtime::PointerValue* cloneBigInt(</span><span class="s4">const </span><span class="s1">Runtime::PointerValue* pv) override {</span>
    <span class="s4">return </span><span class="s1">plain_.cloneBigInt(pv)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s1">Runtime::PointerValue* cloneString(</span><span class="s4">const </span><span class="s1">Runtime::PointerValue* pv) override {</span>
    <span class="s4">return </span><span class="s1">plain_.cloneString(pv)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s1">Runtime::PointerValue* cloneObject(</span><span class="s4">const </span><span class="s1">Runtime::PointerValue* pv) override {</span>
    <span class="s4">return </span><span class="s1">plain_.cloneObject(pv)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s1">Runtime::PointerValue* clonePropNameID(</span>
      <span class="s4">const </span><span class="s1">Runtime::PointerValue* pv) override {</span>
    <span class="s4">return </span><span class="s1">plain_.clonePropNameID(pv)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>

  <span class="s1">PropNameID createPropNameIDFromAscii(</span><span class="s4">const char</span><span class="s1">* str</span><span class="s4">, </span><span class="s1">size_t length)</span>
      <span class="s1">override {</span>
    <span class="s4">return </span><span class="s1">plain_.createPropNameIDFromAscii(str</span><span class="s4">, </span><span class="s1">length)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s1">PropNameID createPropNameIDFromUtf8(</span><span class="s4">const </span><span class="s1">uint8_t* utf8</span><span class="s4">, </span><span class="s1">size_t length)</span>
      <span class="s1">override {</span>
    <span class="s4">return </span><span class="s1">plain_.createPropNameIDFromUtf8(utf8</span><span class="s4">, </span><span class="s1">length)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s1">PropNameID createPropNameIDFromString(</span><span class="s4">const </span><span class="s1">String&amp; str) override {</span>
    <span class="s4">return </span><span class="s1">plain_.createPropNameIDFromString(str)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s1">PropNameID createPropNameIDFromSymbol(</span><span class="s4">const </span><span class="s1">Symbol&amp; sym) override {</span>
    <span class="s4">return </span><span class="s1">plain_.createPropNameIDFromSymbol(sym)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s1">std::string utf8(</span><span class="s4">const </span><span class="s1">PropNameID&amp; id) override {</span>
    <span class="s4">return </span><span class="s1">plain_.utf8(id)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s4">bool </span><span class="s1">compare(</span><span class="s4">const </span><span class="s1">PropNameID&amp; a</span><span class="s4">, const </span><span class="s1">PropNameID&amp; b) override {</span>
    <span class="s4">return </span><span class="s1">plain_.compare(a</span><span class="s4">, </span><span class="s1">b)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>

  <span class="s1">std::string symbolToString(</span><span class="s4">const </span><span class="s1">Symbol&amp; sym) override {</span>
    <span class="s4">return </span><span class="s1">plain_.symbolToString(sym)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">BigInt createBigIntFromInt64(int64_t value) override {</span>
    <span class="s4">return </span><span class="s1">plain_.createBigIntFromInt64(value)</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s1">BigInt createBigIntFromUint64(uint64_t value) override {</span>
    <span class="s4">return </span><span class="s1">plain_.createBigIntFromUint64(value)</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">bool </span><span class="s1">bigintIsInt64(</span><span class="s4">const </span><span class="s1">BigInt&amp; b) override {</span>
    <span class="s4">return </span><span class="s1">plain_.bigintIsInt64(b)</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">bool </span><span class="s1">bigintIsUint64(</span><span class="s4">const </span><span class="s1">BigInt&amp; b) override {</span>
    <span class="s4">return </span><span class="s1">plain_.bigintIsUint64(b)</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s1">uint64_t truncate(</span><span class="s4">const </span><span class="s1">BigInt&amp; b) override {</span>
    <span class="s4">return </span><span class="s1">plain_.truncate(b)</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s1">String bigintToString(</span><span class="s4">const </span><span class="s1">BigInt&amp; bigint</span><span class="s4">, int </span><span class="s1">radix) override {</span>
    <span class="s4">return </span><span class="s1">plain_.bigintToString(bigint</span><span class="s4">, </span><span class="s1">radix)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">String createStringFromAscii(</span><span class="s4">const char</span><span class="s1">* str</span><span class="s4">, </span><span class="s1">size_t length) override {</span>
    <span class="s4">return </span><span class="s1">plain_.createStringFromAscii(str</span><span class="s4">, </span><span class="s1">length)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s1">String createStringFromUtf8(</span><span class="s4">const </span><span class="s1">uint8_t* utf8</span><span class="s4">, </span><span class="s1">size_t length) override {</span>
    <span class="s4">return </span><span class="s1">plain_.createStringFromUtf8(utf8</span><span class="s4">, </span><span class="s1">length)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s1">std::string utf8(</span><span class="s4">const </span><span class="s1">String&amp; s) override {</span>
    <span class="s4">return </span><span class="s1">plain_.utf8(s)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">Object createObject() override {</span>
    <span class="s4">return </span><span class="s1">plain_.createObject()</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>

  <span class="s1">Object createObject(std::shared_ptr&lt;HostObject&gt; ho) override {</span>
    <span class="s4">return </span><span class="s1">plain_.createObject(</span>
        <span class="s1">std::make_shared&lt;DecoratedHostObject&gt;(*</span><span class="s4">this, </span><span class="s1">std::move(ho)))</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s1">std::shared_ptr&lt;HostObject&gt; getHostObject(</span><span class="s4">const </span><span class="s1">jsi::Object&amp; o) override {</span>
    <span class="s1">std::shared_ptr&lt;HostObject&gt; dho = plain_.getHostObject(o)</span><span class="s4">;</span>
    <span class="s4">return static_cast</span><span class="s1">&lt;DecoratedHostObject&amp;&gt;(*dho).plainHO_</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s1">HostFunctionType&amp; getHostFunction(</span><span class="s4">const </span><span class="s1">jsi::Function&amp; f) override {</span>
    <span class="s1">HostFunctionType&amp; dhf = plain_.getHostFunction(f)</span><span class="s4">;</span>
    <span class="s0">// This will fail if a cpp file including this header is not compiled</span>
    <span class="s0">// with RTTI.</span>
    <span class="s4">return </span><span class="s1">dhf.target&lt;DecoratedHostFunction&gt;()-&gt;plainHF_</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>

  <span class="s4">bool </span><span class="s1">hasNativeState(</span><span class="s4">const </span><span class="s1">Object&amp; o) override {</span>
    <span class="s4">return </span><span class="s1">plain_.hasNativeState(o)</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s1">std::shared_ptr&lt;NativeState&gt; getNativeState(</span><span class="s4">const </span><span class="s1">Object&amp; o) override {</span>
    <span class="s4">return </span><span class="s1">plain_.getNativeState(o)</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">void </span><span class="s1">setNativeState(</span><span class="s4">const </span><span class="s1">Object&amp; o</span><span class="s4">, </span><span class="s1">std::shared_ptr&lt;NativeState&gt; state)</span>
      <span class="s1">override {</span>
    <span class="s1">plain_.setNativeState(o</span><span class="s4">, </span><span class="s1">state)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">Value getProperty(</span><span class="s4">const </span><span class="s1">Object&amp; o</span><span class="s4">, const </span><span class="s1">PropNameID&amp; name) override {</span>
    <span class="s4">return </span><span class="s1">plain_.getProperty(o</span><span class="s4">, </span><span class="s1">name)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s1">Value getProperty(</span><span class="s4">const </span><span class="s1">Object&amp; o</span><span class="s4">, const </span><span class="s1">String&amp; name) override {</span>
    <span class="s4">return </span><span class="s1">plain_.getProperty(o</span><span class="s4">, </span><span class="s1">name)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s4">bool </span><span class="s1">hasProperty(</span><span class="s4">const </span><span class="s1">Object&amp; o</span><span class="s4">, const </span><span class="s1">PropNameID&amp; name) override {</span>
    <span class="s4">return </span><span class="s1">plain_.hasProperty(o</span><span class="s4">, </span><span class="s1">name)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s4">bool </span><span class="s1">hasProperty(</span><span class="s4">const </span><span class="s1">Object&amp; o</span><span class="s4">, const </span><span class="s1">String&amp; name) override {</span>
    <span class="s4">return </span><span class="s1">plain_.hasProperty(o</span><span class="s4">, </span><span class="s1">name)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s4">void </span><span class="s1">setPropertyValue(</span>
      <span class="s4">const </span><span class="s1">Object&amp; o</span><span class="s4">,</span>
      <span class="s4">const </span><span class="s1">PropNameID&amp; name</span><span class="s4">,</span>
      <span class="s4">const </span><span class="s1">Value&amp; value) override {</span>
    <span class="s1">plain_.setPropertyValue(o</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">value)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s4">void </span><span class="s1">setPropertyValue(</span><span class="s4">const </span><span class="s1">Object&amp; o</span><span class="s4">, const </span><span class="s1">String&amp; name</span><span class="s4">, const </span><span class="s1">Value&amp; value)</span>
      <span class="s1">override {</span>
    <span class="s1">plain_.setPropertyValue(o</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">value)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>

  <span class="s4">bool </span><span class="s1">isArray(</span><span class="s4">const </span><span class="s1">Object&amp; o) </span><span class="s4">const </span><span class="s1">override {</span>
    <span class="s4">return </span><span class="s1">plain_.isArray(o)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s4">bool </span><span class="s1">isArrayBuffer(</span><span class="s4">const </span><span class="s1">Object&amp; o) </span><span class="s4">const </span><span class="s1">override {</span>
    <span class="s4">return </span><span class="s1">plain_.isArrayBuffer(o)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s4">bool </span><span class="s1">isFunction(</span><span class="s4">const </span><span class="s1">Object&amp; o) </span><span class="s4">const </span><span class="s1">override {</span>
    <span class="s4">return </span><span class="s1">plain_.isFunction(o)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s4">bool </span><span class="s1">isHostObject(</span><span class="s4">const </span><span class="s1">jsi::Object&amp; o) </span><span class="s4">const </span><span class="s1">override {</span>
    <span class="s4">return </span><span class="s1">plain_.isHostObject(o)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s4">bool </span><span class="s1">isHostFunction(</span><span class="s4">const </span><span class="s1">jsi::Function&amp; f) </span><span class="s4">const </span><span class="s1">override {</span>
    <span class="s4">return </span><span class="s1">plain_.isHostFunction(f)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s1">Array getPropertyNames(</span><span class="s4">const </span><span class="s1">Object&amp; o) override {</span>
    <span class="s4">return </span><span class="s1">plain_.getPropertyNames(o)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>

  <span class="s1">WeakObject createWeakObject(</span><span class="s4">const </span><span class="s1">Object&amp; o) override {</span>
    <span class="s4">return </span><span class="s1">plain_.createWeakObject(o)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s1">Value lockWeakObject(</span><span class="s4">const </span><span class="s1">WeakObject&amp; wo) override {</span>
    <span class="s4">return </span><span class="s1">plain_.lockWeakObject(wo)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>

  <span class="s1">Array createArray(size_t length) override {</span>
    <span class="s4">return </span><span class="s1">plain_.createArray(length)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s1">ArrayBuffer createArrayBuffer(</span>
      <span class="s1">std::shared_ptr&lt;MutableBuffer&gt; buffer) override {</span>
    <span class="s4">return </span><span class="s1">plain_.createArrayBuffer(std::move(buffer))</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s1">size_t size(</span><span class="s4">const </span><span class="s1">Array&amp; a) override {</span>
    <span class="s4">return </span><span class="s1">plain_.size(a)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s1">size_t size(</span><span class="s4">const </span><span class="s1">ArrayBuffer&amp; ab) override {</span>
    <span class="s4">return </span><span class="s1">plain_.size(ab)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s1">uint8_t* data(</span><span class="s4">const </span><span class="s1">ArrayBuffer&amp; ab) override {</span>
    <span class="s4">return </span><span class="s1">plain_.data(ab)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s1">Value getValueAtIndex(</span><span class="s4">const </span><span class="s1">Array&amp; a</span><span class="s4">, </span><span class="s1">size_t i) override {</span>
    <span class="s4">return </span><span class="s1">plain_.getValueAtIndex(a</span><span class="s4">, </span><span class="s1">i)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s4">void </span><span class="s1">setValueAtIndexImpl(</span><span class="s4">const </span><span class="s1">Array&amp; a</span><span class="s4">, </span><span class="s1">size_t i</span><span class="s4">, const </span><span class="s1">Value&amp; value)</span>
      <span class="s1">override {</span>
    <span class="s1">plain_.setValueAtIndexImpl(a</span><span class="s4">, </span><span class="s1">i</span><span class="s4">, </span><span class="s1">value)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>

  <span class="s1">Function createFunctionFromHostFunction(</span>
      <span class="s4">const </span><span class="s1">PropNameID&amp; name</span><span class="s4">,</span>
      <span class="s4">unsigned int </span><span class="s1">paramCount</span><span class="s4">,</span>
      <span class="s1">HostFunctionType func) override {</span>
    <span class="s4">return </span><span class="s1">plain_.createFunctionFromHostFunction(</span>
        <span class="s1">name</span><span class="s4">, </span><span class="s1">paramCount</span><span class="s4">, </span><span class="s1">DecoratedHostFunction(*</span><span class="s4">this, </span><span class="s1">std::move(func)))</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s1">Value call(</span>
      <span class="s4">const </span><span class="s1">Function&amp; f</span><span class="s4">,</span>
      <span class="s4">const </span><span class="s1">Value&amp; jsThis</span><span class="s4">,</span>
      <span class="s4">const </span><span class="s1">Value* args</span><span class="s4">,</span>
      <span class="s1">size_t count) override {</span>
    <span class="s4">return </span><span class="s1">plain_.call(f</span><span class="s4">, </span><span class="s1">jsThis</span><span class="s4">, </span><span class="s1">args</span><span class="s4">, </span><span class="s1">count)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s1">Value callAsConstructor(</span><span class="s4">const </span><span class="s1">Function&amp; f</span><span class="s4">, const </span><span class="s1">Value* args</span><span class="s4">, </span><span class="s1">size_t count)</span>
      <span class="s1">override {</span>
    <span class="s4">return </span><span class="s1">plain_.callAsConstructor(f</span><span class="s4">, </span><span class="s1">args</span><span class="s4">, </span><span class="s1">count)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>

  <span class="s0">// Private data for managing scopes.</span>
  <span class="s1">Runtime::ScopeState* pushScope() override {</span>
    <span class="s4">return </span><span class="s1">plain_.pushScope()</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">void </span><span class="s1">popScope(Runtime::ScopeState* ss) override {</span>
    <span class="s1">plain_.popScope(ss)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">bool </span><span class="s1">strictEquals(</span><span class="s4">const </span><span class="s1">Symbol&amp; a</span><span class="s4">, const </span><span class="s1">Symbol&amp; b) </span><span class="s4">const </span><span class="s1">override {</span>
    <span class="s4">return </span><span class="s1">plain_.strictEquals(a</span><span class="s4">, </span><span class="s1">b)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s4">bool </span><span class="s1">strictEquals(</span><span class="s4">const </span><span class="s1">BigInt&amp; a</span><span class="s4">, const </span><span class="s1">BigInt&amp; b) </span><span class="s4">const </span><span class="s1">override {</span>
    <span class="s4">return </span><span class="s1">plain_.strictEquals(a</span><span class="s4">, </span><span class="s1">b)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s4">bool </span><span class="s1">strictEquals(</span><span class="s4">const </span><span class="s1">String&amp; a</span><span class="s4">, const </span><span class="s1">String&amp; b) </span><span class="s4">const </span><span class="s1">override {</span>
    <span class="s4">return </span><span class="s1">plain_.strictEquals(a</span><span class="s4">, </span><span class="s1">b)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s4">bool </span><span class="s1">strictEquals(</span><span class="s4">const </span><span class="s1">Object&amp; a</span><span class="s4">, const </span><span class="s1">Object&amp; b) </span><span class="s4">const </span><span class="s1">override {</span>
    <span class="s4">return </span><span class="s1">plain_.strictEquals(a</span><span class="s4">, </span><span class="s1">b)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>

  <span class="s4">bool </span><span class="s1">instanceOf(</span><span class="s4">const </span><span class="s1">Object&amp; o</span><span class="s4">, const </span><span class="s1">Function&amp; f) override {</span>
    <span class="s4">return </span><span class="s1">plain_.instanceOf(o</span><span class="s4">, </span><span class="s1">f)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>

  <span class="s0">// jsi::Instrumentation methods</span>

  <span class="s1">std::string getRecordedGCStats() override {</span>
    <span class="s4">return </span><span class="s1">plain().instrumentation().getRecordedGCStats()</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">std::unordered_map&lt;std::string</span><span class="s4">, </span><span class="s1">int64_t&gt; getHeapInfo(</span>
      <span class="s4">bool </span><span class="s1">includeExpensive) override {</span>
    <span class="s4">return </span><span class="s1">plain().instrumentation().getHeapInfo(includeExpensive)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">void </span><span class="s1">collectGarbage(std::string cause) override {</span>
    <span class="s1">plain().instrumentation().collectGarbage(std::move(cause))</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">void </span><span class="s1">startTrackingHeapObjectStackTraces(</span>
      <span class="s1">std::function&lt;</span><span class="s4">void</span><span class="s1">(</span>
          <span class="s1">uint64_t</span><span class="s4">,</span>
          <span class="s1">std::chrono::microseconds</span><span class="s4">,</span>
          <span class="s1">std::vector&lt;HeapStatsUpdate&gt;)&gt; callback) override {</span>
    <span class="s1">plain().instrumentation().startTrackingHeapObjectStackTraces(</span>
        <span class="s1">std::move(callback))</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">void </span><span class="s1">stopTrackingHeapObjectStackTraces() override {</span>
    <span class="s1">plain().instrumentation().stopTrackingHeapObjectStackTraces()</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">void </span><span class="s1">startHeapSampling(size_t samplingInterval) override {</span>
    <span class="s1">plain().instrumentation().startHeapSampling(samplingInterval)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">void </span><span class="s1">stopHeapSampling(std::ostream&amp; os) override {</span>
    <span class="s1">plain().instrumentation().stopHeapSampling(os)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">void </span><span class="s1">createSnapshotToFile(</span><span class="s4">const </span><span class="s1">std::string&amp; path) override {</span>
    <span class="s1">plain().instrumentation().createSnapshotToFile(path)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">void </span><span class="s1">createSnapshotToStream(std::ostream&amp; os) override {</span>
    <span class="s1">plain().instrumentation().createSnapshotToStream(os)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">std::string flushAndDisableBridgeTrafficTrace() override {</span>
    <span class="s4">return const_cast</span><span class="s1">&lt;Plain&amp;&gt;(plain())</span>
        <span class="s1">.instrumentation()</span>
        <span class="s1">.flushAndDisableBridgeTrafficTrace()</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">void </span><span class="s1">writeBasicBlockProfileTraceToFile(</span>
      <span class="s4">const </span><span class="s1">std::string&amp; fileName) </span><span class="s4">const </span><span class="s1">override {</span>
    <span class="s4">const_cast</span><span class="s1">&lt;Plain&amp;&gt;(plain())</span>
        <span class="s1">.instrumentation()</span>
        <span class="s1">.writeBasicBlockProfileTraceToFile(fileName)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">/// Dump external profiler symbols to the given file name.</span>
  <span class="s4">void </span><span class="s1">dumpProfilerSymbolsToFile(</span><span class="s4">const </span><span class="s1">std::string&amp; fileName) </span><span class="s4">const </span><span class="s1">override {</span>
    <span class="s4">const_cast</span><span class="s1">&lt;Plain&amp;&gt;(plain()).instrumentation().dumpProfilerSymbolsToFile(</span>
        <span class="s1">fileName)</span><span class="s4">;</span>
  <span class="s1">}</span>

 <span class="s4">private</span><span class="s1">:</span>
  <span class="s1">Plain&amp; plain_</span><span class="s4">;</span>
<span class="s1">}</span><span class="s4">;</span>

<span class="s4">namespace </span><span class="s1">detail {</span>

<span class="s0">// This metaprogramming allows the With type's methods to be</span>
<span class="s0">// optional.</span>

<span class="s4">template </span><span class="s1">&lt;</span><span class="s4">typename </span><span class="s1">T</span><span class="s4">, typename </span><span class="s1">U = </span><span class="s4">void</span><span class="s1">&gt;</span>
<span class="s4">struct </span><span class="s1">BeforeCaller {</span>
  <span class="s4">static void </span><span class="s1">before(T&amp;) {}</span>
<span class="s1">}</span><span class="s4">;</span>

<span class="s4">template </span><span class="s1">&lt;</span><span class="s4">typename </span><span class="s1">T</span><span class="s4">, typename </span><span class="s1">U = </span><span class="s4">void</span><span class="s1">&gt;</span>
<span class="s4">struct </span><span class="s1">AfterCaller {</span>
  <span class="s4">static void </span><span class="s1">after(T&amp;) {}</span>
<span class="s1">}</span><span class="s4">;</span>

<span class="s0">// decltype((void)&amp;...) is either SFINAE, or void.</span>
<span class="s0">// So, if SFINAE does not happen for T, then this specialization exists</span>
<span class="s0">// for BeforeCaller&lt;T, void&gt;, and always applies.  If not, only the</span>
<span class="s0">// default above exists, and that is used instead.</span>
<span class="s4">template </span><span class="s1">&lt;</span><span class="s4">typename </span><span class="s1">T&gt;</span>
<span class="s4">struct </span><span class="s1">BeforeCaller&lt;T</span><span class="s4">, decltype</span><span class="s1">((</span><span class="s4">void</span><span class="s1">)&amp;T::before)&gt; {</span>
  <span class="s4">static void </span><span class="s1">before(T&amp; t) {</span>
    <span class="s1">t.before()</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s4">;</span>

<span class="s4">template </span><span class="s1">&lt;</span><span class="s4">typename </span><span class="s1">T&gt;</span>
<span class="s4">struct </span><span class="s1">AfterCaller&lt;T</span><span class="s4">, decltype</span><span class="s1">((</span><span class="s4">void</span><span class="s1">)&amp;T::after)&gt; {</span>
  <span class="s4">static void </span><span class="s1">after(T&amp; t) {</span>
    <span class="s1">t.after()</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s4">;</span>

<span class="s0">// It's possible to use multiple decorators by nesting</span>
<span class="s0">// WithRuntimeDecorator&lt;...&gt;, but this specialization allows use of</span>
<span class="s0">// std::tuple of decorator classes instead.  See testlib.cpp for an</span>
<span class="s0">// example.</span>
<span class="s4">template </span><span class="s1">&lt;</span><span class="s4">typename</span><span class="s1">... T&gt;</span>
<span class="s4">struct </span><span class="s1">BeforeCaller&lt;std::tuple&lt;T...&gt;&gt; {</span>
  <span class="s4">static void </span><span class="s1">before(std::tuple&lt;T...&gt;&amp; tuple) {</span>
    <span class="s1">all_before&lt;</span><span class="s5">0</span><span class="s4">, </span><span class="s1">T...&gt;(tuple)</span><span class="s4">;</span>
  <span class="s1">}</span>

 <span class="s4">private</span><span class="s1">:</span>
  <span class="s4">template </span><span class="s1">&lt;size_t N</span><span class="s4">, typename </span><span class="s1">U</span><span class="s4">, typename</span><span class="s1">... Rest&gt;</span>
  <span class="s4">static void </span><span class="s1">all_before(std::tuple&lt;T...&gt;&amp; tuple) {</span>
    <span class="s1">detail::BeforeCaller&lt;U&gt;::before(std::get&lt;N&gt;(tuple))</span><span class="s4">;</span>
    <span class="s1">all_before&lt;N + </span><span class="s5">1</span><span class="s4">, </span><span class="s1">Rest...&gt;(tuple)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">template </span><span class="s1">&lt;size_t N&gt;</span>
  <span class="s4">static void </span><span class="s1">all_before(std::tuple&lt;T...&gt;&amp;) {}</span>
<span class="s1">}</span><span class="s4">;</span>

<span class="s4">template </span><span class="s1">&lt;</span><span class="s4">typename</span><span class="s1">... T&gt;</span>
<span class="s4">struct </span><span class="s1">AfterCaller&lt;std::tuple&lt;T...&gt;&gt; {</span>
  <span class="s4">static void </span><span class="s1">after(std::tuple&lt;T...&gt;&amp; tuple) {</span>
    <span class="s1">all_after&lt;</span><span class="s5">0</span><span class="s4">, </span><span class="s1">T...&gt;(tuple)</span><span class="s4">;</span>
  <span class="s1">}</span>

 <span class="s4">private</span><span class="s1">:</span>
  <span class="s4">template </span><span class="s1">&lt;size_t N</span><span class="s4">, typename </span><span class="s1">U</span><span class="s4">, typename</span><span class="s1">... Rest&gt;</span>
  <span class="s4">static void </span><span class="s1">all_after(std::tuple&lt;T...&gt;&amp; tuple) {</span>
    <span class="s1">all_after&lt;N + </span><span class="s5">1</span><span class="s4">, </span><span class="s1">Rest...&gt;(tuple)</span><span class="s4">;</span>
    <span class="s1">detail::AfterCaller&lt;U&gt;::after(std::get&lt;N&gt;(tuple))</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">template </span><span class="s1">&lt;size_t N&gt;</span>
  <span class="s4">static void </span><span class="s1">all_after(std::tuple&lt;T...&gt;&amp;) {}</span>
<span class="s1">}</span><span class="s4">;</span>

<span class="s1">} </span><span class="s0">// namespace detail</span>

<span class="s0">// A decorator which implements an around idiom.  A With instance is</span>
<span class="s0">// RAII constructed before each call to the undecorated class; the</span>
<span class="s0">// ctor is passed a single argument of type WithArg&amp;.  Plain and Base</span>
<span class="s0">// are used as in the base class.</span>
<span class="s4">template </span><span class="s1">&lt;</span><span class="s4">typename </span><span class="s1">With</span><span class="s4">, typename </span><span class="s1">Plain = Runtime</span><span class="s4">, typename </span><span class="s1">Base = Runtime&gt;</span>
<span class="s4">class </span><span class="s1">WithRuntimeDecorator : </span><span class="s4">public </span><span class="s1">RuntimeDecorator&lt;Plain</span><span class="s4">, </span><span class="s1">Base&gt; {</span>
 <span class="s4">public</span><span class="s1">:</span>
  <span class="s4">using </span><span class="s1">RD = RuntimeDecorator&lt;Plain</span><span class="s4">, </span><span class="s1">Base&gt;</span><span class="s4">;</span>

  <span class="s0">// The reference arguments to the ctor are stored, but not used by</span>
  <span class="s0">// the ctor, and there is no ctor, so they can be passed members of</span>
  <span class="s0">// the derived class.</span>
  <span class="s1">WithRuntimeDecorator(Plain&amp; plain</span><span class="s4">, </span><span class="s1">With&amp; with) : RD(plain)</span><span class="s4">, </span><span class="s1">with_(with) {}</span>

  <span class="s1">Value evaluateJavaScript(</span>
      <span class="s4">const </span><span class="s1">std::shared_ptr&lt;</span><span class="s4">const </span><span class="s1">Buffer&gt;&amp; buffer</span><span class="s4">,</span>
      <span class="s4">const </span><span class="s1">std::string&amp; sourceURL) override {</span>
    <span class="s1">Around around{with_}</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">RD::evaluateJavaScript(buffer</span><span class="s4">, </span><span class="s1">sourceURL)</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s1">std::shared_ptr&lt;</span><span class="s4">const </span><span class="s1">PreparedJavaScript&gt; prepareJavaScript(</span>
      <span class="s4">const </span><span class="s1">std::shared_ptr&lt;</span><span class="s4">const </span><span class="s1">Buffer&gt;&amp; buffer</span><span class="s4">,</span>
      <span class="s1">std::string sourceURL) override {</span>
    <span class="s1">Around around{with_}</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">RD::prepareJavaScript(buffer</span><span class="s4">, </span><span class="s1">std::move(sourceURL))</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s1">Value evaluatePreparedJavaScript(</span>
      <span class="s4">const </span><span class="s1">std::shared_ptr&lt;</span><span class="s4">const </span><span class="s1">PreparedJavaScript&gt;&amp; js) override {</span>
    <span class="s1">Around around{with_}</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">RD::evaluatePreparedJavaScript(js)</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">bool </span><span class="s1">drainMicrotasks(</span><span class="s4">int </span><span class="s1">maxMicrotasksHint) override {</span>
    <span class="s1">Around around{with_}</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">RD::drainMicrotasks(maxMicrotasksHint)</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s1">Object global() override {</span>
    <span class="s1">Around around{with_}</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">RD::global()</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s1">std::string description() override {</span>
    <span class="s1">Around around{with_}</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">RD::description()</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s4">bool </span><span class="s1">isInspectable() override {</span>
    <span class="s1">Around around{with_}</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">RD::isInspectable()</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>

  <span class="s0">// The jsi:: prefix is necessary because MSVC compiler complains C2247:</span>
  <span class="s0">// Instrumentation is not accessible because RuntimeDecorator uses private</span>
  <span class="s0">// to inherit from Instrumentation.</span>
  <span class="s0">// TODO(T40821815) Consider removing this workaround when updating MSVC</span>
  <span class="s1">jsi::Instrumentation&amp; instrumentation() override {</span>
    <span class="s1">Around around{with_}</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">RD::instrumentation()</span><span class="s4">;</span>
  <span class="s1">}</span>

 <span class="s4">protected</span><span class="s1">:</span>
  <span class="s1">Runtime::PointerValue* cloneSymbol(</span><span class="s4">const </span><span class="s1">Runtime::PointerValue* pv) override {</span>
    <span class="s1">Around around{with_}</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">RD::cloneSymbol(pv)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s1">Runtime::PointerValue* cloneString(</span><span class="s4">const </span><span class="s1">Runtime::PointerValue* pv) override {</span>
    <span class="s1">Around around{with_}</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">RD::cloneString(pv)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s1">Runtime::PointerValue* cloneObject(</span><span class="s4">const </span><span class="s1">Runtime::PointerValue* pv) override {</span>
    <span class="s1">Around around{with_}</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">RD::cloneObject(pv)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s1">Runtime::PointerValue* clonePropNameID(</span>
      <span class="s4">const </span><span class="s1">Runtime::PointerValue* pv) override {</span>
    <span class="s1">Around around{with_}</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">RD::clonePropNameID(pv)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>

  <span class="s1">PropNameID createPropNameIDFromAscii(</span><span class="s4">const char</span><span class="s1">* str</span><span class="s4">, </span><span class="s1">size_t length)</span>
      <span class="s1">override {</span>
    <span class="s1">Around around{with_}</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">RD::createPropNameIDFromAscii(str</span><span class="s4">, </span><span class="s1">length)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s1">PropNameID createPropNameIDFromUtf8(</span><span class="s4">const </span><span class="s1">uint8_t* utf8</span><span class="s4">, </span><span class="s1">size_t length)</span>
      <span class="s1">override {</span>
    <span class="s1">Around around{with_}</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">RD::createPropNameIDFromUtf8(utf8</span><span class="s4">, </span><span class="s1">length)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s1">PropNameID createPropNameIDFromString(</span><span class="s4">const </span><span class="s1">String&amp; str) override {</span>
    <span class="s1">Around around{with_}</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">RD::createPropNameIDFromString(str)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s1">std::string utf8(</span><span class="s4">const </span><span class="s1">PropNameID&amp; id) override {</span>
    <span class="s1">Around around{with_}</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">RD::utf8(id)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s4">bool </span><span class="s1">compare(</span><span class="s4">const </span><span class="s1">PropNameID&amp; a</span><span class="s4">, const </span><span class="s1">PropNameID&amp; b) override {</span>
    <span class="s1">Around around{with_}</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">RD::compare(a</span><span class="s4">, </span><span class="s1">b)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>

  <span class="s1">std::string symbolToString(</span><span class="s4">const </span><span class="s1">Symbol&amp; sym) override {</span>
    <span class="s1">Around around{with_}</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">RD::symbolToString(sym)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>

  <span class="s1">String createStringFromAscii(</span><span class="s4">const char</span><span class="s1">* str</span><span class="s4">, </span><span class="s1">size_t length) override {</span>
    <span class="s1">Around around{with_}</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">RD::createStringFromAscii(str</span><span class="s4">, </span><span class="s1">length)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s1">String createStringFromUtf8(</span><span class="s4">const </span><span class="s1">uint8_t* utf8</span><span class="s4">, </span><span class="s1">size_t length) override {</span>
    <span class="s1">Around around{with_}</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">RD::createStringFromUtf8(utf8</span><span class="s4">, </span><span class="s1">length)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s1">std::string utf8(</span><span class="s4">const </span><span class="s1">String&amp; s) override {</span>
    <span class="s1">Around around{with_}</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">RD::utf8(s)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">Object createObject() override {</span>
    <span class="s1">Around around{with_}</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">RD::createObject()</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s1">Object createObject(std::shared_ptr&lt;HostObject&gt; ho) override {</span>
    <span class="s1">Around around{with_}</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">RD::createObject(std::move(ho))</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s1">std::shared_ptr&lt;HostObject&gt; getHostObject(</span><span class="s4">const </span><span class="s1">jsi::Object&amp; o) override {</span>
    <span class="s1">Around around{with_}</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">RD::getHostObject(o)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s1">HostFunctionType&amp; getHostFunction(</span><span class="s4">const </span><span class="s1">jsi::Function&amp; f) override {</span>
    <span class="s1">Around around{with_}</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">RD::getHostFunction(f)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>

  <span class="s1">Value getProperty(</span><span class="s4">const </span><span class="s1">Object&amp; o</span><span class="s4">, const </span><span class="s1">PropNameID&amp; name) override {</span>
    <span class="s1">Around around{with_}</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">RD::getProperty(o</span><span class="s4">, </span><span class="s1">name)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s1">Value getProperty(</span><span class="s4">const </span><span class="s1">Object&amp; o</span><span class="s4">, const </span><span class="s1">String&amp; name) override {</span>
    <span class="s1">Around around{with_}</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">RD::getProperty(o</span><span class="s4">, </span><span class="s1">name)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s4">bool </span><span class="s1">hasProperty(</span><span class="s4">const </span><span class="s1">Object&amp; o</span><span class="s4">, const </span><span class="s1">PropNameID&amp; name) override {</span>
    <span class="s1">Around around{with_}</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">RD::hasProperty(o</span><span class="s4">, </span><span class="s1">name)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s4">bool </span><span class="s1">hasProperty(</span><span class="s4">const </span><span class="s1">Object&amp; o</span><span class="s4">, const </span><span class="s1">String&amp; name) override {</span>
    <span class="s1">Around around{with_}</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">RD::hasProperty(o</span><span class="s4">, </span><span class="s1">name)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s4">void </span><span class="s1">setPropertyValue(</span>
      <span class="s4">const </span><span class="s1">Object&amp; o</span><span class="s4">,</span>
      <span class="s4">const </span><span class="s1">PropNameID&amp; name</span><span class="s4">,</span>
      <span class="s4">const </span><span class="s1">Value&amp; value) override {</span>
    <span class="s1">Around around{with_}</span><span class="s4">;</span>
    <span class="s1">RD::setPropertyValue(o</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">value)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s4">void </span><span class="s1">setPropertyValue(</span><span class="s4">const </span><span class="s1">Object&amp; o</span><span class="s4">, const </span><span class="s1">String&amp; name</span><span class="s4">, const </span><span class="s1">Value&amp; value)</span>
      <span class="s1">override {</span>
    <span class="s1">Around around{with_}</span><span class="s4">;</span>
    <span class="s1">RD::setPropertyValue(o</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">value)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>

  <span class="s4">bool </span><span class="s1">isArray(</span><span class="s4">const </span><span class="s1">Object&amp; o) </span><span class="s4">const </span><span class="s1">override {</span>
    <span class="s1">Around around{with_}</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">RD::isArray(o)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s4">bool </span><span class="s1">isArrayBuffer(</span><span class="s4">const </span><span class="s1">Object&amp; o) </span><span class="s4">const </span><span class="s1">override {</span>
    <span class="s1">Around around{with_}</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">RD::isArrayBuffer(o)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s4">bool </span><span class="s1">isFunction(</span><span class="s4">const </span><span class="s1">Object&amp; o) </span><span class="s4">const </span><span class="s1">override {</span>
    <span class="s1">Around around{with_}</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">RD::isFunction(o)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s4">bool </span><span class="s1">isHostObject(</span><span class="s4">const </span><span class="s1">jsi::Object&amp; o) </span><span class="s4">const </span><span class="s1">override {</span>
    <span class="s1">Around around{with_}</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">RD::isHostObject(o)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s4">bool </span><span class="s1">isHostFunction(</span><span class="s4">const </span><span class="s1">jsi::Function&amp; f) </span><span class="s4">const </span><span class="s1">override {</span>
    <span class="s1">Around around{with_}</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">RD::isHostFunction(f)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s1">Array getPropertyNames(</span><span class="s4">const </span><span class="s1">Object&amp; o) override {</span>
    <span class="s1">Around around{with_}</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">RD::getPropertyNames(o)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>

  <span class="s1">WeakObject createWeakObject(</span><span class="s4">const </span><span class="s1">Object&amp; o) override {</span>
    <span class="s1">Around around{with_}</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">RD::createWeakObject(o)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s1">Value lockWeakObject(</span><span class="s4">const </span><span class="s1">WeakObject&amp; wo) override {</span>
    <span class="s1">Around around{with_}</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">RD::lockWeakObject(wo)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>

  <span class="s1">Array createArray(size_t length) override {</span>
    <span class="s1">Around around{with_}</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">RD::createArray(length)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s1">ArrayBuffer createArrayBuffer(</span>
      <span class="s1">std::shared_ptr&lt;MutableBuffer&gt; buffer) override {</span>
    <span class="s4">return </span><span class="s1">RD::createArrayBuffer(std::move(buffer))</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s1">size_t size(</span><span class="s4">const </span><span class="s1">Array&amp; a) override {</span>
    <span class="s1">Around around{with_}</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">RD::size(a)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s1">size_t size(</span><span class="s4">const </span><span class="s1">ArrayBuffer&amp; ab) override {</span>
    <span class="s1">Around around{with_}</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">RD::size(ab)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s1">uint8_t* data(</span><span class="s4">const </span><span class="s1">ArrayBuffer&amp; ab) override {</span>
    <span class="s1">Around around{with_}</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">RD::data(ab)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s1">Value getValueAtIndex(</span><span class="s4">const </span><span class="s1">Array&amp; a</span><span class="s4">, </span><span class="s1">size_t i) override {</span>
    <span class="s1">Around around{with_}</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">RD::getValueAtIndex(a</span><span class="s4">, </span><span class="s1">i)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s4">void </span><span class="s1">setValueAtIndexImpl(</span><span class="s4">const </span><span class="s1">Array&amp; a</span><span class="s4">, </span><span class="s1">size_t i</span><span class="s4">, const </span><span class="s1">Value&amp; value)</span>
      <span class="s1">override {</span>
    <span class="s1">Around around{with_}</span><span class="s4">;</span>
    <span class="s1">RD::setValueAtIndexImpl(a</span><span class="s4">, </span><span class="s1">i</span><span class="s4">, </span><span class="s1">value)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>

  <span class="s1">Function createFunctionFromHostFunction(</span>
      <span class="s4">const </span><span class="s1">PropNameID&amp; name</span><span class="s4">,</span>
      <span class="s4">unsigned int </span><span class="s1">paramCount</span><span class="s4">,</span>
      <span class="s1">HostFunctionType func) override {</span>
    <span class="s1">Around around{with_}</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">RD::createFunctionFromHostFunction(</span>
        <span class="s1">name</span><span class="s4">, </span><span class="s1">paramCount</span><span class="s4">, </span><span class="s1">std::move(func))</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s1">Value call(</span>
      <span class="s4">const </span><span class="s1">Function&amp; f</span><span class="s4">,</span>
      <span class="s4">const </span><span class="s1">Value&amp; jsThis</span><span class="s4">,</span>
      <span class="s4">const </span><span class="s1">Value* args</span><span class="s4">,</span>
      <span class="s1">size_t count) override {</span>
    <span class="s1">Around around{with_}</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">RD::call(f</span><span class="s4">, </span><span class="s1">jsThis</span><span class="s4">, </span><span class="s1">args</span><span class="s4">, </span><span class="s1">count)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s1">Value callAsConstructor(</span><span class="s4">const </span><span class="s1">Function&amp; f</span><span class="s4">, const </span><span class="s1">Value* args</span><span class="s4">, </span><span class="s1">size_t count)</span>
      <span class="s1">override {</span>
    <span class="s1">Around around{with_}</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">RD::callAsConstructor(f</span><span class="s4">, </span><span class="s1">args</span><span class="s4">, </span><span class="s1">count)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>

  <span class="s0">// Private data for managing scopes.</span>
  <span class="s1">Runtime::ScopeState* pushScope() override {</span>
    <span class="s1">Around around{with_}</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">RD::pushScope()</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">void </span><span class="s1">popScope(Runtime::ScopeState* ss) override {</span>
    <span class="s1">Around around{with_}</span><span class="s4">;</span>
    <span class="s1">RD::popScope(ss)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">bool </span><span class="s1">strictEquals(</span><span class="s4">const </span><span class="s1">Symbol&amp; a</span><span class="s4">, const </span><span class="s1">Symbol&amp; b) </span><span class="s4">const </span><span class="s1">override {</span>
    <span class="s1">Around around{with_}</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">RD::strictEquals(a</span><span class="s4">, </span><span class="s1">b)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s4">bool </span><span class="s1">strictEquals(</span><span class="s4">const </span><span class="s1">String&amp; a</span><span class="s4">, const </span><span class="s1">String&amp; b) </span><span class="s4">const </span><span class="s1">override {</span>
    <span class="s1">Around around{with_}</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">RD::strictEquals(a</span><span class="s4">, </span><span class="s1">b)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s4">bool </span><span class="s1">strictEquals(</span><span class="s4">const </span><span class="s1">Object&amp; a</span><span class="s4">, const </span><span class="s1">Object&amp; b) </span><span class="s4">const </span><span class="s1">override {</span>
    <span class="s1">Around around{with_}</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">RD::strictEquals(a</span><span class="s4">, </span><span class="s1">b)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>

  <span class="s4">bool </span><span class="s1">instanceOf(</span><span class="s4">const </span><span class="s1">Object&amp; o</span><span class="s4">, const </span><span class="s1">Function&amp; f) override {</span>
    <span class="s1">Around around{with_}</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">RD::instanceOf(o</span><span class="s4">, </span><span class="s1">f)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>

 <span class="s4">private</span><span class="s1">:</span>
  <span class="s0">// Wrap an RAII type around With&amp; to guarantee after always happens.</span>
  <span class="s4">struct </span><span class="s1">Around {</span>
    <span class="s1">Around(With&amp; with) : with_(with) {</span>
      <span class="s1">detail::BeforeCaller&lt;With&gt;::before(with_)</span><span class="s4">;</span>
    <span class="s1">}</span>
    <span class="s1">~Around() {</span>
      <span class="s1">detail::AfterCaller&lt;With&gt;::after(with_)</span><span class="s4">;</span>
    <span class="s1">}</span>

    <span class="s1">With&amp; with_</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>

  <span class="s1">With&amp; with_</span><span class="s4">;</span>
<span class="s1">}</span><span class="s4">;</span>

<span class="s1">} </span><span class="s0">// namespace jsi</span>
<span class="s1">} </span><span class="s0">// namespace facebook</span>
</pre>
</body>
</html>